

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="最近接触的项目涉及到动捕和动画，以前接触的范围主要是GamePlay以及C++和蓝图的交互，很少接触动画，借此机会学习一下UE5的动画系统。">
<meta property="og:type" content="article">
<meta property="og:title" content="【UE5】动画系统">
<meta property="og:url" content="http://example.com/2023/01/31/%E3%80%90UE5%E3%80%91%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="最近接触的项目涉及到动捕和动画，以前接触的范围主要是GamePlay以及C++和蓝图的交互，很少接触动画，借此机会学习一下UE5的动画系统。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311955651.png">
<meta property="article:published_time" content="2023-01-30T16:00:00.000Z">
<meta property="article:modified_time" content="2025-12-23T14:33:38.094Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="UE5">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311955651.png">
  
  
  
  <title>【UE5】动画系统 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Goulandis</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/Page.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="【UE5】动画系统"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-01-31 00:00" pubdate>
          2023年01月31日
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          28k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          232 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">【UE5】动画系统</h1>
            
            
              <div class="markdown-body">
                
                <meta name="referrer" content="no-referrer" />

<p>最近接触的项目涉及到动捕和动画，以前接触的范围主要是GamePlay以及C++和蓝图的交互，很少接触动画，借此机会学习一下UE5的动画系统。</p>
<span id="more"></span>

<p>首先把整个动画系统的框架了解一下。</p>
<p>参考博客：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/62401630">奶帆</a>、<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/SkeletalMeshAnimation/Skeleton/">骨架资源</a>、<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.27/zh-CN/AnimatingObjects/SkeletalMeshAnimation/Persona/SkeletonTree/">骨架树</a>、<a target="_blank" rel="noopener" href="https://papalqi.cn/2020/ue4%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">papalqi</a>、<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/462945444">郭袁</a>、<a target="_blank" rel="noopener" href="https://stefanperales.com/blog/dynamic-ik-retargeting-in-ue5/">Stefan Perales</a></p>
<!--more-->

<h1 id="一、动画系统的框架"><a href="#一、动画系统的框架" class="headerlink" title="一、动画系统的框架"></a>一、动画系统的框架</h1><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs scss">graph <span class="hljs-selector-tag">TD</span><br><span class="hljs-built_in">D1</span>(AimOffset)--&gt;<span class="hljs-built_in">C2</span>(BlendSpace);<br><span class="hljs-built_in">D2</span>(AnimationMontage)--&gt;<span class="hljs-built_in">C3</span>(AnimationCompostie);<br><span class="hljs-built_in">C1</span>(PhysicsAsset)--&gt;<span class="hljs-built_in">B1</span>(SkeletalMesh);<br><span class="hljs-built_in">C2</span>(BlendSpace)--&gt;<span class="hljs-built_in">B2</span>(AnimationSequence);<br><span class="hljs-built_in">C3</span>(AnimationCompostie)--&gt;<span class="hljs-built_in">B2</span>(AnimationSequence);<br><span class="hljs-built_in">B1</span>(SkeletalMesh)--&gt;<span class="hljs-built_in">A1</span>(Skeleton);<br><span class="hljs-built_in">B2</span>(AnimationSequence)--&gt;<span class="hljs-built_in">A1</span>(Skeleton);<br><span class="hljs-built_in">D2</span>(AnimationMontage)--&gt;<span class="hljs-built_in">B2</span>(AnimationSequence);<br>graph <span class="hljs-selector-tag">TD</span><br><span class="hljs-selector-tag">A</span>(AnimationBlueprint);<br><span class="hljs-built_in">D</span>(AnimInstance);<br>graph <span class="hljs-selector-tag">TD</span><br><span class="hljs-selector-tag">A</span>(PoseAsset)<br><span class="hljs-selector-tag">B</span>(ControlRig)<br><span class="hljs-built_in">C</span>(Animation State Machie)<br></code></pre></td></tr></table></figure>

<p>我们自上而下，从左往右看：</p>
<h2 id="1-AimOffset"><a href="#1-AimOffset" class="headerlink" title="1.AimOffset"></a>1.AimOffset</h2><p>AimOffset在UE4中的直译是目标偏移，用于对主体动画的混合叠加，多用于射击瞄准，如在吃鸡游戏中人物持枪瞄准时根据视角不同可以向上瞄准和对地瞄准和左右侧身瞄准。Epic不愧是做射击游戏起家的，AimOffset在UE中使用的图标都是一个人持枪的样子。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311954153.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311954153.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h2 id="2-AnimationMotage"><a href="#2-AnimationMotage" class="headerlink" title="2.AnimationMotage"></a>2.AnimationMotage</h2><p>AnimationMotage直译为动画蒙太奇，Motage在影视剪辑中是一种剪辑手法，通过将一系列视点不同的镜头组合起来的一种手法，感觉UE也是沿用这种解释，将不同而又有关联的多个动画组合起来构成一个完整的动画，这个完整的动画就是AnimationMotage。如一个攻击技能动画可以由拔刀动画+向上跳起动画+向目标砸下动画+收刀动画组成。这几个动画就可以由一个AnimationMotage组合在一起。AnimationMotage可以便于AnimationBlueprint更好的控制动画。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311954901.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311954901.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h2 id="3-PhysicsAsset"><a href="#3-PhysicsAsset" class="headerlink" title="3.PhysicsAsset"></a>3.PhysicsAsset</h2><p>PhysicsAsset—物理资产，官方给的定义是</p>
<blockquote>
<p>物理资产用于定义骨架网格体使用的物理和碰撞。它们包含一组刚体和约束，这些构成一个布偶，而布偶并不 局限于人形布偶。它们可以用于任何使用形体和约束的物理模拟。因为一个骨架网格体只允许一个物理资产， 所以可以为许多骨架网格体打开或关闭它们。</p>
</blockquote>
<p>我们在打开动画相关的资产的时候一般都能看到物理资产。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311955262.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311955262.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h2 id="4-BlendSpace"><a href="#4-BlendSpace" class="headerlink" title="4.BlendSpace"></a>4.BlendSpace</h2><p>BlendSpace—混合空间，BlendSpace是用于根据输入的float值在两个动画进行融合采样然后输出融合后的动画的工具，如两个动画一个是向前走一个是向左走，两个动画就可以通过输入的float值在混合空间进行混合，然后输出从前到左这个扇形方向任何一个方向运行的动画。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311955533.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311955533.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h2 id="5-AnimationCompostie"><a href="#5-AnimationCompostie" class="headerlink" title="5.AnimationCompostie"></a>5.AnimationCompostie</h2><p>AnimationCompostie—动画合成，按照<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.27/zh-CN/AnimatingObjects/SkeletalMeshAnimation/AnimationComposite/">官方的解释</a>就是</p>
<blockquote>
<p>动画合成作为一种将多个动画组合在一起将它们作为单个单元进行处理的方法。在某些情况下，你可能会遇到这样的情况：你需要将多个动画序列拼接在一起，这样就可以将它们当作一个序列而不是多个序列来使用。这正是 动画合成 的目的。动画合成是一种动画资产，专门设计用于允许你将多个动画组合在一起以作为单个单元进行处理。但是，请注意合成只是追加动画；它不提供任何混合能力。</p>
</blockquote>
<h2 id="6-SkeletalMesh"><a href="#6-SkeletalMesh" class="headerlink" title="6.SkeletalMesh"></a>6.SkeletalMesh</h2><p>SkeletalMesh—骨骼模型，绑定了骨骼之后的网格体，也是角色实际应用mesh。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311955619.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311955619.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h2 id="7-AnimationSequence"><a href="#7-AnimationSequence" class="headerlink" title="7.AnimationSequence"></a>7.AnimationSequence</h2><p>AnimationSequence—动画序列，帧动画的一种，官方给的定义是</p>
<blockquote>
<p><strong>动画序列（AnimationSequence）</strong> 是一个可以在骨架网格体上播放的独立的动画资源。它们包含了一些关键帧，这些关键帧可以及时地指出某个特定点处的一个骨骼的位置、旋转度及缩放比例。通过回放序列中的这些关键帧，并在将它们互相混合，使得骨架网格体可以产生平滑的动画效果。</p>
<p>每个 <em>动画序列</em> 资源指向一个特定的骨架，且仅可以在那个骨架上进行播放。这意味着，为了在多个骨架网格物体间共享动画，所有网格物体都必须使用同样的骨架资源。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311955370.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311955370.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h2 id="8-Skeleton"><a href="#8-Skeleton" class="headerlink" title="8.Skeleton"></a>8.Skeleton</h2><p>Skeleton—骨骼，骨骼是整个动画的系统的基础，任何动画都要在骨骼的基础上进行创作，只要人物应用的骨骼保持一致，同一个动画就可以在不同的人物上应用。</p>
<p>官方定义是</p>
<blockquote>
<p>如果您熟悉数字内容创建，那么对”骨架”的概念应该有所了解。 在多数3D应用程序中，骨架通常是一个数字层级架构，用于定义角色中的骨骼或关节，并以诸多方式模仿真实的生物骨架。 在虚幻引擎4中，一个重要的区别是骨架资源将 <strong>关联动画数据</strong>，而并非只是骨架网格体中的骨骼层级。 在UE4中，骨架资源将把骨骼（关节）数据关联到动画轨迹，从而驱动动画。</p>
</blockquote>
<h2 id="9-AnimationBlueprint"><a href="#9-AnimationBlueprint" class="headerlink" title="9.AnimationBlueprint"></a>9.AnimationBlueprint</h2><p>AnimationBlueprint—动画蓝图，动画蓝图是UE专门用来控制动画的专用蓝图，用于将各种动画的混合，叠加，控制，更新以及状态等进行程序化控制，然后输出最终的动画到角色身上。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311955511.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311955511.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h2 id="10-各个资产之间的关系"><a href="#10-各个资产之间的关系" class="headerlink" title="10.各个资产之间的关系"></a>10.各个资产之间的关系</h2><p>我们以一个发球动作为例。</p>
<p>可以把整个骨骼(Skeleton)是整个动画系统的基础，存储着一些最基础的数据，决定了一个角色可以做什么样的动作；</p>
<p>骨骼模型(SkeletalMesh)是依附于骨骼之上的血肉，决定角色动画的外型形象；物理资产(PhysicsAsset)是依附于骨骼之上的物理碰撞体，是动画之间物理碰撞；</p>
<p>动画序列(AnimationSequence)是一段一段的动作片段，如起步做东，冲刺动作，抬脚动作、踢出动作；</p>
<p>混合空间(BlendSpace)和目标偏移(AimOffset)都是为动作片段优化动作的，混合空间为各个动画片段添加变化，如踢出动作可以混合出偏内侧踢和偏外侧踢，目标偏移为指定动画增加优化动作，如起步动作的屈膝优化；</p>
<p>动画融合(AnimationCompostie)是对整体动作的优化，可以将一个一个的动画片段进行截取组合，组合成一个完整的新动作，如一个个动作片段可能会有一些多余的小动作，动画融合就可以把这些小动作清理掉并把截取出来的动作并接成一个简洁的动作，可以将整个发球动作融合成助跑和射球两个动画融合，也可以直接融合成一整个完整的发球动作；</p>
<p>动画蒙太奇(AniamtionMotage)则是对整个动画的整合控制，可以直接整合一个个的动画片段，也可以整合组合过的动画融合，让后对整个动画提供参数控制，相当于给骨骼肌肉发送动作指令的神经系统；</p>
<p>动画蓝图(AnimationBlueprint)为整个动画系统提供程序逻辑控制的能力，是整个动作控制的大脑，控制着动作的一举一动，当然在一个做动作的过程中动画蓝图不是必须，就如我们做一些动作是可以直接通过肌肉记忆做出动作而无需过大脑。</p>
<h1 id="二、骨骼"><a href="#二、骨骼" class="headerlink" title="二、骨骼"></a>二、骨骼</h1><p>骨骼存储着一些最基础的信息，如：</p>
<ul>
<li>骨骼层级信息；</li>
<li>参考姿势信息；</li>
<li>骨骼的名称；</li>
<li>插槽信息；</li>
<li>曲线信息；</li>
<li>动画通知信息；</li>
<li>插槽数据；</li>
<li>虚拟骨骼信息；</li>
<li>骨骼映射表；</li>
<li>重定位信息；</li>
<li>各个骨骼之间的约束信息。</li>
</ul>
<h2 id="1-骨骼的创建"><a href="#1-骨骼的创建" class="headerlink" title="1.骨骼的创建"></a>1.骨骼的创建</h2><p>骨骼的创建一般都发生在导入模型资产到UE的过程中由UE根据导入的骨骼模型和骨骼设置自动创建，同时UE也提供根据已有的骨骼模型来创建一个新的骨骼资产，UE在创建出新的骨骼资产后会把动画资源重新关联到新的骨骼资产上。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311955360.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311955360.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h2 id="2-骨骼树"><a href="#2-骨骼树" class="headerlink" title="2.骨骼树"></a>2.骨骼树</h2><p>我们打开骨骼资产编辑器，在左侧就能看到一列密密麻麻的树型骨骼结构，这里我做一些简单的了解。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311955919.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311955919.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>我们可以在骨骼资产编辑器中渲染视图的Character&#x2F;Bones下勾选Bone Names和All Hierachy将所有骨骼和骨骼名称显示出出来。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311955651.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311955651.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<ul>
<li><p>root：整个树结构的根是root节点，按照规范root节点所在的位置就是人物在地面的中心；</p>
</li>
<li><p>pelvis：直译为盆骨，是整个躯干骨骼的根节点，动画通过这个节点来控制整个身体的运动，pelvis直接从root节点连接到盆骨位置处；</p>
</li>
<li><p>ik_foot_root和ik_hand_root：这两个节点就是上图中从root节点延申到脚和手的骨骼，是用于脚部和手部的IK动画的节点，这里暂时先不讨论；</p>
</li>
<li><p>spine_01-spine_03：是三节脊椎骨，从下往上依次嵌套，覆盖腹部、腰部和胸部，动画通过这三个节点来控制上半身的动作；</p>
</li>
<li><p>clavicle_l和clavicle_r：左右锁骨，是手部骨骼的根节点，控制着整个手臂的动作；</p>
</li>
<li><p>upperarm_l和upperarm_r：左右肩膀的骨骼；</p>
</li>
<li><p>lowerarm_l和lowerarm_r：左右臂的骨骼；</p>
</li>
<li><p>hand_l和hand_r：手腕的骨骼，手腕再往下就是手指骨骼了；</p>
</li>
<li><p>neck_01：颈部骨骼，动画通过这个节点来控制头部的动作；</p>
</li>
<li><p>head：头部骨骼，用于继续往上延申出控制眼睛动作的骨骼，控制嘴巴动作的骨骼和头发动作的骨骼；如：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311956284.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311956284.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
</li>
<li><p>thigh_l和thigh_r：盆骨外下的跨部的骨骼，是整个腿部骨骼的根节点，控制整个腿部的动作。</p>
</li>
<li><p>calf_l和calf_r：大腿骨骼；</p>
</li>
<li><p>foot_l和foot_r：小腿骨骼；</p>
</li>
<li><p>ball_l和ball_r：脚掌的骨骼；</p>
</li>
</ul>
<p>每个根骨骼都有一个根节点，也就是图中骨骼根部的球状部位，骨骼之间通过根节点进行约束，出了root节点，每根骨骼节点都会存储相对于父节点的变换矩阵，通过变化矩阵动画系统就可以从根节点的运动计算出其下所有子节点的相对运动。</p>
<h2 id="3-骨骼动画驱动骨骼和模型"><a href="#3-骨骼动画驱动骨骼和模型" class="headerlink" title="3.骨骼动画驱动骨骼和模型"></a>3.骨骼动画驱动骨骼和模型</h2><p>所谓骨骼动画其实就是一系列的骨骼移动旋转的关键帧信息，动画系统通过每帧读取这些关键帧信息来控制骨骼做对应移动旋转动作，然后骨骼再驱动绑定在骨骼上的模型的点来控制模型跟随骨骼运动，这个过程是一些列复杂空间坐标转换，最终输出人物在世界坐标中的动画效果。</p>
<h2 id="4-骨骼插槽"><a href="#4-骨骼插槽" class="headerlink" title="4.骨骼插槽"></a>4.骨骼插槽</h2><p>骨骼插槽就是字面的意思，附着在骨骼上的插槽，可以用于在骨骼的指定位置添加对象，如在手上添加武器，在头上添加帽子等。</p>
<h3 id="添加插槽"><a href="#添加插槽" class="headerlink" title="添加插槽"></a>添加插槽</h3><p>在骨骼树下右键指定的骨骼选择Add Socket可以在指定骨骼下添加插槽，一个骨骼下可以添加多个插槽。插槽会记录下自己相对与骨骼的Transform信息，当对象绑定到插槽时会将Transform信息应用到对象上。</p>
<h3 id="在编辑器中绑定插槽"><a href="#在编辑器中绑定插槽" class="headerlink" title="在编辑器中绑定插槽"></a>在编辑器中绑定插槽</h3><p>静态绑定就是直接在编辑器中进行绑定，我们为Character添加一个StaticMesh并给与一个球体模型，然后在Details&#x2F;Sockets下就可以选择组件要绑定的骨骼插槽了。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311956681.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311956681.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>选了骨骼插槽后StaticMesh就会应用骨骼插槽记录的Transform信息，自动修改相对位置和相对缩放。</p>
<h3 id="蓝图动态绑定插槽"><a href="#蓝图动态绑定插槽" class="headerlink" title="蓝图动态绑定插槽"></a>蓝图动态绑定插槽</h3><p>我们以一个人物跳起时头顶发生爆炸的效果为例。</p>
<p>我们在头部骨骼上创建一个插槽，然后使用蓝图动态创建一个ParticleSystemComponent，将ParticleSystemComponent绑定到Mesh上，在AttachComponentToComponent节点上我们就可以直接绑定插槽。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311956813.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311956813.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>然后在跳起时触发特效</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311956118.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311956118.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>运行效果：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311956197.gif"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311956197.gif" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h3 id="C-动态绑定插槽"><a href="#C-动态绑定插槽" class="headerlink" title="C++动态绑定插槽"></a>C++动态绑定插槽</h3><p>先上代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Particles/ParticleSystemComponent.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;GameFramework/Character.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;OCharacter.generated.h&quot;</span></span><br><span class="hljs-built_in">UCLASS</span>()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHERWORLDLYKINGDOM_API</span> AOCharacter : <span class="hljs-keyword">public</span> ACharacter<br>&#123;<br>	<span class="hljs-built_in">GENERATED_BODY</span>()<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">UPROPERTY</span>(BlueprintReadWrite, EditAnywhere, Category = <span class="hljs-string">&quot;Component&quot;</span>)<br>		UParticleSystemComponent* ParticleSystemComp;<br>	<span class="hljs-built_in">UPROPERTY</span>(BlueprintReadWrite, EditAnywhere, Category = <span class="hljs-string">&quot;Component&quot;</span>)<br>		USkeletalMeshComponent* SkeletalMeshComp;<br>	<span class="hljs-built_in">UPROPERTY</span>(BlueprintReadWrite, EditAnywhere, Category = <span class="hljs-string">&quot;Component&quot;</span>)<br>		UParticleSystem* ParticleSystem;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">AOCharacter</span>();<br><span class="hljs-keyword">protected</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-keyword">public</span>:	<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Tick</span><span class="hljs-params">(<span class="hljs-type">float</span> DeltaTime)</span> <span class="hljs-keyword">override</span></span>;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">SetupPlayerInputComponent</span><span class="hljs-params">(<span class="hljs-keyword">class</span> UInputComponent* PlayerInputComponent)</span> <span class="hljs-keyword">override</span></span>;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OJump</span><span class="hljs-params">()</span></span>;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OStopJumping</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-comment">//.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;OCharacter.h&quot;</span></span><br><span class="hljs-comment">//...</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AOCharacter::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Super::<span class="hljs-built_in">BeginPlay</span>();<br>	ParticleSystemComp = <span class="hljs-built_in">NewObject</span>&lt;UParticleSystemComponent&gt;(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;ParticleSystem&quot;</span>));<br>	ParticleSystemComp-&gt;<span class="hljs-built_in">RegisterComponent</span>();<br>	ParticleSystemComp-&gt;<span class="hljs-built_in">SetAutoActivate</span>(<span class="hljs-literal">false</span>);<br>	TArray&lt;USkeletalMeshComponent*&gt; SComps;<br>	<span class="hljs-built_in">GetComponents</span>&lt;USkeletalMeshComponent&gt;(SComps);<br>	<span class="hljs-keyword">for</span> (TObjectIterator&lt;USkeletalMeshComponent&gt; It; It; ++It)<br>	&#123;<br>		USkeletalMeshComponent* Comp = *It;<br>		<span class="hljs-keyword">if</span> (Comp-&gt;ComponentTags.<span class="hljs-built_in">Num</span>() &gt; <span class="hljs-number">0</span>)<br>		&#123;<br>			<span class="hljs-keyword">if</span> (Comp-&gt;ComponentTags[<span class="hljs-number">0</span>] == <span class="hljs-built_in">FName</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Main&quot;</span>)))<br>			&#123;<br>				ParticleSystemComp-&gt;<span class="hljs-built_in">AttachToComponent</span>(SkeletalMeshComp, FAttachmentTransformRules::KeepRelativeTransform, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;headSocket&quot;</span>));<br>			&#125;<br>		&#125;<br>	&#125;	<br>	ParticleSystem = <span class="hljs-built_in">LoadObject</span>&lt;UParticleSystem&gt;(<span class="hljs-literal">nullptr</span>, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;ParticleSystem&#x27;/Game/AnimationStudy/StarterContent/Particles/P_Explosion.P_Explosion&#x27;&quot;</span>));<br>	ParticleSystemComp-&gt;<span class="hljs-built_in">SetTemplate</span>(ParticleSystem);<br>	InputComponent-&gt;<span class="hljs-built_in">BindAction</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Jump&quot;</span>), EInputEvent::IE_Pressed, <span class="hljs-keyword">this</span>, &amp;AOCharacter::Jump);<br>	InputComponent-&gt;<span class="hljs-built_in">BindAction</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Jump&quot;</span>), EInputEvent::IE_Released, <span class="hljs-keyword">this</span>, &amp;AOCharacter::StopJumping);<br>&#125;<br><span class="hljs-comment">//...</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AOCharacter::OJump</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">Jump</span>();<br>	<span class="hljs-keyword">if</span> (ParticleSystemComp != <span class="hljs-literal">nullptr</span>)<br>	&#123;<br>		ParticleSystemComp-&gt;<span class="hljs-built_in">SetActive</span>(<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		<span class="hljs-built_in">UE_LOG</span>(LogTemp, Error, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;AOCharacter::Jump-ParticleSystemComp is null&quot;</span>));<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AOCharacter::OStopJumping</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">StopJumping</span>();<br>	<span class="hljs-keyword">if</span> (ParticleSystemComp != <span class="hljs-literal">nullptr</span>)<br>	&#123;<br>		ParticleSystemComp-&gt;<span class="hljs-built_in">SetActive</span>(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br><br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		<span class="hljs-built_in">UE_LOG</span>(LogTemp, Error, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;AOCharacter::StopJumping-ParticleSystemComp is null&quot;</span>));<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我这里是直接在Character中进行插槽绑定的，所以先为<code>ThirdPersonCharacter</code>蓝图创建一个C++父类<code>AOCharacter</code>，然后在父类中进行插槽绑定。</p>
<p>为了将<code>UParticleSystemComponent</code>组件挂载在指定的<code>USkeletalMeshComponent</code>上这里使用<code>ComponentTag</code>标签来做组件的识别标志。</p>
<p>最终效果：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311958808.gif"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311958808.gif" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h2 id="7-骨骼重定向"><a href="#7-骨骼重定向" class="headerlink" title="7.骨骼重定向"></a>7.骨骼重定向</h2><h3 id="骨骼重定向的作用"><a href="#骨骼重定向的作用" class="headerlink" title="骨骼重定向的作用"></a>骨骼重定向的作用</h3><p>首先我们需要明白动画的底层规则是什么，动画序列是依附于骨骼创建出来的若干关键帧的组合，这些关键帧中存储着这套骨骼的一些基本信息，所以这个动画序列只能在对应的骨骼上使用，如果想要将这个动画序列使用在另一套不同的骨骼上，由于动画序列中并没有另一套骨骼的信息，或者说信息不匹配，所以就无法应用。</p>
<p>骨骼重定向技术就是用来解决这个问题的，重定向有一个基础前提，就是源骨骼与目标骨骼必须在整体层级上保持一直，才能进行重定向。</p>
<p>什么叫做整体层级上保持一致呢？这里用小白人和一个丧尸的骨骼来举例子。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311958895.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311958895.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>可以看到丧尸Hips骨骼的子层级和小白人的pelvis骨骼的子层级基本一致，动画主要使用盆骨，三根脊椎骨，锁骨，手臂骨，小臂骨手指骨，脖子的骨骼，大腿骨，小腿骨以及脚骨，二者在层级上都保持一致，区别只在于丧尸骨骼的手指骨骼被拉长了，盆骨处多了两个服装动画使用的骨骼BackCloth和FrontCloth，而丧尸骨骼相对于小白人缺少了两个IK骨骼。这种情况，尽管骨骼名称不一样，依然属于整体层级上保持一致，二者就可以做重定向来互相使用动画。</p>
<p>如果拿小白人和一只小狗的骨骼举例子，那么种情况就是整体层级不一致了。</p>
<p>如果将小白人的动画重定向后应用到丧尸身上，由于小白人的骨骼在丧尸上基本都有，所以动画可以应用，但是由于小白人没有服装骨骼，所以丧尸的服装将不会有动画，丧尸骨骼没有IK骨骼，所以小白人的IK动画在丧尸身上也不会生效。如果将丧尸的动画重定向到小白人身上，同样的道理，动画也可以应用上，但是也是由于小白人缺少服装骨骼，所以丧尸服装骨骼的动画在小白人身上也不会生效。</p>
<h3 id="如何进行骨骼重定向"><a href="#如何进行骨骼重定向" class="headerlink" title="如何进行骨骼重定向"></a>如何进行骨骼重定向</h3><p>了解了重定向的基本规则之后，我们该如何重定向呢？</p>
<p>这里我使用外部动画应用到小白人身上为例子来说明。</p>
<p>这里我们先去网上下载一个动画素材下来，这里可以去Adabo的<a target="_blank" rel="noopener" href="https://www.mixamo.com/#/?page=2&type=Character">Mixamo</a>网址去下载动画素材。下载素材需要先登录账号，注册一个登录进去，在Animations下我选择了一个跳舞的动画Rumba Dacing来做素材。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311958905.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311958905.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>点击右侧的DownLoad进行下载，下载下来的文件是一个fbx文件，我们将文件导入进UE，勾选上导入动画，其他的选项全部默认就可以，然后导入全部。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311959205.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311959205.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>导入进来两个材质，一个骨骼网格体，两个动画序列，一个物理资产和一个骨骼资产。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311959748.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311959748.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>来看看动画序列：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311959191.gif"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311959191.gif" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>我们双击进入骨骼资产，在菜单栏有一个重定向管理器，打开会弹出骨骼重定向编辑视图。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311959765.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311959765.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>点击选择绑定，选择人形绑定，然后在下方我们需要手动的将新导入的骨骼一一的映射到标准的人形骨骼上。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311959131.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311959131.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>这里映射的是基本的身体骨架，点击显示高级项，可以再进行手指和脚步的骨骼映射，一些没有的骨骼可以不映射，设置完之后可以点击保存将映射信息保存下来。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311959360.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311959360.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>到这一步外部骨骼重定向到标准人体骨骼就完成了。</p>
<p>然后我们打开小白人的骨骼，同样使用重定向管理器，在选择绑定处也选择人形绑定，然后点击自动映射，因为小白人的骨骼UE就是按照标准骨骼来创建的，所以自动映射可以映射上。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312000195.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312000195.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>然后右键新导入的跳舞动画，选择重定向动画资产&#x2F;复制动画资产并重定向。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312000534.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312000534.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>这时我们就可以进入真正的骨骼重定向界面。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312000969.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312000969.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>选择我们需要重定向的小白人骨骼，点击重定向，这是UE会自动为我们创建一个重定向后的动画序列。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312000807.gif"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312000807.gif" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>可以看到动画已经应用到小白人身上了，UE通过标准人体骨骼将外部骨骼的动画重定向到了小白人的骨骼上，但是骨骼位置似乎出现了偏移，这是因为，从Mixamo下载的动画初始姿势是Maya标准的T-Pos姿势，整体上看起来是一个T字，手臂和身体成90度角。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312000892.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312000892.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>而UE的默认初始姿势则不是标准的T-Pos，手臂和身体成45度角。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312001201.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312001201.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>这就会导致重定向时骨骼的变换出现偏差，有两个中处理方案，一种是外部导入的骨骼按照UE的标准制作初始姿势，另一种就是将UE默认的初始姿势修改成Maya的标准T-Pos姿势。由于我不会maya，所以我只能选择后面的一个方案来处理了。</p>
<h3 id="修复小白人位姿偏移"><a href="#修复小白人位姿偏移" class="headerlink" title="修复小白人位姿偏移"></a>修复小白人位姿偏移</h3><p>这里我使用Mixamo来将小白人的姿势改为T-Pos。</p>
<p>首先将小白人的骨骼网格体导出来。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312001041.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312001041.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>兼容格式要选择2013以下，静态网格体中的碰撞不需要导出可以取消勾选。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312001039.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312001039.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>然后我们再次进入<a target="_blank" rel="noopener" href="https://www.mixamo.com/#/?page=1&type=Motion%2CMotionPack">Mixamo</a>点击右侧的Upload Character，把我们的导出的网格体上传到Mixamo，上传完成后小白人的模型就可以在Mixamo中浏览了。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312001032.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312001032.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>然后在Animations下搜索T-Pose，点击T-Pose动作，小白人就应用上了T-Pose动作。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312001606.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312001606.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>然后再把小白人下载下来并导入UE中，会直接导入一个名字叫T-Pose的动画序列。右键这个动画序列&#x2F;创建&#x2F;创建姿势资产。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312001620.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312001620.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>然后打开小白人的骨骼，在重定向管理器视图选择修改姿势，导入我们刚创建的姿势资产，然后点击查看姿势，我们新的T-Pos姿势就应用到了小白人身上，现在我们再重定向一次，直接右键跳舞动画&#x2F;重定向动画资产&#x2F;复制动画资产并重定向，让UE重新创建一个动画序列，然后来看看效果：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312001914.gif"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312001914.gif" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>效果还可以。</p>
<h3 id="重定向链"><a href="#重定向链" class="headerlink" title="重定向链"></a>重定向链</h3><p>这是UE5的新功能，IK Rig和IK Retargeter在做骨骼重定向的时候可以以一条骨骼链的形式来进行链与链的重定向并且通过IK重定向器直接使用名字进行映射，可以省去重定向过程中的很多麻烦操作。</p>
<p>这里我使用从<a target="_blank" rel="noopener" href="https://www.aplaybox.com/details/model/vLy9oQVdjFXj">模之屋</a>下载的看板娘的模型套用到小白人身上作为例子。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312002359.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312002359.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>首先从模之屋下载MMD模型，这里下载的模型是.pmx格式的，不能直接应用到UE中，所以需要先把.pmx格式的文件转换成.fbx，这里使用了一个<a target="_blank" rel="noopener" href="http://stereoarts.jp/">日本大佬</a>从一个Unity插件中提取出来的工具(pmx2fbx)进行转换，国内也有很多帮运，如：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV11K4y1G7DL/?vd_source=e979466844c4915a4200c496efb35cfb">https://www.bilibili.com/video/BV11K4y1G7DL/?vd_source=e979466844c4915a4200c496efb35cfb</a></p>
<p>使用方法也很简单，输入指令将下载好的mmd模型转换为UE可识别的fbx文件，然后导入到UE。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312002900.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312002900.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>导入进来的模型会自带很多空白材质，需要我们自己导入模型自带的贴图修复，这里就先使用白模了。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312002959.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312002959.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>首先<code>右键/动画/IK绑定/IK绑定</code>为我们新导入的模型骨骼创建一个IK绑定，选择我们新导入的骨骼网格体perer_41，并命名为IKRing_Per。</p>
<p>然后在IK编辑器里选择骨骼右键&#x2F;新建来自选定骨骼的重定向链，在弹出的界面点击确定，这是UE会提示我们为骨骼链添加IK目标，由于现在还没有目标，所以选择无目标，这样一条骨骼链就创建好了。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312002430.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312002430.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>这里我没有重定向手指，只重定向了几个主要的骨骼，下面列出我重定向的骨骼链及其涉及骨骼的名称：</p>
<table>
<thead>
<tr>
<th>骨骼链名称</th>
<th>涉及骨骼</th>
</tr>
</thead>
<tbody><tr>
<td>Root</td>
<td>263_!Root</td>
</tr>
<tr>
<td>Spine</td>
<td>12_joint_Torso</td>
</tr>
<tr>
<td></td>
<td>13_joint_Torso2</td>
</tr>
<tr>
<td>Head</td>
<td>19_joint_Neck</td>
</tr>
<tr>
<td></td>
<td>21_joint_Head</td>
</tr>
<tr>
<td>LeftArm</td>
<td>61_joint_LeftArm</td>
</tr>
<tr>
<td></td>
<td>66_joint_LeftElbow</td>
</tr>
<tr>
<td></td>
<td>71_joint_LeftWrist</td>
</tr>
<tr>
<td>RightArm</td>
<td>25_joint_RightArm</td>
</tr>
<tr>
<td></td>
<td>30_joint_RightElbow</td>
</tr>
<tr>
<td></td>
<td>35_joint_RightWrist</td>
</tr>
<tr>
<td>LeftLeg</td>
<td>115_joint_LeftHipD</td>
</tr>
<tr>
<td></td>
<td>116_joint_LeftKneeD</td>
</tr>
<tr>
<td></td>
<td>117_joint_LeftFootD</td>
</tr>
<tr>
<td></td>
<td>118_!joint_hidariashisakiEX</td>
</tr>
<tr>
<td>RightLeg</td>
<td>111_joint_RightHipD</td>
</tr>
<tr>
<td></td>
<td>112_joint_RightKneeD</td>
</tr>
<tr>
<td></td>
<td>113_joint_RightFootD</td>
</tr>
<tr>
<td></td>
<td>114_!joint_migiashisakiEX</td>
</tr>
<tr>
<td>LeftClavicle</td>
<td>59_joint_LeftShoulder</td>
</tr>
<tr>
<td>RightClavicle</td>
<td>23_joint_RightShoulder</td>
</tr>
</tbody></table>
<p>盆骨(14_joint_HipMaster)比较特殊，不用创建骨骼链，但是要设置为重定向根。</p>
<p>然后为小白人也创建一个IK绑定，命名为IKRing_SK，按照一样的逻辑创建对应的骨骼链和设定重定向根：</p>
<table>
<thead>
<tr>
<th>骨骼链名称</th>
<th>涉及骨骼</th>
</tr>
</thead>
<tbody><tr>
<td>Root</td>
<td>root</td>
</tr>
<tr>
<td>Spine</td>
<td>spine_01</td>
</tr>
<tr>
<td></td>
<td>spine_02</td>
</tr>
<tr>
<td></td>
<td>spine_03</td>
</tr>
<tr>
<td></td>
<td>spine_04</td>
</tr>
<tr>
<td></td>
<td>spine_05</td>
</tr>
<tr>
<td>Head</td>
<td>neck_01</td>
</tr>
<tr>
<td></td>
<td>neck_02</td>
</tr>
<tr>
<td></td>
<td>head</td>
</tr>
<tr>
<td>LeftArm</td>
<td>upperarm_l</td>
</tr>
<tr>
<td></td>
<td>lowerarm_l</td>
</tr>
<tr>
<td></td>
<td>hand_l</td>
</tr>
<tr>
<td>RightArm</td>
<td>upperarm_r</td>
</tr>
<tr>
<td></td>
<td>lowerarm_r</td>
</tr>
<tr>
<td></td>
<td>hand_r</td>
</tr>
<tr>
<td>LeftLeg</td>
<td>thigh_l</td>
</tr>
<tr>
<td></td>
<td>calf_l</td>
</tr>
<tr>
<td></td>
<td>foot_l</td>
</tr>
<tr>
<td></td>
<td>ball_l</td>
</tr>
<tr>
<td>RightLeg</td>
<td>thigh_r</td>
</tr>
<tr>
<td></td>
<td>calf_r</td>
</tr>
<tr>
<td></td>
<td>foot_r</td>
</tr>
<tr>
<td></td>
<td>ball_r</td>
</tr>
<tr>
<td>LeftClavicle</td>
<td>clavicle_l</td>
</tr>
<tr>
<td>RightClavicle</td>
<td>clavicle_r</td>
</tr>
</tbody></table>
<p>然后再右键&#x2F;动画&#x2F;IK绑定&#x2F;IK重定向器，在弹出的界面中选择IKRing_Per作为源，然后进入IK重定向器编辑视图。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312002184.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312002184.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>在细节面板设置目标为IKRing_SK，为了重定向效果更好，我们需要将目标骨骼的姿势尽量修改得和源骨骼一致，在左侧点击编辑模式可以直接修改骨骼偏移来对姿势进行编辑，可以修改目标网格体偏移来设置源骨骼与目标骨骼的重合与分离。</p>
<p>全部设置好之后，我们就可以在资产浏览器中选择一个动画序列来看看重定向之后的效果：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312002798.gif"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312002798.gif" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>看起来效果还不错。</p>
<p>重定向好之后我们要怎么把模型应用到小白人身上呢？</p>
<p>在应用到小白人之前我们先给人物上一下材质和布料(布料可以查看第三章骨骼网格体第2小节布料系统)，这样好看点，做起来也有动力😍。</p>
<p>过程就直接省略了，直接看效果：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312002527.gif"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312002527.gif" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>首先我们要为新角色创建一个动画蓝图，创建的时候要选择新角色的骨骼，这里命名为Anim_Per：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312003973.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312003973.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>从网格体重定向姿势(Retarget Pose From Mesh)应该是UE5专门为数字人添加的节点，我在UE4.27中搜不到这个节点，Retarget Pose From Mesh可以从一个骨骼网格体复制动画数据到当前骨骼网格体，因为动画序列在不同的骨骼上是不兼容的，Retarget Pose From Mesh可以让一套骨骼便捷的使用另一套骨骼的动画序列，使用上需要在Details&#x2F;Settings&#x2F;IKRetarfeterAsset中设置我们配置好的IK重定向器。然后我们拷贝一个第三人模板的角色蓝图，在已有的骨骼网格体Mesh下新建一个骨骼网格体，并设置好我们的角色资产和动画蓝图。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312003589.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312003589.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>然后将两个骨骼网格体的Details&#x2F;Optimization&#x2F;Visibility Based Anim Tick Option选项设置为Always Ticj Pose and Refresh Bones，这时我们的新角色就可以跟着第三人称模板的角色做动作了，然后把Mesh隐藏起来，然后跑起来看看效果：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312003712.gif"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312003712.gif" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>看起来阴影有点问题，不过这是另一个问题了，这里就不用在意了。</p>
<h3 id="导出重定向动画"><a href="#导出重定向动画" class="headerlink" title="导出重定向动画"></a>导出重定向动画</h3><p>这个方法是可以不一个个重定向动画序列的方式，当然这也导致我们的角色蓝图离不开父骨骼，如果我们想使用角色自己的独立动画序列资源，则在重定向编辑器中选择我们需要重定向的动画序列，点击资产浏览器下的导出选定动画即可，或者也可直接右键动画序列资产&#x2F;重定向动画资产&#x2F;复制和重定向动画资产，然后在重定向视图选择重定向器。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312003258.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312003258.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h1 id="三、骨骼网格体"><a href="#三、骨骼网格体" class="headerlink" title="三、骨骼网格体"></a>三、骨骼网格体</h1><h2 id="1-骨骼网格体转静态网格体"><a href="#1-骨骼网格体转静态网格体" class="headerlink" title="1.骨骼网格体转静态网格体"></a>1.骨骼网格体转静态网格体</h2><p>有时我们可能需要一些人物的Pose在做一些宣传图或者在游戏中做一些雕像之类的，骨骼网格体转静态网格体可以方便达成这些功能，其作用是将我们在骨骼编辑器中编辑好的临时姿势保存起来，因为骨骼编辑器可以编辑骨骼转向和偏移，但是都是临时的，我们可以将编辑好的姿势保存为静态网格体，这样以后就可以在任何需要的地方使用了。</p>
<p>做法也比较简单，在骨骼编辑器中将人物的姿势编辑好，然后直接点击菜单栏的Make Static Mesh即可将姿势保存为静态网格体。</p>
<h2 id="2-布料系统"><a href="#2-布料系统" class="headerlink" title="2.布料系统"></a>2.布料系统</h2><p>UE是自带了一套布料系统的，虽然效果上不是很优秀，不过也可以应付一些基本需求了。这里之所以把布料系统放在骨骼网格体章节下，是因为UE的布料是基于骨骼网格体的，并且UE的布料系统内容也不多。</p>
<p>这里说的布料系统基于骨骼网格体的意思是，UE的布料系统只能应用在Skeletal Mesh上，普通的Static Mesh是不能使用UE的布料系统的，这就要求所有要引用布料的模型都需要至少附带一根骨骼。</p>
<p>这里我们继续使用第二章中的MMD模型Perer来学习布料系统。布料编辑器是和骨骼网格体编辑集成在一起的，对布料的编辑就是直接在骨骼网格体编辑器中进行。</p>
<h3 id="创建衣服数据"><a href="#创建衣服数据" class="headerlink" title="创建衣服数据"></a>创建衣服数据</h3><p>布料的一些基础信息UE使用了ClothingData资产来存储，直接在骨骼网格体编辑器中选中要创建衣服数据的网格体&#x2F;右键&#x2F;Create Clothing Data from Section。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312003097.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312003097.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>AssetName可以修改衣服数据资产的名称，PhyiscsAsset可以选择衣服数据绑定的物理资产。</p>
<p>然后UE会自动打开Clothing管理窗口，当然我们也可以在Windows下手动打开Clothing窗口然后在ClothingData栏中点击Add Clothing来添加衣服数据。</p>
<h3 id="应用衣服数据"><a href="#应用衣服数据" class="headerlink" title="应用衣服数据"></a>应用衣服数据</h3><p>ClothingData只是一个存储布料数据的资产，我还需要将资产应用到骨骼网格体上，选中要应用的骨骼网格体&#x2F;右键&#x2F;Apply Clothong Data，然后选择想要的资产应用。此时衣服上就有布料数据了，当然现在还没有布料效果，因为我们还没往ClothingData中刷入布料权重信息。</p>
<h3 id="刷布料权重"><a href="#刷布料权重" class="headerlink" title="刷布料权重"></a>刷布料权重</h3><p>点击菜单栏的Activate Cloth Paint，此时衣服骨骼网格体变成紫红色并显示网格，鼠标上到上边会出现绿色的笔刷，Clothing视图会多出很多配置选项，左上角会多出一个笔刷范围内的顶点的布料权重值Cloth Value。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312003557.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312003557.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>在Clothing视图下我们需要关注一般只有的Tool Settings&#x2F;Paint Value和Brush&#x2F;Radius，前者设置的笔刷将赋予骨骼网格体的布料权重，默认值范围为0-100，超出范围的值需要手动输入，值越大代表权重越大，权重越大布料受物理系统影响越大，0就是不受物理系统影响，在骨骼网格体上表现为紫红色，受影响的部分变现为半透明灰色，中间值显示为黑色。</p>
<p>在刷权重的过程中可以按H键预览布料效果，或则取消激活Activate Cloth Paint也可以看效果。</p>
<p>有时候布料刷完之后表现起来可能怪怪的，这是因为布料受到物理资产的影响，布料会直接收到物理资产中的碰撞的碰撞影响，如果布料表现怪怪的我们可以调节一下物理资产中碰撞体大小和方位。</p>
<p>一个好的布料效果需要模型和布料经过大量的微调才行，一般来说网格体的点越多布料效果越好，但是也会越吃性能，具体项目需要在具体实践中找到平衡。</p>
<p>然后在给裙子也刷上布料就可以达到这个效果了：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312004961.gif"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312004961.gif" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>UE的布料系统也包含很多内容，由于已经不在动画系统范畴，这里就只看这么多了，更多了留到以后再看。</p>
<h1 id="四、物理资产"><a href="#四、物理资产" class="headerlink" title="四、物理资产"></a>四、物理资产</h1><p>物理资产是专门用于骨骼网格体和布料系统做物理模拟的资产。</p>
<p>关于物理资产编辑器的界面的介绍可以看这篇文章：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/90983975">UE4物理精粹Part 2：Physics Assets Tool详解 - 知乎 (zhihu.com)</a></p>
<h2 id="1-创建物理资产"><a href="#1-创建物理资产" class="headerlink" title="1.创建物理资产"></a>1.创建物理资产</h2><p>物理资产可以在导入模型时勾选Create Physics Asset选项然UE根据骨骼创建默认的物理资产，也可以右键&#x2F;Physics&#x2F;Physics Asset来手动创建物理资产，手动创建物理资产时会让我们选择绑定骨骼，并且第一次打开时会然我们设置物理资产的约束。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312004044.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312004044.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h2 id="2-物理形体"><a href="#2-物理形体" class="headerlink" title="2.物理形体"></a>2.物理形体</h2><p>我们打开物理资产看到的一个个的胶囊体就是物理形体，UE通过这些物理形体来实现骨骼之间的物理碰撞。</p>
<h3 id="创建物理形体"><a href="#创建物理形体" class="headerlink" title="创建物理形体"></a>创建物理形体</h3><p>一般我们在导入模型或者手动创建物理资产后UE会为物理资产默认生成一套物理形体，一般不需要我们手动创建，当然如果我们角色UE默认创建的不好、物理形体丢失或者想要增加一些形体也是可以手动创建的。</p>
<p>如果物理形体丢失了，在物理资产编辑器视图的Tools视图中<code>Generate All Bodies</code>按钮，在保证当前没有选择任何形体或骨骼的前提下，点击即可从新生成一套UE默认的物理形体组合。</p>
<p>如果想要增加物理形体，我们需要在Skeleton Tree视图选中想要添加形体的骨骼，然后点击Tools视图的<code>Add Bodies</code>按钮，这个按钮添加的形体是默认的胶囊体样式，如果想要添加其他样式(如正方体)，则右键骨骼&#x2F;Add Shape，然后选择想要的样式即可。默认情况下物理资产编辑视图的Skeleton Tree视图好像是只显示形体而不显示骨骼的，我们需要点击Skeleton Tree右侧的设置图标选择Show All Bones才能看到所有的骨骼。</p>
<h3 id="物理形体的属性"><a href="#物理形体的属性" class="headerlink" title="物理形体的属性"></a>物理形体的属性</h3><p>物理形体的属性相当的多，就不一一列举了，可以直接查看[官方文档](<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/5.0/zh-CN/physics-bodies-reference-for-unreal-engine/">虚幻引擎物理形体参考 | 虚幻引擎5.0文档 (unrealengine.com)</a>)。</p>
<h2 id="3-物理约束"><a href="#3-物理约束" class="headerlink" title="3.物理约束"></a>3.物理约束</h2><p>物理约束本质上一种连接点，利用物理约束可以通过约束应用的限制和力度将多个Actors连接起来，如：绳索、吊桥等。</p>
<p>UE的物理约束系统是一个独立的系统，动画系统中的骨骼物理约束只是发动画系统对物理约束系统的应用。</p>
<p>在学习骨骼约束之前我们首先应该对物理约束系统有一个基础的了解。</p>
<h3 id="物理动画"><a href="#物理动画" class="headerlink" title="物理动画"></a>物理动画</h3><p>有了物理约束自然也就可以实现一些物理动画了，UE预制了一些物理约束Actor可供我们实现一些简单的物理动画。</p>
<p><strong>PhysicsConstraintActor</strong></p>
<p>物理约束对象(PhysicsConstraintActor)是一个连接点，可以对连接上连接点头尾的StaticMesh进行物理约束，如我们可以使用PhysicsConstraintActor创建一个具有物理惯性的下垂摆动动画：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312004927.gif"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312004927.gif" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>使用方法也比较简单，PlaceActor中找到PhysicsConstraintActor拖入场景中，然后在Details&#x2F;Constraint的Constraint Actor 1和Constraint Actor 2分别选择两个StaticMeshActor，设置需要摆动的方块启用物理模拟，并且Mobility设置为Moveable，运行后这个方块就会因为重力向下坠落，但由于受到PhysicsConstraintActor的物理约束，方块就会在物理约束下摆动，然后随着重力作用慢慢停止运动。</p>
<p>这里有一点需要注意，PhysicsConstraintActor只能约束StaticMesh，在选择头尾Actor时如果Actor是StaticMesh那么只需要选择约束Actor就可以实现约束了，如果Actor就是普通蓝图Actor则除了选择约束Actor还需要指定约束的StaticMesh组件名称。</p>
<p><strong>CableActor</strong></p>
<p>缆索是UE预制的绳子Actor，可以很便捷是制作出绳子的效果，这里还是使用上面的例子，但是两个Cube换成自定义的Actor，在加上CableActor来看看效果：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312004126.gif"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312004126.gif" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>CableActor和PhysicsConstraintActor的用法差不多，也是从PlaceActor中找到然后拖入场景，然后在Details&#x2F;Cable&#x2F;Attach End To选择缆索末端的Actor，同样CableActor也只能约束StaticMesh，所以使用自定义Actor时需要指定ComponentName，预制的CableActor由一个空的CableActor和一个CableComponent组件组成，CableActor所在的位置为绳子头部，CableComponent所在的位置为绳子尾部。</p>
<p><strong>PhysicsThruster</strong></p>
<p>UE预制的在PlaceActor中的物理推进器Actor我没有研究出有什么用，可能有效果只是PhysicsThruster自身不可视我们看不到效果，不过我们可以从PhysicsThrusterComponent中窥见一二。我们只需要向自定义Actor中添加一个PhysicsThrusterComponent组件，然后勾选PhysicsThrusterComponent的Details&#x2F;Activation&#x2F;Auto Activate，然后Actor给与一个StaticMesh并启用物理模拟，物理推进器就可以推着Actor运动了，物理推进器组件会给与Actor一个持续的力，可以看一下有趣实践：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312004297.gif"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312004297.gif" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>上面三种UE预制的物理约束都由组件，另外一些物理约束只以组件的形式出现。</p>
<p><strong>PhysicsHandleComponent</strong></p>
<p>物理柄组件是UE预制的专门用于制作物品抓取效果的组件，使用物理柄组件可以很方便快捷的实现任何具备物理效果的物体的抓取。</p>
<p>先来看一下效果：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312005442.gif"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312005442.gif" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>实现上也比较方便，我们自己要实现的就是获取要抓取的Actor，和设置Actor跟随人物视角运动，其他就可以全交给PhysicsHandle组件了。这里我使用了继承自DefaultPawn的自定义Pawn来作为可控角色。全部蓝图如下：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312006964.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312006964.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><strong>PhysicalAnimationComponent</strong></p>
<p>物理动画组件是用来设置角色在被Controller控制的同时也能被物理系统控制，一般需要配合布娃娃系统使用，如双手或身体的物理下垂，以实现“人类一败涂地”中的角色效果，用法其实也很简单，这里用一个案例来说明。</p>
<p>这里用第三人称模板来实践，首先为角色蓝图添加物理动画组件，然后在游戏开始时配置组件数据并启用布娃娃系统。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312006961.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312006961.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<ul>
<li>Set Skeletal Mesh Component：为物理动画组件指定需要应用物理动画的骨骼网格体；</li>
<li>Apply Physical Animation Settings Below：使指定骨骼及其所有子骨骼应用指定的物理动画数据；</li>
<li>Set All Bodies Below Simulate Physics：启动布娃娃系统，需要注意的是Include Self需要取消勾选；</li>
<li>然后碰撞体组件的Details&#x2F;Collision&#x2F;Collision Presets设置为IgnoreOnlyPawn，骨骼网格体的Details&#x2F;Collision&#x2F;Collision Presets设置为Pawn。</li>
</ul>
<p>然后看看效果：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312006951.gif"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312006951.gif" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><strong>DestructibleComponent</strong></p>
<p>可摧毁组件专门用于制作破碎效果，组件用于存储可摧毁物体的物理数据，当然只有DestructibleMesh才可以制作破碎效果。</p>
<p><strong>RadialForceComponent</strong></p>
<p>径向力组件用于发出径向力或脉冲来影响物理对象或可摧毁对象的，径向力组件发出的力是瞬发的，发出后将不再持续。</p>
<p>DestructibleComponent和RadialForceComponent都涉及到物理破碎的知识，有点扯远了，这里也不多累述了。</p>
<h2 id="4-布娃娃系统"><a href="#4-布娃娃系统" class="headerlink" title="4.布娃娃系统"></a>4.布娃娃系统</h2><p>要制作一个简单的布娃娃效果其实不难，UE已经为我们制作好了网格体的布娃娃效果，应用布娃娃效果的网格体必须绑定物理资产，然后我们就可以直接通过Set All Bodies Below Simulate Physics节点启用和关闭布娃娃系统了，当我们在控制角色上启用布娃娃系统时SkeletalMesh将直接交由UE的物理系统控制，此时Pawn将失去对SkeletalMesh的控制。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312006662.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312006662.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<ul>
<li>Target：要应用布娃娃系统的网格体，可以是静态网格体也可以是骨骼网格体；</li>
<li>In Bone Name：启用布娃娃系统的骨骼名称，指定名称往下的所有子骨骼都会启用布娃娃系统，如我们指定肩锁骨则整个手臂都会启用布娃娃系统，如果指定root则全身启用布娃娃系统；</li>
<li>New Simulate：启用或关闭布娃娃系统；</li>
<li>Include Self：具体是什么作用不清楚，官方文档没有说明，引擎源码也没有说明。</li>
</ul>
<p>我们还可以通过Set All Bodies Below Physics Blend Weight节点来设置布娃娃系统与动画系统的控制权重，不设置默认权重为1，即启动后完全由物理系统控制角色动画。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312006612.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312006612.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>然后我们来做一个简单的布娃娃系统。</p>
<p>首先编辑角色蓝图：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312006864.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312006864.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>当角色掉落到地面时启用布娃娃系统，并设置权重为1。</p>
<p>然后碰撞体组件的Details&#x2F;Collision&#x2F;Collision Presets设置为IgnoreOnlyPawn，骨骼网格体的Details&#x2F;Collision&#x2F;Collision Presets设置为Pawn，然年看看效果：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312006763.gif"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312006763.gif" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h1 id="五、动画序列"><a href="#五、动画序列" class="headerlink" title="五、动画序列"></a>五、动画序列</h1><p>动画序列(AnimationSequence)是依附于骨骼的独立的动画资源，序列中大量的骨骼关键帧。是动画混合、动画合成、姿势资产和IK等的基础资源。</p>
<h2 id="1-动画曲线"><a href="#1-动画曲线" class="headerlink" title="1.动画曲线"></a>1.动画曲线</h2><p>动画曲线就是以动画序列的帧数为X轴，以其他类型的值为Y轴的二维函数曲线，动画曲线没有什么特殊的意义，只是根据动画序列的帧数变化提供一个变化的值。</p>
<h3 id="动画曲线的创建与编辑"><a href="#动画曲线的创建与编辑" class="headerlink" title="动画曲线的创建与编辑"></a>动画曲线的创建与编辑</h3><p>动画曲线在动画序列编辑界面创建，单击Curves的下拉三角选择Add Curve&#x2F;Create Curve。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312007908.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312007908.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>单击曲线的下拉三角选择Edit Curve或者双击曲线可进入曲线的编辑视图。</p>
<h3 id="动画曲线管理"><a href="#动画曲线管理" class="headerlink" title="动画曲线管理"></a>动画曲线管理</h3><p>在骨骼编辑器、动画序列编辑器和动画蓝图的菜单栏选择Window&#x2F;Anim Curves可以打开动画曲线管理视图，在动画曲线管理视图可以对曲线进行筛选管理，是否激活材质参数以及编辑曲线的属性。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312007197.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312007197.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h3 id="元数据曲线"><a href="#元数据曲线" class="headerlink" title="元数据曲线"></a>元数据曲线</h3><p>在创建曲线时我们能看到一个Add Metadata选项，这个就是用来创建元数据曲线的按钮，元数据曲线就是一个特殊的动画曲线，元素据曲线是一根Y值为常量1的曲线，即Y值永远为1，不随X轴变化而变化，且不可修改。</p>
<p>按照官方的解释是，在大多情况下动画使用的曲线都是常量值为1的曲线，只有少数情况会用到值变化的曲线，所以才有了元数据曲线。</p>
<h3 id="动画曲线的使用"><a href="#动画曲线的使用" class="headerlink" title="动画曲线的使用"></a>动画曲线的使用</h3><p>这里以一个人物跳起时脚变大的麒麟腿效果为例子。</p>
<p>这里使用的是第三人称模板，在ThirdPersonJump_Start动画序列中添加曲线FootCurve，并添加(0.1,1)、(0.2,2)两个关键帧，在ThirdPersonJump_Loop动画序列中添加曲线FootCurve，并添加关键帧(0,2)，在ThirdPersonJump_End动画序列中添加曲线FootCurve，并添加关键帧(0,2)、(0.2,1)。</p>
<p>这里所有动画序列都使用相同名称的曲线的一个好处是在动画蓝图中可以使用同一个名称来获取不同动画序列中的这个名称的曲线的值。</p>
<p>动画蓝图在播放到某一个动画序列时，通过名称来获取当前播放的动画序列的曲线的值。</p>
<p>在动画蓝图的JumpStart状态，JumpLoop状态，JumpEnd状态分别写入如下蓝图逻辑：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312007517.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312007517.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>其中Transform(Modify)Bone节点做如下设置：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312007116.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312007116.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>Transform(Modify)Bone是骨骼变换节点，可以对骨骼做位移，旋转和缩放变换，在Skeletal Control&#x2F;Bone to Modify绑定骨骼既可对绑定骨骼做变换控制。</p>
<p>三者的不同在于播放各自的动画序列，JumpStart状态播放ThirdPersonJump_Start动画，JumpLoop播放ThirdPersonJump_Loop动画，JumpEnd播放ThirdPersonJump_End动画。</p>
<p>运行效果：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312007878.gif"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312007878.gif" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h3 id="其他曲线节点"><a href="#其他曲线节点" class="headerlink" title="其他曲线节点"></a>其他曲线节点</h3><p>对曲线的获取除了上面用到的GetCurveValue节点，还有GetAllCurveNames和GetActiveCurveNames两个节点。</p>
<h2 id="2-动画通知"><a href="#2-动画通知" class="headerlink" title="2.动画通知"></a>2.动画通知</h2><p>动画通知(Anim Notify)，是一种动画回调程序逻辑的机制，在动画的序列帧中绑定通知点，当动画播放到指定帧时就会触发函数回调，通知游戏逻辑。</p>
<h3 id="动画通知的创建"><a href="#动画通知的创建" class="headerlink" title="动画通知的创建"></a>动画通知的创建</h3><p>动画通知的创建比较简单，再动画序列编辑器中的时间轴旁有一个Notifies栏，右键时间轴&#x2F;Add Notify&#x2F;New Notify，然后为动画通知命名，就可以在对应的通知栏创建一个动画通知。</p>
<p>每一个动画序列在被创建时会默认创建一个名称为1的动画通知栏，动画通知栏只是用来分类管理动画通知的，就如同蓝图变量里的Category。</p>
<p>在同一个通知栏同一帧处可以触发多个动画通知，一般同一栏同一帧处要触发多个动画通知的时候采用分栏管理会比较方便管理，点击Notifies的下拉三角&#x2F;Add Notify Track可以增加新的分栏。</p>
<h3 id="动画通知的回调"><a href="#动画通知的回调" class="headerlink" title="动画通知的回调"></a>动画通知的回调</h3><p>动画通知创建好后，编译完就可以直接在与动画序列绑定的动画蓝图中直接搜索到动画通知事件，动画通知被创建好后动画系统会为动画蓝图创建对应的名为<code>AnimNotify_&lt;动画通知名&gt;</code>的蓝图事件，当角色动画播放到动画通知所在的动画序列的关键帧时对应的通知事件会被动画系统触发，然后我们就可以在动画蓝图中处理逻辑，或者通过调度器将通知传递到其他蓝图，或者直接引用其他蓝图的对象将通知传递出去。</p>
<h3 id="在C-中使用动画通知"><a href="#在C-中使用动画通知" class="headerlink" title="在C++中使用动画通知"></a>在C++中使用动画通知</h3><p>动画通知是依赖于动画实例(AnimInstance)而存在的，所以我们要想在C++中使用动画通知，就得先在C++中创建动画实例，然后再在实例中创建动画通知。</p>
<p>创建一个继承自UAnimInstance的自定义动画实例，在类中添加一个<code>void AnimNotify_XXX(UAnimNotify* Notify)</code>格式的函数，如：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">//.h</span><br><span class="hljs-built_in">UCLASS</span>()<br>class OTHERWORLDLYKINGDOM_API UOAminInstacne : public UAnimInstance<br>&#123;<br>	<span class="hljs-built_in">GENERATED_BODY</span>()<br>public:<br>	<span class="hljs-built_in">UFUNCTION</span>()<br>	void <span class="hljs-built_in">AnimNotify_Jump</span>(UAnimNotify* Notify);<br>&#125;;<br><span class="hljs-comment">//.cpp</span><br>void UOAminInstacne::<span class="hljs-built_in">AnimNotify_Jump</span>(UAnimNotify* Notify)<br>&#123;<br>    <span class="hljs-built_in">UE_LOG</span>(LogTemp, Log, TEXT(&quot;Jump&quot;));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里有几点需要注意，函数必须是<code>void AnimNotify_XXX(UAnimNotify* Notify)</code>格式，XXX对应的是动画通知的名字，动画系统会自动将这个函数与名字对应的动画通知相绑定，函数返回值必须是void，否则当动画通知回调时会触发警告：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran">LogAnimNotify: Warning: Anim notifier <span class="hljs-keyword">named</span> AnimNotify_JumpStart, but the <span class="hljs-keyword">parameter</span> <span class="hljs-keyword">number</span> does not match or not of the correct <span class="hljs-keyword">type</span><br></code></pre></td></tr></table></figure>

<p>并且函数必须使用<code>UFUNCTION()</code>加入反射系统，否则动画系统将找不到函数与对应的动画通知相绑定。</p>
<p>创建好动画实例后，只需要在ThirdPerson_AnimBP的Class Settings的Details&#x2F;Class Options&#x2F;Parent Class下把父类改成我们自己创建的类，第三人称模板的动画蓝图就继承自我们自己创建的AnimInstance了，然后再在动画序列中创建一个与动画回调AnimNotify_Jump对应的动画通知Jump，当动画播放到动画通知所在的动画序列的关键帧处时就会自动触发C++中的动画回调函数，这样动画通知的信号就传递到了C++，当如果我们不想使用C++的AnimInstance我们也可以使用动画通知的蓝图回调事件加C++动态代理来实现这一功能。</p>
<h3 id="自定义动画通知"><a href="#自定义动画通知" class="headerlink" title="自定义动画通知"></a>自定义动画通知</h3><p>除了使用自定义的动画蓝图外，我们也可以使用自定义的动画通知，我们只需要创建一个继承自UAnimNotify的蓝图类或C++类，动画系统就会将自定义的动画通知注册进系统，我们就可以在动画序列编辑器中看到自定义的动画通知了，如：创建一个名叫AnimNotify_JumpStart的自定义动画通知，然后我们就可以在动画序列里看到这个预定义通知：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312008544.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312008544.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>自定义类中提供了<code>Received_Notify</code>函数的重写，这样我们在接受到动画通知时可以做一些通用的处理逻辑。自定义的动画通知在被回调时直接进入Received_Notify接口，通过这个接口来处理逻辑，因此UE就将自定义动画通知的回调事件从动画蓝图中略去了，所以在动画蓝图中我们搜不到自定义通知的回调事件，因此自定义动画通知无法在动画蓝图中使用。并且自定义动画通知也不会显示在骨骼编辑器的Animation Notifies中显示。</p>
<h3 id="骨骼通知"><a href="#骨骼通知" class="headerlink" title="骨骼通知"></a>骨骼通知</h3><p>骨骼通知实际上和动画通知是一回事，我们创建一个动画通知时，动画通知是保存在骨骼资产里的，这也是为什么我添加动画通知时，骨骼资产会出现修改后的*号，我们添加的动画通知可以在骨骼编辑器的Animation Notifies视图下看到，如之前添加Jump通知。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312008432.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312008432.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>我们添加骨骼通知时可以检索到骨骼资产里保存的所有的通知。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312008744.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312008744.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>由于通知并不存储在动画序列里而是存储在骨骼资产里，所以我们在动画序列里删除的通知只是删除了通知的引用而并没有删除通知本身，我需要到骨骼资产里删除才是删除通知本身。</p>
<h3 id="通知状态"><a href="#通知状态" class="headerlink" title="通知状态"></a>通知状态</h3><p>通知状态应该交动画状态通知可能更合理，其实就是一种持续的动画通知，普通的动画通知是在动画运行到指定关键帧时进行一次调用，而通知状态则是可以跨多帧并且在通知所跨的每一帧都会进行通知，UE为我们预制了几个粒子特效播放的通知状态：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312008826.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312008826.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>可以很便捷通过动画来触发一些粒子效果，比如人物走动时的烟尘效果。</p>
<ul>
<li>Trail：用来制作有运动轨迹的特效；</li>
<li>Timed Particle Effect：用来播放老的粒子特效；</li>
<li>Timed Niagara Effect：用来播放新的粒子特效；</li>
<li>Advanced Timed Niagara Effect：可定时的粒子播放，只适用于新的粒子特效。</li>
</ul>
<p>这里我们来使用Timed Particle Effect制作一个人物跑动时脚底冒火的效果。</p>
<p>分别在两个脚底骨骼ball_l和ball_r下创建两个插槽ball_lSocket和ball_rSocket，然后创建两个通知状态，并分别设置好触发时间、播放的粒子特效、绑定的插槽名称和插槽的缩放。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312008402.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312008402.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>然后就可以跑起来看效果了：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312008080.gif"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312008080.gif" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h3 id="自定义通知状态"><a href="#自定义通知状态" class="headerlink" title="自定义通知状态"></a>自定义通知状态</h3><p>官方预制的几个通知状态虽然用起来很便捷，但是功能却很单一，大多数时候还是得使用自定义的通知状态。</p>
<p>自定义的通知状态需要继承AnimNotifyState，我们直接创建一个继承自AnimNotifyState的蓝图类并命名为AnimNotifyState_Jump，自定义通知状态就注册进了动画系统，这时我们就可以在动画序列里看到自定义的动画通知了。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312009478.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312009478.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>AnimNotifyState蓝图类是一个UObject类，并且蓝图编辑视图中没有Graphs视图，这就意味着AnimNotifyState蓝图类不能创建自定义事件，自定义动画通知状态的入口主要就是三个函数重载，<code>Received_NotifyBegin</code>、<code>Received_NOtifyEnd</code>和<code>Received_NotifyTick</code>分别由动画系统在通知状态的开始帧、结束帧和每一帧中调用。在这三个函数接口中我们就可以在动画播放的指定时刻处理自定义的游戏逻辑。</p>
<h3 id="动画同步标记"><a href="#动画同步标记" class="headerlink" title="动画同步标记"></a>动画同步标记</h3><p>动画同步标记的资料目前我只在<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/SkeletalMeshAnimation/Sequences/Notifies/">官方文档</a>有找到，看来看去也没看明白怎么用，只知道动画同步标记是用来同步两个动画序列的，自己测试好像也没有看出有什么效果。</p>
<h1 id="六、姿势资产"><a href="#六、姿势资产" class="headerlink" title="六、姿势资产"></a>六、姿势资产</h1><p>姿势资产(PoseAsset)是UE专门创建出来用于FACS(面部行为编码系统)和视位曲线驱动姿势的面捕动画(也就是我们俗称的面部捕捉)的资产，姿势资产一般配合变形目标一起使用，变形目标提供网格体变形的能力，而姿势资产则可以将这种变形动画混合进入动画蓝图中。</p>
<h2 id="1-创建姿势"><a href="#1-创建姿势" class="headerlink" title="1.创建姿势"></a>1.创建姿势</h2><p>姿势必须依赖于某一个动画序列而存在，我们可以右键动画序列，在Create&#x2F;Create PoseAsset下创建与指定动画序列绑定的姿势，或者右键空白处Animation&#x2F;PoseAsset，然后在姿势创建视图绑定动画序列来创建一个姿势。</p>
<p>创建好姿势后，在姿势编辑器界面中会附带很多的Pose，动画序列每有一个关键帧，姿势资产便会创建一个Pose，这些Pose就是附加在骨骼数据里的曲线。</p>
<h2 id="2-变形目标"><a href="#2-变形目标" class="headerlink" title="2.变形目标"></a>2.变形目标</h2><p>变形目标(MorphTargets)实际上是建模中的一种术语，变形目标和骨骼动画有点类似，都是通过FBX导入，并且都自带网格体资产、动画序列资产和骨骼资产，不同的是变形目标还自带动画曲线。变形目标自带的曲线需要在建模时就名好名字，在UE中无法修改曲线名称。</p>
<p>导入变形目标的FBX是需要勾选<code>网格体/导入变形目标</code>选项，否则导入的FBX将作为普通骨骼网格体导入。</p>
<p>变形目标导入成功后，我们可以在骨骼网格体编辑器的<code>窗口/变形目标预览器</code>视图中看到变形目标自带的所有曲线，修改曲线值可以更改变形目标的形态。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312009261.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312009261.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h2 id="3-使用姿势"><a href="#3-使用姿势" class="headerlink" title="3.使用姿势"></a>3.使用姿势</h2><p>姿势资产和动画序列一样可以直接拖到动画蓝图中以一个节点的形式使用，姿势节点有一个输入引脚一个输出引脚，姿势节点会输入的姿势进行混合然后输出混合好后的姿势。</p>
<p>姿势节点一般配合<code>ModifyCurve</code>(修改曲线)节点使用，修改曲线节点可以通过曲线名称动态的修改动画系统中所有动画曲线的值，修改曲线节点可以在Details&#x2F;Modify Curve&#x2F;Curve Map中绑定一个Map来传递曲线值。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312009161.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312009161.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>这里有一点是需要注意的，变形目标自带曲线，而通过变形目标的动画序列创建的姿势动画系统也会针对每一帧创建曲线，二者之间实际上是有重复的，即变形目标的自带曲线和姿势中的曲线可以控制同一形变，估计是因为变形目标的曲线名称不能在UE中修改，可能会出现美术的命名习惯和程序的命名习惯不一致，所以UE才搞这么一出吧。</p>
<p>所以对于上面的例子，我也可以不使用姿势资产，而通过修改曲线节点直接修改变形目标的自带曲线，如：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312009619.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312009619.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>知道了原理之后我们就可以把变形目标换成人脸表情，我们就可以通过曲线来驱动表情了。</p>
<p>只要传入的面捕数据遵循LiveLink协议，UE就可以将数据传入<code>LiveLinkPose</code>节点来驱动输入动画系统中的对应曲线，UE为我们预制好了LiveLinkRemapAsset重定向资源来做表情的重定向，这个资产我们可以在LiveLinkPose节点的细节面板中看到，对于和标准重定向资源不同的表情控制我们可以继承LiveLinkRemapAsset类来创建自定义的重定向资源，具体可以参见<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/5.1/zh-CN/live-link-in-unreal-engine/">虚幻引擎Live Link</a>。</p>
<h1 id="七、混合空间"><a href="#七、混合空间" class="headerlink" title="七、混合空间"></a>七、混合空间</h1><p>混合空间是UE专门用于混合动画的一种资产，相比与动画蓝图的混合节点，混合空间可以更方便的混合多种动画，并请且可以使用float进行状态控制。创建好的混合空间也可以直接在动画系统的资产浏览器找到，可以将混合空间视为一种特殊的动画序列。</p>
<p>混合空间有两种二维的BlendSpace和一维的BlendSpace1D，二者的用法基本都一样，在混合空间编辑视图里面最重要的就是AssetDetails面板。</p>
<p>这里就挑一些比较重要的，常用的设置讲解一下，其他的可以看[官方文档](<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/5.0/zh-CN/blend-spaces-in-unreal-engine/">虚幻引擎中的混合空间 | 虚幻引擎5.0文档 (unrealengine.com)</a>)</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312009961.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312009961.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>Axis Settings</p>
<ul>
<li><p>Name：指定轴的名称，这个名称也是动画蓝图使用混合空间时对应轴的输入引脚的名称；</p>
</li>
<li><p>Minimum&#x2F;Maximum Axis Value：轴的最小值和最大值。</p>
</li>
<li><p>Grid Divisions：轴的分段，值越大分的段就越多，分段越多动画混合就会准确。</p>
</li>
<li><p>Snap to Grid：勾选后动画系统会自动强制将不在网格顶点的混合点设置到网格顶点上；</p>
</li>
<li><p>Wrap Input：勾选后轴的输入值可以超出最大值和最小值的范围，当输入了超出范围的输入值时混合空间会将轴视为一个圆环，自动匹配输入值在环中的位置，并输出对应的姿势。</p>
</li>
<li><p>Smoothiing Time：值输入后动画更具输入值混合动画时的延迟，这里设置一个比较大数字看起效果可能会更明显，如：设置成2秒，将值设为0则关闭平滑时间。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312009517.gif"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312009517.gif" srcset="/img/loading.gif" lazyload alt="img"></a></p>
</li>
<li><p>Damping Ratio：平滑时间的缓动函数，有平均(Averaged)、线性(Linear)、立方体(Cubic)、慢入&#x2F;慢出(Ease In&#x2F;Out)、指数波(Exponential)和弹簧阻尼系统(Spring Damper)可选。</p>
</li>
<li><p>Max Speed：混合点跟随输入值的最大速度，会影响平滑时间，入我们上面设置的2秒的平滑时间，而实际混合点的跟随延迟并没有两秒，就是因为最大跟随速度是3。</p>
</li>
<li><p>Analysis：混合空间分析，有很多预制分析函数可选择，混合空间分析内容比较多，而且感觉一般情况也用不上，可以直接参见[官方文档](<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/5.0/zh-CN/automatic-blend-space-creation-in-unreal-engine/">虚幻引擎中的自动混合空间创建 | 虚幻引擎5.0文档 (unrealengine.com)</a>)。</p>
</li>
<li><p>Weight Speed：权重速度，功能上和平滑时间差不多，相当于是UE预制的平滑时间，权重越小动画混合的越快，0则关闭权重速度。权重速度不可以与平滑时间或平滑类型一起使用。</p>
</li>
<li><p>Smoothing：启用权重速度的慢入慢出，和权重速度一样不可以与平滑时间或平滑类型一起使用。</p>
</li>
<li><p>Per Bone Overrides：每个骨骼覆盖，可以指定每根骨骼的混合速度。</p>
</li>
<li><p>Notify Trigger Mode：动画通知触发模式，可以设置混合空间中混入的动画序列中动画通知以什么模式触发，可以选择所有动画(All Animations)—触发所有动画序列中的动画通知、最高权重动画(Highest Weighted Animation)—只触发权重最高的动画序列中的动画通知、None—不出触发。</p>
</li>
</ul>
<h1 id="八、目标偏移"><a href="#八、目标偏移" class="headerlink" title="八、目标偏移"></a>八、目标偏移</h1><p>目标偏移是一种特殊的混合空间，用于在一个动画上叠加一个动画混合。</p>
<p>目标偏移从名字就可以看出最初的作用就是用于在持枪动画的基础上叠加瞄准动画用的，当然我们想叠加其他的动画也是可以的。首先我们需要创建一个目标偏移资产，右键内容浏览器空白&#x2F;Animation&#x2F;Anim Offset，目标偏移是一种特殊的二维混合空间，所以编辑界面和混合空间是一样的，和混合空间不同的是一般的动画序列是不可以直接拖入目标偏移的混合视图，我们要想在目标偏移中使用某个动画序列，我们必须对这个动画序列做一些设置。</p>
<p>我们需要设置动画序列的Asset Details&#x2F;Additive Settings如下：</p>
<ul>
<li>Additive Anim Type：Mesh Space；</li>
<li>Base Pose Type：Selected animation frame；</li>
<li>Base Pose Animation：被叠加的动画序列；</li>
<li>Ref Frame Index：0。</li>
</ul>
<p>然后这个动画序列就可以被拖入目标偏移的混合视图去了。</p>
<p>在目标偏移的Asset Details&#x2F;Additive Setttings&#x2F;Preview Base Pose也需要设置成被叠加动画序列。</p>
<p>然后目标偏移资产就可以直接在动画蓝图中使用了。</p>
<p>目标偏移在动画蓝图中是这样的：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312009877.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312009877.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>X，Y引脚分别为设置的横轴纵轴的名称，Base Pose传入要叠加的姿势，Alpha为混合权重。</p>
<p>目标偏移对加入叠加和被叠加的动画有一定的要求，如果二者比较重要的骨骼的偏移有偏差就会出现瞬移或者卡帧的问题，如我在Idle的姿势上叠加了一个被攻击的目标偏移：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312010153.gif"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312010153.gif" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h1 id="九、动画合成"><a href="#九、动画合成" class="headerlink" title="九、动画合成"></a>九、动画合成</h1><p>动画合成的功能很简单，就是单纯的将多个动画序列并接到一起作为一个动画资产来使用。</p>
<p>动画合成资产不具备动画混合能力，但在并接单个动画序列时提供一些简单的处理能力，如：删除动画序列的头尾帧，设置单个序列的播放速率和播放循环次数。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312010807.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312010807.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>Composite即为合成轨道，合成轨道有两个轨道栏，导入的动画序列会由动画系统在两个轨道栏中一次错开，以方便编辑与区分。AssetDetails是这个动画合成资产的属性详情，不过上面的属性也没啥用处，连<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/5.1/zh-CN/animation-composites-in-unreal-engine/">官方文档</a>都懒得说明。</p>
<p>选中一个动画序列会显示这个动画序列在动画合成中属性详情，主要的属性就是开始时间(StartTime)、结束时间(EndTime)、PlayRate(播放速率)和循环次数(LoopCount)，可以对单个动画序列进行简单的编辑。</p>
<p>动画合成也可以向普通的动画序列一样使用动画通知和动画曲线。</p>
<h1 id="十、动画蒙太奇"><a href="#十、动画蒙太奇" class="headerlink" title="十、动画蒙太奇"></a>十、动画蒙太奇</h1><p>动画蒙太奇可以算是一个高级版的动画合成，动画蒙太奇的功能也是将多个动画序列并接成一个资产，但相对与动画合成，动画蒙太奇的功能要强大得多，动画蒙太奇提供一种程序精确控制动画的方式。动画蒙太奇的作用是和状态机互补的，尽管状态机的功能很强大，但是也有不足的地方，比如当一个角色有10个技能，每个技能又由一系列的动画序列组成的时候，每个技能又由不能的按键触发，再加上角色基础的移动、跳跃等状态和一些只有在特殊场合才使用的动画，要只通过状态机实现这样的动作组，状态机会变得非常复杂，控制逻辑也会变得非常复杂，动画蒙太奇就可以弥补状态机的这一缺点，我们可以将10个技能和一些额外的动画都做成动画蒙太奇，这些蒙太奇可以使用一个或几个蒙太奇插槽混入状态机中，然后通过程序直接控制播放可以极大的减小状态机的复杂度。</p>
<p>动画蒙太奇编辑视图和动画合成编辑视图长得基本一样，使用上也大差不差，在编辑一段自己的动画蒙太奇之前我们需要先了解两个概念。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312010982.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312010982.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h2 id="1-蒙太奇分段"><a href="#1-蒙太奇分段" class="headerlink" title="1.蒙太奇分段"></a>1.蒙太奇分段</h2><p>可以看到动画蒙太奇编辑视图相对于动画合成编辑视图多了一个Montage轨道，这个轨道就是用来处理蒙太奇分段的，蒙太奇分段就是动画轨道上的一个时间片段，如上图中Montage轨道上就有三个分段，分段所在的帧即为分段的起始帧，分段会将下一个分段的起始帧或动画蒙太奇的结束帧作为分段的结束帧，当一个分段之后还有其他分段则使用下一个分段的其实帧作为这个分段的结束帧，当一个分段之后没有其他的分段了则使用动画蒙太奇的结束帧作为这个分段的结束帧。如上图Pose1的结束帧就是Pose2的起始帧，Pose3的结束帧就是整个轨道的最后一帧。</p>
<h3 id="创建蒙太奇分段"><a href="#创建蒙太奇分段" class="headerlink" title="创建蒙太奇分段"></a>创建蒙太奇分段</h3><p>右键Montage轨道即可创建一个新的蒙太奇分段，创建的蒙太奇分段都会在Timing轨道带一个序号标签，这个序号标签就是单纯用来标识的，没有其他作用也不能选中，所有的分段都会显示在MontageSections视图中。</p>
<h3 id="编辑蒙太奇分段"><a href="#编辑蒙太奇分段" class="headerlink" title="编辑蒙太奇分段"></a>编辑蒙太奇分段</h3><p>创建好蒙太奇分段后可以直接拖动分段来设定分段的起始帧位置，在MontageSections中会默认将新创建的分段自动连接在一起，大多数情况下我们是不希望那所有分段都连接在一起的，所以我们可以点击Clear按钮清除所有连接，或者点击箭头&#x2F;Remove Link来断开指定连接。</p>
<p>在MontageSections视图中没有连接其他分段的分段的后面会有一个白色正方形按钮，点击即可选择这个分段之后想要连接哪个分段。</p>
<p>当几个分段连接在一起之后，动画蒙太奇会在播放完第一个分段后按照播放链一次播放后面的片段。</p>
<h2 id="2-蒙太奇插槽"><a href="#2-蒙太奇插槽" class="headerlink" title="2.蒙太奇插槽"></a>2.蒙太奇插槽</h2><p>蒙太奇插槽指定就是动画蒙太奇编辑视图中的Group轨道，在创建一个新的动画蒙太奇时动画系统会设置这个动画蒙太奇到DefaultGroup.DefaultSlot轨道，即默认分组下的默认插槽。</p>
<h3 id="创建蒙太奇插槽"><a href="#创建蒙太奇插槽" class="headerlink" title="创建蒙太奇插槽"></a>创建蒙太奇插槽</h3><p>如果我们要创建自己的插槽，需要在Anim Slot Manger视图中操作，分组和文件夹的作用一样，用于管理各个插槽。</p>
<p>一个动画蒙太奇资产可以包含多个插槽，要添加更多的插槽进入轨道，只需要点击Group的下拉三角选择New Slot，即可添加所有的已被创建的插槽。</p>
<h3 id="使用蒙太奇插槽"><a href="#使用蒙太奇插槽" class="headerlink" title="使用蒙太奇插槽"></a>使用蒙太奇插槽</h3><p>编辑好的动画蒙太奇是不能向动画合成一样直接拖入动画蓝图中使用的，而是需要通过蒙太奇插槽混合进入动画状态中。</p>
<p>蒙太奇插槽直接在动画蓝图中是搜索不到的，我们需要使用默认插槽(Slot Defaultslot)来切换，点击默认插槽在Details&#x2F;Settings&#x2F;Slot Name可以进行插槽切换。</p>
<p>蒙太奇插槽在没有播放动画蒙太奇时不会影响动画蓝图其他节点，在播放动画蒙太奇时将直接忽略插槽之前的状态，插槽的输出引脚将只输出动画蒙太奇的状态。</p>
<h2 id="3-播放动画蒙太奇"><a href="#3-播放动画蒙太奇" class="headerlink" title="3.播放动画蒙太奇"></a>3.播放动画蒙太奇</h2><p>只要把动画蒙太奇分段和插槽理解到位了，动画蒙太奇的精髓也就掌握了，接下来就是使用了。播放动画蒙太奇的方法就一个蓝图节点：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312010505.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312010505.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<ul>
<li>In Skeletal Mesh Component：要应用动画蒙太奇的骨骼网格体组件，骨骼网格体组件绑定的骨骼和动画蒙太奇绑定的骨骼必须是一致的；</li>
<li>Montage to Play：要应用的动画蒙太奇资产；</li>
<li>Play Rate：整个动画蒙太奇播放的速率；</li>
<li>Starting Position：播放的起始时间；</li>
<li>Starting Section：要播放的蒙太奇分段；</li>
<li>On Completed：蒙太奇播放完后调用；</li>
<li>On Blend Out：混出时调用，这个混出就是动画蒙太奇资产属性的混合设置下的混出，类似于视频的淡出；</li>
<li>On Interrupted：在动画蒙太奇播放被中断时调用；</li>
<li>On Notify Begin：在蒙太奇通知或蒙太奇通知窗口开始激活时调用；</li>
<li>On Notify End：在蒙太奇通知窗口结束时调用；</li>
<li>Notify Name：当前活跃的动画通知名称。</li>
</ul>
<p>除了Play Montage节点UE还提供了一个更简洁的节点Play Anim Montage：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312011088.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312011088.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>通过上面的这些知识点我们就可以制作一个角色出场动画了，这里使用两断动画来并接出一个出场动画：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312011133.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312011133.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>先再Anim Slot Manager创建一个自定义的插槽StartPose，点击下拉三角在Slot Name选择新创建的插槽，然后拖入两断动画序列进入轨道。</p>
<p>创建三个分段，Pose1、Pose2、Pose3，我们需要的是Pose1分段和Pose3分段，所以在Montage Sections视图将Pose1连接到Pose3。</p>
<p>在动画蓝图添加默认的插槽节点并切换到自定义的插槽。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312011709.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312011709.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>然后在角色蓝图的BeginPlay播放动画蒙太奇的Pose1分段：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312011538.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312011538.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>然后来看一下效果：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312011972.gif"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312011972.gif" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>可以看到角色在播放蒙太奇的过程中有出现跳帧的情况，这是因为我们使用了带根位移的动画，像这种出场动画我们是希望动画带位移，我们想要使用动画的位移这就涉及到另一个知识点—蒙太奇与根运动。</p>
<h2 id="4-蒙太奇与根运动"><a href="#4-蒙太奇与根运动" class="headerlink" title="4.蒙太奇与根运动"></a>4.蒙太奇与根运动</h2><p>说起来也简单，要应用动画序列的根位移我们只需要勾选带有根位移的动画序列的Details&#x2F;RootMotion&#x2F;EnableRootMotion，这样动画系统就会自动计算动画位移和角色位移，然后我们再来看一下效果：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312012528.gif"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312012528.gif" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>效果已经很可以了。</p>
<h2 id="5-蒙太奇通知"><a href="#5-蒙太奇通知" class="headerlink" title="5.蒙太奇通知"></a>5.蒙太奇通知</h2><p>蒙太奇通知是专门用于动画蒙太奇的动画通知，创建方式上和普通动画通知一样，使用上有些差别，蒙太奇通知不会在动画蓝图中创建对应的事件，而是由PlayMontage节点触发，当我们使用PlayMontage节点播放蒙太奇动画，在动画播放到蒙太奇通知所在帧时就会触发On Notify Begin回调，一个动画蒙太奇中有多少个蒙太奇通知就会回调多少次。</p>
<p>蒙太奇通知有三类，Montage Notify、Montage Notify Window和Disable Root Motion。</p>
<ul>
<li>Montage Notify：蒙太奇通知对应普通的动画通知，激活时会回调PlayMontage节点的On Notify Begin；</li>
<li>Montage Notify Window：蒙太奇通知窗口对应普通的动画通知状态，开始激活时会回调PlayMontage节点的On Notify Begin，结束激活时会回调PlayMontage节点的On Notify End；</li>
<li>Disable Root Motion：禁用骨骼运动这个动画通知有点特殊，作用就是在激活期间禁用动画序列的根位移，有时动画蒙太奇会使用动画序列的根位移，比如上面的例子，但使用了根位移我们就没法控制角色的移动了，有时可能在蒙太奇播放的某个时间断里我们想要控制角色移动，Disable Root Motion就可以满足这种精确控制。Disable Root Motion使用上和蒙太奇通知窗口类似，但是Disable Root Motion不会触发PlayMontage的回调，甚至不能修改通知的名称。</li>
</ul>
<p>现在我们用蒙太奇通知来为出场动画加一些特效，制作在大剑与地面接触时产生爆炸的效果。</p>
<p>首先在骨骼上的武器骨骼上加一个骨骼插槽weaponSlot，然后在动画蒙太奇中添加两个蒙太奇通知。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312012520.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312012520.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>然后在角色蓝图中编写特效触发逻辑：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312012737.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312012737.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>然后来看一下效果：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312013266.gif"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312013266.gif" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h2 id="6-子蒙太奇"><a href="#6-子蒙太奇" class="headerlink" title="6.子蒙太奇"></a>6.子蒙太奇</h2><p>动画蒙太奇还可以创建类似子类的子蒙太奇，子蒙太奇所有属性包括分段、动画通知都和父蒙太奇一样，且不可更改，唯一能更改的就是插槽轨道中的动画序列，子蒙太奇的作用就是相同的动画蒙太奇配置应用不同的动画序列来适应不同的场景。</p>
<h1 id="十一、动画蓝图"><a href="#十一、动画蓝图" class="headerlink" title="十一、动画蓝图"></a>十一、动画蓝图</h1><p>动画蓝图是整个动画系统的终点，所有的动画序列经过骨骼定向、混合、编译调整、融合之后，都通过动画蓝图整合在一起，给予角色使用。</p>
<p>动画蓝图均集成自AnimationInstance类，并且创建时需要绑定骨骼，这也印证了UE的动画系统都是基于骨骼的，一切的一切都要在骨骼之上才能应用。</p>
<h2 id="1-动画蓝图编辑器"><a href="#1-动画蓝图编辑器" class="headerlink" title="1.动画蓝图编辑器"></a>1.动画蓝图编辑器</h2><p>动画蓝图是动画系统专用蓝图，和不普通蓝图编辑器界面有所不同，动画蓝图有两个Graph，Event Graph和Anim Graph，Event Graph就是普通的蓝图编辑视图，普通蓝图能干的事它都能干，提供一个每帧调用的Event Blueorint Update Animation事件。Anim Graph则是专门的动画编辑视图，用于对动画做控制，如姿势混合、曲线控制、动画序列的读取以及状态机等都在这个视图编辑，视图提供一个最终输出OutputPose，动画可以在Anim Grahp中经过各种各样的编辑修改，但最终都只能连接上OutputPose来输出给角色。</p>
<p>按<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.27/zh-CN/AnimatingObjects/SkeletalMeshAnimation/AnimBlueprints/">官方</a>的说话，二者是相互配合工作的，Event Graph用于更新Anim Graph所需的数据，而Anim Graph使用这些数据驱动状态机、混合空间等驱动角色运动。</p>
<h2 id="2-Event-Graph常用节点"><a href="#2-Event-Graph常用节点" class="headerlink" title="2.Event Graph常用节点"></a>2.Event Graph常用节点</h2><p>动画蓝图的Event Graph有一些特殊的预定义事件。</p>
<h3 id="BlueprintBeginPlay"><a href="#BlueprintBeginPlay" class="headerlink" title="BlueprintBeginPlay"></a>BlueprintBeginPlay</h3><p>效果和常用的BeginPlay事件一样，在游戏开始时调用一次。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312013041.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312013041.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h3 id="BlueprintInitializeAnimation"><a href="#BlueprintInitializeAnimation" class="headerlink" title="BlueprintInitializeAnimation"></a>BlueprintInitializeAnimation</h3><p>BlueprintInitializeAnimation的调用有点类似构造函数，应该是在动画蓝图被构造的时候由系统在构造函数里调用的，在编译和实例化动画蓝图时会被调用一次。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312013679.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312013679.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h3 id="BlueprintUpdateAnimation"><a href="#BlueprintUpdateAnimation" class="headerlink" title="BlueprintUpdateAnimation"></a>BlueprintUpdateAnimation</h3><p>在PIE和Runtime都会每帧都会调用一次</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312013197.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312013197.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h3 id="BlueprintLinkAnimationLayersLayersInitialized"><a href="#BlueprintLinkAnimationLayersLayersInitialized" class="headerlink" title="BlueprintLinkAnimationLayersLayersInitialized"></a>BlueprintLinkAnimationLayersLayersInitialized</h3><p>BlueprintLinkAnimationLayersLayersInitialized节点在链接动画层初始化时会被调用一次，按照官方的说法是：</p>
<blockquote>
<p>在所有链接动画层初始化时激活连接的节点。您可以使用此节点运行一次逻辑，一旦所有链接的动画层首次初始化，该逻辑就会被激活。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312013350.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312013350.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h3 id="BlueprintPostEvaluateAnimation"><a href="#BlueprintPostEvaluateAnimation" class="headerlink" title="BlueprintPostEvaluateAnimation"></a>BlueprintPostEvaluateAnimation</h3><p>BlueprintPostEvaluateAnimation的作用我始终没看懂，按照官方的说法就是：</p>
<blockquote>
<p>在评估 AnimBP 后激活顺序节点。使用此节点，您可以激活将在评估 AnimBP 后运行的逻辑</p>
</blockquote>
<p>BlueprintPostEvaluateAnimation和BlueprintUpdateAnimation一样在PIE和Runtime都会每帧调用一次</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>出来上面的几个事件外，动画蓝图还可以直接调用InputAction，即在设置界面配置的按键绑定事件。</p>
<h2 id="3-Anim-Graph常用节点"><a href="#3-Anim-Graph常用节点" class="headerlink" title="3.Anim Graph常用节点"></a>3.Anim Graph常用节点</h2><h3 id="空间转换节点"><a href="#空间转换节点" class="headerlink" title="空间转换节点"></a>空间转换节点</h3><p>空间转换节点有两个，LocalToComponent和ComponentToLocal。</p>
<p>在UE的动画系统中常规的动画姿势是运行在局部空间中的(这个局部空间个人理解应该就是以根骨骼为参照的局部坐标系)，但是所有的骨骼控制节点和一些混合节点则是运行在组件空间中的(组件空间个人理解应该是以父骨骼为参照的局部坐标系)，当需要对组件空间中的姿势做控制时就需要这两个节点做空间转换，所以两个节点一般成对出现。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312013831.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312013831.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>其中白色代表局部空间数据流，蓝色代表组件空间数据流。</p>
<h3 id="LayeredBlendPerBone"><a href="#LayeredBlendPerBone" class="headerlink" title="LayeredBlendPerBone"></a><strong>LayeredBlendPerBone</strong></h3><p>这个节点的中文名为<code>每个骨骼的分层混合</code>。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312013628.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312013628.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>节点的作用就是在基础姿势上从骨骼的层级上混合其他姿势到基础姿势中。</p>
<p>这里以第三人称模板的跑步姿势为基础姿势，然后往这个姿势中混合一个抬剑的姿势作为例子。</p>
<p>首先从Epic商城中找到<code>Bossy Enemy Animation Pack</code>姿势包，然后导入到我们的项目中来。使用第二章骨骼第7小节骨骼重定向中重定向链的方式让小红人使用小白的动画序列，然后在动画蓝图做动画混合：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312014222.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312014222.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>这里Boss_BattleEntrance_RM就是抬剑姿势。</p>
<ul>
<li>Base Pose：需要被混合的基础姿势；</li>
<li>Blend Poses 0：需要加入混合的0号新姿势；</li>
<li>Blend Weights 0：0号新姿势混入基础姿势的权重；</li>
<li>Add pin：添加新的混合姿势；</li>
</ul>
<p>到这一步混合还是不能生效的，我们还需要再节点细节面板中对要进入混合的骨骼做过滤。</p>
<p>在节点的细节面板中对骨骼进行配置：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312014044.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312014044.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>深度混合代表骨骼参与混合的程度，0表示不参与混合，1表示完全取代基础骨骼变化，0-1之间则表示不同程度的混合，-1表示完全不参与混合，骨骼完全不会影响原骨骼。</p>
<p>然后运行一下看看效果：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312014092.gif"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312014092.gif" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>LayeredBlendPerBone节点有两种模式Branch Filter和Blend Mask，在Details&#x2F;Config&#x2F;Blend Mode中可以切换两种模式，前面使用的就是Branch Filter–骨骼筛选，Blend Mask–骨骼遮罩可以做到比Branch Filter更精准具体的混合。</p>
<p>要使用骨骼遮罩我首先需要在骨骼编辑器中创建骨骼遮罩。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312014759.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312014759.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>在BlendMasks栏显示的是已经存在的骨骼遮罩资产，创建好骨骼遮罩后骨骼编辑器会在骨骼树的右侧新增一列骨骼遮罩列，骨骼遮罩会对每一根骨骼都设有权重，权重为0表示这根骨骼上的叠加姿势完全不会应用到这个骨骼上，权重为1表示在这根骨骼上完全应用叠加姿势，权重介于0-1则根据权重值在这根骨骼上做姿势混合。</p>
<p>鼠标放置在骨骼遮罩列列头上会在列头显示设置菜单，在菜单中可以做切换骨骼遮罩和删除骨骼遮罩等操作。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312014725.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312014725.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>这里我以走路姿势叠加一个被攻击的姿势作为例子。</p>
<p>这里我们我们把上半身的骨骼的遮罩权重全部设置成1，下半身的骨骼的遮罩权重全部设置成0，这样就可以实现一个在走路的过程中被攻击的动作。</p>
<p>设置好之后，就可以在LayeredBlendPerBone节点中应用了，在Details&#x2F;Config&#x2F;Blend Masks中使用我们新创建的骨骼遮罩BlendMask，然后编译，看一下效果：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312014901.gif"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312014901.gif" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>感觉走起路来会飘，这是因为有一些骨骼是两个姿势都会使用且比较重要的，我们不能一刀切将骨骼遮罩权重设置1和0，所以我们在微调一下骨骼遮罩的权重，这里我们把root和pelvis骨骼的设置为0，将spine_01、spine_02、spine_03骨骼设置为0.5，然后再来看看效果：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312015041.gif"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312015041.gif" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>可以看到效果就已经好很多了。</p>
<p>LayeredBlendPerBone节点的骨骼遮罩模式除了可以是使用骨骼遮罩(BlendMask)外还可以使用混合描述，混合描述又分为TimeBlendProfiles和WeightBlendProfiles，这些都是一些比较细微的混合了，感觉属于高端玩法了，一般情况也用不上，所以这里就不列举了，具体用处与功效可以参见<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/5.0/zh-CN/blend-masks-and-blend-profiles-in-unreal-engine/">官方文档</a>。</p>
<h3 id="Blend"><a href="#Blend" class="headerlink" title="Blend"></a><strong>Blend</strong></h3><p>Blend节点功能上和LayeredBlendPerBone一样，只是Blend不能做骨骼过滤，且只能做两个姿势的混合，使用上比LayeredBlendPerBone更方便，Blend不会做骨骼过滤，所以性能上会比LayeredBlendPerBone强，所以在不需要做骨骼过滤的情况下更合适。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312015626.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312015626.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h3 id="BlendMulti"><a href="#BlendMulti" class="headerlink" title="BlendMulti"></a><strong>BlendMulti</strong></h3><p>BlendMulti是Blend的多输入版，默认是两个输入引脚，右键节点&#x2F;Add Blend Pin可以向节点添加新的引脚，选中引脚右键&#x2F;Remove Blend Pin可以删除引脚，并且BlendMulti没有了基础姿势，所有的姿势都可以设置权重。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312015515.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312015515.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h3 id="BlendPosesByBool"><a href="#BlendPosesByBool" class="headerlink" title="BlendPosesByBool"></a><strong>BlendPosesByBool</strong></h3><p>这是一个姿势的切换节点，可以根据输入的Bool值在两个姿势之间进行切换。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312016454.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312016454.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h3 id="BlendPosesByInt"><a href="#BlendPosesByInt" class="headerlink" title="BlendPosesByInt"></a><strong>BlendPosesByInt</strong></h3><p>BlendPosesByInt就是BlendPosesByBool的多输入版本，通过Int值来在多个姿势之间做切换，引脚的添加与删除和BlendMulti一样。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312016243.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312016243.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h3 id="BlendBoneByChannel"><a href="#BlendBoneByChannel" class="headerlink" title="BlendBoneByChannel"></a>BlendBoneByChannel</h3><p>BlendBoneByChannel节点的功能很强大，除了不能添加更多的输入引脚功能上比LayeredBlendPerBone节点还强大，BlendBoneByChannel不仅可以筛选骨骼，甚至可以筛选骨骼的Translation、Rotation、Scale变换和应用的坐标空间，在节点的Details&#x2F;Blend&#x2F;Bone Definitions中可以添加要应用的骨骼和要应用的变换，SourceBone是基础姿势的骨骼，TargetBone是附加姿势的骨骼。在Details&#x2F;Blend&#x2F;Transform Space可以选择混合要应用的坐标空间。</p>
<p>如我们在走路姿势上附加一个被攻击的姿势，但只应用右手手臂的动作。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312016635.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312016635.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>设置骨骼筛选</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312016172.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312016172.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>最终效果：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312016034.gif"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312016034.gif" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>可以和下面的ApplyAdditive节点的效果对比看会更明显。</p>
<h3 id="ApplyAdditive"><a href="#ApplyAdditive" class="headerlink" title="ApplyAdditive"></a>ApplyAdditive</h3><p>ApplyAdditive节点的作用是动画附加，可以将一个动画附加在基础动画之上，要附加的动画序列需要做特殊的处理，即动画序列编辑器中的AssetDeltails视图&#x2F;Additive Settings&#x2F;Additive Anim Type设置为Local Space，Base Pose Type 设置为Selected animation frame，然后Base Pose Animation选择一个参考姿势，参考姿势的作用是附加动作和参照动作一样动作的地方在后续附加在其他动作上时会被忽略，不同的就会附加。</p>
<p>如我们在走路姿势上附加一个被攻击的姿势：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312016350.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312016350.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312016618.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312016618.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>然后效果：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312016983.gif"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312016983.gif" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>混合的还是很好的，效果基本和LayeredBlendPerBone差不多了。</p>
<p>ApplyAdditive和Blend的区别就是ApplyAdditive是附加动画到基础动画上，由于有一个参照姿势进行动作过滤，所以混合起来效果会更好，而Blend则直接将两个姿势混合，所有的骨骼都会根据权重互相影响，在这种情况下混合起来效果就没那么好，不过Blend很适合做步态的混合。</p>
<h3 id="BlendPosesByEnum"><a href="#BlendPosesByEnum" class="headerlink" title="BlendPosesByEnum"></a>BlendPosesByEnum</h3><p>这个节点的名字不是固定，是根据需要应用的枚举类型变化的，如我有一个枚举叫BlendEnum，那么我在搜索BlendPosesByEnum节点的时候就不是搜索BlendPosesByEnum而是搜索BlendPosesBlendEnum，直接搜索BlendPosesByEnum会列出系统所有的枚举在BlendPosesByEnum的应用。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312016063.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312016063.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>BlendPosesByEnum节点的作用就是可以根据枚举中值来添加输入引脚，引脚会根据枚举的值来命名，并且使用枚举来做姿势切换，BlendPosesByEnum还提供一个默认姿势，当没有添加任何引脚时就会使用默认姿势。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312016962.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312016962.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>BlendPosesByEnum节点默认是没有添加枚举中定义的引脚的，需要手动右键进行添加。</p>
<h3 id="ApplyMeshSpaceAdditive"><a href="#ApplyMeshSpaceAdditive" class="headerlink" title="ApplyMeshSpaceAdditive"></a>ApplyMeshSpaceAdditive</h3><p>这个节点在网上的资料实在是找不到，官方文档也没有说明，只在Youtubo上找到了一个<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=154aGaLIid0">视频案例</a>使用方式和ApplyAdditive基本一样，只是动画序列里的AssetDetails&#x2F;AdditiveSettings&#x2F;AdditiveAnimType选择MeshSpace。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312017959.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312017959.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h3 id="MakeDynamicAdditive"><a href="#MakeDynamicAdditive" class="headerlink" title="MakeDynamicAdditive"></a>MakeDynamicAdditive</h3><p>MakeDynamicAdditive的作用正好和ApplyAdditive相反，MakeDynamicAdditive是从基础姿势中减去附加姿势。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312017279.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312017279.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h3 id="Inertialization"><a href="#Inertialization" class="headerlink" title="Inertialization"></a>Inertialization</h3><p>Inertialization(惯性化)节点按照官方的说法是用来做高性能优化的，一旦启用了惯性化，那么动画系统将不再进行姿势混合计算，而是使用惯性化来输出姿势，可能是我测试的动画根本不吃什么性能，所以我实际使用中没有感觉有什么作用😂。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312017303.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312017303.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h3 id="ModifyCurve"><a href="#ModifyCurve" class="headerlink" title="ModifyCurve"></a>ModifyCurve</h3><p>ModifyCurve节点用于在动画蓝图中驱动动画序列里创建的动画曲线。可以右键添加和删除曲线引脚。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312017485.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312017485.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h3 id="LiveLinkPose"><a href="#LiveLinkPose" class="headerlink" title="LiveLinkPose"></a>LiveLinkPose</h3><p>LiveLinkPose是UE专门开发用于接收动捕、表捕、手捕设备实时数据的节点，LiveLinkPose可以直接将这些实时数据混合成姿势用于角色动画的姿势混合中，如在播放指定动画序列时混入脸捕数据。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312017621.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312017621.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>LiveLinkPose节点由LiveLink插件提供，需要启用LiveLink插件才能搜索到这个节点，在LiveLinkSubjectName中输入LiveLink视图配置的数据源名称即可实时接收到源传递过来的数据，并与输入姿势混合，并且输出一个带有实时数据的混合姿势。</p>
<h2 id="4-状态机"><a href="#4-状态机" class="headerlink" title="4.状态机"></a>4.状态机</h2><p>状态机是动画蓝图里面一个非常重要的模块，用于管理复杂的姿势混合。</p>
<p>一个角色可能会有很多动画，或者各种技能，当这大量的动作姿势在AnimGraph混合的时候会导致视图非常复杂，在普通蓝图中可以使用函数、宏、事件来封装或者使用节点来组合，而动画蓝图则使用状态机来封装。</p>
<p>一个状态机由若干的状态(State)、导管(Conduit)、状态别名(Alias)、转换规则以及唯一的入口(Entry)组成。</p>
<h3 id="创建状态机"><a href="#创建状态机" class="headerlink" title="创建状态机"></a>创建状态机</h3><p>直接在AnimGraph视图右键搜索State Machines即可创建一个状态机。状态机在表现上和普通蓝图的节点很相似。状态机没有输入引脚只有输出引脚，并且输出的也是一个姿势。</p>
<p>创建好状态机后就可以双击进入状态机节点，对状态机进行编辑了。</p>
<h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>State是用来封装姿势混合过程的节点，一个State输出一个最终姿势，State节点可双击进入进行姿势混合编辑。</p>
<p>每一个状态都可以在Details&#x2F;AnimationState中定义三个回调事件，分别是进入状态事件(EnteredStateEvent)、离开状态事件(LeftSatateEvent)和完全混合状态事件(FullyBlendedStateEvent)，在CustomBlueprintEvent处填写自定义事件名称，就可以为这个状态创建三个动画通知回调事件，和普通的动画通知效果一样，直接在EventGraph中搜索即可使用。</p>
<h3 id="Transition-Rule"><a href="#Transition-Rule" class="headerlink" title="Transition Rule"></a>Transition Rule</h3><p>我们从一个State1节点的边缘按住鼠标左键拖动到另一个State2节点的边缘即可创建State1转换到State2的TransitionRule，TransitionRule由一个箭头加一个转换节点组成，转换节点可双击进入，转换节点固定输出一个bool值，只有返回true时才可转换到所指向的State，转换节点中可以编写一些bool表达式逻辑，由于转换规则没有输入引脚，所以在转换规则编辑视图中是不可以直接调用带输入输出流程引脚的函数的，不过可以使用纯函数，所以一些比较复杂的bool表达式可以使用纯函数封装。</p>
<p>在转换规则中UE定制了几个转换专用的纯函数蓝图节点，不过个人感觉一般也不怎么用得上，所以就直接上官方文档链接了—[虚幻引擎中的转换规则](<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/5.0/zh-CN/transition-rules-in-unreal-engine/">虚幻引擎中的转换规则 | 虚幻引擎5.0文档 (unrealengine.com)</a>)。</p>
<p>除了纯函数函数蓝图节点外，UE也为转换规则定制了几个动画通知函数。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312017137.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312017137.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>这些动画通知函数除了<code>WasAnim Notify State Active in Any State</code>外，其他的都只能在转换规则中使用。这些通知主要分为三类：</p>
<ul>
<li>Was Anim Notify Name Triggered In Any State：在转换规则之前的任何状态中如果指定名称的动画通知被触发则返回true；</li>
<li>Was Anim Notify State Active In Any State：在转换规则之前任何状态中如果指定类型的动画通知状态被激活了则返回true；</li>
<li>Was Anim Notify Triggered In Any State：在转换规则之前任何状态中如果指定类型的动画通知被触发了则返回true；</li>
<li>Was Anim Notify Name Triggered In Source：在转换规则之前的活动状态中如果指定名称的动画通知被触发则返回true；</li>
<li>Was Anim Notify State Active In Source：在转换规则之前活动状态中如果指定类型的动画通知状态被激活了则返回true；</li>
<li>Was Anim Notify Triggered In Source：在转换规则之前活动状态中如果指定类型的动画通知被触发了则返回true；</li>
<li>Was Anim Notify Name Triggered In State Machine：在转换规则之前的指定状态中如果指定名称的动画通知被触发则返回true；</li>
<li>Was Anim Notify State Active In State Machine：在转换规则之前指定状态中如果指定类型的动画通知状态被激活了则返回true；</li>
<li>Was Anim Notify Triggered In State Machine：在转换规则之前指定状态中如果指定类型的动画通知被触发了则返回true；</li>
</ul>
<p>除了上面的几个通知外，转换规则也和状态也样Details&#x2F;Notifications下提供了三个自定义动画通知，开始过渡事件(Start Transition Event)、终止过渡事件(End Transition Event)和中断过渡事件(Interrupt Transition Event)。</p>
<p>而对于中断过渡事件UE提供了更高端的设置，在Details&#x2F;Events&#x2F;TransitionInterrupt下可以设置更详细的中断配置。</p>
<p><strong>Transition Rule Details</strong></p>
<ul>
<li><p>Priority Order：转换规则的优先级，当同一时刻有多个转换规则满足转换要求时，动画系统将选择优先级数字最小的优先转换。</p>
</li>
<li><p>Bidirectional：这个设置官方已经放弃使用了。</p>
</li>
<li><p>Transiton&#x2F;Blend Logic：选择当前转换规则所使用的从前一个状态转换到下一个状态的混合模式，提供标准混合(Standard Blend)、惯性化混合(Interialization)和自定义(Custom)三种，选择不同的模式在Blend Settings下就可以设置不同选项。选择自定义模式在Blend Logic下拉列表后面会多出一个按钮Edit Blend Graph，点击按钮能进入自定义混合模式编辑界面，即可编辑自己的转换规则混合模式。</p>
<p>UE为转换规则自定义混合视图也定制了四个专用的蓝图纯函数节点：</p>
<p>SateWeight：获取上一个状态的混合权重。该数字在转换时长内逐渐从 1 减小到 0。</p>
<p>GetTransitoinTimeElapsed： 获取指定转换的耗时（以秒为单位）。</p>
<p>GetTransitionTimeElapsed(Ratio)：获取指定转换的耗时（以交叉转换时长的比例表示）。换句话说，该数字在转换时长内逐渐从 0增大到 1。</p>
<p>GetTransitionCrossfadeDuration：获取指定转换的交叉转换时长。这是 混合设置（Blend Settings）&gt; 时长（Duration）属性中使用的数字。</p>
</li>
<li><p>Transition Rule Sharing：设置共享转换图表，在编辑状态机的时候有些转换规则的转换逻辑可能都是一样的，此时我们无需去编辑每一个转换规则，我们只需要编辑其中一个，然后点击Transition Rule Sharing栏后面的(Promote to Shared)按钮输入共享视图的名称，将这个转换规则的视图提升为共享视图，编译后我们在其他的转换规则的Transition Rule Sharing的下拉列表就可以看到新创建的共享视图了，选择即可应用共享视图，应用了共享视图的转换规则节点UE会自动为节点配色，以便区分。</p>
</li>
<li><p>Automatic Rule Based on Sequence Player in State：启动后转换规则会在上一个状态中最相关的动画结束时自动混入下一个状态，而不用编写转换逻辑。</p>
</li>
<li><p>Sync Group Name to Require Valid Markers Rule：和同步组配合使用，使用了同步组后只有在上一个状态包含了同步组标识的动画序列时这个转换规则才生效。</p>
</li>
<li><p>Transition Crossfade Sharing：应用共享Blend Settings，点击后面的Promote To Shared按钮可以将当前设置提升为共享设置，编译后即可在其他的转换规则节点中使用这个设置，修改设置时会同步所有转换规则。</p>
</li>
<li><p>Dureation：转换所需要的时间长度。</p>
</li>
<li><p>Mode：转换混合时使用的曲线类型，按住Ctrl+Alt可以查看曲线预览。</p>
</li>
<li><p>Custom Blend Curve：设置自定义曲线。</p>
</li>
<li><p>Blend Profile：设置转换规则要应用的混合描述。</p>
</li>
</ul>
<p>共享转换规则作用域只在单个状态机中，在其他的状态机中读取不到，并且状态到导管，和状态到状态的共享转换规则也不通用。</p>
<h3 id="Conduit"><a href="#Conduit" class="headerlink" title="Conduit"></a>Conduit</h3><p>导管(Conduit)是用来给状态梳理转换流程的，导管可以看作是一种特殊的转换规则，普通转换规则只能在状态之间进行一对一转换，导管则可以实现一对一、一对多、多对一和多对多的转换。双击导管节点可进入导管编辑视图，导管编辑视图和转换规则一样也只返回一个bool值。导管的Details视图只有一个名称属性，没有其他任何属性。</p>
<p>如这样的一个状态机：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312017654.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312017654.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>我就可以用导管疏导成这样：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312017435.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312017435.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>这在一些极为复杂的状态机中很有用。</p>
<p>如果想要从Entry直接连接到导管，则需要勾选状态机的Details&#x2F;Settings&#x2F;Allow Conduit Entry States选项。</p>
<h3 id="Alias"><a href="#Alias" class="headerlink" title="Alias"></a>Alias</h3><p>状态别名(Alias)的作用和导管一样也是对复杂的状态转换进行疏导，状态别名可以看成若干个状态节点的集合的别名，这里的别名可以直接理解为编程语言中的别名，我们可以在状态别名的Details&#x2F;State Alias下勾选状态机中哪些状态属于集合，当集合中的任一状态激活时，别名也同时会被激活。</p>
<p>如上面的状态机，我们可以使用别名来疏导成这样：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312017749.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312017749.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h3 id="状态机属性"><a href="#状态机属性" class="headerlink" title="状态机属性"></a>状态机属性</h3><ul>
<li>Max Transitions Per Frame：设置在整个状态机中一帧内可以同时发生的转换的数量，默认值是3，表示在一帧内如果满足转换条件则可以同时触发三个转换，三个转换会在系统的配置下或根据优先级或根据默认规则彼此竞争最终使用一个转换，如果设置成1，则一帧内只能做出一个转换决策，从而避免多个转换之间互相竞争。</li>
<li>Max Transitions Requests：这个属性应该UE5.1新加的，我在UE5.0的官方文档中没有找到这个属性的介绍，直接机翻的意思是”可以随时取消的最大转换请求数。删除最早的转换请求以适应新创建的请求”，应该也是和转换相关的。</li>
<li>Skip First Update Transition：勾选此选项，当状态机初始化时如果转换规则满足则直接进入对应的状态，不勾选则初始化时及时满足转换规则也不会进入对应状态而是依旧处于默认状态。实际使用中似乎感觉这个选项没什么乱用，效果只会在状态机初始化时执行一次，之后要想效果再生效就只能重启引擎让状态机再初始化一次，并且不会影响运行时的效果。</li>
<li>Reinitialize on Becominig Relevant：当状态机变得相关时重新初始化，即当多个状态机混合时，每次进入这个状态机时，状态机都进行一次初始化，但是只会进入到默认状态，即使满足转换规则也不会进入对应的状态。</li>
<li>Create Notify Meta Data：启用转换规则的动画通知，如果不勾选，则状态机内所有的动画通知都不可用。不知道是不是bug，我实际测试时并没有实现官方文档说的这个效果，动画通知始终有效。</li>
<li>Allow Conduit Entry States：启用该属性将允许<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/5.0/zh-CN/state-machines-in-unreal-engine#%E5%AF%BC%E7%AE%A1">导管</a>用作进入状态，从而允许不同的默认状态，具体取决于导管的转换规则。</li>
</ul>
<h1 id="十二、ControlRig"><a href="#十二、ControlRig" class="headerlink" title="十二、ControlRig"></a>十二、ControlRig</h1><p>控制绑定(ControlRig)是UE为了虚拟制片引入一个插件模块，使用ControlRig可以在Sequence中很便捷的控制骨骼动画，除此之外也给程序提供了一个便捷的控制骨骼运动的接口，发展到现在ControlRig主要应用已经有虚拟制片、动画IK以及动捕，面捕，手捕等的骨骼控制等。</p>
<p>ControlRig在UE5中默认是不启动的，所以如果我们想要使用ControlRig资产就必须启用ControlRig插件。</p>
<h2 id="1-ControlRig资产"><a href="#1-ControlRig资产" class="headerlink" title="1.ControlRig资产"></a>1.ControlRig资产</h2><p>我们可以动过右键内容浏览器&#x2F;Animation&#x2F;ControlRig&#x2F;ControlRig或直接右键对应的骨骼网格体&#x2F;Create&#x2F;ControlRig来创建一个ControlRig资产(UE5.0和UE5.1可能会有点不一样)。创建ControlRig资产时会让我们选择ControlRig的父类，如果没有自定义的ControlRig父类则直接选择ControlRig类，我们可以通过继承ControlRig类来自定义ControlRig资产的父类，以实现一些通用功能的封装。</p>
<p>ControlRig有专门的编辑器界面，通过骨骼网格体创建的ControlRig是已经绑定好骨骼的，而直接创建的ControlRig里面没有任何东西，我们需要自己手动绑定骨骼，双击进入编辑器界面在RigHierachy视图下有一个ImportHierarchy按钮，点击在弹出的界面中选择我们要应用的骨骼网格体即可为资产手动绑定骨骼或则右键RigHierachy视图的空白处&#x2F;Import来选择导入的谷骨骼网格体。</p>
<h2 id="2-ControlRig编辑器"><a href="#2-ControlRig编辑器" class="headerlink" title="2.ControlRig编辑器"></a>2.ControlRig编辑器</h2><p>ControlRig编辑器中有很多的视图都是比较重要的，我们需要了解一下他们的作用。</p>
<h3 id="菜单栏"><a href="#菜单栏" class="headerlink" title="菜单栏"></a>菜单栏</h3><p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312017163.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312017163.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<ul>
<li>Forwards Solve：解算器预览，解算器决定ControlRig的计算方式，不同的解算器对应不同的ControlRig入口，ControlRig默认使用Forwards Solve解算器，对应Forwards Solve事件入口，我们可以点击解算器预览按钮后面的设置按钮选择不同的解算器预览，解算器往后连接的一系列节点组成的一条长链被称为解算链，解算器预览提供四种预览，Forwards Solve、Backwards Solve、Backwards and Forwards、Contruction Event，选择Forwards Solve，ControlRig编辑器将激活向前解算器，选择Backwawrds Solve，ControlRig编辑器将激活向后解算器，选择Backwards and Forwards，ControlRig将同时激活向前向后解算器，先执行向后解算器，再执行向前解算器，Construction Event好像没什么卵用。</li>
<li>Auto Compile：自动编译，选中后ControlRig编辑器将在我们做了任何修改之后自动编译，而无需我们手动编译。</li>
<li>Control Rig Editor Preview：这个选项官方文档中也没有说明，自己在摸索之后感觉是和后面的调试模式功能配合使用的，这个选项可以选择使用Control Rig Editor Preview或资产本身。</li>
<li>ReleaseMode：ControlRig的运行模式，切换到DebugMode配合Control Rig Editor Preview可以在ControlRig编辑器中进行解算链的调试，在DebugMode模式下后面的运行按钮会变亮，我们在解算链中添加断点，然后运行解算链，运行会在断点节点处中断，然后可以使用后面的几个工具进行断点调试。</li>
<li>Diff：这个选项使用来做版本控制的，一般没有直接使用UE连接版本控制软件都用不上。</li>
<li>Hide Unrelated：解释是说隐藏与选中节点无关的节点，但是没搞明白怎么用。</li>
</ul>
<h3 id="RigHierachy"><a href="#RigHierachy" class="headerlink" title="RigHierachy"></a>RigHierachy</h3><p>绑定层级视图显示了整个骨骼层级，我们可以选中对应的骨骼打开右键菜单来对骨骼进行操作，其中比较重要的就是New菜单下的控制点，创建好的控制点会依附在对应的骨骼层级下。</p>
<h3 id="Execution-Stack"><a href="#Execution-Stack" class="headerlink" title="Execution Stack"></a>Execution Stack</h3><p>执行堆栈视图显示了整个解算链的执行流程，在执行堆栈视图可以清晰的看到执行流程并点击可以快速定位到对应的节点。</p>
<h3 id="Curve-Container"><a href="#Curve-Container" class="headerlink" title="Curve Container"></a>Curve Container</h3><p>曲线容器视图列出了ControlRig绑定骨骼可以使用的所有动画曲线，我们可以使用<code>GetCurveValue</code>和<code>SetCurveValue</code>节点来获取与操作这些曲线。</p>
<h2 id="3-Control"><a href="#3-Control" class="headerlink" title="3.Control"></a>3.Control</h2><p>ControlRig中最重要的内容就是控制点，我们对骨骼的控制都通过Control控制点来操作，我们通过选中对应的骨骼在右键菜单的New栏中选择New Control来创建新的Control控制点，创建出来的控制点会依附在对应的骨骼层级中，以红色的图标表示。同时也可以选择多个骨骼在右键菜单的New栏中选择Add Controls For Selected选项来批量创建，批量创建的控制点不会依附在对应的骨骼层级中而是会单独的创建一个层级。</p>
<p>控制点的细节面板(这里就挑一些重要的看了)：</p>
<ul>
<li><p>Control&#x2F;Animation Type：动画类型，官方文档也没有说明具体由什么用，网上也几乎搜不到资料，只能自己摸索了。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Animation Control</td>
<td>有具体形体，可以控制动画的控制点</td>
</tr>
<tr>
<td>Animation Channel</td>
<td>具有动画通道的没有具体形体的控制点</td>
</tr>
<tr>
<td>Proxy Control</td>
<td>代理控制点，看说明是可以代替多个控制点的移动控制，并且Driven Controls下也可以添加驱动控制点，就是不知道怎么用</td>
</tr>
<tr>
<td>Visual Cue</td>
<td>不可选中也不可控制动画，但有具体形体的控制点，主要用于标识作用</td>
</tr>
</tbody></table>
</li>
<li><p>Control&#x2F;Value Type：控制点值的类型，不同类型的值可以进行不同形式的骨骼控制。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Bool</td>
<td>布尔型值的控制点可以在操作蓝图节点中设置布尔值，只是没弄明白设置设个布尔值对骨骼控制有什么作用</td>
</tr>
<tr>
<td>Float</td>
<td>浮点型值得控制点可以在PrimaryAxis中选择一个轴，控制点将只能在这跟轴上移动，不可以在其他轴上移动</td>
</tr>
<tr>
<td>Int</td>
<td>整型值控制点作用上和浮点型类似，除此之外整型值控制点可以在ControlEnum中绑定枚举类型，将整型转换成枚举类型，以便程序控制时更方便</td>
</tr>
<tr>
<td>Vector2D</td>
<td>Vector2D值控制点可以限制控制点在一个平面内移动，在PrimaryAxis可以选定一个轴，选定的轴将被排除在平面外，即控制点只能在剩下的两个轴组成的平面内移动</td>
</tr>
<tr>
<td>Position</td>
<td>Position值类型控制点可以限制控制点只能修改位移</td>
</tr>
<tr>
<td>Scale</td>
<td>Scale值类型控制点可以限制控制点只能修改大小变换</td>
</tr>
<tr>
<td>Rotator</td>
<td>Rotator值类型控制点可以限制控制点只能修改旋转量</td>
</tr>
<tr>
<td>Euler Transform</td>
<td>EulerTransform值类型控制点对控制点没限制，控制点可以修改整个Transform值</td>
</tr>
</tbody></table>
</li>
<li><p>Transform&#x2F;Min&#x2F;Max：我们选择一些值类型的控制点时在Transform栏中可能会出现Min和Max的控制栏，我们勾选上指定的轴就可以对应用在这个轴上的输入值控制接收最小值和最大值。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312018338.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312018338.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
</li>
<li><p>Shape&#x2F;Shape Properties&#x2F;Shape：选择控制点形体的样式，对于不同值类型的控制点选择适合的样式可以很直观的看出控制点的值类型和控制方式。</p>
</li>
</ul>
<h3 id="控制点的变换应用"><a href="#控制点的变换应用" class="headerlink" title="控制点的变换应用"></a>控制点的变换应用</h3><p>我们单单只创建控制点是不能直接使用控制点控制骨骼的，我们需要使用两个节点来传递变换值，获取控制点变化的<code>Get Transform - Control</code>节点和设置骨骼变换的<code>Set Transform - Bone</code>节点，我们将节点连接到解算器，编译后就可以在预览视图中通过控制点实时预览控制点对骨骼的控制了。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312018953.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312018953.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>我们这里做一个使用控制点来实现一个简单捏脸的例子实践一下。</p>
<h3 id="使用控制点实现捏脸效果"><a href="#使用控制点实现捏脸效果" class="headerlink" title="使用控制点实现捏脸效果"></a>使用控制点实现捏脸效果</h3><p>这里使用官方提供一个<a target="_blank" rel="noopener" href="https://www.unrealengine.com/marketplace/zh-CN/product/paragon-shinbi">免费角色</a>作为素材。</p>
<p>首先为角色创建一个ControlRig资产—Shinbi_CtrRig，并在角色脸部的指定骨骼上都创建对应控制点：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312018075.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312018075.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>然后配置解算链：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312018737.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312018737.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312018213.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312018213.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312018437.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312018437.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312018738.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312018738.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>这里节点比较多就做了封装。</p>
<p>到这里骨骼的控制就实现了，然后我们需要将控制应用到动画中，我们为角色创建一个新的动画蓝图Anim_Shinbi，实现如下：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312018144.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312018144.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>ControlRig节点需要在<code>Details/ControlRig/ControlRigClass</code>中选择我们创建的ControlRig资产—Shinbi_CtrRig，然后在ControlRig节点的Details&#x2F;Input下就可以看到在ControlRig资产中配置到结算链上的骨骼控制引脚了：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312018937.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312018937.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>勾选上这些引脚用来接收输入，在动画蓝图中创建对应的变量来传递输入值。</p>
<p>然后我们创建一个UI把值传递到动画蓝图中，并对值做一些大小限制以实现比较好一点的效果，然后就可以实现简单的捏脸效果了，来看一下效果：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312018729.gif"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312018729.gif" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h2 id="4-Bone"><a href="#4-Bone" class="headerlink" title="4.Bone"></a>4.Bone</h2><p>Bone是一种虚拟骨骼，创建出来后使用空心的骨骼图标表示，与实心的真实骨骼图标做区分，虚拟骨骼没有网格权重，不会影响网格交换，一般用来做辅助骨骼。</p>
<h2 id="5-Null"><a href="#5-Null" class="headerlink" title="5.Null"></a>5.Null</h2><p>空项(Null)是一种容器，用于管理控制器和虚拟骨骼，类似文件夹。</p>
<h2 id="6-FullBodyIK"><a href="#6-FullBodyIK" class="headerlink" title="6.FullBodyIK"></a>6.FullBodyIK</h2><p>FBIK(FullBodyIK)是UE5在ControlRig框架下实现的一种IK方式，首先我们应该清楚什么是IK，IK即Inverse Kinematic—逆向动力学，与FK(Forward Kinematic)—正向动力学相对，我们知道人体骨骼动画中的骨骼是一种树型结构，父骨骼的移动会影响到子骨骼的移动，而子骨骼的移动也能反作用于父骨骼，通过父骨骼的移动正向计算其下所有子骨骼的移动的过程就是FK，反之，已知某一子骨骼的移动，反向计算其上层级骨骼的移动的过程就是IK，如我们常见的足部IK，就是通过控制足部骨骼的位置和旋转来适应不同的地形，然后通过IK来计算小腿、大腿、盆骨等上层层级骨骼的位置旋转来协调不同地形上的绳梯姿态。</p>
<p>UE自身提供了4中IK方法，TwoBoneIK、FABRIK、CCDIK和FBIK，每种IK方式各有优劣，具体可以看这篇博客<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/446995093">【骨骼动画】UE的IK解决方案 - 知乎 (zhihu.com)</a>。</p>
<p>看UE5的趋势官方应该是更倾向与使用FBIK的，因为在UE5的第三人称模板中官方已经使用FBIK为我们制作好了一个效果还行的足部IK了，ControlRig叫CR_Mannequin_BasicFookIK，并且直接应用了第三人称动画蓝图中了。</p>
<p>FBIK的核心就三个东西，首先使用射线检测确定骨骼的落点变换，然后使用ControlRig解算器控制骨骼变换，最后使用<code>FullBodyIK</code>计算其他骨骼的变换，这样一个IK动画就完成了。</p>
<p>这其中的最重要的自然是FullBodyIK节点，节点功能很强大，输入引脚也是极其的多，我们一个个看。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312019568.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312019568.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<ul>
<li><p>Root：设置IK计算的根骨骼，即IK计算的最上层骨骼，再往上就不计算了，在人形骨骼上一般都设置为盆骨；</p>
</li>
<li><p>Effectors：官方文档成Effectors为执行器，用来设置IK计算的起始骨骼，这是一个数组可以设置多个起始骨骼。</p>
<p>Bone：应用的Effector设置的起始骨骼名称；</p>
<p>Transform：IK起点的变换，注意这里不是IK起始骨骼的变换，而是通过射线检测计算出来的骨骼落点的变换。</p>
<p>Position Alpha&#x2F;Rotation Alpha：效果类似动画蓝图Blend节点的Alpha，用于控制骨骼变换的应用程度，1表示完全应用IK计算后的骨骼变换，0则是完全不应用。这里UE5.0和UE5.1有点出入，5.0二者合并成了一个Offset Alpha；</p>
<p>Strength Alpha：Effectors对骨骼链的影响程度；</p>
<p>Pull Chain Alpha：这个也是5.1新出的配置，官方文档上也没有更新这个设置的说明，按照编辑器的中文解释，这个设置使用来针对不同密集程度的骨骼链做IK解算时改善计算结果的；</p>
<p>Pin Rotation：这个设置也是5.1新出的，官方文档上也没有更新这个设置的说明，按照编辑器的中文解释，这个设置也是用来在移动输入的骨骼变换和执行器输入的骨骼变换之间做混合的，1表示使用执行器的骨骼变换，0表示使用移动输入的骨骼变换。感觉和Rotation Alpha的效果差不多，实际实践中感觉Pin Rotation的影响程度更高一点。</p>
</li>
<li><p>Bone Settings：骨骼设置用于针对单个骨骼进行解算属性设置，由于IK解算有时解算出来的结果有些骨骼可能不是很理想，所以骨骼设置是很有必要的。</p>
<p>Bone：需要应用设置的骨骼名称；</p>
<p>Rotation Stiffness&#x2F;Position Stiffness：旋转刚度&#x2F;位置刚度设置IK计算时对应用骨骼的影响程度，0表示骨骼可以自由移动，即完全影响，1表示骨骼完全锁定。</p>
<p>X&#x2F;Y&#x2F;Z：这些设置就是和Control控制器的Min&#x2F;Max设置的效果是一样的，限制应用骨骼的在轴向上的变换范围，有三种模式，Free—骨骼的变换不受限制，此时Min&#x2F;Max值不会生效，Limited—骨骼的变换将限制在Min到Max值之间，Locked—骨骼会被锁定，无法进行任何变换；</p>
<p>Use Preferred Angles：是否启用偏好角度，启用偏好角度会导致更多解算迭代，所以会消耗更多的计算；</p>
<p>Preferred Angles：用来强制使应用骨骼在解算时只在解剖学上的正确方向弯曲，不过我始终没有玩明白怎么用。</p>
</li>
<li><p>Excluded Bones：排除骨骼就是用来指定某根骨骼排除在解算链之外，不参与解算，主要用于来矫正姿势。</p>
</li>
<li><p>Settings：Setting是全局解算器设置；</p>
<p>Iterations：迭代次数，设置解算器的全局迭代次数，迭代次数越高，解算效果越好，同时也会越吃性能；</p>
<p>Mass Multiplier：质量倍乘器，值越大解算应用时全身骨骼看起来就会越僵硬，值越小看起来就会越软爬爬的；</p>
<p>Min Mass Multiplier：控制质量倍乘器的最小值；</p>
<p>Allow Stretch：这个设置没能摸索出有啥用；</p>
<p>Root Behavior：设置解算器的行为模式；</p>
<p>Start Solve from Input Pose：如果设置为true，解算器将在每一Tick重设，解算将从当前姿势开始，如果设置为false，解算器将从上一次解算的结果开始解算，输入的动画将倍忽略，一没弄明白有什么作用，默认都是勾选的，一般也不会动它。</p>
</li>
</ul>
<h2 id="7-解算器"><a href="#7-解算器" class="headerlink" title="7.解算器"></a>7.解算器</h2><p>在UE5.1中ControlRig提供了四种解算模式，Forwards Solve(向前解算)、Backwards Solve(向后解算)。</p>
<p><strong>向前解算</strong>即Control控制器驱动骨骼，是应用范围最广的解算，是ControlRig的默认解算方式。</p>
<p><strong>向后解算</strong>即使用骨骼驱动Control控制器，向后解算一般用于将动画序列烘培到Sequencer中的ControlRig上。</p>
<h2 id="8-构造事件"><a href="#8-构造事件" class="headerlink" title="8.构造事件"></a>8.构造事件</h2><p>ControlRig没有公开构造函数，但是为我们提供了一个构造事件—ConstructionEvent，需要我们手动创建节点。</p>
<h2 id="9-样条线控制"><a href="#9-样条线控制" class="headerlink" title="9.样条线控制"></a>9.样条线控制</h2><p>样条线控制可以将一整条骨骼链作为一个整体进行控制，尤其是应用在触手，蛇、马尾辫等长条状的网格体上会很便捷。</p>
<h3 id="创建样条线控制"><a href="#创建样条线控制" class="headerlink" title="创建样条线控制"></a>创建样条线控制</h3><p>创建样条线控制我们需要为一整条骨骼链的没一根骨骼创建Control控制器，然后将控制器的Translation添加进<code>Spline From Points</code>节点的Points数组中：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312019951.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312019951.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>Spline From Points节点的输入引脚说明参考<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/5.1/zh-CN/control-rig-spline-rigging-in-unreal-engine/">虚幻引擎中的Control Rig样条线操控</a>。</p>
<p>然后将样条线绘制出来：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312019329.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312019329.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>编译之后就可以在预览视图看到绘制出来的样条线了。</p>
<p>需要注意的是Points必须传入四个以上的元素才能生成样条线。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312019962.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312019962.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h3 id="应用样条线控制"><a href="#应用样条线控制" class="headerlink" title="应用样条线控制"></a>应用样条线控制</h3><p>绘制出的样条线还不能控制骨骼，还需要将样条线的控制应用到骨骼上。</p>
<p>使用Fit Chain Spline Curve节点可以将样条线控制应用到骨骼上，多选骨骼拖到蓝图中，在弹出菜单中选择Create Item Array，可以创建一个Rig Elemeny Key Array骨骼数据节点，传给Fit Chain Spline Curve节点的Items上，Spline连Spline From Points返回值，然后就可以使用样条线控制骨骼链了。</p>
<h2 id="10-姿势缓存"><a href="#10-姿势缓存" class="headerlink" title="10.姿势缓存"></a>10.姿势缓存</h2><p>姿势缓存是ControlRig提供的一个功能，可以将ControlRig中的动画的某一帧的姿势存储为一个姿势缓存变量，其实ControlRig的姿势缓存在功能效果上和姿势资产区别不大，但是姿势缓存有一个强大的能力，就是基于ControlRig强大的骨骼控制能力和程序控制能力，姿势缓存可以只单独缓存指定骨骼的姿势变换，应用姿势时也只应用这些骨骼的姿势变换，并且可以通过程序控制在运行时存储动画的任意时刻的姿势。</p>
<p>ControlRig框架专门提供了一个<code>RigPose</code>类型来存储姿势缓存，并且提供<code>GetPoseCache</code>节点来获取ControlRig控制下的动画姿势，最后通过<code>ApplyPoseCache</code>节点来应用姿势缓存，甚至在调试时提供了<code>DrawPoseCache</code>节点来绘制姿势缓存：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312019755.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312019755.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>我们可以将控制变量StartCachePose和ApplyCachePose通过动画蓝图的ControlRig节点传递出去，我们就可以通过程序实时的缓存姿势并应用姿势了。</p>
<p>可以看看一个简单的效果：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312019469.gif"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312019469.gif" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h2 id="11-ControlRig函数库"><a href="#11-ControlRig函数库" class="headerlink" title="11.ControlRig函数库"></a>11.ControlRig函数库</h2><p>ControlRig函数库和蓝图函数库的功能是一样的，用来共享ControlRig的公共逻辑，和蓝图函数库不同的是，ControlRig的每一个资产都可以是一个函数库，我们只需要将函数设为Public就可以使这个函数在所有的ControlRig资产里使用了，但是为了方便管理一般都单独使用一个不绑定骨骼网格体的ControlRig资产来专门管理公共函数。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="category-chain-item">学习笔记</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/UE5/" class="print-no-link">#UE5</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>【UE5】动画系统</div>
      <div>http://example.com/2023/01/31/【UE5】动画系统/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>January 31, 2023</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/06/03/%E3%80%90AI%E3%80%91Stable%20Diffusion%20WebUI%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" title="【AI】Stable Diffusion WebUI使用指南">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">【AI】Stable Diffusion WebUI使用指南</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/12/07/%E3%80%90UE5%E3%80%91%E5%A4%9A%E7%94%A8%E6%88%B7%E5%8D%8F%E5%90%8C%E7%BC%96%E8%BE%91/" title="【UE5】【UE5】多用户协同编辑">
                        <span class="hidden-mobile">【UE5】【UE5】多用户协同编辑</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
