{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/Fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/Fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/Fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/Fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"themes/Fluid/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/Fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/Fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"themes/Fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"themes/Fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"themes/Fluid/source/js/debouncer.js","path":"js/debouncer.js","modified":0,"renderable":1},{"_id":"themes/Fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"themes/Fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"themes/Fluid/source/js/lazyload.js","path":"js/lazyload.js","modified":0,"renderable":1},{"_id":"themes/Fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/Fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"themes/Fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/Fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1},{"_id":"themes/Fluid/source/lib/hint/hint.min.css","path":"lib/hint/hint.min.css","modified":0,"renderable":1},{"_id":"themes/Fluid/source/img/About.png","path":"img/About.png","modified":0,"renderable":1},{"_id":"themes/Fluid/source/img/Archives.png","path":"img/Archives.png","modified":0,"renderable":1},{"_id":"themes/Fluid/source/img/Categories.jpg","path":"img/Categories.jpg","modified":0,"renderable":1},{"_id":"themes/Fluid/source/img/Home.jpg","path":"img/Home.jpg","modified":0,"renderable":1},{"_id":"themes/Fluid/source/img/Post.jpg","path":"img/Post.jpg","modified":0,"renderable":1},{"_id":"themes/Fluid/source/img/Tags.jpg","path":"img/Tags.jpg","modified":0,"renderable":1},{"_id":"themes/Fluid/source/img/shun.jpg","path":"img/shun.jpg","modified":0,"renderable":1},{"_id":"themes/Fluid/source/Home.jpg","path":"Home.jpg","modified":0,"renderable":1},{"_id":"themes/Fluid/source/Post.jpg","path":"Post.jpg","modified":0,"renderable":1},{"_id":"themes/Fluid/source/Tags.jpg","path":"Tags.jpg","modified":0,"renderable":1},{"_id":"themes/Fluid/source/About.png","path":"About.png","modified":0,"renderable":1},{"_id":"themes/Fluid/source/Archives.png","path":"Archives.png","modified":0,"renderable":1},{"_id":"themes/Fluid/source/Categories.jpg","path":"Categories.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/Fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1608117878700},{"_id":"themes/Fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1608117878703},{"_id":"source/_posts/【C#】C#两种数组定义的区别.md","hash":"4484224a70bd15af6264b7670b1845a1620fd903","modified":1574061919000},{"_id":"source/_posts/【C#】C#高级.md","hash":"131d4494511550023deda702f58802a6608e0996","modified":1574061919000},{"_id":"source/_posts/【C#】C#中级.md","hash":"43bd41b1ad644eaa199f42a62b435044e19cd225","modified":1574061919000},{"_id":"source/_posts/【C++】C++STL标准模板库.md","hash":"4d0c782ce5205ea37c890de2989d60fe04eca23e","modified":1617074395514},{"_id":"source/_posts/【C++】C++中的四种个智能指针.md","hash":"b3062a22bd1567d7862c500f24ccd0cf40087f1a","modified":1615965523685},{"_id":"source/_posts/【C++】C++中的四种转换类型.md","hash":"0b06c9b933438e5a214acd5231189d147afc6b90","modified":1620874021237},{"_id":"source/_posts/【C++】C++函数模板的实现机制剖析.md","hash":"32166733d26470db426816f992fdc7e6c96433c4","modified":1615965497619},{"_id":"source/_posts/【C++】C++进阶.md","hash":"0d679a9cf9af7d5ee9f774bf1559e1ab776df450","modified":1615965504935},{"_id":"source/_posts/【C++】全局变量、静态全局变量、局部变量与静态局部变量.md","hash":"2ddf380e15ce11e67d7b7d8680b1cfbe40936c34","modified":1615965538861},{"_id":"source/_posts/【C++】C++高级.md","hash":"6d7a718437fc8995f29d742c91077b813a4c8008","modified":1617084950916},{"_id":"source/_posts/【C++】C++面向对象模型初探.md","hash":"f3c762c3e2b217290d355e027e6ab907488d142b","modified":1615965511777},{"_id":"source/_posts/【Lua】Lua基础.md","hash":"267050e5c3461808f4d2df6d53c513da81a43f4d","modified":1612186337325},{"_id":"source/_posts/【Linux】Linux基础.md","hash":"4008054b877c760abf43018298786f0fc01bd15f","modified":1612186321185},{"_id":"source/_posts/【C】C的typedef的妙用.md","hash":"f3b5a9b3e0fc19834a0976e2a6440482feaf5d8a","modified":1612185979697},{"_id":"source/_posts/【Qt】Qt基础.md","hash":"582cb1400e7b7fa2c69489e8fda5b4079b8e9d19","modified":1614145243361},{"_id":"source/_posts/【MyQSL】MyQSL存储过程.md","hash":"10f91a85cbc223ebe7c92030d9fe1398ecac5ca9","modified":1612186344275},{"_id":"source/_posts/【UE4】UE4基础.md","hash":"c477ee93df860a1e01674aef6e56d57554b61441","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4组件.md","hash":"4e0a465c41a70f86f6168f13b077cd8ce7d6b141","modified":1620735122613},{"_id":"source/_posts/【UE4】UE4蓝图基础.md","hash":"d7296d6ce2bd1330d0bbb607f516899047ac8f25","modified":1612185743104},{"_id":"source/_posts/【UE4】UE4联级粒子系统.md","hash":"19fc9b07e030c631740101b9f99d9af2afd75db0","modified":1612186425196},{"_id":"source/_posts/【UE4】UE4连接MySQL.md","hash":"a2468d15d0300f6ccdb3e7f915cc3210b37be829","modified":1612186417109},{"_id":"source/_posts/【UE4】UE4读写Json文件.md","hash":"00928ce9a06dd0e3ae4b2cb0cf28e62cabad7723","modified":1612186375185},{"_id":"source/_posts/【Unity3d】Animation.md","hash":"aab93c4ae10f7061653489843734a73ce626274d","modified":1612186441038},{"_id":"source/_posts/【Unity3d】Space.md","hash":"3929a253aacbfb21a1ac451c782b9f019e09ebd0","modified":1612186460804},{"_id":"source/_posts/【Unity3d】Lightmap.md","hash":"edfe3ca04fc81f9bce2560706d808b9571b1d836","modified":1612186451534},{"_id":"source/_posts/【Unity3d】Unity常用技巧笔记.md","hash":"d6f952acb256713daba70163ac76d4c8c10ebd4b","modified":1612186475317},{"_id":"source/_posts/【Unity3d】存档与读档.md","hash":"aabd716ce81f10de74b06724fc6dd957025fb180","modified":1612186482652},{"_id":"source/_posts/【Unity3d】游戏截屏.md","hash":"c01d6a982617da17a8d1530391f10bbcf8022579","modified":1612186489735},{"_id":"source/_posts/【待解决】一些待解决的难题.md","hash":"d968fe51d1b6d9c024c2d5292d3cb5421e69e64d","modified":1620885689095},{"_id":"source/_posts/【程序编程】程序编程高级.md","hash":"b9015d379ee3b7ec60c7b04cb055dfee534e8389","modified":1612186499914},{"_id":"source/_posts/【日记】在武汉跑秋招的日子.md","hash":"5494d4364e67df2c6e4b298b1a4ab17a5bb619a2","modified":1612193311122},{"_id":"source/_posts/【shell】shell基础.md","hash":"1079e032bcff74cdca4c4c80c1a11d670f1ba458","modified":1612186369325},{"_id":"source/_posts/【算法】一些牛逼轰轰的算法记录.md","hash":"cc17714556df4a5d5f4e806c49a5d2c86371a8fb","modified":1616730132593},{"_id":"source/_posts/【网络通信】物联网通信基础.md","hash":"277e2aec9d649abb408c408c7c3df3203a5adbe9","modified":1612186559695},{"_id":"source/_posts/【网络游戏】网络游戏基础.md","hash":"bb9f2074179dabe5d881584b55d3b812d6f286f0","modified":1612186569505},{"_id":"source/_posts/【计算机图形学】多变形填充算法原理.md","hash":"0ca81ad9a644aeb8ad1a031fbc6e116548e99988","modified":1612186536186},{"_id":"source/_posts/.git/COMMIT_EDITMSG","hash":"dad27b7fc77b981d88de93f22ad63a82f89157fb","modified":1610107962226},{"_id":"source/_posts/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1610107915994},{"_id":"source/_posts/.git/index","hash":"d85716131f7dcced145b9d853487deef80fb8d33","modified":1612337391569},{"_id":"source/_posts/.git/config","hash":"80de82dfd57795eed1fcbc83b7a9a318eb9e3b20","modified":1610107916012},{"_id":"source/_posts/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1610107915874},{"_id":"source/_posts/【C++】C++STL标准模板库/Snipaste_2019-10-06_10-41-56.png","hash":"810d61e3712627b3635a1d1ce1f6491557dc201b","modified":1574061919000},{"_id":"source/_posts/【C++】C++函数模板的实现机制剖析/Snipaste_2019-10-03_16-51-51.png","hash":"2a90c735ad40783b372412f70f7118ffeaf85ebe","modified":1574061919000},{"_id":"source/_posts/【C++】C++函数模板的实现机制剖析/Snipaste_2019-10-03_20-12-24.png","hash":"cad8a86adae84406c2e8817fd6ad2c2fd5978a24","modified":1574061919000},{"_id":"source/_posts/【C++】C++函数模板的实现机制剖析/Snipaste_2019-10-03_19-57-21.png","hash":"85d519d58f5f4729d5ab1352172f91204ad9a717","modified":1574061919000},{"_id":"source/_posts/【C++】C++面向对象模型初探/Snipaste_2019-10-02_09-07-09.png","hash":"9788155af506713955a83e6b75841ab266a600c1","modified":1574061919000},{"_id":"source/_posts/【C++】C++高级/Snipaste_2019-10-01_16-21-15.png","hash":"11db0bd09076d6a9c5453ffb9d727fcc69f76014","modified":1574061919000},{"_id":"source/_posts/【C++】C++函数模板的实现机制剖析/Snipaste_2019-10-03_20-08-21.png","hash":"5c01aefb45d2ffba96637150a101159fb8f2e382","modified":1574061919000},{"_id":"source/_posts/【C++】C++高级/Snipaste_2019-10-01_16-52-53.png","hash":"597bf574dfd790524a42791a734b4e6f56001648","modified":1574061919000},{"_id":"source/_posts/【C++】C++高级/Snipaste_2019-10-02_16-10-55.png","hash":"c37e3f7d89ea5eaa7f8706f7e6c403e1e240adf8","modified":1574061919000},{"_id":"source/_posts/【C++】C++高级/Snipaste_2019-09-14_16-29-43.png","hash":"a55e0855be7a6b9653d60e1aa02f35d028edf35c","modified":1574061919000},{"_id":"source/_posts/【C++】全局变量、静态全局变量、局部变量与静态局部变量/Snipaste_2019-09-11_21-35-55.png","hash":"505601dffe4500c8a647a7063482ce62106e25e4","modified":1574061919000},{"_id":"source/_posts/【C++】全局变量、静态全局变量、局部变量与静态局部变量/Snipaste_2019-09-11_21-36-28.png","hash":"07871d39f3a7ee00adf0eb647cad376c59f2f842","modified":1574061919000},{"_id":"source/_posts/【C++】C++高级/Snipaste_2019-10-06_10-03-47.png","hash":"ec465977f70b7aa59d67bac0a5ad41c61b5dd583","modified":1574061919000},{"_id":"source/_posts/【C++】C++高级/Snipaste_2019-10-02_15-50-39.png","hash":"64fa5f2de6fb00f854a93938e5079edd530ba1d5","modified":1574061919000},{"_id":"source/_posts/【C++】全局变量、静态全局变量、局部变量与静态局部变量/Snipaste_2019-09-11_21-36-38.png","hash":"f5a18dbfff19d9882af97385cfc2e516b66c6e8f","modified":1574061919000},{"_id":"source/_posts/【Linux】Linux基础/3.png","hash":"65c53fe085fb8347bb9c533cf4ce1691e9730943","modified":1574061919000},{"_id":"source/_posts/【Linux】Linux基础/1.png","hash":"e74c708ed4982ebfcf7d877f208c8c387f5e2807","modified":1574061919000},{"_id":"source/_posts/【Linux】Linux基础/4.png","hash":"db75575cba757e8f832672d4f6c1890d478df81c","modified":1574061919000},{"_id":"source/_posts/【Linux】Linux基础/6.png","hash":"18a0e386b38c07dc6a669d336b8b6550346fab90","modified":1574061919000},{"_id":"source/_posts/【Linux】Linux基础/5.png","hash":"7036239e4d1887d9c459a14a763d442e9b327797","modified":1574061919000},{"_id":"source/_posts/【Linux】Linux基础/7.png","hash":"5a78f505de229568325c94e53d986a6629093b38","modified":1574061919000},{"_id":"source/_posts/【Linux】Linux基础/8.png","hash":"9d26c95560af50e4a37d34fcf775d686a7bbe7fa","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-14_14-17-41.png","hash":"f83bcfa6debb9a1913515beab33f3d5715d5a5b4","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-15_10-16-42.png","hash":"8ede8469885ebf7cbc923d32805055cddf1d9252","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-15_10-31-54.png","hash":"3f9f6113883e9699b692866442cb0ce4cafadee2","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-15_10-39-37.png","hash":"5f4cd72fe0f354f694290b73ab1bdc0242a25b79","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-15_10-36-15.png","hash":"0044a9c1749c0453d64e75155990bc30a2b57f1c","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-15_10-47-10.png","hash":"71085564086326ac75335000c36b9f4dcc85dcd1","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-15_10-45-14.png","hash":"56a1fa9cfc719c352cfe7899f921eb3c6bd0dc88","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-15_11-04-47.png","hash":"ff5bf999fe1885ce5b2903b743191478f7d40f22","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-15_10-50-02.png","hash":"847b7161ad116c2ea0b9d2aa19a46056fcbfdc71","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-15_10-50-54.png","hash":"d5f88cbc7960644e0a452418da6cd899146e40c0","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-15_11-11-16.png","hash":"610880f8df9508b1a995c17057ed1d9c1c2e66ae","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-15_11-05-09.png","hash":"701a17ab4e85d5bef0637c467236642e22eadf5f","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-15_11-06-57.png","hash":"f975caeeaa07a96417efbbd8cb90f037164ab621","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-15_11-04-58.png","hash":"d14dae474a49c9debf89ae13defc9639d610fdc7","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-15_11-11-01.png","hash":"1005bef143ae4569261a45ccae43ee03330fb108","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-15_11-11-45.png","hash":"92d60d6fdf802ff58a02e62c0087562567513977","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-15_11-11-34.png","hash":"2e0b939a04bafefcc400cb356101a9452fedc3d6","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-15_11-12-10.png","hash":"57f22abebb3de28f6921173fc1cb97ef7cde8771","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-15_11-11-59.png","hash":"565c665097bd82963d37d3ee55ea61f19bdd5045","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-15_11-12-21.png","hash":"0140c32908f8bb585f9d2227f2d2d5aec3970230","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-15_11-12-31.png","hash":"5539e9b0014726ebd77482b9444ad7662b17b250","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-15_17-56-02.png","hash":"46fa4147b43c5849aef46813de50478e25bb446a","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-16_10-05-42.png","hash":"5f878e497d56e4943e2725dfa8c1feb9d3fe8bff","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-15_17-55-17.png","hash":"ca70a2d3894ad2068736e6a64731f8ce20d0eb45","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-15_18-02-03.png","hash":"86cd277b252a4cc1da93e97f5494bc87196ca565","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-16_10-40-52.png","hash":"ea43cd38cbf6d5fe5f1466c6a2559895a9cf15b1","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-16_17-06-01.png","hash":"c173ad764a607ea5124f5c58431226ba15b3f6be","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-16_17-13-58.png","hash":"49ffc8e93a439ed8da9b46daa461578935e09118","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-16_17-10-46.png","hash":"c14c3b3fb2db09bc121a82fea4f5c65b0bba8281","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-16_17-15-33.png","hash":"d68fc315e76de6efd20023d2349efc21acd1414d","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-16_21-27-20.png","hash":"83888c019cd4467ab6d76b6dab9473c8bad020d0","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-17_13-30-29.png","hash":"6ec3a520660892a2bc8e89d4912b0e4c77149668","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-17_13-46-52.png","hash":"971eb5730cde5a669cdc07b59ffae9f0a89ffbd6","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-17_13-30-49.png","hash":"018066c51f1b15f6b5b3e5b481c12b9a44fe70ae","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-25_10-33-38.png","hash":"64554330a54c6b95ee127c991e4888a69e429103","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-23_17-38-23.png","hash":"05d6fe4fc011f089704900b288f1bd6200556eb8","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-23_17-41-13.png","hash":"320625ad1a89a4da4b9a14518c92395ba42075ec","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-25_10-53-07.png","hash":"ddcb3857c76fd5c1fce4df83312e1b18d42dcec2","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-25_10-57-11.png","hash":"0371cb3e8f1e81e9393db23deb69500533bfa1d7","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-23_17-24-52.png","hash":"bb492205214896e665910cad73c5201b976b986a","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-25_11-10-28.png","hash":"36d8cc3a758a61b8b51b827df9b2aa036390d2fe","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-25_11-02-10.png","hash":"f4310100332d4b3fe782214afb78bde5d975c346","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-25_11-30-52.png","hash":"fc92e45a352a1c4b9e1abd2bd403b895e3f18e80","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-25_11-17-59.png","hash":"d2c402446c1775bcb6bb0a8abc811a9f7610ab7e","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-25_11-21-18.png","hash":"eddb2a62c1ae3a93280d41caa572d80aef68a317","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-25_11-26-07.png","hash":"200c62da25dc88ebdfa39e6caffea12785d9279e","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-25_11-42-14.png","hash":"3aa5d7c963c118ce37b5993684a9a9577005addd","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-25_11-50-37.png","hash":"a3b20410850873ae846e3e8f3853a7418a188710","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-25_11-39-53.png","hash":"0b863649f6e654b394955e3647fced1fcc956c72","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-25_11-46-47.png","hash":"73c6ec827855ffae563f210494d6f4b4484ce837","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-25_13-12-40.png","hash":"99ff8392aadd3ef46878e5257154e6eb0f381799","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-28_17-04-19.png","hash":"fcd324ec161790fe960119fdcdb9a47e925b7be7","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-25_13-32-38.png","hash":"bc2a709db523fc659a2fb6986296eadb53ec7570","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-25_13-19-47.png","hash":"3a793d0b095e18ff4df0b10cb7320e8e5195c5a6","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-29_09-09-05.png","hash":"c191952901614af5ca09f775338d2e35c7852714","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-28_17-26-35.png","hash":"50425fc1f654e3ed970fafe5165c351a9aaaadf7","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-28_17-28-37.png","hash":"c7643952253687e3672706dbe1b0acca7a06a38d","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4联级粒子系统/Snipaste_2019-11-14_09-41-14.png","hash":"2ade6fef39dbba64358a5d2f79ac88f682b4efec","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4联级粒子系统/Snipaste_2019-11-14_10-25-52.png","hash":"9ee3c1e6d54c5b0170248c8e7cd5b0c519be5cd6","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4联级粒子系统/Snipaste_2019-11-14_10-14-27.png","hash":"d2d45fcf41738dc41f1c11eea9ba5f85e2f9c5e9","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4联级粒子系统/Snipaste_2019-11-14_10-51-44.png","hash":"6641d07308c0d50c2447e8c065d5cdfc3fa45da1","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4联级粒子系统/Snipaste_2019-11-14_11-50-46.png","hash":"2e70c74851578edb3a5d94b4c2a0fe7f2ee4d2bb","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4联级粒子系统/Snipaste_2019-11-14_19-47-55.png","hash":"0548e3fb6a783367d0a2af3e8305aa0b36b809c7","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4联级粒子系统/Snipaste_2019-11-15_15-41-29.png","hash":"710f6dad4ba7890a60051a3bc6f89d846bf5cf5d","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-24_09-51-55.png","hash":"3c55d238b69ccbc521c5ad08b9644bda580f145d","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-24_10-45-29.png","hash":"b704a10ea2838729dfb50e5db77d366821a456bc","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-24_10-53-34.png","hash":"101791a642dca4718f7812d7a9e9f115947a74a9","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-24_10-53-06.png","hash":"56f4fee835704b79b6f3935ea110c9ba3ef1d89c","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-24_11-09-34.png","hash":"d77d66be1d8ba7b252bf66f0b90facaa57925e99","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-25_17-23-07.png","hash":"41905075876259d9b105a4c4d413b34401ed803e","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-25_17-23-27.png","hash":"0a83b862045bd256006f7c943e083d201cf05306","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-25_17-18-23.png","hash":"87987ac555489debfea1fec095a1953fd73b3230","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-31-36.png","hash":"ba2ee11a37f1815ffbfdab147b73161c46446795","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-25_17-36-36.png","hash":"7553e0f0ef41dfd9e0952f87a50f6de87f90b685","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-31-16.png","hash":"ade46d8881e3c15f1a04b83e9eb3915a541a5078","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-31-47.png","hash":"635642af09c49970dabd8e88306f7e00af24cabf","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-31-23.png","hash":"fe4f918ef3fec236da53b5a4a0fff3943cf0a7f8","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-39-15.png","hash":"60b0d897de36070faa73e5cb498e896c8035794f","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-39-52.png","hash":"8d22244bea3196a6e67057344df7a97a73649b7f","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-40-45.png","hash":"cb8e521fede3cf38da8ff0ea3a3bb5cbc21e677b","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-39-35.png","hash":"4182d56811a3252ebc9ec0d730f340c689f50c49","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-40-54.png","hash":"8c8e6b846343e5450e4a69cd7e1020ef32ac8abb","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-40-59.png","hash":"ea2148fe24979d5c8332ce1ca4f50cae63521f33","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-25_19-14-34.png","hash":"aefe27e9f978b8c23570c6f30c8486a6d3245b7f","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-21-48.png","hash":"a11b51e94b9331eb7936704ef2fb886b16d2c6bd","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-37-55.png","hash":"2d47aedb9096ea9c5c1601a5e792c79d86c7f789","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-46-46.png","hash":"0d398816ac7b4345f6f3495e17828c68480322a7","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-24-33.png","hash":"1b5cc46f8a19f5607b4631c232cd031640e124b8","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-42-24.png","hash":"075ccdadbc3a1c44d391288048e29f83a53dd7b8","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-50-31.png","hash":"61ffbd8f56ffb672190c3fce3fb67a7561cca07a","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-53-49.png","hash":"06caa84fa5b3d9d91a7cf9368eeed844e2023fa3","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-59-54.png","hash":"ccf34babcb3bb65373f4f93a2278449348e8a73d","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-07-44.png","hash":"dea91d3b9a042ba417e7f75da511d80a095ade41","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-07-50.png","hash":"b1d6ea713edee473f3cecd8939d2718bc8a04ff5","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-12-59.png","hash":"748732a228e6a13df384d15286c25c557afd6a51","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-21-30.png","hash":"08575e7872c9da7eda474b4170786eb2749dc79c","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-29-34.png","hash":"213cc29f7b2f03df188991824d2875b250dd5fef","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-30-00.png","hash":"c363550daba311a430d1326e3a77bbc093c991a8","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-25-34.png","hash":"d0e0e322959a40433f2b7d6b98b4a8dbe48d1830","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-27_10-32-38.png","hash":"d8bd1910293501ae25dafdd46ddbb89ae6ce9eae","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-27_10-38-13.png","hash":"4a9fe778400ae1372b3a24580cdb8fadf4e1594f","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-27_11-01-39.png","hash":"f3503da8827e583536e1bdcd679933d85dee71d1","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-27_11-28-43.png","hash":"06fd9ec3a40d13d78e36d36379c64a2a2ba75b9c","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-27_11-04-21.png","hash":"7b666b1faccf4d57fb8068daecaa2984a59b0ba3","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-28_17-00-10.png","hash":"7f1daca36a8e7ebea17b979721e7ceb8e624defd","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-28_15-51-30.png","hash":"01bca903f964a3c76edbb14de1fbd09d558269f8","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4连接MySQL/Snipaste_2019-11-05_17-54-58.png","hash":"27c07cacaa21c95831d38c452bfe6f59cf3eb9f4","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4连接MySQL/Snipaste_2019-11-05_18-14-47.png","hash":"18a412d7081079da2a4d60bbfd85e069312a4edf","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4连接MySQL/Snipaste_2019-11-05_18-02-53.png","hash":"5c57866c6623ed0b2c7b5444fd53e5f038dfa6a9","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4连接MySQL/Snipaste_2019-11-05_18-17-44.png","hash":"c6269a3a27c752c7ef1863d37535f8b0b76a236b","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4连接MySQL/Snipaste_2019-11-05_18-26-48.png","hash":"965a01ba8c647bc27a2a00bbd70d474ad8ac6a9f","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4连接MySQL/Snipaste_2019-11-05_18-27-48.png","hash":"32afad21d07ba21035398bbd592ceee5307bfe22","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4连接MySQL/Snipaste_2019-11-05_18-34-52.png","hash":"b5ceda67e3b162e555fd59450cf8a5348cfc8923","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4连接MySQL/Snipaste_2019-11-05_19-14-07.png","hash":"ec07cbdc14eb07a8c65387c1674cb920c2e14fa9","modified":1574061919000},{"_id":"source/_posts/【Unity3d】Unity常用技巧笔记/Snipaste_2019-08-27_11-35-00.png","hash":"8b2c152edbeba31889b8f5d99cb30221e9ff0cca","modified":1574061919000},{"_id":"source/_posts/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1610107915885},{"_id":"source/_posts/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1610107915932},{"_id":"source/_posts/.git/hooks/fsmonitor-watchman.sample","hash":"118ff5509f187039734d04456bf01e44c933ac19","modified":1610107915943},{"_id":"source/_posts/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1610107915961},{"_id":"source/_posts/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1610107915953},{"_id":"source/_posts/.git/hooks/pre-merge-commit.sample","hash":"04c64e58bc25c149482ed45dbd79e40effb89eb7","modified":1610107915971},{"_id":"source/_posts/.git/hooks/pre-push.sample","hash":"a599b773b930ca83dbc3a5c7c13059ac4a6eaedc","modified":1610107915975},{"_id":"source/_posts/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1610107915980},{"_id":"source/_posts/.git/hooks/pre-commit.sample","hash":"a79d057388ee2c2fe6561d7697f1f5efcff96f23","modified":1610107915967},{"_id":"source/_posts/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1610107915987},{"_id":"source/_posts/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1610107915984},{"_id":"source/_posts/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1610107915992},{"_id":"source/_posts/.git/hooks/update.sample","hash":"730e6bd5225478bab6147b7a62a6e2ae21d40507","modified":1610107915991},{"_id":"source/_posts/.git/logs/HEAD","hash":"a46a0fbb6ce7ac880677354a1108b97fb54030bc","modified":1610107962311},{"_id":"source/_posts/.git/refs/heads/master","hash":"749b9b9442f6662f4b48a27f4d45b7298845a8b0","modified":1610107962310},{"_id":"source/_posts/.git/objects/00/51dc339c0b42fc4405eb16bc633797d139418d","hash":"e50a5fed2902b9e86acbea354d8e085d579d08a3","modified":1610107929799},{"_id":"source/_posts/.git/objects/00/65ecb72fb0baccfe412d744a5c73d26eaa4533","hash":"f8c6e7223e4dccbb3da4957f2c89867966a8bfe9","modified":1610107929330},{"_id":"source/_posts/.git/objects/03/e5bb4d039cd3b039e266ec201ce096bb7f1c0d","hash":"ee159482ae4499df8741e9b73a6824979285f4c1","modified":1610107930719},{"_id":"source/_posts/.git/objects/00/77ea885ef97a4e5cf0090d4bce6e1ea57f13e7","hash":"68fd3f473b791bec7915146764493269ded8ff1e","modified":1610107923260},{"_id":"source/_posts/.git/objects/00/a5ca556bcad7a502f6ebf04a057e6b50b7e81c","hash":"cdde688788dafbf2b2b430ea6a494250e3ca289a","modified":1610107922921},{"_id":"source/_posts/.git/objects/07/bfdf3d7f005dd5ac1c99b2397d0550aec34356","hash":"290ade7f4f4fd05b75c18a1a10811ebb06a67c49","modified":1610107927524},{"_id":"source/_posts/.git/objects/04/1d288c1925f4199f36440bc1e5060b43ce3f3d","hash":"aa4a8da868390cbbc4bae9e822722ef08b053141","modified":1610107928616},{"_id":"source/_posts/.git/objects/04/c0918daddaf6db6c1365ee1d6e9397ed02d5c4","hash":"48bd358860194c3167af9388ba7636ba3e0edac6","modified":1610107922760},{"_id":"source/_posts/.git/objects/08/e87214bfa7292fc7774bacc660d664d9f6ded2","hash":"2e77351ba3b3a0dd6ae33bf6011d788364d69526","modified":1610107926237},{"_id":"source/_posts/.git/objects/08/feaddcc3ea76695bbc100980c201bc1a087ad9","hash":"b8ffab2e079363f1c67b31d8f818686b23d11208","modified":1610107929428},{"_id":"source/_posts/.git/objects/0a/1ff2fac6642cf91b4ccc5ee09cce86acbef9ce","hash":"9dea469fd0517e76e2455340e62bfc35b4ddb06f","modified":1610107926924},{"_id":"source/_posts/.git/objects/0c/98eaf1993cf3a02b2f6b476a26d48ae39e238c","hash":"1e4474979fb2cc69d07da60abc1b8f803c3065e6","modified":1610107961152},{"_id":"source/_posts/.git/objects/0c/ad513690da9a739d3bb58bc301ad939863c4d6","hash":"17da0f3d613ad31d8524efb1167e016302082df5","modified":1610107929776},{"_id":"source/_posts/.git/objects/0c/e39b9b931444a73f75d53aaf65bad9eee67ace","hash":"523ad8b8002a1b795cbec1b16a799a4990984add","modified":1610107930360},{"_id":"source/_posts/.git/objects/0d/783fb599bb9b5f336167220e1985339eed425f","hash":"b66453dcc1a880b651f37d592fbcca3148980fa6","modified":1610107928730},{"_id":"source/_posts/.git/objects/0f/3ac9630a39d55943648f4a6598e11137f8a01a","hash":"72b3a9ff16a2bd749897be60d42217b187d36afe","modified":1610107929062},{"_id":"source/_posts/.git/objects/0e/1c3b359f0df905c45d751a009e2db0b705aff6","hash":"5a61ae38bf957200cc1db6d97343503afb635462","modified":1610107921882},{"_id":"source/_posts/.git/objects/12/4285f1177a0d1a55cc6b99e216275cace96995","hash":"e7a51d00272091adc4ad51db3ba18b23b3b022c5","modified":1610107961230},{"_id":"source/_posts/.git/objects/10/19ac974ea6da2299c6809787f1c5fdc3acda38","hash":"0c6dccb030adc11c72d41931810de65c7c672d1d","modified":1610107931237},{"_id":"source/_posts/.git/objects/0e/4d1ef40e8566f1a780325790fcdc869249e491","hash":"83f13da4cd6575f4d0b7b1f20e8be5ae8fa96cf7","modified":1610107927898},{"_id":"source/_posts/.git/objects/15/9e2ae8763869263de9b597b88f227f96c77e39","hash":"6701130225a357d5c0e7c3a9e94e7685a056bd01","modified":1610107930240},{"_id":"source/_posts/.git/objects/13/554656ea8f44ef03112f176550e6c1caa8edda","hash":"63313767eaa6c59f9d17222861b60e3b53e12a5b","modified":1610107927027},{"_id":"source/_posts/.git/objects/15/bec9d476ed23a8aca54699f2bbf53d20dad04c","hash":"c42d981499cbd8289a11e2f336dbe0c7cfc7359a","modified":1610107925601},{"_id":"source/_posts/.git/objects/18/9815a636e875e70098cdc292dff268c68152ea","hash":"e08e43b284c324ebf8b115c4da4f1a9904d3045e","modified":1610107961470},{"_id":"source/_posts/.git/objects/1d/f04d7cffee88d4b79b4897fe7373f7b27caea2","hash":"648c03cbe9e268f124cd9cce12f2a8dfcc002110","modified":1610107925800},{"_id":"source/_posts/.git/objects/19/f114e860f68907e46e3f56d21c004144b98559","hash":"8b143c6f2df017a33fc6c22cef4e2582ad1fa5e4","modified":1610107926147},{"_id":"source/_posts/.git/objects/17/c1628ce10630cc7fe08a6b89ef65c49c96295a","hash":"dd563ff8551c571e513e0b07bba0c964fbcf4e7d","modified":1610107961286},{"_id":"source/_posts/.git/objects/1b/1589b522925a02479afa6814938edc266924b0","hash":"4542c8c6de95928cacffb62a4c170277673756e7","modified":1610107926125},{"_id":"source/_posts/.git/objects/1d/b8b4697e7bcb09422e9f040ed9b05011c15737","hash":"99e543358e60e7424765ca88fcb64746fb014921","modified":1610107929680},{"_id":"source/_posts/.git/objects/1a/8d0d519907e0658239ba09c359f2724798f919","hash":"27d29c28ee10208dec0ef207f3826fbf37bff776","modified":1610107921836},{"_id":"source/_posts/.git/objects/1f/01284885c1995f278aaf1333ace24d06153b4d","hash":"174bc018b08bbad22237d787a533d68b7ddc528e","modified":1610107961547},{"_id":"source/_posts/.git/objects/1e/aa80d779195ef7d82f87a9ceda09a295737edf","hash":"041de443a217a288740172da282a9e9da618640c","modified":1610107930395},{"_id":"source/_posts/.git/objects/21/3837221afab1a2360ae5ab229c592e3c67a783","hash":"36734667f30b0578555229ed1177f93220992f73","modified":1610107922864},{"_id":"source/_posts/.git/objects/23/5d11b0bea9edb920ad30ab1e67ef53e2c8d69b","hash":"c22029f61c5945faa35388f82719061d70dec3c3","modified":1610107926990},{"_id":"source/_posts/.git/objects/2c/18587242e958210131ffdd4d4a5eb9ef4fb790","hash":"9b08881030b7ce89d1e499bf6764a31bb2e98a6a","modified":1610107961445},{"_id":"source/_posts/.git/objects/25/f1deea363f24ef9be8f9decfb16473f8f0585c","hash":"483b6b2e09cd51071b895923c01d92903df4f8ec","modified":1610107927587},{"_id":"source/_posts/.git/objects/26/4748f4e4fcdcd21c9481e325b13efea4a15171","hash":"7ebc0828e5d7416612e40dfe5cb94ccf96d4cc4c","modified":1610107928808},{"_id":"source/_posts/.git/objects/2e/316e9b2feff133306ad0ba85918164148e26ba","hash":"92ec5df2d6e37712ce7bbad54f459a1b62d62469","modified":1610107926347},{"_id":"source/_posts/.git/objects/2d/8ea81d3cd4c293c1d24de0a1f4a1230ca6f936","hash":"4a4a6c688b777aede75cdb186374d390f1928f6c","modified":1610107922523},{"_id":"source/_posts/.git/objects/30/9f77f63fb630961ba8fc9c5313f8d81c74a6df","hash":"6f6a463eea492e393a54520036801b388a5b562f","modified":1610107927059},{"_id":"source/_posts/.git/objects/30/ceab6e40057cbc2f7edd4de2b06bbd98463db2","hash":"22ed8e907d45da9b74edde720580499c5ea6083c","modified":1610107928581},{"_id":"source/_posts/.git/objects/31/f00fdd95f783ca9918dab11b810ffa13774203","hash":"241b2deadf6f42c1b1e183b700b55ba06a12e3b7","modified":1610107924961},{"_id":"source/_posts/.git/objects/32/d4b530d3daa5f5630521b8a5c3f863ca279dbc","hash":"40ddbf2d079520b61658393a357a49353eeb4d39","modified":1610107931716},{"_id":"source/_posts/.git/objects/35/ca52feff6468ed360e87d9b9ebe37b6e7bb4dc","hash":"66f328d2b6804d543964550ae2e27c4eb945d63f","modified":1610107922832},{"_id":"source/_posts/.git/objects/37/9a82f5c04dda2c87970266c3e9375ff08d062c","hash":"2a7d951abe840011bb3da2adaf2c864443363c5e","modified":1610107926559},{"_id":"source/_posts/.git/objects/35/3ff1d5ae68e86c1f8f1e5adef8b79f32f0189b","hash":"3395b18ce305934940cddbb0a89d0f2c7fb309df","modified":1610107929305},{"_id":"source/_posts/.git/objects/3a/023d644fc8d59aec402f24e6ab6ec991398106","hash":"05f79af025d24d64ec3820f9b111e09411781ca0","modified":1610107930973},{"_id":"source/_posts/.git/objects/3b/71175d8905992a742473a9a7a6d50e4c156c20","hash":"f3aaad59c3aab806843ad06c1f0cf46c9e6d426b","modified":1610107927366},{"_id":"source/_posts/.git/objects/39/d9b2af27a2eccedfa19dd220f5d1f52c5f1b0d","hash":"579372544c553aa863a7b6f5b630f0ca413107ae","modified":1610107929274},{"_id":"source/_posts/.git/objects/3f/454d88b9e5b5140b884f0da8f2a719a8d0c5a1","hash":"99b4be24b850d31b7bd3d8f7b547b1066ce5fca8","modified":1610107927864},{"_id":"source/_posts/.git/objects/3c/bc67067a450b159e65560093b0275901a2114f","hash":"b105bdc77fc7d6637ffbac26b4e4037f3a643ac6","modified":1610107932015},{"_id":"source/_posts/.git/objects/3f/3556f9a8b9dbfc75f14e0d6eb4a4b39dbe557d","hash":"3348a8a88a62ba390defa42c4b1bbf4f0f6667df","modified":1610107924029},{"_id":"source/_posts/.git/objects/42/0f19649350f3e5abecf0521ad977003773973a","hash":"768b6fbd1266d90f5e4e17b06651df4fb5b21516","modified":1610107961007},{"_id":"source/_posts/.git/objects/42/71b19c6db4f19b911a3f5810374ece83239719","hash":"007ddf3e36dc0d43b470fdba82a0be35d59cdf3a","modified":1610107921713},{"_id":"source/_posts/.git/objects/43/209e50952297562dbfc65fe77b05e39fa0bc2f","hash":"137ed297e712cb8bab89667a3f2df8bb5109e5fe","modified":1610107925020},{"_id":"source/_posts/.git/objects/42/c11643b0b2f0cec22ec5da2e15aee61c6f3cc5","hash":"024fa87d03cd6c7d6fe904b380dc0242dc5e59a0","modified":1610107929507},{"_id":"source/_posts/.git/objects/49/4d8b9e48c2f345c2c85735aac154956adbb253","hash":"62a4125bb05b51033527e361ce5ef38cdae5b65e","modified":1610107960906},{"_id":"source/_posts/.git/objects/45/96e0ff95ec2cbc60f7c5476c159e838a4e3215","hash":"76faa0d2f7c1df9dfb4a72a3fb8ce4e2c1a97b75","modified":1610107926891},{"_id":"source/_posts/.git/objects/48/718bf20dae084ed1170399a90917a21cc45f07","hash":"94a582a0aff224ab3ecb7e2e2d8fa58c2a5a2969","modified":1610107961522},{"_id":"source/_posts/.git/objects/48/b16fb9dcae5ecc90cbaf8e224e699ad89ea0a3","hash":"e3fa7e9b378a2a02da219fc3ea1ccd52fbde03df","modified":1610107961416},{"_id":"source/_posts/.git/objects/4c/20ad7637eedd53489c2d8ed03e94335fa50f32","hash":"f20b35b417ca5fef1b949c81509f023a3e30b7a3","modified":1610107923949},{"_id":"source/_posts/.git/objects/4d/1234b2be2121958948f1f13f3e5720bc65c837","hash":"c3bce8299492f4365c40a69bd6bde6d9f2bc0a1c","modified":1610107929720},{"_id":"source/_posts/.git/objects/52/3947504e994413ae54da2e5ce7ac71c1a6af0f","hash":"7eccf1e81f62436eb6d53dc7d2efe39bba4fa3d5","modified":1610107927096},{"_id":"source/_posts/.git/objects/52/01954c1ea19da718b799bef7dfccda2b299838","hash":"cea4214e8e3212eb8a5fcc1ef01452eb70771071","modified":1610107924288},{"_id":"source/_posts/.git/objects/53/989a5d6ad2ae1a11e77e065ce6cd5c43c6a352","hash":"963f2a5537a0a0f8dd1149b7d285ffb0c6c89852","modified":1610107927653},{"_id":"source/_posts/.git/objects/58/53878246dcf5dc17c4c504349b99918e1e92bb","hash":"7e983ff5015cf5addef7b1c067a746380b8d3369","modified":1610107938650},{"_id":"source/_posts/.git/objects/58/73aaa36fca422ebd523c0ee991b1df91ab6009","hash":"c1e5ec8606ddbbdb63ec7461600b568637845fb2","modified":1610107929394},{"_id":"source/_posts/.git/objects/5b/7df9605b2b3185cab60c4ca5ad7752fb19e4b4","hash":"bb4eeef3b3d549ab716d68246cc4fbf13b633a8d","modified":1610107961686},{"_id":"source/_posts/.git/objects/5a/b961c32df140e053639345cba8e8f2049af122","hash":"2d75167418b5f2dee795abb8f68cc29b341cf81f","modified":1610107923580},{"_id":"source/_posts/.git/objects/5d/0378261f2ade8851cf39ce5e41c2837d53a380","hash":"866fd63067552ab411a1c1d35908182894cc2f98","modified":1610107927288},{"_id":"source/_posts/.git/objects/5f/af4c05c50781e9d8843bdbfae7a8171dd336fe","hash":"d68ae610a9ce440cec8017e35462abf53e4b7393","modified":1610107929539},{"_id":"source/_posts/.git/objects/5f/1efcc6f406f229a1d320d520c54da61da208d5","hash":"123e7a2263e10f0146f368f733b9d9ecaa08434d","modified":1610107927253},{"_id":"source/_posts/.git/objects/61/3d55a168c1adf8902bc5dd1584f77190b95b2e","hash":"b848213fd8935e3bd1664cf2621003484207472f","modified":1610107923664},{"_id":"source/_posts/.git/objects/5c/5b30ba6f119a1ab8d722b6d203a4943c94e65f","hash":"f2268d2f66cf06bdb24c911877bd63b0419eaf5e","modified":1610107928183},{"_id":"source/_posts/.git/objects/63/5d4a7089c2e0c6ecb797d076d85bd240e42cd9","hash":"e8086ca6f3caface8b02d7bf9d63889f34bf8b13","modified":1610107931206},{"_id":"source/_posts/.git/objects/5d/eff94c298777b872b178f5abb8b8f9a6eb5735","hash":"bfab4b0f5e0321b730a45cac4310dc599a7a346d","modified":1610107929092},{"_id":"source/_posts/.git/objects/63/75be2ee7dbb4672497d78aec35568572ac0dcf","hash":"4803778b3dedcf19af4bbd752118294cd5c46190","modified":1610107930853},{"_id":"source/_posts/.git/objects/64/bc53950986ecde536bbbfc9bc746256935d9c6","hash":"295326a8cc367d1fadc52b38873ffdd8e90cb09a","modified":1610107929987},{"_id":"source/_posts/.git/objects/68/065818ec522799fc98707a9b9b084c37829f8b","hash":"7614458d480298eff43f8bbd2dd7165a1725b6ad","modified":1610107931014},{"_id":"source/_posts/.git/objects/67/c78d6e03dea23172730b03f62344d9c8d38c9f","hash":"61f459fc00d789c43d06e63df4114e4b4355453f","modified":1610107922594},{"_id":"source/_posts/.git/objects/6e/e75eab6ef265571d9b8197368aa54e26920eca","hash":"2afec855a4adef28acc5b17827e1bdf51df3a6e7","modified":1610107926312},{"_id":"source/_posts/.git/objects/6e/ff8f18d44276bae54bfb3370f8e37dea522e7f","hash":"d09d6a0b86ab0875df1689e0db07f6ad4b50cff9","modified":1610107928098},{"_id":"source/_posts/.git/objects/6f/a42f6fda1d5cd6f178f96fe100a667200aed01","hash":"6c49358a2edf93fe82a63a3b32a9a44b51833f6e","modified":1610107930506},{"_id":"source/_posts/.git/objects/71/eda24af57e45fc78e94dcc5aa7ae785533039c","hash":"d2a3c532961a9e86946e4e9e194b2cae97dc5947","modified":1610107929642},{"_id":"source/_posts/.git/objects/73/a4b77720948f3a1065746b6d15891cbd8ccb0b","hash":"bc2a3a30842a996abbc0ce90ed651468097e5969","modified":1610107926079},{"_id":"source/_posts/.git/objects/75/a5e8ee87f2ee503142c6a2d5cf433f7caefeea","hash":"8c319271f5836efb81a3210458fb470d16c9dbfb","modified":1610107927466},{"_id":"source/_posts/.git/objects/77/ba6b9fe858e436a5940ed40c547b19944aa7f6","hash":"b74ff1ab973058159b4ac4758840f539d7c1a87a","modified":1610107938928},{"_id":"source/_posts/.git/objects/76/7dc45bb694070de0adab29bc53d58d7618c58c","hash":"e0483dc46e3cd8a01b8c3686e304cd3c056070bb","modified":1610107929361},{"_id":"source/_posts/.git/objects/7a/ef1fb5c547b0d00a84cfeac975f773aa9c0eae","hash":"17e1d6469d8accb0afc57aee0b8b9e10780adb2e","modified":1610107930585},{"_id":"source/_posts/.git/objects/7a/fea49a4496ccb2aa6bc94431c9d3bd54b29a64","hash":"89c24ff35cdb005c6a8f91cb5bc1d0abc4d6925e","modified":1610107926181},{"_id":"source/_posts/.git/objects/7b/62dcdc883c89167eaf3483c6ab2774208ce57a","hash":"a10ebe2fc22865c67dfc8d22e7a106a9dab88a00","modified":1610107931145},{"_id":"source/_posts/.git/objects/7d/04d40afe50ff188570fbfc761788ec926bbe55","hash":"6965d1362b279085e4d488f67f3b0b0141270a53","modified":1610107961585},{"_id":"source/_posts/.git/objects/78/1ab81476ae0c366ae758b40b751bb053d6a555","hash":"05c44dd1d62750b7d597e338ae13ac645d1e47ff","modified":1610107922024},{"_id":"source/_posts/.git/objects/7b/d40453f7f1790e580164d8ccf4b69d39d41a42","hash":"a9b11ea16f36a9746b535cecaba27a86f3fc1f36","modified":1610107931772},{"_id":"source/_posts/.git/objects/80/91d38de82be8206e598127cb46897773522cbb","hash":"53f910d922c392db25455b14b4a0da582084e716","modified":1610107929911},{"_id":"source/_posts/.git/objects/7e/f7dd0dc1d45ace0d0a8cb4835991b8d201e068","hash":"50937e5bdbe64d450854ef924e5372d7f9c5eca7","modified":1610107926959},{"_id":"source/_posts/.git/objects/85/bd18e4bd2e2dfe5d80e4eb9c6cab9cfc493e5c","hash":"cdf35a97f4f8c18bd7f08338bb5763d9a1dc2030","modified":1610107931845},{"_id":"source/_posts/.git/objects/84/83968a82373d84450edc4aa8f706875e56c0d0","hash":"8d10c58f34bc1691c957eb16e7a108a575a2bd1c","modified":1610107922053},{"_id":"source/_posts/.git/objects/88/529e3d0690d741f9712d1105781409de55abcc","hash":"78db7c6270dd34b9f3eadd9e9df82bb35acea2c5","modified":1610107923335},{"_id":"source/_posts/.git/objects/8a/4eca0ef02186ce981da8bc90f2caf3874f0038","hash":"59550dc0612320a6f7326c0570687c7f23a8c119","modified":1610107923452},{"_id":"source/_posts/.git/objects/8b/27148aad449a7128dda5140871f4b31f337518","hash":"1e195d3f6a0b89dca0576f48506769fa4040205b","modified":1610107961780},{"_id":"source/_posts/.git/objects/8b/09b0b4e0f666d241ae92bd6df3f9e00a0b21fb","hash":"c81af1b0b443a55c08f1ba6823172e5e11942ef4","modified":1610107927615},{"_id":"source/_posts/.git/objects/8a/85eff81c3e8d571d09d3301c182b29318db622","hash":"786b8ab8a5c043ac763e9b960f8d15610199a74d","modified":1610107928411},{"_id":"source/_posts/.git/objects/8b/eb6fa011e1f92c9eeebcd15b274f233310753d","hash":"283f2e79c7631e94447d9da05a8e294922ac9aa7","modified":1610107923497},{"_id":"source/_posts/.git/objects/8b/5a196c0baae02d0a17728c49f98f6d8748b118","hash":"d20713141de0a0218df650a8d50c2025874c56ad","modified":1610107923080},{"_id":"source/_posts/.git/objects/90/62dcf86a2245fb8d2b245508de9d99640f8162","hash":"1444d30c1c195f180832fe973a95082715ec3db9","modified":1610107925367},{"_id":"source/_posts/.git/objects/86/a91182dfb646831968f4643f6d6e2a49a7c774","hash":"72bec552c296897f53bcf67e0b59909cbe3c6819","modified":1610107929238},{"_id":"source/_posts/.git/objects/90/b4bcb330c301f21fe1208d7e53bff64a1bc06a","hash":"6c61e1024320391163a07557fda3b4aded208a98","modified":1610107938138},{"_id":"source/_posts/.git/objects/91/2f008d80c0625ef0f59062bfd58a647acd71b8","hash":"54c438dd69de9d0706865de924b7946050a76e04","modified":1610107929886},{"_id":"source/_posts/.git/objects/92/e3a33daa6589e7a4b2193d29d69cbdfbfc4ddb","hash":"0e92685e257cac7c364c721b2641ad4094ee56a6","modified":1610107921769},{"_id":"source/_posts/.git/objects/92/d52d0cd578fa72c49108a385f65d2a72417f51","hash":"2748a24b068c2c5cfee413189a2c675801060c70","modified":1610107931815},{"_id":"source/_posts/.git/objects/94/640ee600bba380cfac10d6d0bdcf7364ab5105","hash":"35ffdf43ed1c409b2af61960d15212d037b9bea4","modified":1610107961332},{"_id":"source/_posts/.git/objects/96/bfa3d7a12f7d50877b0ee5809b7ff5e47f0e6b","hash":"6cc366bc72df842fe22c684c7d0a3c6792221c05","modified":1610107923530},{"_id":"source/_posts/.git/objects/94/e2cb2c9d08831e3c3e7f4127da41db143a2066","hash":"c44dc88d4014dd9b6f8e9f00dc6108b194b83c11","modified":1610107923900},{"_id":"source/_posts/.git/objects/98/b685a6708f7158a8d174fbe9a41480d0d6da4f","hash":"a18ab2925ce79b7cb5d374da0be822faed69237f","modified":1610107930640},{"_id":"source/_posts/.git/objects/9b/66705bf9636c0a929cb7ffd2aa5b041d90a929","hash":"d9130bb9a9f6dc9d1fb67c2d4162d16df480cd0d","modified":1610107929137},{"_id":"source/_posts/.git/objects/a0/4d82cda2519d17410097795f5e682d3ca73b20","hash":"9d408012b1cef3824ebd35de49defde850eb36c8","modified":1610107928122},{"_id":"source/_posts/.git/objects/9d/f7f1661d37892d6ad683f2744ba52357fb1bb0","hash":"d0e6054fae7000c39062fa303d89a53ef2ae1a2d","modified":1610107921655},{"_id":"source/_posts/.git/objects/9c/ec83c31dbc3c400ad32d3276054c2b5e499f49","hash":"1a7b7caec796a97ba68ab44b97ee782da516d3ad","modified":1610107927548},{"_id":"source/_posts/.git/objects/a0/9ee8408ea4d6cff3ee559a2481049460bb00f4","hash":"c18e1f7ee380f9af3a22d69ad9d0f1d015018edf","modified":1610107930616},{"_id":"source/_posts/.git/objects/a0/c5cbfdbbbe9784d5341e2830878ea1154e521d","hash":"5f087004997cdb58e8bb68d51dc7ae3195814002","modified":1610107923630},{"_id":"source/_posts/.git/objects/a2/50910ebef64258897f24b9f021cc9ce08ecd18","hash":"68a9adeee628ba541cf439df36a9c71bdb093076","modified":1610107923220},{"_id":"source/_posts/.git/objects/a1/e478688c428f3d3f2a8e3e4f4b0a7a4c6a445a","hash":"74b0bda0367de4f35f44bdf432ee96c85670fa84","modified":1610107925511},{"_id":"source/_posts/.git/objects/a5/766184b151bdbd09ffe4363f5344dba4997e3f","hash":"95c9e08a61e44e3fb81e67cb3f64fbf753af02a6","modified":1610107927328},{"_id":"source/_posts/.git/objects/ab/34c7af80160bb57bac7123feff40c7d3350fff","hash":"172418e6306a0436503467f8e81b5d8ee08bfa85","modified":1610107926102},{"_id":"source/_posts/.git/objects/a6/bb67eaca999f6b9a6e9ebe20f3640bc6a307c0","hash":"6cf6ee78602850d21332e2bdf6ae5e14803c5d40","modified":1610107928210},{"_id":"source/_posts/.git/objects/a5/df8515f9cadd123d7cbbd29a9c51bea63f978c","hash":"238894264704ac38c7c5bff1cf386b1856da41ad","modified":1610107928000},{"_id":"source/_posts/.git/objects/a8/783b52718f6a48051b895888a9c5a5b4e07707","hash":"6643985238587b5352638506dcf7c59a9906f573","modified":1610107928441},{"_id":"source/_posts/.git/objects/ac/24cbf90b1fccd26402bfa7039ffa5ccd5e75ea","hash":"5dc03453a20cb6757abd1fcd439e87c44496b9b4","modified":1610107931960},{"_id":"source/_posts/.git/objects/ab/7381985a31eb7370a25f2616f69389f22446cc","hash":"98f3eb66b0c70f4416afa08821b5a8c11406f0f8","modified":1610107962243},{"_id":"source/_posts/.git/objects/ac/ca7f071993f6bbef046457216b45a575e22a31","hash":"95b96d72af843cee792633d0e781deca86173e7a","modified":1610107926381},{"_id":"source/_posts/.git/objects/af/26512a39baf739c0bde5a09885998b0a4dee89","hash":"2b8380e4799527b580d6313b8685d43588e224f8","modified":1610107930289},{"_id":"source/_posts/.git/objects/af/a6e28d7f513ec58b172508199d0482c1ca94b0","hash":"753a76bb91e5e2e1490281b5cb4e5bc74cb7663c","modified":1610107930017},{"_id":"source/_posts/.git/objects/af/11017ed80b2014c8c53387fd0424b3f74b943d","hash":"c455e6ebfa03d181bd74d6e5c796f2eecd58aa04","modified":1610107927407},{"_id":"source/_posts/.git/objects/af/b0479621fa575fd2d4440292b3f553254eee2b","hash":"d07c9ceee2ba73ec3386f56e0433805f8e52b576","modified":1610107929854},{"_id":"source/_posts/.git/objects/b0/319aeae5bb27cacce93aa064ac7f429b639616","hash":"366268e3f36e29a0997dfffb1252a2e2a57d62ba","modified":1610107961630},{"_id":"source/_posts/.git/objects/b2/de1b0a1389179b2976e27e6a75c316b04c552f","hash":"afdf2c306272d914da36c41375c202ce2ec8fa6d","modified":1610107924916},{"_id":"source/_posts/.git/objects/b2/e32f522d6ab1c430957883f03e4664a01a3b9e","hash":"e6a9890531a9f1b515512c922a13a81b2bbf5e5f","modified":1610107927175},{"_id":"source/_posts/.git/objects/b2/7d2902681c157fd94d592dbf01bd5ce23a965f","hash":"4b403e6769a0cb446f38dfd046104dd1deb10656","modified":1610107930749},{"_id":"source/_posts/.git/objects/b8/88db49d8d8191463fcea9aa4182c3e85eb68c6","hash":"f07421fae54eac5632086fd7d7884ad97091ed4e","modified":1610107961744},{"_id":"source/_posts/.git/objects/b4/5b19294242795249574d4684f49d051fd866a9","hash":"024eeff1860d6dfb894f9dc3660bbc2ccbe31d58","modified":1610107927965},{"_id":"source/_posts/.git/objects/b4/aa6ef58f6ef7bb72f2a2277ddd274033fc2010","hash":"0c5411ddb0ded8474c6937aa37d86bc6a23d91a7","modified":1610107927212},{"_id":"source/_posts/.git/objects/be/2ffeaebb1d40415901240e3e28a1032ec931da","hash":"e971b9032f11cda458b8db3860c9ca84a969c594","modified":1610107925900},{"_id":"source/_posts/.git/objects/c0/2245c80351f406fdcc50dfcbce6efeefdcefec","hash":"2bbf7f73d49bdb8b22025539b3732de03aa1289d","modified":1610107928696},{"_id":"source/_posts/.git/objects/bd/e276d76fb5f1ba52fd255fc3f6a87f41dc0a59","hash":"308d450a5c44eb02c4d5f58bba091d43385e358e","modified":1610107938382},{"_id":"source/_posts/.git/objects/bd/081de514442313e6e89caf759bd9afd22e0d13","hash":"be69f1f2d4c142757a39843bfec5b22e99099a51","modified":1610107926675},{"_id":"source/_posts/.git/objects/c0/45c61efdc94269f8d992b0585f6106d3da8929","hash":"b4d765fc62a2f476219524ea71257d38aa2b5541","modified":1610107931520},{"_id":"source/_posts/.git/objects/c1/1cd95a132456ac6b59000324927019360de549","hash":"3dbc52da90c6cc8c026e62ca08a177f061728c47","modified":1610107931881},{"_id":"source/_posts/.git/objects/bf/67139ebce38bda222ad1be4051351200ec43aa","hash":"47459f23974c2832e17631333d10fb1853039303","modified":1610107925843},{"_id":"source/_posts/.git/objects/c1/358e88d0484bc7fc9e980d907fc1285853c2d1","hash":"1b3c31cadf22ff4c69d4e34ba42d198905fbe539","modified":1610107929744},{"_id":"source/_posts/.git/objects/c0/77a3e9b72fb977d514a1f258030b784f86ee40","hash":"83b7920c1d81f496fb180606fedae99b72d97ca9","modified":1610107926762},{"_id":"source/_posts/.git/objects/c5/2d33d6afc9526d3ac77384d9fd6cf7d8f487cc","hash":"7a78f98fb9b6f5c10a01ddc0bc2400866ebf5546","modified":1610107961829},{"_id":"source/_posts/.git/objects/c9/de33bf6393ab05718fc93ec37cf4c7bfd59ee4","hash":"0b3f8847de17c0e5a95964ce7d9b7ae78213f3ae","modified":1610107925182},{"_id":"source/_posts/.git/objects/c7/b7dff1fb869d3913a52858e3a2498d60153a35","hash":"0ec9fdb944f7312d82aecb2daed43bc90558bdf9","modified":1610107922487},{"_id":"source/_posts/.git/objects/ca/d92baf93a520dcbbaf4780ce74ee91d29d636e","hash":"b7d8b17d4bc7603d0d973f8ffb2472b9d1390e54","modified":1610107930329},{"_id":"source/_posts/.git/objects/cd/c5e9ac9101752bfd6f900f2e19f58cfa1a6f47","hash":"4adcae758b980a9ab105b4e678afd1358a2b9112","modified":1610107929024},{"_id":"source/_posts/.git/objects/cc/1fc7b8ce10900707b5e8dfe7778545485dfe87","hash":"99ee5798428285126da49f8b3244549dbb33bc08","modified":1610107926868},{"_id":"source/_posts/.git/objects/cf/0fdf8057814d09bc4d48d217286660fc265138","hash":"6029b0fe1cc69e40fab3c5e1a7c1b1cf9956f8e4","modified":1610107925771},{"_id":"source/_posts/.git/objects/d0/4694ebc8518dea6061b5228bdcf05ef2adf037","hash":"1ad80a76d30716b185bb4200db80a2b45e7a0b1d","modified":1610107923869},{"_id":"source/_posts/.git/objects/d1/47820cf2d9c923f983889bb5dd7940ebe72692","hash":"cce019218f4719c3aec76034110eb356bd12527c","modified":1610107926057},{"_id":"source/_posts/.git/objects/cf/c8e0855cd34c86dcc1b46cd9ec3155133a7775","hash":"363f1cf5ff5e58ed89314acc714f40459ccbe1f0","modified":1610107928846},{"_id":"source/_posts/.git/objects/d2/a84228a9d831dd7217633922629f8a9ea446bf","hash":"59799c6805c02ed3a1e5294803d23614b670885b","modified":1610107923406},{"_id":"source/_posts/.git/objects/d1/592657fb0e0e7c5d00886563a0c78e5d464397","hash":"ad8828e7e29440efa2720c58e2265285bd253fc2","modified":1610107927780},{"_id":"source/_posts/.git/objects/d6/f90c328b19db4527cf07d19d2d36d584408ea8","hash":"5cebccd2d31a40e4cfd99a01c85bf13750a43c34","modified":1610107923142},{"_id":"source/_posts/.git/objects/d7/71d92fa0256db854001ebd937b873370cf7027","hash":"3a2a33086a472dfd415e685a4d36bc227c4c0eb1","modified":1610107925739},{"_id":"source/_posts/.git/objects/d7/aa969470e1a056cf9e1da110f6751b2302ff95","hash":"54d2d3054097d281c7cf94a0f721c0b3129498d2","modified":1610107923766},{"_id":"source/_posts/.git/objects/db/c3cf2b27ac993a8c3c2130a589a218daad2044","hash":"c9c5a708e4ce8d6912a18c38fae93e99da7f7a15","modified":1610107925564},{"_id":"source/_posts/.git/objects/de/a0cdb40b0cdaff62b10399310d6b0538903e4c","hash":"85d379c55ab041492d12f99e3576b1a5cbb8b199","modified":1610107928156},{"_id":"source/_posts/.git/objects/df/0ba69ff056496b5907dfee35f394f7c69a6971","hash":"496538ea7f5f7cab6487f6ab77159d9d9cbe8d9b","modified":1610107926270},{"_id":"source/_posts/.git/objects/e0/37420288c7f5ec19b90a3252f829bb1c0111aa","hash":"6e14d33e04bc2ba1d6b7024249e52dc22c350fc9","modified":1610107930055},{"_id":"source/_posts/.git/objects/e3/a69d2ec15c147be5522458563d3364e7b876dd","hash":"0c62dc3ee87b761af7ecfa7cd45a0f8be904e8ef","modified":1610107927720},{"_id":"source/_posts/.git/objects/e6/69a2e965a555e7d1045a10c483181439085b67","hash":"023a674e5d6d9c10d4152d896d66a57dd1749b05","modified":1610107927682},{"_id":"source/_posts/.git/objects/e9/732a94df398f7e6ce1529693c77ce6ef215ba3","hash":"ee558a7cc985691ba67ea4e34429d856057cd5a3","modified":1610107929207},{"_id":"source/_posts/.git/objects/d9/76c3ec899cfba71b51b153af7fe3183300bc7b","hash":"1adc2d5d26bac78d3b4cc92cabb02c85d6b2fcbe","modified":1610107929601},{"_id":"source/_posts/.git/objects/e6/72a1344e30ca7376352b61c96ac9dd3e5da366","hash":"646c6423ffb55bad110ab6ea4937cd7fd527ddbb","modified":1610107962145},{"_id":"source/_posts/.git/objects/ea/5ae35adffbfb35dabb31872487b863fccd19af","hash":"03f156ad34dbd6a40fa5c25808c429ad85f393a1","modified":1610107961947},{"_id":"source/_posts/.git/objects/ea/7d53683e1e4553ce60a50fb5443fcc8fbfcb7a","hash":"4e5d60f6e2d7116acbef86be3e1a13bd242cd02c","modified":1610107930428},{"_id":"source/_posts/.git/objects/e7/77dca7b8c9067ecb94aea0120ae52dfa904a7c","hash":"e17af0e0fa8496646b6c24453e9c00aad302f18a","modified":1610107926594},{"_id":"source/_posts/.git/objects/eb/5033e4f670f78c9239fdd296ab32c8a64d445f","hash":"80d1e983ad45c4003afcaabcd3bdc34a53e36849","modified":1610107928043},{"_id":"source/_posts/.git/objects/eb/695be8c89984593f9a6e298fc0957db0b20b6e","hash":"9cb6e9c062da6a6dee933070ca42a72e317c4729","modified":1610107928970},{"_id":"source/_posts/.git/objects/ed/5237f4d94aec88213ce28a140dfa8bbf3c1820","hash":"589a6176319f8c640c90e215eab8279bff73e45d","modified":1610107929833},{"_id":"source/_posts/.git/objects/ed/ed20b7892a3fe0de3da9ce2ec72e1c75acef6b","hash":"32e8b0b44fb5f15f9acf11360c5bea09838ce75d","modified":1610107930798},{"_id":"source/_posts/.git/objects/ed/a6bdba4596af32a3b41cf9ea5a80cc8e918973","hash":"b4795233f57d7a952493a181574aaa1a00994d21","modified":1610107930931},{"_id":"source/_posts/.git/objects/ee/909824a8cb1f3e47b41861934aadf057bf686b","hash":"8d6d90f3e25620376afdbfaf9f24a95bd0d3fc41","modified":1610107922970},{"_id":"source/_posts/.git/objects/ec/7b2632ecd10a39a903d4681cb2ed76949ef340","hash":"4b9c65422e222c76eaf3a293185182cb90aef258","modified":1610107926623},{"_id":"source/_posts/.git/objects/f0/f4957b7617d0a74f9fa466c178277570e126bd","hash":"e144b28f8538e0da669c045e8188e8c57df8bb95","modified":1610107928774},{"_id":"source/_posts/.git/objects/f2/6b7064f38a2715923648e71767cb71fabf723c","hash":"bc96dcc6a80dc8aafe79b23d2e8459cec4b78962","modified":1610107922889},{"_id":"source/_posts/.git/objects/f3/41cb0ad6317b61c2bbcf0abd285ac219f9beb0","hash":"501fcced4d06084804728f5416440888c15dc59a","modified":1610107923177},{"_id":"source/_posts/.git/objects/f3/dce878bc6e355952d9915d6f7fbf7dfce0881a","hash":"274ad2c00c19ccfbb90b9e146f0a773967bd5177","modified":1610107961107},{"_id":"source/_posts/.git/objects/f4/fe5abb7be599961add8f3d4e8e79b5f4828d91","hash":"3a796ce26f242e68cd1b8724c015a32c3efe8794","modified":1610107930086},{"_id":"source/_posts/.git/objects/f8/673ab71cd2f9ae56af095a0b2475e865a9284d","hash":"5dcfc4be77396f20b9b82c17bd5d2721b2ea1bfd","modified":1610107929171},{"_id":"source/_posts/.git/objects/fa/36c596bac47064af9b53569b67f37c3eb588e6","hash":"233cf23da1468e6e5160f3a317e17333d99b6c2a","modified":1610107928066},{"_id":"source/_posts/.git/objects/f8/7b797bdef0289129de98f11658c4c74f540139","hash":"b4aaa2969755b95b4bc0c4466394bd3fd158ed54","modified":1610107926018},{"_id":"source/_posts/.git/objects/f9/7d7a76cdb896f31ac63f6970723c23a1469657","hash":"1535e6b670c5e97c7acbaf9fa32942a8c2637739","modified":1610107927933},{"_id":"source/_posts/.git/objects/fc/7c5e17b0423daa2cc622c24a48d6fe20c0abfb","hash":"6cc973f9a0c66a514c5beb30b79d311af519c02a","modified":1610107938343},{"_id":"source/_posts/.git/objects/fb/f869d52c46f9d03d44a157141e6898f76f0522","hash":"6786621d121ff014193c1b5a5ca033f74fc7513c","modified":1610107926839},{"_id":"source/_posts/.git/objects/fc/0f7c1517c3db76fa432f836c281b4893ebbbd8","hash":"cd875fd30f7c63dbf7cd5de49513f5606d04ecb7","modified":1610107927749},{"_id":"source/_posts/.git/logs/refs/heads/master","hash":"a46a0fbb6ce7ac880677354a1108b97fb54030bc","modified":1610107962312},{"_id":"source/_posts/.git/objects/ff/5bcd74833bb98274300413d39e3736c4314cfd","hash":"07312d92a9c730ebe8a3ef77e0b45dc8f4886e6a","modified":1610107960950},{"_id":"source/_posts/.git/objects/fd/d2340befe082ccb1195e31ad217f035d3a4ce6","hash":"f827df056105e5e187436c314a9cf3e547255f23","modified":1610107929942},{"_id":"themes/Fluid/.editorconfig","hash":"b595159772f3ee1ef5e6780ce307270e741cb309","modified":1608117878652},{"_id":"themes/Fluid/.eslintrc","hash":"3df89453e1f63051fafc90f16a8d83951050e316","modified":1608117878653},{"_id":"source/_posts/.git/objects/fe/b11a11fb7e2bda2d123f2fb073ae97027a4007","hash":"56813998e13c8555efcd93c5b74459013e0f8afd","modified":1610107923822},{"_id":"themes/Fluid/.gitattributes","hash":"3e00e1fb043438cd820d94ee3dc9ffb6718996f3","modified":1608117878653},{"_id":"themes/Fluid/.gitignore","hash":"5d7e78749ba0a1efcf61253d4a9e50fc6ce0b4bc","modified":1608117878659},{"_id":"themes/Fluid/_config.yml","hash":"718d4ae12bde234ae25aff26ab3ac23085148b66","modified":1612190336536},{"_id":"themes/Fluid/LICENSE","hash":"653274b0f005f82768a7e5e17a32d38bfe38d492","modified":1608117878660},{"_id":"themes/Fluid/languages/de.yml","hash":"288f649c2c2314eb610693b18853ee74f0541e87","modified":1608117878664},{"_id":"themes/Fluid/package.json","hash":"3a77d0d197419dfe1ad759f0e5b2fb27d719965a","modified":1608117878684},{"_id":"themes/Fluid/languages/en.yml","hash":"31f2867619a768606166778d4ee51f3d00ac33a0","modified":1608117878664},{"_id":"themes/Fluid/languages/zh-CN.yml","hash":"3b92f4428d66c31610f6cde13b82ee723aff00d2","modified":1608117878665},{"_id":"themes/Fluid/languages/ja.yml","hash":"dc43be11a300893ebef47283c22f2f946ca21260","modified":1608117878665},{"_id":"themes/Fluid/layout/archive.ejs","hash":"7a1e19dec37804927f0d331d7e6c80ed03becd61","modified":1608117878681},{"_id":"themes/Fluid/layout/404.ejs","hash":"79a598e43c40d48b23076361720f1e77df466e41","modified":1608117878666},{"_id":"themes/Fluid/layout/about.ejs","hash":"22acb19c193fd215d0f5d5668fbf5ca5f5407388","modified":1608117878681},{"_id":"themes/Fluid/layout/category.ejs","hash":"dd2bd15cbd811d6ea973b6e6a17d99e36151e274","modified":1608117878682},{"_id":"themes/Fluid/layout/categories.ejs","hash":"0a8fe294cbbcc5112e360fcfdef5925fd39580bb","modified":1608117878681},{"_id":"themes/Fluid/layout/index.ejs","hash":"f061580cd54f39b510c6f4d3331ad301becca74c","modified":1608117878682},{"_id":"themes/Fluid/layout/layout.ejs","hash":"4bb0917c1e532bd55bac3dce3ec6117b38f340f7","modified":1608117878682},{"_id":"themes/Fluid/layout/links.ejs","hash":"8efaa2ab9804df1b3f72b6940b47247eb7853b66","modified":1608117878682},{"_id":"themes/Fluid/layout/page.ejs","hash":"9f4a66735082127fd0792ba747029212e63c90a1","modified":1608117878683},{"_id":"themes/Fluid/layout/tag.ejs","hash":"3a9296eb7181e8b3fb0cdc60cbafc815b98d6f51","modified":1608117878683},{"_id":"themes/Fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"beb3474d6f65c1e56700ba872c6a0d0836d4168e","modified":1608117878654},{"_id":"themes/Fluid/gulpfile.js","hash":"1ad8861ce4f702c164f908efb6c1c6504154ed2d","modified":1608117878663},{"_id":"themes/Fluid/layout/post.ejs","hash":"71a2d016bf1929943e6e849bf20c2c7434b6852e","modified":1608117878683},{"_id":"themes/Fluid/README.md","hash":"f75577ec5abe2033077dae29354d46041c7aeb96","modified":1608117878660},{"_id":"themes/Fluid/README_en.md","hash":"2b47ed68ec888dcc34fa6aad9ce95aeba6744fec","modified":1608117878661},{"_id":"themes/Fluid/layout/tags.ejs","hash":"b7c1a6d8fc1097fc16d2300260297013cb692153","modified":1608117878683},{"_id":"themes/Fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"5cc30e7b6e7b77c8b40b182ba02a5d93d37d2fc2","modified":1608117878656},{"_id":"themes/Fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"78ce211415d502c5a4398d786d5c697d34d868b9","modified":1608117878655},{"_id":"themes/Fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"7db378613df2b7d13e8c428c006399a879a4a852","modified":1608117878656},{"_id":"themes/Fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"18381d03518526d7cefd024a0bdd8d9e7c6440f5","modified":1608117878657},{"_id":"themes/Fluid/layout/_partial/archive-list.ejs","hash":"7d780309e12c437c2f8a246dd2fd0c272b8636ce","modified":1608117878667},{"_id":"themes/Fluid/layout/_partial/footer.ejs","hash":"a886be025d5e3b2c49657ba30e459f980a7cc75e","modified":1608117878674},{"_id":"themes/Fluid/layout/_partial/beian.ejs","hash":"53d9f79b4a3b71d2e89872fa138bc09611862ee4","modified":1608117878667},{"_id":"themes/Fluid/layout/_partial/css.ejs","hash":"23ead7d3e6c9a86ca0076d0ef7db98f3bb4c9b08","modified":1608117878673},{"_id":"themes/Fluid/layout/_partial/head.ejs","hash":"e0a374abd17d436e47c224519abe889050859158","modified":1608117878675},{"_id":"themes/Fluid/layout/_partial/nav.ejs","hash":"a2c16035ea5690882159f9df3a9ddb77ea74b4af","modified":1608117878675},{"_id":"themes/Fluid/layout/_partial/paginator.ejs","hash":"8191c630b3db4dd1dd8aad56defad93334a7b691","modified":1608117878676},{"_id":"themes/Fluid/layout/_partial/scripts.ejs","hash":"7026b27fe961f8f821757b84340a55ffdce7e37d","modified":1608117878679},{"_id":"themes/Fluid/layout/_partial/post-meta.ejs","hash":"3f16de8c40d87c7d23eba121dd8061757c3f9a58","modified":1608117878679},{"_id":"themes/Fluid/layout/_partial/search.ejs","hash":"bea21f1b5de61badd6c068080315c201fc80bc36","modified":1608117878680},{"_id":"themes/Fluid/layout/_partial/statistics.ejs","hash":"a70c26e415a27f07f38b9384e7eb48d1f2b30328","modified":1608117878680},{"_id":"themes/Fluid/layout/_partial/toc.ejs","hash":"76e6bc368cf46d4103ea9514699e10ec0b9a4b56","modified":1608117878680},{"_id":"themes/Fluid/scripts/events/index.js","hash":"a889022b079541f0fa5833f018c98cf81f864e4f","modified":1608117878684},{"_id":"themes/Fluid/scripts/filters/locals.js","hash":"2340a576635b16fd2456b3494f5afe89cd7764db","modified":1608117878687},{"_id":"themes/Fluid/scripts/filters/post-filter.js","hash":"1827cb42259dbfff1d072c5c8b388bf7d76e6acd","modified":1608117878687},{"_id":"themes/Fluid/scripts/generators/local-search.js","hash":"bda7fbe58082a2a02c0db066794b791b14462271","modified":1608117878688},{"_id":"themes/Fluid/scripts/generators/pages.js","hash":"a2a15ea722863aba09dcad578558432682a3b6b3","modified":1608117878688},{"_id":"themes/Fluid/scripts/helpers/page.js","hash":"49b2c6449d7be35739c6cfea3cab4e790580983a","modified":1608117878689},{"_id":"themes/Fluid/scripts/helpers/export-config.js","hash":"c0c6b38b41300c44a5e031f9cf8ad436af763762","modified":1608117878689},{"_id":"themes/Fluid/scripts/helpers/url.js","hash":"1664f8faa028898bd6f91d6db61c7dbf7463ee01","modified":1608117878689},{"_id":"themes/Fluid/scripts/helpers/utils.js","hash":"4acb213f90f1e7ba3696ef08d894a2a84807b669","modified":1608117878689},{"_id":"themes/Fluid/scripts/helpers/wordcount.js","hash":"da6144ee040fed0a9b9f45da3478bc33087b5ac9","modified":1608117878690},{"_id":"themes/Fluid/scripts/tags/checkbox.js","hash":"dac0e08eaa3614a6fd9ddbdfb4584094b1bdb30a","modified":1608117878690},{"_id":"themes/Fluid/scripts/tags/button.js","hash":"e1d0caed12e7cd9a35cf64272c41854b2901a58f","modified":1608117878690},{"_id":"themes/Fluid/scripts/tags/group-image.js","hash":"cc176cc1d7e7cc28cedf8397ae748c691d140be2","modified":1608117878691},{"_id":"themes/Fluid/scripts/tags/label.js","hash":"6c5916d86c63795c7e910bf614b0e7ece5073702","modified":1608117878691},{"_id":"themes/Fluid/scripts/tags/note.js","hash":"0410e9f982f19e71eb166da31e967a628dfbddcf","modified":1608117878692},{"_id":"themes/Fluid/scripts/tags/mermaid.js","hash":"dbfe59fde77d87b1d7d0c46480a2a729010988eb","modified":1608117878691},{"_id":"themes/Fluid/scripts/utils/join-path.js","hash":"ec068c699155565aea4aa4ab55d8a10b2947a114","modified":1608117878692},{"_id":"themes/Fluid/scripts/utils/object.js","hash":"d07abe58481ab097fc4e5b9f573cdc46bce4bfec","modified":1608117878693},{"_id":"themes/Fluid/.github/ISSUE_TEMPLATE/question.md","hash":"102213e5d6790d060c0e26b4a3a7ec744d753c52","modified":1608117878657},{"_id":"themes/Fluid/.github/workflows/lint.yaml","hash":"17f7d9aba4420011b7665275c58f838557d2434c","modified":1608117878659},{"_id":"themes/Fluid/source/css/main.styl","hash":"bf536db598434c36cc0c752196bfde46e584a92e","modified":1608117878704},{"_id":"themes/Fluid/.github/workflows/limit.yaml","hash":"bdbdb66da69ab7353b546f02150a6792f4787975","modified":1608117878658},{"_id":"themes/Fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1608117878705},{"_id":"themes/Fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1608117878706},{"_id":"themes/Fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1608117878706},{"_id":"themes/Fluid/source/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1608117878705},{"_id":"themes/Fluid/source/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1608117878705},{"_id":"themes/Fluid/source/css/gitalk.css","hash":"1fe60b2ab1d704f5a4f55e700dca5b8785fb390e","modified":1608117878704},{"_id":"themes/Fluid/source/js/debouncer.js","hash":"8833902327af7beac17ab97227fcd835329abfa2","modified":1608117878707},{"_id":"themes/Fluid/source/js/color-schema.js","hash":"eb64f1d74891b0d063d835a9b95b0914d5aced09","modified":1608117878707},{"_id":"themes/Fluid/source/js/events.js","hash":"3d2e05b83e49e30eec0f85e10707a27e02cc2903","modified":1608117878707},{"_id":"themes/Fluid/source/js/boot.js","hash":"1b6c093fc2e110c6d3378483fbd00e76aa52136e","modified":1608117878706},{"_id":"themes/Fluid/source/js/lazyload.js","hash":"91df93084b53aab48500ebb88019c8c523945243","modified":1608117878708},{"_id":"themes/Fluid/source/js/leancloud.js","hash":"67c04252b14c1da645952c4e299a00030440a28e","modified":1608117878708},{"_id":"themes/Fluid/source/xml/local-search.xml","hash":"85fcc23b4db654a7f91fc55b6fb0442bb3ed3a9a","modified":1608117878710},{"_id":"themes/Fluid/layout/_partial/comments/changyan.ejs","hash":"fc4890cde550b8e275492ea02b4c5e56e4a08ecf","modified":1608117878668},{"_id":"themes/Fluid/layout/_partial/comments/disqus.ejs","hash":"9c07fa38b30f5d8815ec9fff91c4b6aeed71c301","modified":1608117878669},{"_id":"themes/Fluid/layout/_partial/comments/gitalk.ejs","hash":"71564e440e0dc4338d7bb3a6d98790633f0cd640","modified":1608117878669},{"_id":"themes/Fluid/layout/_partial/comments/livere.ejs","hash":"9ba4ce6240ff29c4328e58ec88b90392e825289b","modified":1608117878670},{"_id":"themes/Fluid/layout/_partial/comments/twikoo.ejs","hash":"0bf01d77b3c6eb2831056d6627fdc15b6fcf9ba1","modified":1608117878671},{"_id":"themes/Fluid/layout/_partial/comments/utterances.ejs","hash":"8e99361e920a2add4c84a122dd319e72ab5a8c4f","modified":1608117878672},{"_id":"themes/Fluid/layout/_partial/comments/remark42.ejs","hash":"dd757f563edc9e0f2a5efb281bc4985a0a186d58","modified":1608117878671},{"_id":"themes/Fluid/layout/_partial/comments/valine.ejs","hash":"9a1e040ff2e53c3046cfce915b50729080d74e78","modified":1608117878673},{"_id":"themes/Fluid/layout/_partial/comments/waline.ejs","hash":"4a76d773037caf370f22ef8d62e8cfa138628e5a","modified":1608117878673},{"_id":"themes/Fluid/layout/_partial/plugins/analytics.ejs","hash":"d20f54bf2fd5cd274b4b9c5542eafbfec5120838","modified":1608117878677},{"_id":"themes/Fluid/layout/_partial/plugins/local-search.ejs","hash":"1daab8ac0e67db873816e96cc8535c7640d58e40","modified":1608117878677},{"_id":"themes/Fluid/layout/_partial/plugins/math.ejs","hash":"a49a0064b55cf6d8f2a61abfecd41f0083757e04","modified":1608117878678},{"_id":"themes/Fluid/layout/_partial/plugins/mermaid.ejs","hash":"fd1f78287c868ccab78b6244b66e3f9b0968c4a8","modified":1608117878678},{"_id":"themes/Fluid/layout/_partial/plugins/nprogress.ejs","hash":"98b92f77f17985035e0ec7c97e6d8624b72c9641","modified":1608117878679},{"_id":"themes/Fluid/layout/_partial/plugins/typed.ejs","hash":"c57817ceaee868d416558e56d2a8d0d418c64a2d","modified":1608117878679},{"_id":"themes/Fluid/scripts/events/lib/footnote.js","hash":"13d8466cd4c98367131b5f3d6a30b3d4ce8de26f","modified":1608117878685},{"_id":"themes/Fluid/scripts/events/lib/hello.js","hash":"374d4fec78c0d90d72bee81af244d700d7a407db","modified":1608117878685},{"_id":"themes/Fluid/scripts/events/lib/merge-configs.js","hash":"db6356abf0c997ea115a7577102188222bc7fc37","modified":1608117878686},{"_id":"themes/Fluid/scripts/events/lib/lazyload.js","hash":"01a13ac2f1960ac17935d59adb794604e29145c4","modified":1608117878686},{"_id":"themes/Fluid/scripts/events/lib/highlight.js","hash":"1d272faab76bddb8240751c7d87b1c5c8eadc4a9","modified":1608117878685},{"_id":"themes/Fluid/scripts/events/lib/preset-configs.js","hash":"995a312c52788bb7087396a5daded2bf132d4fce","modified":1608117878686},{"_id":"themes/Fluid/source/js/local-search.js","hash":"bb899b1ddb2f3c2565d846def2f742ca15407cae","modified":1608117878708},{"_id":"themes/Fluid/scripts/events/lib/version.js","hash":"1d5a3a8cbf970d9d1a28a7ae9b935cc1b7afbeff","modified":1608117878687},{"_id":"themes/Fluid/source/css/_mixins/base.styl","hash":"046979dbd8cdabd21d89f9c1d8f1bb3f2fd06d6f","modified":1608117878694},{"_id":"themes/Fluid/source/css/_functions/base.styl","hash":"171697018fd384fce0834875ca94b91f16564cac","modified":1608117878693},{"_id":"themes/Fluid/source/js/utils.js","hash":"43787e6704b24acd8f6639a527b7ae18c0adc1b3","modified":1608117878709},{"_id":"themes/Fluid/source/js/plugins.js","hash":"d7c9bde00847d5a3d8af3c94eb6ba07129ac7a3e","modified":1608117878709},{"_id":"themes/Fluid/source/css/_pages/pages.styl","hash":"92c062cf55457b6549497244d09ec34e9c0c95c2","modified":1608117878703},{"_id":"themes/Fluid/source/css/_pages/_about/about.styl","hash":"47235d222812e2f829e9bde039fa719bbced9325","modified":1608117878694},{"_id":"themes/Fluid/source/lib/hint/hint.min.css","hash":"64fa8c328dc93432ec822de2818aef21a4f63b29","modified":1608117878710},{"_id":"themes/Fluid/source/css/_variables/base.styl","hash":"6d99bc7df1b61d7043168468fa928bd3da2a9fc8","modified":1608117878703},{"_id":"themes/Fluid/source/css/_pages/_category/categories.styl","hash":"0924e35eff2ec84e2d9e4772abccda452d9463ef","modified":1608117878700},{"_id":"themes/Fluid/source/css/_pages/_base/base.styl","hash":"574a9c64f071d938a31a768451aad64b2999a1d6","modified":1608117878698},{"_id":"themes/Fluid/source/css/_pages/_base/inline.styl","hash":"c98c4be12ae65b5db335527509e89af6d1451dbd","modified":1608117878699},{"_id":"themes/Fluid/source/css/_pages/_archive/archive.styl","hash":"86926a80bf6f39a7f47789b1a8f44b5984b4683f","modified":1608117878695},{"_id":"themes/Fluid/source/css/_pages/_base/color-schema.styl","hash":"615d35d4d73f1efe114add257eb7c600571029ad","modified":1608117878698},{"_id":"themes/Fluid/source/css/_pages/_base/keyframes.styl","hash":"58a7f8f2baea2d58cf5f7edfc91314ee5d7156ca","modified":1608117878699},{"_id":"themes/Fluid/source/css/_pages/_links/links.styl","hash":"83694b28209c548ef38bee78e473b02e90cbcf9f","modified":1608117878701},{"_id":"themes/Fluid/source/css/_pages/_index/index.styl","hash":"3e8339b19dc168a8154027381ce2616faf4d8e48","modified":1608117878701},{"_id":"themes/Fluid/source/css/_pages/_base/rewrite.styl","hash":"13c24997fdd15a38784806fed36ba4e34c8a9c35","modified":1608117878699},{"_id":"themes/Fluid/source/css/_pages/_post/post.styl","hash":"080a34e90b8ebfa1c7071574ea5085436eb43f83","modified":1608117878702},{"_id":"themes/Fluid/source/css/_pages/_base/_widget/banner.styl","hash":"65f14bece44cd68a4da93e5aee3a68b51677a8ee","modified":1608117878695},{"_id":"themes/Fluid/source/css/_pages/_tag/tags.styl","hash":"29e9b72cfda2f2baf9cf2597fcd7f9e66303a9bd","modified":1608117878703},{"_id":"themes/Fluid/source/css/_pages/_post/tag_plugin.styl","hash":"81daa88456f7bc9053b08ec667b3b0ca82565059","modified":1608117878702},{"_id":"themes/Fluid/source/css/_pages/_base/_widget/copy-btn.styl","hash":"fd44a4da774afc00fd49638a9fe6b9d925e52810","modified":1608117878696},{"_id":"themes/Fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"41935973a66c14ab2bea0539d4b1f15c62534fa4","modified":1608117878697},{"_id":"themes/Fluid/source/css/_pages/_base/_widget/footer.styl","hash":"dbd0a3518e5bfca92851490b34654f46bb5cfc76","modified":1608117878696},{"_id":"themes/Fluid/source/css/_pages/_base/_widget/board.styl","hash":"bb9cdde191b9b1287ba19414bab862f30be6a8a0","modified":1608117878696},{"_id":"themes/Fluid/source/css/_pages/_base/_widget/header.styl","hash":"64a2c98711b1765a7d8eb99f9e3cd0b9b0673f40","modified":1608117878697},{"_id":"source/_posts/【C++】C++STL标准模板库/Snipaste_2019-10-06_14-36-13.png","hash":"8d5ba40456eebbf1980ca791bf463eaff70e9290","modified":1574061919000},{"_id":"source/_posts/【C++】C++中的四种转换类型/Snipaste_2019-09-12_10-11-10.png","hash":"5696fb19f2d72c2161f4a1497bef9c68016373ef","modified":1574061919000},{"_id":"source/_posts/【C++】C++中的四种转换类型/Snipaste_2019-09-12_16-32-44.png","hash":"4d26c7a6c9d42f801d7a6d53af4f820e90f06f38","modified":1574061919000},{"_id":"themes/Fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"d29064ed8bdf62d5cf4eac32ebdb5d0c7075ebbd","modified":1608117878697},{"_id":"source/_posts/【C++】C++高级/Snipaste_2019-09-14_09-39-52.png","hash":"a50164c862b593399eb3791eea5c3118e0f1b4bf","modified":1574061919000},{"_id":"source/_posts/【Linux】Linux基础/2.png","hash":"dbf18a4e77773e54be17847e9e4e889c2930860e","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-15_10-49-05.png","hash":"ca5692c9ef6079fd5323ad6115f8b7ae5a25c270","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-16_10-06-16.png","hash":"081d2c65597bb20119bb1edc30b500f7c2822600","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-16_10-07-00.png","hash":"242bdb22dc186655f2f6d77befaf6b7cf14b1915","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-16_10-06-10.png","hash":"3d17173feaca9e015bcb4e31b504953028400123","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-17_21-18-55.png","hash":"21ada8cf0e08292df6c592b053ac53cb3448bf2a","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-25_11-53-42.png","hash":"73f301358405ec6f7c4f3a02cfde542fc3c723f4","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-25_11-56-15.png","hash":"333ce02b2e4bddece40140609827a8c683f17b69","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4联级粒子系统/Snipaste_2019-11-14_10-58-31.png","hash":"af681111b549c57a38a622fb6d7034eb9007b1b1","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4联级粒子系统/Snipaste_2019-11-14_11-14-32.png","hash":"e33944519a55306a3df1c2ea329cf500369e9002","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4联级粒子系统/Snipaste_2019-11-14_19-48-16.png","hash":"4163e6ff5df6335d69af47e6c2771c7fb08a8797","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-24_15-11-12.png","hash":"6bed8c6af17501079ef4ad59fb1d855c5de52eb1","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-24_14-55-47.png","hash":"b5ca8383cdc6fec3e04bd5e588e885a8ea7c1f9e","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_10-58-33.png","hash":"5136b69cd4a410b42109aa2a2f27e099c1e49d30","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-25_19-04-57.png","hash":"b7d1622850aa9558bc381d6c98a2108ff0d5aa4c","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-02-54.png","hash":"54b0de977b1b0ceccf1947a54b60fb2ac00d863d","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_19-59-29.png","hash":"43e83aac38ad697b66bc220000a258c0bf938c05","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-27_10-35-51.png","hash":"ea10f8899c92bf55b8c07a42ecc57c33b178c49b","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4连接MySQL/Snipaste_2019-10-23_10-36-25.png","hash":"5e8cc17525a7d927da9a610282b5f183f7e05757","modified":1574061919000},{"_id":"themes/Fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"5081ec00d3a1ee1a117cf33308abf25d71d133c4","modified":1608117878698},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-28_16-45-41.png","hash":"13ae1f4e51e9a233a366471ec9a9bba7518e6c3a","modified":1574061919000},{"_id":"themes/Fluid/source/css/_pages/_base/_widget/search.styl","hash":"1f4e678d7219815ab62de1b92ec75e021247f90b","modified":1608117878698},{"_id":"source/_posts/【UE4】UE4连接MySQL/Snipaste_2019-11-05_19-12-00.png","hash":"00de89bb9c0e786e222acd6693c4c2902ff236c2","modified":1574061919000},{"_id":"source/_posts/.git/objects/08/622f8bcef868473cbdf7acf2581346455fe166","hash":"f9eaa59ccc69a29e56cd2157b3fe910e54344ed7","modified":1610107923707},{"_id":"source/_posts/.git/objects/0e/277f99ff943694f1582e9e47672270fa589f70","hash":"38eb275de599dc42bef5b717d7bd9850cb96aff0","modified":1610107926720},{"_id":"source/_posts/.git/objects/24/179750c368ced72e7283278a142d051dcec89f","hash":"5664a1cb1266ca8a3c1d6ccfa11a6ef14a50272a","modified":1610107921952},{"_id":"source/_posts/.git/objects/27/185be5fa0c8837ee9e1dea6cf1987b7aab691f","hash":"4d00fb8036555a4c3c7cb98c998434a9b2e5a4d2","modified":1610107922090},{"_id":"source/_posts/.git/objects/2b/be003064e80e1320c10ee039808dede45206d3","hash":"94235def7c11b380b48209c2bc64b27b528938f6","modified":1610107927809},{"_id":"source/_posts/.git/objects/4c/98b357d01b538660ba35eb091ed0a61a5053d4","hash":"b4fd5f8beff15d34d57df679444ce576166b34a4","modified":1610107931063},{"_id":"source/_posts/.git/objects/48/21de36eb17a0d57b097598d6008a228c447c3d","hash":"5ba9e32e29b7940f02df47b6464bac41ab0bb9fc","modified":1610107930205},{"_id":"source/_posts/.git/objects/6b/cee2731172bba9a8e4be1439563b3fea6951ab","hash":"cefd0cf22ebd789d619af76def9b4a1018902c3f","modified":1610107928479},{"_id":"source/_posts/.git/objects/6e/bddd428b14bd306a76e8c3d37a2a4a8c188b47","hash":"52bc37fa88c2f50238011ad819553c9e8ed8291c","modified":1610107925322},{"_id":"source/_posts/.git/objects/75/ebc1739961fa2c32778cd11a41651344b7e47b","hash":"8d362077a296d4bbd84d7a1cd7b0e8e4c25616bb","modified":1610107927833},{"_id":"source/_posts/.git/objects/7a/8c379b1f3deb24b417ea402009dcfc7c6fa449","hash":"5e0235a126439e78ef1669fe37ea64758657d1ea","modified":1610107928376},{"_id":"source/_posts/.git/objects/7d/33544d4478bcb9b420a889c98518c083cc9f58","hash":"3ed277be2ef87febcb47a47d4cd84c7a100dda27","modified":1610107930545},{"_id":"source/_posts/.git/objects/7e/d3f2ba1979a8b290729d9dfe07d95fc4b60297","hash":"676de8dda4b0abfc85f0ad64f26e423b3959fccd","modified":1610107930472},{"_id":"source/_posts/.git/objects/84/2b14d268e4a7bb48bbae454504998fd3340a92","hash":"109aa025aa9167d02214aefcf46d15917510f54d","modified":1610107928249},{"_id":"source/_posts/.git/objects/93/bb834af9533460f7461df86130f523e02451f9","hash":"4ca5828965256b69a8a05dce57671e2645db0d21","modified":1610107929472},{"_id":"source/_posts/.git/objects/a0/95ecfdb78ed765d3323459e9f98759f67b63f9","hash":"387797fd475fe7f908086dbd211552a1ea7f0a5b","modified":1610107927133},{"_id":"source/_posts/.git/objects/9d/ef9fb6354c624a3af87310632bd5a7c79fdb5d","hash":"44d205125953bfc3f2e1319ad5d23cb427630067","modified":1610107928904},{"_id":"source/_posts/.git/objects/a3/69064bc8eef86d7545185ff9b6a86517148c8a","hash":"68890f8ec368e9b1d5f7c616793910239a7a2f9c","modified":1610107923019},{"_id":"source/_posts/.git/objects/a6/2ab085b24f859b3a369a3f397c2fa61ffa758a","hash":"c8431bbc49a00f0f303406a797abe0a48adc6585","modified":1610107928943},{"_id":"source/_posts/.git/objects/ac/bac6f1bcd36c16dfc7ba1de134ecc9d72385a3","hash":"e7429e7b17a92dd3f1e8c5e849a6eb81dbaa511a","modified":1610107930680},{"_id":"source/_posts/.git/objects/c5/fa80bcd60a5a8ce5e0604e20a4efa047fc53e2","hash":"1bb19c1d170f7658f6ef9b119b90131a8d1f071a","modified":1610107922410},{"_id":"source/_posts/.git/objects/f0/9a4eb6cd64212d7424d511f4c97fde39f96064","hash":"b22771e0d9bc274af776c25272821ed4e889a2d7","modified":1610107926799},{"_id":"source/_posts/【C++】C++中的四种转换类型/Snipaste_2019-09-12_11-51-30.png","hash":"4a8fcaf0577f5a65d01701988de966f96c516f6a","modified":1574061919000},{"_id":"source/_posts/【C++】C++中的四种转换类型/Snipaste_2019-09-12_10-44-16.png","hash":"661f9ff0574baf2e3dcdbb515de1b6a43fe41a5d","modified":1574061919000},{"_id":"source/_posts/【C++】C++中的四种转换类型/Snipaste_2019-09-12_11-06-11.png","hash":"aa62e7231b877ae93b784cab2f17ec3213a458b3","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-14_14-17-46.png","hash":"8a8f9ce0ed85941affdbfce6b588aa3e55f7fd79","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-14_14-17-49.png","hash":"beaa3ceb15efbe13bf7a57e322245c6f71299210","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-24_11-12-38.png","hash":"e2ccdcfc20a97e8dd57e1102fe9fde71e9797e51","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-27_11-31-04.png","hash":"bd4e0537881416b948fbf9ceed44ccb07e4b85ec","modified":1574061919000},{"_id":"source/_posts/.git/objects/2b/3bf3f68f0d2ff27b0cb635b3ae2db447e4c4ed","hash":"55de5af4d969e002d24c1a2e70585fe841c641e5","modified":1610107928877},{"_id":"source/_posts/.git/objects/3b/44e60c40755f5863edbae11c1406e5797468e8","hash":"6fc9e6ff5cb63fad1062923fc973d9e6c536707b","modified":1610107922160},{"_id":"source/_posts/.git/objects/55/7ad661ca8373114f4dad262a8e368fc6d6b841","hash":"8d902d791ef3acd433cacc26dce3c37c8175e80f","modified":1610107922340},{"_id":"source/_posts/.git/objects/5b/4786fd21dabb4eae0324b488b75efd79c2d27e","hash":"0e5ba76435ecef87e48842e8f4b779e2fb5a6876","modified":1610107922246},{"_id":"source/_posts/.git/objects/97/6462e0e9947e86353dbcdc8fb8bdebd5b0b699","hash":"bc98a1a6075cbe08f3a506fe267e527f93188118","modified":1610107925240},{"_id":"source/_posts/【C++】C++函数模板的实现机制剖析/Snipaste_2019-10-03_20-07-41.png","hash":"d0cf6cb62c29ef17eb23940549bd935dc0f02fd3","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-15_10-23-36.png","hash":"9150ea14e4c635f103cd011dff31ad2700e24691","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-15_10-23-17.png","hash":"62a865df56919f2c709b44133254c670b97c6e35","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4联级粒子系统/Snipaste_2019-11-14_11-03-35.png","hash":"bbc2ad95a69c21a5b99126a388ac85519def2245","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4联级粒子系统/Snipaste_2019-11-14_11-10-41.png","hash":"a845cfea131a4ced491ed5542bf60ffa81b1a6b5","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_17-38-54.png","hash":"aed2953ba79a0b2e220f229ce12d430d0af7e5c9","modified":1574061919000},{"_id":"source/_posts/.git/objects/08/3b00282c6f80ac8c1b4b221fb7c8e232ed2544","hash":"b10ad2d0cf66b1396027956dd6fd28a4f3b8d856","modified":1610107930161},{"_id":"source/_posts/.git/objects/08/c0ad2758a90adfdaca831c09c8e19e67a6e2d5","hash":"ef6841f13e38bdb89abcfa6d0a16d024a290bda0","modified":1610107928289},{"_id":"source/_posts/.git/objects/15/62c7b73f2a38c52db64dd8d3c5fbb04da0173e","hash":"61b4a20b065935da87038356ed8bf7e919f31288","modified":1610107925480},{"_id":"source/_posts/.git/objects/1f/b24d43dc060af5c0af1b563a347e2e674840b8","hash":"4d6d9891d563972b496a86dd1ca05e99f33068cd","modified":1610107925439},{"_id":"source/_posts/.git/objects/72/471b25fc9adc67e78b750124ea910527c47c08","hash":"928d7ae0dcce06a689854e20e0872802396b4cbc","modified":1610107928344},{"_id":"source/_posts/.git/objects/b2/a8ba95ca6e004975828fd0fdc9d88e038d4017","hash":"4e45e49b244892488dea431508190679f8be2b87","modified":1610107922686},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-14_11-46-45.png","hash":"ac2230cfae134ce8e2e343f3c1fd94d824e82b6d","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-24_09-41-27.png","hash":"a320fe2b688f260b3107db98d0c86a425a6737b1","modified":1574061919000},{"_id":"source/_posts/.git/objects/f5/1d58733f5e5c75aef77001cb636b6d61913f6c","hash":"238afd6050ac2f224c8007469d1a05727c9fa2bc","modified":1610107925114},{"_id":"source/_posts/.git/objects/f5/a46af087f0d9b55a2681d97ffdbf43f28cb485","hash":"02a01e3187103f991e13686a10f965c329f1c2f1","modified":1610107928661},{"_id":"source/_posts/.git/objects/ba/f5e3dc5da3c40d0b3493e32d74ddb68b144d77","hash":"9bfe193f28e65b9b63bcaa53831df0ddfae061e8","modified":1610107924107},{"_id":"source/_posts/【Linux】Linux基础/9.png","hash":"f89c4f40fceffe3270865ae53802662b509ff792","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-15_10-59-58.png","hash":"8e5fb25c3a7a04a6f590ff39f23b864ed21baf54","modified":1574061919000},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-15_11-15-27.png","hash":"c7f49eaf79025d956ed59b3ebe2a68e5d8fb4115","modified":1574061919000},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/Snipaste_2019-09-08_09-15-55.png","hash":"9be0eac8c02b5ddc7f989ae4916807ab09c68099","modified":1574061919000},{"_id":"source/_posts/.git/objects/66/1218ad6a9c831aa365c09231df60fbcfbb8be4","hash":"56a2f77540c09c7032e7a24c7c22b438705671a1","modified":1610107937748},{"_id":"source/_posts/.git/objects/73/1670f8c0c7251f70f2812b5856088cc6a2fb93","hash":"930496b823c8b66ada67def491984ac7fe9f3691","modified":1610107925969},{"_id":"source/_posts/.git/objects/c1/c0f7e77a7476df20151990302d6c2ae3dcf6e5","hash":"354660c1ae51c01c602a6dcfdd329e9a6142bc88","modified":1610107926496},{"_id":"source/_posts/【UE4】UE4联级粒子系统/Snipaste_2019-11-15_15-05-48.png","hash":"9f1cb0bafafc1a76a027e7f661b1030b631dd3ef","modified":1574061919000},{"_id":"source/_posts/.git/objects/35/ca2b9017ab7f13b753e7560505a2b12eaf30f9","hash":"effb9f1e8ee34acf0f9a1a0326dd2e15b5bf36eb","modified":1610107928536},{"_id":"source/_posts/.git/objects/e3/a02bf8a72643a080a0f9ebd4da6c4b007d932a","hash":"385b1ca1ce59b1a6a468936a5e4e8057dcf473b6","modified":1610107925703},{"_id":"source/_posts/【UE4】UE4基础/Snipaste_2019-10-15_10-42-21.png","hash":"d0603a7887618e98b79545f1ccd6ed48680785db","modified":1574061919000},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/Snipaste_2019-09-08_09-23-19.png","hash":"71ac9b67b6dd5da0a2993341647ad05df28b1357","modified":1574061919000},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/Snipaste_2019-09-08_09-28-22.png","hash":"d0f9d0530f0295f806e047cc3ccbae6dc257e14d","modified":1574061919000},{"_id":"source/_posts/.git/objects/20/6aa19b752a8531f27f6677dab8128957b3bb9f","hash":"9c9f5144f86a3a04c972b9bff40d9e1f768709aa","modified":1610107937843},{"_id":"source/_posts/.git/objects/39/490d106f542891f9b1ef9dcadafb45aea79a3e","hash":"09ff032d27ec81ed86d756963976282d2063d260","modified":1610107937944},{"_id":"source/_posts/.git/objects/c0/c2363b56546ea34c7104ed01221e562a3e0445","hash":"810473cff867a0a194d94e99ec6b1a51bf8431e8","modified":1610107931664},{"_id":"source/_posts/【Unity3d】Space/Unity3d_Space.png","hash":"166e98471595a37ceb251a386330f2d9082747d7","modified":1574061919000},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190513.jpg","hash":"dfd693ceb839b96b0c904864c946a192ac1a28d6","modified":1574061919000},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/Snipaste_2019-09-08_09-34-22.png","hash":"4c1b8e5d02764c3fecfdb826a45ef894be9c89e8","modified":1574061919000},{"_id":"source/_posts/.git/objects/67/0d35d28e5a3d5d16f751b09f9a879fb5bd1d8c","hash":"87e0129a441a84e41a6fa9967d8449cc96df6fd5","modified":1610107938085},{"_id":"source/_posts/.git/objects/f8/b5dabb7bbbcc284681c6b5e67a76cc570f98a8","hash":"531d5c755dd17015ae7eb743dd714ab5e7fd4f24","modified":1610107933526},{"_id":"source/_posts/.git/objects/46/2d12ee6ed0f5993dd3c32de4eae050568c0e54","hash":"b5a84abd3d7abe4d3736feaadf8f0f3cbf5e5dc3","modified":1610107938266},{"_id":"source/_posts/【程序编程】程序编程高级/程序编程高级.png","hash":"580dd5da5be3387deee2b11a0abfdfb35613811c","modified":1574061919000},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190452.jpg","hash":"7d97cda11fc0f67e86a9bee5c2071dfa542cfeaa","modified":1574061919000},{"_id":"source/_posts/.git/objects/8c/6ec70b95efd7f9fa68f86e9b63ac59982926be","hash":"1b1916e2a7cdb37f1adeb2cd481cef352a71d099","modified":1610107932851},{"_id":"source/_posts/.git/objects/92/c7f633c3337e76f0105a61cb54cc69b13a061d","hash":"017e9e6fc909b00a7fc68a5398932b641c2b4df9","modified":1610107933001},{"_id":"source/_posts/.git/objects/9a/ccc720eab222ed836a4f37078ed0817f6364df","hash":"52c9fa5216d4dc5dc05f77b944af6f6492a3d6ee","modified":1610107936577},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190456.jpg","hash":"a43cbb34f7897911d11cbd288b4ec3a4730e343f","modified":1574061919000},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190626.jpg","hash":"66bfee7195531ec251fcb619807b67557e74bca7","modified":1574061919000},{"_id":"source/_posts/.git/objects/00/b66a828054ae345a12a73f2f549ac82ff3dc90","hash":"285574ab4138e355cb3aaaf48790ca61f117b9cf","modified":1610107931415},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190634.jpg","hash":"2b59287bc72f813364ac207c03578432b16e6899","modified":1574061919000},{"_id":"source/_posts/.git/objects/09/0affff35740f165cfcc5bf32633435f7f4a1d5","hash":"bed88fd6afeb32b739e2db5966602d8989f814d9","modified":1610107937090},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190518.jpg","hash":"5bfd0f313a82c1c25f119e3b46a5f8a7210ed4fe","modified":1574061919000},{"_id":"source/_posts/.git/objects/e4/81eb76ae98bf7b4b6f6f4c35adf99da0b213c7","hash":"b0232eabedd9ff1ee3ecc7316d1f6764ba878ff3","modified":1610107935491},{"_id":"source/_posts/.git/objects/e6/c7dbb58d359577a1505208f91769bf53aa3b51","hash":"fc5d200a6d8f8d581bb14ab153a000aa26eb7298","modified":1610107933657},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190604.jpg","hash":"fa70f354999954542e8de724142fb0e5f61bd8f7","modified":1574061919000},{"_id":"source/_posts/.git/objects/64/a1e0d15e0151cade12c51b233efb9701006ce0","hash":"96c100a8ff2224c5b6714b1ef91923815363dee7","modified":1610107933194},{"_id":"source/_posts/.git/objects/f1/1f1fe41aeb95d472605b18e74fe6693ffb9193","hash":"e350e40c99494c786fda93a099413d6db1dac574","modified":1610107938823},{"_id":"source/_posts/【Unity3d】Lightmap/Unity_Lightmap.png","hash":"d9f59201a5bfefae4e7a19037ec5fa83fd252fcc","modified":1574061919000},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190414.jpg","hash":"1097a0d58ff63494fc9df8063df1ba3dc68fe718","modified":1574061919000},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190500.jpg","hash":"234900faa13b3ac924602b35ec6567d43de58703","modified":1574061919000},{"_id":"source/_posts/.git/objects/95/82ddbf02e63829904d456b9a48f933325d839b","hash":"230c16500d4bd7784abf2473bf5496d9bb463389","modified":1610107933883},{"_id":"source/_posts/.git/objects/ea/9cbf7309804118ac31150e47c9d23d624971d1","hash":"78a4be17ba4612e56dbf4369c16c98efef159ea4","modified":1610107932200},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190444.jpg","hash":"68f5f3ebc70e48beff4b72328a176ef5e33c55a3","modified":1574061919000},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190532.jpg","hash":"d6f2182efaaf7e19113aee4716f90113474e60e8","modified":1574061919000},{"_id":"source/_posts/.git/objects/41/7fed64ff00fa24994b187c326af390bf46ed70","hash":"a871c3131a0b698724b2a1c6b8bf47c779e4bd34","modified":1610107932425},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190600.jpg","hash":"e2140f8b5708d2d88b5f54b4ac26eee7a55d21ac","modified":1574061919000},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190616.jpg","hash":"392aaeb7d3e95e57bddb29d75cb9db5d52a90037","modified":1574061919000},{"_id":"source/_posts/.git/objects/2c/f3ebafcbdb5dd6cf2b3f52e4f54c1c7adaace9","hash":"b279086a25154d6d7eb18807851e103e9cad62ae","modified":1610107936167},{"_id":"source/_posts/.git/objects/a8/e0447e7bd2470a96d6495d08b75f6963e6e7db","hash":"2349c51fbf74b9883929860fd9a318922df02305","modified":1610107935256},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190504.jpg","hash":"427c42dc3ce9a96a89d0d6a31f77be9b5477e401","modified":1574061919000},{"_id":"source/_posts/.git/objects/18/8de2a7d69cb9e0788401716ba8036cbde3cf8f","hash":"ccb169517f530863b21bb3b200787a73390b8087","modified":1610107938573},{"_id":"source/_posts/.git/objects/52/cb204e134bed57777da7a7f04ecd1fdc86297b","hash":"75193e3260810bf14d8677ad2e30ac9ab447039d","modified":1610107933388},{"_id":"source/_posts/.git/objects/ba/3c9a075f9b0d4d70a47e4abc504991c75b4992","hash":"14a57fe4c5c2e8863313bd25ec08b543cafcd755","modified":1610107937614},{"_id":"source/_posts/.git/objects/f4/9675a64b2927b3387c2f2d383a6c5dcae2812e","hash":"c5afe64cf25bec5f9965b7aa86b756f9fded2d43","modified":1610107937365},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190448.jpg","hash":"97c7bbd7c7fb08f7cb0ac999252619164c3e245b","modified":1574061919000},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190638.jpg","hash":"3e2d6ecaa5276c95d560b4d04cf5bbf101b39d6d","modified":1574061919000},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190641.jpg","hash":"782bbc9b28e087862b54290d339f0d86730fcb6f","modified":1574061919000},{"_id":"source/_posts/【网络通信】物联网通信基础/物联网通信技术基础.png","hash":"4cc498e86f16de8102e148fc52eaf2b362c01399","modified":1574061919000},{"_id":"source/_posts/.git/objects/d9/c1ee9b6f3bb7812dd8a92da6d447450c03c501","hash":"071930506f194fbe7be7706dc9617893ed84af32","modified":1610107932661},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190612.jpg","hash":"08ddb1df3dc127669c7866ecd39beac2ff007594","modified":1574061919000},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190622.jpg","hash":"61358bc5e08f52864424778437035cfe0d556f32","modified":1574061919000},{"_id":"source/_posts/.git/objects/e1/8ae5a90c1ecd451d0a84b9419dfe4976a1e4c5","hash":"c7cfa184b07664c5508fe7ced4fa4d95e6c950ee","modified":1610107935938},{"_id":"source/_posts/.git/objects/f1/645004f57b00ef0016d60ee7c1b1c116e5e464","hash":"51b3ebca07016265c34423243567385a7c1fb618","modified":1610107936355},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190556.jpg","hash":"28db93f05e9acbc0afc723a64de2329d76ee3909","modified":1574061919000},{"_id":"source/_posts/.git/objects/eb/971dd8cf053769612827061766fa5b97a4d88c","hash":"52ecb23fee7b4aefdeb21a357ac949d946028566","modified":1610107935036},{"_id":"source/_posts/.git/objects/bb/ece58f68e36cb192b0fd728f81d2d23348629c","hash":"c0ef25164d535e678381e25df7fa4915f9fba912","modified":1610107934778},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190552.jpg","hash":"2ab850404ffb530e81c219450521f53b2b768703","modified":1574061919000},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190542.jpg","hash":"d2ff3d6038baa9a54a0e371acd4c5801a7869d50","modified":1574061919000},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190547.jpg","hash":"7ea440b83e24df2ad4a3d33636a1498d3f84e414","modified":1574061919000},{"_id":"source/_posts/.git/objects/25/f75f6d82f3ea4132ef401eb4a5529add399c7e","hash":"7bdbd829316d2d16b60f6d6e2f9207eb5e8b0749","modified":1610107934532},{"_id":"source/_posts/.git/objects/71/77b02bd9b15986981cdea1a644e468a2d3c232","hash":"ad8ebe293836dad6b43e742d8f7f5820f6e2b271","modified":1610107934293},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190538.jpg","hash":"e6a48efcb69a1bc33c0b5d6952fd7a564d4b87b3","modified":1574061919000},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190607.jpg","hash":"6ed81df498eced4f8284e720f03c451da9a30ce3","modified":1574061919000},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190630.jpg","hash":"24b42d9c8e254f45decb91f34d1d28889617256a","modified":1574061919000},{"_id":"source/_posts/.git/objects/0b/e8ee4b1c8831ff5aa56fe46b8913f03cf47281","hash":"852433adc0ff2509f7fd531f710af24b759fad86","modified":1610107935706},{"_id":"source/_posts/.git/objects/49/4dd49f8c2838d28c8c08d052595ad22bb68eb3","hash":"b971a48cbe208d0e24827d51f4cb625b36f3c567","modified":1610107934087},{"_id":"source/_posts/.git/objects/99/44c7334fb42a72900c9e9fe116f6bf6f8bd1b1","hash":"c1edc8fd84e76d9c62e06d25a894e05575e829dc","modified":1610107936827},{"_id":"source/_posts/.git/objects/94/9e0afaa156a94b64b13511dcb8cfa87a5bec07","hash":"bde3adac459e8a8eb020ce5ee7ced2af2ce94b40","modified":1610107924513},{"_id":"source/_posts/【网络游戏】网络游戏基础/网络游戏基础.jpg","hash":"0118b0b496d409e3758320f375569426f298bb82","modified":1574061919000},{"_id":"source/_posts/.git/objects/ba/4218a654e596e84b6ec89c3714bae96770cd01","hash":"c12806bce152e83be218b21c5eb5fc1973000f73","modified":1610107924788},{"_id":"source/_posts/【Lua】Lua基础/Lua基础1.png","hash":"c1b38cf0fe6961681a41fb0521d187bbb2d2df6c","modified":1574061919000},{"_id":"source/_posts/【Lua】Lua基础/Lua基础2.png","hash":"c21f71c7832f37ea9c7fead5b84975dd441bb416","modified":1574061919000},{"_id":"public/atom.xml","hash":"13d879d150873ed310b24f164af2003d092347bf","modified":1620987064589},{"_id":"public/sitemap.xml","hash":"ac44e45b2fb220dfcce121800e49821263a962d1","modified":1620987064589},{"_id":"public/local-search.xml","hash":"d8b8dee3623f99d3441d675c0d4d278e35209b32","modified":1620987064589},{"_id":"public/2019/10/14/【UE4】UE4基础/index.html","hash":"dc7a3ace67434a5b9e6b47f2a00f5ecdaed360bd","modified":1612190373658},{"_id":"public/2019/09/30/【shell】shell基础/index.html","hash":"4ce5f597159c7c132242f1f776ce772a4403c8c9","modified":1617085026022},{"_id":"public/2019/09/11/【C++】全局变量、静态全局变量、局部变量与静态局部变量/index.html","hash":"b819a280e4c01b80434787090e7d8411261d59f7","modified":1615965672359},{"_id":"public/2019/09/09/【Lua】Lua基础/index.html","hash":"761147bc94ff3bcf2801d45d0222ccb4b5845194","modified":1612190373658},{"_id":"public/2019/09/11/【C#】C#两种数组定义的区别/index.html","hash":"d962c7ab2b77d43676a4e941ef3fe8a4196dc369","modified":1612190373658},{"_id":"public/2019/08/27/【Unity3d】Unity常用技巧笔记/index.html","hash":"d630152c4b7a327c6a7e1cec2da2e0429c0e9ab9","modified":1612190373658},{"_id":"public/2019/08/25/【Unity3d】Space/index.html","hash":"c6db45cab2d77c12f8cebc22b7ffe05ea7acbf2d","modified":1612190373658},{"_id":"public/2019/08/25/【Unity3d】Lightmap/index.html","hash":"b07255ec908ef1207ea445ae3b8e56528cba7b1b","modified":1614147040400},{"_id":"public/2019/08/25/【网络游戏】网络游戏基础/index.html","hash":"3b58c45157ec2eb6687a176c3d340d18c79dee76","modified":1612190373658},{"_id":"public/2019/08/25/【程序编程】程序编程高级/index.html","hash":"ef8d9b39b1a7c734cad87c91fdcf10c0626f2fba","modified":1614147040400},{"_id":"public/2019/08/25/【网络通信】物联网通信基础/index.html","hash":"42080344c6301743a7ff2d3fff79a966b10ff648","modified":1612190373658},{"_id":"public/2019/08/25/【Qt】Qt基础/index.html","hash":"b17e5ea6f38898664b0339a81cdb4e2e8f8e01be","modified":1614147040400},{"_id":"public/2019/08/25/【C#】C#高级/index.html","hash":"58216beb6e07108fa49fe7b972f55cb5800270a4","modified":1612190373658},{"_id":"public/2019/08/25/【C#】C#中级/index.html","hash":"b4947bb348e5defb19e272d3bf0f4aecc28a75ac","modified":1612190373658},{"_id":"public/2019/08/23/【Unity3d】游戏截屏/index.html","hash":"e82d01303d514cb3922b30f7d1a31601159f347b","modified":1612190373658},{"_id":"public/archives/index.html","hash":"fdd9e9e66bc1df0205c39fae55e88d42434b8e1c","modified":1620987064589},{"_id":"public/archives/page/2/index.html","hash":"b2d7115f9398aa6e9aae0c24647a40e007205db0","modified":1620987064589},{"_id":"public/archives/page/3/index.html","hash":"67c88042969ba63afdee505577419a8ba0cb1889","modified":1620987064589},{"_id":"public/archives/page/4/index.html","hash":"37c5b0d2bd3d29da7709a224ec934367383dbe89","modified":1620987064589},{"_id":"public/archives/2019/index.html","hash":"3b710882cce693ff5fa174cf4a93b9094576ae68","modified":1620987064589},{"_id":"public/archives/2019/page/2/index.html","hash":"11a93741a0143c072755af283fc408f2e096203d","modified":1620987064589},{"_id":"public/archives/2019/page/3/index.html","hash":"f96442b0efa1b9357c676c145e288a5a67078f8b","modified":1620987064589},{"_id":"public/archives/2019/page/4/index.html","hash":"960fb2ccde5d12316b1db1f9f21861c9e0aba1d5","modified":1620987064589},{"_id":"public/archives/2019/08/index.html","hash":"be8422d3315b9f02571f218bf58f16e3dcc1080d","modified":1620987064589},{"_id":"public/archives/2019/08/page/2/index.html","hash":"f8b9c20e5d6eb89840125d0cf1dd05866a9c6267","modified":1620987064589},{"_id":"public/archives/2019/09/index.html","hash":"bc2058905c5fe4f9ec6dcfd519d3a3663f9d2093","modified":1620987064589},{"_id":"public/archives/2019/10/index.html","hash":"f58094ff6154de3207b39de1f65a7e2b66794577","modified":1620987064589},{"_id":"public/archives/2019/10/page/2/index.html","hash":"7d004d7c992322f30809b7780aaf521ac64ba08a","modified":1615965672359},{"_id":"public/archives/2019/11/index.html","hash":"62fe740e073f716e1429d61ad0f40f67dc240251","modified":1620987064589},{"_id":"public/categories/学习笔记/index.html","hash":"75c7ec65a2029f4d955581e9dcea8c47d56a97d5","modified":1617085026022},{"_id":"public/categories/学习笔记/page/2/index.html","hash":"f56d9b8ba46f7608ad6bbc6aa8c6718b79feb970","modified":1615883053981},{"_id":"public/categories/学习笔记/page/3/index.html","hash":"e35725fbf1cc5d6b4706775ceb8c0ef3d24bf34b","modified":1615883053981},{"_id":"public/categories/知识记录/index.html","hash":"15a6eee6bf4c70cf23139ecdc79b88d5357c01f0","modified":1616651393998},{"_id":"public/categories/知识记录/page/2/index.html","hash":"faffde332f5aec69f89e9605d3640c2e807cf746","modified":1616651393998},{"_id":"public/categories/待解决/index.html","hash":"f61efaa4ab49fb9e13509d061a55d243e9f70a2d","modified":1612190373658},{"_id":"public/categories/日记/index.html","hash":"707799e34dd33ab6b054528db9cae2ffd0d9f49b","modified":1612273903678},{"_id":"public/tags/C/index.html","hash":"e49200095b38d1ad85f26bd974785d87fa0c1429","modified":1612190373658},{"_id":"public/tags/Linux/index.html","hash":"c38e35a47d6c5a74dfefe56263a3a9c88e2df780","modified":1612190373658},{"_id":"public/tags/MySQL/index.html","hash":"2ddbf0b615d984cc17268907055cbfb71f3bedba","modified":1612190373658},{"_id":"public/tags/Lua/index.html","hash":"27ce711f9c6805fe6d567154ef6e867108ba2998","modified":1612190373658},{"_id":"public/tags/Qt/index.html","hash":"6089e2e0c0a2b4c25968d3ff7f9c72cb029093da","modified":1612190373658},{"_id":"public/tags/UE4/index.html","hash":"cef3ecbfae9eabfae3e078ba4464946ff221ab06","modified":1615883053981},{"_id":"public/tags/Unity3d/index.html","hash":"13ccd54a6993e943534a39b2dae1a362a11961f7","modified":1612190373658},{"_id":"public/tags/shell/index.html","hash":"cb1832f81629dc7c6e789ad35a7cba5b3a4ae1c0","modified":1612190373658},{"_id":"public/tags/程序问题/index.html","hash":"99574b2fae22dcbda390d7648999447bbe635b53","modified":1612190373658},{"_id":"public/tags/大事件/index.html","hash":"ad3183fb01501f8184b025dc218b654c6f3d82d3","modified":1612273903678},{"_id":"public/tags/程序编程原理/index.html","hash":"42deb147970a56aa5ee0b9dd93d5c26e947f8543","modified":1612190373658},{"_id":"public/tags/算法/index.html","hash":"ca5dc3194f80876eb5c0b05c26c7aed6e1e873a4","modified":1612190373658},{"_id":"public/tags/游戏网络/index.html","hash":"92b71b5cc1bec8d9796eaea92141500cffd353c7","modified":1612190373658},{"_id":"public/404.html","hash":"6a539afcfdafa3d498ef98a2f340985a1706c316","modified":1612190373658},{"_id":"public/tags/网络通信/index.html","hash":"6c99e9f9c7fe92fbb6e4e6ef6b2c178bd2b9b36c","modified":1612190373658},{"_id":"public/tags/图形学/index.html","hash":"12170d41aef7bb1d2fa76d4abc5f5560008cde30","modified":1612190373658},{"_id":"public/tags/index.html","hash":"f61f17b739eb4960c23abd96456814eb6d533550","modified":1615965672359},{"_id":"public/links/index.html","hash":"339dc05c0c53aac296b417686787fc521b8267aa","modified":1612190373658},{"_id":"public/2019/11/06/【UE4】UE4组件/index.html","hash":"46094f1d7013ae60681d2cc7c19d99f9a31324bb","modified":1620983992431},{"_id":"public/2019/11/17/【UE4】UE4联级粒子系统/index.html","hash":"1757b4593ea23758b1afc669b27b93060fbb31d5","modified":1612273903678},{"_id":"public/2019/11/06/【UE4】UE4连接MySQL/index.html","hash":"d67c86c18b5d1721c43c6d49ade6450a2c25441c","modified":1612190373658},{"_id":"public/2019/11/06/【UE4】UE4读写Json文件/index.html","hash":"b8cd1e28c914f38633c31629576e3574cfb95d07","modified":1612190373658},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/index.html","hash":"66278a4326c10d413a5266ec4ae2bf9536081913","modified":1612190373658},{"_id":"public/2019/10/21/【MyQSL】MyQSL存储过程/index.html","hash":"f179e1085f90e392ee7e21a63412662b5aa37b6b","modified":1620983992431},{"_id":"public/2019/10/12/【日记】在武汉跑秋招的日子/index.html","hash":"a4838a26e918b655cf7ae7fa30e2175bb48f7a06","modified":1620983992431},{"_id":"public/2019/10/10/【待解决】一些待解决的难题/index.html","hash":"848877ef7fc26d7bddefe09794a9d2614f439520","modified":1620983992431},{"_id":"public/2019/10/08/【C++】C++中的四种个智能指针/index.html","hash":"c75cf117cedbdd5d8d2ddf5d7a652d20943428de","modified":1615965672359},{"_id":"public/2019/10/08/【算法】一些牛逼轰轰的算法记录/index.html","hash":"7289919b79aed3b787eccd34226355f678569a4d","modified":1617085026022},{"_id":"public/2019/10/06/【C++】C++STL标准模板库/index.html","hash":"509ca98b8f9ebb54a470f77aa842dc512fc40eb9","modified":1617085026022},{"_id":"public/2019/10/03/【C++】C++函数模板的实现机制剖析/index.html","hash":"d21ceec5d031a27beadbd90cc8538b4e266eb1e2","modified":1615965672359},{"_id":"public/2019/10/03/【C】C的typedef的妙用/index.html","hash":"e28d60b536543fbf74797878baf90a5b8bce0989","modified":1612190373658},{"_id":"public/2019/10/01/【C++】C++面向对象模型初探/index.html","hash":"e82be58f1234308c98d742c494da9f27bba93d22","modified":1615965672359},{"_id":"public/2019/09/14/【C++】C++高级/index.html","hash":"46af28c828d24ae923ee4c31b0ac0965ce935570","modified":1617085026022},{"_id":"public/2019/09/12/【C++】C++中的四种转换类型/index.html","hash":"d98dcb7534843a0eca02be4ed65d6c8510fea521","modified":1620983992431},{"_id":"public/2019/08/25/【Linux】Linux基础/index.html","hash":"9e5e554792083f94a9a61ca1d63cbf0d3824c5ab","modified":1612190373658},{"_id":"public/2019/08/23/【C++】C++进阶/index.html","hash":"fc50265eb0ccee4433a8f3afd36c045e160fdc34","modified":1615965672359},{"_id":"public/2019/08/23/【Unity3d】存档与读档/index.html","hash":"53bfde0941de42c5678696fbd68c000044a511d7","modified":1612190373658},{"_id":"public/2019/08/23/【Unity3d】Animation/index.html","hash":"0df8de2a8bec06261d1f3daedb1b5b54d50b2531","modified":1612190373658},{"_id":"public/2019/08/23/【计算机图形学】多变形填充算法原理/index.html","hash":"a2aeb2c619e28a35e9c69a4fa168f11f180b4f3b","modified":1612190373658},{"_id":"public/index.html","hash":"5efef56470e621a3b9fe78fca89eee2f2b29ad18","modified":1620987064589},{"_id":"public/page/2/index.html","hash":"d70f17ccb46930f28232749f6e7a1abd1e900a71","modified":1620987064589},{"_id":"public/page/3/index.html","hash":"4f4c34904d27e5b28d4806bf16efac9a4759b49b","modified":1620987064589},{"_id":"public/page/4/index.html","hash":"885b6e32f80dc353767900c2d35b6ffd0837a27b","modified":1620987064589},{"_id":"public/categories/index.html","hash":"099099d088d669d3a1066942ad5aa87117867c07","modified":1617085026022},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1611392811271},{"_id":"public/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1611392811271},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1611392811271},{"_id":"public/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1611392811271},{"_id":"public/xml/local-search.xml","hash":"85fcc23b4db654a7f91fc55b6fb0442bb3ed3a9a","modified":1611392811271},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1611392811271},{"_id":"public/2019/10/03/【C++】C++函数模板的实现机制剖析/Snipaste_2019-10-03_16-51-51.png","hash":"2a90c735ad40783b372412f70f7118ffeaf85ebe","modified":1611392811271},{"_id":"public/2019/10/03/【C++】C++函数模板的实现机制剖析/Snipaste_2019-10-03_19-57-21.png","hash":"85d519d58f5f4729d5ab1352172f91204ad9a717","modified":1611392811271},{"_id":"public/2019/10/03/【C++】C++函数模板的实现机制剖析/Snipaste_2019-10-03_20-12-24.png","hash":"cad8a86adae84406c2e8817fd6ad2c2fd5978a24","modified":1611392811271},{"_id":"public/2019/10/03/【C++】C++函数模板的实现机制剖析/Snipaste_2019-10-03_20-08-21.png","hash":"5c01aefb45d2ffba96637150a101159fb8f2e382","modified":1611392811271},{"_id":"public/2019/09/11/【C++】全局变量、静态全局变量、局部变量与静态局部变量/Snipaste_2019-09-11_21-35-55.png","hash":"505601dffe4500c8a647a7063482ce62106e25e4","modified":1611392811271},{"_id":"public/2019/09/11/【C++】全局变量、静态全局变量、局部变量与静态局部变量/Snipaste_2019-09-11_21-36-28.png","hash":"07871d39f3a7ee00adf0eb647cad376c59f2f842","modified":1611392811271},{"_id":"public/2019/09/11/【C++】全局变量、静态全局变量、局部变量与静态局部变量/Snipaste_2019-09-11_21-36-38.png","hash":"f5a18dbfff19d9882af97385cfc2e516b66c6e8f","modified":1611392811271},{"_id":"public/2019/10/01/【C++】C++面向对象模型初探/Snipaste_2019-10-02_09-07-09.png","hash":"9788155af506713955a83e6b75841ab266a600c1","modified":1611392811271},{"_id":"public/2019/08/25/【Linux】Linux基础/1.png","hash":"e74c708ed4982ebfcf7d877f208c8c387f5e2807","modified":1611392811271},{"_id":"public/2019/08/25/【Linux】Linux基础/3.png","hash":"65c53fe085fb8347bb9c533cf4ce1691e9730943","modified":1611392811271},{"_id":"public/2019/08/25/【Linux】Linux基础/4.png","hash":"db75575cba757e8f832672d4f6c1890d478df81c","modified":1611392811271},{"_id":"public/2019/08/25/【Linux】Linux基础/5.png","hash":"7036239e4d1887d9c459a14a763d442e9b327797","modified":1611392811271},{"_id":"public/2019/08/25/【Linux】Linux基础/7.png","hash":"5a78f505de229568325c94e53d986a6629093b38","modified":1611392811271},{"_id":"public/2019/08/25/【Linux】Linux基础/8.png","hash":"9d26c95560af50e4a37d34fcf775d686a7bbe7fa","modified":1611392811271},{"_id":"public/2019/08/25/【Linux】Linux基础/6.png","hash":"18a0e386b38c07dc6a669d336b8b6550346fab90","modified":1611392811271},{"_id":"public/2019/11/06/【UE4】UE4组件/Snipaste_2019-10-25_10-57-11.png","hash":"0371cb3e8f1e81e9393db23deb69500533bfa1d7","modified":1611392811271},{"_id":"public/2019/11/06/【UE4】UE4组件/Snipaste_2019-10-25_11-02-10.png","hash":"f4310100332d4b3fe782214afb78bde5d975c346","modified":1611392811271},{"_id":"public/2019/11/06/【UE4】UE4组件/Snipaste_2019-10-25_10-53-07.png","hash":"ddcb3857c76fd5c1fce4df83312e1b18d42dcec2","modified":1611392811271},{"_id":"public/2019/11/06/【UE4】UE4组件/Snipaste_2019-10-25_11-10-28.png","hash":"36d8cc3a758a61b8b51b827df9b2aa036390d2fe","modified":1611392811271},{"_id":"public/2019/11/06/【UE4】UE4组件/Snipaste_2019-10-25_10-33-38.png","hash":"64554330a54c6b95ee127c991e4888a69e429103","modified":1611392811271},{"_id":"public/2019/11/06/【UE4】UE4组件/Snipaste_2019-10-25_11-17-59.png","hash":"d2c402446c1775bcb6bb0a8abc811a9f7610ab7e","modified":1611392811271},{"_id":"public/2019/11/06/【UE4】UE4组件/Snipaste_2019-10-25_11-21-18.png","hash":"eddb2a62c1ae3a93280d41caa572d80aef68a317","modified":1611392811271},{"_id":"public/2019/11/06/【UE4】UE4组件/Snipaste_2019-10-25_11-30-52.png","hash":"fc92e45a352a1c4b9e1abd2bd403b895e3f18e80","modified":1611392811271},{"_id":"public/2019/11/06/【UE4】UE4组件/Snipaste_2019-10-25_11-26-07.png","hash":"200c62da25dc88ebdfa39e6caffea12785d9279e","modified":1611392811271},{"_id":"public/2019/11/06/【UE4】UE4组件/Snipaste_2019-10-25_11-42-14.png","hash":"3aa5d7c963c118ce37b5993684a9a9577005addd","modified":1611392811271},{"_id":"public/2019/11/06/【UE4】UE4组件/Snipaste_2019-10-25_11-46-47.png","hash":"73c6ec827855ffae563f210494d6f4b4484ce837","modified":1611392811271},{"_id":"public/2019/11/06/【UE4】UE4组件/Snipaste_2019-10-25_11-39-53.png","hash":"0b863649f6e654b394955e3647fced1fcc956c72","modified":1611392811271},{"_id":"public/2019/11/06/【UE4】UE4组件/Snipaste_2019-10-25_11-50-37.png","hash":"a3b20410850873ae846e3e8f3853a7418a188710","modified":1611392811271},{"_id":"public/2019/11/06/【UE4】UE4组件/Snipaste_2019-10-25_13-12-40.png","hash":"99ff8392aadd3ef46878e5257154e6eb0f381799","modified":1611392811271},{"_id":"public/2019/11/06/【UE4】UE4组件/Snipaste_2019-10-25_13-19-47.png","hash":"3a793d0b095e18ff4df0b10cb7320e8e5195c5a6","modified":1611392811271},{"_id":"public/2019/11/06/【UE4】UE4组件/Snipaste_2019-10-28_17-26-35.png","hash":"50425fc1f654e3ed970fafe5165c351a9aaaadf7","modified":1611392811271},{"_id":"public/2019/11/06/【UE4】UE4组件/Snipaste_2019-10-28_17-04-19.png","hash":"fcd324ec161790fe960119fdcdb9a47e925b7be7","modified":1611392811271},{"_id":"public/2019/11/06/【UE4】UE4组件/Snipaste_2019-10-25_13-32-38.png","hash":"bc2a709db523fc659a2fb6986296eadb53ec7570","modified":1611392811271},{"_id":"public/2019/11/06/【UE4】UE4组件/Snipaste_2019-10-29_09-09-05.png","hash":"c191952901614af5ca09f775338d2e35c7852714","modified":1611392811271},{"_id":"public/2019/11/06/【UE4】UE4组件/Snipaste_2019-10-28_17-28-37.png","hash":"c7643952253687e3672706dbe1b0acca7a06a38d","modified":1611392811271},{"_id":"public/2019/11/06/【UE4】UE4连接MySQL/Snipaste_2019-11-05_17-54-58.png","hash":"27c07cacaa21c95831d38c452bfe6f59cf3eb9f4","modified":1611392811271},{"_id":"public/2019/11/06/【UE4】UE4连接MySQL/Snipaste_2019-11-05_18-02-53.png","hash":"5c57866c6623ed0b2c7b5444fd53e5f038dfa6a9","modified":1611392811271},{"_id":"public/2019/11/06/【UE4】UE4连接MySQL/Snipaste_2019-11-05_18-17-44.png","hash":"c6269a3a27c752c7ef1863d37535f8b0b76a236b","modified":1611392811271},{"_id":"public/2019/11/06/【UE4】UE4连接MySQL/Snipaste_2019-11-05_18-14-47.png","hash":"18a412d7081079da2a4d60bbfd85e069312a4edf","modified":1611392811271},{"_id":"public/2019/11/06/【UE4】UE4连接MySQL/Snipaste_2019-11-05_18-26-48.png","hash":"965a01ba8c647bc27a2a00bbd70d474ad8ac6a9f","modified":1611392811271},{"_id":"public/2019/11/06/【UE4】UE4连接MySQL/Snipaste_2019-11-05_18-27-48.png","hash":"32afad21d07ba21035398bbd592ceee5307bfe22","modified":1611392811271},{"_id":"public/2019/11/06/【UE4】UE4连接MySQL/Snipaste_2019-11-05_18-34-52.png","hash":"b5ceda67e3b162e555fd59450cf8a5348cfc8923","modified":1611392811271},{"_id":"public/2019/11/06/【UE4】UE4连接MySQL/Snipaste_2019-11-05_19-14-07.png","hash":"ec07cbdc14eb07a8c65387c1674cb920c2e14fa9","modified":1611392811271},{"_id":"public/2019/11/17/【UE4】UE4联级粒子系统/Snipaste_2019-11-14_09-41-14.png","hash":"2ade6fef39dbba64358a5d2f79ac88f682b4efec","modified":1611392811271},{"_id":"public/2019/11/17/【UE4】UE4联级粒子系统/Snipaste_2019-11-14_10-14-27.png","hash":"d2d45fcf41738dc41f1c11eea9ba5f85e2f9c5e9","modified":1611392811271},{"_id":"public/2019/11/17/【UE4】UE4联级粒子系统/Snipaste_2019-11-14_10-51-44.png","hash":"6641d07308c0d50c2447e8c065d5cdfc3fa45da1","modified":1611392811271},{"_id":"public/2019/11/17/【UE4】UE4联级粒子系统/Snipaste_2019-11-14_10-25-52.png","hash":"9ee3c1e6d54c5b0170248c8e7cd5b0c519be5cd6","modified":1611392811271},{"_id":"public/2019/11/17/【UE4】UE4联级粒子系统/Snipaste_2019-11-14_19-47-55.png","hash":"0548e3fb6a783367d0a2af3e8305aa0b36b809c7","modified":1611392811271},{"_id":"public/2019/11/17/【UE4】UE4联级粒子系统/Snipaste_2019-11-14_11-50-46.png","hash":"2e70c74851578edb3a5d94b4c2a0fe7f2ee4d2bb","modified":1611392811271},{"_id":"public/2019/11/17/【UE4】UE4联级粒子系统/Snipaste_2019-11-15_15-41-29.png","hash":"710f6dad4ba7890a60051a3bc6f89d846bf5cf5d","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-14_14-17-41.png","hash":"f83bcfa6debb9a1913515beab33f3d5715d5a5b4","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-15_10-16-42.png","hash":"8ede8469885ebf7cbc923d32805055cddf1d9252","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-15_10-36-15.png","hash":"0044a9c1749c0453d64e75155990bc30a2b57f1c","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-15_10-31-54.png","hash":"3f9f6113883e9699b692866442cb0ce4cafadee2","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-15_10-39-37.png","hash":"5f4cd72fe0f354f694290b73ab1bdc0242a25b79","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-15_10-45-14.png","hash":"56a1fa9cfc719c352cfe7899f921eb3c6bd0dc88","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-15_10-47-10.png","hash":"71085564086326ac75335000c36b9f4dcc85dcd1","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-15_10-50-54.png","hash":"d5f88cbc7960644e0a452418da6cd899146e40c0","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-15_10-50-02.png","hash":"847b7161ad116c2ea0b9d2aa19a46056fcbfdc71","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-15_11-04-47.png","hash":"ff5bf999fe1885ce5b2903b743191478f7d40f22","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-15_11-04-58.png","hash":"d14dae474a49c9debf89ae13defc9639d610fdc7","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-15_11-05-09.png","hash":"701a17ab4e85d5bef0637c467236642e22eadf5f","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-15_11-11-01.png","hash":"1005bef143ae4569261a45ccae43ee03330fb108","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-15_11-06-57.png","hash":"f975caeeaa07a96417efbbd8cb90f037164ab621","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-15_11-11-45.png","hash":"92d60d6fdf802ff58a02e62c0087562567513977","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-15_11-11-16.png","hash":"610880f8df9508b1a995c17057ed1d9c1c2e66ae","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-15_11-12-10.png","hash":"57f22abebb3de28f6921173fc1cb97ef7cde8771","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-15_11-11-34.png","hash":"2e0b939a04bafefcc400cb356101a9452fedc3d6","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-15_11-12-21.png","hash":"0140c32908f8bb585f9d2227f2d2d5aec3970230","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-15_11-11-59.png","hash":"565c665097bd82963d37d3ee55ea61f19bdd5045","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-15_11-12-31.png","hash":"5539e9b0014726ebd77482b9444ad7662b17b250","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-15_17-56-02.png","hash":"46fa4147b43c5849aef46813de50478e25bb446a","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-15_17-55-17.png","hash":"ca70a2d3894ad2068736e6a64731f8ce20d0eb45","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-15_18-02-03.png","hash":"86cd277b252a4cc1da93e97f5494bc87196ca565","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-16_10-05-42.png","hash":"5f878e497d56e4943e2725dfa8c1feb9d3fe8bff","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-16_17-13-58.png","hash":"49ffc8e93a439ed8da9b46daa461578935e09118","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-16_17-10-46.png","hash":"c14c3b3fb2db09bc121a82fea4f5c65b0bba8281","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-16_17-06-01.png","hash":"c173ad764a607ea5124f5c58431226ba15b3f6be","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-16_17-15-33.png","hash":"d68fc315e76de6efd20023d2349efc21acd1414d","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-16_21-27-20.png","hash":"83888c019cd4467ab6d76b6dab9473c8bad020d0","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-16_10-40-52.png","hash":"ea43cd38cbf6d5fe5f1466c6a2559895a9cf15b1","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-17_13-30-29.png","hash":"6ec3a520660892a2bc8e89d4912b0e4c77149668","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-17_13-30-49.png","hash":"018066c51f1b15f6b5b3e5b481c12b9a44fe70ae","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-17_13-46-52.png","hash":"971eb5730cde5a669cdc07b59ffae9f0a89ffbd6","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-23_17-24-52.png","hash":"bb492205214896e665910cad73c5201b976b986a","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-23_17-41-13.png","hash":"320625ad1a89a4da4b9a14518c92395ba42075ec","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-23_17-38-23.png","hash":"05d6fe4fc011f089704900b288f1bd6200556eb8","modified":1611392811271},{"_id":"public/2019/08/27/【Unity3d】Unity常用技巧笔记/Snipaste_2019-08-27_11-35-00.png","hash":"8b2c152edbeba31889b8f5d99cb30221e9ff0cca","modified":1611392811271},{"_id":"public/2019/10/06/【C++】C++STL标准模板库/Snipaste_2019-10-06_10-41-56.png","hash":"810d61e3712627b3635a1d1ce1f6491557dc201b","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-24_09-51-55.png","hash":"3c55d238b69ccbc521c5ad08b9644bda580f145d","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-24_10-53-06.png","hash":"56f4fee835704b79b6f3935ea110c9ba3ef1d89c","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-24_10-45-29.png","hash":"b704a10ea2838729dfb50e5db77d366821a456bc","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-24_10-53-34.png","hash":"101791a642dca4718f7812d7a9e9f115947a74a9","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-24_11-09-34.png","hash":"d77d66be1d8ba7b252bf66f0b90facaa57925e99","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-25_17-23-07.png","hash":"41905075876259d9b105a4c4d413b34401ed803e","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-25_17-18-23.png","hash":"87987ac555489debfea1fec095a1953fd73b3230","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-25_17-36-36.png","hash":"7553e0f0ef41dfd9e0952f87a50f6de87f90b685","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-25_17-23-27.png","hash":"0a83b862045bd256006f7c943e083d201cf05306","modified":1611392811271},{"_id":"public/2019/09/12/【C++】C++中的四种转换类型/Snipaste_2019-09-12_10-11-10.png","hash":"5696fb19f2d72c2161f4a1497bef9c68016373ef","modified":1611392811271},{"_id":"public/2019/09/12/【C++】C++中的四种转换类型/Snipaste_2019-09-12_16-32-44.png","hash":"4d26c7a6c9d42f801d7a6d53af4f820e90f06f38","modified":1611392811271},{"_id":"public/2019/08/25/【Linux】Linux基础/2.png","hash":"dbf18a4e77773e54be17847e9e4e889c2930860e","modified":1611392811271},{"_id":"public/2019/11/06/【UE4】UE4组件/Snipaste_2019-10-25_11-56-15.png","hash":"333ce02b2e4bddece40140609827a8c683f17b69","modified":1611392811271},{"_id":"public/2019/11/06/【UE4】UE4组件/Snipaste_2019-10-25_11-53-42.png","hash":"73f301358405ec6f7c4f3a02cfde542fc3c723f4","modified":1611392811271},{"_id":"public/2019/11/06/【UE4】UE4连接MySQL/Snipaste_2019-10-23_10-36-25.png","hash":"5e8cc17525a7d927da9a610282b5f183f7e05757","modified":1611392811271},{"_id":"public/2019/11/06/【UE4】UE4连接MySQL/Snipaste_2019-11-05_19-12-00.png","hash":"00de89bb9c0e786e222acd6693c4c2902ff236c2","modified":1611392811271},{"_id":"public/2019/11/17/【UE4】UE4联级粒子系统/Snipaste_2019-11-14_10-58-31.png","hash":"af681111b549c57a38a622fb6d7034eb9007b1b1","modified":1611392811271},{"_id":"public/2019/11/17/【UE4】UE4联级粒子系统/Snipaste_2019-11-14_11-14-32.png","hash":"e33944519a55306a3df1c2ea329cf500369e9002","modified":1611392811271},{"_id":"public/2019/11/17/【UE4】UE4联级粒子系统/Snipaste_2019-11-14_19-48-16.png","hash":"4163e6ff5df6335d69af47e6c2771c7fb08a8797","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-15_10-49-05.png","hash":"ca5692c9ef6079fd5323ad6115f8b7ae5a25c270","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-16_10-06-16.png","hash":"081d2c65597bb20119bb1edc30b500f7c2822600","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-16_10-06-10.png","hash":"3d17173feaca9e015bcb4e31b504953028400123","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-16_10-07-00.png","hash":"242bdb22dc186655f2f6d77befaf6b7cf14b1915","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-17_21-18-55.png","hash":"21ada8cf0e08292df6c592b053ac53cb3448bf2a","modified":1611392811271},{"_id":"public/2019/10/06/【C++】C++STL标准模板库/Snipaste_2019-10-06_14-36-13.png","hash":"8d5ba40456eebbf1980ca791bf463eaff70e9290","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-24_14-55-47.png","hash":"b5ca8383cdc6fec3e04bd5e588e885a8ea7c1f9e","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-31-16.png","hash":"ade46d8881e3c15f1a04b83e9eb3915a541a5078","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-31-36.png","hash":"ba2ee11a37f1815ffbfdab147b73161c46446795","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-31-23.png","hash":"fe4f918ef3fec236da53b5a4a0fff3943cf0a7f8","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-31-47.png","hash":"635642af09c49970dabd8e88306f7e00af24cabf","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-39-35.png","hash":"4182d56811a3252ebc9ec0d730f340c689f50c49","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-39-15.png","hash":"60b0d897de36070faa73e5cb498e896c8035794f","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-39-52.png","hash":"8d22244bea3196a6e67057344df7a97a73649b7f","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-40-54.png","hash":"8c8e6b846343e5450e4a69cd7e1020ef32ac8abb","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-40-45.png","hash":"cb8e521fede3cf38da8ff0ea3a3bb5cbc21e677b","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-40-59.png","hash":"ea2148fe24979d5c8332ce1ca4f50cae63521f33","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-25_19-14-34.png","hash":"aefe27e9f978b8c23570c6f30c8486a6d3245b7f","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-21-48.png","hash":"a11b51e94b9331eb7936704ef2fb886b16d2c6bd","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-24-33.png","hash":"1b5cc46f8a19f5607b4631c232cd031640e124b8","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-37-55.png","hash":"2d47aedb9096ea9c5c1601a5e792c79d86c7f789","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-46-46.png","hash":"0d398816ac7b4345f6f3495e17828c68480322a7","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-42-24.png","hash":"075ccdadbc3a1c44d391288048e29f83a53dd7b8","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-50-31.png","hash":"61ffbd8f56ffb672190c3fce3fb67a7561cca07a","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-59-54.png","hash":"ccf34babcb3bb65373f4f93a2278449348e8a73d","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-53-49.png","hash":"06caa84fa5b3d9d91a7cf9368eeed844e2023fa3","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-07-44.png","hash":"dea91d3b9a042ba417e7f75da511d80a095ade41","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-07-50.png","hash":"b1d6ea713edee473f3cecd8939d2718bc8a04ff5","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-12-59.png","hash":"748732a228e6a13df384d15286c25c557afd6a51","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-21-30.png","hash":"08575e7872c9da7eda474b4170786eb2749dc79c","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-25-34.png","hash":"d0e0e322959a40433f2b7d6b98b4a8dbe48d1830","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-29-34.png","hash":"213cc29f7b2f03df188991824d2875b250dd5fef","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-30-00.png","hash":"c363550daba311a430d1326e3a77bbc093c991a8","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-27_10-32-38.png","hash":"d8bd1910293501ae25dafdd46ddbb89ae6ce9eae","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-27_10-38-13.png","hash":"4a9fe778400ae1372b3a24580cdb8fadf4e1594f","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-27_11-01-39.png","hash":"f3503da8827e583536e1bdcd679933d85dee71d1","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-27_11-04-21.png","hash":"7b666b1faccf4d57fb8068daecaa2984a59b0ba3","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-27_11-28-43.png","hash":"06fd9ec3a40d13d78e36d36379c64a2a2ba75b9c","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-28_15-51-30.png","hash":"01bca903f964a3c76edbb14de1fbd09d558269f8","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-28_17-00-10.png","hash":"7f1daca36a8e7ebea17b979721e7ceb8e624defd","modified":1611392811271},{"_id":"public/2019/09/14/【C++】C++高级/Snipaste_2019-09-14_16-29-43.png","hash":"a55e0855be7a6b9653d60e1aa02f35d028edf35c","modified":1611392811271},{"_id":"public/2019/09/14/【C++】C++高级/Snipaste_2019-10-01_16-21-15.png","hash":"11db0bd09076d6a9c5453ffb9d727fcc69f76014","modified":1611392811271},{"_id":"public/2019/09/14/【C++】C++高级/Snipaste_2019-10-01_16-52-53.png","hash":"597bf574dfd790524a42791a734b4e6f56001648","modified":1611392811271},{"_id":"public/2019/09/14/【C++】C++高级/Snipaste_2019-10-02_15-50-39.png","hash":"64fa5f2de6fb00f854a93938e5079edd530ba1d5","modified":1611392811271},{"_id":"public/2019/09/14/【C++】C++高级/Snipaste_2019-10-02_16-10-55.png","hash":"c37e3f7d89ea5eaa7f8706f7e6c403e1e240adf8","modified":1611392811271},{"_id":"public/2019/09/14/【C++】C++高级/Snipaste_2019-10-06_10-03-47.png","hash":"ec465977f70b7aa59d67bac0a5ad41c61b5dd583","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-24_15-11-12.png","hash":"6bed8c6af17501079ef4ad59fb1d855c5de52eb1","modified":1611392811271},{"_id":"public/2019/09/12/【C++】C++中的四种转换类型/Snipaste_2019-09-12_10-44-16.png","hash":"661f9ff0574baf2e3dcdbb515de1b6a43fe41a5d","modified":1611392811271},{"_id":"public/2019/09/12/【C++】C++中的四种转换类型/Snipaste_2019-09-12_11-51-30.png","hash":"4a8fcaf0577f5a65d01701988de966f96c516f6a","modified":1611392811271},{"_id":"public/2019/09/12/【C++】C++中的四种转换类型/Snipaste_2019-09-12_11-06-11.png","hash":"aa62e7231b877ae93b784cab2f17ec3213a458b3","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-14_14-17-46.png","hash":"8a8f9ce0ed85941affdbfce6b588aa3e55f7fd79","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-14_14-17-49.png","hash":"beaa3ceb15efbe13bf7a57e322245c6f71299210","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-24_11-12-38.png","hash":"e2ccdcfc20a97e8dd57e1102fe9fde71e9797e51","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-25_19-04-57.png","hash":"b7d1622850aa9558bc381d6c98a2108ff0d5aa4c","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-26_10-58-33.png","hash":"5136b69cd4a410b42109aa2a2f27e099c1e49d30","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-02-54.png","hash":"54b0de977b1b0ceccf1947a54b60fb2ac00d863d","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-26_19-59-29.png","hash":"43e83aac38ad697b66bc220000a258c0bf938c05","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-27_10-35-51.png","hash":"ea10f8899c92bf55b8c07a42ecc57c33b178c49b","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-28_16-45-41.png","hash":"13ae1f4e51e9a233a366471ec9a9bba7518e6c3a","modified":1611392811271},{"_id":"public/2019/09/14/【C++】C++高级/Snipaste_2019-09-14_09-39-52.png","hash":"a50164c862b593399eb3791eea5c3118e0f1b4bf","modified":1611392811271},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1611392811271},{"_id":"public/js/boot.js","hash":"1aea6f229e2298c7c134e9f1cc94576cd3f30611","modified":1611392811271},{"_id":"public/js/debouncer.js","hash":"045f324777bdfb99d4c17b1806169f029f897a65","modified":1611392811271},{"_id":"public/js/events.js","hash":"9b3a3dfdbc64e6b367ae2ebf7700ed611ecd0d47","modified":1611392811271},{"_id":"public/js/color-schema.js","hash":"7d7444387e549e06a4a378706df92558de62e4e7","modified":1611392811271},{"_id":"public/js/leancloud.js","hash":"4701f49b3dc62939adff5cc11f6d21963df7f135","modified":1611392811271},{"_id":"public/js/lazyload.js","hash":"0df461660bbd73a79f3125ba4e9bdbc856232e6b","modified":1611392811271},{"_id":"public/js/local-search.js","hash":"13d5ef2fe68c49bd6096781034dbb26c190b5176","modified":1611392811271},{"_id":"public/js/plugins.js","hash":"e1fd90d773b3e8dfb075086f58787de21288d650","modified":1611392811271},{"_id":"public/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":1611392811271},{"_id":"public/js/utils.js","hash":"3086cede8d6d96ac5f4b5236b06271599a1ebbcb","modified":1611392811271},{"_id":"public/css/main.css","hash":"08f5e8366e8512663b992aa2d6afb73096e52440","modified":1611392811271},{"_id":"public/2019/10/03/【C++】C++函数模板的实现机制剖析/Snipaste_2019-10-03_20-07-41.png","hash":"d0cf6cb62c29ef17eb23940549bd935dc0f02fd3","modified":1611392811271},{"_id":"public/2019/11/17/【UE4】UE4联级粒子系统/Snipaste_2019-11-14_11-03-35.png","hash":"bbc2ad95a69c21a5b99126a388ac85519def2245","modified":1611392811271},{"_id":"public/2019/11/17/【UE4】UE4联级粒子系统/Snipaste_2019-11-14_11-10-41.png","hash":"a845cfea131a4ced491ed5542bf60ffa81b1a6b5","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-15_10-23-17.png","hash":"62a865df56919f2c709b44133254c670b97c6e35","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-15_10-23-36.png","hash":"9150ea14e4c635f103cd011dff31ad2700e24691","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-27_11-31-04.png","hash":"bd4e0537881416b948fbf9ceed44ccb07e4b85ec","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-14_11-46-45.png","hash":"ac2230cfae134ce8e2e343f3c1fd94d824e82b6d","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-24_09-41-27.png","hash":"a320fe2b688f260b3107db98d0c86a425a6737b1","modified":1611392811271},{"_id":"public/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-26_17-38-54.png","hash":"aed2953ba79a0b2e220f229ce12d430d0af7e5c9","modified":1611392811271},{"_id":"public/2019/08/25/【Linux】Linux基础/9.png","hash":"f89c4f40fceffe3270865ae53802662b509ff792","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-15_10-59-58.png","hash":"8e5fb25c3a7a04a6f590ff39f23b864ed21baf54","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-15_11-15-27.png","hash":"c7f49eaf79025d956ed59b3ebe2a68e5d8fb4115","modified":1611392811271},{"_id":"public/2019/10/12/【日记】在武汉跑秋招的日子/Snipaste_2019-09-08_09-15-55.png","hash":"9be0eac8c02b5ddc7f989ae4916807ab09c68099","modified":1611392811271},{"_id":"public/2019/11/17/【UE4】UE4联级粒子系统/Snipaste_2019-11-15_15-05-48.png","hash":"9f1cb0bafafc1a76a027e7f661b1030b631dd3ef","modified":1611392811271},{"_id":"public/2019/10/14/【UE4】UE4基础/Snipaste_2019-10-15_10-42-21.png","hash":"d0603a7887618e98b79545f1ccd6ed48680785db","modified":1611392811271},{"_id":"public/2019/10/12/【日记】在武汉跑秋招的日子/Snipaste_2019-09-08_09-23-19.png","hash":"71ac9b67b6dd5da0a2993341647ad05df28b1357","modified":1611392811271},{"_id":"public/2019/10/12/【日记】在武汉跑秋招的日子/Snipaste_2019-09-08_09-28-22.png","hash":"d0f9d0530f0295f806e047cc3ccbae6dc257e14d","modified":1611392811271},{"_id":"public/2019/08/25/【Unity3d】Space/Unity3d_Space.png","hash":"166e98471595a37ceb251a386330f2d9082747d7","modified":1611392811271},{"_id":"public/2019/10/12/【日记】在武汉跑秋招的日子/QQ图片20191012190513.jpg","hash":"dfd693ceb839b96b0c904864c946a192ac1a28d6","modified":1611392811271},{"_id":"public/2019/10/12/【日记】在武汉跑秋招的日子/Snipaste_2019-09-08_09-34-22.png","hash":"4c1b8e5d02764c3fecfdb826a45ef894be9c89e8","modified":1611392811271},{"_id":"public/2019/08/25/【程序编程】程序编程高级/程序编程高级.png","hash":"580dd5da5be3387deee2b11a0abfdfb35613811c","modified":1611392811271},{"_id":"public/2019/10/12/【日记】在武汉跑秋招的日子/QQ图片20191012190452.jpg","hash":"7d97cda11fc0f67e86a9bee5c2071dfa542cfeaa","modified":1611392811271},{"_id":"public/2019/10/12/【日记】在武汉跑秋招的日子/QQ图片20191012190456.jpg","hash":"a43cbb34f7897911d11cbd288b4ec3a4730e343f","modified":1611392811271},{"_id":"public/2019/10/12/【日记】在武汉跑秋招的日子/QQ图片20191012190626.jpg","hash":"66bfee7195531ec251fcb619807b67557e74bca7","modified":1611392811271},{"_id":"public/2019/10/12/【日记】在武汉跑秋招的日子/QQ图片20191012190634.jpg","hash":"2b59287bc72f813364ac207c03578432b16e6899","modified":1611392811271},{"_id":"public/2019/10/12/【日记】在武汉跑秋招的日子/QQ图片20191012190518.jpg","hash":"5bfd0f313a82c1c25f119e3b46a5f8a7210ed4fe","modified":1611392811271},{"_id":"public/2019/10/12/【日记】在武汉跑秋招的日子/QQ图片20191012190604.jpg","hash":"fa70f354999954542e8de724142fb0e5f61bd8f7","modified":1611392811271},{"_id":"public/2019/08/25/【Unity3d】Lightmap/Unity_Lightmap.png","hash":"d9f59201a5bfefae4e7a19037ec5fa83fd252fcc","modified":1611392811271},{"_id":"public/2019/10/12/【日记】在武汉跑秋招的日子/QQ图片20191012190414.jpg","hash":"1097a0d58ff63494fc9df8063df1ba3dc68fe718","modified":1611392811271},{"_id":"public/2019/10/12/【日记】在武汉跑秋招的日子/QQ图片20191012190500.jpg","hash":"234900faa13b3ac924602b35ec6567d43de58703","modified":1611392811271},{"_id":"public/2019/10/12/【日记】在武汉跑秋招的日子/QQ图片20191012190444.jpg","hash":"68f5f3ebc70e48beff4b72328a176ef5e33c55a3","modified":1611392811271},{"_id":"public/2019/10/12/【日记】在武汉跑秋招的日子/QQ图片20191012190532.jpg","hash":"d6f2182efaaf7e19113aee4716f90113474e60e8","modified":1611392811271},{"_id":"public/2019/10/12/【日记】在武汉跑秋招的日子/QQ图片20191012190600.jpg","hash":"e2140f8b5708d2d88b5f54b4ac26eee7a55d21ac","modified":1611392811271},{"_id":"public/2019/10/12/【日记】在武汉跑秋招的日子/QQ图片20191012190616.jpg","hash":"392aaeb7d3e95e57bddb29d75cb9db5d52a90037","modified":1611392811271},{"_id":"public/2019/10/12/【日记】在武汉跑秋招的日子/QQ图片20191012190504.jpg","hash":"427c42dc3ce9a96a89d0d6a31f77be9b5477e401","modified":1611392811271},{"_id":"public/2019/10/12/【日记】在武汉跑秋招的日子/QQ图片20191012190448.jpg","hash":"97c7bbd7c7fb08f7cb0ac999252619164c3e245b","modified":1611392811271},{"_id":"public/2019/10/12/【日记】在武汉跑秋招的日子/QQ图片20191012190638.jpg","hash":"3e2d6ecaa5276c95d560b4d04cf5bbf101b39d6d","modified":1611392811271},{"_id":"public/2019/10/12/【日记】在武汉跑秋招的日子/QQ图片20191012190641.jpg","hash":"782bbc9b28e087862b54290d339f0d86730fcb6f","modified":1611392811271},{"_id":"public/2019/08/25/【网络通信】物联网通信基础/物联网通信技术基础.png","hash":"4cc498e86f16de8102e148fc52eaf2b362c01399","modified":1611392811271},{"_id":"public/2019/10/12/【日记】在武汉跑秋招的日子/QQ图片20191012190612.jpg","hash":"08ddb1df3dc127669c7866ecd39beac2ff007594","modified":1611392811271},{"_id":"public/2019/10/12/【日记】在武汉跑秋招的日子/QQ图片20191012190622.jpg","hash":"61358bc5e08f52864424778437035cfe0d556f32","modified":1611392811271},{"_id":"public/2019/10/12/【日记】在武汉跑秋招的日子/QQ图片20191012190556.jpg","hash":"28db93f05e9acbc0afc723a64de2329d76ee3909","modified":1611392811271},{"_id":"public/2019/10/12/【日记】在武汉跑秋招的日子/QQ图片20191012190552.jpg","hash":"2ab850404ffb530e81c219450521f53b2b768703","modified":1611392811271},{"_id":"public/2019/10/12/【日记】在武汉跑秋招的日子/QQ图片20191012190542.jpg","hash":"d2ff3d6038baa9a54a0e371acd4c5801a7869d50","modified":1611392811271},{"_id":"public/2019/10/12/【日记】在武汉跑秋招的日子/QQ图片20191012190547.jpg","hash":"7ea440b83e24df2ad4a3d33636a1498d3f84e414","modified":1611392811271},{"_id":"public/2019/10/12/【日记】在武汉跑秋招的日子/QQ图片20191012190538.jpg","hash":"e6a48efcb69a1bc33c0b5d6952fd7a564d4b87b3","modified":1611392811271},{"_id":"public/2019/10/12/【日记】在武汉跑秋招的日子/QQ图片20191012190607.jpg","hash":"6ed81df498eced4f8284e720f03c451da9a30ce3","modified":1611392811271},{"_id":"public/2019/10/12/【日记】在武汉跑秋招的日子/QQ图片20191012190630.jpg","hash":"24b42d9c8e254f45decb91f34d1d28889617256a","modified":1611392811271},{"_id":"public/2019/08/25/【网络游戏】网络游戏基础/网络游戏基础.jpg","hash":"0118b0b496d409e3758320f375569426f298bb82","modified":1611392811271},{"_id":"public/2019/09/09/【Lua】Lua基础/Lua基础1.png","hash":"c1b38cf0fe6961681a41fb0521d187bbb2d2df6c","modified":1611392811271},{"_id":"public/2019/09/09/【Lua】Lua基础/Lua基础2.png","hash":"c21f71c7832f37ea9c7fead5b84975dd441bb416","modified":1611392811271},{"_id":"themes/Fluid/source/img/Home.jpg","hash":"73e59f9adb171419b170eafef5910978d39f88a2","modified":1612322035700},{"_id":"themes/Fluid/source/img/Post.jpg","hash":"db5d8fde1698e19a41b984eaeb0f46b482427a79","modified":1612322199408},{"_id":"themes/Fluid/source/img/Categories.jpg","hash":"1c14a6fc51bf5de02c692d5dd71cad9224d7ad6e","modified":1612322174669},{"_id":"themes/Fluid/source/img/Tags.jpg","hash":"6bc21bcefcfa081870d1ece790ca0bbefccf3ab7","modified":1612322219925},{"_id":"themes/Fluid/source/img/About.png","hash":"4121649df269f0a69486ecfe13961d9653413b0d","modified":1612322118116},{"_id":"themes/Fluid/source/img/Archives.png","hash":"d2e024f5a685937eb28f020dee89f966b59f5d43","modified":1612322151291},{"_id":"public/img/Home.jpg","hash":"73e59f9adb171419b170eafef5910978d39f88a2","modified":1612322047634},{"_id":"public/img/Post.jpg","hash":"db5d8fde1698e19a41b984eaeb0f46b482427a79","modified":1612322230789},{"_id":"public/img/Categories.jpg","hash":"1c14a6fc51bf5de02c692d5dd71cad9224d7ad6e","modified":1612322230789},{"_id":"public/img/Tags.jpg","hash":"6bc21bcefcfa081870d1ece790ca0bbefccf3ab7","modified":1612322230789},{"_id":"public/img/About.png","hash":"4121649df269f0a69486ecfe13961d9653413b0d","modified":1612322230789},{"_id":"public/img/Archives.png","hash":"d2e024f5a685937eb28f020dee89f966b59f5d43","modified":1612322230789},{"_id":"themes/Fluid/source/img/shun.jpg","hash":"7b423c4c9ab061f6a58b4d7a80f4ff54be919d01","modified":1612190104560},{"_id":"public/img/shun.jpg","hash":"7b423c4c9ab061f6a58b4d7a80f4ff54be919d01","modified":1612190373658},{"_id":"source/_posts/测试.md","hash":"6d082190a66f27940cc9d00c73da5fd47a38eb3c","modified":1612193159983},{"_id":"public/2021/02/01/测试/index.html","hash":"065e2e9e0414642476dc85fad4b05a0e61892f6e","modified":1612193167447},{"_id":"public/archives/2021/index.html","hash":"7b046cd92de5aa395ce7e32b2458fe813a10f38c","modified":1620987064589},{"_id":"public/archives/2021/02/index.html","hash":"af8835c18cd25b21c871957c11a5cd9da88dcc9c","modified":1620987064589},{"_id":"source/_posts/【日记】在衡变的日子.md","hash":"b83195d92aac59e3c7ff290108b6ae9b7f5855f0","modified":1612273879028},{"_id":"source/_posts/【日记】在衡变的日子/QQ图片20210202211300.jpg","hash":"f96dbfb9ee2de52f4c3d4b4381df841d7db518b2","modified":1612271519992},{"_id":"source/_posts/【日记】在衡变的日子/QQ图片20210202211306.jpg","hash":"fbf7583252813be73cc8b998ed48b252b10b5a88","modified":1612271521117},{"_id":"source/_posts/【日记】在衡变的日子/QQ图片20210202211319.jpg","hash":"79fda7fa02e975b51e1c4333d9ac889f59d91924","modified":1612271518172},{"_id":"source/_posts/【日记】在衡变的日子/QQ图片20210202211257.jpg","hash":"038ba25a702df951ef493ee267ecb649711e9d1a","modified":1612271520499},{"_id":"source/_posts/【日记】在衡变的日子/QQ图片20210202211250.jpg","hash":"ae45894a4f7e16dda020bcdadf0ed061adb28fdc","modified":1612271522480},{"_id":"source/_posts/【日记】在衡变的日子/QQ图片20210202211325.jpg","hash":"3f05dd8068bf7fa13cd07af36613b471d677065c","modified":1612271517394},{"_id":"source/_posts/【日记】在衡变的日子/QQ图片20210202211910.jpg","hash":"0b7d602c5d81b6212a271c5f204e3b6cb9953c9b","modified":1612271514740},{"_id":"source/_posts/【日记】在衡变的日子/QQ图片20210202211323.jpg","hash":"a95a6ce3c765ba5c5a03fc65f5dcc696c6f757c8","modified":1612271517880},{"_id":"source/_posts/【日记】在衡变的日子/QQ图片20210202211328.jpg","hash":"66d7e8de685ab71cc3a11bb5d8ba605f0a97d789","modified":1612271516967},{"_id":"public/2021/02/02/【日记】在衡变的日子/index.html","hash":"6ff40abd87f7ab0eacc347f535adc848de320818","modified":1612320927476},{"_id":"public/2021/02/02/【日记】在衡变的日子/QQ图片20210202211300.jpg","hash":"f96dbfb9ee2de52f4c3d4b4381df841d7db518b2","modified":1612273903678},{"_id":"public/2021/02/02/【日记】在衡变的日子/QQ图片20210202211319.jpg","hash":"79fda7fa02e975b51e1c4333d9ac889f59d91924","modified":1612273903678},{"_id":"public/2021/02/02/【日记】在衡变的日子/QQ图片20210202211306.jpg","hash":"fbf7583252813be73cc8b998ed48b252b10b5a88","modified":1612273903678},{"_id":"public/2021/02/02/【日记】在衡变的日子/QQ图片20210202211250.jpg","hash":"ae45894a4f7e16dda020bcdadf0ed061adb28fdc","modified":1612273903678},{"_id":"public/2021/02/02/【日记】在衡变的日子/QQ图片20210202211257.jpg","hash":"038ba25a702df951ef493ee267ecb649711e9d1a","modified":1612273903678},{"_id":"public/2021/02/02/【日记】在衡变的日子/QQ图片20210202211910.jpg","hash":"0b7d602c5d81b6212a271c5f204e3b6cb9953c9b","modified":1612273903678},{"_id":"public/2021/02/02/【日记】在衡变的日子/QQ图片20210202211325.jpg","hash":"3f05dd8068bf7fa13cd07af36613b471d677065c","modified":1612273903678},{"_id":"public/2021/02/02/【日记】在衡变的日子/QQ图片20210202211323.jpg","hash":"a95a6ce3c765ba5c5a03fc65f5dcc696c6f757c8","modified":1612273903678},{"_id":"public/2021/02/02/【日记】在衡变的日子/QQ图片20210202211328.jpg","hash":"66d7e8de685ab71cc3a11bb5d8ba605f0a97d789","modified":1612273903678},{"_id":"source/_posts/【C++】C++ PremierReadNote.md","hash":"ead74e172b8bf8a889b28d19e53a4a45f8539ccb","modified":1617086515056},{"_id":"source/_posts/【Dev】DevExpress应用.md","hash":"1420e8b1068211cd5193fdbdee62601ff6dadab7","modified":1616721016852},{"_id":"source/_posts/【Dev】DevExpress应用/Image_20201222193848.png","hash":"3620e0e955271725fe6d81c06a7b727fe681b53e","modified":1608637148160},{"_id":"source/_posts/【Dev】DevExpress应用/Snipaste_2020-12-17_19-49-11.png","hash":"798508476209fd38e28c4a45d0bc2b338a945f53","modified":1608205752511},{"_id":"source/_posts/【Dev】DevExpress应用/Snipaste_2020-12-18_09-13-12.png","hash":"01bad696aae8cc6d5b92a9ed8b621649adbbb777","modified":1608253994102},{"_id":"source/_posts/【Dev】DevExpress应用/Snipaste_2020-12-17_19-29-45.png","hash":"9425863d3218ec8cebe3c3b0345614d58f0098dc","modified":1608204586495},{"_id":"source/_posts/【Dev】DevExpress应用/Snipaste_2020-12-18_09-11-36.png","hash":"2e06e72def8028c95c7b992986742d6adcf1e420","modified":1608253898722},{"_id":"source/_posts/【Dev】DevExpress应用/Snipaste_2020-12-22_19-13-20.png","hash":"a286a82abc35027189b331b42b54330019c93b2d","modified":1608635603182},{"_id":"source/_posts/【Dev】DevExpress应用/Snipaste_2021-01-06_21-26-31.png","hash":"7102052f379d73c1c6ec877017e8ee110f399b09","modified":1609939593477},{"_id":"source/_posts/【Dev】DevExpress应用/Snipaste_2021-01-07_20-43-04.png","hash":"56cbb72fcdaf1d2b3ddfc795fd83642d6b09f5a7","modified":1610023386389},{"_id":"source/_posts/【Dev】DevExpress应用/Snipaste_2021-01-07_20-45-28.png","hash":"811e77c19023a8962524201e2d1edef70f2e3daf","modified":1610023530243},{"_id":"source/_posts/【Dev】DevExpress应用/Snipaste_2020-12-17_19-20-19.png","hash":"4cb8005ace0ce5927c477d95e221000e0d3ac2c2","modified":1608204027762},{"_id":"source/_posts/【Dev】DevExpress应用/Snipaste_2021-01-07_20-38-53.png","hash":"b48a9851a77b5fb992d4a630da2035c03863cb03","modified":1610023136056},{"_id":"source/_posts/【Dev】DevExpress应用/Snipaste_2021-01-07_20-45-55.png","hash":"0bc341746e7c1142d80c2b1c7b86d4e4fac21c33","modified":1610023556544},{"_id":"public/2021/02/03/【C++】C++ PremierReadNote/index.html","hash":"647a4416fed9bdf66ee1cdc47b065660b7558478","modified":1617151831912},{"_id":"public/2021/02/03/【Dev】DevExpress应用/index.html","hash":"97969cd8f8c524a0b40d2f11f88a6f07de360e43","modified":1617085026022},{"_id":"public/tags/Dev/index.html","hash":"6411c62400b430348ee174459cb1c74a222186e2","modified":1612320927476},{"_id":"public/2021/02/03/【Dev】DevExpress应用/Image_20201222193848.png","hash":"3620e0e955271725fe6d81c06a7b727fe681b53e","modified":1612320927476},{"_id":"public/2021/02/03/【Dev】DevExpress应用/Snipaste_2020-12-17_19-29-45.png","hash":"9425863d3218ec8cebe3c3b0345614d58f0098dc","modified":1612320927476},{"_id":"public/2021/02/03/【Dev】DevExpress应用/Snipaste_2020-12-17_19-20-19.png","hash":"4cb8005ace0ce5927c477d95e221000e0d3ac2c2","modified":1612320927476},{"_id":"public/2021/02/03/【Dev】DevExpress应用/Snipaste_2020-12-17_19-49-11.png","hash":"798508476209fd38e28c4a45d0bc2b338a945f53","modified":1612320927476},{"_id":"public/2021/02/03/【Dev】DevExpress应用/Snipaste_2020-12-18_09-11-36.png","hash":"2e06e72def8028c95c7b992986742d6adcf1e420","modified":1612320927476},{"_id":"public/2021/02/03/【Dev】DevExpress应用/Snipaste_2020-12-18_09-13-12.png","hash":"01bad696aae8cc6d5b92a9ed8b621649adbbb777","modified":1612320927476},{"_id":"public/2021/02/03/【Dev】DevExpress应用/Snipaste_2021-01-06_21-26-31.png","hash":"7102052f379d73c1c6ec877017e8ee110f399b09","modified":1612320927476},{"_id":"public/2021/02/03/【Dev】DevExpress应用/Snipaste_2020-12-22_19-13-20.png","hash":"a286a82abc35027189b331b42b54330019c93b2d","modified":1612320927476},{"_id":"public/2021/02/03/【Dev】DevExpress应用/Snipaste_2021-01-07_20-43-04.png","hash":"56cbb72fcdaf1d2b3ddfc795fd83642d6b09f5a7","modified":1612320927476},{"_id":"public/2021/02/03/【Dev】DevExpress应用/Snipaste_2021-01-07_20-45-28.png","hash":"811e77c19023a8962524201e2d1edef70f2e3daf","modified":1612320927476},{"_id":"public/2021/02/03/【Dev】DevExpress应用/Snipaste_2021-01-07_20-38-53.png","hash":"b48a9851a77b5fb992d4a630da2035c03863cb03","modified":1612320927476},{"_id":"public/2021/02/03/【Dev】DevExpress应用/Snipaste_2021-01-07_20-45-55.png","hash":"0bc341746e7c1142d80c2b1c7b86d4e4fac21c33","modified":1612320927476},{"_id":"themes/Fluid/source/Home.jpg","hash":"1545b392f488abc92d12adbccef11a3ad9823ac5","modified":1612187209626},{"_id":"public/Home.jpg","hash":"1545b392f488abc92d12adbccef11a3ad9823ac5","modified":1612321465523},{"_id":"themes/Fluid/source/Post.jpg","hash":"4b6dcad420b98daf92708ea901be276d30f04b99","modified":1612187220706},{"_id":"themes/Fluid/source/Categories.jpg","hash":"39418dab582147f51dbf45e5d13e3811859fc056","modified":1612187221459},{"_id":"themes/Fluid/source/Tags.jpg","hash":"796083827ba031a2a352cfbc3c7353dfc432a527","modified":1612187214716},{"_id":"themes/Fluid/source/About.png","hash":"309d62fd141470e684e86b999a28dea49d8edde7","modified":1612187223762},{"_id":"themes/Fluid/source/Archives.png","hash":"3b4842a0c0a4a1fbd442c9a1cb1d53dd806c56ec","modified":1612187218858},{"_id":"public/Post.jpg","hash":"4b6dcad420b98daf92708ea901be276d30f04b99","modified":1612322230789},{"_id":"public/Tags.jpg","hash":"796083827ba031a2a352cfbc3c7353dfc432a527","modified":1612322230789},{"_id":"public/Categories.jpg","hash":"39418dab582147f51dbf45e5d13e3811859fc056","modified":1612322230789},{"_id":"public/About.png","hash":"309d62fd141470e684e86b999a28dea49d8edde7","modified":1612322230789},{"_id":"public/Archives.png","hash":"3b4842a0c0a4a1fbd442c9a1cb1d53dd806c56ec","modified":1612322230789},{"_id":"source/_posts/【Python】Python学习笔记.md","hash":"1160048f27e545607eb548649a01e3c30343da1b","modified":1614067252640},{"_id":"public/tags/Python/index.html","hash":"391b9c1d6249ebf72f09425acf95e91d335a4446","modified":1614067430657},{"_id":"public/2021/02/04/【Python】Python学习笔记/index.html","hash":"92b3107a68e9596ef82ea09f2becaf6c323f7f29","modified":1615883053981},{"_id":"source/_posts/【计算机网络】物联网通信基础.md","hash":"5a7b61c5196cb51cac9fba3affad969ac0b22167","modified":1614146964559},{"_id":"source/_posts/【计算机网络】网络游戏基础.md","hash":"2c9455b4dc11e6c048f7d5b273e3b0fe4bbd8c62","modified":1614146939629},{"_id":"public/2019/08/25/【计算机网络】网络游戏基础/index.html","hash":"cb520600752e73d33ce7468eb0d20a085fd555e4","modified":1614147040400},{"_id":"public/2019/08/25/【计算机网络】物联网通信基础/index.html","hash":"a7636839d612ea9a6c20cb735b14cbc97cc4d484","modified":1614147040400},{"_id":"public/tags/计算机网络/index.html","hash":"b307c25ace5fe81268070a6396f405c5db3fd537","modified":1614147040400},{"_id":"source/_posts/【UE4】UE4GamePlay架构.md","hash":"c5a8b105e50c7f7718fc8601f745170572fa3475","modified":1620903682596},{"_id":"source/_posts/【UE4】UE4GamePlay架构/Snipaste_2021-03-10_16-27-31.png","hash":"11127ceafb1b5e1e008d022c94819598205fdfd5","modified":1615364852826},{"_id":"source/_posts/【UE4】UE4GamePlay架构/Snipaste_2021-02-26_14-10-33.png","hash":"2aa3d3408517b38ce794629c4da788166f1afffc","modified":1614319853418},{"_id":"source/_posts/【UE4】UE4GamePlay架构/Snipaste_2021-03-09_21-15-31.png","hash":"720b4cd5031832609be3695273e2cb6956a3bf9e","modified":1615295743043},{"_id":"public/archives/page/5/index.html","hash":"16aad2b5082d4ab3ac8b079f63885ba8b9d7f427","modified":1620987064589},{"_id":"public/page/5/index.html","hash":"09c86fbf41cfd333152454f1f5e9ca616e3676d1","modified":1620987064589},{"_id":"public/2021/02/26/【UE4】UE4GamePlay架构/index.html","hash":"3d2ce930c46d7de5783f6b2d8825328dd93928b6","modified":1620983992431},{"_id":"public/2021/02/26/【UE4】UE4GamePlay架构/Snipaste_2021-03-10_16-27-31.png","hash":"11127ceafb1b5e1e008d022c94819598205fdfd5","modified":1615883053981},{"_id":"public/2021/02/26/【UE4】UE4GamePlay架构/Snipaste_2021-02-26_14-10-33.png","hash":"2aa3d3408517b38ce794629c4da788166f1afffc","modified":1615883053981},{"_id":"public/2021/02/26/【UE4】UE4GamePlay架构/Snipaste_2021-03-09_21-15-31.png","hash":"720b4cd5031832609be3695273e2cb6956a3bf9e","modified":1615883053981},{"_id":"source/_posts/【C++】C++11新特性.md","hash":"1db37f6ce99218b15055bec321be5fc659b32a15","modified":1616059398369},{"_id":"public/2021/03/17/【C++】C++11新特性/index.html","hash":"d33e371e21812091658f5e86e8099c51451e791e","modified":1620984912072},{"_id":"public/archives/2021/03/index.html","hash":"bb8fb9dc4c4b511d218a4643dde075d90b589716","modified":1620987064589},{"_id":"public/tags/CPlus/index.html","hash":"a1801fc2c743c86d1ed17b111087b93dc66fd244","modified":1617085026022},{"_id":"source/_posts/【UE4】UE4GamePlay架构/Snipaste_2021-03-18_14-34-58.png","hash":"68477da60d9b937e667f77f07aecc31cffb1b09b","modified":1616049300959},{"_id":"source/_posts/【UE4】UE4GamePlay架构/Snipaste_2021-03-19_21-54-55.png","hash":"0899e8a968d3cff0d4d39eb90f50077496e6967d","modified":1616162097189},{"_id":"public/2021/02/26/【UE4】UE4GamePlay架构/Snipaste_2021-03-18_14-34-58.png","hash":"68477da60d9b937e667f77f07aecc31cffb1b09b","modified":1616651393998},{"_id":"public/2021/02/26/【UE4】UE4GamePlay架构/Snipaste_2021-03-19_21-54-55.png","hash":"0899e8a968d3cff0d4d39eb90f50077496e6967d","modified":1616651393998},{"_id":"source/_posts/【C++】C++STL标准模板库/Snipaste_2021-03-30_09-43-50.png","hash":"640e684bd8314f4ed5b01aca778684cd360f97f9","modified":1617068636655},{"_id":"public/2019/10/06/【C++】C++STL标准模板库/Snipaste_2021-03-30_09-43-50.png","hash":"640e684bd8314f4ed5b01aca778684cd360f97f9","modified":1617085026022},{"_id":"source/_posts/【UE4】UE4GamePlay架构/Snipaste_2021-04-01_11-26-15.png","hash":"8d329c49a577ffb0e0af7f87de3ea4a00114b256","modified":1617247582786},{"_id":"public/2021/02/26/【UE4】UE4GamePlay架构/Snipaste_2021-04-01_11-26-15.png","hash":"8d329c49a577ffb0e0af7f87de3ea4a00114b256","modified":1617355217781},{"_id":"source/_posts/【BAT】BATWindows自动脚本同步GitHub远程仓库.md","hash":"dc2225404780e3a9817e9233445047486db48e4c","modified":1620983837795},{"_id":"source/_posts/【UE4】UE4Socket编程.md","hash":"564b06e2b91f560963cd247e32c77d7e8cec3764","modified":1620984410217},{"_id":"source/_posts/【UE4】UE4使用蓝图动态修改粒子参数.md","hash":"5c14ea426508f905bc2ee1ebd6189b5bb852d4d4","modified":1620984632972},{"_id":"source/_posts/【UE4】UE4内嵌Web及与Web通信.md","hash":"4296c8a031a5022712fabc7bf5060998088cbca6","modified":1620984614587},{"_id":"source/_posts/【UE4】UE4角色控制.md","hash":"1794e997b79cb01d4dd8dff32f5fc9477b2f7e5c","modified":1620984591165},{"_id":"source/_posts/【BAT】BATWindows自动脚本同步GitHub远程仓库/Snipaste_2020-01-21_16-04-19.png","hash":"ce113ff6978c5e500cd80ecd7f7f91fa66dd7f1a","modified":1620789535173},{"_id":"source/_posts/【UE4】UE4Socket编程/Snipaste_2019-12-02_20-23-53.png","hash":"e23e98c6d6ad478922602312f4f5248cf723d61b","modified":1620789535181},{"_id":"source/_posts/【UE4】UE4使用蓝图动态修改粒子参数/Snipaste_2020-01-17_16-11-42.png","hash":"858fa9b93b186097b9657c664b7f778fe141670b","modified":1620789535181},{"_id":"source/_posts/【UE4】UE4使用蓝图动态修改粒子参数/Snipaste_2020-01-17_16-14-22.png","hash":"6b4644a146562ab1521e8ab59c1816bf2cb70075","modified":1620789535182},{"_id":"source/_posts/【UE4】UE4使用蓝图动态修改粒子参数/Snipaste_2020-01-17_16-32-09.png","hash":"c975265da28c99964a029ca07bc8b551877d6255","modified":1620789535182},{"_id":"source/_posts/【UE4】UE4使用蓝图动态修改粒子参数/Snipaste_2020-01-17_16-36-34.png","hash":"2e565c21ec7b163fb4ed9a3308e7f4150585caa3","modified":1620789535183},{"_id":"source/_posts/【UE4】UE4嵌入Web及与Web通信/Snipaste_2020-01-16_11-27-04.png","hash":"bbe4953732e911bf4915c32a637129dfe3d24910","modified":1620789535228},{"_id":"source/_posts/【UE4】UE4嵌入Web及与Web通信/Snipaste_2020-01-16_11-30-39.png","hash":"0c78e7c4ce98a368623714e77e1803804668c3ac","modified":1620789535228},{"_id":"source/_posts/【UE4】UE4嵌入Web及与Web通信/Snipaste_2020-01-16_11-32-49.png","hash":"5f84c73442b11f38dfbddebc3a97a7ab9963b078","modified":1620789535229},{"_id":"source/_posts/【UE4】UE4嵌入Web及与Web通信/Snipaste_2020-01-16_11-35-42.png","hash":"104188c44c30eaa0f3a8dda75ded9af7e9782a1c","modified":1620789535229},{"_id":"source/_posts/【UE4】UE4嵌入Web及与Web通信/Snipaste_2020-01-16_17-43-42.png","hash":"bcc133a67eb5bdd9a80abd3e7b782e67466f80e0","modified":1620789535232},{"_id":"source/_posts/【UE4】UE4嵌入Web及与Web通信/Snipaste_2020-01-16_18-22-57.png","hash":"00668bbc3ab0150406fabca6c95bd487bd370377","modified":1620789535234},{"_id":"source/_posts/【UE4】UE4嵌入Web及与Web通信/Snipaste_2020-01-16_18-23-16.png","hash":"3c7d49dd0a6dcf4d759873c5b064e951b626c51b","modified":1620789535234},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-07_17-43-04.png","hash":"a2961c7b5cc4a2e80e5f4c51cb72d7330547dbe7","modified":1620789535247},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-07_20-06-13.png","hash":"cade31da8b90a86db652e79e087f014454dba3ff","modified":1620789535249},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-08_16-58-04.png","hash":"329638fa188c3f608e260c7d15f05ac767fde7be","modified":1620789535259},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-08_17-35-49.png","hash":"bafa1cb31e95cca4a84ad084f40edd377fc4a88c","modified":1620789535265},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-08_15-43-04.png","hash":"9f470fa7a7cdf6ab2b404f8112bee8b09d6a51d2","modified":1620789535249},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-08_18-06-31.png","hash":"c366383ca3b8e85166e206d8fdca766fc0d1bab9","modified":1620789535269},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-08_15-41-32.png","hash":"745ae81389413a1c906b853987b200b534a2c202","modified":1620789535249},{"_id":"source/_posts/【UE4】UE4使用蓝图动态修改粒子参数/Snipaste_2020-01-17_16-41-30.png","hash":"d03116b0535f72fc30680fe791aa5dc4dc3c5e3f","modified":1620789535184},{"_id":"source/_posts/【UE4】UE4嵌入Web及与Web通信/Snipaste_2020-01-16_10-56-54.png","hash":"41df692e63687db8ed35341be6c58c9610cbb9f0","modified":1620789535228},{"_id":"source/_posts/【UE4】UE4嵌入Web及与Web通信/Snipaste_2020-01-16_14-03-48.png","hash":"1630db7506a5cbca8793cbc6812776cd80d6b4a2","modified":1620789535232},{"_id":"source/_posts/【UE4】UE4嵌入Web及与Web通信/Snipaste_2020-01-16_18-09-06.png","hash":"5f654fe9c8eeab95664da07b42e7550652ebccfb","modified":1620789535233},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-07_16-26-46.png","hash":"3e9abfe26f0ca25df5798f4287211b333301a98d","modified":1620789535242},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-07_18-06-58.png","hash":"ee74bea30953025c28b13374a80e4ee576a2cbd6","modified":1620789535248},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-08_16-58-54.png","hash":"bae4c447764e9d0d61e355da58110765f00241d0","modified":1620789535259},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-08_17-47-44.png","hash":"e076cf3bd27102f5a60aa5c6dc69698a3964afcc","modified":1620789535266},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-08_18-40-04.png","hash":"cd4d534e71dc5532cd471630051b758c1049c32d","modified":1620789535274},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-07_17-10-49.png","hash":"f9325873e4dd11fb635a536843ee369b0ddc25ba","modified":1620789535247},{"_id":"source/_posts/【BAT】BATWindows自动脚本同步GitHub远程仓库/Snipaste_2020-01-21_16-29-49.png","hash":"d67d0c670e0528f9694da99659ed7c867d092964","modified":1620789535174},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-08_16-08-15.png","hash":"2152144162c19af85255bd2b3921daf58115a399","modified":1620789535251},{"_id":"source/_posts/【UE4】UE4Socket编程/Snipaste_2019-12-01_19-00-42.png","hash":"819929ae5e4efa1a9022a82a0372b258a8fe60b9","modified":1620789535180},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-08_18-45-34.png","hash":"46a6d5de111fd2f536ba331b119164399e478018","modified":1620789535275},{"_id":"source/_posts/【UE4】UE4嵌入Web及与Web通信/Snipaste_2020-01-16_11-36-15.png","hash":"b76ea651b3108a248283797f9516769d64a9cc0f","modified":1620789535231},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-07_16-53-31.png","hash":"a1b551bdf6b798c251a60b3eace16512b4f8988c","modified":1620789535243},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-07_17-03-45.png","hash":"ad8209796d2cbd1dad668b91e09069b76f4de999","modified":1620789535246},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-08_16-58-00.png","hash":"b2693d0c9f95638d2c6738c3a2c322b408c27e3b","modified":1620789535258},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-08_18-00-16.png","hash":"30645fe98d6ecb30dc53a27ac6dec6b03ca189dc","modified":1620789535268},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-08_18-45-47.png","hash":"44743bcd97c90fe78d56810416f913071e0398e4","modified":1620789535277},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-08_16-26-18.png","hash":"086abf86239490e2d5f299ecafb2ac5a0d958537","modified":1620789535255},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-08_17-32-12.png","hash":"e253749bf2cad083ba85f323419881c2e3a19f36","modified":1620789535264},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-08_18-32-17.png","hash":"76baa7d928ec796fd5e0aa961a7a195ceac02c96","modified":1620789535273},{"_id":"source/_posts/【UE4】UE4使用蓝图动态修改粒子参数/Snipaste_2020-01-17_16-43-43.png","hash":"cb5c1d7800f29063d6c454d1cbe670e1c646401a","modified":1620789535187},{"_id":"source/_posts/【UE4】UE4使用蓝图动态修改粒子参数/Snipaste_2020-01-17_16-43-57.png","hash":"304313d78aab45fe76c91f4f57f612ac30646798","modified":1620789535190},{"_id":"source/_posts/【UE4】UE4使用蓝图动态修改粒子参数/Snipaste_2020-01-17_16-44-15.png","hash":"f295a3a59dabd830ec13a7dc2dd8d33a3b0f8c23","modified":1620789535193},{"_id":"public/2021/05/12/【UE4】UE4使用蓝图动态修改粒子参数/index.html","hash":"5bd4e0ad165fa0ad41c1d6e2aa9e035d74492a39","modified":1620983992431},{"_id":"public/2021/05/12/【BAT】BATWindows自动脚本同步GitHub远程仓库/index.html","hash":"10efda30e7fc8b61111f90c84ac560707e3096bc","modified":1620983992431},{"_id":"public/archives/2021/page/2/index.html","hash":"0bea952724e0931cc52beb00f7422a6ce5ea5544","modified":1620987064589},{"_id":"public/archives/2021/05/index.html","hash":"bff5703024a6866115eca30d463829efce3baf50","modified":1620987064589},{"_id":"public/2021/05/12/【UE4】UE4内嵌Web及与Web通信/index.html","hash":"30c2e2d44771b6d86444653e2ef825abc7e1cf6b","modified":1620983992431},{"_id":"public/2021/05/12/【UE4】UE4角色控制/index.html","hash":"23ebbded560b60b38a29f19c60b63773f6d4cefa","modified":1620983992431},{"_id":"public/2021/05/12/【UE4】UE4Socket编程/index.html","hash":"7d83f64d97edd0e969561cedbc342c6445086014","modified":1620983992431},{"_id":"public/2021/05/12/【BAT】BATWindows自动脚本同步GitHub远程仓库/Snipaste_2020-01-21_16-04-19.png","hash":"ce113ff6978c5e500cd80ecd7f7f91fa66dd7f1a","modified":1620983992431},{"_id":"public/2021/05/12/【UE4】UE4使用蓝图动态修改粒子参数/Snipaste_2020-01-17_16-11-42.png","hash":"858fa9b93b186097b9657c664b7f778fe141670b","modified":1620983992431},{"_id":"public/2021/05/12/【UE4】UE4使用蓝图动态修改粒子参数/Snipaste_2020-01-17_16-32-09.png","hash":"c975265da28c99964a029ca07bc8b551877d6255","modified":1620983992431},{"_id":"public/2021/05/12/【UE4】UE4Socket编程/Snipaste_2019-12-02_20-23-53.png","hash":"e23e98c6d6ad478922602312f4f5248cf723d61b","modified":1620983992431},{"_id":"public/2021/05/12/【UE4】UE4使用蓝图动态修改粒子参数/Snipaste_2020-01-17_16-14-22.png","hash":"6b4644a146562ab1521e8ab59c1816bf2cb70075","modified":1620983992431},{"_id":"public/2021/05/12/【UE4】UE4使用蓝图动态修改粒子参数/Snipaste_2020-01-17_16-36-34.png","hash":"2e565c21ec7b163fb4ed9a3308e7f4150585caa3","modified":1620983992431},{"_id":"public/2021/05/12/【UE4】UE4角色控制/Snipaste_2019-12-07_20-06-13.png","hash":"cade31da8b90a86db652e79e087f014454dba3ff","modified":1620983992431},{"_id":"public/2021/05/12/【UE4】UE4角色控制/Snipaste_2019-12-07_17-43-04.png","hash":"a2961c7b5cc4a2e80e5f4c51cb72d7330547dbe7","modified":1620983992431},{"_id":"public/2021/05/12/【UE4】UE4角色控制/Snipaste_2019-12-08_15-41-32.png","hash":"745ae81389413a1c906b853987b200b534a2c202","modified":1620983992431},{"_id":"public/2021/05/12/【UE4】UE4角色控制/Snipaste_2019-12-08_15-43-04.png","hash":"9f470fa7a7cdf6ab2b404f8112bee8b09d6a51d2","modified":1620983992431},{"_id":"public/2021/05/12/【UE4】UE4角色控制/Snipaste_2019-12-08_16-58-04.png","hash":"329638fa188c3f608e260c7d15f05ac767fde7be","modified":1620983992431},{"_id":"public/2021/05/12/【UE4】UE4角色控制/Snipaste_2019-12-08_17-35-49.png","hash":"bafa1cb31e95cca4a84ad084f40edd377fc4a88c","modified":1620983992431},{"_id":"public/2021/05/12/【UE4】UE4角色控制/Snipaste_2019-12-08_18-06-31.png","hash":"c366383ca3b8e85166e206d8fdca766fc0d1bab9","modified":1620983992431},{"_id":"public/2021/05/12/【UE4】UE4使用蓝图动态修改粒子参数/Snipaste_2020-01-17_16-41-30.png","hash":"d03116b0535f72fc30680fe791aa5dc4dc3c5e3f","modified":1620983992431},{"_id":"public/2021/05/12/【UE4】UE4角色控制/Snipaste_2019-12-07_16-26-46.png","hash":"3e9abfe26f0ca25df5798f4287211b333301a98d","modified":1620983992431},{"_id":"public/2021/05/12/【UE4】UE4角色控制/Snipaste_2019-12-07_18-06-58.png","hash":"ee74bea30953025c28b13374a80e4ee576a2cbd6","modified":1620983992431},{"_id":"public/2021/05/12/【UE4】UE4角色控制/Snipaste_2019-12-08_16-58-54.png","hash":"bae4c447764e9d0d61e355da58110765f00241d0","modified":1620983992431},{"_id":"public/2021/05/12/【UE4】UE4角色控制/Snipaste_2019-12-08_17-47-44.png","hash":"e076cf3bd27102f5a60aa5c6dc69698a3964afcc","modified":1620983992431},{"_id":"public/2021/05/12/【UE4】UE4角色控制/Snipaste_2019-12-08_18-40-04.png","hash":"cd4d534e71dc5532cd471630051b758c1049c32d","modified":1620983992431},{"_id":"public/2021/05/12/【UE4】UE4Socket编程/Snipaste_2019-12-01_19-00-42.png","hash":"819929ae5e4efa1a9022a82a0372b258a8fe60b9","modified":1620983992431},{"_id":"public/2021/05/12/【BAT】BATWindows自动脚本同步GitHub远程仓库/Snipaste_2020-01-21_16-29-49.png","hash":"d67d0c670e0528f9694da99659ed7c867d092964","modified":1620983992431},{"_id":"public/2021/05/12/【UE4】UE4角色控制/Snipaste_2019-12-07_17-10-49.png","hash":"f9325873e4dd11fb635a536843ee369b0ddc25ba","modified":1620983992431},{"_id":"public/2021/05/12/【UE4】UE4角色控制/Snipaste_2019-12-08_16-08-15.png","hash":"2152144162c19af85255bd2b3921daf58115a399","modified":1620983992431},{"_id":"public/2021/05/12/【UE4】UE4角色控制/Snipaste_2019-12-08_18-45-34.png","hash":"46a6d5de111fd2f536ba331b119164399e478018","modified":1620983992431},{"_id":"public/2021/05/12/【UE4】UE4角色控制/Snipaste_2019-12-08_18-45-47.png","hash":"44743bcd97c90fe78d56810416f913071e0398e4","modified":1620983992431},{"_id":"public/2021/05/12/【UE4】UE4角色控制/Snipaste_2019-12-07_16-53-31.png","hash":"a1b551bdf6b798c251a60b3eace16512b4f8988c","modified":1620983992431},{"_id":"public/2021/05/12/【UE4】UE4角色控制/Snipaste_2019-12-07_17-03-45.png","hash":"ad8209796d2cbd1dad668b91e09069b76f4de999","modified":1620983992431},{"_id":"public/2021/05/12/【UE4】UE4角色控制/Snipaste_2019-12-08_16-58-00.png","hash":"b2693d0c9f95638d2c6738c3a2c322b408c27e3b","modified":1620983992431},{"_id":"public/2021/05/12/【UE4】UE4角色控制/Snipaste_2019-12-08_18-00-16.png","hash":"30645fe98d6ecb30dc53a27ac6dec6b03ca189dc","modified":1620983992431},{"_id":"public/2021/05/12/【UE4】UE4角色控制/Snipaste_2019-12-08_16-26-18.png","hash":"086abf86239490e2d5f299ecafb2ac5a0d958537","modified":1620983992431},{"_id":"public/2021/05/12/【UE4】UE4角色控制/Snipaste_2019-12-08_17-32-12.png","hash":"e253749bf2cad083ba85f323419881c2e3a19f36","modified":1620983992431},{"_id":"public/2021/05/12/【UE4】UE4角色控制/Snipaste_2019-12-08_18-32-17.png","hash":"76baa7d928ec796fd5e0aa961a7a195ceac02c96","modified":1620983992431},{"_id":"public/2021/05/12/【UE4】UE4使用蓝图动态修改粒子参数/Snipaste_2020-01-17_16-43-57.png","hash":"304313d78aab45fe76c91f4f57f612ac30646798","modified":1620983992431},{"_id":"public/2021/05/12/【UE4】UE4使用蓝图动态修改粒子参数/Snipaste_2020-01-17_16-44-15.png","hash":"f295a3a59dabd830ec13a7dc2dd8d33a3b0f8c23","modified":1620983992431},{"_id":"public/2021/05/12/【UE4】UE4使用蓝图动态修改粒子参数/Snipaste_2020-01-17_16-43-43.png","hash":"cb5c1d7800f29063d6c454d1cbe670e1c646401a","modified":1620983992431},{"_id":"source/_posts/【BAT】BATWindows自动脚本同步GitHUb远程仓库.md","hash":"78ac219389d88ff7b6fed0265062a73ef15f19ca","modified":1620984656982},{"_id":"public/2021/05/14/【BAT】BATWindows自动脚本同步GitHUb远程仓库/index.html","hash":"d112f6b3ba2f4e5ebd52ef901e2d85d84600051f","modified":1620987064589},{"_id":"public/2021/05/14/【UE4】UE4使用蓝图动态修改粒子参数/index.html","hash":"c5d3999b4b61634dbbd86933641295d3e32c2af6","modified":1620984912072},{"_id":"public/2021/05/14/【UE4】UE4内嵌Web及与Web通信/index.html","hash":"3fa9e1838513ee9a4ecfd3b58143d1546fa2d330","modified":1620984912072},{"_id":"public/2021/05/14/【UE4】UE4角色控制/index.html","hash":"a9a2dfe0266a52b6d246b6dc077d8963a853fffb","modified":1620984912072},{"_id":"public/2021/05/14/【UE4】UE4Socket编程/index.html","hash":"61e42ed9d5ba7241bd19898ee39852dbbd232c59","modified":1620984912072},{"_id":"public/2021/05/14/【BAT】BATWindows自动脚本同步GitHUb远程仓库/Snipaste_2020-01-21_16-04-19.png","hash":"ce113ff6978c5e500cd80ecd7f7f91fa66dd7f1a","modified":1620984912072},{"_id":"public/2021/05/14/【UE4】UE4使用蓝图动态修改粒子参数/Snipaste_2020-01-17_16-11-42.png","hash":"858fa9b93b186097b9657c664b7f778fe141670b","modified":1620984912072},{"_id":"public/2021/05/14/【UE4】UE4使用蓝图动态修改粒子参数/Snipaste_2020-01-17_16-14-22.png","hash":"6b4644a146562ab1521e8ab59c1816bf2cb70075","modified":1620984912072},{"_id":"public/2021/05/14/【UE4】UE4使用蓝图动态修改粒子参数/Snipaste_2020-01-17_16-32-09.png","hash":"c975265da28c99964a029ca07bc8b551877d6255","modified":1620984912072},{"_id":"public/2021/05/14/【UE4】UE4使用蓝图动态修改粒子参数/Snipaste_2020-01-17_16-36-34.png","hash":"2e565c21ec7b163fb4ed9a3308e7f4150585caa3","modified":1620984912072},{"_id":"public/2021/05/14/【UE4】UE4Socket编程/Snipaste_2019-12-02_20-23-53.png","hash":"e23e98c6d6ad478922602312f4f5248cf723d61b","modified":1620984912072},{"_id":"public/2021/05/14/【UE4】UE4角色控制/Snipaste_2019-12-07_17-43-04.png","hash":"a2961c7b5cc4a2e80e5f4c51cb72d7330547dbe7","modified":1620984912072},{"_id":"public/2021/05/14/【UE4】UE4角色控制/Snipaste_2019-12-08_15-41-32.png","hash":"745ae81389413a1c906b853987b200b534a2c202","modified":1620984912072},{"_id":"public/2021/05/14/【UE4】UE4角色控制/Snipaste_2019-12-07_20-06-13.png","hash":"cade31da8b90a86db652e79e087f014454dba3ff","modified":1620984912072},{"_id":"public/2021/05/14/【UE4】UE4角色控制/Snipaste_2019-12-08_15-43-04.png","hash":"9f470fa7a7cdf6ab2b404f8112bee8b09d6a51d2","modified":1620984912072},{"_id":"public/2021/05/14/【UE4】UE4角色控制/Snipaste_2019-12-08_16-58-04.png","hash":"329638fa188c3f608e260c7d15f05ac767fde7be","modified":1620984912072},{"_id":"public/2021/05/14/【UE4】UE4角色控制/Snipaste_2019-12-08_17-35-49.png","hash":"bafa1cb31e95cca4a84ad084f40edd377fc4a88c","modified":1620984912072},{"_id":"public/2021/05/14/【UE4】UE4角色控制/Snipaste_2019-12-08_18-06-31.png","hash":"c366383ca3b8e85166e206d8fdca766fc0d1bab9","modified":1620984912072},{"_id":"public/2021/05/14/【UE4】UE4使用蓝图动态修改粒子参数/Snipaste_2020-01-17_16-41-30.png","hash":"d03116b0535f72fc30680fe791aa5dc4dc3c5e3f","modified":1620984912072},{"_id":"public/2021/05/14/【UE4】UE4角色控制/Snipaste_2019-12-07_16-26-46.png","hash":"3e9abfe26f0ca25df5798f4287211b333301a98d","modified":1620984912072},{"_id":"public/2021/05/14/【UE4】UE4角色控制/Snipaste_2019-12-07_18-06-58.png","hash":"ee74bea30953025c28b13374a80e4ee576a2cbd6","modified":1620984912072},{"_id":"public/2021/05/14/【UE4】UE4角色控制/Snipaste_2019-12-08_16-58-54.png","hash":"bae4c447764e9d0d61e355da58110765f00241d0","modified":1620984912072},{"_id":"public/2021/05/14/【UE4】UE4角色控制/Snipaste_2019-12-08_17-47-44.png","hash":"e076cf3bd27102f5a60aa5c6dc69698a3964afcc","modified":1620984912072},{"_id":"public/2021/05/14/【UE4】UE4角色控制/Snipaste_2019-12-08_18-40-04.png","hash":"cd4d534e71dc5532cd471630051b758c1049c32d","modified":1620984912072},{"_id":"public/2021/05/14/【BAT】BATWindows自动脚本同步GitHUb远程仓库/Snipaste_2020-01-21_16-29-49.png","hash":"d67d0c670e0528f9694da99659ed7c867d092964","modified":1620984912072},{"_id":"public/2021/05/14/【UE4】UE4Socket编程/Snipaste_2019-12-01_19-00-42.png","hash":"819929ae5e4efa1a9022a82a0372b258a8fe60b9","modified":1620984912072},{"_id":"public/2021/05/14/【UE4】UE4角色控制/Snipaste_2019-12-07_17-10-49.png","hash":"f9325873e4dd11fb635a536843ee369b0ddc25ba","modified":1620984912072},{"_id":"public/2021/05/14/【UE4】UE4角色控制/Snipaste_2019-12-08_16-08-15.png","hash":"2152144162c19af85255bd2b3921daf58115a399","modified":1620984912072},{"_id":"public/2021/05/14/【UE4】UE4角色控制/Snipaste_2019-12-08_18-45-34.png","hash":"46a6d5de111fd2f536ba331b119164399e478018","modified":1620984912072},{"_id":"public/2021/05/14/【UE4】UE4角色控制/Snipaste_2019-12-08_18-45-47.png","hash":"44743bcd97c90fe78d56810416f913071e0398e4","modified":1620984912072},{"_id":"public/2021/05/14/【UE4】UE4角色控制/Snipaste_2019-12-07_16-53-31.png","hash":"a1b551bdf6b798c251a60b3eace16512b4f8988c","modified":1620984912072},{"_id":"public/2021/05/14/【UE4】UE4角色控制/Snipaste_2019-12-07_17-03-45.png","hash":"ad8209796d2cbd1dad668b91e09069b76f4de999","modified":1620984912072},{"_id":"public/2021/05/14/【UE4】UE4角色控制/Snipaste_2019-12-08_16-58-00.png","hash":"b2693d0c9f95638d2c6738c3a2c322b408c27e3b","modified":1620984912072},{"_id":"public/2021/05/14/【UE4】UE4角色控制/Snipaste_2019-12-08_18-00-16.png","hash":"30645fe98d6ecb30dc53a27ac6dec6b03ca189dc","modified":1620984912072},{"_id":"public/2021/05/14/【UE4】UE4角色控制/Snipaste_2019-12-08_16-26-18.png","hash":"086abf86239490e2d5f299ecafb2ac5a0d958537","modified":1620984912072},{"_id":"public/2021/05/14/【UE4】UE4角色控制/Snipaste_2019-12-08_17-32-12.png","hash":"e253749bf2cad083ba85f323419881c2e3a19f36","modified":1620984912072},{"_id":"public/2021/05/14/【UE4】UE4角色控制/Snipaste_2019-12-08_18-32-17.png","hash":"76baa7d928ec796fd5e0aa961a7a195ceac02c96","modified":1620984912072},{"_id":"public/2021/05/14/【UE4】UE4使用蓝图动态修改粒子参数/Snipaste_2020-01-17_16-43-43.png","hash":"cb5c1d7800f29063d6c454d1cbe670e1c646401a","modified":1620984912072},{"_id":"public/2021/05/14/【UE4】UE4使用蓝图动态修改粒子参数/Snipaste_2020-01-17_16-44-15.png","hash":"f295a3a59dabd830ec13a7dc2dd8d33a3b0f8c23","modified":1620984912072},{"_id":"public/2021/05/14/【UE4】UE4使用蓝图动态修改粒子参数/Snipaste_2020-01-17_16-43-57.png","hash":"304313d78aab45fe76c91f4f57f612ac30646798","modified":1620984912072},{"_id":"source/_posts/【UE4】UE4基于Spline的测距功能.md","hash":"7337fdf42c138e18efd4122247c2977e447c82dd","modified":1620986778302},{"_id":"source/_posts/【UE4】UE4实现自定义框选.md","hash":"8371754f8e996f53176010fbebcd0d794dacc379","modified":1620987016140},{"_id":"public/2021/05/14/【UE4】UE4实现自定义框选/index.html","hash":"c94dacbab5a8e47cf0a0a0fecf844846f60d2cf5","modified":1620987064589},{"_id":"public/2021/05/14/【UE4】UE4基于Spline的测距功能/index.html","hash":"a13b01dd255e94cfd6f34e1311ac450c49d8773e","modified":1620987064589}],"Category":[{"name":"学习笔记","_id":"ckk9hocae0002dwr72kfc6kt2"},{"name":"知识记录","_id":"ckk9hocah0007dwr747zbhgqj"},{"name":"待解决","_id":"ckk9hocb30023dwr71fa3gojs"},{"name":"日记","_id":"ckk9hocb60029dwr73v0w6kmf"}],"Data":[],"Page":[],"Post":[{"title":"C#中级","date":"2019-08-25T07:48:58.000Z","_content":"\n﻿![在这里插入图片描述](https://img-blog.csdnimg.cn/20190825154217891.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n","source":"_posts/【C#】C#中级.md","raw":"---\ntitle: C#中级\ndate: 2019-08-25 15:48:58\ntags: C#\ncategories: 学习笔记\n---\n\n﻿![在这里插入图片描述](https://img-blog.csdnimg.cn/20190825154217891.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n","slug":"【C#】C#中级","published":1,"updated":"2019-11-18T07:25:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckk9hoca90000dwr79kkt1xys","content":"<p>﻿<img src=\"https://img-blog.csdnimg.cn/20190825154217891.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>﻿<img src=\"https://img-blog.csdnimg.cn/20190825154217891.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n"},{"title":"【C#】C#两种二维数组的区别","date":"2019-09-11T02:43:50.000Z","_content":"\nC#支持两种二维数组的定义方式（以int数组为例）：\n\n# 1.普通数组\n\n```c#\nint[,] array = new int[1,2];\n```\n\n这种方式形式上较为简便，要注意的是new之后的[]里面是一定要注明数组大小的，不注明会报错，也就是说这种方式定义的数组是确定大小的。\n\n数组的赋值：\n\n```c#\nint[,] array = new int[2,3]{{1,2,3},{4,5,6}};\n```\n\n# 2.多播数组\n\n```c#\nint[][] array = new int[2][];\n```\n\n这种方式需要注明行数，列数不能注明，注明会报错，这种方式定义的是一个函数确定而列数不确定的不确定大小的数组。\n\n数组的赋值：\n\n```c#\nint[][] array = new int[2][]{new int[]{1,2,3},new int[]{4,5,6}}\n```\n\n\n\n两种二维数组是不能兼容的，即使用方式1定义的二维数组不能使用方式2来使用，反之亦然。\n\n","source":"_posts/【C#】C#两种数组定义的区别.md","raw":"---\ntitle: 【C#】C#两种二维数组的区别\ndate: 2019-09-11 10:43:50\ntags: C#\ncategories: 知识记录\n---\n\nC#支持两种二维数组的定义方式（以int数组为例）：\n\n# 1.普通数组\n\n```c#\nint[,] array = new int[1,2];\n```\n\n这种方式形式上较为简便，要注意的是new之后的[]里面是一定要注明数组大小的，不注明会报错，也就是说这种方式定义的数组是确定大小的。\n\n数组的赋值：\n\n```c#\nint[,] array = new int[2,3]{{1,2,3},{4,5,6}};\n```\n\n# 2.多播数组\n\n```c#\nint[][] array = new int[2][];\n```\n\n这种方式需要注明行数，列数不能注明，注明会报错，这种方式定义的是一个函数确定而列数不确定的不确定大小的数组。\n\n数组的赋值：\n\n```c#\nint[][] array = new int[2][]{new int[]{1,2,3},new int[]{4,5,6}}\n```\n\n\n\n两种二维数组是不能兼容的，即使用方式1定义的二维数组不能使用方式2来使用，反之亦然。\n\n","slug":"【C#】C#两种数组定义的区别","published":1,"updated":"2019-11-18T07:25:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckk9hocac0001dwr7gfqlepzz","content":"<p>C#支持两种二维数组的定义方式（以int数组为例）：</p>\n<h1 id=\"1-普通数组\"><a href=\"#1-普通数组\" class=\"headerlink\" title=\"1.普通数组\"></a>1.普通数组</h1><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c#\"><span class=\"hljs-built_in\">int</span>[,] array = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>];<br></code></pre></td></tr></table></figure>\n<p>这种方式形式上较为简便，要注意的是new之后的[]里面是一定要注明数组大小的，不注明会报错，也就是说这种方式定义的数组是确定大小的。</p>\n<p>数组的赋值：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c#\"><span class=\"hljs-built_in\">int</span>[,] array = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>[<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>]&#123;&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>&#125;,&#123;<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>&#125;&#125;;<br></code></pre></td></tr></table></figure>\n<h1 id=\"2-多播数组\"><a href=\"#2-多播数组\" class=\"headerlink\" title=\"2.多播数组\"></a>2.多播数组</h1><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c#\"><span class=\"hljs-built_in\">int</span>[][] array = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>[<span class=\"hljs-number\">2</span>][];<br></code></pre></td></tr></table></figure>\n<p>这种方式需要注明行数，列数不能注明，注明会报错，这种方式定义的是一个函数确定而列数不确定的不确定大小的数组。</p>\n<p>数组的赋值：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c#\"><span class=\"hljs-built_in\">int</span>[][] array = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>[<span class=\"hljs-number\">2</span>][]&#123;<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>[]&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>&#125;,<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>[]&#123;<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>&#125;&#125;<br></code></pre></td></tr></table></figure>\n\n\n<p>两种二维数组是不能兼容的，即使用方式1定义的二维数组不能使用方式2来使用，反之亦然。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>C#支持两种二维数组的定义方式（以int数组为例）：</p>\n<h1 id=\"1-普通数组\"><a href=\"#1-普通数组\" class=\"headerlink\" title=\"1.普通数组\"></a>1.普通数组</h1><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c#\"><span class=\"hljs-built_in\">int</span>[,] array = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>];<br></code></pre></td></tr></table></figure>\n<p>这种方式形式上较为简便，要注意的是new之后的[]里面是一定要注明数组大小的，不注明会报错，也就是说这种方式定义的数组是确定大小的。</p>\n<p>数组的赋值：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c#\"><span class=\"hljs-built_in\">int</span>[,] array = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>[<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>]&#123;&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>&#125;,&#123;<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>&#125;&#125;;<br></code></pre></td></tr></table></figure>\n<h1 id=\"2-多播数组\"><a href=\"#2-多播数组\" class=\"headerlink\" title=\"2.多播数组\"></a>2.多播数组</h1><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c#\"><span class=\"hljs-built_in\">int</span>[][] array = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>[<span class=\"hljs-number\">2</span>][];<br></code></pre></td></tr></table></figure>\n<p>这种方式需要注明行数，列数不能注明，注明会报错，这种方式定义的是一个函数确定而列数不确定的不确定大小的数组。</p>\n<p>数组的赋值：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c#\"><span class=\"hljs-built_in\">int</span>[][] array = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>[<span class=\"hljs-number\">2</span>][]&#123;<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>[]&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>&#125;,<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>[]&#123;<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>&#125;&#125;<br></code></pre></td></tr></table></figure>\n\n\n<p>两种二维数组是不能兼容的，即使用方式1定义的二维数组不能使用方式2来使用，反之亦然。</p>\n"},{"title":"C#高级","date":"2019-08-25T10:00:25.000Z","_content":"\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190825170050917.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190825170113521.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190825170131207.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n","source":"_posts/【C#】C#高级.md","raw":"---\ntitle: C#高级\ndate: 2019-08-25 18:00:25\ntags: C#\ncategories: 学习笔记\n---\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190825170050917.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190825170113521.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190825170131207.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n","slug":"【C#】C#高级","published":1,"updated":"2019-11-18T07:25:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckk9hocaf0004dwr7c2d95mo6","content":"<p><img src=\"https://img-blog.csdnimg.cn/20190825170050917.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/20190825170113521.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190825170131207.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://img-blog.csdnimg.cn/20190825170050917.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/20190825170113521.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190825170131207.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n"},{"title":"【C++】C++中的四种个智能指针.md","date":"2019-10-08T14:24:31.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n智能指针的出现的目的就是为了解决c++中出现异常安全资源管理问题，智能指针的实现原理是依据RAII机制(Resource Acquisition Is Initialization)，这是的智能指针本质上是一个对象，行为表现上是一个指针。\n\n智能指针都是类模板使用时是必须指定类型参数的，如：`auto_ptr<int> ptr`\n\n# 1.auto_ptr\n\n- auto_ptr采用所有权的模式，指针内不做引用计数，因此一个对象只能由一个auto_ptr指针所拥有，在给其他auto_ptr指针赋值时，所有权会转移\n- auto_ptr中使用delete来释放资源，所以auto_ptr不能指向数组，因为数组的释放使用的是delete[]\n- auto_ptr指针的判空使用auto_ptr.get()==NULL来判断\n\nauto_ptr是C++98中的标准，在C++11中已经被弃用。\n\nauto_ptr由于是所有权模式，所在在auto_ptr做参数时，会转移所有权，即将函数外的auto_ptr的所有权转义给函数内的auto_ptr的所有权，如果函数内不做所有权转移的话，函数外的auto_ptr将变为空指针，而导致引用出错。如：\n\n**不转移所有权**\n\n```C++\nvoid Test(auto_ptr<int> apt)\n{\n\tcout << *apt << endl;\n\treturn apt;\n}\n\nint main()\n{\n\tauto_ptr<int> ptr(new int(1));\n\tTest(ptr);\n\tif (ptr.get() == NULL)\n\t\tcout << \"NULL\" << endl;\n\telse\n\t\tcout << \"NO NULL\" << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**输出结果：**\n\n```\n1\nNULL\n```\n\n**转移所有权**\n\n```C++\nauto_ptr<int> Test(auto_ptr<int> apt)\n{\n\tcout << *apt << endl;\n\treturn apt;\n}\n\nint main()\n{\n\tauto_ptr<int> ptr(new int(1));\n\tptr = Test(ptr);\n\tif (ptr.get() == NULL)\n\t\tcout << \"NULL\" << endl;\n\telse\n\t\tcout << \"NO NULL\" << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**输出结果：**\n\n```\n1\nNO NULL\n```\n\n# 2.unique_ptr\n\n- unique_ptr是C++11中对C++98中的auto_ptr的替换与强化\n\n- unique_ptr也是使用独占所有权模式，即一个unique_ptr指针指向一个对象后，不可以在把这个对象赋予给另一个unique_ptr指针，后来出于一些考虑C++又提供了srd::move()函数来做所有权的移交，被移交所有权的unique_ptr指针会指向空，这时再使用这个指针就会报错\n- unique_ptr指针支持直接使用==判空，如：\n\n```C++\nunique_ptr<int> ptr;\nif(ptr == NULL)\n\tcout<<\"NULL\"<<endl;\n```\n\n当然unique_ptr依旧支持unique_ptr.get()==NULL来判空。\n\n- 当unique_ptr作为实参进行传递时，必须使用std::move()来移交所有权，这是unique_ptr的独占所有权性质决定的。如：\n\n```C++\nvoid Test(unique_ptr<int> apt)\n{\n\tcout << *apt << endl;\n}\n\nint main()\n{\n\tunique_ptr<int> ptr(new int(1));\n\tunique_ptr<int> pt = move(ptr);\n\tTest(std::move(ptr));\n\tif (ptr == NULL)\n\t\tcout << \"NULL\" << endl;\n\telse\n\t\tcout << \"NO NULL\" << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n# 3.shared_ptr\n\n- shared_ptr指针支持一个对象被多个指针指向\n\n- shared_ptr使用计数机制来记录对象被多少个shared_ptr指针所指向，可以使用share_ptr.reset()函数来释放当前指针，对象的引用计数减一，当引用计数减为0时，释放对象资源\n- 可以使用shared_ptr.use_count()来获取当前对象的引用计数\n\n我们来看一个例子：\n\n```C++\nvoid Test(shared_ptr<int> ptr)\n{\n\tcout << \"count_1:\"<< ptr.use_count() << endl;\n}\n\nint main()\n{\n\tshared_ptr<int> ptr(new int(1));\n\tshared_ptr<int> pt = ptr;\n\tTest(ptr);\n\tpt.reset();\n\tcout << \"count_2:\"<< ptr.use_count() << endl;\n\tif (ptr == NULL)\n\t\tcout << \"NULL\" << endl;\n\telse\n\t\tcout << \"NO NULL\" << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**输出结果：**\n\n```\ncount_1:3\ncount_2:1\nNO NULL\n```\n\n咦！为什么引用计数count_1是3呢？这是因为在函数内形参`shared_ptr<int> ptr`也指向了同一个对象。而当函数Test结束形参指针释放，同时又使用reset()函数释放pt指针，所以count_2:1\n\n# 4.weak_ptr\n\n虽然shared_ptr使用起来更接近C的原生指针，但是当shared_ptr指针作为类成员时，可能会出现互相引用的而形成死锁，导致引用计数永远无法将为0的现象，如：\n\n```C++\nclass B;\nclass A\n{\npublic:\n\tshared_ptr<B> pa;\n};\nclass B\n{\npublic:\n\tshared_ptr<A> pb;\n};\nint main()\n{\n\tshared_ptr<A> pa(new A());\n\tshared_ptr<B> pb(new B());\n\tpa->pa = pb;\n\tpb->pb = pa;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n这种情况是，pa是指向A类型的shared_ptr指针指向A类型对象，而pa指向的内存里面又有一个shared_ptr指针指向B类型对象，同理pb也是如此，这样就导致，当A要被释放时，要先释放B，而B要释放时又要先释放A，如此便形成了一个互相等待的死循环。weak_ptr的存在就是为了解决这种问题。\n\nweak_ptr指针是一种弱引用，它指向对象和释放时不会引起引用计数的变化，这样便可以打破shared_ptr的这种死循环了，我们将上面的代码改成如下，就可以解死循环了。\n\n```C++\nclass B;\nclass A\n{\npublic:\n\tweak_ptr<B> pa;\n};\nclass B\n{\npublic:\n\tshared_ptr<A> pb;\n};\nint main()\n{\n\tshared_ptr<A> pa(new A());\n\tshared_ptr<B> pb(new B());\n\tpa->pa = pb;\n\tpb->pb = pa;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```","source":"_posts/【C++】C++中的四种个智能指针.md","raw":"---\ntitle: 【C++】C++中的四种个智能指针.md\ndate: 2019-10-08 22:24:31\ntags: CPlus\ncategories: 知识记录\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n智能指针的出现的目的就是为了解决c++中出现异常安全资源管理问题，智能指针的实现原理是依据RAII机制(Resource Acquisition Is Initialization)，这是的智能指针本质上是一个对象，行为表现上是一个指针。\n\n智能指针都是类模板使用时是必须指定类型参数的，如：`auto_ptr<int> ptr`\n\n# 1.auto_ptr\n\n- auto_ptr采用所有权的模式，指针内不做引用计数，因此一个对象只能由一个auto_ptr指针所拥有，在给其他auto_ptr指针赋值时，所有权会转移\n- auto_ptr中使用delete来释放资源，所以auto_ptr不能指向数组，因为数组的释放使用的是delete[]\n- auto_ptr指针的判空使用auto_ptr.get()==NULL来判断\n\nauto_ptr是C++98中的标准，在C++11中已经被弃用。\n\nauto_ptr由于是所有权模式，所在在auto_ptr做参数时，会转移所有权，即将函数外的auto_ptr的所有权转义给函数内的auto_ptr的所有权，如果函数内不做所有权转移的话，函数外的auto_ptr将变为空指针，而导致引用出错。如：\n\n**不转移所有权**\n\n```C++\nvoid Test(auto_ptr<int> apt)\n{\n\tcout << *apt << endl;\n\treturn apt;\n}\n\nint main()\n{\n\tauto_ptr<int> ptr(new int(1));\n\tTest(ptr);\n\tif (ptr.get() == NULL)\n\t\tcout << \"NULL\" << endl;\n\telse\n\t\tcout << \"NO NULL\" << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**输出结果：**\n\n```\n1\nNULL\n```\n\n**转移所有权**\n\n```C++\nauto_ptr<int> Test(auto_ptr<int> apt)\n{\n\tcout << *apt << endl;\n\treturn apt;\n}\n\nint main()\n{\n\tauto_ptr<int> ptr(new int(1));\n\tptr = Test(ptr);\n\tif (ptr.get() == NULL)\n\t\tcout << \"NULL\" << endl;\n\telse\n\t\tcout << \"NO NULL\" << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**输出结果：**\n\n```\n1\nNO NULL\n```\n\n# 2.unique_ptr\n\n- unique_ptr是C++11中对C++98中的auto_ptr的替换与强化\n\n- unique_ptr也是使用独占所有权模式，即一个unique_ptr指针指向一个对象后，不可以在把这个对象赋予给另一个unique_ptr指针，后来出于一些考虑C++又提供了srd::move()函数来做所有权的移交，被移交所有权的unique_ptr指针会指向空，这时再使用这个指针就会报错\n- unique_ptr指针支持直接使用==判空，如：\n\n```C++\nunique_ptr<int> ptr;\nif(ptr == NULL)\n\tcout<<\"NULL\"<<endl;\n```\n\n当然unique_ptr依旧支持unique_ptr.get()==NULL来判空。\n\n- 当unique_ptr作为实参进行传递时，必须使用std::move()来移交所有权，这是unique_ptr的独占所有权性质决定的。如：\n\n```C++\nvoid Test(unique_ptr<int> apt)\n{\n\tcout << *apt << endl;\n}\n\nint main()\n{\n\tunique_ptr<int> ptr(new int(1));\n\tunique_ptr<int> pt = move(ptr);\n\tTest(std::move(ptr));\n\tif (ptr == NULL)\n\t\tcout << \"NULL\" << endl;\n\telse\n\t\tcout << \"NO NULL\" << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n# 3.shared_ptr\n\n- shared_ptr指针支持一个对象被多个指针指向\n\n- shared_ptr使用计数机制来记录对象被多少个shared_ptr指针所指向，可以使用share_ptr.reset()函数来释放当前指针，对象的引用计数减一，当引用计数减为0时，释放对象资源\n- 可以使用shared_ptr.use_count()来获取当前对象的引用计数\n\n我们来看一个例子：\n\n```C++\nvoid Test(shared_ptr<int> ptr)\n{\n\tcout << \"count_1:\"<< ptr.use_count() << endl;\n}\n\nint main()\n{\n\tshared_ptr<int> ptr(new int(1));\n\tshared_ptr<int> pt = ptr;\n\tTest(ptr);\n\tpt.reset();\n\tcout << \"count_2:\"<< ptr.use_count() << endl;\n\tif (ptr == NULL)\n\t\tcout << \"NULL\" << endl;\n\telse\n\t\tcout << \"NO NULL\" << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**输出结果：**\n\n```\ncount_1:3\ncount_2:1\nNO NULL\n```\n\n咦！为什么引用计数count_1是3呢？这是因为在函数内形参`shared_ptr<int> ptr`也指向了同一个对象。而当函数Test结束形参指针释放，同时又使用reset()函数释放pt指针，所以count_2:1\n\n# 4.weak_ptr\n\n虽然shared_ptr使用起来更接近C的原生指针，但是当shared_ptr指针作为类成员时，可能会出现互相引用的而形成死锁，导致引用计数永远无法将为0的现象，如：\n\n```C++\nclass B;\nclass A\n{\npublic:\n\tshared_ptr<B> pa;\n};\nclass B\n{\npublic:\n\tshared_ptr<A> pb;\n};\nint main()\n{\n\tshared_ptr<A> pa(new A());\n\tshared_ptr<B> pb(new B());\n\tpa->pa = pb;\n\tpb->pb = pa;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n这种情况是，pa是指向A类型的shared_ptr指针指向A类型对象，而pa指向的内存里面又有一个shared_ptr指针指向B类型对象，同理pb也是如此，这样就导致，当A要被释放时，要先释放B，而B要释放时又要先释放A，如此便形成了一个互相等待的死循环。weak_ptr的存在就是为了解决这种问题。\n\nweak_ptr指针是一种弱引用，它指向对象和释放时不会引起引用计数的变化，这样便可以打破shared_ptr的这种死循环了，我们将上面的代码改成如下，就可以解死循环了。\n\n```C++\nclass B;\nclass A\n{\npublic:\n\tweak_ptr<B> pa;\n};\nclass B\n{\npublic:\n\tshared_ptr<A> pb;\n};\nint main()\n{\n\tshared_ptr<A> pa(new A());\n\tshared_ptr<B> pb(new B());\n\tpa->pa = pb;\n\tpb->pb = pa;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```","slug":"【C++】C++中的四种个智能指针","published":1,"updated":"2021-03-17T07:18:43.685Z","_id":"ckk9hocag0005dwr7b9b63nqp","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p>智能指针的出现的目的就是为了解决c++中出现异常安全资源管理问题，智能指针的实现原理是依据RAII机制(Resource Acquisition Is Initialization)，这是的智能指针本质上是一个对象，行为表现上是一个指针。</p>\n<p>智能指针都是类模板使用时是必须指定类型参数的，如：<code>auto_ptr&lt;int&gt; ptr</code></p>\n<h1 id=\"1-auto-ptr\"><a href=\"#1-auto-ptr\" class=\"headerlink\" title=\"1.auto_ptr\"></a>1.auto_ptr</h1><ul>\n<li>auto_ptr采用所有权的模式，指针内不做引用计数，因此一个对象只能由一个auto_ptr指针所拥有，在给其他auto_ptr指针赋值时，所有权会转移</li>\n<li>auto_ptr中使用delete来释放资源，所以auto_ptr不能指向数组，因为数组的释放使用的是delete[]</li>\n<li>auto_ptr指针的判空使用auto_ptr.get()==NULL来判断</li>\n</ul>\n<p>auto_ptr是C++98中的标准，在C++11中已经被弃用。</p>\n<p>auto_ptr由于是所有权模式，所在在auto_ptr做参数时，会转移所有权，即将函数外的auto_ptr的所有权转义给函数内的auto_ptr的所有权，如果函数内不做所有权转移的话，函数外的auto_ptr将变为空指针，而导致引用出错。如：</p>\n<p><strong>不转移所有权</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Test</span><span class=\"hljs-params\">(<span class=\"hljs-built_in\">auto_ptr</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; apt)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; *apt &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t<span class=\"hljs-keyword\">return</span> apt;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\"><span class=\"hljs-built_in\">auto_ptr</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">ptr</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>(<span class=\"hljs-number\">1</span>))</span></span>;<br>\tTest(ptr);<br>\t<span class=\"hljs-keyword\">if</span> (ptr.get() == <span class=\"hljs-literal\">NULL</span>)<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;NULL&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t<span class=\"hljs-keyword\">else</span><br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;NO NULL&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-number\">1</span><br><span class=\"hljs-literal\">NULL</span><br></code></pre></td></tr></table></figure>\n<p><strong>转移所有权</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-built_in\">auto_ptr</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">Test</span><span class=\"hljs-params\">(<span class=\"hljs-built_in\">auto_ptr</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; apt)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; *apt &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t<span class=\"hljs-keyword\">return</span> apt;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\"><span class=\"hljs-built_in\">auto_ptr</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">ptr</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>(<span class=\"hljs-number\">1</span>))</span></span>;<br>\tptr = Test(ptr);<br>\t<span class=\"hljs-keyword\">if</span> (ptr.get() == <span class=\"hljs-literal\">NULL</span>)<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;NULL&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t<span class=\"hljs-keyword\">else</span><br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;NO NULL&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-number\">1</span><br><span class=\"hljs-literal\">NO</span> <span class=\"hljs-literal\">NULL</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"2-unique-ptr\"><a href=\"#2-unique-ptr\" class=\"headerlink\" title=\"2.unique_ptr\"></a>2.unique_ptr</h1><ul>\n<li><p>unique_ptr是C++11中对C++98中的auto_ptr的替换与强化</p>\n</li>\n<li><p>unique_ptr也是使用独占所有权模式，即一个unique_ptr指针指向一个对象后，不可以在把这个对象赋予给另一个unique_ptr指针，后来出于一些考虑C++又提供了srd::move()函数来做所有权的移交，被移交所有权的unique_ptr指针会指向空，这时再使用这个指针就会报错</p>\n</li>\n<li><p>unique_ptr指针支持直接使用==判空，如：</p>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-built_in\">unique_ptr</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; ptr;<br><span class=\"hljs-keyword\">if</span>(ptr == <span class=\"hljs-literal\">NULL</span>)<br>\t<span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">&quot;NULL&quot;</span>&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br></code></pre></td></tr></table></figure>\n<p>当然unique_ptr依旧支持unique_ptr.get()==NULL来判空。</p>\n<ul>\n<li>当unique_ptr作为实参进行传递时，必须使用std::move()来移交所有权，这是unique_ptr的独占所有权性质决定的。如：</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Test</span><span class=\"hljs-params\">(<span class=\"hljs-built_in\">unique_ptr</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; apt)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; *apt &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\"><span class=\"hljs-built_in\">unique_ptr</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">ptr</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>(<span class=\"hljs-number\">1</span>))</span></span>;<br>\t<span class=\"hljs-built_in\">unique_ptr</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; pt = move(ptr);<br>\tTest(<span class=\"hljs-built_in\">std</span>::move(ptr));<br>\t<span class=\"hljs-keyword\">if</span> (ptr == <span class=\"hljs-literal\">NULL</span>)<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;NULL&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t<span class=\"hljs-keyword\">else</span><br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;NO NULL&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"3-shared-ptr\"><a href=\"#3-shared-ptr\" class=\"headerlink\" title=\"3.shared_ptr\"></a>3.shared_ptr</h1><ul>\n<li><p>shared_ptr指针支持一个对象被多个指针指向</p>\n</li>\n<li><p>shared_ptr使用计数机制来记录对象被多少个shared_ptr指针所指向，可以使用share_ptr.reset()函数来释放当前指针，对象的引用计数减一，当引用计数减为0时，释放对象资源</p>\n</li>\n<li><p>可以使用shared_ptr.use_count()来获取当前对象的引用计数</p>\n</li>\n</ul>\n<p>我们来看一个例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Test</span><span class=\"hljs-params\">(<span class=\"hljs-built_in\">shared_ptr</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; ptr)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;count_1:&quot;</span>&lt;&lt; ptr.use_count() &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\"><span class=\"hljs-built_in\">shared_ptr</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">ptr</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>(<span class=\"hljs-number\">1</span>))</span></span>;<br>\t<span class=\"hljs-built_in\">shared_ptr</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; pt = ptr;<br>\tTest(ptr);<br>\tpt.reset();<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;count_2:&quot;</span>&lt;&lt; ptr.use_count() &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t<span class=\"hljs-keyword\">if</span> (ptr == <span class=\"hljs-literal\">NULL</span>)<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;NULL&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t<span class=\"hljs-keyword\">else</span><br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;NO NULL&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-string\">count_1:3</span><br><span class=\"hljs-string\">count_2:1</span><br><span class=\"hljs-literal\">NO</span> <span class=\"hljs-literal\">NULL</span><br></code></pre></td></tr></table></figure>\n<p>咦！为什么引用计数count_1是3呢？这是因为在函数内形参<code>shared_ptr&lt;int&gt; ptr</code>也指向了同一个对象。而当函数Test结束形参指针释放，同时又使用reset()函数释放pt指针，所以count_2:1</p>\n<h1 id=\"4-weak-ptr\"><a href=\"#4-weak-ptr\" class=\"headerlink\" title=\"4.weak_ptr\"></a>4.weak_ptr</h1><p>虽然shared_ptr使用起来更接近C的原生指针，但是当shared_ptr指针作为类成员时，可能会出现互相引用的而形成死锁，导致引用计数永远无法将为0的现象，如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">B</span>;</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">shared_ptr</span>&lt;B&gt; pa;<br>&#125;;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">B</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">shared_ptr</span>&lt;A&gt; pb;<br>&#125;;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\"><span class=\"hljs-built_in\">shared_ptr</span>&lt;A&gt; <span class=\"hljs-title\">pa</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">new</span> A())</span></span>;<br>\t<span class=\"hljs-function\"><span class=\"hljs-built_in\">shared_ptr</span>&lt;B&gt; <span class=\"hljs-title\">pb</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">new</span> B())</span></span>;<br>\tpa-&gt;pa = pb;<br>\tpb-&gt;pb = pa;<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这种情况是，pa是指向A类型的shared_ptr指针指向A类型对象，而pa指向的内存里面又有一个shared_ptr指针指向B类型对象，同理pb也是如此，这样就导致，当A要被释放时，要先释放B，而B要释放时又要先释放A，如此便形成了一个互相等待的死循环。weak_ptr的存在就是为了解决这种问题。</p>\n<p>weak_ptr指针是一种弱引用，它指向对象和释放时不会引起引用计数的变化，这样便可以打破shared_ptr的这种死循环了，我们将上面的代码改成如下，就可以解死循环了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">B</span>;</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\tweak_ptr&lt;B&gt; pa;<br>&#125;;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">B</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">shared_ptr</span>&lt;A&gt; pb;<br>&#125;;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\"><span class=\"hljs-built_in\">shared_ptr</span>&lt;A&gt; <span class=\"hljs-title\">pa</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">new</span> A())</span></span>;<br>\t<span class=\"hljs-function\"><span class=\"hljs-built_in\">shared_ptr</span>&lt;B&gt; <span class=\"hljs-title\">pb</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">new</span> B())</span></span>;<br>\tpa-&gt;pa = pb;<br>\tpb-&gt;pb = pa;<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p>智能指针的出现的目的就是为了解决c++中出现异常安全资源管理问题，智能指针的实现原理是依据RAII机制(Resource Acquisition Is Initialization)，这是的智能指针本质上是一个对象，行为表现上是一个指针。</p>\n<p>智能指针都是类模板使用时是必须指定类型参数的，如：<code>auto_ptr&lt;int&gt; ptr</code></p>\n<h1 id=\"1-auto-ptr\"><a href=\"#1-auto-ptr\" class=\"headerlink\" title=\"1.auto_ptr\"></a>1.auto_ptr</h1><ul>\n<li>auto_ptr采用所有权的模式，指针内不做引用计数，因此一个对象只能由一个auto_ptr指针所拥有，在给其他auto_ptr指针赋值时，所有权会转移</li>\n<li>auto_ptr中使用delete来释放资源，所以auto_ptr不能指向数组，因为数组的释放使用的是delete[]</li>\n<li>auto_ptr指针的判空使用auto_ptr.get()==NULL来判断</li>\n</ul>\n<p>auto_ptr是C++98中的标准，在C++11中已经被弃用。</p>\n<p>auto_ptr由于是所有权模式，所在在auto_ptr做参数时，会转移所有权，即将函数外的auto_ptr的所有权转义给函数内的auto_ptr的所有权，如果函数内不做所有权转移的话，函数外的auto_ptr将变为空指针，而导致引用出错。如：</p>\n<p><strong>不转移所有权</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Test</span><span class=\"hljs-params\">(<span class=\"hljs-built_in\">auto_ptr</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; apt)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; *apt &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t<span class=\"hljs-keyword\">return</span> apt;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\"><span class=\"hljs-built_in\">auto_ptr</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">ptr</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>(<span class=\"hljs-number\">1</span>))</span></span>;<br>\tTest(ptr);<br>\t<span class=\"hljs-keyword\">if</span> (ptr.get() == <span class=\"hljs-literal\">NULL</span>)<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;NULL&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t<span class=\"hljs-keyword\">else</span><br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;NO NULL&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-number\">1</span><br><span class=\"hljs-literal\">NULL</span><br></code></pre></td></tr></table></figure>\n<p><strong>转移所有权</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-built_in\">auto_ptr</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">Test</span><span class=\"hljs-params\">(<span class=\"hljs-built_in\">auto_ptr</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; apt)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; *apt &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t<span class=\"hljs-keyword\">return</span> apt;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\"><span class=\"hljs-built_in\">auto_ptr</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">ptr</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>(<span class=\"hljs-number\">1</span>))</span></span>;<br>\tptr = Test(ptr);<br>\t<span class=\"hljs-keyword\">if</span> (ptr.get() == <span class=\"hljs-literal\">NULL</span>)<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;NULL&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t<span class=\"hljs-keyword\">else</span><br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;NO NULL&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-number\">1</span><br><span class=\"hljs-literal\">NO</span> <span class=\"hljs-literal\">NULL</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"2-unique-ptr\"><a href=\"#2-unique-ptr\" class=\"headerlink\" title=\"2.unique_ptr\"></a>2.unique_ptr</h1><ul>\n<li><p>unique_ptr是C++11中对C++98中的auto_ptr的替换与强化</p>\n</li>\n<li><p>unique_ptr也是使用独占所有权模式，即一个unique_ptr指针指向一个对象后，不可以在把这个对象赋予给另一个unique_ptr指针，后来出于一些考虑C++又提供了srd::move()函数来做所有权的移交，被移交所有权的unique_ptr指针会指向空，这时再使用这个指针就会报错</p>\n</li>\n<li><p>unique_ptr指针支持直接使用==判空，如：</p>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-built_in\">unique_ptr</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; ptr;<br><span class=\"hljs-keyword\">if</span>(ptr == <span class=\"hljs-literal\">NULL</span>)<br>\t<span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">&quot;NULL&quot;</span>&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br></code></pre></td></tr></table></figure>\n<p>当然unique_ptr依旧支持unique_ptr.get()==NULL来判空。</p>\n<ul>\n<li>当unique_ptr作为实参进行传递时，必须使用std::move()来移交所有权，这是unique_ptr的独占所有权性质决定的。如：</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Test</span><span class=\"hljs-params\">(<span class=\"hljs-built_in\">unique_ptr</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; apt)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; *apt &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\"><span class=\"hljs-built_in\">unique_ptr</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">ptr</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>(<span class=\"hljs-number\">1</span>))</span></span>;<br>\t<span class=\"hljs-built_in\">unique_ptr</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; pt = move(ptr);<br>\tTest(<span class=\"hljs-built_in\">std</span>::move(ptr));<br>\t<span class=\"hljs-keyword\">if</span> (ptr == <span class=\"hljs-literal\">NULL</span>)<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;NULL&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t<span class=\"hljs-keyword\">else</span><br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;NO NULL&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"3-shared-ptr\"><a href=\"#3-shared-ptr\" class=\"headerlink\" title=\"3.shared_ptr\"></a>3.shared_ptr</h1><ul>\n<li><p>shared_ptr指针支持一个对象被多个指针指向</p>\n</li>\n<li><p>shared_ptr使用计数机制来记录对象被多少个shared_ptr指针所指向，可以使用share_ptr.reset()函数来释放当前指针，对象的引用计数减一，当引用计数减为0时，释放对象资源</p>\n</li>\n<li><p>可以使用shared_ptr.use_count()来获取当前对象的引用计数</p>\n</li>\n</ul>\n<p>我们来看一个例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Test</span><span class=\"hljs-params\">(<span class=\"hljs-built_in\">shared_ptr</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; ptr)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;count_1:&quot;</span>&lt;&lt; ptr.use_count() &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\"><span class=\"hljs-built_in\">shared_ptr</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">ptr</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>(<span class=\"hljs-number\">1</span>))</span></span>;<br>\t<span class=\"hljs-built_in\">shared_ptr</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; pt = ptr;<br>\tTest(ptr);<br>\tpt.reset();<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;count_2:&quot;</span>&lt;&lt; ptr.use_count() &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t<span class=\"hljs-keyword\">if</span> (ptr == <span class=\"hljs-literal\">NULL</span>)<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;NULL&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t<span class=\"hljs-keyword\">else</span><br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;NO NULL&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-string\">count_1:3</span><br><span class=\"hljs-string\">count_2:1</span><br><span class=\"hljs-literal\">NO</span> <span class=\"hljs-literal\">NULL</span><br></code></pre></td></tr></table></figure>\n<p>咦！为什么引用计数count_1是3呢？这是因为在函数内形参<code>shared_ptr&lt;int&gt; ptr</code>也指向了同一个对象。而当函数Test结束形参指针释放，同时又使用reset()函数释放pt指针，所以count_2:1</p>\n<h1 id=\"4-weak-ptr\"><a href=\"#4-weak-ptr\" class=\"headerlink\" title=\"4.weak_ptr\"></a>4.weak_ptr</h1><p>虽然shared_ptr使用起来更接近C的原生指针，但是当shared_ptr指针作为类成员时，可能会出现互相引用的而形成死锁，导致引用计数永远无法将为0的现象，如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">B</span>;</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">shared_ptr</span>&lt;B&gt; pa;<br>&#125;;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">B</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">shared_ptr</span>&lt;A&gt; pb;<br>&#125;;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\"><span class=\"hljs-built_in\">shared_ptr</span>&lt;A&gt; <span class=\"hljs-title\">pa</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">new</span> A())</span></span>;<br>\t<span class=\"hljs-function\"><span class=\"hljs-built_in\">shared_ptr</span>&lt;B&gt; <span class=\"hljs-title\">pb</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">new</span> B())</span></span>;<br>\tpa-&gt;pa = pb;<br>\tpb-&gt;pb = pa;<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这种情况是，pa是指向A类型的shared_ptr指针指向A类型对象，而pa指向的内存里面又有一个shared_ptr指针指向B类型对象，同理pb也是如此，这样就导致，当A要被释放时，要先释放B，而B要释放时又要先释放A，如此便形成了一个互相等待的死循环。weak_ptr的存在就是为了解决这种问题。</p>\n<p>weak_ptr指针是一种弱引用，它指向对象和释放时不会引起引用计数的变化，这样便可以打破shared_ptr的这种死循环了，我们将上面的代码改成如下，就可以解死循环了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">B</span>;</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\tweak_ptr&lt;B&gt; pa;<br>&#125;;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">B</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">shared_ptr</span>&lt;A&gt; pb;<br>&#125;;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\"><span class=\"hljs-built_in\">shared_ptr</span>&lt;A&gt; <span class=\"hljs-title\">pa</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">new</span> A())</span></span>;<br>\t<span class=\"hljs-function\"><span class=\"hljs-built_in\">shared_ptr</span>&lt;B&gt; <span class=\"hljs-title\">pb</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">new</span> B())</span></span>;<br>\tpa-&gt;pa = pb;<br>\tpb-&gt;pb = pa;<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"【C++】C++中的四种类型转换","date":"2019-09-12T01:43:34.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\nC++提供四种类型转换：const_cast、static_cast、dynamic_cast、reinterpret_cast\n\n# 1.const_cast\n\n​\tconst_cast的存在主要就是针对const字段，C++提供const_cast的目的就是为了消除const字段的const属性，让const字段也可以修改。\n\n​\tconst_cast的用法：\n\n​\t\tconst_cast只能将常指针转换为非常指针，不能直接将常字段转换为非常字段，只能通过指针类间接的修改常字段所在的内存的内容。\n\n​\t\t例：\n\n```C++\nconst int a = 1;\nconst int* n = &a;\nint* m = const_cast<int*>(n) ;\n*m = 2;\n```\n\n​\t最终的输出结果：\n\n```\na = 1,*n = 2,*m = 2\n&a=n=m\n```\n\n​\t\t奇怪，指针n，m的确指向了地址&a，之中的内容的确也修改成了2，可为什么字段a的值依旧是1？\n\n​\t\t经过多方查阅资料和自己的试验，原来对于常字段在预编译的过程中编译器就会给常字段预定义为初始化的值，类似宏定义一般，尽管内存的内容被改变了，但是常字段的值依旧被预定义为初始化的值。\n\n​\t\t但是，我就疑问了，既然const_cast就是用来修改const字段的，可是只是改变了其内存的值，字段的值依旧没变，那么程序里使用该字段的地方的值依旧没有改变，如此const_cast似乎没有达到想要的结果。\n\n​\t\t$\\color{red}{不过const_cast似乎可以修改const标识的结构体对象中没有再用const标识的字段，也可以修改用const标识的类对象中没有用const标识的公有字段，但是在结构体或类中用const标识的字段就不能再修改了。}$\n\n![](【C++】C++中的四种转换类型/Snipaste_2019-09-12_10-44-16.png)\n\n# 2.static_cast\n\n​\tstatic_cast类型转换的用法几乎和C中的基本类型转换的用法一致，而C++的static_cast类型转换增加了类型检查，在安全性上较C要强。\n\n​\tstatic_cast支持所有类型之间的转换包括类，对于类在继承过程中的类型转换有两点是需要注意的，\n\n一、static_cast类型转换在上行转换是安全的，在下行转换是不安全，（上行转换：从子类转换到父类，下行转换：从父类转换到子类），\n\n二、static_cast类型转换在类的转换中因该使用指针转换，即通过指针间接的实现转换，直接对类的对象进行转换类型会被裁剪，并且在下行转换中不使用指针会报错。\n\n![](【C++】C++中的四种转换类型/Snipaste_2019-09-12_11-51-30.png)\n\n# 3.dynamic_cast\n\n​\tdynamic_cast类型转换用于类之间的上下行转换，与static_cast不同的是，dynamic_cast类型转换无论上下行都具有类型检查，都可以进行安全的类型转换。上行转换dynamic_cast与static_cast完全一致，下行转换dynamic_cast比static_cast更安全。\n\n​\tdynamic_cast的具体使用场景就是将父类指针转换成子类指针，但是使用条件就是只能用于含有虚函数的类，因为dynamic_cast的内部机制就是利用虚函数表里的类型信息来判断一个父类指针是否指向一个子类对象，转换失败会抛出bad_cast异常，并返回null。\n\n# 4.reinterpret_cast\n\n​\treinterpret_cast类型转换只能对指针进行操作，reinterpret_cast类型转换提供的是一种更底层的转换模式--比特位上的重新解释，即对某一类型的内存地址的比特位以另一种类型来解释，这可能不好理解，在这放一张图来辅助理解。\n\n![](【C++】C++中的四种转换类型/Snipaste_2019-09-12_16-32-44.png)\n\n​\tp是指向字符串的char类型指针，i是指向整型的指针，i = reinterpret_cast<int*>(p)则将p所指向的内存里的比特位以int类型来重新解释并复制到i所指向的内存地址上，于是在输出 *i 时，输出的是一个整型的数值。\n\nreinterret_cast可以说是一个安全的强制类型转换了。 \n\n​\t至于为什么cout<<p时不是输出的p所指向的地址而是地址里的内容，我始终没有弄明白，不过不影响对reinterpret_cast类型转换的理解。","source":"_posts/【C++】C++中的四种转换类型.md","raw":"---\ntitle: 【C++】C++中的四种类型转换\ndate: 2019-09-12 09:43:34\ntags: CPlus\ncategories: 知识记录\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\nC++提供四种类型转换：const_cast、static_cast、dynamic_cast、reinterpret_cast\n\n# 1.const_cast\n\n​\tconst_cast的存在主要就是针对const字段，C++提供const_cast的目的就是为了消除const字段的const属性，让const字段也可以修改。\n\n​\tconst_cast的用法：\n\n​\t\tconst_cast只能将常指针转换为非常指针，不能直接将常字段转换为非常字段，只能通过指针类间接的修改常字段所在的内存的内容。\n\n​\t\t例：\n\n```C++\nconst int a = 1;\nconst int* n = &a;\nint* m = const_cast<int*>(n) ;\n*m = 2;\n```\n\n​\t最终的输出结果：\n\n```\na = 1,*n = 2,*m = 2\n&a=n=m\n```\n\n​\t\t奇怪，指针n，m的确指向了地址&a，之中的内容的确也修改成了2，可为什么字段a的值依旧是1？\n\n​\t\t经过多方查阅资料和自己的试验，原来对于常字段在预编译的过程中编译器就会给常字段预定义为初始化的值，类似宏定义一般，尽管内存的内容被改变了，但是常字段的值依旧被预定义为初始化的值。\n\n​\t\t但是，我就疑问了，既然const_cast就是用来修改const字段的，可是只是改变了其内存的值，字段的值依旧没变，那么程序里使用该字段的地方的值依旧没有改变，如此const_cast似乎没有达到想要的结果。\n\n​\t\t$\\color{red}{不过const_cast似乎可以修改const标识的结构体对象中没有再用const标识的字段，也可以修改用const标识的类对象中没有用const标识的公有字段，但是在结构体或类中用const标识的字段就不能再修改了。}$\n\n![](【C++】C++中的四种转换类型/Snipaste_2019-09-12_10-44-16.png)\n\n# 2.static_cast\n\n​\tstatic_cast类型转换的用法几乎和C中的基本类型转换的用法一致，而C++的static_cast类型转换增加了类型检查，在安全性上较C要强。\n\n​\tstatic_cast支持所有类型之间的转换包括类，对于类在继承过程中的类型转换有两点是需要注意的，\n\n一、static_cast类型转换在上行转换是安全的，在下行转换是不安全，（上行转换：从子类转换到父类，下行转换：从父类转换到子类），\n\n二、static_cast类型转换在类的转换中因该使用指针转换，即通过指针间接的实现转换，直接对类的对象进行转换类型会被裁剪，并且在下行转换中不使用指针会报错。\n\n![](【C++】C++中的四种转换类型/Snipaste_2019-09-12_11-51-30.png)\n\n# 3.dynamic_cast\n\n​\tdynamic_cast类型转换用于类之间的上下行转换，与static_cast不同的是，dynamic_cast类型转换无论上下行都具有类型检查，都可以进行安全的类型转换。上行转换dynamic_cast与static_cast完全一致，下行转换dynamic_cast比static_cast更安全。\n\n​\tdynamic_cast的具体使用场景就是将父类指针转换成子类指针，但是使用条件就是只能用于含有虚函数的类，因为dynamic_cast的内部机制就是利用虚函数表里的类型信息来判断一个父类指针是否指向一个子类对象，转换失败会抛出bad_cast异常，并返回null。\n\n# 4.reinterpret_cast\n\n​\treinterpret_cast类型转换只能对指针进行操作，reinterpret_cast类型转换提供的是一种更底层的转换模式--比特位上的重新解释，即对某一类型的内存地址的比特位以另一种类型来解释，这可能不好理解，在这放一张图来辅助理解。\n\n![](【C++】C++中的四种转换类型/Snipaste_2019-09-12_16-32-44.png)\n\n​\tp是指向字符串的char类型指针，i是指向整型的指针，i = reinterpret_cast<int*>(p)则将p所指向的内存里的比特位以int类型来重新解释并复制到i所指向的内存地址上，于是在输出 *i 时，输出的是一个整型的数值。\n\nreinterret_cast可以说是一个安全的强制类型转换了。 \n\n​\t至于为什么cout<<p时不是输出的p所指向的地址而是地址里的内容，我始终没有弄明白，不过不影响对reinterpret_cast类型转换的理解。","slug":"【C++】C++中的四种转换类型","published":1,"updated":"2021-05-13T02:47:01.237Z","_id":"ckk9hocah0006dwr78y3x38ht","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p>C++提供四种类型转换：const_cast、static_cast、dynamic_cast、reinterpret_cast</p>\n<h1 id=\"1-const-cast\"><a href=\"#1-const-cast\" class=\"headerlink\" title=\"1.const_cast\"></a>1.const_cast</h1><p>​    const_cast的存在主要就是针对const字段，C++提供const_cast的目的就是为了消除const字段的const属性，让const字段也可以修改。</p>\n<p>​    const_cast的用法：</p>\n<p>​        const_cast只能将常指针转换为非常指针，不能直接将常字段转换为非常字段，只能通过指针类间接的修改常字段所在的内存的内容。</p>\n<p>​        例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">int</span> a = <span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">int</span>* n = &amp;a;<br><span class=\"hljs-keyword\">int</span>* m = <span class=\"hljs-keyword\">const_cast</span>&lt;<span class=\"hljs-keyword\">int</span>*&gt;(n) ;<br>*m = <span class=\"hljs-number\">2</span>;<br></code></pre></td></tr></table></figure>\n<p>​    最终的输出结果：</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nix\"><span class=\"hljs-attr\">a</span> = <span class=\"hljs-number\">1</span>,*<span class=\"hljs-attr\">n</span> = <span class=\"hljs-number\">2</span>,*<span class=\"hljs-attr\">m</span> = <span class=\"hljs-number\">2</span><br>&amp;<span class=\"hljs-attr\">a=n=m</span><br></code></pre></td></tr></table></figure>\n<p>​        奇怪，指针n，m的确指向了地址&amp;a，之中的内容的确也修改成了2，可为什么字段a的值依旧是1？</p>\n<p>​        经过多方查阅资料和自己的试验，原来对于常字段在预编译的过程中编译器就会给常字段预定义为初始化的值，类似宏定义一般，尽管内存的内容被改变了，但是常字段的值依旧被预定义为初始化的值。</p>\n<p>​        但是，我就疑问了，既然const_cast就是用来修改const字段的，可是只是改变了其内存的值，字段的值依旧没变，那么程序里使用该字段的地方的值依旧没有改变，如此const_cast似乎没有达到想要的结果。</p>\n<p>​        $\\color{red}{不过const_cast似乎可以修改const标识的结构体对象中没有再用const标识的字段，也可以修改用const标识的类对象中没有用const标识的公有字段，但是在结构体或类中用const标识的字段就不能再修改了。}$</p>\n<p><img src=\"/2019/09/12/%E3%80%90C++%E3%80%91C++%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/Snipaste_2019-09-12_10-44-16.png\"></p>\n<h1 id=\"2-static-cast\"><a href=\"#2-static-cast\" class=\"headerlink\" title=\"2.static_cast\"></a>2.static_cast</h1><p>​    static_cast类型转换的用法几乎和C中的基本类型转换的用法一致，而C++的static_cast类型转换增加了类型检查，在安全性上较C要强。</p>\n<p>​    static_cast支持所有类型之间的转换包括类，对于类在继承过程中的类型转换有两点是需要注意的，</p>\n<p>一、static_cast类型转换在上行转换是安全的，在下行转换是不安全，（上行转换：从子类转换到父类，下行转换：从父类转换到子类），</p>\n<p>二、static_cast类型转换在类的转换中因该使用指针转换，即通过指针间接的实现转换，直接对类的对象进行转换类型会被裁剪，并且在下行转换中不使用指针会报错。</p>\n<p><img src=\"/2019/09/12/%E3%80%90C++%E3%80%91C++%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/Snipaste_2019-09-12_11-51-30.png\"></p>\n<h1 id=\"3-dynamic-cast\"><a href=\"#3-dynamic-cast\" class=\"headerlink\" title=\"3.dynamic_cast\"></a>3.dynamic_cast</h1><p>​    dynamic_cast类型转换用于类之间的上下行转换，与static_cast不同的是，dynamic_cast类型转换无论上下行都具有类型检查，都可以进行安全的类型转换。上行转换dynamic_cast与static_cast完全一致，下行转换dynamic_cast比static_cast更安全。</p>\n<p>​    dynamic_cast的具体使用场景就是将父类指针转换成子类指针，但是使用条件就是只能用于含有虚函数的类，因为dynamic_cast的内部机制就是利用虚函数表里的类型信息来判断一个父类指针是否指向一个子类对象，转换失败会抛出bad_cast异常，并返回null。</p>\n<h1 id=\"4-reinterpret-cast\"><a href=\"#4-reinterpret-cast\" class=\"headerlink\" title=\"4.reinterpret_cast\"></a>4.reinterpret_cast</h1><p>​    reinterpret_cast类型转换只能对指针进行操作，reinterpret_cast类型转换提供的是一种更底层的转换模式–比特位上的重新解释，即对某一类型的内存地址的比特位以另一种类型来解释，这可能不好理解，在这放一张图来辅助理解。</p>\n<p><img src=\"/2019/09/12/%E3%80%90C++%E3%80%91C++%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/Snipaste_2019-09-12_16-32-44.png\"></p>\n<p>​    p是指向字符串的char类型指针，i是指向整型的指针，i = reinterpret_cast&lt;int*&gt;(p)则将p所指向的内存里的比特位以int类型来重新解释并复制到i所指向的内存地址上，于是在输出 *i 时，输出的是一个整型的数值。</p>\n<p>reinterret_cast可以说是一个安全的强制类型转换了。 </p>\n<p>​    至于为什么cout&lt;&lt;p时不是输出的p所指向的地址而是地址里的内容，我始终没有弄明白，不过不影响对reinterpret_cast类型转换的理解。</p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p>C++提供四种类型转换：const_cast、static_cast、dynamic_cast、reinterpret_cast</p>\n<h1 id=\"1-const-cast\"><a href=\"#1-const-cast\" class=\"headerlink\" title=\"1.const_cast\"></a>1.const_cast</h1><p>​    const_cast的存在主要就是针对const字段，C++提供const_cast的目的就是为了消除const字段的const属性，让const字段也可以修改。</p>\n<p>​    const_cast的用法：</p>\n<p>​        const_cast只能将常指针转换为非常指针，不能直接将常字段转换为非常字段，只能通过指针类间接的修改常字段所在的内存的内容。</p>\n<p>​        例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">int</span> a = <span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">int</span>* n = &amp;a;<br><span class=\"hljs-keyword\">int</span>* m = <span class=\"hljs-keyword\">const_cast</span>&lt;<span class=\"hljs-keyword\">int</span>*&gt;(n) ;<br>*m = <span class=\"hljs-number\">2</span>;<br></code></pre></td></tr></table></figure>\n<p>​    最终的输出结果：</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nix\"><span class=\"hljs-attr\">a</span> = <span class=\"hljs-number\">1</span>,*<span class=\"hljs-attr\">n</span> = <span class=\"hljs-number\">2</span>,*<span class=\"hljs-attr\">m</span> = <span class=\"hljs-number\">2</span><br>&amp;<span class=\"hljs-attr\">a=n=m</span><br></code></pre></td></tr></table></figure>\n<p>​        奇怪，指针n，m的确指向了地址&amp;a，之中的内容的确也修改成了2，可为什么字段a的值依旧是1？</p>\n<p>​        经过多方查阅资料和自己的试验，原来对于常字段在预编译的过程中编译器就会给常字段预定义为初始化的值，类似宏定义一般，尽管内存的内容被改变了，但是常字段的值依旧被预定义为初始化的值。</p>\n<p>​        但是，我就疑问了，既然const_cast就是用来修改const字段的，可是只是改变了其内存的值，字段的值依旧没变，那么程序里使用该字段的地方的值依旧没有改变，如此const_cast似乎没有达到想要的结果。</p>\n<p>​        $\\color{red}{不过const_cast似乎可以修改const标识的结构体对象中没有再用const标识的字段，也可以修改用const标识的类对象中没有用const标识的公有字段，但是在结构体或类中用const标识的字段就不能再修改了。}$</p>\n<p><img src=\"/2019/09/12/%E3%80%90C++%E3%80%91C++%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/Snipaste_2019-09-12_10-44-16.png\"></p>\n<h1 id=\"2-static-cast\"><a href=\"#2-static-cast\" class=\"headerlink\" title=\"2.static_cast\"></a>2.static_cast</h1><p>​    static_cast类型转换的用法几乎和C中的基本类型转换的用法一致，而C++的static_cast类型转换增加了类型检查，在安全性上较C要强。</p>\n<p>​    static_cast支持所有类型之间的转换包括类，对于类在继承过程中的类型转换有两点是需要注意的，</p>\n<p>一、static_cast类型转换在上行转换是安全的，在下行转换是不安全，（上行转换：从子类转换到父类，下行转换：从父类转换到子类），</p>\n<p>二、static_cast类型转换在类的转换中因该使用指针转换，即通过指针间接的实现转换，直接对类的对象进行转换类型会被裁剪，并且在下行转换中不使用指针会报错。</p>\n<p><img src=\"/2019/09/12/%E3%80%90C++%E3%80%91C++%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/Snipaste_2019-09-12_11-51-30.png\"></p>\n<h1 id=\"3-dynamic-cast\"><a href=\"#3-dynamic-cast\" class=\"headerlink\" title=\"3.dynamic_cast\"></a>3.dynamic_cast</h1><p>​    dynamic_cast类型转换用于类之间的上下行转换，与static_cast不同的是，dynamic_cast类型转换无论上下行都具有类型检查，都可以进行安全的类型转换。上行转换dynamic_cast与static_cast完全一致，下行转换dynamic_cast比static_cast更安全。</p>\n<p>​    dynamic_cast的具体使用场景就是将父类指针转换成子类指针，但是使用条件就是只能用于含有虚函数的类，因为dynamic_cast的内部机制就是利用虚函数表里的类型信息来判断一个父类指针是否指向一个子类对象，转换失败会抛出bad_cast异常，并返回null。</p>\n<h1 id=\"4-reinterpret-cast\"><a href=\"#4-reinterpret-cast\" class=\"headerlink\" title=\"4.reinterpret_cast\"></a>4.reinterpret_cast</h1><p>​    reinterpret_cast类型转换只能对指针进行操作，reinterpret_cast类型转换提供的是一种更底层的转换模式–比特位上的重新解释，即对某一类型的内存地址的比特位以另一种类型来解释，这可能不好理解，在这放一张图来辅助理解。</p>\n<p><img src=\"/2019/09/12/%E3%80%90C++%E3%80%91C++%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/Snipaste_2019-09-12_16-32-44.png\"></p>\n<p>​    p是指向字符串的char类型指针，i是指向整型的指针，i = reinterpret_cast&lt;int*&gt;(p)则将p所指向的内存里的比特位以int类型来重新解释并复制到i所指向的内存地址上，于是在输出 *i 时，输出的是一个整型的数值。</p>\n<p>reinterret_cast可以说是一个安全的强制类型转换了。 </p>\n<p>​    至于为什么cout&lt;&lt;p时不是输出的p所指向的地址而是地址里的内容，我始终没有弄明白，不过不影响对reinterpret_cast类型转换的理解。</p>\n"},{"title":"【C++】C++函数模板的实现机制剖析","date":"2019-10-03T12:14:23.000Z","_content":"\n\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 函数模板的实现机制剖析\n\n要剖析函数模板的实现机制，我们要先了解程序的编译过程，这里以gcc为例\n\n![](【C++】C++函数模板的实现机制剖析/Snipaste_2019-10-03_16-51-51.png)\n\n这里对下面代码进行剖析\n\n```c++\n#include \"stdafx.h\"//这是VS的固有头文件\n#include <iostream>\nusing namespace std;\n\ntemplate <typename T>\nvoid Fun(T a,T b)\n{\n\ta = a + b;\n\tcout << \"我是函数模板\" << endl;\n}\nint main()\n{\n\tFun(1, 2);\n\tFun(0.1, 0.2);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n打开控制台，使用命令生成汇编文件(当然环境变量里需要有g++编译器的路径才能这样使用，具体操作放在文末)\n\n```shell\ng++ -S 1.cpp -o 1.s\n```\n\n我们来查看汇编文件\n\n```pascal\n\t.file\t\"C++.cpp\"\n.lcomm __ZStL8__ioinit,1,1\n\t.def\t___main;\t.scl\t2;\t.type\t32;\t.endef\n\t.section .rdata,\"dr\"\nLC2:\n\t.ascii \"pause\\0\"\n\t.text\n\t.globl\t_main\n\t.def\t_main;\t.scl\t2;\t.type\t32;\t.endef\n_main:\nLFB1062:\n\t.cfi_startproc\n\tpushl\t%ebp\n\t.cfi_def_cfa_offset 8\n\t.cfi_offset 5, -8\n\tmovl\t%esp, %ebp\n\t.cfi_def_cfa_register 5\n\tandl\t$-16, %esp\n\tsubl\t$16, %esp\n\tcall\t___main//--------------进入main函数\n\tmovl\t$2, 4(%esp)\n\tmovl\t$1, (%esp)\n\tcall\t__Z3FunIiEvT_S0_//-----第一次调用函数模板\n\tfldl\tLC0\n\tfstpl\t8(%esp)\n\tfldl\tLC1\n\tfstpl\t(%esp)\n\tcall\t__Z3FunIdEvT_S0_//-----第二次调用函数模板\n\tmovl\t$LC2, (%esp)\n\tcall\t_system\n\tmovl\t$0, %eax\n\tleave\n\t.cfi_restore 5\n\t.cfi_def_cfa 4, 4\n\tret\n\t.cfi_endproc\nLFE1062:\n\t.section .rdata,\"dr\"\nLC4:\n\t.ascii \"\\316\\322\\312\\307\\272\\257\\312\\375\\304\\243\\260\\345\\0\"\n\t.section\t.text$_Z3FunIiEvT_S0_,\"x\"\n\t.linkonce discard\n\t.globl\t__Z3FunIiEvT_S0_\n\t.def\t__Z3FunIiEvT_S0_;\t.scl\t2;\t.type\t32;\t.endef\n__Z3FunIiEvT_S0_://------------第一次调用时函数模板的具体实现\nLFB1063:\n\t.cfi_startproc\n\tpushl\t%ebp\n\t.cfi_def_cfa_offset 8\n\t.cfi_offset 5, -8\n\tmovl\t%esp, %ebp\n\t.cfi_def_cfa_register 5\n\tsubl\t$24, %esp\n\tmovl\t12(%ebp), %eax\n\taddl\t%eax, 8(%ebp)\n\tmovl\t$LC4, 4(%esp)\n\tmovl\t$__ZSt4cout, (%esp)\n\tcall\t__ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc\n\tmovl\t$__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_, (%esp)\n\tmovl\t%eax, %ecx\n\tcall\t__ZNSolsEPFRSoS_E\n\tsubl\t$4, %esp\n\tnop\n\tleave\n\t.cfi_restore 5\n\t.cfi_def_cfa 4, 4\n\tret\n\t.cfi_endproc\nLFE1063:\n\t.section\t.text$_Z3FunIdEvT_S0_,\"x\"\n\t.linkonce discard\n\t.globl\t__Z3FunIdEvT_S0_//-第二次调用时函数模板的具体实现\n\t.def\t__Z3FunIdEvT_S0_;\t.scl\t2;\t.type\t32;\t.endef\n__Z3FunIdEvT_S0_:\nLFB1064:\n\t.cfi_startproc\n\tpushl\t%ebp\n\t.cfi_def_cfa_offset 8\n\t.cfi_offset 5, -8\n\tmovl\t%esp, %ebp\n\t.cfi_def_cfa_register 5\n\tsubl\t$40, %esp\n\tmovl\t8(%ebp), %eax\n\tmovl\t%eax, -16(%ebp)\n\tmovl\t12(%ebp), %eax\n\tmovl\t%eax, -12(%ebp)\n\tmovl\t16(%ebp), %eax\n\tmovl\t%eax, -24(%ebp)\n\tmovl\t20(%ebp), %eax\n\tmovl\t%eax, -20(%ebp)\n\tfldl\t-16(%ebp)\n\tfaddl\t-24(%ebp)\n\tfstpl\t-16(%ebp)\n\tmovl\t$LC4, 4(%esp)\n\tmovl\t$__ZSt4cout, (%esp)\n\tcall\t__ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc\n\tmovl\t$__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_, (%esp)\n\tmovl\t%eax, %ecx\n\tcall\t__ZNSolsEPFRSoS_E\n\tsubl\t$4, %esp\n\tnop\n\tleave\n\t.cfi_restore 5\n\t.cfi_def_cfa 4, 4\n\tret\n\t.cfi_endproc\nLFE1064:\n\t.text\n\t.def\t___tcf_0;\t.scl\t3;\t.type\t32;\t.endef\n___tcf_0:\nLFB1074:\n\t.cfi_startproc\n\tpushl\t%ebp\n\t.cfi_def_cfa_offset 8\n\t.cfi_offset 5, -8\n\tmovl\t%esp, %ebp\n\t.cfi_def_cfa_register 5\n\tsubl\t$8, %esp\n\tmovl\t$__ZStL8__ioinit, %ecx\n\tcall\t__ZNSt8ios_base4InitD1Ev\n\tleave\n\t.cfi_restore 5\n\t.cfi_def_cfa 4, 4\n\tret\n\t.cfi_endproc\nLFE1074:\n\t.def\t__Z41__static_initialization_and_destruction_0ii;\t.scl\t3;\t.type\t32;\t.endef\n__Z41__static_initialization_and_destruction_0ii:\nLFB1073:\n\t.cfi_startproc\n\tpushl\t%ebp\n\t.cfi_def_cfa_offset 8\n\t.cfi_offset 5, -8\n\tmovl\t%esp, %ebp\n\t.cfi_def_cfa_register 5\n\tsubl\t$24, %esp\n\tcmpl\t$1, 8(%ebp)\n\tjne\tL8\n\tcmpl\t$65535, 12(%ebp)\n\tjne\tL8\n\tmovl\t$__ZStL8__ioinit, %ecx\n\tcall\t__ZNSt8ios_base4InitC1Ev\n\tmovl\t$___tcf_0, (%esp)\n\tcall\t_atexit\nL8:\n\tnop\n\tleave\n\t.cfi_restore 5\n\t.cfi_def_cfa 4, 4\n\tret\n\t.cfi_endproc\nLFE1073:\n\t.def\t__GLOBAL__sub_I_main;\t.scl\t3;\t.type\t32;\t.endef\n__GLOBAL__sub_I_main:\nLFB1075:\n\t.cfi_startproc\n\tpushl\t%ebp\n\t.cfi_def_cfa_offset 8\n\t.cfi_offset 5, -8\n\tmovl\t%esp, %ebp\n\t.cfi_def_cfa_register 5\n\tsubl\t$24, %esp\n\tmovl\t$65535, 4(%esp)\n\tmovl\t$1, (%esp)\n\tcall\t__Z41__static_initialization_and_destruction_0ii\n\tleave\n\t.cfi_restore 5\n\t.cfi_def_cfa 4, 4\n\tret\n\t.cfi_endproc\nLFE1075:\n\t.section\t.ctors,\"w\"\n\t.align 4\n\t.long\t__GLOBAL__sub_I_main\n\t.section .rdata,\"dr\"\n\t.align 8\nLC0:\n\t.long\t-1717986918\n\t.long\t1070176665\n\t.align 8\nLC1:\n\t.long\t-1717986918\n\t.long\t1069128089\n\t.ident\t\"GCC: (i686-posix-dwarf-rev0, Built by MinGW-W64 project) 5.3.0\"\n\t.def\t_system;\t.scl\t2;\t.type\t32;\t.endef\n\t.def\t__ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc;\t.scl\t2;\t.type\t32;\t.endef\n\t.def\t__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_;\t.scl\t2;\t.type\t32;\t.endef\n\t.def\t__ZNSolsEPFRSoS_E;\t.scl\t2;\t.type\t32;\t.endef\n\t.def\t__ZNSt8ios_base4InitD1Ev;\t.scl\t2;\t.type\t32;\t.endef\n\t.def\t__ZNSt8ios_base4InitC1Ev;\t.scl\t2;\t.type\t32;\t.endef\n\t.def\t_atexit;\t.scl\t2;\t.type\t32;\t.endef\n```\n\n可以看到，在汇编码中编译器将模板`void Fun(T a,T b)`分别针对类型`int`和类型`float`进行了两次具体实现，这不是和没有使用模板，直接写两个函数一样么？没错就是一样的，只是C++将这个工作交从程序员手里移交给了编译器来做。\n\n事实上C++对函数模板进行了<font color=red>两次编译</font>，第一次编译仅仅生成一个函数头，第二次编译则是在函数调用时根据模板的类型参数列表具体的实现这个模板对应的类型的函数实例，注意这里是根据类型参数列表来实现，而不是根据调用次数，如：\n\n```c++\nFun(1, 2);\nFun(0.1, 0.2);\n```\n\n编译器实现两个模板实例`int`和`float`\n\n```c++\nFun(1, 2);\nFun(3 ,4);\nFun(0.1, 0.2);\n```\n\n编译器还是实现两个模板实例`int`和`float`\n\n由此可以看出\n\n<font color=red> 编译器并不是把函数模板处理成能够处理任意类的函数</font>\n\n<font color=red>编译器将函数模板根据具体类型产生不同的函数</font>\n\n<font color=red>编译器会对函数模板进行两次编译，在申明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。</font>\n\ng++命令的使用\n\n首先电脑里要有g++这个软件，我这里使用的是Qt里集成的g++软件\n\n![](【C++】C++函数模板的实现机制剖析/Snipaste_2019-10-03_19-57-21.png)\n\n然后右键我的电脑-->属性-->高级环境设置-->环境变量-->系统变量/Path-->编辑\n\n![](【C++】C++函数模板的实现机制剖析/Snipaste_2019-10-03_20-07-41.png)\n\n再然后新建-->将g++.exe所在的路径拷贝到新建的环境变量中\n\n![](【C++】C++函数模板的实现机制剖析/Snipaste_2019-10-03_20-08-21.png)\n\n测试一下，win+r-->cmd-->任意目录键入g++\n\n![](【C++】C++函数模板的实现机制剖析/Snipaste_2019-10-03_20-12-24.png)\n\n可以看到系统没有提示无此命令，说明配置成功","source":"_posts/【C++】C++函数模板的实现机制剖析.md","raw":"---\ntitle: 【C++】C++函数模板的实现机制剖析\ndate: 2019-10-03 20:14:23\ntags: CPlus\ncategories: 知识记录\n---\n\n\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 函数模板的实现机制剖析\n\n要剖析函数模板的实现机制，我们要先了解程序的编译过程，这里以gcc为例\n\n![](【C++】C++函数模板的实现机制剖析/Snipaste_2019-10-03_16-51-51.png)\n\n这里对下面代码进行剖析\n\n```c++\n#include \"stdafx.h\"//这是VS的固有头文件\n#include <iostream>\nusing namespace std;\n\ntemplate <typename T>\nvoid Fun(T a,T b)\n{\n\ta = a + b;\n\tcout << \"我是函数模板\" << endl;\n}\nint main()\n{\n\tFun(1, 2);\n\tFun(0.1, 0.2);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n打开控制台，使用命令生成汇编文件(当然环境变量里需要有g++编译器的路径才能这样使用，具体操作放在文末)\n\n```shell\ng++ -S 1.cpp -o 1.s\n```\n\n我们来查看汇编文件\n\n```pascal\n\t.file\t\"C++.cpp\"\n.lcomm __ZStL8__ioinit,1,1\n\t.def\t___main;\t.scl\t2;\t.type\t32;\t.endef\n\t.section .rdata,\"dr\"\nLC2:\n\t.ascii \"pause\\0\"\n\t.text\n\t.globl\t_main\n\t.def\t_main;\t.scl\t2;\t.type\t32;\t.endef\n_main:\nLFB1062:\n\t.cfi_startproc\n\tpushl\t%ebp\n\t.cfi_def_cfa_offset 8\n\t.cfi_offset 5, -8\n\tmovl\t%esp, %ebp\n\t.cfi_def_cfa_register 5\n\tandl\t$-16, %esp\n\tsubl\t$16, %esp\n\tcall\t___main//--------------进入main函数\n\tmovl\t$2, 4(%esp)\n\tmovl\t$1, (%esp)\n\tcall\t__Z3FunIiEvT_S0_//-----第一次调用函数模板\n\tfldl\tLC0\n\tfstpl\t8(%esp)\n\tfldl\tLC1\n\tfstpl\t(%esp)\n\tcall\t__Z3FunIdEvT_S0_//-----第二次调用函数模板\n\tmovl\t$LC2, (%esp)\n\tcall\t_system\n\tmovl\t$0, %eax\n\tleave\n\t.cfi_restore 5\n\t.cfi_def_cfa 4, 4\n\tret\n\t.cfi_endproc\nLFE1062:\n\t.section .rdata,\"dr\"\nLC4:\n\t.ascii \"\\316\\322\\312\\307\\272\\257\\312\\375\\304\\243\\260\\345\\0\"\n\t.section\t.text$_Z3FunIiEvT_S0_,\"x\"\n\t.linkonce discard\n\t.globl\t__Z3FunIiEvT_S0_\n\t.def\t__Z3FunIiEvT_S0_;\t.scl\t2;\t.type\t32;\t.endef\n__Z3FunIiEvT_S0_://------------第一次调用时函数模板的具体实现\nLFB1063:\n\t.cfi_startproc\n\tpushl\t%ebp\n\t.cfi_def_cfa_offset 8\n\t.cfi_offset 5, -8\n\tmovl\t%esp, %ebp\n\t.cfi_def_cfa_register 5\n\tsubl\t$24, %esp\n\tmovl\t12(%ebp), %eax\n\taddl\t%eax, 8(%ebp)\n\tmovl\t$LC4, 4(%esp)\n\tmovl\t$__ZSt4cout, (%esp)\n\tcall\t__ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc\n\tmovl\t$__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_, (%esp)\n\tmovl\t%eax, %ecx\n\tcall\t__ZNSolsEPFRSoS_E\n\tsubl\t$4, %esp\n\tnop\n\tleave\n\t.cfi_restore 5\n\t.cfi_def_cfa 4, 4\n\tret\n\t.cfi_endproc\nLFE1063:\n\t.section\t.text$_Z3FunIdEvT_S0_,\"x\"\n\t.linkonce discard\n\t.globl\t__Z3FunIdEvT_S0_//-第二次调用时函数模板的具体实现\n\t.def\t__Z3FunIdEvT_S0_;\t.scl\t2;\t.type\t32;\t.endef\n__Z3FunIdEvT_S0_:\nLFB1064:\n\t.cfi_startproc\n\tpushl\t%ebp\n\t.cfi_def_cfa_offset 8\n\t.cfi_offset 5, -8\n\tmovl\t%esp, %ebp\n\t.cfi_def_cfa_register 5\n\tsubl\t$40, %esp\n\tmovl\t8(%ebp), %eax\n\tmovl\t%eax, -16(%ebp)\n\tmovl\t12(%ebp), %eax\n\tmovl\t%eax, -12(%ebp)\n\tmovl\t16(%ebp), %eax\n\tmovl\t%eax, -24(%ebp)\n\tmovl\t20(%ebp), %eax\n\tmovl\t%eax, -20(%ebp)\n\tfldl\t-16(%ebp)\n\tfaddl\t-24(%ebp)\n\tfstpl\t-16(%ebp)\n\tmovl\t$LC4, 4(%esp)\n\tmovl\t$__ZSt4cout, (%esp)\n\tcall\t__ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc\n\tmovl\t$__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_, (%esp)\n\tmovl\t%eax, %ecx\n\tcall\t__ZNSolsEPFRSoS_E\n\tsubl\t$4, %esp\n\tnop\n\tleave\n\t.cfi_restore 5\n\t.cfi_def_cfa 4, 4\n\tret\n\t.cfi_endproc\nLFE1064:\n\t.text\n\t.def\t___tcf_0;\t.scl\t3;\t.type\t32;\t.endef\n___tcf_0:\nLFB1074:\n\t.cfi_startproc\n\tpushl\t%ebp\n\t.cfi_def_cfa_offset 8\n\t.cfi_offset 5, -8\n\tmovl\t%esp, %ebp\n\t.cfi_def_cfa_register 5\n\tsubl\t$8, %esp\n\tmovl\t$__ZStL8__ioinit, %ecx\n\tcall\t__ZNSt8ios_base4InitD1Ev\n\tleave\n\t.cfi_restore 5\n\t.cfi_def_cfa 4, 4\n\tret\n\t.cfi_endproc\nLFE1074:\n\t.def\t__Z41__static_initialization_and_destruction_0ii;\t.scl\t3;\t.type\t32;\t.endef\n__Z41__static_initialization_and_destruction_0ii:\nLFB1073:\n\t.cfi_startproc\n\tpushl\t%ebp\n\t.cfi_def_cfa_offset 8\n\t.cfi_offset 5, -8\n\tmovl\t%esp, %ebp\n\t.cfi_def_cfa_register 5\n\tsubl\t$24, %esp\n\tcmpl\t$1, 8(%ebp)\n\tjne\tL8\n\tcmpl\t$65535, 12(%ebp)\n\tjne\tL8\n\tmovl\t$__ZStL8__ioinit, %ecx\n\tcall\t__ZNSt8ios_base4InitC1Ev\n\tmovl\t$___tcf_0, (%esp)\n\tcall\t_atexit\nL8:\n\tnop\n\tleave\n\t.cfi_restore 5\n\t.cfi_def_cfa 4, 4\n\tret\n\t.cfi_endproc\nLFE1073:\n\t.def\t__GLOBAL__sub_I_main;\t.scl\t3;\t.type\t32;\t.endef\n__GLOBAL__sub_I_main:\nLFB1075:\n\t.cfi_startproc\n\tpushl\t%ebp\n\t.cfi_def_cfa_offset 8\n\t.cfi_offset 5, -8\n\tmovl\t%esp, %ebp\n\t.cfi_def_cfa_register 5\n\tsubl\t$24, %esp\n\tmovl\t$65535, 4(%esp)\n\tmovl\t$1, (%esp)\n\tcall\t__Z41__static_initialization_and_destruction_0ii\n\tleave\n\t.cfi_restore 5\n\t.cfi_def_cfa 4, 4\n\tret\n\t.cfi_endproc\nLFE1075:\n\t.section\t.ctors,\"w\"\n\t.align 4\n\t.long\t__GLOBAL__sub_I_main\n\t.section .rdata,\"dr\"\n\t.align 8\nLC0:\n\t.long\t-1717986918\n\t.long\t1070176665\n\t.align 8\nLC1:\n\t.long\t-1717986918\n\t.long\t1069128089\n\t.ident\t\"GCC: (i686-posix-dwarf-rev0, Built by MinGW-W64 project) 5.3.0\"\n\t.def\t_system;\t.scl\t2;\t.type\t32;\t.endef\n\t.def\t__ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc;\t.scl\t2;\t.type\t32;\t.endef\n\t.def\t__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_;\t.scl\t2;\t.type\t32;\t.endef\n\t.def\t__ZNSolsEPFRSoS_E;\t.scl\t2;\t.type\t32;\t.endef\n\t.def\t__ZNSt8ios_base4InitD1Ev;\t.scl\t2;\t.type\t32;\t.endef\n\t.def\t__ZNSt8ios_base4InitC1Ev;\t.scl\t2;\t.type\t32;\t.endef\n\t.def\t_atexit;\t.scl\t2;\t.type\t32;\t.endef\n```\n\n可以看到，在汇编码中编译器将模板`void Fun(T a,T b)`分别针对类型`int`和类型`float`进行了两次具体实现，这不是和没有使用模板，直接写两个函数一样么？没错就是一样的，只是C++将这个工作交从程序员手里移交给了编译器来做。\n\n事实上C++对函数模板进行了<font color=red>两次编译</font>，第一次编译仅仅生成一个函数头，第二次编译则是在函数调用时根据模板的类型参数列表具体的实现这个模板对应的类型的函数实例，注意这里是根据类型参数列表来实现，而不是根据调用次数，如：\n\n```c++\nFun(1, 2);\nFun(0.1, 0.2);\n```\n\n编译器实现两个模板实例`int`和`float`\n\n```c++\nFun(1, 2);\nFun(3 ,4);\nFun(0.1, 0.2);\n```\n\n编译器还是实现两个模板实例`int`和`float`\n\n由此可以看出\n\n<font color=red> 编译器并不是把函数模板处理成能够处理任意类的函数</font>\n\n<font color=red>编译器将函数模板根据具体类型产生不同的函数</font>\n\n<font color=red>编译器会对函数模板进行两次编译，在申明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。</font>\n\ng++命令的使用\n\n首先电脑里要有g++这个软件，我这里使用的是Qt里集成的g++软件\n\n![](【C++】C++函数模板的实现机制剖析/Snipaste_2019-10-03_19-57-21.png)\n\n然后右键我的电脑-->属性-->高级环境设置-->环境变量-->系统变量/Path-->编辑\n\n![](【C++】C++函数模板的实现机制剖析/Snipaste_2019-10-03_20-07-41.png)\n\n再然后新建-->将g++.exe所在的路径拷贝到新建的环境变量中\n\n![](【C++】C++函数模板的实现机制剖析/Snipaste_2019-10-03_20-08-21.png)\n\n测试一下，win+r-->cmd-->任意目录键入g++\n\n![](【C++】C++函数模板的实现机制剖析/Snipaste_2019-10-03_20-12-24.png)\n\n可以看到系统没有提示无此命令，说明配置成功","slug":"【C++】C++函数模板的实现机制剖析","published":1,"updated":"2021-03-17T07:18:17.619Z","_id":"ckk9hocaj000adwr7ajrd7mo3","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h1 id=\"函数模板的实现机制剖析\"><a href=\"#函数模板的实现机制剖析\" class=\"headerlink\" title=\"函数模板的实现机制剖析\"></a>函数模板的实现机制剖析</h1><p>要剖析函数模板的实现机制，我们要先了解程序的编译过程，这里以gcc为例</p>\n<p><img src=\"/2019/10/03/%E3%80%90C++%E3%80%91C++%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%89%96%E6%9E%90/Snipaste_2019-10-03_16-51-51.png\"></p>\n<p>这里对下面代码进行剖析</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;stdafx.h&quot;</span><span class=\"hljs-comment\">//这是VS的固有头文件</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;<br><br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Fun</span><span class=\"hljs-params\">(T a,T b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\ta = a + b;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;我是函数模板&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tFun(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);<br>\tFun(<span class=\"hljs-number\">0.1</span>, <span class=\"hljs-number\">0.2</span>);<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>打开控制台，使用命令生成汇编文件(当然环境变量里需要有g++编译器的路径才能这样使用，具体操作放在文末)</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">g++ -S 1.cpp -o 1.s<br></code></pre></td></tr></table></figure>\n<p>我们来查看汇编文件</p>\n<figure class=\"highlight pascal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pascal\">\t.file\t&quot;C++.cpp&quot;<br>.lcomm __ZStL8__ioinit,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span><br>\t.def\t___main;\t.scl\t<span class=\"hljs-number\">2</span>;\t.<span class=\"hljs-keyword\">type</span>\t<span class=\"hljs-number\">32</span>;\t.endef<br>\t.section .rdata,&quot;dr&quot;<br>LC2:<br>\t.ascii &quot;pause\\0&quot;<br>\t.text<br>\t.globl\t_main<br>\t.def\t_main;\t.scl\t<span class=\"hljs-number\">2</span>;\t.<span class=\"hljs-keyword\">type</span>\t<span class=\"hljs-number\">32</span>;\t.endef<br>_main:<br>LFB1062:<br>\t.cfi_startproc<br>\tpushl\t%ebp<br>\t.cfi_def_cfa_offset <span class=\"hljs-number\">8</span><br>\t.cfi_offset <span class=\"hljs-number\">5</span>, -<span class=\"hljs-number\">8</span><br>\tmovl\t%esp, %ebp<br>\t.cfi_def_cfa_register <span class=\"hljs-number\">5</span><br>\tandl\t$-<span class=\"hljs-number\">16</span>, %esp<br>\tsubl\t<span class=\"hljs-number\">$16</span>, %esp<br>\tcall\t___main<span class=\"hljs-comment\">//--------------进入main函数</span><br>\tmovl\t<span class=\"hljs-number\">$2</span>, <span class=\"hljs-number\">4</span>(%esp)<br>\tmovl\t<span class=\"hljs-number\">$1</span>, (%esp)<br>\tcall\t__Z3FunIiEvT_S0_<span class=\"hljs-comment\">//-----第一次调用函数模板</span><br>\tfldl\tLC0<br>\tfstpl\t<span class=\"hljs-number\">8</span>(%esp)<br>\tfldl\tLC1<br>\tfstpl\t(%esp)<br>\tcall\t__Z3FunIdEvT_S0_<span class=\"hljs-comment\">//-----第二次调用函数模板</span><br>\tmovl\t$LC2, (%esp)<br>\tcall\t_system<br>\tmovl\t<span class=\"hljs-number\">$0</span>, %eax<br>\tleave<br>\t.cfi_restore <span class=\"hljs-number\">5</span><br>\t.cfi_def_cfa <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">4</span><br>\tret<br>\t.cfi_endproc<br>LFE1062:<br>\t.section .rdata,&quot;dr&quot;<br>LC4:<br>\t.ascii &quot;\\316\\322\\312\\307\\272\\257\\312\\375\\304\\243\\260\\345\\0&quot;<br>\t.section\t.text$_Z3FunIiEvT_S0_,&quot;x&quot;<br>\t.linkonce discard<br>\t.globl\t__Z3FunIiEvT_S0_<br>\t.def\t__Z3FunIiEvT_S0_;\t.scl\t<span class=\"hljs-number\">2</span>;\t.<span class=\"hljs-keyword\">type</span>\t<span class=\"hljs-number\">32</span>;\t.endef<br>__Z3FunIiEvT_S0_:<span class=\"hljs-comment\">//------------第一次调用时函数模板的具体实现</span><br>LFB1063:<br>\t.cfi_startproc<br>\tpushl\t%ebp<br>\t.cfi_def_cfa_offset <span class=\"hljs-number\">8</span><br>\t.cfi_offset <span class=\"hljs-number\">5</span>, -<span class=\"hljs-number\">8</span><br>\tmovl\t%esp, %ebp<br>\t.cfi_def_cfa_register <span class=\"hljs-number\">5</span><br>\tsubl\t<span class=\"hljs-number\">$24</span>, %esp<br>\tmovl\t<span class=\"hljs-number\">12</span>(%ebp), %eax<br>\taddl\t%eax, <span class=\"hljs-number\">8</span>(%ebp)<br>\tmovl\t$LC4, 4(%esp)<br>\tmovl\t$__ZSt4cout, (%esp)<br>\tcall\t__ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc<br>\tmovl\t$__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_, (%esp)<br>\tmovl\t%eax, %ecx<br>\tcall\t__ZNSolsEPFRSoS_E<br>\tsubl\t<span class=\"hljs-number\">$4</span>, %esp<br>\tnop<br>\tleave<br>\t.cfi_restore <span class=\"hljs-number\">5</span><br>\t.cfi_def_cfa <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">4</span><br>\tret<br>\t.cfi_endproc<br>LFE1063:<br>\t.section\t.text$_Z3FunIdEvT_S0_,&quot;x&quot;<br>\t.linkonce discard<br>\t.globl\t__Z3FunIdEvT_S0_<span class=\"hljs-comment\">//-第二次调用时函数模板的具体实现</span><br>\t.def\t__Z3FunIdEvT_S0_;\t.scl\t<span class=\"hljs-number\">2</span>;\t.<span class=\"hljs-keyword\">type</span>\t<span class=\"hljs-number\">32</span>;\t.endef<br>__Z3FunIdEvT_S0_:<br>LFB1064:<br>\t.cfi_startproc<br>\tpushl\t%ebp<br>\t.cfi_def_cfa_offset <span class=\"hljs-number\">8</span><br>\t.cfi_offset <span class=\"hljs-number\">5</span>, -<span class=\"hljs-number\">8</span><br>\tmovl\t%esp, %ebp<br>\t.cfi_def_cfa_register <span class=\"hljs-number\">5</span><br>\tsubl\t<span class=\"hljs-number\">$40</span>, %esp<br>\tmovl\t<span class=\"hljs-number\">8</span>(%ebp), %eax<br>\tmovl\t%eax, -<span class=\"hljs-number\">16</span>(%ebp)<br>\tmovl\t<span class=\"hljs-number\">12</span>(%ebp), %eax<br>\tmovl\t%eax, -<span class=\"hljs-number\">12</span>(%ebp)<br>\tmovl\t<span class=\"hljs-number\">16</span>(%ebp), %eax<br>\tmovl\t%eax, -<span class=\"hljs-number\">24</span>(%ebp)<br>\tmovl\t<span class=\"hljs-number\">20</span>(%ebp), %eax<br>\tmovl\t%eax, -<span class=\"hljs-number\">20</span>(%ebp)<br>\tfldl\t-<span class=\"hljs-number\">16</span>(%ebp)<br>\tfaddl\t-<span class=\"hljs-number\">24</span>(%ebp)<br>\tfstpl\t-<span class=\"hljs-number\">16</span>(%ebp)<br>\tmovl\t$LC4, 4(%esp)<br>\tmovl\t$__ZSt4cout, (%esp)<br>\tcall\t__ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc<br>\tmovl\t$__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_, (%esp)<br>\tmovl\t%eax, %ecx<br>\tcall\t__ZNSolsEPFRSoS_E<br>\tsubl\t<span class=\"hljs-number\">$4</span>, %esp<br>\tnop<br>\tleave<br>\t.cfi_restore <span class=\"hljs-number\">5</span><br>\t.cfi_def_cfa <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">4</span><br>\tret<br>\t.cfi_endproc<br>LFE1064:<br>\t.text<br>\t.def\t___tcf_0;\t.scl\t<span class=\"hljs-number\">3</span>;\t.<span class=\"hljs-keyword\">type</span>\t<span class=\"hljs-number\">32</span>;\t.endef<br>___tcf_0:<br>LFB1074:<br>\t.cfi_startproc<br>\tpushl\t%ebp<br>\t.cfi_def_cfa_offset <span class=\"hljs-number\">8</span><br>\t.cfi_offset <span class=\"hljs-number\">5</span>, -<span class=\"hljs-number\">8</span><br>\tmovl\t%esp, %ebp<br>\t.cfi_def_cfa_register <span class=\"hljs-number\">5</span><br>\tsubl\t<span class=\"hljs-number\">$8</span>, %esp<br>\tmovl\t$__ZStL8__ioinit, %ecx<br>\tcall\t__ZNSt8ios_base4InitD1Ev<br>\tleave<br>\t.cfi_restore <span class=\"hljs-number\">5</span><br>\t.cfi_def_cfa <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">4</span><br>\tret<br>\t.cfi_endproc<br>LFE1074:<br>\t.def\t__Z41__static_initialization_and_destruction_0ii;\t.scl\t<span class=\"hljs-number\">3</span>;\t.<span class=\"hljs-keyword\">type</span>\t<span class=\"hljs-number\">32</span>;\t.endef<br>__Z41__static_initialization_and_destruction_0ii:<br>LFB1073:<br>\t.cfi_startproc<br>\tpushl\t%ebp<br>\t.cfi_def_cfa_offset <span class=\"hljs-number\">8</span><br>\t.cfi_offset <span class=\"hljs-number\">5</span>, -<span class=\"hljs-number\">8</span><br>\tmovl\t%esp, %ebp<br>\t.cfi_def_cfa_register <span class=\"hljs-number\">5</span><br>\tsubl\t<span class=\"hljs-number\">$24</span>, %esp<br>\tcmpl\t<span class=\"hljs-number\">$1</span>, <span class=\"hljs-number\">8</span>(%ebp)<br>\tjne\tL8<br>\tcmpl\t<span class=\"hljs-number\">$65535</span>, <span class=\"hljs-number\">12</span>(%ebp)<br>\tjne\tL8<br>\tmovl\t$__ZStL8__ioinit, %ecx<br>\tcall\t__ZNSt8ios_base4InitC1Ev<br>\tmovl\t$___tcf_0, (%esp)<br>\tcall\t_atexit<br>L8:<br>\tnop<br>\tleave<br>\t.cfi_restore <span class=\"hljs-number\">5</span><br>\t.cfi_def_cfa <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">4</span><br>\tret<br>\t.cfi_endproc<br>LFE1073:<br>\t.def\t__GLOBAL__sub_I_main;\t.scl\t<span class=\"hljs-number\">3</span>;\t.<span class=\"hljs-keyword\">type</span>\t<span class=\"hljs-number\">32</span>;\t.endef<br>__GLOBAL__sub_I_main:<br>LFB1075:<br>\t.cfi_startproc<br>\tpushl\t%ebp<br>\t.cfi_def_cfa_offset <span class=\"hljs-number\">8</span><br>\t.cfi_offset <span class=\"hljs-number\">5</span>, -<span class=\"hljs-number\">8</span><br>\tmovl\t%esp, %ebp<br>\t.cfi_def_cfa_register <span class=\"hljs-number\">5</span><br>\tsubl\t<span class=\"hljs-number\">$24</span>, %esp<br>\tmovl\t<span class=\"hljs-number\">$65535</span>, <span class=\"hljs-number\">4</span>(%esp)<br>\tmovl\t<span class=\"hljs-number\">$1</span>, (%esp)<br>\tcall\t__Z41__static_initialization_and_destruction_0ii<br>\tleave<br>\t.cfi_restore <span class=\"hljs-number\">5</span><br>\t.cfi_def_cfa <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">4</span><br>\tret<br>\t.cfi_endproc<br>LFE1075:<br>\t.section\t.ctors,&quot;w&quot;<br>\t.align <span class=\"hljs-number\">4</span><br>\t.long\t__GLOBAL__sub_I_main<br>\t.section .rdata,&quot;dr&quot;<br>\t.align <span class=\"hljs-number\">8</span><br>LC0:<br>\t.long\t-<span class=\"hljs-number\">1717986918</span><br>\t.long\t<span class=\"hljs-number\">1070176665</span><br>\t.align <span class=\"hljs-number\">8</span><br>LC1:<br>\t.long\t-<span class=\"hljs-number\">1717986918</span><br>\t.long\t<span class=\"hljs-number\">1069128089</span><br>\t.ident\t&quot;GCC: (i686-posix-dwarf-rev0, Built by MinGW-W64 project) 5.3.0&quot;<br>\t.def\t_system;\t.scl\t<span class=\"hljs-number\">2</span>;\t.<span class=\"hljs-keyword\">type</span>\t<span class=\"hljs-number\">32</span>;\t.endef<br>\t.def\t__ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc;\t.scl\t<span class=\"hljs-number\">2</span>;\t.<span class=\"hljs-keyword\">type</span>\t<span class=\"hljs-number\">32</span>;\t.endef<br>\t.def\t__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_;\t.scl\t<span class=\"hljs-number\">2</span>;\t.<span class=\"hljs-keyword\">type</span>\t<span class=\"hljs-number\">32</span>;\t.endef<br>\t.def\t__ZNSolsEPFRSoS_E;\t.scl\t<span class=\"hljs-number\">2</span>;\t.<span class=\"hljs-keyword\">type</span>\t<span class=\"hljs-number\">32</span>;\t.endef<br>\t.def\t__ZNSt8ios_base4InitD1Ev;\t.scl\t<span class=\"hljs-number\">2</span>;\t.<span class=\"hljs-keyword\">type</span>\t<span class=\"hljs-number\">32</span>;\t.endef<br>\t.def\t__ZNSt8ios_base4InitC1Ev;\t.scl\t<span class=\"hljs-number\">2</span>;\t.<span class=\"hljs-keyword\">type</span>\t<span class=\"hljs-number\">32</span>;\t.endef<br>\t.def\t_atexit;\t.scl\t<span class=\"hljs-number\">2</span>;\t.<span class=\"hljs-keyword\">type</span>\t<span class=\"hljs-number\">32</span>;\t.endef<br></code></pre></td></tr></table></figure>\n<p>可以看到，在汇编码中编译器将模板<code>void Fun(T a,T b)</code>分别针对类型<code>int</code>和类型<code>float</code>进行了两次具体实现，这不是和没有使用模板，直接写两个函数一样么？没错就是一样的，只是C++将这个工作交从程序员手里移交给了编译器来做。</p>\n<p>事实上C++对函数模板进行了<font color=\"red\">两次编译</font>，第一次编译仅仅生成一个函数头，第二次编译则是在函数调用时根据模板的类型参数列表具体的实现这个模板对应的类型的函数实例，注意这里是根据类型参数列表来实现，而不是根据调用次数，如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">Fun(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);<br>Fun(<span class=\"hljs-number\">0.1</span>, <span class=\"hljs-number\">0.2</span>);<br></code></pre></td></tr></table></figure>\n<p>编译器实现两个模板实例<code>int</code>和<code>float</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">Fun(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);<br>Fun(<span class=\"hljs-number\">3</span> ,<span class=\"hljs-number\">4</span>);<br>Fun(<span class=\"hljs-number\">0.1</span>, <span class=\"hljs-number\">0.2</span>);<br></code></pre></td></tr></table></figure>\n<p>编译器还是实现两个模板实例<code>int</code>和<code>float</code></p>\n<p>由此可以看出</p>\n<p><font color=\"red\"> 编译器并不是把函数模板处理成能够处理任意类的函数</font></p>\n<p><font color=\"red\">编译器将函数模板根据具体类型产生不同的函数</font></p>\n<p><font color=\"red\">编译器会对函数模板进行两次编译，在申明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。</font></p>\n<p>g++命令的使用</p>\n<p>首先电脑里要有g++这个软件，我这里使用的是Qt里集成的g++软件</p>\n<p><img src=\"/2019/10/03/%E3%80%90C++%E3%80%91C++%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%89%96%E6%9E%90/Snipaste_2019-10-03_19-57-21.png\"></p>\n<p>然后右键我的电脑–&gt;属性–&gt;高级环境设置–&gt;环境变量–&gt;系统变量/Path–&gt;编辑</p>\n<p><img src=\"/2019/10/03/%E3%80%90C++%E3%80%91C++%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%89%96%E6%9E%90/Snipaste_2019-10-03_20-07-41.png\"></p>\n<p>再然后新建–&gt;将g++.exe所在的路径拷贝到新建的环境变量中</p>\n<p><img src=\"/2019/10/03/%E3%80%90C++%E3%80%91C++%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%89%96%E6%9E%90/Snipaste_2019-10-03_20-08-21.png\"></p>\n<p>测试一下，win+r–&gt;cmd–&gt;任意目录键入g++</p>\n<p><img src=\"/2019/10/03/%E3%80%90C++%E3%80%91C++%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%89%96%E6%9E%90/Snipaste_2019-10-03_20-12-24.png\"></p>\n<p>可以看到系统没有提示无此命令，说明配置成功</p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h1 id=\"函数模板的实现机制剖析\"><a href=\"#函数模板的实现机制剖析\" class=\"headerlink\" title=\"函数模板的实现机制剖析\"></a>函数模板的实现机制剖析</h1><p>要剖析函数模板的实现机制，我们要先了解程序的编译过程，这里以gcc为例</p>\n<p><img src=\"/2019/10/03/%E3%80%90C++%E3%80%91C++%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%89%96%E6%9E%90/Snipaste_2019-10-03_16-51-51.png\"></p>\n<p>这里对下面代码进行剖析</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;stdafx.h&quot;</span><span class=\"hljs-comment\">//这是VS的固有头文件</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;<br><br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Fun</span><span class=\"hljs-params\">(T a,T b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\ta = a + b;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;我是函数模板&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tFun(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);<br>\tFun(<span class=\"hljs-number\">0.1</span>, <span class=\"hljs-number\">0.2</span>);<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>打开控制台，使用命令生成汇编文件(当然环境变量里需要有g++编译器的路径才能这样使用，具体操作放在文末)</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">g++ -S 1.cpp -o 1.s<br></code></pre></td></tr></table></figure>\n<p>我们来查看汇编文件</p>\n<figure class=\"highlight pascal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pascal\">\t.file\t&quot;C++.cpp&quot;<br>.lcomm __ZStL8__ioinit,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span><br>\t.def\t___main;\t.scl\t<span class=\"hljs-number\">2</span>;\t.<span class=\"hljs-keyword\">type</span>\t<span class=\"hljs-number\">32</span>;\t.endef<br>\t.section .rdata,&quot;dr&quot;<br>LC2:<br>\t.ascii &quot;pause\\0&quot;<br>\t.text<br>\t.globl\t_main<br>\t.def\t_main;\t.scl\t<span class=\"hljs-number\">2</span>;\t.<span class=\"hljs-keyword\">type</span>\t<span class=\"hljs-number\">32</span>;\t.endef<br>_main:<br>LFB1062:<br>\t.cfi_startproc<br>\tpushl\t%ebp<br>\t.cfi_def_cfa_offset <span class=\"hljs-number\">8</span><br>\t.cfi_offset <span class=\"hljs-number\">5</span>, -<span class=\"hljs-number\">8</span><br>\tmovl\t%esp, %ebp<br>\t.cfi_def_cfa_register <span class=\"hljs-number\">5</span><br>\tandl\t$-<span class=\"hljs-number\">16</span>, %esp<br>\tsubl\t<span class=\"hljs-number\">$16</span>, %esp<br>\tcall\t___main<span class=\"hljs-comment\">//--------------进入main函数</span><br>\tmovl\t<span class=\"hljs-number\">$2</span>, <span class=\"hljs-number\">4</span>(%esp)<br>\tmovl\t<span class=\"hljs-number\">$1</span>, (%esp)<br>\tcall\t__Z3FunIiEvT_S0_<span class=\"hljs-comment\">//-----第一次调用函数模板</span><br>\tfldl\tLC0<br>\tfstpl\t<span class=\"hljs-number\">8</span>(%esp)<br>\tfldl\tLC1<br>\tfstpl\t(%esp)<br>\tcall\t__Z3FunIdEvT_S0_<span class=\"hljs-comment\">//-----第二次调用函数模板</span><br>\tmovl\t$LC2, (%esp)<br>\tcall\t_system<br>\tmovl\t<span class=\"hljs-number\">$0</span>, %eax<br>\tleave<br>\t.cfi_restore <span class=\"hljs-number\">5</span><br>\t.cfi_def_cfa <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">4</span><br>\tret<br>\t.cfi_endproc<br>LFE1062:<br>\t.section .rdata,&quot;dr&quot;<br>LC4:<br>\t.ascii &quot;\\316\\322\\312\\307\\272\\257\\312\\375\\304\\243\\260\\345\\0&quot;<br>\t.section\t.text$_Z3FunIiEvT_S0_,&quot;x&quot;<br>\t.linkonce discard<br>\t.globl\t__Z3FunIiEvT_S0_<br>\t.def\t__Z3FunIiEvT_S0_;\t.scl\t<span class=\"hljs-number\">2</span>;\t.<span class=\"hljs-keyword\">type</span>\t<span class=\"hljs-number\">32</span>;\t.endef<br>__Z3FunIiEvT_S0_:<span class=\"hljs-comment\">//------------第一次调用时函数模板的具体实现</span><br>LFB1063:<br>\t.cfi_startproc<br>\tpushl\t%ebp<br>\t.cfi_def_cfa_offset <span class=\"hljs-number\">8</span><br>\t.cfi_offset <span class=\"hljs-number\">5</span>, -<span class=\"hljs-number\">8</span><br>\tmovl\t%esp, %ebp<br>\t.cfi_def_cfa_register <span class=\"hljs-number\">5</span><br>\tsubl\t<span class=\"hljs-number\">$24</span>, %esp<br>\tmovl\t<span class=\"hljs-number\">12</span>(%ebp), %eax<br>\taddl\t%eax, <span class=\"hljs-number\">8</span>(%ebp)<br>\tmovl\t$LC4, 4(%esp)<br>\tmovl\t$__ZSt4cout, (%esp)<br>\tcall\t__ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc<br>\tmovl\t$__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_, (%esp)<br>\tmovl\t%eax, %ecx<br>\tcall\t__ZNSolsEPFRSoS_E<br>\tsubl\t<span class=\"hljs-number\">$4</span>, %esp<br>\tnop<br>\tleave<br>\t.cfi_restore <span class=\"hljs-number\">5</span><br>\t.cfi_def_cfa <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">4</span><br>\tret<br>\t.cfi_endproc<br>LFE1063:<br>\t.section\t.text$_Z3FunIdEvT_S0_,&quot;x&quot;<br>\t.linkonce discard<br>\t.globl\t__Z3FunIdEvT_S0_<span class=\"hljs-comment\">//-第二次调用时函数模板的具体实现</span><br>\t.def\t__Z3FunIdEvT_S0_;\t.scl\t<span class=\"hljs-number\">2</span>;\t.<span class=\"hljs-keyword\">type</span>\t<span class=\"hljs-number\">32</span>;\t.endef<br>__Z3FunIdEvT_S0_:<br>LFB1064:<br>\t.cfi_startproc<br>\tpushl\t%ebp<br>\t.cfi_def_cfa_offset <span class=\"hljs-number\">8</span><br>\t.cfi_offset <span class=\"hljs-number\">5</span>, -<span class=\"hljs-number\">8</span><br>\tmovl\t%esp, %ebp<br>\t.cfi_def_cfa_register <span class=\"hljs-number\">5</span><br>\tsubl\t<span class=\"hljs-number\">$40</span>, %esp<br>\tmovl\t<span class=\"hljs-number\">8</span>(%ebp), %eax<br>\tmovl\t%eax, -<span class=\"hljs-number\">16</span>(%ebp)<br>\tmovl\t<span class=\"hljs-number\">12</span>(%ebp), %eax<br>\tmovl\t%eax, -<span class=\"hljs-number\">12</span>(%ebp)<br>\tmovl\t<span class=\"hljs-number\">16</span>(%ebp), %eax<br>\tmovl\t%eax, -<span class=\"hljs-number\">24</span>(%ebp)<br>\tmovl\t<span class=\"hljs-number\">20</span>(%ebp), %eax<br>\tmovl\t%eax, -<span class=\"hljs-number\">20</span>(%ebp)<br>\tfldl\t-<span class=\"hljs-number\">16</span>(%ebp)<br>\tfaddl\t-<span class=\"hljs-number\">24</span>(%ebp)<br>\tfstpl\t-<span class=\"hljs-number\">16</span>(%ebp)<br>\tmovl\t$LC4, 4(%esp)<br>\tmovl\t$__ZSt4cout, (%esp)<br>\tcall\t__ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc<br>\tmovl\t$__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_, (%esp)<br>\tmovl\t%eax, %ecx<br>\tcall\t__ZNSolsEPFRSoS_E<br>\tsubl\t<span class=\"hljs-number\">$4</span>, %esp<br>\tnop<br>\tleave<br>\t.cfi_restore <span class=\"hljs-number\">5</span><br>\t.cfi_def_cfa <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">4</span><br>\tret<br>\t.cfi_endproc<br>LFE1064:<br>\t.text<br>\t.def\t___tcf_0;\t.scl\t<span class=\"hljs-number\">3</span>;\t.<span class=\"hljs-keyword\">type</span>\t<span class=\"hljs-number\">32</span>;\t.endef<br>___tcf_0:<br>LFB1074:<br>\t.cfi_startproc<br>\tpushl\t%ebp<br>\t.cfi_def_cfa_offset <span class=\"hljs-number\">8</span><br>\t.cfi_offset <span class=\"hljs-number\">5</span>, -<span class=\"hljs-number\">8</span><br>\tmovl\t%esp, %ebp<br>\t.cfi_def_cfa_register <span class=\"hljs-number\">5</span><br>\tsubl\t<span class=\"hljs-number\">$8</span>, %esp<br>\tmovl\t$__ZStL8__ioinit, %ecx<br>\tcall\t__ZNSt8ios_base4InitD1Ev<br>\tleave<br>\t.cfi_restore <span class=\"hljs-number\">5</span><br>\t.cfi_def_cfa <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">4</span><br>\tret<br>\t.cfi_endproc<br>LFE1074:<br>\t.def\t__Z41__static_initialization_and_destruction_0ii;\t.scl\t<span class=\"hljs-number\">3</span>;\t.<span class=\"hljs-keyword\">type</span>\t<span class=\"hljs-number\">32</span>;\t.endef<br>__Z41__static_initialization_and_destruction_0ii:<br>LFB1073:<br>\t.cfi_startproc<br>\tpushl\t%ebp<br>\t.cfi_def_cfa_offset <span class=\"hljs-number\">8</span><br>\t.cfi_offset <span class=\"hljs-number\">5</span>, -<span class=\"hljs-number\">8</span><br>\tmovl\t%esp, %ebp<br>\t.cfi_def_cfa_register <span class=\"hljs-number\">5</span><br>\tsubl\t<span class=\"hljs-number\">$24</span>, %esp<br>\tcmpl\t<span class=\"hljs-number\">$1</span>, <span class=\"hljs-number\">8</span>(%ebp)<br>\tjne\tL8<br>\tcmpl\t<span class=\"hljs-number\">$65535</span>, <span class=\"hljs-number\">12</span>(%ebp)<br>\tjne\tL8<br>\tmovl\t$__ZStL8__ioinit, %ecx<br>\tcall\t__ZNSt8ios_base4InitC1Ev<br>\tmovl\t$___tcf_0, (%esp)<br>\tcall\t_atexit<br>L8:<br>\tnop<br>\tleave<br>\t.cfi_restore <span class=\"hljs-number\">5</span><br>\t.cfi_def_cfa <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">4</span><br>\tret<br>\t.cfi_endproc<br>LFE1073:<br>\t.def\t__GLOBAL__sub_I_main;\t.scl\t<span class=\"hljs-number\">3</span>;\t.<span class=\"hljs-keyword\">type</span>\t<span class=\"hljs-number\">32</span>;\t.endef<br>__GLOBAL__sub_I_main:<br>LFB1075:<br>\t.cfi_startproc<br>\tpushl\t%ebp<br>\t.cfi_def_cfa_offset <span class=\"hljs-number\">8</span><br>\t.cfi_offset <span class=\"hljs-number\">5</span>, -<span class=\"hljs-number\">8</span><br>\tmovl\t%esp, %ebp<br>\t.cfi_def_cfa_register <span class=\"hljs-number\">5</span><br>\tsubl\t<span class=\"hljs-number\">$24</span>, %esp<br>\tmovl\t<span class=\"hljs-number\">$65535</span>, <span class=\"hljs-number\">4</span>(%esp)<br>\tmovl\t<span class=\"hljs-number\">$1</span>, (%esp)<br>\tcall\t__Z41__static_initialization_and_destruction_0ii<br>\tleave<br>\t.cfi_restore <span class=\"hljs-number\">5</span><br>\t.cfi_def_cfa <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">4</span><br>\tret<br>\t.cfi_endproc<br>LFE1075:<br>\t.section\t.ctors,&quot;w&quot;<br>\t.align <span class=\"hljs-number\">4</span><br>\t.long\t__GLOBAL__sub_I_main<br>\t.section .rdata,&quot;dr&quot;<br>\t.align <span class=\"hljs-number\">8</span><br>LC0:<br>\t.long\t-<span class=\"hljs-number\">1717986918</span><br>\t.long\t<span class=\"hljs-number\">1070176665</span><br>\t.align <span class=\"hljs-number\">8</span><br>LC1:<br>\t.long\t-<span class=\"hljs-number\">1717986918</span><br>\t.long\t<span class=\"hljs-number\">1069128089</span><br>\t.ident\t&quot;GCC: (i686-posix-dwarf-rev0, Built by MinGW-W64 project) 5.3.0&quot;<br>\t.def\t_system;\t.scl\t<span class=\"hljs-number\">2</span>;\t.<span class=\"hljs-keyword\">type</span>\t<span class=\"hljs-number\">32</span>;\t.endef<br>\t.def\t__ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc;\t.scl\t<span class=\"hljs-number\">2</span>;\t.<span class=\"hljs-keyword\">type</span>\t<span class=\"hljs-number\">32</span>;\t.endef<br>\t.def\t__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_;\t.scl\t<span class=\"hljs-number\">2</span>;\t.<span class=\"hljs-keyword\">type</span>\t<span class=\"hljs-number\">32</span>;\t.endef<br>\t.def\t__ZNSolsEPFRSoS_E;\t.scl\t<span class=\"hljs-number\">2</span>;\t.<span class=\"hljs-keyword\">type</span>\t<span class=\"hljs-number\">32</span>;\t.endef<br>\t.def\t__ZNSt8ios_base4InitD1Ev;\t.scl\t<span class=\"hljs-number\">2</span>;\t.<span class=\"hljs-keyword\">type</span>\t<span class=\"hljs-number\">32</span>;\t.endef<br>\t.def\t__ZNSt8ios_base4InitC1Ev;\t.scl\t<span class=\"hljs-number\">2</span>;\t.<span class=\"hljs-keyword\">type</span>\t<span class=\"hljs-number\">32</span>;\t.endef<br>\t.def\t_atexit;\t.scl\t<span class=\"hljs-number\">2</span>;\t.<span class=\"hljs-keyword\">type</span>\t<span class=\"hljs-number\">32</span>;\t.endef<br></code></pre></td></tr></table></figure>\n<p>可以看到，在汇编码中编译器将模板<code>void Fun(T a,T b)</code>分别针对类型<code>int</code>和类型<code>float</code>进行了两次具体实现，这不是和没有使用模板，直接写两个函数一样么？没错就是一样的，只是C++将这个工作交从程序员手里移交给了编译器来做。</p>\n<p>事实上C++对函数模板进行了<font color=\"red\">两次编译</font>，第一次编译仅仅生成一个函数头，第二次编译则是在函数调用时根据模板的类型参数列表具体的实现这个模板对应的类型的函数实例，注意这里是根据类型参数列表来实现，而不是根据调用次数，如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">Fun(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);<br>Fun(<span class=\"hljs-number\">0.1</span>, <span class=\"hljs-number\">0.2</span>);<br></code></pre></td></tr></table></figure>\n<p>编译器实现两个模板实例<code>int</code>和<code>float</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">Fun(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);<br>Fun(<span class=\"hljs-number\">3</span> ,<span class=\"hljs-number\">4</span>);<br>Fun(<span class=\"hljs-number\">0.1</span>, <span class=\"hljs-number\">0.2</span>);<br></code></pre></td></tr></table></figure>\n<p>编译器还是实现两个模板实例<code>int</code>和<code>float</code></p>\n<p>由此可以看出</p>\n<p><font color=\"red\"> 编译器并不是把函数模板处理成能够处理任意类的函数</font></p>\n<p><font color=\"red\">编译器将函数模板根据具体类型产生不同的函数</font></p>\n<p><font color=\"red\">编译器会对函数模板进行两次编译，在申明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。</font></p>\n<p>g++命令的使用</p>\n<p>首先电脑里要有g++这个软件，我这里使用的是Qt里集成的g++软件</p>\n<p><img src=\"/2019/10/03/%E3%80%90C++%E3%80%91C++%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%89%96%E6%9E%90/Snipaste_2019-10-03_19-57-21.png\"></p>\n<p>然后右键我的电脑–&gt;属性–&gt;高级环境设置–&gt;环境变量–&gt;系统变量/Path–&gt;编辑</p>\n<p><img src=\"/2019/10/03/%E3%80%90C++%E3%80%91C++%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%89%96%E6%9E%90/Snipaste_2019-10-03_20-07-41.png\"></p>\n<p>再然后新建–&gt;将g++.exe所在的路径拷贝到新建的环境变量中</p>\n<p><img src=\"/2019/10/03/%E3%80%90C++%E3%80%91C++%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%89%96%E6%9E%90/Snipaste_2019-10-03_20-08-21.png\"></p>\n<p>测试一下，win+r–&gt;cmd–&gt;任意目录键入g++</p>\n<p><img src=\"/2019/10/03/%E3%80%90C++%E3%80%91C++%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%89%96%E6%9E%90/Snipaste_2019-10-03_20-12-24.png\"></p>\n<p>可以看到系统没有提示无此命令，说明配置成功</p>\n"},{"title":"【C++】C++面向对象模型初探","date":"2019-10-01T13:58:43.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 1.成员的分开存储\n\nC++通过将类的成员分开存储的方式来实现面向对象\n\n| 成员         | 存储位置                                                     |\n| ------------ | ------------------------------------------------------------ |\n| 普通成员变量 | 栈区，与struct变量有相同的内存布局和字节对齐方式             |\n| 静态成员变量 | 全局数据区，如此便可以使用类名和类所有的对象都可以访问       |\n| 成员函数     | 代码段，包括静态成员函数和非静态成员函数                     |\n| 虚函数       | 虚函数表指针(vfptr)存放在栈区，其指向的虚函数表有自身的内存存储空间 |\n\n# 2.C++类的内存分布\n\n要想更好的了解这些，我们还需了解C++类的内存分布\n\n![](【C++】C++面向对象模型初探/Snipaste_2019-10-02_09-07-09.png)\n\n## **Stack：** \n\n栈，存放Automatic Variables，按内存地址由高到低方向生长，其最大大小由编译时确定，速度快，但自由性差，最大空间不大。保存程序中的局部变量。\n\n## **Heap：** \n\n堆，自由申请的空间，按内存地址由低到高方向生长，其大小由系统内存/虚拟内存上限决定，速度较慢，但自由性大，可用空间大。 动态分配的内存在调用malloc（）或者相关函数产生，在调用free()时释放，由程序员决定而不是一系列规则规定内存持续时间，因此内存块可在一个函数中创建，在另一个函数中释放。由于这点，动态内存分配容易导致堆区内存碎片化。\n\n## **.Data：**\n\n 存放程序中<font color=red> 已经初始化的非零全局变量。静态分配。</font>\n\ndata又可分为读写（RW）区域和只读（RO）区域。 \n\n- RO段保存常量所以也被称为`.constdata` eg const数据\n- RW段则是普通非常全局变量，静态变量就在其中\n\n## **.Bss：** \n\n存放程序中**未初始化**的和零值全局变量。静态分配，在程序开始时通常会被清零。\n\n## **.Text：** \n\n也称为代码段(Code)，用来存放程序执行代码，同时也可能会包含一些常量(如一些字符串常量等）。该段内存为静态分配，只读(某些架构可能允许修改)。 \n这块内存是共享的,当有多个相同进程(Process)存在时，共用同一个text段。\n\n------\n\n普通成员变量存储在栈区，使得每一个类的对象都拥有各自独立的普通成员变量。\n\n静态成员变量存储在全局数据区，是的每一个类的对象都共享一份静态\n\n成员变量。\n\n# 3.this指针\n\n那么，存放在代码段的成员函数是怎么区分调用对象的呢？\n\n事实上，<font color=red> C++为每一个函数都隐式定义了一个函数所属类类型的指针形参--this，而this指针永远指向调用函数的对象</font>，如此函数便可以识别调用自身的是类的哪个对象了。\n\n这里有一点要注意，<font color=red> C++并没有为静态成员函数定义this指针，如此，静态成员函数被所有的对象共享</font>。\n\n# 4.总结\n\n通过成员的分开存储和普通成员函数的`this指针`C++便可以识别各个不同的对象，如此便实现了面向对象。","source":"_posts/【C++】C++面向对象模型初探.md","raw":"---\ntitle: 【C++】C++面向对象模型初探\ndate: 2019-10-01 21:58:43\ntags: CPlus\ncategories: 知识记录\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 1.成员的分开存储\n\nC++通过将类的成员分开存储的方式来实现面向对象\n\n| 成员         | 存储位置                                                     |\n| ------------ | ------------------------------------------------------------ |\n| 普通成员变量 | 栈区，与struct变量有相同的内存布局和字节对齐方式             |\n| 静态成员变量 | 全局数据区，如此便可以使用类名和类所有的对象都可以访问       |\n| 成员函数     | 代码段，包括静态成员函数和非静态成员函数                     |\n| 虚函数       | 虚函数表指针(vfptr)存放在栈区，其指向的虚函数表有自身的内存存储空间 |\n\n# 2.C++类的内存分布\n\n要想更好的了解这些，我们还需了解C++类的内存分布\n\n![](【C++】C++面向对象模型初探/Snipaste_2019-10-02_09-07-09.png)\n\n## **Stack：** \n\n栈，存放Automatic Variables，按内存地址由高到低方向生长，其最大大小由编译时确定，速度快，但自由性差，最大空间不大。保存程序中的局部变量。\n\n## **Heap：** \n\n堆，自由申请的空间，按内存地址由低到高方向生长，其大小由系统内存/虚拟内存上限决定，速度较慢，但自由性大，可用空间大。 动态分配的内存在调用malloc（）或者相关函数产生，在调用free()时释放，由程序员决定而不是一系列规则规定内存持续时间，因此内存块可在一个函数中创建，在另一个函数中释放。由于这点，动态内存分配容易导致堆区内存碎片化。\n\n## **.Data：**\n\n 存放程序中<font color=red> 已经初始化的非零全局变量。静态分配。</font>\n\ndata又可分为读写（RW）区域和只读（RO）区域。 \n\n- RO段保存常量所以也被称为`.constdata` eg const数据\n- RW段则是普通非常全局变量，静态变量就在其中\n\n## **.Bss：** \n\n存放程序中**未初始化**的和零值全局变量。静态分配，在程序开始时通常会被清零。\n\n## **.Text：** \n\n也称为代码段(Code)，用来存放程序执行代码，同时也可能会包含一些常量(如一些字符串常量等）。该段内存为静态分配，只读(某些架构可能允许修改)。 \n这块内存是共享的,当有多个相同进程(Process)存在时，共用同一个text段。\n\n------\n\n普通成员变量存储在栈区，使得每一个类的对象都拥有各自独立的普通成员变量。\n\n静态成员变量存储在全局数据区，是的每一个类的对象都共享一份静态\n\n成员变量。\n\n# 3.this指针\n\n那么，存放在代码段的成员函数是怎么区分调用对象的呢？\n\n事实上，<font color=red> C++为每一个函数都隐式定义了一个函数所属类类型的指针形参--this，而this指针永远指向调用函数的对象</font>，如此函数便可以识别调用自身的是类的哪个对象了。\n\n这里有一点要注意，<font color=red> C++并没有为静态成员函数定义this指针，如此，静态成员函数被所有的对象共享</font>。\n\n# 4.总结\n\n通过成员的分开存储和普通成员函数的`this指针`C++便可以识别各个不同的对象，如此便实现了面向对象。","slug":"【C++】C++面向对象模型初探","published":1,"updated":"2021-03-17T07:18:31.777Z","_id":"ckk9hocak000bdwr746nx9ti7","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h1 id=\"1-成员的分开存储\"><a href=\"#1-成员的分开存储\" class=\"headerlink\" title=\"1.成员的分开存储\"></a>1.成员的分开存储</h1><p>C++通过将类的成员分开存储的方式来实现面向对象</p>\n<table>\n<thead>\n<tr>\n<th>成员</th>\n<th>存储位置</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>普通成员变量</td>\n<td>栈区，与struct变量有相同的内存布局和字节对齐方式</td>\n</tr>\n<tr>\n<td>静态成员变量</td>\n<td>全局数据区，如此便可以使用类名和类所有的对象都可以访问</td>\n</tr>\n<tr>\n<td>成员函数</td>\n<td>代码段，包括静态成员函数和非静态成员函数</td>\n</tr>\n<tr>\n<td>虚函数</td>\n<td>虚函数表指针(vfptr)存放在栈区，其指向的虚函数表有自身的内存存储空间</td>\n</tr>\n</tbody></table>\n<h1 id=\"2-C-类的内存分布\"><a href=\"#2-C-类的内存分布\" class=\"headerlink\" title=\"2.C++类的内存分布\"></a>2.C++类的内存分布</h1><p>要想更好的了解这些，我们还需了解C++类的内存分布</p>\n<p><img src=\"/2019/10/01/%E3%80%90C++%E3%80%91C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%88%9D%E6%8E%A2/Snipaste_2019-10-02_09-07-09.png\"></p>\n<h2 id=\"Stack：\"><a href=\"#Stack：\" class=\"headerlink\" title=\"Stack：\"></a><strong>Stack：</strong></h2><p>栈，存放Automatic Variables，按内存地址由高到低方向生长，其最大大小由编译时确定，速度快，但自由性差，最大空间不大。保存程序中的局部变量。</p>\n<h2 id=\"Heap：\"><a href=\"#Heap：\" class=\"headerlink\" title=\"Heap：\"></a><strong>Heap：</strong></h2><p>堆，自由申请的空间，按内存地址由低到高方向生长，其大小由系统内存/虚拟内存上限决定，速度较慢，但自由性大，可用空间大。 动态分配的内存在调用malloc（）或者相关函数产生，在调用free()时释放，由程序员决定而不是一系列规则规定内存持续时间，因此内存块可在一个函数中创建，在另一个函数中释放。由于这点，动态内存分配容易导致堆区内存碎片化。</p>\n<h2 id=\"Data：\"><a href=\"#Data：\" class=\"headerlink\" title=\".Data：\"></a><strong>.Data：</strong></h2><p> 存放程序中<font color=\"red\"> 已经初始化的非零全局变量。静态分配。</font></p>\n<p>data又可分为读写（RW）区域和只读（RO）区域。 </p>\n<ul>\n<li>RO段保存常量所以也被称为<code>.constdata</code> eg const数据</li>\n<li>RW段则是普通非常全局变量，静态变量就在其中</li>\n</ul>\n<h2 id=\"Bss：\"><a href=\"#Bss：\" class=\"headerlink\" title=\".Bss：\"></a><strong>.Bss：</strong></h2><p>存放程序中<strong>未初始化</strong>的和零值全局变量。静态分配，在程序开始时通常会被清零。</p>\n<h2 id=\"Text：\"><a href=\"#Text：\" class=\"headerlink\" title=\".Text：\"></a><strong>.Text：</strong></h2><p>也称为代码段(Code)，用来存放程序执行代码，同时也可能会包含一些常量(如一些字符串常量等）。该段内存为静态分配，只读(某些架构可能允许修改)。<br>这块内存是共享的,当有多个相同进程(Process)存在时，共用同一个text段。</p>\n<hr>\n<p>普通成员变量存储在栈区，使得每一个类的对象都拥有各自独立的普通成员变量。</p>\n<p>静态成员变量存储在全局数据区，是的每一个类的对象都共享一份静态</p>\n<p>成员变量。</p>\n<h1 id=\"3-this指针\"><a href=\"#3-this指针\" class=\"headerlink\" title=\"3.this指针\"></a>3.this指针</h1><p>那么，存放在代码段的成员函数是怎么区分调用对象的呢？</p>\n<p>事实上，<font color=\"red\"> C++为每一个函数都隐式定义了一个函数所属类类型的指针形参–this，而this指针永远指向调用函数的对象</font>，如此函数便可以识别调用自身的是类的哪个对象了。</p>\n<p>这里有一点要注意，<font color=\"red\"> C++并没有为静态成员函数定义this指针，如此，静态成员函数被所有的对象共享</font>。</p>\n<h1 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4.总结\"></a>4.总结</h1><p>通过成员的分开存储和普通成员函数的<code>this指针</code>C++便可以识别各个不同的对象，如此便实现了面向对象。</p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h1 id=\"1-成员的分开存储\"><a href=\"#1-成员的分开存储\" class=\"headerlink\" title=\"1.成员的分开存储\"></a>1.成员的分开存储</h1><p>C++通过将类的成员分开存储的方式来实现面向对象</p>\n<table>\n<thead>\n<tr>\n<th>成员</th>\n<th>存储位置</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>普通成员变量</td>\n<td>栈区，与struct变量有相同的内存布局和字节对齐方式</td>\n</tr>\n<tr>\n<td>静态成员变量</td>\n<td>全局数据区，如此便可以使用类名和类所有的对象都可以访问</td>\n</tr>\n<tr>\n<td>成员函数</td>\n<td>代码段，包括静态成员函数和非静态成员函数</td>\n</tr>\n<tr>\n<td>虚函数</td>\n<td>虚函数表指针(vfptr)存放在栈区，其指向的虚函数表有自身的内存存储空间</td>\n</tr>\n</tbody></table>\n<h1 id=\"2-C-类的内存分布\"><a href=\"#2-C-类的内存分布\" class=\"headerlink\" title=\"2.C++类的内存分布\"></a>2.C++类的内存分布</h1><p>要想更好的了解这些，我们还需了解C++类的内存分布</p>\n<p><img src=\"/2019/10/01/%E3%80%90C++%E3%80%91C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%88%9D%E6%8E%A2/Snipaste_2019-10-02_09-07-09.png\"></p>\n<h2 id=\"Stack：\"><a href=\"#Stack：\" class=\"headerlink\" title=\"Stack：\"></a><strong>Stack：</strong></h2><p>栈，存放Automatic Variables，按内存地址由高到低方向生长，其最大大小由编译时确定，速度快，但自由性差，最大空间不大。保存程序中的局部变量。</p>\n<h2 id=\"Heap：\"><a href=\"#Heap：\" class=\"headerlink\" title=\"Heap：\"></a><strong>Heap：</strong></h2><p>堆，自由申请的空间，按内存地址由低到高方向生长，其大小由系统内存/虚拟内存上限决定，速度较慢，但自由性大，可用空间大。 动态分配的内存在调用malloc（）或者相关函数产生，在调用free()时释放，由程序员决定而不是一系列规则规定内存持续时间，因此内存块可在一个函数中创建，在另一个函数中释放。由于这点，动态内存分配容易导致堆区内存碎片化。</p>\n<h2 id=\"Data：\"><a href=\"#Data：\" class=\"headerlink\" title=\".Data：\"></a><strong>.Data：</strong></h2><p> 存放程序中<font color=\"red\"> 已经初始化的非零全局变量。静态分配。</font></p>\n<p>data又可分为读写（RW）区域和只读（RO）区域。 </p>\n<ul>\n<li>RO段保存常量所以也被称为<code>.constdata</code> eg const数据</li>\n<li>RW段则是普通非常全局变量，静态变量就在其中</li>\n</ul>\n<h2 id=\"Bss：\"><a href=\"#Bss：\" class=\"headerlink\" title=\".Bss：\"></a><strong>.Bss：</strong></h2><p>存放程序中<strong>未初始化</strong>的和零值全局变量。静态分配，在程序开始时通常会被清零。</p>\n<h2 id=\"Text：\"><a href=\"#Text：\" class=\"headerlink\" title=\".Text：\"></a><strong>.Text：</strong></h2><p>也称为代码段(Code)，用来存放程序执行代码，同时也可能会包含一些常量(如一些字符串常量等）。该段内存为静态分配，只读(某些架构可能允许修改)。<br>这块内存是共享的,当有多个相同进程(Process)存在时，共用同一个text段。</p>\n<hr>\n<p>普通成员变量存储在栈区，使得每一个类的对象都拥有各自独立的普通成员变量。</p>\n<p>静态成员变量存储在全局数据区，是的每一个类的对象都共享一份静态</p>\n<p>成员变量。</p>\n<h1 id=\"3-this指针\"><a href=\"#3-this指针\" class=\"headerlink\" title=\"3.this指针\"></a>3.this指针</h1><p>那么，存放在代码段的成员函数是怎么区分调用对象的呢？</p>\n<p>事实上，<font color=\"red\"> C++为每一个函数都隐式定义了一个函数所属类类型的指针形参–this，而this指针永远指向调用函数的对象</font>，如此函数便可以识别调用自身的是类的哪个对象了。</p>\n<p>这里有一点要注意，<font color=\"red\"> C++并没有为静态成员函数定义this指针，如此，静态成员函数被所有的对象共享</font>。</p>\n<h1 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4.总结\"></a>4.总结</h1><p>通过成员的分开存储和普通成员函数的<code>this指针</code>C++便可以识别各个不同的对象，如此便实现了面向对象。</p>\n"},{"title":"【C++】普通全局变量、静态全局变量、普通局部变量与静态局部变量","date":"2019-09-11T12:58:55.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 1.普通全局变量\n\n​\t普通全局变量是定义在函数和类外的或由extern标识或直接定义没有static标识的变量。\n\n​\t各个类型的变量之间最主要的区别就是作用域的不同了，普通全局变量的作用域在整个源程序中，全局变量对整个源程序中都是可见的，无论源程序是由单个文件还是多个文件组成，普通全局变量具有external链接属性，所以普通全局变量在整个源程序的各个文件中都可以被引用。\n\n# 2.静态全局变量\n\n​\t静态全局变量是定义在函数和类外的由static标识的变量。\n\n​\t静态全局变量具有文件作用域，具有internal链接属性，只能在定义的文件中使用，在其他文件中可以定义同名的变量，而全局变量则不行，这里要注意静态全局变量与类静态全局变量是不同的，类静态全局变量受到类权限限制，不同的访问权限就之间决定了类静态全局变量的作用域，类全局变量的使用与类一致，能使用类的地方就能使用类全局变量。\n\n​\t关于普通全局变量和静态全局变量的区别，我一直没有弄得很清楚，我有在网上查阅很多bolg，大家的说法都出奇的一致，我上面写的也是在查阅很多blog后总结的，但是我实际测试时，普通全局变量和静态全局变量似乎都可以被其他文件使用，并且 在其他文件中定义静态全局变量似乎也没有报错，没有弄明白这个其他文件指的是什么文件。\n\n![](【C++】全局变量、静态全局变量、局部变量与静态局部变量/Snipaste_2019-09-11_21-36-28.png)\n\n![](【C++】全局变量、静态全局变量、局部变量与静态局部变量/Snipaste_2019-09-11_21-36-38.png)\n\n# 3.普通局部变量\n\n​\t普通局部变量是定义在函数内的没有static标识的变量。\n\n​\t普通局部变量具有块作用域，生命周期从定义开始到跳出函数结束，普通局部变量每次使用都会初始化一次。\n\n# 4.静态局部变量\n\n​\t静态局部变量的作用于和普通局部变量一致，但是静态局部变量的内存地址在函数结束后不会被销毁，且会保存赋值结果，静态局部变量和静态全局变量一样会一直驻留在静态区，静态局部变量只会初始化一次，在下一次函数被调用时不会再初始化而是直接调用。","source":"_posts/【C++】全局变量、静态全局变量、局部变量与静态局部变量.md","raw":"---\ntitle: 【C++】普通全局变量、静态全局变量、普通局部变量与静态局部变量\ndate: 2019-09-11 20:58:55\ntags: CPlus\ncategories: 知识记录\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 1.普通全局变量\n\n​\t普通全局变量是定义在函数和类外的或由extern标识或直接定义没有static标识的变量。\n\n​\t各个类型的变量之间最主要的区别就是作用域的不同了，普通全局变量的作用域在整个源程序中，全局变量对整个源程序中都是可见的，无论源程序是由单个文件还是多个文件组成，普通全局变量具有external链接属性，所以普通全局变量在整个源程序的各个文件中都可以被引用。\n\n# 2.静态全局变量\n\n​\t静态全局变量是定义在函数和类外的由static标识的变量。\n\n​\t静态全局变量具有文件作用域，具有internal链接属性，只能在定义的文件中使用，在其他文件中可以定义同名的变量，而全局变量则不行，这里要注意静态全局变量与类静态全局变量是不同的，类静态全局变量受到类权限限制，不同的访问权限就之间决定了类静态全局变量的作用域，类全局变量的使用与类一致，能使用类的地方就能使用类全局变量。\n\n​\t关于普通全局变量和静态全局变量的区别，我一直没有弄得很清楚，我有在网上查阅很多bolg，大家的说法都出奇的一致，我上面写的也是在查阅很多blog后总结的，但是我实际测试时，普通全局变量和静态全局变量似乎都可以被其他文件使用，并且 在其他文件中定义静态全局变量似乎也没有报错，没有弄明白这个其他文件指的是什么文件。\n\n![](【C++】全局变量、静态全局变量、局部变量与静态局部变量/Snipaste_2019-09-11_21-36-28.png)\n\n![](【C++】全局变量、静态全局变量、局部变量与静态局部变量/Snipaste_2019-09-11_21-36-38.png)\n\n# 3.普通局部变量\n\n​\t普通局部变量是定义在函数内的没有static标识的变量。\n\n​\t普通局部变量具有块作用域，生命周期从定义开始到跳出函数结束，普通局部变量每次使用都会初始化一次。\n\n# 4.静态局部变量\n\n​\t静态局部变量的作用于和普通局部变量一致，但是静态局部变量的内存地址在函数结束后不会被销毁，且会保存赋值结果，静态局部变量和静态全局变量一样会一直驻留在静态区，静态局部变量只会初始化一次，在下一次函数被调用时不会再初始化而是直接调用。","slug":"【C++】全局变量、静态全局变量、局部变量与静态局部变量","published":1,"updated":"2021-03-17T07:18:58.861Z","_id":"ckk9hocal000gdwr7eaqfdjo9","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h1 id=\"1-普通全局变量\"><a href=\"#1-普通全局变量\" class=\"headerlink\" title=\"1.普通全局变量\"></a>1.普通全局变量</h1><p>​    普通全局变量是定义在函数和类外的或由extern标识或直接定义没有static标识的变量。</p>\n<p>​    各个类型的变量之间最主要的区别就是作用域的不同了，普通全局变量的作用域在整个源程序中，全局变量对整个源程序中都是可见的，无论源程序是由单个文件还是多个文件组成，普通全局变量具有external链接属性，所以普通全局变量在整个源程序的各个文件中都可以被引用。</p>\n<h1 id=\"2-静态全局变量\"><a href=\"#2-静态全局变量\" class=\"headerlink\" title=\"2.静态全局变量\"></a>2.静态全局变量</h1><p>​    静态全局变量是定义在函数和类外的由static标识的变量。</p>\n<p>​    静态全局变量具有文件作用域，具有internal链接属性，只能在定义的文件中使用，在其他文件中可以定义同名的变量，而全局变量则不行，这里要注意静态全局变量与类静态全局变量是不同的，类静态全局变量受到类权限限制，不同的访问权限就之间决定了类静态全局变量的作用域，类全局变量的使用与类一致，能使用类的地方就能使用类全局变量。</p>\n<p>​    关于普通全局变量和静态全局变量的区别，我一直没有弄得很清楚，我有在网上查阅很多bolg，大家的说法都出奇的一致，我上面写的也是在查阅很多blog后总结的，但是我实际测试时，普通全局变量和静态全局变量似乎都可以被其他文件使用，并且 在其他文件中定义静态全局变量似乎也没有报错，没有弄明白这个其他文件指的是什么文件。</p>\n<p><img src=\"/2019/09/11/%E3%80%90C++%E3%80%91%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E9%9D%99%E6%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/Snipaste_2019-09-11_21-36-28.png\"></p>\n<p><img src=\"/2019/09/11/%E3%80%90C++%E3%80%91%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E9%9D%99%E6%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/Snipaste_2019-09-11_21-36-38.png\"></p>\n<h1 id=\"3-普通局部变量\"><a href=\"#3-普通局部变量\" class=\"headerlink\" title=\"3.普通局部变量\"></a>3.普通局部变量</h1><p>​    普通局部变量是定义在函数内的没有static标识的变量。</p>\n<p>​    普通局部变量具有块作用域，生命周期从定义开始到跳出函数结束，普通局部变量每次使用都会初始化一次。</p>\n<h1 id=\"4-静态局部变量\"><a href=\"#4-静态局部变量\" class=\"headerlink\" title=\"4.静态局部变量\"></a>4.静态局部变量</h1><p>​    静态局部变量的作用于和普通局部变量一致，但是静态局部变量的内存地址在函数结束后不会被销毁，且会保存赋值结果，静态局部变量和静态全局变量一样会一直驻留在静态区，静态局部变量只会初始化一次，在下一次函数被调用时不会再初始化而是直接调用。</p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h1 id=\"1-普通全局变量\"><a href=\"#1-普通全局变量\" class=\"headerlink\" title=\"1.普通全局变量\"></a>1.普通全局变量</h1><p>​    普通全局变量是定义在函数和类外的或由extern标识或直接定义没有static标识的变量。</p>\n<p>​    各个类型的变量之间最主要的区别就是作用域的不同了，普通全局变量的作用域在整个源程序中，全局变量对整个源程序中都是可见的，无论源程序是由单个文件还是多个文件组成，普通全局变量具有external链接属性，所以普通全局变量在整个源程序的各个文件中都可以被引用。</p>\n<h1 id=\"2-静态全局变量\"><a href=\"#2-静态全局变量\" class=\"headerlink\" title=\"2.静态全局变量\"></a>2.静态全局变量</h1><p>​    静态全局变量是定义在函数和类外的由static标识的变量。</p>\n<p>​    静态全局变量具有文件作用域，具有internal链接属性，只能在定义的文件中使用，在其他文件中可以定义同名的变量，而全局变量则不行，这里要注意静态全局变量与类静态全局变量是不同的，类静态全局变量受到类权限限制，不同的访问权限就之间决定了类静态全局变量的作用域，类全局变量的使用与类一致，能使用类的地方就能使用类全局变量。</p>\n<p>​    关于普通全局变量和静态全局变量的区别，我一直没有弄得很清楚，我有在网上查阅很多bolg，大家的说法都出奇的一致，我上面写的也是在查阅很多blog后总结的，但是我实际测试时，普通全局变量和静态全局变量似乎都可以被其他文件使用，并且 在其他文件中定义静态全局变量似乎也没有报错，没有弄明白这个其他文件指的是什么文件。</p>\n<p><img src=\"/2019/09/11/%E3%80%90C++%E3%80%91%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E9%9D%99%E6%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/Snipaste_2019-09-11_21-36-28.png\"></p>\n<p><img src=\"/2019/09/11/%E3%80%90C++%E3%80%91%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E9%9D%99%E6%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/Snipaste_2019-09-11_21-36-38.png\"></p>\n<h1 id=\"3-普通局部变量\"><a href=\"#3-普通局部变量\" class=\"headerlink\" title=\"3.普通局部变量\"></a>3.普通局部变量</h1><p>​    普通局部变量是定义在函数内的没有static标识的变量。</p>\n<p>​    普通局部变量具有块作用域，生命周期从定义开始到跳出函数结束，普通局部变量每次使用都会初始化一次。</p>\n<h1 id=\"4-静态局部变量\"><a href=\"#4-静态局部变量\" class=\"headerlink\" title=\"4.静态局部变量\"></a>4.静态局部变量</h1><p>​    静态局部变量的作用于和普通局部变量一致，但是静态局部变量的内存地址在函数结束后不会被销毁，且会保存赋值结果，静态局部变量和静态全局变量一样会一直驻留在静态区，静态局部变量只会初始化一次，在下一次函数被调用时不会再初始化而是直接调用。</p>\n"},{"title":"【C】C的typedef的妙用","date":"2019-10-03T01:53:37.000Z","_content":"\n\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 1.自定义数组类型\n\n```c\ntypedef int (Array)[5];\n```\n\n`Array`是一个类型为`int`长度为5的数组类型，即定义一个`Array a;`那么a就是一个类型为int长度为5的数组，所以a的使用方法和数组一致。\n\n```c\ntypedef int(Array)[5];\nArray a;\nint i = 0,j = 0;\nfor (i = 0; i < 5; i++)\n\ta[i] = i;\nfor (j = 0; j < 5; j++)\n\tprintf(\"%d,\", a[j]);\n```\n\n# 2.自定义指向数组的指针类型\n\n```c\ntypedef char(*Arrayptr)[8];\n```\n\n`Arrayptr`是一个指向`char`类型的长度为8的数组的指针类型，此类型的指针只能指向`char`类型的长度为8的数组。且每一次指针移步，移动的距离是1*8=8字节。\n\n需要注意的是`()`不能省略，否则定义就会变义。\n\n除了自定义指针类型来指向一个固定的数组外，C还可以直接定义一个指向固定数组的指针变量。\n\n```c\nint (*p)[5];\n```\n\n`p`就是一个指向类型为整型且长度为5的数组的指针变量。\n\n# 3.自定义函数类型\n\n```c\ntypedef int (Funptr)(int a, int b);//函数类型\nint Fun1(int a, int b)\n{\n\treturn a + b;\n}\nvoid Fun2(Funptr *p)\n{\n\tprintf(\"%d\\n\", p(1, 2));\n}\nint main()\n{\n\tFunptr *p = &Fun1;\n\tFun2(p);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n`Funptr`是一个指向返回值为`int`参数列表为`int,int`的函数的类型，通过`Funptr`函数类型的指针可以将返回值为`int`参数列表为`int,int`的函数当作参数来使用，使函数的调用更为灵活。\n\n除了定义函数类型可以达到这种效果，我们还可以直接定义指向函数的指针类型来实现函数参数化，如：\n\n```c\ntypedef int (*Funptr)(int a, int b);\nint Fun1(int a, int b)\n{\n\treturn a + b;\n}\nvoid Fun2(Funptr p)\n{\n\tprintf(\"%d\\n\", p(1, 2));\n}\nint main()\n{\n\tFunptr p = &Fun1;\n\tFun2(p);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n这样的效果和定义函数类型是一样的。\n\n当然我们还可以直接定义一个指向函数的指针变量，来实现同样的效果，如：\n\n```c\nint Fun1(int a, int b)\n{\n\treturn a + b;\n}\nvoid Fun2(Funptr p)\n{\n\tprintf(\"%d\\n\", p(1, 2));\n}\nint main()\n{\n\tint(*p)(int a, int b) = &Fun1;\n\tFun2(p);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n我们还可以这么做，一样能达到相同的效果：\n\n```c\nint Fun1(int a, int b)\n{\n\treturn a + b;\n}\nvoid Fun2(int (*ptr)(int a,int b))//直接定义函数指针的形参\n{\n\tprintf(\"%d\\n\", ptr(1, 2));\n}\nint main()\n{\n\tFun2(&Fun1);//直接传递函数地址\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n搞了那么多似乎函数指针只是把函数的调用弄得更复杂了而已，除了把函数当作参数来使用似乎没有什么作用了，真的是如此吗？\n\n<font color=red> 如果我们仔细观察，会发现函数指针将函数的调用和函数的实现分隔开来了，即函数指针提前规定好了函数的实现标准，这样只要后来者按照这个标准来实现函数，可以不用修改前人的代码，就能实现函数的完美的调用，这一作用在具体的项目迭代中是及其出众的。</font>\n\n","source":"_posts/【C】C的typedef的妙用.md","raw":"---\ntitle: 【C】C的typedef的妙用\ndate: 2019-10-03 09:53:37\ntags: C\ncategories: 知识记录\n---\n\n\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 1.自定义数组类型\n\n```c\ntypedef int (Array)[5];\n```\n\n`Array`是一个类型为`int`长度为5的数组类型，即定义一个`Array a;`那么a就是一个类型为int长度为5的数组，所以a的使用方法和数组一致。\n\n```c\ntypedef int(Array)[5];\nArray a;\nint i = 0,j = 0;\nfor (i = 0; i < 5; i++)\n\ta[i] = i;\nfor (j = 0; j < 5; j++)\n\tprintf(\"%d,\", a[j]);\n```\n\n# 2.自定义指向数组的指针类型\n\n```c\ntypedef char(*Arrayptr)[8];\n```\n\n`Arrayptr`是一个指向`char`类型的长度为8的数组的指针类型，此类型的指针只能指向`char`类型的长度为8的数组。且每一次指针移步，移动的距离是1*8=8字节。\n\n需要注意的是`()`不能省略，否则定义就会变义。\n\n除了自定义指针类型来指向一个固定的数组外，C还可以直接定义一个指向固定数组的指针变量。\n\n```c\nint (*p)[5];\n```\n\n`p`就是一个指向类型为整型且长度为5的数组的指针变量。\n\n# 3.自定义函数类型\n\n```c\ntypedef int (Funptr)(int a, int b);//函数类型\nint Fun1(int a, int b)\n{\n\treturn a + b;\n}\nvoid Fun2(Funptr *p)\n{\n\tprintf(\"%d\\n\", p(1, 2));\n}\nint main()\n{\n\tFunptr *p = &Fun1;\n\tFun2(p);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n`Funptr`是一个指向返回值为`int`参数列表为`int,int`的函数的类型，通过`Funptr`函数类型的指针可以将返回值为`int`参数列表为`int,int`的函数当作参数来使用，使函数的调用更为灵活。\n\n除了定义函数类型可以达到这种效果，我们还可以直接定义指向函数的指针类型来实现函数参数化，如：\n\n```c\ntypedef int (*Funptr)(int a, int b);\nint Fun1(int a, int b)\n{\n\treturn a + b;\n}\nvoid Fun2(Funptr p)\n{\n\tprintf(\"%d\\n\", p(1, 2));\n}\nint main()\n{\n\tFunptr p = &Fun1;\n\tFun2(p);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n这样的效果和定义函数类型是一样的。\n\n当然我们还可以直接定义一个指向函数的指针变量，来实现同样的效果，如：\n\n```c\nint Fun1(int a, int b)\n{\n\treturn a + b;\n}\nvoid Fun2(Funptr p)\n{\n\tprintf(\"%d\\n\", p(1, 2));\n}\nint main()\n{\n\tint(*p)(int a, int b) = &Fun1;\n\tFun2(p);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n我们还可以这么做，一样能达到相同的效果：\n\n```c\nint Fun1(int a, int b)\n{\n\treturn a + b;\n}\nvoid Fun2(int (*ptr)(int a,int b))//直接定义函数指针的形参\n{\n\tprintf(\"%d\\n\", ptr(1, 2));\n}\nint main()\n{\n\tFun2(&Fun1);//直接传递函数地址\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n搞了那么多似乎函数指针只是把函数的调用弄得更复杂了而已，除了把函数当作参数来使用似乎没有什么作用了，真的是如此吗？\n\n<font color=red> 如果我们仔细观察，会发现函数指针将函数的调用和函数的实现分隔开来了，即函数指针提前规定好了函数的实现标准，这样只要后来者按照这个标准来实现函数，可以不用修改前人的代码，就能实现函数的完美的调用，这一作用在具体的项目迭代中是及其出众的。</font>\n\n","slug":"【C】C的typedef的妙用","published":1,"updated":"2021-02-01T13:26:19.697Z","_id":"ckk9hocam000hdwr7ht7n3pz9","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h1 id=\"1-自定义数组类型\"><a href=\"#1-自定义数组类型\" class=\"headerlink\" title=\"1.自定义数组类型\"></a>1.自定义数组类型</h1><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">typedef int (Array)[5];<br></code></pre></td></tr></table></figure>\n<p><code>Array</code>是一个类型为<code>int</code>长度为5的数组类型，即定义一个<code>Array a;</code>那么a就是一个类型为int长度为5的数组，所以a的使用方法和数组一致。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">typedef int(Array)[5];<br>Array a;<br><span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>,j = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">5</span>; i++)<br>\ta[i] = i;<br><span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">5</span>; j++)<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d,&quot;</span>, a[j]);<br></code></pre></td></tr></table></figure>\n<h1 id=\"2-自定义指向数组的指针类型\"><a href=\"#2-自定义指向数组的指针类型\" class=\"headerlink\" title=\"2.自定义指向数组的指针类型\"></a>2.自定义指向数组的指针类型</h1><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">typedef char(*Arrayptr)[8];<br></code></pre></td></tr></table></figure>\n<p><code>Arrayptr</code>是一个指向<code>char</code>类型的长度为8的数组的指针类型，此类型的指针只能指向<code>char</code>类型的长度为8的数组。且每一次指针移步，移动的距离是1*8=8字节。</p>\n<p>需要注意的是<code>()</code>不能省略，否则定义就会变义。</p>\n<p>除了自定义指针类型来指向一个固定的数组外，C还可以直接定义一个指向固定数组的指针变量。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">int</span> (*p)[<span class=\"hljs-number\">5</span>];<br></code></pre></td></tr></table></figure>\n<p><code>p</code>就是一个指向类型为整型且长度为5的数组的指针变量。</p>\n<h1 id=\"3-自定义函数类型\"><a href=\"#3-自定义函数类型\" class=\"headerlink\" title=\"3.自定义函数类型\"></a>3.自定义函数类型</h1><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-title\">int</span> <span class=\"hljs-params\">(Funptr)</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> b)</span></span>;<span class=\"hljs-comment\">//函数类型</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">Fun1</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> a + b;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Fun2</span><span class=\"hljs-params\">(Funptr *p)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\n&quot;</span>, p(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>));<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tFunptr *p = &amp;Fun1;<br>\tFun2(p);<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><code>Funptr</code>是一个指向返回值为<code>int</code>参数列表为<code>int,int</code>的函数的类型，通过<code>Funptr</code>函数类型的指针可以将返回值为<code>int</code>参数列表为<code>int,int</code>的函数当作参数来使用，使函数的调用更为灵活。</p>\n<p>除了定义函数类型可以达到这种效果，我们还可以直接定义指向函数的指针类型来实现函数参数化，如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-title\">int</span> <span class=\"hljs-params\">(*Funptr)</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> b)</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">Fun1</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> a + b;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Fun2</span><span class=\"hljs-params\">(Funptr p)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\n&quot;</span>, p(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>));<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tFunptr p = &amp;Fun1;<br>\tFun2(p);<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这样的效果和定义函数类型是一样的。</p>\n<p>当然我们还可以直接定义一个指向函数的指针变量，来实现同样的效果，如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">Fun1</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> a + b;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Fun2</span><span class=\"hljs-params\">(Funptr p)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\n&quot;</span>, p(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>));<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">int</span>(*p)(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> b) = &amp;Fun1;<br>\tFun2(p);<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>我们还可以这么做，一样能达到相同的效果：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">Fun1</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> a + b;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Fun2</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> (*ptr)(<span class=\"hljs-keyword\">int</span> a,<span class=\"hljs-keyword\">int</span> b))</span><span class=\"hljs-comment\">//直接定义函数指针的形参</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\n&quot;</span>, ptr(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>));<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tFun2(&amp;Fun1);<span class=\"hljs-comment\">//直接传递函数地址</span><br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>搞了那么多似乎函数指针只是把函数的调用弄得更复杂了而已，除了把函数当作参数来使用似乎没有什么作用了，真的是如此吗？</p>\n<p><font color=\"red\"> 如果我们仔细观察，会发现函数指针将函数的调用和函数的实现分隔开来了，即函数指针提前规定好了函数的实现标准，这样只要后来者按照这个标准来实现函数，可以不用修改前人的代码，就能实现函数的完美的调用，这一作用在具体的项目迭代中是及其出众的。</font></p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h1 id=\"1-自定义数组类型\"><a href=\"#1-自定义数组类型\" class=\"headerlink\" title=\"1.自定义数组类型\"></a>1.自定义数组类型</h1><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">typedef int (Array)[5];<br></code></pre></td></tr></table></figure>\n<p><code>Array</code>是一个类型为<code>int</code>长度为5的数组类型，即定义一个<code>Array a;</code>那么a就是一个类型为int长度为5的数组，所以a的使用方法和数组一致。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">typedef int(Array)[5];<br>Array a;<br><span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>,j = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">5</span>; i++)<br>\ta[i] = i;<br><span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">5</span>; j++)<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d,&quot;</span>, a[j]);<br></code></pre></td></tr></table></figure>\n<h1 id=\"2-自定义指向数组的指针类型\"><a href=\"#2-自定义指向数组的指针类型\" class=\"headerlink\" title=\"2.自定义指向数组的指针类型\"></a>2.自定义指向数组的指针类型</h1><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">typedef char(*Arrayptr)[8];<br></code></pre></td></tr></table></figure>\n<p><code>Arrayptr</code>是一个指向<code>char</code>类型的长度为8的数组的指针类型，此类型的指针只能指向<code>char</code>类型的长度为8的数组。且每一次指针移步，移动的距离是1*8=8字节。</p>\n<p>需要注意的是<code>()</code>不能省略，否则定义就会变义。</p>\n<p>除了自定义指针类型来指向一个固定的数组外，C还可以直接定义一个指向固定数组的指针变量。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">int</span> (*p)[<span class=\"hljs-number\">5</span>];<br></code></pre></td></tr></table></figure>\n<p><code>p</code>就是一个指向类型为整型且长度为5的数组的指针变量。</p>\n<h1 id=\"3-自定义函数类型\"><a href=\"#3-自定义函数类型\" class=\"headerlink\" title=\"3.自定义函数类型\"></a>3.自定义函数类型</h1><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-title\">int</span> <span class=\"hljs-params\">(Funptr)</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> b)</span></span>;<span class=\"hljs-comment\">//函数类型</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">Fun1</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> a + b;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Fun2</span><span class=\"hljs-params\">(Funptr *p)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\n&quot;</span>, p(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>));<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tFunptr *p = &amp;Fun1;<br>\tFun2(p);<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><code>Funptr</code>是一个指向返回值为<code>int</code>参数列表为<code>int,int</code>的函数的类型，通过<code>Funptr</code>函数类型的指针可以将返回值为<code>int</code>参数列表为<code>int,int</code>的函数当作参数来使用，使函数的调用更为灵活。</p>\n<p>除了定义函数类型可以达到这种效果，我们还可以直接定义指向函数的指针类型来实现函数参数化，如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-title\">int</span> <span class=\"hljs-params\">(*Funptr)</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> b)</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">Fun1</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> a + b;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Fun2</span><span class=\"hljs-params\">(Funptr p)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\n&quot;</span>, p(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>));<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tFunptr p = &amp;Fun1;<br>\tFun2(p);<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这样的效果和定义函数类型是一样的。</p>\n<p>当然我们还可以直接定义一个指向函数的指针变量，来实现同样的效果，如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">Fun1</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> a + b;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Fun2</span><span class=\"hljs-params\">(Funptr p)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\n&quot;</span>, p(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>));<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">int</span>(*p)(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> b) = &amp;Fun1;<br>\tFun2(p);<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>我们还可以这么做，一样能达到相同的效果：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">Fun1</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> a + b;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Fun2</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> (*ptr)(<span class=\"hljs-keyword\">int</span> a,<span class=\"hljs-keyword\">int</span> b))</span><span class=\"hljs-comment\">//直接定义函数指针的形参</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\n&quot;</span>, ptr(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>));<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tFun2(&amp;Fun1);<span class=\"hljs-comment\">//直接传递函数地址</span><br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>搞了那么多似乎函数指针只是把函数的调用弄得更复杂了而已，除了把函数当作参数来使用似乎没有什么作用了，真的是如此吗？</p>\n<p><font color=\"red\"> 如果我们仔细观察，会发现函数指针将函数的调用和函数的实现分隔开来了，即函数指针提前规定好了函数的实现标准，这样只要后来者按照这个标准来实现函数，可以不用修改前人的代码，就能实现函数的完美的调用，这一作用在具体的项目迭代中是及其出众的。</font></p>\n"},{"title":"Linux基础","date":"2019-08-25T10:25:16.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n<center>Linux学习笔记</center>\n\n# l  **pwd**：查看当前所在路\n\n命令格式：命令 -选项 -参数（目录）\n\n命令：\n\nls：查看当前路径下的文件\n\n选项：\n\n| 选项   | 作用                         |\n| ------ | ---------------------------- |\n| **-d** | 只查看当前目录的信息         |\n| **-l** | 查看详细信息                 |\n| **-a** | 显示所有文件（包含隐藏文件） |\n| **-h** | 显示文件大小                 |\n\n例：ls -l     命令 -选项\n\n选项可以组合：ls -a -l/ls -al：查看所有文件的详细信息\n\nls -al /etc/   命令 -选项 -参数 ：查看etc目录下的所有文件的详细信息\n\n# l  **cd** **：** **路径切换**        \n\n| 选项     | 作用                                                         |\n| -------- | ------------------------------------------------------------ |\n| “**-**”  | 返回到之前目录                                               |\n| “**..**” | 返回上一级目录（“.”当前目录，“..”上一级目录）                |\n| “**~**”  | 到用户所在的家目录（家目录：用户所在目录，如windowsC盘的用户目录） |\n\ntouch ：cd到临时目录tmp下可创建新文件    touch 文件名\n\n# l  **Linux目录结构**\n\n| 文件名     | 作用                    |\n| ---------- | ----------------------- |\n| /boot      | linux启动时，需要的文件 |\n| /dve       | 设备文件                |\n| /etc       | 配置文件                |\n| /home      | 用户家目录              |\n| /media     | 媒体文件                |\n| /mnt       | 挂载文件                |\n| /opt       | 第三方软件              |\n| /proc      | 虚拟化文件              |\n| /root      | 管理员的家目录          |\n| /run       | 远程文件                |\n| /srv       | 压缩过的文件            |\n| /sys       | 系统文件                |\n| /usr       | 安装的软件，            |\n| /var       | 可变数据、日志          |\n| /tmp       | 临时文件                |\n| /usr/bin   | 普通用户可以使用的命令  |\n| /usr/sbin  | 超级用户可以使用的命令  |\n| /usr/lib   | 32位库文件              |\n| /usr/lib64 | 64位库文件              |\n\n# l  **Linux文件处理**\n\n## **文件类型判断：**\n\n-ls -l\n\n![img](【Linux】Linux基础/1.png)\n\n| 文件以“_”开头 | 文件类型                            |\n| ------------- | ----------------------------------- |\n| “d”           | 目录                                |\n| “-”           | 文件                                |\n| “l”           | 链接文件（类似win中快捷方式）       |\n| “b”           | 设备文件，提供存储接口的设备        |\n| “c”           | 设备文件，提供串行结合口的设备—键盘 |\n\n \n\n## **文件处理：**\n\n![img](【Linux】Linux基础/2.png)\n\ncp            cp abc a：复制abc并命名为a/多文件复制：cp a abc goulandis/：复制a、abc到goulandis下\n\nmv            mv 文件1 文件2：将文件1更名为文件2/mv 文件1（文件2 ….） 目录：将文件移动到目录下                 \n\nrm             rm -f 文件1 （文件2…）：强制删除\n\nmkdir       mkdir -p （要创建的）目录1/（要创建的）目录2：创建目录1并在目录1下创建目录2\n\n## **查看文件：**  \n\n| 命令             | 作用                        |\n| ---------------- | --------------------------- |\n| **cat/****路径** | 查看文件                    |\n| nl               | 显示的时候，顺便出现行号    |\n| tac              | 从最后一行开始显示          |\n| head             | 显示文件前10行 -n：设置行数 |\n| tail             | 显示文件尾10行 -n：设置行数 |\n| wc               | 显示文件行数，数字，字节    |\n| more             | 一页一页翻动                |\n| **less**         | 一页一页翻动                |\n\n| **cat****和tac****选项** | 作用                           |\n| ------------------------ | ------------------------------ |\n| -A                       | 整合命令-vET（整合-v、-E、-T） |\n| -b                       | 列出行号，但是空白行不标志行号 |\n| -E                       | 将结尾的断行字符（$）显示出来  |\n| -n                       | 列出行号，空白行也会标志出来   |\n| -T                       | 将tab键以^I显示                |\n| -v                       | 列出一些看不出来的字符         |\n| <区分大小写>             |                                |\n\n| **nl****的选项** |                                  |                          |\n| ---------------- | -------------------------------- | ------------------------ |\n| 总选项           | 分选项                           | 作用                     |\n| b                | ba                               | 无论是否有空，都列出行号 |\n| bt               | 如果有空行，则不列出行号（默认） |                          |\n| n                | nln                              | 行号在屏幕最左方         |\n| nrn              | 行号在屏幕最右方，前面不加0      |                          |\n| nrz              | 行号在屏幕最右方，前面加0        |                          |\n| w                |                                  | 缩进多少位               |\n\n| **more****的选项** | 作用                 |\n| ------------------ | -------------------- |\n| 空格               | 向下翻一页           |\n| 回车               | 向下翻一行           |\n| /字符串            | 搜索                 |\n| :f                 | 立刻显示文件名和行数 |\n| b                  | 翻到第一页           |\n| q                  | 离开                 |\n\n| **less****的选项** | 作用                                |\n| ------------------ | ----------------------------------- |\n| **空格**           | 向下翻动一行                        |\n| **回车**           | 向下翻动一页                        |\n| **pagedown**       | 向下翻动一页                        |\n| **pageup**         | 向上翻动一页                        |\n| **n**              | 重复前一个搜索（操作：n）           |\n| **N**              | 反向重复前一个搜索（操作：shift+n） |\n| **q**              | 退出                                |\n\n| head和tail的选项                  | 作用                   |\n| --------------------------------- | ---------------------- |\n| -n                                | 指定显示几行，默认10行 |\n| 日志文件路径（/var/log/messages） | 查看日志               |\n\n| wc的选项 | 作用                                                       |\n| -------- | ---------------------------------------------------------- |\n| -c       | 只显示字节                                                 |\n| -w       | 只显示字数，一个字被定义为空白、跳格、换行字符、分隔字符串 |\n| -l       | 只显示行                                                   |\n\n| **Vim编辑器操作命令** | 作用           |\n| --------------------- | -------------- |\n| **i**                 | 插入           |\n| **esc**               | 退出           |\n| **u**                 | 撤销           |\n| **x**                 | 删除           |\n| **v**                 | 选择文本       |\n| **y**                 | 复制           |\n| **yy**                | 复制当前行     |\n| **dd**                | 删除光标所在行 |\n| **p**                 | 粘贴           |\n| **:w**                | 保存           |\n| **:wq**               | 保存并退出     |\n| **:q****！**          | 强制退出       |\n\n \n\n## **软链接：**\n\n![img](【Linux】Linux基础/3.png)\n\n![img](【Linux】Linux基础/4.png)\n\n## **硬链接：**\n\n![](【Linux】Linux基础/5.png)\n\nls -I ：查看Inode编号\n\n \n\n# l  **关机操作**\n\n| sync                   | 数据同步写入磁盘 |\n| ---------------------- | ---------------- |\n| **shutdown**           | 常用关机指令     |\n| reboot、halt、poweroff | 重启，关机       |\n\n| shutdown的指令 | 作用                                                         |\n| -------------- | ------------------------------------------------------------ |\n| -t             | 添加秒数。几秒后关机                                         |\n| -k             | 不是真关机，二十发出警告信息                                 |\n| **-r**         | 在系统服务都停止后，重启                                     |\n| **-h**         | 在系统服务都停止后，关机                                     |\n| -f             | 关闭，并且开机一个后强行略过磁盘检查                         |\n| -F             | 重启后强制进行磁盘检查                                       |\n| -c             | 取消已经在进行的shutdown指令内容                             |\n|                | shutdown -h now    现在马上停止服务并关机   shutdown -h 12：00       在12：00时刻停止服务并关机   shutdown -h +10     十分钟以后停止服务并关机   shutdown -r now     现在马上停止服务并重启   shutdown -r +30 ‘the system will reboot’       先发一个警告信息“the system will reboot”，系统将要在30分钟后重启   shutdown -k now ‘the system will reboot’     现在马上发出一个警告信息“the system will reboot” |\n\n# l  **Linux文件权限**\n\n![img](【Linux】Linux基础/6.png)\n\n| 权限 | 连接 | 所有者 | 所属组 | 容量（默认单位B） | 修改日期 | 文件名 |\n| ---- | ---- | ------ | ------ | ----------------- | -------- | ------ |\n|      |      |        |        |                   |          |        |\n\n| **文件的权限**                         |                  |\n| -------------------------------------- | ---------------- |\n| r、w、x ： 读、写、执行，没有权限就是- |                  |\n| 第一组rwx                              | 文件所有者的权限 |\n| 第二组rwx                              | 文件所属组的权限 |\n| 第三组rwx                              | 文件其他人的权限 |\n\n| **目录的权限** |                                                        |\n| -------------- | ------------------------------------------------------ |\n| r              | 具有读取目录的结构列表的权限，可以查看目录下有哪些文件 |\n| w              | 该权限对于目录来说是很大的                             |\n| 1              | 可以在该目录下新建新的文件和目录                       |\n| 2              | 可以删除已存在的文件和目录                             |\n| 3              | 将已存在的文件和目录重命名                             |\n| 4              | 移动该目录内的文件和目录的位置                         |\n| X              | 是否可以进入该目录                                     |\n\n| **文件权限的修改**                                           |                                                              |                          |      |          |      |\n| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------ | ---- | -------- | ---- |\n| 命令                                                         | 命令作用                                                     | 格式                     | 选项 | 选项作用 |      |\n| chown                                                        | 修改文件的拥有者，前提是要有该拥有者                         | chown 拥有者   文件/目录 | -R   | 递归修改 |      |\n| chgrp                                                        | 修改文件所属组，前提是要有该组                               |                          | -R   | 递归修改 |      |\n| chmod                                                        | 修改拥有者和所属组的权限                                     |                          |      |          |      |\n| 加减法                                                       | chmod    u/g/o+/-/=r/w/x 123：   将文件1213给用户/组/其他人加/减/赋予一个读/写/执行权限 |                          |      |          |      |\n| 数字法                                                       | r=4    w=2  x=1 ： chmod  632 123 ：   将文件123给用户赋予r和w权限，给组赋予wx权限，给其他人赋予w权限 |                          |      |          |      |\n| chown -R goulandis 123 ： 将123目录下的所有文件包括目录本身的拥有者修改为goulandis |                                                              |                          |      |          |      |\n|                                                              |                                                              |                          |      |          |      |\n\n**默认权限：**\n\numask      查看当前用户的umask权限       \n\numask –(选项) ：临时修改默认权限\n\n/etc/bashrc ： 永久修改默认权限（通过修改脚本文件实现）\n\numask的选项说明\n\n0022         拿走的权限\n\n​         第一个数字表示特殊权限\n\n​         022=rwxr-xr-x ：不拿走用户的权限、拿走用户组的w权限、拿走其他用户的w权限\n\n目录无法拿走x权限\n\n普通用户umask值 0002\n\nroot用户umask值 0022\n\n## **文件的特殊权限:**\n\n![img](【Linux】Linux基础/7.png)\n\n当s出现在拥有者的x权限的位置时，表示拥有者有SUID的权限（Set UID）\n\n当s出现在用户组的x权限的位置时，表示用户组有SGID的权限（Set GID）\n\n当s出现在其他人的x权限的位置时，表示其他人有SBIT的权限（Sticky Bit）\n\n| SUID                                                         | 临时获取文件拥有者的权限-----只能针对文件                   |\n| ------------------------------------------------------------ | ----------------------------------------------------------- |\n| SGID                                                         | 可以作用于目录，也可以作用于文件                            |\n| 作用于文件 ： 和SUID作用一样                                 |                                                             |\n| 作用与目录 ： 继承父级目-----目录会不停的继承，下级目录会一直继承父级目录的权限值 |                                                             |\n| SBIT                                                         | 只有文件的拥有者才能删除修改该目录下的文件-----只能针对目录 |\n| S和T有大小写之分   大写 ： 没有x权限   小写 ： 有x权限       |                                                             |\n| 数字法 ：SUID=4、SGID=2、SBIT=1                              |                                                             |\n\n![img](【Linux】Linux基础/8.png)\n\n \n\n# l  **Linux进程**\n\n进程 ：已经启动的可执行程序的运行实例\n\nPID : 进程的ID（每一个进程都有唯一的PID）\n\nPPID ： 父进程的ID\n\n任何一个进程都可以创建紫进程\n\n| ｐｓ　：　查看当前的进程情况 |                          |\n| ---------------------------- | ------------------------ |\n| 选项                         | 作用                     |\n| －ａｕｘ／ａｕｘ             | 列出所有进程             |\n| －ｅｆ                       | 列出所有进程             |\n| －ｌ                         | 列出和当前用户有关的进程 |\n| －ｕ                         | 查看某一用户的进程       |\n| －ｔｏｐ                     | 实时查看进程状况         |\n\n![img](【Linux】Linux基础/9.png)\n\n","source":"_posts/【Linux】Linux基础.md","raw":"---\ntitle: Linux基础\ndate: 2019-08-25 18:25:16\ntags: Linux\ncategories: 学习笔记\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n<center>Linux学习笔记</center>\n\n# l  **pwd**：查看当前所在路\n\n命令格式：命令 -选项 -参数（目录）\n\n命令：\n\nls：查看当前路径下的文件\n\n选项：\n\n| 选项   | 作用                         |\n| ------ | ---------------------------- |\n| **-d** | 只查看当前目录的信息         |\n| **-l** | 查看详细信息                 |\n| **-a** | 显示所有文件（包含隐藏文件） |\n| **-h** | 显示文件大小                 |\n\n例：ls -l     命令 -选项\n\n选项可以组合：ls -a -l/ls -al：查看所有文件的详细信息\n\nls -al /etc/   命令 -选项 -参数 ：查看etc目录下的所有文件的详细信息\n\n# l  **cd** **：** **路径切换**        \n\n| 选项     | 作用                                                         |\n| -------- | ------------------------------------------------------------ |\n| “**-**”  | 返回到之前目录                                               |\n| “**..**” | 返回上一级目录（“.”当前目录，“..”上一级目录）                |\n| “**~**”  | 到用户所在的家目录（家目录：用户所在目录，如windowsC盘的用户目录） |\n\ntouch ：cd到临时目录tmp下可创建新文件    touch 文件名\n\n# l  **Linux目录结构**\n\n| 文件名     | 作用                    |\n| ---------- | ----------------------- |\n| /boot      | linux启动时，需要的文件 |\n| /dve       | 设备文件                |\n| /etc       | 配置文件                |\n| /home      | 用户家目录              |\n| /media     | 媒体文件                |\n| /mnt       | 挂载文件                |\n| /opt       | 第三方软件              |\n| /proc      | 虚拟化文件              |\n| /root      | 管理员的家目录          |\n| /run       | 远程文件                |\n| /srv       | 压缩过的文件            |\n| /sys       | 系统文件                |\n| /usr       | 安装的软件，            |\n| /var       | 可变数据、日志          |\n| /tmp       | 临时文件                |\n| /usr/bin   | 普通用户可以使用的命令  |\n| /usr/sbin  | 超级用户可以使用的命令  |\n| /usr/lib   | 32位库文件              |\n| /usr/lib64 | 64位库文件              |\n\n# l  **Linux文件处理**\n\n## **文件类型判断：**\n\n-ls -l\n\n![img](【Linux】Linux基础/1.png)\n\n| 文件以“_”开头 | 文件类型                            |\n| ------------- | ----------------------------------- |\n| “d”           | 目录                                |\n| “-”           | 文件                                |\n| “l”           | 链接文件（类似win中快捷方式）       |\n| “b”           | 设备文件，提供存储接口的设备        |\n| “c”           | 设备文件，提供串行结合口的设备—键盘 |\n\n \n\n## **文件处理：**\n\n![img](【Linux】Linux基础/2.png)\n\ncp            cp abc a：复制abc并命名为a/多文件复制：cp a abc goulandis/：复制a、abc到goulandis下\n\nmv            mv 文件1 文件2：将文件1更名为文件2/mv 文件1（文件2 ….） 目录：将文件移动到目录下                 \n\nrm             rm -f 文件1 （文件2…）：强制删除\n\nmkdir       mkdir -p （要创建的）目录1/（要创建的）目录2：创建目录1并在目录1下创建目录2\n\n## **查看文件：**  \n\n| 命令             | 作用                        |\n| ---------------- | --------------------------- |\n| **cat/****路径** | 查看文件                    |\n| nl               | 显示的时候，顺便出现行号    |\n| tac              | 从最后一行开始显示          |\n| head             | 显示文件前10行 -n：设置行数 |\n| tail             | 显示文件尾10行 -n：设置行数 |\n| wc               | 显示文件行数，数字，字节    |\n| more             | 一页一页翻动                |\n| **less**         | 一页一页翻动                |\n\n| **cat****和tac****选项** | 作用                           |\n| ------------------------ | ------------------------------ |\n| -A                       | 整合命令-vET（整合-v、-E、-T） |\n| -b                       | 列出行号，但是空白行不标志行号 |\n| -E                       | 将结尾的断行字符（$）显示出来  |\n| -n                       | 列出行号，空白行也会标志出来   |\n| -T                       | 将tab键以^I显示                |\n| -v                       | 列出一些看不出来的字符         |\n| <区分大小写>             |                                |\n\n| **nl****的选项** |                                  |                          |\n| ---------------- | -------------------------------- | ------------------------ |\n| 总选项           | 分选项                           | 作用                     |\n| b                | ba                               | 无论是否有空，都列出行号 |\n| bt               | 如果有空行，则不列出行号（默认） |                          |\n| n                | nln                              | 行号在屏幕最左方         |\n| nrn              | 行号在屏幕最右方，前面不加0      |                          |\n| nrz              | 行号在屏幕最右方，前面加0        |                          |\n| w                |                                  | 缩进多少位               |\n\n| **more****的选项** | 作用                 |\n| ------------------ | -------------------- |\n| 空格               | 向下翻一页           |\n| 回车               | 向下翻一行           |\n| /字符串            | 搜索                 |\n| :f                 | 立刻显示文件名和行数 |\n| b                  | 翻到第一页           |\n| q                  | 离开                 |\n\n| **less****的选项** | 作用                                |\n| ------------------ | ----------------------------------- |\n| **空格**           | 向下翻动一行                        |\n| **回车**           | 向下翻动一页                        |\n| **pagedown**       | 向下翻动一页                        |\n| **pageup**         | 向上翻动一页                        |\n| **n**              | 重复前一个搜索（操作：n）           |\n| **N**              | 反向重复前一个搜索（操作：shift+n） |\n| **q**              | 退出                                |\n\n| head和tail的选项                  | 作用                   |\n| --------------------------------- | ---------------------- |\n| -n                                | 指定显示几行，默认10行 |\n| 日志文件路径（/var/log/messages） | 查看日志               |\n\n| wc的选项 | 作用                                                       |\n| -------- | ---------------------------------------------------------- |\n| -c       | 只显示字节                                                 |\n| -w       | 只显示字数，一个字被定义为空白、跳格、换行字符、分隔字符串 |\n| -l       | 只显示行                                                   |\n\n| **Vim编辑器操作命令** | 作用           |\n| --------------------- | -------------- |\n| **i**                 | 插入           |\n| **esc**               | 退出           |\n| **u**                 | 撤销           |\n| **x**                 | 删除           |\n| **v**                 | 选择文本       |\n| **y**                 | 复制           |\n| **yy**                | 复制当前行     |\n| **dd**                | 删除光标所在行 |\n| **p**                 | 粘贴           |\n| **:w**                | 保存           |\n| **:wq**               | 保存并退出     |\n| **:q****！**          | 强制退出       |\n\n \n\n## **软链接：**\n\n![img](【Linux】Linux基础/3.png)\n\n![img](【Linux】Linux基础/4.png)\n\n## **硬链接：**\n\n![](【Linux】Linux基础/5.png)\n\nls -I ：查看Inode编号\n\n \n\n# l  **关机操作**\n\n| sync                   | 数据同步写入磁盘 |\n| ---------------------- | ---------------- |\n| **shutdown**           | 常用关机指令     |\n| reboot、halt、poweroff | 重启，关机       |\n\n| shutdown的指令 | 作用                                                         |\n| -------------- | ------------------------------------------------------------ |\n| -t             | 添加秒数。几秒后关机                                         |\n| -k             | 不是真关机，二十发出警告信息                                 |\n| **-r**         | 在系统服务都停止后，重启                                     |\n| **-h**         | 在系统服务都停止后，关机                                     |\n| -f             | 关闭，并且开机一个后强行略过磁盘检查                         |\n| -F             | 重启后强制进行磁盘检查                                       |\n| -c             | 取消已经在进行的shutdown指令内容                             |\n|                | shutdown -h now    现在马上停止服务并关机   shutdown -h 12：00       在12：00时刻停止服务并关机   shutdown -h +10     十分钟以后停止服务并关机   shutdown -r now     现在马上停止服务并重启   shutdown -r +30 ‘the system will reboot’       先发一个警告信息“the system will reboot”，系统将要在30分钟后重启   shutdown -k now ‘the system will reboot’     现在马上发出一个警告信息“the system will reboot” |\n\n# l  **Linux文件权限**\n\n![img](【Linux】Linux基础/6.png)\n\n| 权限 | 连接 | 所有者 | 所属组 | 容量（默认单位B） | 修改日期 | 文件名 |\n| ---- | ---- | ------ | ------ | ----------------- | -------- | ------ |\n|      |      |        |        |                   |          |        |\n\n| **文件的权限**                         |                  |\n| -------------------------------------- | ---------------- |\n| r、w、x ： 读、写、执行，没有权限就是- |                  |\n| 第一组rwx                              | 文件所有者的权限 |\n| 第二组rwx                              | 文件所属组的权限 |\n| 第三组rwx                              | 文件其他人的权限 |\n\n| **目录的权限** |                                                        |\n| -------------- | ------------------------------------------------------ |\n| r              | 具有读取目录的结构列表的权限，可以查看目录下有哪些文件 |\n| w              | 该权限对于目录来说是很大的                             |\n| 1              | 可以在该目录下新建新的文件和目录                       |\n| 2              | 可以删除已存在的文件和目录                             |\n| 3              | 将已存在的文件和目录重命名                             |\n| 4              | 移动该目录内的文件和目录的位置                         |\n| X              | 是否可以进入该目录                                     |\n\n| **文件权限的修改**                                           |                                                              |                          |      |          |      |\n| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------ | ---- | -------- | ---- |\n| 命令                                                         | 命令作用                                                     | 格式                     | 选项 | 选项作用 |      |\n| chown                                                        | 修改文件的拥有者，前提是要有该拥有者                         | chown 拥有者   文件/目录 | -R   | 递归修改 |      |\n| chgrp                                                        | 修改文件所属组，前提是要有该组                               |                          | -R   | 递归修改 |      |\n| chmod                                                        | 修改拥有者和所属组的权限                                     |                          |      |          |      |\n| 加减法                                                       | chmod    u/g/o+/-/=r/w/x 123：   将文件1213给用户/组/其他人加/减/赋予一个读/写/执行权限 |                          |      |          |      |\n| 数字法                                                       | r=4    w=2  x=1 ： chmod  632 123 ：   将文件123给用户赋予r和w权限，给组赋予wx权限，给其他人赋予w权限 |                          |      |          |      |\n| chown -R goulandis 123 ： 将123目录下的所有文件包括目录本身的拥有者修改为goulandis |                                                              |                          |      |          |      |\n|                                                              |                                                              |                          |      |          |      |\n\n**默认权限：**\n\numask      查看当前用户的umask权限       \n\numask –(选项) ：临时修改默认权限\n\n/etc/bashrc ： 永久修改默认权限（通过修改脚本文件实现）\n\numask的选项说明\n\n0022         拿走的权限\n\n​         第一个数字表示特殊权限\n\n​         022=rwxr-xr-x ：不拿走用户的权限、拿走用户组的w权限、拿走其他用户的w权限\n\n目录无法拿走x权限\n\n普通用户umask值 0002\n\nroot用户umask值 0022\n\n## **文件的特殊权限:**\n\n![img](【Linux】Linux基础/7.png)\n\n当s出现在拥有者的x权限的位置时，表示拥有者有SUID的权限（Set UID）\n\n当s出现在用户组的x权限的位置时，表示用户组有SGID的权限（Set GID）\n\n当s出现在其他人的x权限的位置时，表示其他人有SBIT的权限（Sticky Bit）\n\n| SUID                                                         | 临时获取文件拥有者的权限-----只能针对文件                   |\n| ------------------------------------------------------------ | ----------------------------------------------------------- |\n| SGID                                                         | 可以作用于目录，也可以作用于文件                            |\n| 作用于文件 ： 和SUID作用一样                                 |                                                             |\n| 作用与目录 ： 继承父级目-----目录会不停的继承，下级目录会一直继承父级目录的权限值 |                                                             |\n| SBIT                                                         | 只有文件的拥有者才能删除修改该目录下的文件-----只能针对目录 |\n| S和T有大小写之分   大写 ： 没有x权限   小写 ： 有x权限       |                                                             |\n| 数字法 ：SUID=4、SGID=2、SBIT=1                              |                                                             |\n\n![img](【Linux】Linux基础/8.png)\n\n \n\n# l  **Linux进程**\n\n进程 ：已经启动的可执行程序的运行实例\n\nPID : 进程的ID（每一个进程都有唯一的PID）\n\nPPID ： 父进程的ID\n\n任何一个进程都可以创建紫进程\n\n| ｐｓ　：　查看当前的进程情况 |                          |\n| ---------------------------- | ------------------------ |\n| 选项                         | 作用                     |\n| －ａｕｘ／ａｕｘ             | 列出所有进程             |\n| －ｅｆ                       | 列出所有进程             |\n| －ｌ                         | 列出和当前用户有关的进程 |\n| －ｕ                         | 查看某一用户的进程       |\n| －ｔｏｐ                     | 实时查看进程状况         |\n\n![img](【Linux】Linux基础/9.png)\n\n","slug":"【Linux】Linux基础","published":1,"updated":"2021-02-01T13:32:01.185Z","_id":"ckk9hocao000mdwr79a1l3si1","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<center>Linux学习笔记</center>\n\n<h1 id=\"l-pwd：查看当前所在路\"><a href=\"#l-pwd：查看当前所在路\" class=\"headerlink\" title=\"l  pwd：查看当前所在路\"></a>l  <strong>pwd</strong>：查看当前所在路</h1><p>命令格式：命令 -选项 -参数（目录）</p>\n<p>命令：</p>\n<p>ls：查看当前路径下的文件</p>\n<p>选项：</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>-d</strong></td>\n<td>只查看当前目录的信息</td>\n</tr>\n<tr>\n<td><strong>-l</strong></td>\n<td>查看详细信息</td>\n</tr>\n<tr>\n<td><strong>-a</strong></td>\n<td>显示所有文件（包含隐藏文件）</td>\n</tr>\n<tr>\n<td><strong>-h</strong></td>\n<td>显示文件大小</td>\n</tr>\n</tbody></table>\n<p>例：ls -l     命令 -选项</p>\n<p>选项可以组合：ls -a -l/ls -al：查看所有文件的详细信息</p>\n<p>ls -al /etc/   命令 -选项 -参数 ：查看etc目录下的所有文件的详细信息</p>\n<h1 id=\"l-cd-：-路径切换\"><a href=\"#l-cd-：-路径切换\" class=\"headerlink\" title=\"l  cd ： 路径切换\"></a>l  <strong>cd</strong> <strong>：</strong> <strong>路径切换</strong></h1><table>\n<thead>\n<tr>\n<th>选项</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>“**-**”</td>\n<td>返回到之前目录</td>\n</tr>\n<tr>\n<td>“**..**”</td>\n<td>返回上一级目录（“.”当前目录，“..”上一级目录）</td>\n</tr>\n<tr>\n<td>“**~**”</td>\n<td>到用户所在的家目录（家目录：用户所在目录，如windowsC盘的用户目录）</td>\n</tr>\n</tbody></table>\n<p>touch ：cd到临时目录tmp下可创建新文件    touch 文件名</p>\n<h1 id=\"l-Linux目录结构\"><a href=\"#l-Linux目录结构\" class=\"headerlink\" title=\"l  Linux目录结构\"></a>l  <strong>Linux目录结构</strong></h1><table>\n<thead>\n<tr>\n<th>文件名</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>/boot</td>\n<td>linux启动时，需要的文件</td>\n</tr>\n<tr>\n<td>/dve</td>\n<td>设备文件</td>\n</tr>\n<tr>\n<td>/etc</td>\n<td>配置文件</td>\n</tr>\n<tr>\n<td>/home</td>\n<td>用户家目录</td>\n</tr>\n<tr>\n<td>/media</td>\n<td>媒体文件</td>\n</tr>\n<tr>\n<td>/mnt</td>\n<td>挂载文件</td>\n</tr>\n<tr>\n<td>/opt</td>\n<td>第三方软件</td>\n</tr>\n<tr>\n<td>/proc</td>\n<td>虚拟化文件</td>\n</tr>\n<tr>\n<td>/root</td>\n<td>管理员的家目录</td>\n</tr>\n<tr>\n<td>/run</td>\n<td>远程文件</td>\n</tr>\n<tr>\n<td>/srv</td>\n<td>压缩过的文件</td>\n</tr>\n<tr>\n<td>/sys</td>\n<td>系统文件</td>\n</tr>\n<tr>\n<td>/usr</td>\n<td>安装的软件，</td>\n</tr>\n<tr>\n<td>/var</td>\n<td>可变数据、日志</td>\n</tr>\n<tr>\n<td>/tmp</td>\n<td>临时文件</td>\n</tr>\n<tr>\n<td>/usr/bin</td>\n<td>普通用户可以使用的命令</td>\n</tr>\n<tr>\n<td>/usr/sbin</td>\n<td>超级用户可以使用的命令</td>\n</tr>\n<tr>\n<td>/usr/lib</td>\n<td>32位库文件</td>\n</tr>\n<tr>\n<td>/usr/lib64</td>\n<td>64位库文件</td>\n</tr>\n</tbody></table>\n<h1 id=\"l-Linux文件处理\"><a href=\"#l-Linux文件处理\" class=\"headerlink\" title=\"l  Linux文件处理\"></a>l  <strong>Linux文件处理</strong></h1><h2 id=\"文件类型判断：\"><a href=\"#文件类型判断：\" class=\"headerlink\" title=\"文件类型判断：\"></a><strong>文件类型判断：</strong></h2><p>-ls -l</p>\n<p><img src=\"/2019/08/25/%E3%80%90Linux%E3%80%91Linux%E5%9F%BA%E7%A1%80/1.png\" alt=\"img\"></p>\n<table>\n<thead>\n<tr>\n<th>文件以“_”开头</th>\n<th>文件类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>“d”</td>\n<td>目录</td>\n</tr>\n<tr>\n<td>“-”</td>\n<td>文件</td>\n</tr>\n<tr>\n<td>“l”</td>\n<td>链接文件（类似win中快捷方式）</td>\n</tr>\n<tr>\n<td>“b”</td>\n<td>设备文件，提供存储接口的设备</td>\n</tr>\n<tr>\n<td>“c”</td>\n<td>设备文件，提供串行结合口的设备—键盘</td>\n</tr>\n</tbody></table>\n<h2 id=\"文件处理：\"><a href=\"#文件处理：\" class=\"headerlink\" title=\"文件处理：\"></a><strong>文件处理：</strong></h2><p><img src=\"/2019/08/25/%E3%80%90Linux%E3%80%91Linux%E5%9F%BA%E7%A1%80/2.png\" alt=\"img\"></p>\n<p>cp            cp abc a：复制abc并命名为a/多文件复制：cp a abc goulandis/：复制a、abc到goulandis下</p>\n<p>mv            mv 文件1 文件2：将文件1更名为文件2/mv 文件1（文件2 ….） 目录：将文件移动到目录下                 </p>\n<p>rm             rm -f 文件1 （文件2…）：强制删除</p>\n<p>mkdir       mkdir -p （要创建的）目录1/（要创建的）目录2：创建目录1并在目录1下创建目录2</p>\n<h2 id=\"查看文件：\"><a href=\"#查看文件：\" class=\"headerlink\" title=\"查看文件：\"></a><strong>查看文件：</strong></h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>cat/**</strong>路径**</td>\n<td>查看文件</td>\n</tr>\n<tr>\n<td>nl</td>\n<td>显示的时候，顺便出现行号</td>\n</tr>\n<tr>\n<td>tac</td>\n<td>从最后一行开始显示</td>\n</tr>\n<tr>\n<td>head</td>\n<td>显示文件前10行 -n：设置行数</td>\n</tr>\n<tr>\n<td>tail</td>\n<td>显示文件尾10行 -n：设置行数</td>\n</tr>\n<tr>\n<td>wc</td>\n<td>显示文件行数，数字，字节</td>\n</tr>\n<tr>\n<td>more</td>\n<td>一页一页翻动</td>\n</tr>\n<tr>\n<td><strong>less</strong></td>\n<td>一页一页翻动</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th><strong>cat**</strong>和tac**<strong>选项</strong></th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-A</td>\n<td>整合命令-vET（整合-v、-E、-T）</td>\n</tr>\n<tr>\n<td>-b</td>\n<td>列出行号，但是空白行不标志行号</td>\n</tr>\n<tr>\n<td>-E</td>\n<td>将结尾的断行字符（$）显示出来</td>\n</tr>\n<tr>\n<td>-n</td>\n<td>列出行号，空白行也会标志出来</td>\n</tr>\n<tr>\n<td>-T</td>\n<td>将tab键以^I显示</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>列出一些看不出来的字符</td>\n</tr>\n<tr>\n<td>&lt;区分大小写&gt;</td>\n<td></td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th><strong>nl**</strong>的选项**</th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>总选项</td>\n<td>分选项</td>\n<td>作用</td>\n</tr>\n<tr>\n<td>b</td>\n<td>ba</td>\n<td>无论是否有空，都列出行号</td>\n</tr>\n<tr>\n<td>bt</td>\n<td>如果有空行，则不列出行号（默认）</td>\n<td></td>\n</tr>\n<tr>\n<td>n</td>\n<td>nln</td>\n<td>行号在屏幕最左方</td>\n</tr>\n<tr>\n<td>nrn</td>\n<td>行号在屏幕最右方，前面不加0</td>\n<td></td>\n</tr>\n<tr>\n<td>nrz</td>\n<td>行号在屏幕最右方，前面加0</td>\n<td></td>\n</tr>\n<tr>\n<td>w</td>\n<td></td>\n<td>缩进多少位</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th><strong>more**</strong>的选项**</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>空格</td>\n<td>向下翻一页</td>\n</tr>\n<tr>\n<td>回车</td>\n<td>向下翻一行</td>\n</tr>\n<tr>\n<td>/字符串</td>\n<td>搜索</td>\n</tr>\n<tr>\n<td>:f</td>\n<td>立刻显示文件名和行数</td>\n</tr>\n<tr>\n<td>b</td>\n<td>翻到第一页</td>\n</tr>\n<tr>\n<td>q</td>\n<td>离开</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th><strong>less**</strong>的选项**</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>空格</strong></td>\n<td>向下翻动一行</td>\n</tr>\n<tr>\n<td><strong>回车</strong></td>\n<td>向下翻动一页</td>\n</tr>\n<tr>\n<td><strong>pagedown</strong></td>\n<td>向下翻动一页</td>\n</tr>\n<tr>\n<td><strong>pageup</strong></td>\n<td>向上翻动一页</td>\n</tr>\n<tr>\n<td><strong>n</strong></td>\n<td>重复前一个搜索（操作：n）</td>\n</tr>\n<tr>\n<td><strong>N</strong></td>\n<td>反向重复前一个搜索（操作：shift+n）</td>\n</tr>\n<tr>\n<td><strong>q</strong></td>\n<td>退出</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>head和tail的选项</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-n</td>\n<td>指定显示几行，默认10行</td>\n</tr>\n<tr>\n<td>日志文件路径（/var/log/messages）</td>\n<td>查看日志</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>wc的选项</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-c</td>\n<td>只显示字节</td>\n</tr>\n<tr>\n<td>-w</td>\n<td>只显示字数，一个字被定义为空白、跳格、换行字符、分隔字符串</td>\n</tr>\n<tr>\n<td>-l</td>\n<td>只显示行</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th><strong>Vim编辑器操作命令</strong></th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>i</strong></td>\n<td>插入</td>\n</tr>\n<tr>\n<td><strong>esc</strong></td>\n<td>退出</td>\n</tr>\n<tr>\n<td><strong>u</strong></td>\n<td>撤销</td>\n</tr>\n<tr>\n<td><strong>x</strong></td>\n<td>删除</td>\n</tr>\n<tr>\n<td><strong>v</strong></td>\n<td>选择文本</td>\n</tr>\n<tr>\n<td><strong>y</strong></td>\n<td>复制</td>\n</tr>\n<tr>\n<td><strong>yy</strong></td>\n<td>复制当前行</td>\n</tr>\n<tr>\n<td><strong>dd</strong></td>\n<td>删除光标所在行</td>\n</tr>\n<tr>\n<td><strong>p</strong></td>\n<td>粘贴</td>\n</tr>\n<tr>\n<td><strong>:w</strong></td>\n<td>保存</td>\n</tr>\n<tr>\n<td><strong>:wq</strong></td>\n<td>保存并退出</td>\n</tr>\n<tr>\n<td><strong>:q**</strong>！**</td>\n<td>强制退出</td>\n</tr>\n</tbody></table>\n<h2 id=\"软链接：\"><a href=\"#软链接：\" class=\"headerlink\" title=\"软链接：\"></a><strong>软链接：</strong></h2><p><img src=\"/2019/08/25/%E3%80%90Linux%E3%80%91Linux%E5%9F%BA%E7%A1%80/3.png\" alt=\"img\"></p>\n<p><img src=\"/2019/08/25/%E3%80%90Linux%E3%80%91Linux%E5%9F%BA%E7%A1%80/4.png\" alt=\"img\"></p>\n<h2 id=\"硬链接：\"><a href=\"#硬链接：\" class=\"headerlink\" title=\"硬链接：\"></a><strong>硬链接：</strong></h2><p><img src=\"/2019/08/25/%E3%80%90Linux%E3%80%91Linux%E5%9F%BA%E7%A1%80/5.png\"></p>\n<p>ls -I ：查看Inode编号</p>\n<h1 id=\"l-关机操作\"><a href=\"#l-关机操作\" class=\"headerlink\" title=\"l  关机操作\"></a>l  <strong>关机操作</strong></h1><table>\n<thead>\n<tr>\n<th>sync</th>\n<th>数据同步写入磁盘</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>shutdown</strong></td>\n<td>常用关机指令</td>\n</tr>\n<tr>\n<td>reboot、halt、poweroff</td>\n<td>重启，关机</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>shutdown的指令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-t</td>\n<td>添加秒数。几秒后关机</td>\n</tr>\n<tr>\n<td>-k</td>\n<td>不是真关机，二十发出警告信息</td>\n</tr>\n<tr>\n<td><strong>-r</strong></td>\n<td>在系统服务都停止后，重启</td>\n</tr>\n<tr>\n<td><strong>-h</strong></td>\n<td>在系统服务都停止后，关机</td>\n</tr>\n<tr>\n<td>-f</td>\n<td>关闭，并且开机一个后强行略过磁盘检查</td>\n</tr>\n<tr>\n<td>-F</td>\n<td>重启后强制进行磁盘检查</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>取消已经在进行的shutdown指令内容</td>\n</tr>\n<tr>\n<td></td>\n<td>shutdown -h now    现在马上停止服务并关机   shutdown -h 12：00       在12：00时刻停止服务并关机   shutdown -h +10     十分钟以后停止服务并关机   shutdown -r now     现在马上停止服务并重启   shutdown -r +30 ‘the system will reboot’       先发一个警告信息“the system will reboot”，系统将要在30分钟后重启   shutdown -k now ‘the system will reboot’     现在马上发出一个警告信息“the system will reboot”</td>\n</tr>\n</tbody></table>\n<h1 id=\"l-Linux文件权限\"><a href=\"#l-Linux文件权限\" class=\"headerlink\" title=\"l  Linux文件权限\"></a>l  <strong>Linux文件权限</strong></h1><p><img src=\"/2019/08/25/%E3%80%90Linux%E3%80%91Linux%E5%9F%BA%E7%A1%80/6.png\" alt=\"img\"></p>\n<table>\n<thead>\n<tr>\n<th>权限</th>\n<th>连接</th>\n<th>所有者</th>\n<th>所属组</th>\n<th>容量（默认单位B）</th>\n<th>修改日期</th>\n<th>文件名</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th><strong>文件的权限</strong></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>r、w、x ： 读、写、执行，没有权限就是-</td>\n<td></td>\n</tr>\n<tr>\n<td>第一组rwx</td>\n<td>文件所有者的权限</td>\n</tr>\n<tr>\n<td>第二组rwx</td>\n<td>文件所属组的权限</td>\n</tr>\n<tr>\n<td>第三组rwx</td>\n<td>文件其他人的权限</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th><strong>目录的权限</strong></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>r</td>\n<td>具有读取目录的结构列表的权限，可以查看目录下有哪些文件</td>\n</tr>\n<tr>\n<td>w</td>\n<td>该权限对于目录来说是很大的</td>\n</tr>\n<tr>\n<td>1</td>\n<td>可以在该目录下新建新的文件和目录</td>\n</tr>\n<tr>\n<td>2</td>\n<td>可以删除已存在的文件和目录</td>\n</tr>\n<tr>\n<td>3</td>\n<td>将已存在的文件和目录重命名</td>\n</tr>\n<tr>\n<td>4</td>\n<td>移动该目录内的文件和目录的位置</td>\n</tr>\n<tr>\n<td>X</td>\n<td>是否可以进入该目录</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th><strong>文件权限的修改</strong></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>命令</td>\n<td>命令作用</td>\n<td>格式</td>\n<td>选项</td>\n<td>选项作用</td>\n<td></td>\n</tr>\n<tr>\n<td>chown</td>\n<td>修改文件的拥有者，前提是要有该拥有者</td>\n<td>chown 拥有者   文件/目录</td>\n<td>-R</td>\n<td>递归修改</td>\n<td></td>\n</tr>\n<tr>\n<td>chgrp</td>\n<td>修改文件所属组，前提是要有该组</td>\n<td></td>\n<td>-R</td>\n<td>递归修改</td>\n<td></td>\n</tr>\n<tr>\n<td>chmod</td>\n<td>修改拥有者和所属组的权限</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>加减法</td>\n<td>chmod    u/g/o+/-/=r/w/x 123：   将文件1213给用户/组/其他人加/减/赋予一个读/写/执行权限</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>数字法</td>\n<td>r=4    w=2  x=1 ： chmod  632 123 ：   将文件123给用户赋予r和w权限，给组赋予wx权限，给其他人赋予w权限</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>chown -R goulandis 123 ： 将123目录下的所有文件包括目录本身的拥有者修改为goulandis</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p><strong>默认权限：</strong></p>\n<p>umask      查看当前用户的umask权限       </p>\n<p>umask –(选项) ：临时修改默认权限</p>\n<p>/etc/bashrc ： 永久修改默认权限（通过修改脚本文件实现）</p>\n<p>umask的选项说明</p>\n<p>0022         拿走的权限</p>\n<p>​         第一个数字表示特殊权限</p>\n<p>​         022=rwxr-xr-x ：不拿走用户的权限、拿走用户组的w权限、拿走其他用户的w权限</p>\n<p>目录无法拿走x权限</p>\n<p>普通用户umask值 0002</p>\n<p>root用户umask值 0022</p>\n<h2 id=\"文件的特殊权限\"><a href=\"#文件的特殊权限\" class=\"headerlink\" title=\"文件的特殊权限:\"></a><strong>文件的特殊权限:</strong></h2><p><img src=\"/2019/08/25/%E3%80%90Linux%E3%80%91Linux%E5%9F%BA%E7%A1%80/7.png\" alt=\"img\"></p>\n<p>当s出现在拥有者的x权限的位置时，表示拥有者有SUID的权限（Set UID）</p>\n<p>当s出现在用户组的x权限的位置时，表示用户组有SGID的权限（Set GID）</p>\n<p>当s出现在其他人的x权限的位置时，表示其他人有SBIT的权限（Sticky Bit）</p>\n<table>\n<thead>\n<tr>\n<th>SUID</th>\n<th>临时获取文件拥有者的权限—–只能针对文件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SGID</td>\n<td>可以作用于目录，也可以作用于文件</td>\n</tr>\n<tr>\n<td>作用于文件 ： 和SUID作用一样</td>\n<td></td>\n</tr>\n<tr>\n<td>作用与目录 ： 继承父级目—–目录会不停的继承，下级目录会一直继承父级目录的权限值</td>\n<td></td>\n</tr>\n<tr>\n<td>SBIT</td>\n<td>只有文件的拥有者才能删除修改该目录下的文件—–只能针对目录</td>\n</tr>\n<tr>\n<td>S和T有大小写之分   大写 ： 没有x权限   小写 ： 有x权限</td>\n<td></td>\n</tr>\n<tr>\n<td>数字法 ：SUID=4、SGID=2、SBIT=1</td>\n<td></td>\n</tr>\n</tbody></table>\n<p><img src=\"/2019/08/25/%E3%80%90Linux%E3%80%91Linux%E5%9F%BA%E7%A1%80/8.png\" alt=\"img\"></p>\n<h1 id=\"l-Linux进程\"><a href=\"#l-Linux进程\" class=\"headerlink\" title=\"l  Linux进程\"></a>l  <strong>Linux进程</strong></h1><p>进程 ：已经启动的可执行程序的运行实例</p>\n<p>PID : 进程的ID（每一个进程都有唯一的PID）</p>\n<p>PPID ： 父进程的ID</p>\n<p>任何一个进程都可以创建紫进程</p>\n<table>\n<thead>\n<tr>\n<th>ｐｓ　：　查看当前的进程情况</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>选项</td>\n<td>作用</td>\n</tr>\n<tr>\n<td>－ａｕｘ／ａｕｘ</td>\n<td>列出所有进程</td>\n</tr>\n<tr>\n<td>－ｅｆ</td>\n<td>列出所有进程</td>\n</tr>\n<tr>\n<td>－ｌ</td>\n<td>列出和当前用户有关的进程</td>\n</tr>\n<tr>\n<td>－ｕ</td>\n<td>查看某一用户的进程</td>\n</tr>\n<tr>\n<td>－ｔｏｐ</td>\n<td>实时查看进程状况</td>\n</tr>\n</tbody></table>\n<p><img src=\"/2019/08/25/%E3%80%90Linux%E3%80%91Linux%E5%9F%BA%E7%A1%80/9.png\" alt=\"img\"></p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<center>Linux学习笔记</center>\n\n<h1 id=\"l-pwd：查看当前所在路\"><a href=\"#l-pwd：查看当前所在路\" class=\"headerlink\" title=\"l  pwd：查看当前所在路\"></a>l  <strong>pwd</strong>：查看当前所在路</h1><p>命令格式：命令 -选项 -参数（目录）</p>\n<p>命令：</p>\n<p>ls：查看当前路径下的文件</p>\n<p>选项：</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>-d</strong></td>\n<td>只查看当前目录的信息</td>\n</tr>\n<tr>\n<td><strong>-l</strong></td>\n<td>查看详细信息</td>\n</tr>\n<tr>\n<td><strong>-a</strong></td>\n<td>显示所有文件（包含隐藏文件）</td>\n</tr>\n<tr>\n<td><strong>-h</strong></td>\n<td>显示文件大小</td>\n</tr>\n</tbody></table>\n<p>例：ls -l     命令 -选项</p>\n<p>选项可以组合：ls -a -l/ls -al：查看所有文件的详细信息</p>\n<p>ls -al /etc/   命令 -选项 -参数 ：查看etc目录下的所有文件的详细信息</p>\n<h1 id=\"l-cd-：-路径切换\"><a href=\"#l-cd-：-路径切换\" class=\"headerlink\" title=\"l  cd ： 路径切换\"></a>l  <strong>cd</strong> <strong>：</strong> <strong>路径切换</strong></h1><table>\n<thead>\n<tr>\n<th>选项</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>“**-**”</td>\n<td>返回到之前目录</td>\n</tr>\n<tr>\n<td>“**..**”</td>\n<td>返回上一级目录（“.”当前目录，“..”上一级目录）</td>\n</tr>\n<tr>\n<td>“**~**”</td>\n<td>到用户所在的家目录（家目录：用户所在目录，如windowsC盘的用户目录）</td>\n</tr>\n</tbody></table>\n<p>touch ：cd到临时目录tmp下可创建新文件    touch 文件名</p>\n<h1 id=\"l-Linux目录结构\"><a href=\"#l-Linux目录结构\" class=\"headerlink\" title=\"l  Linux目录结构\"></a>l  <strong>Linux目录结构</strong></h1><table>\n<thead>\n<tr>\n<th>文件名</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>/boot</td>\n<td>linux启动时，需要的文件</td>\n</tr>\n<tr>\n<td>/dve</td>\n<td>设备文件</td>\n</tr>\n<tr>\n<td>/etc</td>\n<td>配置文件</td>\n</tr>\n<tr>\n<td>/home</td>\n<td>用户家目录</td>\n</tr>\n<tr>\n<td>/media</td>\n<td>媒体文件</td>\n</tr>\n<tr>\n<td>/mnt</td>\n<td>挂载文件</td>\n</tr>\n<tr>\n<td>/opt</td>\n<td>第三方软件</td>\n</tr>\n<tr>\n<td>/proc</td>\n<td>虚拟化文件</td>\n</tr>\n<tr>\n<td>/root</td>\n<td>管理员的家目录</td>\n</tr>\n<tr>\n<td>/run</td>\n<td>远程文件</td>\n</tr>\n<tr>\n<td>/srv</td>\n<td>压缩过的文件</td>\n</tr>\n<tr>\n<td>/sys</td>\n<td>系统文件</td>\n</tr>\n<tr>\n<td>/usr</td>\n<td>安装的软件，</td>\n</tr>\n<tr>\n<td>/var</td>\n<td>可变数据、日志</td>\n</tr>\n<tr>\n<td>/tmp</td>\n<td>临时文件</td>\n</tr>\n<tr>\n<td>/usr/bin</td>\n<td>普通用户可以使用的命令</td>\n</tr>\n<tr>\n<td>/usr/sbin</td>\n<td>超级用户可以使用的命令</td>\n</tr>\n<tr>\n<td>/usr/lib</td>\n<td>32位库文件</td>\n</tr>\n<tr>\n<td>/usr/lib64</td>\n<td>64位库文件</td>\n</tr>\n</tbody></table>\n<h1 id=\"l-Linux文件处理\"><a href=\"#l-Linux文件处理\" class=\"headerlink\" title=\"l  Linux文件处理\"></a>l  <strong>Linux文件处理</strong></h1><h2 id=\"文件类型判断：\"><a href=\"#文件类型判断：\" class=\"headerlink\" title=\"文件类型判断：\"></a><strong>文件类型判断：</strong></h2><p>-ls -l</p>\n<p><img src=\"/2019/08/25/%E3%80%90Linux%E3%80%91Linux%E5%9F%BA%E7%A1%80/1.png\" alt=\"img\"></p>\n<table>\n<thead>\n<tr>\n<th>文件以“_”开头</th>\n<th>文件类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>“d”</td>\n<td>目录</td>\n</tr>\n<tr>\n<td>“-”</td>\n<td>文件</td>\n</tr>\n<tr>\n<td>“l”</td>\n<td>链接文件（类似win中快捷方式）</td>\n</tr>\n<tr>\n<td>“b”</td>\n<td>设备文件，提供存储接口的设备</td>\n</tr>\n<tr>\n<td>“c”</td>\n<td>设备文件，提供串行结合口的设备—键盘</td>\n</tr>\n</tbody></table>\n<h2 id=\"文件处理：\"><a href=\"#文件处理：\" class=\"headerlink\" title=\"文件处理：\"></a><strong>文件处理：</strong></h2><p><img src=\"/2019/08/25/%E3%80%90Linux%E3%80%91Linux%E5%9F%BA%E7%A1%80/2.png\" alt=\"img\"></p>\n<p>cp            cp abc a：复制abc并命名为a/多文件复制：cp a abc goulandis/：复制a、abc到goulandis下</p>\n<p>mv            mv 文件1 文件2：将文件1更名为文件2/mv 文件1（文件2 ….） 目录：将文件移动到目录下                 </p>\n<p>rm             rm -f 文件1 （文件2…）：强制删除</p>\n<p>mkdir       mkdir -p （要创建的）目录1/（要创建的）目录2：创建目录1并在目录1下创建目录2</p>\n<h2 id=\"查看文件：\"><a href=\"#查看文件：\" class=\"headerlink\" title=\"查看文件：\"></a><strong>查看文件：</strong></h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>cat/**</strong>路径**</td>\n<td>查看文件</td>\n</tr>\n<tr>\n<td>nl</td>\n<td>显示的时候，顺便出现行号</td>\n</tr>\n<tr>\n<td>tac</td>\n<td>从最后一行开始显示</td>\n</tr>\n<tr>\n<td>head</td>\n<td>显示文件前10行 -n：设置行数</td>\n</tr>\n<tr>\n<td>tail</td>\n<td>显示文件尾10行 -n：设置行数</td>\n</tr>\n<tr>\n<td>wc</td>\n<td>显示文件行数，数字，字节</td>\n</tr>\n<tr>\n<td>more</td>\n<td>一页一页翻动</td>\n</tr>\n<tr>\n<td><strong>less</strong></td>\n<td>一页一页翻动</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th><strong>cat**</strong>和tac**<strong>选项</strong></th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-A</td>\n<td>整合命令-vET（整合-v、-E、-T）</td>\n</tr>\n<tr>\n<td>-b</td>\n<td>列出行号，但是空白行不标志行号</td>\n</tr>\n<tr>\n<td>-E</td>\n<td>将结尾的断行字符（$）显示出来</td>\n</tr>\n<tr>\n<td>-n</td>\n<td>列出行号，空白行也会标志出来</td>\n</tr>\n<tr>\n<td>-T</td>\n<td>将tab键以^I显示</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>列出一些看不出来的字符</td>\n</tr>\n<tr>\n<td>&lt;区分大小写&gt;</td>\n<td></td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th><strong>nl**</strong>的选项**</th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>总选项</td>\n<td>分选项</td>\n<td>作用</td>\n</tr>\n<tr>\n<td>b</td>\n<td>ba</td>\n<td>无论是否有空，都列出行号</td>\n</tr>\n<tr>\n<td>bt</td>\n<td>如果有空行，则不列出行号（默认）</td>\n<td></td>\n</tr>\n<tr>\n<td>n</td>\n<td>nln</td>\n<td>行号在屏幕最左方</td>\n</tr>\n<tr>\n<td>nrn</td>\n<td>行号在屏幕最右方，前面不加0</td>\n<td></td>\n</tr>\n<tr>\n<td>nrz</td>\n<td>行号在屏幕最右方，前面加0</td>\n<td></td>\n</tr>\n<tr>\n<td>w</td>\n<td></td>\n<td>缩进多少位</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th><strong>more**</strong>的选项**</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>空格</td>\n<td>向下翻一页</td>\n</tr>\n<tr>\n<td>回车</td>\n<td>向下翻一行</td>\n</tr>\n<tr>\n<td>/字符串</td>\n<td>搜索</td>\n</tr>\n<tr>\n<td>:f</td>\n<td>立刻显示文件名和行数</td>\n</tr>\n<tr>\n<td>b</td>\n<td>翻到第一页</td>\n</tr>\n<tr>\n<td>q</td>\n<td>离开</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th><strong>less**</strong>的选项**</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>空格</strong></td>\n<td>向下翻动一行</td>\n</tr>\n<tr>\n<td><strong>回车</strong></td>\n<td>向下翻动一页</td>\n</tr>\n<tr>\n<td><strong>pagedown</strong></td>\n<td>向下翻动一页</td>\n</tr>\n<tr>\n<td><strong>pageup</strong></td>\n<td>向上翻动一页</td>\n</tr>\n<tr>\n<td><strong>n</strong></td>\n<td>重复前一个搜索（操作：n）</td>\n</tr>\n<tr>\n<td><strong>N</strong></td>\n<td>反向重复前一个搜索（操作：shift+n）</td>\n</tr>\n<tr>\n<td><strong>q</strong></td>\n<td>退出</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>head和tail的选项</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-n</td>\n<td>指定显示几行，默认10行</td>\n</tr>\n<tr>\n<td>日志文件路径（/var/log/messages）</td>\n<td>查看日志</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>wc的选项</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-c</td>\n<td>只显示字节</td>\n</tr>\n<tr>\n<td>-w</td>\n<td>只显示字数，一个字被定义为空白、跳格、换行字符、分隔字符串</td>\n</tr>\n<tr>\n<td>-l</td>\n<td>只显示行</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th><strong>Vim编辑器操作命令</strong></th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>i</strong></td>\n<td>插入</td>\n</tr>\n<tr>\n<td><strong>esc</strong></td>\n<td>退出</td>\n</tr>\n<tr>\n<td><strong>u</strong></td>\n<td>撤销</td>\n</tr>\n<tr>\n<td><strong>x</strong></td>\n<td>删除</td>\n</tr>\n<tr>\n<td><strong>v</strong></td>\n<td>选择文本</td>\n</tr>\n<tr>\n<td><strong>y</strong></td>\n<td>复制</td>\n</tr>\n<tr>\n<td><strong>yy</strong></td>\n<td>复制当前行</td>\n</tr>\n<tr>\n<td><strong>dd</strong></td>\n<td>删除光标所在行</td>\n</tr>\n<tr>\n<td><strong>p</strong></td>\n<td>粘贴</td>\n</tr>\n<tr>\n<td><strong>:w</strong></td>\n<td>保存</td>\n</tr>\n<tr>\n<td><strong>:wq</strong></td>\n<td>保存并退出</td>\n</tr>\n<tr>\n<td><strong>:q**</strong>！**</td>\n<td>强制退出</td>\n</tr>\n</tbody></table>\n<h2 id=\"软链接：\"><a href=\"#软链接：\" class=\"headerlink\" title=\"软链接：\"></a><strong>软链接：</strong></h2><p><img src=\"/2019/08/25/%E3%80%90Linux%E3%80%91Linux%E5%9F%BA%E7%A1%80/3.png\" alt=\"img\"></p>\n<p><img src=\"/2019/08/25/%E3%80%90Linux%E3%80%91Linux%E5%9F%BA%E7%A1%80/4.png\" alt=\"img\"></p>\n<h2 id=\"硬链接：\"><a href=\"#硬链接：\" class=\"headerlink\" title=\"硬链接：\"></a><strong>硬链接：</strong></h2><p><img src=\"/2019/08/25/%E3%80%90Linux%E3%80%91Linux%E5%9F%BA%E7%A1%80/5.png\"></p>\n<p>ls -I ：查看Inode编号</p>\n<h1 id=\"l-关机操作\"><a href=\"#l-关机操作\" class=\"headerlink\" title=\"l  关机操作\"></a>l  <strong>关机操作</strong></h1><table>\n<thead>\n<tr>\n<th>sync</th>\n<th>数据同步写入磁盘</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>shutdown</strong></td>\n<td>常用关机指令</td>\n</tr>\n<tr>\n<td>reboot、halt、poweroff</td>\n<td>重启，关机</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>shutdown的指令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-t</td>\n<td>添加秒数。几秒后关机</td>\n</tr>\n<tr>\n<td>-k</td>\n<td>不是真关机，二十发出警告信息</td>\n</tr>\n<tr>\n<td><strong>-r</strong></td>\n<td>在系统服务都停止后，重启</td>\n</tr>\n<tr>\n<td><strong>-h</strong></td>\n<td>在系统服务都停止后，关机</td>\n</tr>\n<tr>\n<td>-f</td>\n<td>关闭，并且开机一个后强行略过磁盘检查</td>\n</tr>\n<tr>\n<td>-F</td>\n<td>重启后强制进行磁盘检查</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>取消已经在进行的shutdown指令内容</td>\n</tr>\n<tr>\n<td></td>\n<td>shutdown -h now    现在马上停止服务并关机   shutdown -h 12：00       在12：00时刻停止服务并关机   shutdown -h +10     十分钟以后停止服务并关机   shutdown -r now     现在马上停止服务并重启   shutdown -r +30 ‘the system will reboot’       先发一个警告信息“the system will reboot”，系统将要在30分钟后重启   shutdown -k now ‘the system will reboot’     现在马上发出一个警告信息“the system will reboot”</td>\n</tr>\n</tbody></table>\n<h1 id=\"l-Linux文件权限\"><a href=\"#l-Linux文件权限\" class=\"headerlink\" title=\"l  Linux文件权限\"></a>l  <strong>Linux文件权限</strong></h1><p><img src=\"/2019/08/25/%E3%80%90Linux%E3%80%91Linux%E5%9F%BA%E7%A1%80/6.png\" alt=\"img\"></p>\n<table>\n<thead>\n<tr>\n<th>权限</th>\n<th>连接</th>\n<th>所有者</th>\n<th>所属组</th>\n<th>容量（默认单位B）</th>\n<th>修改日期</th>\n<th>文件名</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th><strong>文件的权限</strong></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>r、w、x ： 读、写、执行，没有权限就是-</td>\n<td></td>\n</tr>\n<tr>\n<td>第一组rwx</td>\n<td>文件所有者的权限</td>\n</tr>\n<tr>\n<td>第二组rwx</td>\n<td>文件所属组的权限</td>\n</tr>\n<tr>\n<td>第三组rwx</td>\n<td>文件其他人的权限</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th><strong>目录的权限</strong></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>r</td>\n<td>具有读取目录的结构列表的权限，可以查看目录下有哪些文件</td>\n</tr>\n<tr>\n<td>w</td>\n<td>该权限对于目录来说是很大的</td>\n</tr>\n<tr>\n<td>1</td>\n<td>可以在该目录下新建新的文件和目录</td>\n</tr>\n<tr>\n<td>2</td>\n<td>可以删除已存在的文件和目录</td>\n</tr>\n<tr>\n<td>3</td>\n<td>将已存在的文件和目录重命名</td>\n</tr>\n<tr>\n<td>4</td>\n<td>移动该目录内的文件和目录的位置</td>\n</tr>\n<tr>\n<td>X</td>\n<td>是否可以进入该目录</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th><strong>文件权限的修改</strong></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>命令</td>\n<td>命令作用</td>\n<td>格式</td>\n<td>选项</td>\n<td>选项作用</td>\n<td></td>\n</tr>\n<tr>\n<td>chown</td>\n<td>修改文件的拥有者，前提是要有该拥有者</td>\n<td>chown 拥有者   文件/目录</td>\n<td>-R</td>\n<td>递归修改</td>\n<td></td>\n</tr>\n<tr>\n<td>chgrp</td>\n<td>修改文件所属组，前提是要有该组</td>\n<td></td>\n<td>-R</td>\n<td>递归修改</td>\n<td></td>\n</tr>\n<tr>\n<td>chmod</td>\n<td>修改拥有者和所属组的权限</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>加减法</td>\n<td>chmod    u/g/o+/-/=r/w/x 123：   将文件1213给用户/组/其他人加/减/赋予一个读/写/执行权限</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>数字法</td>\n<td>r=4    w=2  x=1 ： chmod  632 123 ：   将文件123给用户赋予r和w权限，给组赋予wx权限，给其他人赋予w权限</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>chown -R goulandis 123 ： 将123目录下的所有文件包括目录本身的拥有者修改为goulandis</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p><strong>默认权限：</strong></p>\n<p>umask      查看当前用户的umask权限       </p>\n<p>umask –(选项) ：临时修改默认权限</p>\n<p>/etc/bashrc ： 永久修改默认权限（通过修改脚本文件实现）</p>\n<p>umask的选项说明</p>\n<p>0022         拿走的权限</p>\n<p>​         第一个数字表示特殊权限</p>\n<p>​         022=rwxr-xr-x ：不拿走用户的权限、拿走用户组的w权限、拿走其他用户的w权限</p>\n<p>目录无法拿走x权限</p>\n<p>普通用户umask值 0002</p>\n<p>root用户umask值 0022</p>\n<h2 id=\"文件的特殊权限\"><a href=\"#文件的特殊权限\" class=\"headerlink\" title=\"文件的特殊权限:\"></a><strong>文件的特殊权限:</strong></h2><p><img src=\"/2019/08/25/%E3%80%90Linux%E3%80%91Linux%E5%9F%BA%E7%A1%80/7.png\" alt=\"img\"></p>\n<p>当s出现在拥有者的x权限的位置时，表示拥有者有SUID的权限（Set UID）</p>\n<p>当s出现在用户组的x权限的位置时，表示用户组有SGID的权限（Set GID）</p>\n<p>当s出现在其他人的x权限的位置时，表示其他人有SBIT的权限（Sticky Bit）</p>\n<table>\n<thead>\n<tr>\n<th>SUID</th>\n<th>临时获取文件拥有者的权限—–只能针对文件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SGID</td>\n<td>可以作用于目录，也可以作用于文件</td>\n</tr>\n<tr>\n<td>作用于文件 ： 和SUID作用一样</td>\n<td></td>\n</tr>\n<tr>\n<td>作用与目录 ： 继承父级目—–目录会不停的继承，下级目录会一直继承父级目录的权限值</td>\n<td></td>\n</tr>\n<tr>\n<td>SBIT</td>\n<td>只有文件的拥有者才能删除修改该目录下的文件—–只能针对目录</td>\n</tr>\n<tr>\n<td>S和T有大小写之分   大写 ： 没有x权限   小写 ： 有x权限</td>\n<td></td>\n</tr>\n<tr>\n<td>数字法 ：SUID=4、SGID=2、SBIT=1</td>\n<td></td>\n</tr>\n</tbody></table>\n<p><img src=\"/2019/08/25/%E3%80%90Linux%E3%80%91Linux%E5%9F%BA%E7%A1%80/8.png\" alt=\"img\"></p>\n<h1 id=\"l-Linux进程\"><a href=\"#l-Linux进程\" class=\"headerlink\" title=\"l  Linux进程\"></a>l  <strong>Linux进程</strong></h1><p>进程 ：已经启动的可执行程序的运行实例</p>\n<p>PID : 进程的ID（每一个进程都有唯一的PID）</p>\n<p>PPID ： 父进程的ID</p>\n<p>任何一个进程都可以创建紫进程</p>\n<table>\n<thead>\n<tr>\n<th>ｐｓ　：　查看当前的进程情况</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>选项</td>\n<td>作用</td>\n</tr>\n<tr>\n<td>－ａｕｘ／ａｕｘ</td>\n<td>列出所有进程</td>\n</tr>\n<tr>\n<td>－ｅｆ</td>\n<td>列出所有进程</td>\n</tr>\n<tr>\n<td>－ｌ</td>\n<td>列出和当前用户有关的进程</td>\n</tr>\n<tr>\n<td>－ｕ</td>\n<td>查看某一用户的进程</td>\n</tr>\n<tr>\n<td>－ｔｏｐ</td>\n<td>实时查看进程状况</td>\n</tr>\n</tbody></table>\n<p><img src=\"/2019/08/25/%E3%80%90Linux%E3%80%91Linux%E5%9F%BA%E7%A1%80/9.png\" alt=\"img\"></p>\n"},{"title":"【MyQSL】MyQSL存储过程","date":"2019-10-21T13:12:42.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 1.什么是存储过程\n\n数据库中的存储过程有点类似编程中的函数，可以供外部环境在需要时调用，并且存储过程只需要编译一次，之后再用则无需进行在此编译。\n\n# 2.存储过程的创建\n\n## 代码\n\n```mysql\ndelimiter //\ncreate procedure Test(in parameter01 int,out parameter02 varchar(45));\nbegin\n\t-- 存储逻辑\nend\n//\ndelimiter ;\n```\n\n## 解析\n\n- **delimiter //**:更改MySQL中语句分隔符`;`，目的就是为了将存储过程作为一个整体，使MySQL中的存储逻辑中的`;`在代码编辑阶段不被编译器识别，`//`标识在两个`//`中间的逻辑为存储逻辑，告知MySQL其中的`;`不需要解释；<font color=red> 但是要记住，在用完`//`这个之后要记得将分隔符转回`;`,否则之后的语句也会使用`//`作为分隔符</font>。其中`//`可以是任意字符或字符串。\n- **create procedure Test(in parameter01 int , out parameter02 vachar(45))**:创建一个存储过程Test，存储过程包含输入参数parameter01和输出参数parameter02，其中`in`标识输入参数，`out`标识输出参数，如果括号中不写标识in/out则默认为输入参数，其中输入参数只能用于从外界传入参数，输出参数只能用于返回结果，类似编程中的返回值。MySQL中也提供`inout`类型的参数，既可以作为输入参数使用也可以作为输出参数使用，但是不建议这么用，比较好的用法还是输入输出分开。\n- **begin end**:`begin end`用来标识一个语句块，必须承兑出现，可以用在任何地方，在存储过程中逻辑写在`begin end`块内。\n\n# 3.存储过程的使用\n\n```mysql\ncall Test(1,@out_parameter);\n```\n\n存储过程的使用就如同函数调用一般，传入输入参数，并使用使用变量来接收输出参数。`@out_parameter`就是用来接收输出参数的变量。\n\n# 4.存储逻辑\n\n在编写存储过程时逻辑判断语句是一定会用到的，下面列举一些常用的逻辑判断语句及其用法。\n\n## if语句\n\nMySQL中单独的if语句和程序编程中有所不同，单独的if语句一般嵌入其他语句中一起用，如：\n\n```mysql\nselect if(exc,'A','B');\n```\n\n当exc的值为true时，输出A，否则输出B，exc可以是一个变量也可以是是一个语句，同理A，B也可以是一个变量或是一个语句。\n\n## if esle语句\n\nif esle语句与esle则有极大的不同，if else语句更接近编程中if esle\n\n```mysql\nif exc1 then\n \t-- 执行逻辑1;\nelseif exc2 then\n\t-- 执行逻辑2;\nelse\n\t-- 执行逻辑3;\nend if;\n```\n\n每一个if/elseif之后都需要跟一个then才能写执行逻辑，需要注意的是，then和执行逻辑之间没有`;`分隔。if语句结束时需要使用 end if;来告知MySQLif判断语句结束。同单独的if语句一样，if else中的exc也可以是变量和语句。\n\n## 循环体\n\nMySQL的循环体使用游标来实现，具体的我们先看一个例子：\n\n```mysql\ndelimiter //\n-- 使用断面名删除断面的时间戳数据，此存储过程不允许删除断面\ncreate procedure DeleteSurfaceDataByName(\nin in_surface_name varchar(32),\nin in_time_point_start varchar(32),\nin in_time_point_end varchar(32),\nout run_state bool\n)\nbegin\n\t-- 判断断面是否合法\n    if exists (select surface_no from surface_number where surface_name = in_surface_name) then\n    begin\n\t\tdeclare num varchar(32) default null;\n\t\t-- 游标的结束标志\n\t\tdeclare done bool default false;\n        -- 为主键id创建游标\n\t\tdeclare cur cursor for select id from surface_data where surface_name = in_surface_name;\n        -- 将结束标志关联到游标\n        declare continue handler for not found set done = true;\n        -- 打开游标\n        open cur;\n        -- 创建循环过程\n        delete_loop:loop\n        -- 从游标结果集中取值到num\n        fetch next from cur into num;\n\t\t-- 游标后移\n        if done then\n\t\t\tleave delete_loop;\n\t\tend if;\n        -- 循环语句\n        begin\n\t\t\t-- 场景1-删除当前段面中某一时段的水文数据\n\t\t\tif in_time_point_start is not null and in_time_point_end is not null then\n\t\t\t\tdelete from surface_data where id = num and ascii(time_point) >= ascii(in_time_point_start) \n\t\t\t\t\tand ascii(time_point) <= ascii(in_time_point_end);\n\t\t\t-- 场景2-删除当前断面中某一时刻的水文数据\n\t\t\telseif in_time_point_start is not null and in_time_point_end is null then\n\t\t\t\tdelete from surface_data where id = num and time_point = in_time_point_start;\n\t\t\tend if;\n\t\tend;\n        -- 结束循环\n        end loop;\n        set run_state = true;\n\tend;\n\telse\n\t\tset run_state = false;\n\tend if;\nend\n//\ndelimiter ;\n```\n\n- **exists()**:和select搭配可以判断满足where条件的selete字段在from的表中是否存在\n- **declare cur cursor for**:和select语句搭配可以为select出来的结果集创建一个游标cur，而这个游标便是循环体的关键，游标就有点类似SLT中迭代器，可以逐一读取结果集中的数据。\n- **declare continue handler for not found set done = true**：光有游标还是无法实现循环体的，循环体还有一个很重要的标志--结束标志，这条语句便是为游标设置循环结束标志，这条语句和前面的`declare done bool default false;`搭配使用，done便是循环结束的标志，通过这条语句将游标和循环结束标志绑定起来。\n- **open cur**：上面仅仅是做好了使用循环体的前提，要想使用循环体还需要将游标打开，以便游标可以使用，open cur便是打开游标cur。\n- **delete_loop:loop**:这是真正的循环体的开始，开始一个循环题delete_loop,同时需要使用`end loop;`来标识循环题结束。\n- **fetch next from cur into num**:向游标cur指向的结果几种逐一读取数据到num变量中，这里要值意num变量和结果集中的数据类型要一至。\n- **if done then leave delete_loop end if;**：判断结束标志done，如果done等于true就继续执行循环体。\n- 在if done then leave delete_loop end if;和end loop之间的就是每次循环执行的语句了。\n\n至此整个循环语句结束。\n\n","source":"_posts/【MyQSL】MyQSL存储过程.md","raw":"---\ntitle: 【MyQSL】MyQSL存储过程\ndate: 2019-10-21 21:12:42\ntags: MySQL\ncategories: 知识记录\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 1.什么是存储过程\n\n数据库中的存储过程有点类似编程中的函数，可以供外部环境在需要时调用，并且存储过程只需要编译一次，之后再用则无需进行在此编译。\n\n# 2.存储过程的创建\n\n## 代码\n\n```mysql\ndelimiter //\ncreate procedure Test(in parameter01 int,out parameter02 varchar(45));\nbegin\n\t-- 存储逻辑\nend\n//\ndelimiter ;\n```\n\n## 解析\n\n- **delimiter //**:更改MySQL中语句分隔符`;`，目的就是为了将存储过程作为一个整体，使MySQL中的存储逻辑中的`;`在代码编辑阶段不被编译器识别，`//`标识在两个`//`中间的逻辑为存储逻辑，告知MySQL其中的`;`不需要解释；<font color=red> 但是要记住，在用完`//`这个之后要记得将分隔符转回`;`,否则之后的语句也会使用`//`作为分隔符</font>。其中`//`可以是任意字符或字符串。\n- **create procedure Test(in parameter01 int , out parameter02 vachar(45))**:创建一个存储过程Test，存储过程包含输入参数parameter01和输出参数parameter02，其中`in`标识输入参数，`out`标识输出参数，如果括号中不写标识in/out则默认为输入参数，其中输入参数只能用于从外界传入参数，输出参数只能用于返回结果，类似编程中的返回值。MySQL中也提供`inout`类型的参数，既可以作为输入参数使用也可以作为输出参数使用，但是不建议这么用，比较好的用法还是输入输出分开。\n- **begin end**:`begin end`用来标识一个语句块，必须承兑出现，可以用在任何地方，在存储过程中逻辑写在`begin end`块内。\n\n# 3.存储过程的使用\n\n```mysql\ncall Test(1,@out_parameter);\n```\n\n存储过程的使用就如同函数调用一般，传入输入参数，并使用使用变量来接收输出参数。`@out_parameter`就是用来接收输出参数的变量。\n\n# 4.存储逻辑\n\n在编写存储过程时逻辑判断语句是一定会用到的，下面列举一些常用的逻辑判断语句及其用法。\n\n## if语句\n\nMySQL中单独的if语句和程序编程中有所不同，单独的if语句一般嵌入其他语句中一起用，如：\n\n```mysql\nselect if(exc,'A','B');\n```\n\n当exc的值为true时，输出A，否则输出B，exc可以是一个变量也可以是是一个语句，同理A，B也可以是一个变量或是一个语句。\n\n## if esle语句\n\nif esle语句与esle则有极大的不同，if else语句更接近编程中if esle\n\n```mysql\nif exc1 then\n \t-- 执行逻辑1;\nelseif exc2 then\n\t-- 执行逻辑2;\nelse\n\t-- 执行逻辑3;\nend if;\n```\n\n每一个if/elseif之后都需要跟一个then才能写执行逻辑，需要注意的是，then和执行逻辑之间没有`;`分隔。if语句结束时需要使用 end if;来告知MySQLif判断语句结束。同单独的if语句一样，if else中的exc也可以是变量和语句。\n\n## 循环体\n\nMySQL的循环体使用游标来实现，具体的我们先看一个例子：\n\n```mysql\ndelimiter //\n-- 使用断面名删除断面的时间戳数据，此存储过程不允许删除断面\ncreate procedure DeleteSurfaceDataByName(\nin in_surface_name varchar(32),\nin in_time_point_start varchar(32),\nin in_time_point_end varchar(32),\nout run_state bool\n)\nbegin\n\t-- 判断断面是否合法\n    if exists (select surface_no from surface_number where surface_name = in_surface_name) then\n    begin\n\t\tdeclare num varchar(32) default null;\n\t\t-- 游标的结束标志\n\t\tdeclare done bool default false;\n        -- 为主键id创建游标\n\t\tdeclare cur cursor for select id from surface_data where surface_name = in_surface_name;\n        -- 将结束标志关联到游标\n        declare continue handler for not found set done = true;\n        -- 打开游标\n        open cur;\n        -- 创建循环过程\n        delete_loop:loop\n        -- 从游标结果集中取值到num\n        fetch next from cur into num;\n\t\t-- 游标后移\n        if done then\n\t\t\tleave delete_loop;\n\t\tend if;\n        -- 循环语句\n        begin\n\t\t\t-- 场景1-删除当前段面中某一时段的水文数据\n\t\t\tif in_time_point_start is not null and in_time_point_end is not null then\n\t\t\t\tdelete from surface_data where id = num and ascii(time_point) >= ascii(in_time_point_start) \n\t\t\t\t\tand ascii(time_point) <= ascii(in_time_point_end);\n\t\t\t-- 场景2-删除当前断面中某一时刻的水文数据\n\t\t\telseif in_time_point_start is not null and in_time_point_end is null then\n\t\t\t\tdelete from surface_data where id = num and time_point = in_time_point_start;\n\t\t\tend if;\n\t\tend;\n        -- 结束循环\n        end loop;\n        set run_state = true;\n\tend;\n\telse\n\t\tset run_state = false;\n\tend if;\nend\n//\ndelimiter ;\n```\n\n- **exists()**:和select搭配可以判断满足where条件的selete字段在from的表中是否存在\n- **declare cur cursor for**:和select语句搭配可以为select出来的结果集创建一个游标cur，而这个游标便是循环体的关键，游标就有点类似SLT中迭代器，可以逐一读取结果集中的数据。\n- **declare continue handler for not found set done = true**：光有游标还是无法实现循环体的，循环体还有一个很重要的标志--结束标志，这条语句便是为游标设置循环结束标志，这条语句和前面的`declare done bool default false;`搭配使用，done便是循环结束的标志，通过这条语句将游标和循环结束标志绑定起来。\n- **open cur**：上面仅仅是做好了使用循环体的前提，要想使用循环体还需要将游标打开，以便游标可以使用，open cur便是打开游标cur。\n- **delete_loop:loop**:这是真正的循环体的开始，开始一个循环题delete_loop,同时需要使用`end loop;`来标识循环题结束。\n- **fetch next from cur into num**:向游标cur指向的结果几种逐一读取数据到num变量中，这里要值意num变量和结果集中的数据类型要一至。\n- **if done then leave delete_loop end if;**：判断结束标志done，如果done等于true就继续执行循环体。\n- 在if done then leave delete_loop end if;和end loop之间的就是每次循环执行的语句了。\n\n至此整个循环语句结束。\n\n","slug":"【MyQSL】MyQSL存储过程","published":1,"updated":"2021-02-01T13:32:24.275Z","_id":"ckk9hocao000odwr7743od9tg","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h1 id=\"1-什么是存储过程\"><a href=\"#1-什么是存储过程\" class=\"headerlink\" title=\"1.什么是存储过程\"></a>1.什么是存储过程</h1><p>数据库中的存储过程有点类似编程中的函数，可以供外部环境在需要时调用，并且存储过程只需要编译一次，之后再用则无需进行在此编译。</p>\n<h1 id=\"2-存储过程的创建\"><a href=\"#2-存储过程的创建\" class=\"headerlink\" title=\"2.存储过程的创建\"></a>2.存储过程的创建</h1><h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">delimiter &#x2F;&#x2F;<br>create procedure Test(in parameter01 int,out parameter02 varchar(45));<br>begin<br>\t-- 存储逻辑<br>end<br>&#x2F;&#x2F;<br>delimiter ;<br></code></pre></td></tr></table></figure>\n<h2 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h2><ul>\n<li><strong>delimiter //</strong>:更改MySQL中语句分隔符<code>;</code>，目的就是为了将存储过程作为一个整体，使MySQL中的存储逻辑中的<code>;</code>在代码编辑阶段不被编译器识别，<code>//</code>标识在两个<code>//</code>中间的逻辑为存储逻辑，告知MySQL其中的<code>;</code>不需要解释；<font color=\"red\"> 但是要记住，在用完<code>//</code>这个之后要记得将分隔符转回<code>;</code>,否则之后的语句也会使用<code>//</code>作为分隔符</font>。其中<code>//</code>可以是任意字符或字符串。</li>\n<li><strong>create procedure Test(in parameter01 int , out parameter02 vachar(45))</strong>:创建一个存储过程Test，存储过程包含输入参数parameter01和输出参数parameter02，其中<code>in</code>标识输入参数，<code>out</code>标识输出参数，如果括号中不写标识in/out则默认为输入参数，其中输入参数只能用于从外界传入参数，输出参数只能用于返回结果，类似编程中的返回值。MySQL中也提供<code>inout</code>类型的参数，既可以作为输入参数使用也可以作为输出参数使用，但是不建议这么用，比较好的用法还是输入输出分开。</li>\n<li><strong>begin end</strong>:<code>begin end</code>用来标识一个语句块，必须承兑出现，可以用在任何地方，在存储过程中逻辑写在<code>begin end</code>块内。</li>\n</ul>\n<h1 id=\"3-存储过程的使用\"><a href=\"#3-存储过程的使用\" class=\"headerlink\" title=\"3.存储过程的使用\"></a>3.存储过程的使用</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">call Test(1,@out_parameter);<br></code></pre></td></tr></table></figure>\n<p>存储过程的使用就如同函数调用一般，传入输入参数，并使用使用变量来接收输出参数。<code>@out_parameter</code>就是用来接收输出参数的变量。</p>\n<h1 id=\"4-存储逻辑\"><a href=\"#4-存储逻辑\" class=\"headerlink\" title=\"4.存储逻辑\"></a>4.存储逻辑</h1><p>在编写存储过程时逻辑判断语句是一定会用到的，下面列举一些常用的逻辑判断语句及其用法。</p>\n<h2 id=\"if语句\"><a href=\"#if语句\" class=\"headerlink\" title=\"if语句\"></a>if语句</h2><p>MySQL中单独的if语句和程序编程中有所不同，单独的if语句一般嵌入其他语句中一起用，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select if(exc,&#39;A&#39;,&#39;B&#39;);<br></code></pre></td></tr></table></figure>\n<p>当exc的值为true时，输出A，否则输出B，exc可以是一个变量也可以是是一个语句，同理A，B也可以是一个变量或是一个语句。</p>\n<h2 id=\"if-esle语句\"><a href=\"#if-esle语句\" class=\"headerlink\" title=\"if esle语句\"></a>if esle语句</h2><p>if esle语句与esle则有极大的不同，if else语句更接近编程中if esle</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">if exc1 then<br> \t-- 执行逻辑1;<br>elseif exc2 then<br>\t-- 执行逻辑2;<br>else<br>\t-- 执行逻辑3;<br>end if;<br></code></pre></td></tr></table></figure>\n<p>每一个if/elseif之后都需要跟一个then才能写执行逻辑，需要注意的是，then和执行逻辑之间没有<code>;</code>分隔。if语句结束时需要使用 end if;来告知MySQLif判断语句结束。同单独的if语句一样，if else中的exc也可以是变量和语句。</p>\n<h2 id=\"循环体\"><a href=\"#循环体\" class=\"headerlink\" title=\"循环体\"></a>循环体</h2><p>MySQL的循环体使用游标来实现，具体的我们先看一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">delimiter &#x2F;&#x2F;<br>-- 使用断面名删除断面的时间戳数据，此存储过程不允许删除断面<br>create procedure DeleteSurfaceDataByName(<br>in in_surface_name varchar(32),<br>in in_time_point_start varchar(32),<br>in in_time_point_end varchar(32),<br>out run_state bool<br>)<br>begin<br>\t-- 判断断面是否合法<br>    if exists (select surface_no from surface_number where surface_name &#x3D; in_surface_name) then<br>    begin<br>\t\tdeclare num varchar(32) default null;<br>\t\t-- 游标的结束标志<br>\t\tdeclare done bool default false;<br>        -- 为主键id创建游标<br>\t\tdeclare cur cursor for select id from surface_data where surface_name &#x3D; in_surface_name;<br>        -- 将结束标志关联到游标<br>        declare continue handler for not found set done &#x3D; true;<br>        -- 打开游标<br>        open cur;<br>        -- 创建循环过程<br>        delete_loop:loop<br>        -- 从游标结果集中取值到num<br>        fetch next from cur into num;<br>\t\t-- 游标后移<br>        if done then<br>\t\t\tleave delete_loop;<br>\t\tend if;<br>        -- 循环语句<br>        begin<br>\t\t\t-- 场景1-删除当前段面中某一时段的水文数据<br>\t\t\tif in_time_point_start is not null and in_time_point_end is not null then<br>\t\t\t\tdelete from surface_data where id &#x3D; num and ascii(time_point) &gt;&#x3D; ascii(in_time_point_start) <br>\t\t\t\t\tand ascii(time_point) &lt;&#x3D; ascii(in_time_point_end);<br>\t\t\t-- 场景2-删除当前断面中某一时刻的水文数据<br>\t\t\telseif in_time_point_start is not null and in_time_point_end is null then<br>\t\t\t\tdelete from surface_data where id &#x3D; num and time_point &#x3D; in_time_point_start;<br>\t\t\tend if;<br>\t\tend;<br>        -- 结束循环<br>        end loop;<br>        set run_state &#x3D; true;<br>\tend;<br>\telse<br>\t\tset run_state &#x3D; false;<br>\tend if;<br>end<br>&#x2F;&#x2F;<br>delimiter ;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><strong>exists()</strong>:和select搭配可以判断满足where条件的selete字段在from的表中是否存在</li>\n<li><strong>declare cur cursor for</strong>:和select语句搭配可以为select出来的结果集创建一个游标cur，而这个游标便是循环体的关键，游标就有点类似SLT中迭代器，可以逐一读取结果集中的数据。</li>\n<li><strong>declare continue handler for not found set done = true</strong>：光有游标还是无法实现循环体的，循环体还有一个很重要的标志–结束标志，这条语句便是为游标设置循环结束标志，这条语句和前面的<code>declare done bool default false;</code>搭配使用，done便是循环结束的标志，通过这条语句将游标和循环结束标志绑定起来。</li>\n<li><strong>open cur</strong>：上面仅仅是做好了使用循环体的前提，要想使用循环体还需要将游标打开，以便游标可以使用，open cur便是打开游标cur。</li>\n<li><strong>delete_loop:loop</strong>:这是真正的循环体的开始，开始一个循环题delete_loop,同时需要使用<code>end loop;</code>来标识循环题结束。</li>\n<li><strong>fetch next from cur into num</strong>:向游标cur指向的结果几种逐一读取数据到num变量中，这里要值意num变量和结果集中的数据类型要一至。</li>\n<li>**if done then leave delete_loop end if;**：判断结束标志done，如果done等于true就继续执行循环体。</li>\n<li>在if done then leave delete_loop end if;和end loop之间的就是每次循环执行的语句了。</li>\n</ul>\n<p>至此整个循环语句结束。</p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h1 id=\"1-什么是存储过程\"><a href=\"#1-什么是存储过程\" class=\"headerlink\" title=\"1.什么是存储过程\"></a>1.什么是存储过程</h1><p>数据库中的存储过程有点类似编程中的函数，可以供外部环境在需要时调用，并且存储过程只需要编译一次，之后再用则无需进行在此编译。</p>\n<h1 id=\"2-存储过程的创建\"><a href=\"#2-存储过程的创建\" class=\"headerlink\" title=\"2.存储过程的创建\"></a>2.存储过程的创建</h1><h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">delimiter &#x2F;&#x2F;<br>create procedure Test(in parameter01 int,out parameter02 varchar(45));<br>begin<br>\t-- 存储逻辑<br>end<br>&#x2F;&#x2F;<br>delimiter ;<br></code></pre></td></tr></table></figure>\n<h2 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h2><ul>\n<li><strong>delimiter //</strong>:更改MySQL中语句分隔符<code>;</code>，目的就是为了将存储过程作为一个整体，使MySQL中的存储逻辑中的<code>;</code>在代码编辑阶段不被编译器识别，<code>//</code>标识在两个<code>//</code>中间的逻辑为存储逻辑，告知MySQL其中的<code>;</code>不需要解释；<font color=\"red\"> 但是要记住，在用完<code>//</code>这个之后要记得将分隔符转回<code>;</code>,否则之后的语句也会使用<code>//</code>作为分隔符</font>。其中<code>//</code>可以是任意字符或字符串。</li>\n<li><strong>create procedure Test(in parameter01 int , out parameter02 vachar(45))</strong>:创建一个存储过程Test，存储过程包含输入参数parameter01和输出参数parameter02，其中<code>in</code>标识输入参数，<code>out</code>标识输出参数，如果括号中不写标识in/out则默认为输入参数，其中输入参数只能用于从外界传入参数，输出参数只能用于返回结果，类似编程中的返回值。MySQL中也提供<code>inout</code>类型的参数，既可以作为输入参数使用也可以作为输出参数使用，但是不建议这么用，比较好的用法还是输入输出分开。</li>\n<li><strong>begin end</strong>:<code>begin end</code>用来标识一个语句块，必须承兑出现，可以用在任何地方，在存储过程中逻辑写在<code>begin end</code>块内。</li>\n</ul>\n<h1 id=\"3-存储过程的使用\"><a href=\"#3-存储过程的使用\" class=\"headerlink\" title=\"3.存储过程的使用\"></a>3.存储过程的使用</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">call Test(1,@out_parameter);<br></code></pre></td></tr></table></figure>\n<p>存储过程的使用就如同函数调用一般，传入输入参数，并使用使用变量来接收输出参数。<code>@out_parameter</code>就是用来接收输出参数的变量。</p>\n<h1 id=\"4-存储逻辑\"><a href=\"#4-存储逻辑\" class=\"headerlink\" title=\"4.存储逻辑\"></a>4.存储逻辑</h1><p>在编写存储过程时逻辑判断语句是一定会用到的，下面列举一些常用的逻辑判断语句及其用法。</p>\n<h2 id=\"if语句\"><a href=\"#if语句\" class=\"headerlink\" title=\"if语句\"></a>if语句</h2><p>MySQL中单独的if语句和程序编程中有所不同，单独的if语句一般嵌入其他语句中一起用，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select if(exc,&#39;A&#39;,&#39;B&#39;);<br></code></pre></td></tr></table></figure>\n<p>当exc的值为true时，输出A，否则输出B，exc可以是一个变量也可以是是一个语句，同理A，B也可以是一个变量或是一个语句。</p>\n<h2 id=\"if-esle语句\"><a href=\"#if-esle语句\" class=\"headerlink\" title=\"if esle语句\"></a>if esle语句</h2><p>if esle语句与esle则有极大的不同，if else语句更接近编程中if esle</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">if exc1 then<br> \t-- 执行逻辑1;<br>elseif exc2 then<br>\t-- 执行逻辑2;<br>else<br>\t-- 执行逻辑3;<br>end if;<br></code></pre></td></tr></table></figure>\n<p>每一个if/elseif之后都需要跟一个then才能写执行逻辑，需要注意的是，then和执行逻辑之间没有<code>;</code>分隔。if语句结束时需要使用 end if;来告知MySQLif判断语句结束。同单独的if语句一样，if else中的exc也可以是变量和语句。</p>\n<h2 id=\"循环体\"><a href=\"#循环体\" class=\"headerlink\" title=\"循环体\"></a>循环体</h2><p>MySQL的循环体使用游标来实现，具体的我们先看一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">delimiter &#x2F;&#x2F;<br>-- 使用断面名删除断面的时间戳数据，此存储过程不允许删除断面<br>create procedure DeleteSurfaceDataByName(<br>in in_surface_name varchar(32),<br>in in_time_point_start varchar(32),<br>in in_time_point_end varchar(32),<br>out run_state bool<br>)<br>begin<br>\t-- 判断断面是否合法<br>    if exists (select surface_no from surface_number where surface_name &#x3D; in_surface_name) then<br>    begin<br>\t\tdeclare num varchar(32) default null;<br>\t\t-- 游标的结束标志<br>\t\tdeclare done bool default false;<br>        -- 为主键id创建游标<br>\t\tdeclare cur cursor for select id from surface_data where surface_name &#x3D; in_surface_name;<br>        -- 将结束标志关联到游标<br>        declare continue handler for not found set done &#x3D; true;<br>        -- 打开游标<br>        open cur;<br>        -- 创建循环过程<br>        delete_loop:loop<br>        -- 从游标结果集中取值到num<br>        fetch next from cur into num;<br>\t\t-- 游标后移<br>        if done then<br>\t\t\tleave delete_loop;<br>\t\tend if;<br>        -- 循环语句<br>        begin<br>\t\t\t-- 场景1-删除当前段面中某一时段的水文数据<br>\t\t\tif in_time_point_start is not null and in_time_point_end is not null then<br>\t\t\t\tdelete from surface_data where id &#x3D; num and ascii(time_point) &gt;&#x3D; ascii(in_time_point_start) <br>\t\t\t\t\tand ascii(time_point) &lt;&#x3D; ascii(in_time_point_end);<br>\t\t\t-- 场景2-删除当前断面中某一时刻的水文数据<br>\t\t\telseif in_time_point_start is not null and in_time_point_end is null then<br>\t\t\t\tdelete from surface_data where id &#x3D; num and time_point &#x3D; in_time_point_start;<br>\t\t\tend if;<br>\t\tend;<br>        -- 结束循环<br>        end loop;<br>        set run_state &#x3D; true;<br>\tend;<br>\telse<br>\t\tset run_state &#x3D; false;<br>\tend if;<br>end<br>&#x2F;&#x2F;<br>delimiter ;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><strong>exists()</strong>:和select搭配可以判断满足where条件的selete字段在from的表中是否存在</li>\n<li><strong>declare cur cursor for</strong>:和select语句搭配可以为select出来的结果集创建一个游标cur，而这个游标便是循环体的关键，游标就有点类似SLT中迭代器，可以逐一读取结果集中的数据。</li>\n<li><strong>declare continue handler for not found set done = true</strong>：光有游标还是无法实现循环体的，循环体还有一个很重要的标志–结束标志，这条语句便是为游标设置循环结束标志，这条语句和前面的<code>declare done bool default false;</code>搭配使用，done便是循环结束的标志，通过这条语句将游标和循环结束标志绑定起来。</li>\n<li><strong>open cur</strong>：上面仅仅是做好了使用循环体的前提，要想使用循环体还需要将游标打开，以便游标可以使用，open cur便是打开游标cur。</li>\n<li><strong>delete_loop:loop</strong>:这是真正的循环体的开始，开始一个循环题delete_loop,同时需要使用<code>end loop;</code>来标识循环题结束。</li>\n<li><strong>fetch next from cur into num</strong>:向游标cur指向的结果几种逐一读取数据到num变量中，这里要值意num变量和结果集中的数据类型要一至。</li>\n<li>**if done then leave delete_loop end if;**：判断结束标志done，如果done等于true就继续执行循环体。</li>\n<li>在if done then leave delete_loop end if;和end loop之间的就是每次循环执行的语句了。</li>\n</ul>\n<p>至此整个循环语句结束。</p>\n"},{"title":"【Lua】Lua基础","date":"2019-09-09T08:26:18.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2019090916141255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190909161442706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n参考博文：https://www.cnblogs.com/cjswwdz/p/5634442.html\n\nXMind源文件：https://github.com/Goulandis/XMinds-2019.8.27/tree/master/Lua\n\n学习地址：https://www.bilibili.com/video/av50685253?from=search&seid=12754355294240767428","source":"_posts/【Lua】Lua基础.md","raw":"---\ntitle: 【Lua】Lua基础\ndate: 2019-09-09 16:26:18\ntags: Lua\ncategories: 学习笔记\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2019090916141255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190909161442706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n参考博文：https://www.cnblogs.com/cjswwdz/p/5634442.html\n\nXMind源文件：https://github.com/Goulandis/XMinds-2019.8.27/tree/master/Lua\n\n学习地址：https://www.bilibili.com/video/av50685253?from=search&seid=12754355294240767428","slug":"【Lua】Lua基础","published":1,"updated":"2021-02-01T13:32:17.325Z","_id":"ckk9hocaq000sdwr7hpbtfm78","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p><img src=\"https://img-blog.csdnimg.cn/2019090916141255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/20190909161442706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>参考博文：<a href=\"https://www.cnblogs.com/cjswwdz/p/5634442.html\">https://www.cnblogs.com/cjswwdz/p/5634442.html</a></p>\n<p>XMind源文件：<a href=\"https://github.com/Goulandis/XMinds-2019.8.27/tree/master/Lua\">https://github.com/Goulandis/XMinds-2019.8.27/tree/master/Lua</a></p>\n<p>学习地址：<a href=\"https://www.bilibili.com/video/av50685253?from=search&amp;seid=12754355294240767428\">https://www.bilibili.com/video/av50685253?from=search&amp;seid=12754355294240767428</a></p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p><img src=\"https://img-blog.csdnimg.cn/2019090916141255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/20190909161442706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>参考博文：<a href=\"https://www.cnblogs.com/cjswwdz/p/5634442.html\">https://www.cnblogs.com/cjswwdz/p/5634442.html</a></p>\n<p>XMind源文件：<a href=\"https://github.com/Goulandis/XMinds-2019.8.27/tree/master/Lua\">https://github.com/Goulandis/XMinds-2019.8.27/tree/master/Lua</a></p>\n<p>学习地址：<a href=\"https://www.bilibili.com/video/av50685253?from=search&amp;seid=12754355294240767428\">https://www.bilibili.com/video/av50685253?from=search&amp;seid=12754355294240767428</a></p>\n"},{"title":"Qt基础","date":"2019-08-25T10:51:19.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n﻿![在这里插入图片描述](https://img-blog.csdnimg.cn/20190825185005696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n","source":"_posts/【Qt】Qt基础.md","raw":"---\ntitle: Qt基础\ndate: 2019-08-25 18:51:19\ntags: Qt\ncategories: 学习笔记\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n﻿![在这里插入图片描述](https://img-blog.csdnimg.cn/20190825185005696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n","slug":"【Qt】Qt基础","published":1,"updated":"2021-02-01T13:32:31.721Z","_id":"ckk9hocaq000vdwr77ko3d286","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p>﻿<img src=\"https://img-blog.csdnimg.cn/20190825185005696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p>﻿<img src=\"https://img-blog.csdnimg.cn/20190825185005696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n"},{"title":"【UE4】UE4组件","date":"2019-11-06T13:10:52.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n不同的蓝图脚本拥有不同的组件集，蓝图脚本的组件集过于庞大，这里只对自己使用过的组件进行列举。\n\n<font color=red>说明：红色字体表示一级目录组件，绿色字体表示二级目录，黄色字体为三级目录(三级目录较为少见所以使用和二级目录相同的三级标题)，白色字体为具体组件说明</font>。\n\n# 一、材质蓝图组件\n\n## <font color=red>Constans(常量)</font>\n\n![](【UE4】UE4组件/Snipaste_2019-10-25_11-46-47.png)\n\n| 组件            | 作用                                              |\n| --------------- | ------------------------------------------------- |\n| Constans        | 一维量，可以表示任何一维数据，如：小数、整数等    |\n| Constans2Vector | 二维量，可以表示任何二维数据，如：二维坐标        |\n| Constans3Vector | 三维量，可以表示任何三维数据，如：三维坐标、RBG等 |\n| Constans4Vector | 四维量，可以表示任何四维数据，如：四元数          |\n\n## <font color=red>Math(数学函数)</font>\n\n#### **Multiply(乘积)**\n\n![](【UE4】UE4组件/Snipaste_2019-10-25_11-50-37.png)\n\n\n\n### <font color=green>Lerp(插值)</font>\n\n![](【UE4】UE4组件/Snipaste_2019-10-25_13-12-40.png)\n\nLerp组件在Math的多个二级目录中存在，有各种类型的插值变化。\n\n**输入：**\n\n- A：插值变化的起始值；\n- B：插值变化的目标值；\n- Alpha：插值的变化规则，连接Float的TimeLine插值将按照TimeLine的规则变化。\n\n**输出：**\n\n- Return Value：返回变化后的插值，将Lerp放入帧函数中可以获得每帧变化的插值。\n\n# 二、普通蓝图组件\n\n------\n\n## <font color=red>Add TimeLine(添加时间线)</font>\n\n\n\n![](【UE4】UE4组件/Snipaste_2019-10-25_10-33-38.png)\n\n**输入：**\n\n- Play：播放，播放完毕下一次触发时不会从头开始，而是会从上一次时间点继续开始；\n- Play from Start：从头开始播放，每次触发都从时间线起点开始执行；\n- Stop：暂停，触发后直接从当前时刻暂停；\n- Reverse：倒序播放，从当前时刻开始倒叙播放；\n- Reverse from End：从末尾开始倒序播放；\n- Set New Time：设置新的时间起点，即时间线从新设置的时间点开始执行；\n- New Time：新的时间起点由外部输入。\n\n**输出：**\n\n- Update：在时间线内每帧执行；\n- Finished：时间线结束时触发；\n- Direction：返回时间线的执行方向，只有两个值“Forward”和“Backward”；\n- New Track 0：自己创建的时间线，创建了才会有，显示的名字也是自己命名的时间线的名字。\n\n## <font color=red>Add Event(添加事件)</font>\n\n### <font color=green>Collision(碰撞体组件)</font>\n\n#### **Event ActorBeginOverlap(自动触发触发器)**\n\n每当有物体进入触发器时自动触发\n\n![](【UE4】UE4组件/Snipaste_2019-10-25_10-53-07.png)\n\n- Other Actor：返回进入触发器的游戏物体的信息。\n\n### <font color=green>Game</font>\n\n### <font color=orange>Damage</font>\n\n#### **Event AnyDamage**\n\nEvent AnyDamage事件是配合Apply Damage组件一起使用的，当Apply Damage组件执行时，会自动触发Event AnyDamage事件。\n\n![](【UE4】UE4组件/Snipaste_2019-10-28_17-28-37.png)\n\n**输出：**\n\n- Damage：从Apply Damage组件的Damage中传递过来的值；\n\n- Damage Type：从Apply Damage组件传递过来的Damage Type Class；\n\n- Instigated By：从Apply Damage组件传递过来的Event Instigateor；\n\n- Damage Causer：从Apply Damage组件传递过来的Damage Causer；\n\n\n## <font color=red>Camera Fades(相机渐变)</font>\n\nCamera Fades组件是只有在Get Player Camera Menager组件的外拉中才能搜索到的专门服务于Get Player Camera Menager组件的相机组件集。\n\n#### **Start Camera Fade(开始渐变)**\n\n![](【UE4】UE4组件/Snipaste_2019-10-25_11-02-10.png)\n\n- Target：渐变目标相机，默认为当前相机；\n- From Alpha：渐变起始Alpha；\n- To Alpha：渐变目标Alpha；\n- Duration：渐变持续时间；\n- Color：渐变颜色；\n- Should Fade Audio：启用声音渐变；\n- Hold when Finished：渐变结束后保持当前Alpha值。\n\n#### **Stop Camera Fade(结束渐变)**\n\n![](【UE4】UE4组件/Snipaste_2019-10-25_11-10-28.png)\n\n触发时立刻停止当前渐变。\n\n## <font color=red>Event BeginPlay</font>\n\n游戏开始时自动触发\n\n![](【UE4】UE4组件/Snipaste_2019-10-25_10-57-11.png)\n\n\n\n## <font color=red>Execute Console Command(执行控制台命令)</font>\n\n![](https://img-blog.csdnimg.cn/20210510102517406.png#pic_center)\n\n\n\n- Command：控制台命令字符串\n- Specific Player：执行控制台命令的执行器，默认为当前GameMode指定的Player\n\n### <font color=green>常见控制台命令</font>\n\n- start fps：显示帧率\n\n- start unit：显示性能调试信息\n\n- start rhi：显示GPU上的消耗细则\n\n  [更多start命令](https://docs.unrealengine.com/zh-CN/TestingAndOptimization/PerformanceAndProfiling/StatCommands/index.html)\n\n- r.MobileContentScaleFactor 0：控制内容在移动设备中的缩放方式，0表示使用设备原始分辨率，如将DPI缩放曲线用于UI缩放，必须设为0\n- DisableAllScreenMessages：禁用所有在运行中的屏幕提示\n\n## <font color=red>Input(输入流)</font>\n\n### <font color=green>Keyboard Events(按键触发事件)</font>\n\n包含所有键盘按键出发事件\n\n## <font color=red>Game</font>\n\n#### **Get Player Pawn(获取角色对象)**\n\n![](【UE4】UE4组件/Snipaste_2019-10-25_11-17-59.png)\n\n- Play Index：输入角色索引，可以直接设置也可以外部输入；\n\n- Return Value：返回获取的角色对象(Object)。\n\n#### **Get Current Level Name(获取关卡名字)**\n\n![](【UE4】UE4组件/Snipaste_2019-10-25_11-21-18.png)\n\n- Remove Prefix String：移除前缀字符串；\n- Return Value：返回获取到的关卡名称(String)。\n\n#### **Get Player Camera Manager(获取角色相机管理器)**\n\n![](【UE4】UE4组件/Snipaste_2019-10-25_11-26-07.png)\n\n- Player Index：输入角色索引；\n- Return Value：返回输入角色身上的相机对象。\n\n### <font color=green>Damage</font>\n\n#### **Apply Damage**\n\nApply Damage组件一般和Event AnyDamage组件配合使用，当Apply Damage组件触发时，UE4会自动调用Event AnyDamage事件。需要注意的是，只有在Base Daamge不为0时才能触发Event Damage事件。\n\n![](【UE4】UE4组件/Snipaste_2019-10-28_17-26-35.png)\n\n**输入：**\n\n- Ddamaged Actor：受到伤害的对象；\n\n- Base Damage：输入的伤害值；\n\n- Event Instigator：引发伤害的对象，如：持枪的敌人；\n\n- Damage Causer：实际造成伤害的对象，如：子弹；\n\n- Damage Type Class：伤害的类型；\n\n\n**输出：**\n\nReturn Value：最终造成的实际伤害。\n\n### <font color=green>Player Controller(角色控制器组件)</font>\n\n### Set View Target With Blend(相机线性移动)\n\n![](https://img-blog.csdnimg.cn/20210508105054190.png#pic_center)\n\n- Target：目标是PlayerController\n- New View Target：相机需要移动到的目的点\n- Blend Time：相机聚焦过程所需时间\n- Blend Func：聚焦方式\n- Blend Exp：控制曲线形状的指数，（实测中好像也没什么效果）\n- Lock Outgoing：为true时锁定视角移动，false则相机会转向\n\n## <font color=red>Rendering(渲染)</font>\n\n### <font color=green>Components</font>\n\n### <font color= orange> Light</font>\n\n#### **Set Intensity(设置光源强度)**\n\n![](【UE4】UE4组件/Snipaste_2019-10-25_13-32-38.png)\n\n- Target：目标光源；\n- New Intensity：目标光源强度。\n\n#### **Get Intensity(获取光源强度)**\n\n使用和Set Intensity一样。\n\n## <font color=red>String(字符串组件)</font>\n\n### <font color=green>Append(字符串连接)</font>\n\n![](【UE4】UE4组件/Snipaste_2019-10-28_17-04-19.png)\n\n### <font color=green>Switch On String(字符串匹配)</font>\n\n![](https://img-blog.csdnimg.cn/20210508103637363.png#pic_center)\n\n- Selection：输入字符串\n- Default：默认输出端口\n- Add pin：添加匹配端口\n\n## <font color=red>Utilities(通用组件)</font>\n\n### <font color=green>Flow Control</font>\n\n#### Branch(if语句)\n\n![](【UE4】UE4组件/Snipaste_2019-10-25_11-30-52.png)\n\n蓝图的if语句\n\n- Condition：输入的判断条件，一般和各种判断组件的输出连接。\n\n#### Delay(延迟函数)\n\n![](【UE4】UE4组件/Snipaste_2019-10-25_11-39-53.png)\n\n- Duration：延迟时间。\n\n### <font color=green>Keyboard Events(按键触发事件)</font>\n\n包含一些字符串操作函数。\n\n### <font color=green>Text</font>\n\n#### Equal\n\n![](【UE4】UE4组件/Snipaste_2019-10-25_11-42-14.png)\n\n输入两个比较对象，输出判断结果(Bool)。\n\n各种其他的判断组件用法一致。\n\n### <font color=green> Transformation</font>\n\n#### Set Actor Scale 3D\n\n![](【UE4】UE4组件/Snipaste_2019-10-25_13-19-47.png)\n\n设置Actor的Scale值\n\n- Target：要设置的目标Actor；\n- New Scale 3D：要设置的目标Scale值。\n\n#### Get Actor Scale 3D\n\n获取Actor的Scale值。\n\n#### Set Timer By Function Name\n\n节点：\n\n![](https://img-blog.csdnimg.cn/2021051114494414.png#pic_center)\n\n描述：通过函数名定时调用函数\n\n输入：\n\n- Object：调用函数所在蓝图，默认为节点所在蓝图\n- Function Name：要调用的函数的名字\n- Time：定时调用时间间隔\n- Looping：是否循环调用\n\n输出：\n\n- 一个Timer Handle结构体，记录了一些函数调用的信息\n\n**关联节点：**\n\n#### Pause Timer By Function Name\n\n节点：\n\n![](https://img-blog.csdnimg.cn/2021051114572299.png#pic_center)\n\n描述：暂停有Set Timer By Function Name节点启用的函数定时调用过程\n\n输入：与Set Timer By Function Name类似\n\n#### Unpause Timer By Function Name\n\n节点：\n\n![](https://img-blog.csdnimg.cn/20210511150004900.png#pic_center)\n\n描述：取消Pause Timer By Function Name的效果，继续Set Timer By Function Name的函数定时调用\n\n#### Clear Timer By Function Name\n\n节点：\n\n![](https://img-blog.csdnimg.cn/20210511151905631.png#pic_center)\n\n描述：清除Set Timer By Function Name的定时调用设置\n\n#### Set Timer By Event\n\n节点：\n\n![](https://img-blog.csdnimg.cn/20210511150319524.png#pic_center)\n\n描述：设置定时调用事件，与Set Timer By Function Name不同Set Timer By Evnet没有对应的Pause和Unpause节点，且Set Timer By Event只能调用所在蓝图的事件\n\n输入：\n\n- Evnet：绑定需要调用的蓝图事件\n- Time：定时调用的时间间隔\n- Looping：是否循环调用\n\n#### Puase Timer By Handle\n\n节点：\n\n![](https://img-blog.csdnimg.cn/20210511150856500.png#pic_center)\n\n描述：通过Set Timer By Function Name和Set Timer By Evnet的Timer Handle返回值来控制调用流程，暂停函数调用\n\n输入：\n\n- Handle：Timer Handle结构体，输入Set Timer By Function Name和Set Timer By Evnet的返回值\n\n#### Upause Timer By Handle\n\n节点：\n\n![](https://img-blog.csdnimg.cn/20210511150910775.png#pic_center)\n\n描述：清除Pause Timer By Handle的暂定效果继续Set Timer By Function或Set Timer By Event的定时效果\n\n#### Clear And Invalidate Timer By Handle\n\n节点：\n\n![](https://img-blog.csdnimg.cn/20210511150903510.png#pic_center)\n\n描述：通过Timer Handle值清除Set Timer By Function Name和Set Timer By Event的定时调用设置\n\n# 三、物理组件\n\nUE4除了提供大量蓝图脚本函数组件来对蓝图类进行精细控制外还提供了一系列物理组件对蓝图类进行一些常规的复杂控制。\n\n## <font color=red>Camera</font>\n\n#### **Camera**\n\n![](【UE4】UE4组件/Snipaste_2019-10-25_11-53-42.png)\n\n相机，用于渲染视野，一般配合Spring Arm一起使用。\n\n#### **Spring Arm**\n\n![](【UE4】UE4组件/Snipaste_2019-10-25_11-56-15.png)\n\n弹簧悬臂，将相机附于其上可以实现相机跟随\n\n## <font color=red>Movement</font>\n\n#### **Rotating Movement**\n\n旋转控制，提供一系列参数对对蓝图类的旋转运动进行控制\n\n## <font color=red>Rendering</font>\n\n#### **Static Mesh**\n\n静态网格，网格控制蓝图的贴图材质、模型外观、阴影渲染等。","source":"_posts/【UE4】UE4组件.md","raw":"---\ntitle: 【UE4】UE4组件\ndate: 2019-11-06 21:10:52\ntags: UE4\ncategories: 学习笔记\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n不同的蓝图脚本拥有不同的组件集，蓝图脚本的组件集过于庞大，这里只对自己使用过的组件进行列举。\n\n<font color=red>说明：红色字体表示一级目录组件，绿色字体表示二级目录，黄色字体为三级目录(三级目录较为少见所以使用和二级目录相同的三级标题)，白色字体为具体组件说明</font>。\n\n# 一、材质蓝图组件\n\n## <font color=red>Constans(常量)</font>\n\n![](【UE4】UE4组件/Snipaste_2019-10-25_11-46-47.png)\n\n| 组件            | 作用                                              |\n| --------------- | ------------------------------------------------- |\n| Constans        | 一维量，可以表示任何一维数据，如：小数、整数等    |\n| Constans2Vector | 二维量，可以表示任何二维数据，如：二维坐标        |\n| Constans3Vector | 三维量，可以表示任何三维数据，如：三维坐标、RBG等 |\n| Constans4Vector | 四维量，可以表示任何四维数据，如：四元数          |\n\n## <font color=red>Math(数学函数)</font>\n\n#### **Multiply(乘积)**\n\n![](【UE4】UE4组件/Snipaste_2019-10-25_11-50-37.png)\n\n\n\n### <font color=green>Lerp(插值)</font>\n\n![](【UE4】UE4组件/Snipaste_2019-10-25_13-12-40.png)\n\nLerp组件在Math的多个二级目录中存在，有各种类型的插值变化。\n\n**输入：**\n\n- A：插值变化的起始值；\n- B：插值变化的目标值；\n- Alpha：插值的变化规则，连接Float的TimeLine插值将按照TimeLine的规则变化。\n\n**输出：**\n\n- Return Value：返回变化后的插值，将Lerp放入帧函数中可以获得每帧变化的插值。\n\n# 二、普通蓝图组件\n\n------\n\n## <font color=red>Add TimeLine(添加时间线)</font>\n\n\n\n![](【UE4】UE4组件/Snipaste_2019-10-25_10-33-38.png)\n\n**输入：**\n\n- Play：播放，播放完毕下一次触发时不会从头开始，而是会从上一次时间点继续开始；\n- Play from Start：从头开始播放，每次触发都从时间线起点开始执行；\n- Stop：暂停，触发后直接从当前时刻暂停；\n- Reverse：倒序播放，从当前时刻开始倒叙播放；\n- Reverse from End：从末尾开始倒序播放；\n- Set New Time：设置新的时间起点，即时间线从新设置的时间点开始执行；\n- New Time：新的时间起点由外部输入。\n\n**输出：**\n\n- Update：在时间线内每帧执行；\n- Finished：时间线结束时触发；\n- Direction：返回时间线的执行方向，只有两个值“Forward”和“Backward”；\n- New Track 0：自己创建的时间线，创建了才会有，显示的名字也是自己命名的时间线的名字。\n\n## <font color=red>Add Event(添加事件)</font>\n\n### <font color=green>Collision(碰撞体组件)</font>\n\n#### **Event ActorBeginOverlap(自动触发触发器)**\n\n每当有物体进入触发器时自动触发\n\n![](【UE4】UE4组件/Snipaste_2019-10-25_10-53-07.png)\n\n- Other Actor：返回进入触发器的游戏物体的信息。\n\n### <font color=green>Game</font>\n\n### <font color=orange>Damage</font>\n\n#### **Event AnyDamage**\n\nEvent AnyDamage事件是配合Apply Damage组件一起使用的，当Apply Damage组件执行时，会自动触发Event AnyDamage事件。\n\n![](【UE4】UE4组件/Snipaste_2019-10-28_17-28-37.png)\n\n**输出：**\n\n- Damage：从Apply Damage组件的Damage中传递过来的值；\n\n- Damage Type：从Apply Damage组件传递过来的Damage Type Class；\n\n- Instigated By：从Apply Damage组件传递过来的Event Instigateor；\n\n- Damage Causer：从Apply Damage组件传递过来的Damage Causer；\n\n\n## <font color=red>Camera Fades(相机渐变)</font>\n\nCamera Fades组件是只有在Get Player Camera Menager组件的外拉中才能搜索到的专门服务于Get Player Camera Menager组件的相机组件集。\n\n#### **Start Camera Fade(开始渐变)**\n\n![](【UE4】UE4组件/Snipaste_2019-10-25_11-02-10.png)\n\n- Target：渐变目标相机，默认为当前相机；\n- From Alpha：渐变起始Alpha；\n- To Alpha：渐变目标Alpha；\n- Duration：渐变持续时间；\n- Color：渐变颜色；\n- Should Fade Audio：启用声音渐变；\n- Hold when Finished：渐变结束后保持当前Alpha值。\n\n#### **Stop Camera Fade(结束渐变)**\n\n![](【UE4】UE4组件/Snipaste_2019-10-25_11-10-28.png)\n\n触发时立刻停止当前渐变。\n\n## <font color=red>Event BeginPlay</font>\n\n游戏开始时自动触发\n\n![](【UE4】UE4组件/Snipaste_2019-10-25_10-57-11.png)\n\n\n\n## <font color=red>Execute Console Command(执行控制台命令)</font>\n\n![](https://img-blog.csdnimg.cn/20210510102517406.png#pic_center)\n\n\n\n- Command：控制台命令字符串\n- Specific Player：执行控制台命令的执行器，默认为当前GameMode指定的Player\n\n### <font color=green>常见控制台命令</font>\n\n- start fps：显示帧率\n\n- start unit：显示性能调试信息\n\n- start rhi：显示GPU上的消耗细则\n\n  [更多start命令](https://docs.unrealengine.com/zh-CN/TestingAndOptimization/PerformanceAndProfiling/StatCommands/index.html)\n\n- r.MobileContentScaleFactor 0：控制内容在移动设备中的缩放方式，0表示使用设备原始分辨率，如将DPI缩放曲线用于UI缩放，必须设为0\n- DisableAllScreenMessages：禁用所有在运行中的屏幕提示\n\n## <font color=red>Input(输入流)</font>\n\n### <font color=green>Keyboard Events(按键触发事件)</font>\n\n包含所有键盘按键出发事件\n\n## <font color=red>Game</font>\n\n#### **Get Player Pawn(获取角色对象)**\n\n![](【UE4】UE4组件/Snipaste_2019-10-25_11-17-59.png)\n\n- Play Index：输入角色索引，可以直接设置也可以外部输入；\n\n- Return Value：返回获取的角色对象(Object)。\n\n#### **Get Current Level Name(获取关卡名字)**\n\n![](【UE4】UE4组件/Snipaste_2019-10-25_11-21-18.png)\n\n- Remove Prefix String：移除前缀字符串；\n- Return Value：返回获取到的关卡名称(String)。\n\n#### **Get Player Camera Manager(获取角色相机管理器)**\n\n![](【UE4】UE4组件/Snipaste_2019-10-25_11-26-07.png)\n\n- Player Index：输入角色索引；\n- Return Value：返回输入角色身上的相机对象。\n\n### <font color=green>Damage</font>\n\n#### **Apply Damage**\n\nApply Damage组件一般和Event AnyDamage组件配合使用，当Apply Damage组件触发时，UE4会自动调用Event AnyDamage事件。需要注意的是，只有在Base Daamge不为0时才能触发Event Damage事件。\n\n![](【UE4】UE4组件/Snipaste_2019-10-28_17-26-35.png)\n\n**输入：**\n\n- Ddamaged Actor：受到伤害的对象；\n\n- Base Damage：输入的伤害值；\n\n- Event Instigator：引发伤害的对象，如：持枪的敌人；\n\n- Damage Causer：实际造成伤害的对象，如：子弹；\n\n- Damage Type Class：伤害的类型；\n\n\n**输出：**\n\nReturn Value：最终造成的实际伤害。\n\n### <font color=green>Player Controller(角色控制器组件)</font>\n\n### Set View Target With Blend(相机线性移动)\n\n![](https://img-blog.csdnimg.cn/20210508105054190.png#pic_center)\n\n- Target：目标是PlayerController\n- New View Target：相机需要移动到的目的点\n- Blend Time：相机聚焦过程所需时间\n- Blend Func：聚焦方式\n- Blend Exp：控制曲线形状的指数，（实测中好像也没什么效果）\n- Lock Outgoing：为true时锁定视角移动，false则相机会转向\n\n## <font color=red>Rendering(渲染)</font>\n\n### <font color=green>Components</font>\n\n### <font color= orange> Light</font>\n\n#### **Set Intensity(设置光源强度)**\n\n![](【UE4】UE4组件/Snipaste_2019-10-25_13-32-38.png)\n\n- Target：目标光源；\n- New Intensity：目标光源强度。\n\n#### **Get Intensity(获取光源强度)**\n\n使用和Set Intensity一样。\n\n## <font color=red>String(字符串组件)</font>\n\n### <font color=green>Append(字符串连接)</font>\n\n![](【UE4】UE4组件/Snipaste_2019-10-28_17-04-19.png)\n\n### <font color=green>Switch On String(字符串匹配)</font>\n\n![](https://img-blog.csdnimg.cn/20210508103637363.png#pic_center)\n\n- Selection：输入字符串\n- Default：默认输出端口\n- Add pin：添加匹配端口\n\n## <font color=red>Utilities(通用组件)</font>\n\n### <font color=green>Flow Control</font>\n\n#### Branch(if语句)\n\n![](【UE4】UE4组件/Snipaste_2019-10-25_11-30-52.png)\n\n蓝图的if语句\n\n- Condition：输入的判断条件，一般和各种判断组件的输出连接。\n\n#### Delay(延迟函数)\n\n![](【UE4】UE4组件/Snipaste_2019-10-25_11-39-53.png)\n\n- Duration：延迟时间。\n\n### <font color=green>Keyboard Events(按键触发事件)</font>\n\n包含一些字符串操作函数。\n\n### <font color=green>Text</font>\n\n#### Equal\n\n![](【UE4】UE4组件/Snipaste_2019-10-25_11-42-14.png)\n\n输入两个比较对象，输出判断结果(Bool)。\n\n各种其他的判断组件用法一致。\n\n### <font color=green> Transformation</font>\n\n#### Set Actor Scale 3D\n\n![](【UE4】UE4组件/Snipaste_2019-10-25_13-19-47.png)\n\n设置Actor的Scale值\n\n- Target：要设置的目标Actor；\n- New Scale 3D：要设置的目标Scale值。\n\n#### Get Actor Scale 3D\n\n获取Actor的Scale值。\n\n#### Set Timer By Function Name\n\n节点：\n\n![](https://img-blog.csdnimg.cn/2021051114494414.png#pic_center)\n\n描述：通过函数名定时调用函数\n\n输入：\n\n- Object：调用函数所在蓝图，默认为节点所在蓝图\n- Function Name：要调用的函数的名字\n- Time：定时调用时间间隔\n- Looping：是否循环调用\n\n输出：\n\n- 一个Timer Handle结构体，记录了一些函数调用的信息\n\n**关联节点：**\n\n#### Pause Timer By Function Name\n\n节点：\n\n![](https://img-blog.csdnimg.cn/2021051114572299.png#pic_center)\n\n描述：暂停有Set Timer By Function Name节点启用的函数定时调用过程\n\n输入：与Set Timer By Function Name类似\n\n#### Unpause Timer By Function Name\n\n节点：\n\n![](https://img-blog.csdnimg.cn/20210511150004900.png#pic_center)\n\n描述：取消Pause Timer By Function Name的效果，继续Set Timer By Function Name的函数定时调用\n\n#### Clear Timer By Function Name\n\n节点：\n\n![](https://img-blog.csdnimg.cn/20210511151905631.png#pic_center)\n\n描述：清除Set Timer By Function Name的定时调用设置\n\n#### Set Timer By Event\n\n节点：\n\n![](https://img-blog.csdnimg.cn/20210511150319524.png#pic_center)\n\n描述：设置定时调用事件，与Set Timer By Function Name不同Set Timer By Evnet没有对应的Pause和Unpause节点，且Set Timer By Event只能调用所在蓝图的事件\n\n输入：\n\n- Evnet：绑定需要调用的蓝图事件\n- Time：定时调用的时间间隔\n- Looping：是否循环调用\n\n#### Puase Timer By Handle\n\n节点：\n\n![](https://img-blog.csdnimg.cn/20210511150856500.png#pic_center)\n\n描述：通过Set Timer By Function Name和Set Timer By Evnet的Timer Handle返回值来控制调用流程，暂停函数调用\n\n输入：\n\n- Handle：Timer Handle结构体，输入Set Timer By Function Name和Set Timer By Evnet的返回值\n\n#### Upause Timer By Handle\n\n节点：\n\n![](https://img-blog.csdnimg.cn/20210511150910775.png#pic_center)\n\n描述：清除Pause Timer By Handle的暂定效果继续Set Timer By Function或Set Timer By Event的定时效果\n\n#### Clear And Invalidate Timer By Handle\n\n节点：\n\n![](https://img-blog.csdnimg.cn/20210511150903510.png#pic_center)\n\n描述：通过Timer Handle值清除Set Timer By Function Name和Set Timer By Event的定时调用设置\n\n# 三、物理组件\n\nUE4除了提供大量蓝图脚本函数组件来对蓝图类进行精细控制外还提供了一系列物理组件对蓝图类进行一些常规的复杂控制。\n\n## <font color=red>Camera</font>\n\n#### **Camera**\n\n![](【UE4】UE4组件/Snipaste_2019-10-25_11-53-42.png)\n\n相机，用于渲染视野，一般配合Spring Arm一起使用。\n\n#### **Spring Arm**\n\n![](【UE4】UE4组件/Snipaste_2019-10-25_11-56-15.png)\n\n弹簧悬臂，将相机附于其上可以实现相机跟随\n\n## <font color=red>Movement</font>\n\n#### **Rotating Movement**\n\n旋转控制，提供一系列参数对对蓝图类的旋转运动进行控制\n\n## <font color=red>Rendering</font>\n\n#### **Static Mesh**\n\n静态网格，网格控制蓝图的贴图材质、模型外观、阴影渲染等。","slug":"【UE4】UE4组件","published":1,"updated":"2021-05-11T12:12:02.613Z","_id":"ckk9hocas0011dwr7fpb7a6l9","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p>不同的蓝图脚本拥有不同的组件集，蓝图脚本的组件集过于庞大，这里只对自己使用过的组件进行列举。</p>\n<p><font color=\"red\">说明：红色字体表示一级目录组件，绿色字体表示二级目录，黄色字体为三级目录(三级目录较为少见所以使用和二级目录相同的三级标题)，白色字体为具体组件说明</font>。</p>\n<h1 id=\"一、材质蓝图组件\"><a href=\"#一、材质蓝图组件\" class=\"headerlink\" title=\"一、材质蓝图组件\"></a>一、材质蓝图组件</h1><h2 id=\"Constans-常量\"><a href=\"#Constans-常量\" class=\"headerlink\" title=\"Constans(常量)\"></a><font color=\"red\">Constans(常量)</font></h2><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_11-46-47.png\"></p>\n<table>\n<thead>\n<tr>\n<th>组件</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Constans</td>\n<td>一维量，可以表示任何一维数据，如：小数、整数等</td>\n</tr>\n<tr>\n<td>Constans2Vector</td>\n<td>二维量，可以表示任何二维数据，如：二维坐标</td>\n</tr>\n<tr>\n<td>Constans3Vector</td>\n<td>三维量，可以表示任何三维数据，如：三维坐标、RBG等</td>\n</tr>\n<tr>\n<td>Constans4Vector</td>\n<td>四维量，可以表示任何四维数据，如：四元数</td>\n</tr>\n</tbody></table>\n<h2 id=\"Math-数学函数\"><a href=\"#Math-数学函数\" class=\"headerlink\" title=\"Math(数学函数)\"></a><font color=\"red\">Math(数学函数)</font></h2><h4 id=\"Multiply-乘积\"><a href=\"#Multiply-乘积\" class=\"headerlink\" title=\"Multiply(乘积)\"></a><strong>Multiply(乘积)</strong></h4><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_11-50-37.png\"></p>\n<h3 id=\"Lerp-插值\"><a href=\"#Lerp-插值\" class=\"headerlink\" title=\"Lerp(插值)\"></a><font color=\"green\">Lerp(插值)</font></h3><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_13-12-40.png\"></p>\n<p>Lerp组件在Math的多个二级目录中存在，有各种类型的插值变化。</p>\n<p><strong>输入：</strong></p>\n<ul>\n<li>A：插值变化的起始值；</li>\n<li>B：插值变化的目标值；</li>\n<li>Alpha：插值的变化规则，连接Float的TimeLine插值将按照TimeLine的规则变化。</li>\n</ul>\n<p><strong>输出：</strong></p>\n<ul>\n<li>Return Value：返回变化后的插值，将Lerp放入帧函数中可以获得每帧变化的插值。</li>\n</ul>\n<h1 id=\"二、普通蓝图组件\"><a href=\"#二、普通蓝图组件\" class=\"headerlink\" title=\"二、普通蓝图组件\"></a>二、普通蓝图组件</h1><hr>\n<h2 id=\"Add-TimeLine-添加时间线\"><a href=\"#Add-TimeLine-添加时间线\" class=\"headerlink\" title=\"Add TimeLine(添加时间线)\"></a><font color=\"red\">Add TimeLine(添加时间线)</font></h2><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_10-33-38.png\"></p>\n<p><strong>输入：</strong></p>\n<ul>\n<li>Play：播放，播放完毕下一次触发时不会从头开始，而是会从上一次时间点继续开始；</li>\n<li>Play from Start：从头开始播放，每次触发都从时间线起点开始执行；</li>\n<li>Stop：暂停，触发后直接从当前时刻暂停；</li>\n<li>Reverse：倒序播放，从当前时刻开始倒叙播放；</li>\n<li>Reverse from End：从末尾开始倒序播放；</li>\n<li>Set New Time：设置新的时间起点，即时间线从新设置的时间点开始执行；</li>\n<li>New Time：新的时间起点由外部输入。</li>\n</ul>\n<p><strong>输出：</strong></p>\n<ul>\n<li>Update：在时间线内每帧执行；</li>\n<li>Finished：时间线结束时触发；</li>\n<li>Direction：返回时间线的执行方向，只有两个值“Forward”和“Backward”；</li>\n<li>New Track 0：自己创建的时间线，创建了才会有，显示的名字也是自己命名的时间线的名字。</li>\n</ul>\n<h2 id=\"Add-Event-添加事件\"><a href=\"#Add-Event-添加事件\" class=\"headerlink\" title=\"Add Event(添加事件)\"></a><font color=\"red\">Add Event(添加事件)</font></h2><h3 id=\"Collision-碰撞体组件\"><a href=\"#Collision-碰撞体组件\" class=\"headerlink\" title=\"Collision(碰撞体组件)\"></a><font color=\"green\">Collision(碰撞体组件)</font></h3><h4 id=\"Event-ActorBeginOverlap-自动触发触发器\"><a href=\"#Event-ActorBeginOverlap-自动触发触发器\" class=\"headerlink\" title=\"Event ActorBeginOverlap(自动触发触发器)\"></a><strong>Event ActorBeginOverlap(自动触发触发器)</strong></h4><p>每当有物体进入触发器时自动触发</p>\n<p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_10-53-07.png\"></p>\n<ul>\n<li>Other Actor：返回进入触发器的游戏物体的信息。</li>\n</ul>\n<h3 id=\"Game\"><a href=\"#Game\" class=\"headerlink\" title=\"Game\"></a><font color=\"green\">Game</font></h3><h3 id=\"Damage\"><a href=\"#Damage\" class=\"headerlink\" title=\"Damage\"></a><font color=\"orange\">Damage</font></h3><h4 id=\"Event-AnyDamage\"><a href=\"#Event-AnyDamage\" class=\"headerlink\" title=\"Event AnyDamage\"></a><strong>Event AnyDamage</strong></h4><p>Event AnyDamage事件是配合Apply Damage组件一起使用的，当Apply Damage组件执行时，会自动触发Event AnyDamage事件。</p>\n<p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-28_17-28-37.png\"></p>\n<p><strong>输出：</strong></p>\n<ul>\n<li><p>Damage：从Apply Damage组件的Damage中传递过来的值；</p>\n</li>\n<li><p>Damage Type：从Apply Damage组件传递过来的Damage Type Class；</p>\n</li>\n<li><p>Instigated By：从Apply Damage组件传递过来的Event Instigateor；</p>\n</li>\n<li><p>Damage Causer：从Apply Damage组件传递过来的Damage Causer；</p>\n</li>\n</ul>\n<h2 id=\"Camera-Fades-相机渐变\"><a href=\"#Camera-Fades-相机渐变\" class=\"headerlink\" title=\"Camera Fades(相机渐变)\"></a><font color=\"red\">Camera Fades(相机渐变)</font></h2><p>Camera Fades组件是只有在Get Player Camera Menager组件的外拉中才能搜索到的专门服务于Get Player Camera Menager组件的相机组件集。</p>\n<h4 id=\"Start-Camera-Fade-开始渐变\"><a href=\"#Start-Camera-Fade-开始渐变\" class=\"headerlink\" title=\"Start Camera Fade(开始渐变)\"></a><strong>Start Camera Fade(开始渐变)</strong></h4><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_11-02-10.png\"></p>\n<ul>\n<li>Target：渐变目标相机，默认为当前相机；</li>\n<li>From Alpha：渐变起始Alpha；</li>\n<li>To Alpha：渐变目标Alpha；</li>\n<li>Duration：渐变持续时间；</li>\n<li>Color：渐变颜色；</li>\n<li>Should Fade Audio：启用声音渐变；</li>\n<li>Hold when Finished：渐变结束后保持当前Alpha值。</li>\n</ul>\n<h4 id=\"Stop-Camera-Fade-结束渐变\"><a href=\"#Stop-Camera-Fade-结束渐变\" class=\"headerlink\" title=\"Stop Camera Fade(结束渐变)\"></a><strong>Stop Camera Fade(结束渐变)</strong></h4><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_11-10-28.png\"></p>\n<p>触发时立刻停止当前渐变。</p>\n<h2 id=\"Event-BeginPlay\"><a href=\"#Event-BeginPlay\" class=\"headerlink\" title=\"Event BeginPlay\"></a><font color=\"red\">Event BeginPlay</font></h2><p>游戏开始时自动触发</p>\n<p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_10-57-11.png\"></p>\n<h2 id=\"Execute-Console-Command-执行控制台命令\"><a href=\"#Execute-Console-Command-执行控制台命令\" class=\"headerlink\" title=\"Execute Console Command(执行控制台命令)\"></a><font color=\"red\">Execute Console Command(执行控制台命令)</font></h2><p><img src=\"https://img-blog.csdnimg.cn/20210510102517406.png#pic_center\"></p>\n<ul>\n<li>Command：控制台命令字符串</li>\n<li>Specific Player：执行控制台命令的执行器，默认为当前GameMode指定的Player</li>\n</ul>\n<h3 id=\"常见控制台命令\"><a href=\"#常见控制台命令\" class=\"headerlink\" title=\"常见控制台命令\"></a><font color=\"green\">常见控制台命令</font></h3><ul>\n<li><p>start fps：显示帧率</p>\n</li>\n<li><p>start unit：显示性能调试信息</p>\n</li>\n<li><p>start rhi：显示GPU上的消耗细则</p>\n<p><a href=\"https://docs.unrealengine.com/zh-CN/TestingAndOptimization/PerformanceAndProfiling/StatCommands/index.html\">更多start命令</a></p>\n</li>\n<li><p>r.MobileContentScaleFactor 0：控制内容在移动设备中的缩放方式，0表示使用设备原始分辨率，如将DPI缩放曲线用于UI缩放，必须设为0</p>\n</li>\n<li><p>DisableAllScreenMessages：禁用所有在运行中的屏幕提示</p>\n</li>\n</ul>\n<h2 id=\"Input-输入流\"><a href=\"#Input-输入流\" class=\"headerlink\" title=\"Input(输入流)\"></a><font color=\"red\">Input(输入流)</font></h2><h3 id=\"Keyboard-Events-按键触发事件\"><a href=\"#Keyboard-Events-按键触发事件\" class=\"headerlink\" title=\"Keyboard Events(按键触发事件)\"></a><font color=\"green\">Keyboard Events(按键触发事件)</font></h3><p>包含所有键盘按键出发事件</p>\n<h2 id=\"Game-1\"><a href=\"#Game-1\" class=\"headerlink\" title=\"Game\"></a><font color=\"red\">Game</font></h2><h4 id=\"Get-Player-Pawn-获取角色对象\"><a href=\"#Get-Player-Pawn-获取角色对象\" class=\"headerlink\" title=\"Get Player Pawn(获取角色对象)\"></a><strong>Get Player Pawn(获取角色对象)</strong></h4><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_11-17-59.png\"></p>\n<ul>\n<li><p>Play Index：输入角色索引，可以直接设置也可以外部输入；</p>\n</li>\n<li><p>Return Value：返回获取的角色对象(Object)。</p>\n</li>\n</ul>\n<h4 id=\"Get-Current-Level-Name-获取关卡名字\"><a href=\"#Get-Current-Level-Name-获取关卡名字\" class=\"headerlink\" title=\"Get Current Level Name(获取关卡名字)\"></a><strong>Get Current Level Name(获取关卡名字)</strong></h4><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_11-21-18.png\"></p>\n<ul>\n<li>Remove Prefix String：移除前缀字符串；</li>\n<li>Return Value：返回获取到的关卡名称(String)。</li>\n</ul>\n<h4 id=\"Get-Player-Camera-Manager-获取角色相机管理器\"><a href=\"#Get-Player-Camera-Manager-获取角色相机管理器\" class=\"headerlink\" title=\"Get Player Camera Manager(获取角色相机管理器)\"></a><strong>Get Player Camera Manager(获取角色相机管理器)</strong></h4><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_11-26-07.png\"></p>\n<ul>\n<li>Player Index：输入角色索引；</li>\n<li>Return Value：返回输入角色身上的相机对象。</li>\n</ul>\n<h3 id=\"Damage-1\"><a href=\"#Damage-1\" class=\"headerlink\" title=\"Damage\"></a><font color=\"green\">Damage</font></h3><h4 id=\"Apply-Damage\"><a href=\"#Apply-Damage\" class=\"headerlink\" title=\"Apply Damage\"></a><strong>Apply Damage</strong></h4><p>Apply Damage组件一般和Event AnyDamage组件配合使用，当Apply Damage组件触发时，UE4会自动调用Event AnyDamage事件。需要注意的是，只有在Base Daamge不为0时才能触发Event Damage事件。</p>\n<p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-28_17-26-35.png\"></p>\n<p><strong>输入：</strong></p>\n<ul>\n<li><p>Ddamaged Actor：受到伤害的对象；</p>\n</li>\n<li><p>Base Damage：输入的伤害值；</p>\n</li>\n<li><p>Event Instigator：引发伤害的对象，如：持枪的敌人；</p>\n</li>\n<li><p>Damage Causer：实际造成伤害的对象，如：子弹；</p>\n</li>\n<li><p>Damage Type Class：伤害的类型；</p>\n</li>\n</ul>\n<p><strong>输出：</strong></p>\n<p>Return Value：最终造成的实际伤害。</p>\n<h3 id=\"Player-Controller-角色控制器组件\"><a href=\"#Player-Controller-角色控制器组件\" class=\"headerlink\" title=\"Player Controller(角色控制器组件)\"></a><font color=\"green\">Player Controller(角色控制器组件)</font></h3><h3 id=\"Set-View-Target-With-Blend-相机线性移动\"><a href=\"#Set-View-Target-With-Blend-相机线性移动\" class=\"headerlink\" title=\"Set View Target With Blend(相机线性移动)\"></a>Set View Target With Blend(相机线性移动)</h3><p><img src=\"https://img-blog.csdnimg.cn/20210508105054190.png#pic_center\"></p>\n<ul>\n<li>Target：目标是PlayerController</li>\n<li>New View Target：相机需要移动到的目的点</li>\n<li>Blend Time：相机聚焦过程所需时间</li>\n<li>Blend Func：聚焦方式</li>\n<li>Blend Exp：控制曲线形状的指数，（实测中好像也没什么效果）</li>\n<li>Lock Outgoing：为true时锁定视角移动，false则相机会转向</li>\n</ul>\n<h2 id=\"Rendering-渲染\"><a href=\"#Rendering-渲染\" class=\"headerlink\" title=\"Rendering(渲染)\"></a><font color=\"red\">Rendering(渲染)</font></h2><h3 id=\"Components\"><a href=\"#Components\" class=\"headerlink\" title=\"Components\"></a><font color=\"green\">Components</font></h3><h3 id=\"Light\"><a href=\"#Light\" class=\"headerlink\" title=\" Light\"></a><font color=\"orange\"> Light</font></h3><h4 id=\"Set-Intensity-设置光源强度\"><a href=\"#Set-Intensity-设置光源强度\" class=\"headerlink\" title=\"Set Intensity(设置光源强度)\"></a><strong>Set Intensity(设置光源强度)</strong></h4><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_13-32-38.png\"></p>\n<ul>\n<li>Target：目标光源；</li>\n<li>New Intensity：目标光源强度。</li>\n</ul>\n<h4 id=\"Get-Intensity-获取光源强度\"><a href=\"#Get-Intensity-获取光源强度\" class=\"headerlink\" title=\"Get Intensity(获取光源强度)\"></a><strong>Get Intensity(获取光源强度)</strong></h4><p>使用和Set Intensity一样。</p>\n<h2 id=\"String-字符串组件\"><a href=\"#String-字符串组件\" class=\"headerlink\" title=\"String(字符串组件)\"></a><font color=\"red\">String(字符串组件)</font></h2><h3 id=\"Append-字符串连接\"><a href=\"#Append-字符串连接\" class=\"headerlink\" title=\"Append(字符串连接)\"></a><font color=\"green\">Append(字符串连接)</font></h3><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-28_17-04-19.png\"></p>\n<h3 id=\"Switch-On-String-字符串匹配\"><a href=\"#Switch-On-String-字符串匹配\" class=\"headerlink\" title=\"Switch On String(字符串匹配)\"></a><font color=\"green\">Switch On String(字符串匹配)</font></h3><p><img src=\"https://img-blog.csdnimg.cn/20210508103637363.png#pic_center\"></p>\n<ul>\n<li>Selection：输入字符串</li>\n<li>Default：默认输出端口</li>\n<li>Add pin：添加匹配端口</li>\n</ul>\n<h2 id=\"Utilities-通用组件\"><a href=\"#Utilities-通用组件\" class=\"headerlink\" title=\"Utilities(通用组件)\"></a><font color=\"red\">Utilities(通用组件)</font></h2><h3 id=\"Flow-Control\"><a href=\"#Flow-Control\" class=\"headerlink\" title=\"Flow Control\"></a><font color=\"green\">Flow Control</font></h3><h4 id=\"Branch-if语句\"><a href=\"#Branch-if语句\" class=\"headerlink\" title=\"Branch(if语句)\"></a>Branch(if语句)</h4><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_11-30-52.png\"></p>\n<p>蓝图的if语句</p>\n<ul>\n<li>Condition：输入的判断条件，一般和各种判断组件的输出连接。</li>\n</ul>\n<h4 id=\"Delay-延迟函数\"><a href=\"#Delay-延迟函数\" class=\"headerlink\" title=\"Delay(延迟函数)\"></a>Delay(延迟函数)</h4><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_11-39-53.png\"></p>\n<ul>\n<li>Duration：延迟时间。</li>\n</ul>\n<h3 id=\"Keyboard-Events-按键触发事件-1\"><a href=\"#Keyboard-Events-按键触发事件-1\" class=\"headerlink\" title=\"Keyboard Events(按键触发事件)\"></a><font color=\"green\">Keyboard Events(按键触发事件)</font></h3><p>包含一些字符串操作函数。</p>\n<h3 id=\"Text\"><a href=\"#Text\" class=\"headerlink\" title=\"Text\"></a><font color=\"green\">Text</font></h3><h4 id=\"Equal\"><a href=\"#Equal\" class=\"headerlink\" title=\"Equal\"></a>Equal</h4><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_11-42-14.png\"></p>\n<p>输入两个比较对象，输出判断结果(Bool)。</p>\n<p>各种其他的判断组件用法一致。</p>\n<h3 id=\"Transformation\"><a href=\"#Transformation\" class=\"headerlink\" title=\" Transformation\"></a><font color=\"green\"> Transformation</font></h3><h4 id=\"Set-Actor-Scale-3D\"><a href=\"#Set-Actor-Scale-3D\" class=\"headerlink\" title=\"Set Actor Scale 3D\"></a>Set Actor Scale 3D</h4><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_13-19-47.png\"></p>\n<p>设置Actor的Scale值</p>\n<ul>\n<li>Target：要设置的目标Actor；</li>\n<li>New Scale 3D：要设置的目标Scale值。</li>\n</ul>\n<h4 id=\"Get-Actor-Scale-3D\"><a href=\"#Get-Actor-Scale-3D\" class=\"headerlink\" title=\"Get Actor Scale 3D\"></a>Get Actor Scale 3D</h4><p>获取Actor的Scale值。</p>\n<h4 id=\"Set-Timer-By-Function-Name\"><a href=\"#Set-Timer-By-Function-Name\" class=\"headerlink\" title=\"Set Timer By Function Name\"></a>Set Timer By Function Name</h4><p>节点：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2021051114494414.png#pic_center\"></p>\n<p>描述：通过函数名定时调用函数</p>\n<p>输入：</p>\n<ul>\n<li>Object：调用函数所在蓝图，默认为节点所在蓝图</li>\n<li>Function Name：要调用的函数的名字</li>\n<li>Time：定时调用时间间隔</li>\n<li>Looping：是否循环调用</li>\n</ul>\n<p>输出：</p>\n<ul>\n<li>一个Timer Handle结构体，记录了一些函数调用的信息</li>\n</ul>\n<p><strong>关联节点：</strong></p>\n<h4 id=\"Pause-Timer-By-Function-Name\"><a href=\"#Pause-Timer-By-Function-Name\" class=\"headerlink\" title=\"Pause Timer By Function Name\"></a>Pause Timer By Function Name</h4><p>节点：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2021051114572299.png#pic_center\"></p>\n<p>描述：暂停有Set Timer By Function Name节点启用的函数定时调用过程</p>\n<p>输入：与Set Timer By Function Name类似</p>\n<h4 id=\"Unpause-Timer-By-Function-Name\"><a href=\"#Unpause-Timer-By-Function-Name\" class=\"headerlink\" title=\"Unpause Timer By Function Name\"></a>Unpause Timer By Function Name</h4><p>节点：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210511150004900.png#pic_center\"></p>\n<p>描述：取消Pause Timer By Function Name的效果，继续Set Timer By Function Name的函数定时调用</p>\n<h4 id=\"Clear-Timer-By-Function-Name\"><a href=\"#Clear-Timer-By-Function-Name\" class=\"headerlink\" title=\"Clear Timer By Function Name\"></a>Clear Timer By Function Name</h4><p>节点：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210511151905631.png#pic_center\"></p>\n<p>描述：清除Set Timer By Function Name的定时调用设置</p>\n<h4 id=\"Set-Timer-By-Event\"><a href=\"#Set-Timer-By-Event\" class=\"headerlink\" title=\"Set Timer By Event\"></a>Set Timer By Event</h4><p>节点：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210511150319524.png#pic_center\"></p>\n<p>描述：设置定时调用事件，与Set Timer By Function Name不同Set Timer By Evnet没有对应的Pause和Unpause节点，且Set Timer By Event只能调用所在蓝图的事件</p>\n<p>输入：</p>\n<ul>\n<li>Evnet：绑定需要调用的蓝图事件</li>\n<li>Time：定时调用的时间间隔</li>\n<li>Looping：是否循环调用</li>\n</ul>\n<h4 id=\"Puase-Timer-By-Handle\"><a href=\"#Puase-Timer-By-Handle\" class=\"headerlink\" title=\"Puase Timer By Handle\"></a>Puase Timer By Handle</h4><p>节点：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210511150856500.png#pic_center\"></p>\n<p>描述：通过Set Timer By Function Name和Set Timer By Evnet的Timer Handle返回值来控制调用流程，暂停函数调用</p>\n<p>输入：</p>\n<ul>\n<li>Handle：Timer Handle结构体，输入Set Timer By Function Name和Set Timer By Evnet的返回值</li>\n</ul>\n<h4 id=\"Upause-Timer-By-Handle\"><a href=\"#Upause-Timer-By-Handle\" class=\"headerlink\" title=\"Upause Timer By Handle\"></a>Upause Timer By Handle</h4><p>节点：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210511150910775.png#pic_center\"></p>\n<p>描述：清除Pause Timer By Handle的暂定效果继续Set Timer By Function或Set Timer By Event的定时效果</p>\n<h4 id=\"Clear-And-Invalidate-Timer-By-Handle\"><a href=\"#Clear-And-Invalidate-Timer-By-Handle\" class=\"headerlink\" title=\"Clear And Invalidate Timer By Handle\"></a>Clear And Invalidate Timer By Handle</h4><p>节点：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210511150903510.png#pic_center\"></p>\n<p>描述：通过Timer Handle值清除Set Timer By Function Name和Set Timer By Event的定时调用设置</p>\n<h1 id=\"三、物理组件\"><a href=\"#三、物理组件\" class=\"headerlink\" title=\"三、物理组件\"></a>三、物理组件</h1><p>UE4除了提供大量蓝图脚本函数组件来对蓝图类进行精细控制外还提供了一系列物理组件对蓝图类进行一些常规的复杂控制。</p>\n<h2 id=\"Camera\"><a href=\"#Camera\" class=\"headerlink\" title=\"Camera\"></a><font color=\"red\">Camera</font></h2><h4 id=\"Camera-1\"><a href=\"#Camera-1\" class=\"headerlink\" title=\"Camera\"></a><strong>Camera</strong></h4><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_11-53-42.png\"></p>\n<p>相机，用于渲染视野，一般配合Spring Arm一起使用。</p>\n<h4 id=\"Spring-Arm\"><a href=\"#Spring-Arm\" class=\"headerlink\" title=\"Spring Arm\"></a><strong>Spring Arm</strong></h4><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_11-56-15.png\"></p>\n<p>弹簧悬臂，将相机附于其上可以实现相机跟随</p>\n<h2 id=\"Movement\"><a href=\"#Movement\" class=\"headerlink\" title=\"Movement\"></a><font color=\"red\">Movement</font></h2><h4 id=\"Rotating-Movement\"><a href=\"#Rotating-Movement\" class=\"headerlink\" title=\"Rotating Movement\"></a><strong>Rotating Movement</strong></h4><p>旋转控制，提供一系列参数对对蓝图类的旋转运动进行控制</p>\n<h2 id=\"Rendering\"><a href=\"#Rendering\" class=\"headerlink\" title=\"Rendering\"></a><font color=\"red\">Rendering</font></h2><h4 id=\"Static-Mesh\"><a href=\"#Static-Mesh\" class=\"headerlink\" title=\"Static Mesh\"></a><strong>Static Mesh</strong></h4><p>静态网格，网格控制蓝图的贴图材质、模型外观、阴影渲染等。</p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p>不同的蓝图脚本拥有不同的组件集，蓝图脚本的组件集过于庞大，这里只对自己使用过的组件进行列举。</p>\n<p><font color=\"red\">说明：红色字体表示一级目录组件，绿色字体表示二级目录，黄色字体为三级目录(三级目录较为少见所以使用和二级目录相同的三级标题)，白色字体为具体组件说明</font>。</p>\n<h1 id=\"一、材质蓝图组件\"><a href=\"#一、材质蓝图组件\" class=\"headerlink\" title=\"一、材质蓝图组件\"></a>一、材质蓝图组件</h1><h2 id=\"Constans-常量\"><a href=\"#Constans-常量\" class=\"headerlink\" title=\"Constans(常量)\"></a><font color=\"red\">Constans(常量)</font></h2><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_11-46-47.png\"></p>\n<table>\n<thead>\n<tr>\n<th>组件</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Constans</td>\n<td>一维量，可以表示任何一维数据，如：小数、整数等</td>\n</tr>\n<tr>\n<td>Constans2Vector</td>\n<td>二维量，可以表示任何二维数据，如：二维坐标</td>\n</tr>\n<tr>\n<td>Constans3Vector</td>\n<td>三维量，可以表示任何三维数据，如：三维坐标、RBG等</td>\n</tr>\n<tr>\n<td>Constans4Vector</td>\n<td>四维量，可以表示任何四维数据，如：四元数</td>\n</tr>\n</tbody></table>\n<h2 id=\"Math-数学函数\"><a href=\"#Math-数学函数\" class=\"headerlink\" title=\"Math(数学函数)\"></a><font color=\"red\">Math(数学函数)</font></h2><h4 id=\"Multiply-乘积\"><a href=\"#Multiply-乘积\" class=\"headerlink\" title=\"Multiply(乘积)\"></a><strong>Multiply(乘积)</strong></h4><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_11-50-37.png\"></p>\n<h3 id=\"Lerp-插值\"><a href=\"#Lerp-插值\" class=\"headerlink\" title=\"Lerp(插值)\"></a><font color=\"green\">Lerp(插值)</font></h3><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_13-12-40.png\"></p>\n<p>Lerp组件在Math的多个二级目录中存在，有各种类型的插值变化。</p>\n<p><strong>输入：</strong></p>\n<ul>\n<li>A：插值变化的起始值；</li>\n<li>B：插值变化的目标值；</li>\n<li>Alpha：插值的变化规则，连接Float的TimeLine插值将按照TimeLine的规则变化。</li>\n</ul>\n<p><strong>输出：</strong></p>\n<ul>\n<li>Return Value：返回变化后的插值，将Lerp放入帧函数中可以获得每帧变化的插值。</li>\n</ul>\n<h1 id=\"二、普通蓝图组件\"><a href=\"#二、普通蓝图组件\" class=\"headerlink\" title=\"二、普通蓝图组件\"></a>二、普通蓝图组件</h1><hr>\n<h2 id=\"Add-TimeLine-添加时间线\"><a href=\"#Add-TimeLine-添加时间线\" class=\"headerlink\" title=\"Add TimeLine(添加时间线)\"></a><font color=\"red\">Add TimeLine(添加时间线)</font></h2><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_10-33-38.png\"></p>\n<p><strong>输入：</strong></p>\n<ul>\n<li>Play：播放，播放完毕下一次触发时不会从头开始，而是会从上一次时间点继续开始；</li>\n<li>Play from Start：从头开始播放，每次触发都从时间线起点开始执行；</li>\n<li>Stop：暂停，触发后直接从当前时刻暂停；</li>\n<li>Reverse：倒序播放，从当前时刻开始倒叙播放；</li>\n<li>Reverse from End：从末尾开始倒序播放；</li>\n<li>Set New Time：设置新的时间起点，即时间线从新设置的时间点开始执行；</li>\n<li>New Time：新的时间起点由外部输入。</li>\n</ul>\n<p><strong>输出：</strong></p>\n<ul>\n<li>Update：在时间线内每帧执行；</li>\n<li>Finished：时间线结束时触发；</li>\n<li>Direction：返回时间线的执行方向，只有两个值“Forward”和“Backward”；</li>\n<li>New Track 0：自己创建的时间线，创建了才会有，显示的名字也是自己命名的时间线的名字。</li>\n</ul>\n<h2 id=\"Add-Event-添加事件\"><a href=\"#Add-Event-添加事件\" class=\"headerlink\" title=\"Add Event(添加事件)\"></a><font color=\"red\">Add Event(添加事件)</font></h2><h3 id=\"Collision-碰撞体组件\"><a href=\"#Collision-碰撞体组件\" class=\"headerlink\" title=\"Collision(碰撞体组件)\"></a><font color=\"green\">Collision(碰撞体组件)</font></h3><h4 id=\"Event-ActorBeginOverlap-自动触发触发器\"><a href=\"#Event-ActorBeginOverlap-自动触发触发器\" class=\"headerlink\" title=\"Event ActorBeginOverlap(自动触发触发器)\"></a><strong>Event ActorBeginOverlap(自动触发触发器)</strong></h4><p>每当有物体进入触发器时自动触发</p>\n<p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_10-53-07.png\"></p>\n<ul>\n<li>Other Actor：返回进入触发器的游戏物体的信息。</li>\n</ul>\n<h3 id=\"Game\"><a href=\"#Game\" class=\"headerlink\" title=\"Game\"></a><font color=\"green\">Game</font></h3><h3 id=\"Damage\"><a href=\"#Damage\" class=\"headerlink\" title=\"Damage\"></a><font color=\"orange\">Damage</font></h3><h4 id=\"Event-AnyDamage\"><a href=\"#Event-AnyDamage\" class=\"headerlink\" title=\"Event AnyDamage\"></a><strong>Event AnyDamage</strong></h4><p>Event AnyDamage事件是配合Apply Damage组件一起使用的，当Apply Damage组件执行时，会自动触发Event AnyDamage事件。</p>\n<p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-28_17-28-37.png\"></p>\n<p><strong>输出：</strong></p>\n<ul>\n<li><p>Damage：从Apply Damage组件的Damage中传递过来的值；</p>\n</li>\n<li><p>Damage Type：从Apply Damage组件传递过来的Damage Type Class；</p>\n</li>\n<li><p>Instigated By：从Apply Damage组件传递过来的Event Instigateor；</p>\n</li>\n<li><p>Damage Causer：从Apply Damage组件传递过来的Damage Causer；</p>\n</li>\n</ul>\n<h2 id=\"Camera-Fades-相机渐变\"><a href=\"#Camera-Fades-相机渐变\" class=\"headerlink\" title=\"Camera Fades(相机渐变)\"></a><font color=\"red\">Camera Fades(相机渐变)</font></h2><p>Camera Fades组件是只有在Get Player Camera Menager组件的外拉中才能搜索到的专门服务于Get Player Camera Menager组件的相机组件集。</p>\n<h4 id=\"Start-Camera-Fade-开始渐变\"><a href=\"#Start-Camera-Fade-开始渐变\" class=\"headerlink\" title=\"Start Camera Fade(开始渐变)\"></a><strong>Start Camera Fade(开始渐变)</strong></h4><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_11-02-10.png\"></p>\n<ul>\n<li>Target：渐变目标相机，默认为当前相机；</li>\n<li>From Alpha：渐变起始Alpha；</li>\n<li>To Alpha：渐变目标Alpha；</li>\n<li>Duration：渐变持续时间；</li>\n<li>Color：渐变颜色；</li>\n<li>Should Fade Audio：启用声音渐变；</li>\n<li>Hold when Finished：渐变结束后保持当前Alpha值。</li>\n</ul>\n<h4 id=\"Stop-Camera-Fade-结束渐变\"><a href=\"#Stop-Camera-Fade-结束渐变\" class=\"headerlink\" title=\"Stop Camera Fade(结束渐变)\"></a><strong>Stop Camera Fade(结束渐变)</strong></h4><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_11-10-28.png\"></p>\n<p>触发时立刻停止当前渐变。</p>\n<h2 id=\"Event-BeginPlay\"><a href=\"#Event-BeginPlay\" class=\"headerlink\" title=\"Event BeginPlay\"></a><font color=\"red\">Event BeginPlay</font></h2><p>游戏开始时自动触发</p>\n<p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_10-57-11.png\"></p>\n<h2 id=\"Execute-Console-Command-执行控制台命令\"><a href=\"#Execute-Console-Command-执行控制台命令\" class=\"headerlink\" title=\"Execute Console Command(执行控制台命令)\"></a><font color=\"red\">Execute Console Command(执行控制台命令)</font></h2><p><img src=\"https://img-blog.csdnimg.cn/20210510102517406.png#pic_center\"></p>\n<ul>\n<li>Command：控制台命令字符串</li>\n<li>Specific Player：执行控制台命令的执行器，默认为当前GameMode指定的Player</li>\n</ul>\n<h3 id=\"常见控制台命令\"><a href=\"#常见控制台命令\" class=\"headerlink\" title=\"常见控制台命令\"></a><font color=\"green\">常见控制台命令</font></h3><ul>\n<li><p>start fps：显示帧率</p>\n</li>\n<li><p>start unit：显示性能调试信息</p>\n</li>\n<li><p>start rhi：显示GPU上的消耗细则</p>\n<p><a href=\"https://docs.unrealengine.com/zh-CN/TestingAndOptimization/PerformanceAndProfiling/StatCommands/index.html\">更多start命令</a></p>\n</li>\n<li><p>r.MobileContentScaleFactor 0：控制内容在移动设备中的缩放方式，0表示使用设备原始分辨率，如将DPI缩放曲线用于UI缩放，必须设为0</p>\n</li>\n<li><p>DisableAllScreenMessages：禁用所有在运行中的屏幕提示</p>\n</li>\n</ul>\n<h2 id=\"Input-输入流\"><a href=\"#Input-输入流\" class=\"headerlink\" title=\"Input(输入流)\"></a><font color=\"red\">Input(输入流)</font></h2><h3 id=\"Keyboard-Events-按键触发事件\"><a href=\"#Keyboard-Events-按键触发事件\" class=\"headerlink\" title=\"Keyboard Events(按键触发事件)\"></a><font color=\"green\">Keyboard Events(按键触发事件)</font></h3><p>包含所有键盘按键出发事件</p>\n<h2 id=\"Game-1\"><a href=\"#Game-1\" class=\"headerlink\" title=\"Game\"></a><font color=\"red\">Game</font></h2><h4 id=\"Get-Player-Pawn-获取角色对象\"><a href=\"#Get-Player-Pawn-获取角色对象\" class=\"headerlink\" title=\"Get Player Pawn(获取角色对象)\"></a><strong>Get Player Pawn(获取角色对象)</strong></h4><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_11-17-59.png\"></p>\n<ul>\n<li><p>Play Index：输入角色索引，可以直接设置也可以外部输入；</p>\n</li>\n<li><p>Return Value：返回获取的角色对象(Object)。</p>\n</li>\n</ul>\n<h4 id=\"Get-Current-Level-Name-获取关卡名字\"><a href=\"#Get-Current-Level-Name-获取关卡名字\" class=\"headerlink\" title=\"Get Current Level Name(获取关卡名字)\"></a><strong>Get Current Level Name(获取关卡名字)</strong></h4><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_11-21-18.png\"></p>\n<ul>\n<li>Remove Prefix String：移除前缀字符串；</li>\n<li>Return Value：返回获取到的关卡名称(String)。</li>\n</ul>\n<h4 id=\"Get-Player-Camera-Manager-获取角色相机管理器\"><a href=\"#Get-Player-Camera-Manager-获取角色相机管理器\" class=\"headerlink\" title=\"Get Player Camera Manager(获取角色相机管理器)\"></a><strong>Get Player Camera Manager(获取角色相机管理器)</strong></h4><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_11-26-07.png\"></p>\n<ul>\n<li>Player Index：输入角色索引；</li>\n<li>Return Value：返回输入角色身上的相机对象。</li>\n</ul>\n<h3 id=\"Damage-1\"><a href=\"#Damage-1\" class=\"headerlink\" title=\"Damage\"></a><font color=\"green\">Damage</font></h3><h4 id=\"Apply-Damage\"><a href=\"#Apply-Damage\" class=\"headerlink\" title=\"Apply Damage\"></a><strong>Apply Damage</strong></h4><p>Apply Damage组件一般和Event AnyDamage组件配合使用，当Apply Damage组件触发时，UE4会自动调用Event AnyDamage事件。需要注意的是，只有在Base Daamge不为0时才能触发Event Damage事件。</p>\n<p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-28_17-26-35.png\"></p>\n<p><strong>输入：</strong></p>\n<ul>\n<li><p>Ddamaged Actor：受到伤害的对象；</p>\n</li>\n<li><p>Base Damage：输入的伤害值；</p>\n</li>\n<li><p>Event Instigator：引发伤害的对象，如：持枪的敌人；</p>\n</li>\n<li><p>Damage Causer：实际造成伤害的对象，如：子弹；</p>\n</li>\n<li><p>Damage Type Class：伤害的类型；</p>\n</li>\n</ul>\n<p><strong>输出：</strong></p>\n<p>Return Value：最终造成的实际伤害。</p>\n<h3 id=\"Player-Controller-角色控制器组件\"><a href=\"#Player-Controller-角色控制器组件\" class=\"headerlink\" title=\"Player Controller(角色控制器组件)\"></a><font color=\"green\">Player Controller(角色控制器组件)</font></h3><h3 id=\"Set-View-Target-With-Blend-相机线性移动\"><a href=\"#Set-View-Target-With-Blend-相机线性移动\" class=\"headerlink\" title=\"Set View Target With Blend(相机线性移动)\"></a>Set View Target With Blend(相机线性移动)</h3><p><img src=\"https://img-blog.csdnimg.cn/20210508105054190.png#pic_center\"></p>\n<ul>\n<li>Target：目标是PlayerController</li>\n<li>New View Target：相机需要移动到的目的点</li>\n<li>Blend Time：相机聚焦过程所需时间</li>\n<li>Blend Func：聚焦方式</li>\n<li>Blend Exp：控制曲线形状的指数，（实测中好像也没什么效果）</li>\n<li>Lock Outgoing：为true时锁定视角移动，false则相机会转向</li>\n</ul>\n<h2 id=\"Rendering-渲染\"><a href=\"#Rendering-渲染\" class=\"headerlink\" title=\"Rendering(渲染)\"></a><font color=\"red\">Rendering(渲染)</font></h2><h3 id=\"Components\"><a href=\"#Components\" class=\"headerlink\" title=\"Components\"></a><font color=\"green\">Components</font></h3><h3 id=\"Light\"><a href=\"#Light\" class=\"headerlink\" title=\" Light\"></a><font color=\"orange\"> Light</font></h3><h4 id=\"Set-Intensity-设置光源强度\"><a href=\"#Set-Intensity-设置光源强度\" class=\"headerlink\" title=\"Set Intensity(设置光源强度)\"></a><strong>Set Intensity(设置光源强度)</strong></h4><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_13-32-38.png\"></p>\n<ul>\n<li>Target：目标光源；</li>\n<li>New Intensity：目标光源强度。</li>\n</ul>\n<h4 id=\"Get-Intensity-获取光源强度\"><a href=\"#Get-Intensity-获取光源强度\" class=\"headerlink\" title=\"Get Intensity(获取光源强度)\"></a><strong>Get Intensity(获取光源强度)</strong></h4><p>使用和Set Intensity一样。</p>\n<h2 id=\"String-字符串组件\"><a href=\"#String-字符串组件\" class=\"headerlink\" title=\"String(字符串组件)\"></a><font color=\"red\">String(字符串组件)</font></h2><h3 id=\"Append-字符串连接\"><a href=\"#Append-字符串连接\" class=\"headerlink\" title=\"Append(字符串连接)\"></a><font color=\"green\">Append(字符串连接)</font></h3><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-28_17-04-19.png\"></p>\n<h3 id=\"Switch-On-String-字符串匹配\"><a href=\"#Switch-On-String-字符串匹配\" class=\"headerlink\" title=\"Switch On String(字符串匹配)\"></a><font color=\"green\">Switch On String(字符串匹配)</font></h3><p><img src=\"https://img-blog.csdnimg.cn/20210508103637363.png#pic_center\"></p>\n<ul>\n<li>Selection：输入字符串</li>\n<li>Default：默认输出端口</li>\n<li>Add pin：添加匹配端口</li>\n</ul>\n<h2 id=\"Utilities-通用组件\"><a href=\"#Utilities-通用组件\" class=\"headerlink\" title=\"Utilities(通用组件)\"></a><font color=\"red\">Utilities(通用组件)</font></h2><h3 id=\"Flow-Control\"><a href=\"#Flow-Control\" class=\"headerlink\" title=\"Flow Control\"></a><font color=\"green\">Flow Control</font></h3><h4 id=\"Branch-if语句\"><a href=\"#Branch-if语句\" class=\"headerlink\" title=\"Branch(if语句)\"></a>Branch(if语句)</h4><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_11-30-52.png\"></p>\n<p>蓝图的if语句</p>\n<ul>\n<li>Condition：输入的判断条件，一般和各种判断组件的输出连接。</li>\n</ul>\n<h4 id=\"Delay-延迟函数\"><a href=\"#Delay-延迟函数\" class=\"headerlink\" title=\"Delay(延迟函数)\"></a>Delay(延迟函数)</h4><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_11-39-53.png\"></p>\n<ul>\n<li>Duration：延迟时间。</li>\n</ul>\n<h3 id=\"Keyboard-Events-按键触发事件-1\"><a href=\"#Keyboard-Events-按键触发事件-1\" class=\"headerlink\" title=\"Keyboard Events(按键触发事件)\"></a><font color=\"green\">Keyboard Events(按键触发事件)</font></h3><p>包含一些字符串操作函数。</p>\n<h3 id=\"Text\"><a href=\"#Text\" class=\"headerlink\" title=\"Text\"></a><font color=\"green\">Text</font></h3><h4 id=\"Equal\"><a href=\"#Equal\" class=\"headerlink\" title=\"Equal\"></a>Equal</h4><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_11-42-14.png\"></p>\n<p>输入两个比较对象，输出判断结果(Bool)。</p>\n<p>各种其他的判断组件用法一致。</p>\n<h3 id=\"Transformation\"><a href=\"#Transformation\" class=\"headerlink\" title=\" Transformation\"></a><font color=\"green\"> Transformation</font></h3><h4 id=\"Set-Actor-Scale-3D\"><a href=\"#Set-Actor-Scale-3D\" class=\"headerlink\" title=\"Set Actor Scale 3D\"></a>Set Actor Scale 3D</h4><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_13-19-47.png\"></p>\n<p>设置Actor的Scale值</p>\n<ul>\n<li>Target：要设置的目标Actor；</li>\n<li>New Scale 3D：要设置的目标Scale值。</li>\n</ul>\n<h4 id=\"Get-Actor-Scale-3D\"><a href=\"#Get-Actor-Scale-3D\" class=\"headerlink\" title=\"Get Actor Scale 3D\"></a>Get Actor Scale 3D</h4><p>获取Actor的Scale值。</p>\n<h4 id=\"Set-Timer-By-Function-Name\"><a href=\"#Set-Timer-By-Function-Name\" class=\"headerlink\" title=\"Set Timer By Function Name\"></a>Set Timer By Function Name</h4><p>节点：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2021051114494414.png#pic_center\"></p>\n<p>描述：通过函数名定时调用函数</p>\n<p>输入：</p>\n<ul>\n<li>Object：调用函数所在蓝图，默认为节点所在蓝图</li>\n<li>Function Name：要调用的函数的名字</li>\n<li>Time：定时调用时间间隔</li>\n<li>Looping：是否循环调用</li>\n</ul>\n<p>输出：</p>\n<ul>\n<li>一个Timer Handle结构体，记录了一些函数调用的信息</li>\n</ul>\n<p><strong>关联节点：</strong></p>\n<h4 id=\"Pause-Timer-By-Function-Name\"><a href=\"#Pause-Timer-By-Function-Name\" class=\"headerlink\" title=\"Pause Timer By Function Name\"></a>Pause Timer By Function Name</h4><p>节点：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2021051114572299.png#pic_center\"></p>\n<p>描述：暂停有Set Timer By Function Name节点启用的函数定时调用过程</p>\n<p>输入：与Set Timer By Function Name类似</p>\n<h4 id=\"Unpause-Timer-By-Function-Name\"><a href=\"#Unpause-Timer-By-Function-Name\" class=\"headerlink\" title=\"Unpause Timer By Function Name\"></a>Unpause Timer By Function Name</h4><p>节点：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210511150004900.png#pic_center\"></p>\n<p>描述：取消Pause Timer By Function Name的效果，继续Set Timer By Function Name的函数定时调用</p>\n<h4 id=\"Clear-Timer-By-Function-Name\"><a href=\"#Clear-Timer-By-Function-Name\" class=\"headerlink\" title=\"Clear Timer By Function Name\"></a>Clear Timer By Function Name</h4><p>节点：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210511151905631.png#pic_center\"></p>\n<p>描述：清除Set Timer By Function Name的定时调用设置</p>\n<h4 id=\"Set-Timer-By-Event\"><a href=\"#Set-Timer-By-Event\" class=\"headerlink\" title=\"Set Timer By Event\"></a>Set Timer By Event</h4><p>节点：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210511150319524.png#pic_center\"></p>\n<p>描述：设置定时调用事件，与Set Timer By Function Name不同Set Timer By Evnet没有对应的Pause和Unpause节点，且Set Timer By Event只能调用所在蓝图的事件</p>\n<p>输入：</p>\n<ul>\n<li>Evnet：绑定需要调用的蓝图事件</li>\n<li>Time：定时调用的时间间隔</li>\n<li>Looping：是否循环调用</li>\n</ul>\n<h4 id=\"Puase-Timer-By-Handle\"><a href=\"#Puase-Timer-By-Handle\" class=\"headerlink\" title=\"Puase Timer By Handle\"></a>Puase Timer By Handle</h4><p>节点：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210511150856500.png#pic_center\"></p>\n<p>描述：通过Set Timer By Function Name和Set Timer By Evnet的Timer Handle返回值来控制调用流程，暂停函数调用</p>\n<p>输入：</p>\n<ul>\n<li>Handle：Timer Handle结构体，输入Set Timer By Function Name和Set Timer By Evnet的返回值</li>\n</ul>\n<h4 id=\"Upause-Timer-By-Handle\"><a href=\"#Upause-Timer-By-Handle\" class=\"headerlink\" title=\"Upause Timer By Handle\"></a>Upause Timer By Handle</h4><p>节点：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210511150910775.png#pic_center\"></p>\n<p>描述：清除Pause Timer By Handle的暂定效果继续Set Timer By Function或Set Timer By Event的定时效果</p>\n<h4 id=\"Clear-And-Invalidate-Timer-By-Handle\"><a href=\"#Clear-And-Invalidate-Timer-By-Handle\" class=\"headerlink\" title=\"Clear And Invalidate Timer By Handle\"></a>Clear And Invalidate Timer By Handle</h4><p>节点：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210511150903510.png#pic_center\"></p>\n<p>描述：通过Timer Handle值清除Set Timer By Function Name和Set Timer By Event的定时调用设置</p>\n<h1 id=\"三、物理组件\"><a href=\"#三、物理组件\" class=\"headerlink\" title=\"三、物理组件\"></a>三、物理组件</h1><p>UE4除了提供大量蓝图脚本函数组件来对蓝图类进行精细控制外还提供了一系列物理组件对蓝图类进行一些常规的复杂控制。</p>\n<h2 id=\"Camera\"><a href=\"#Camera\" class=\"headerlink\" title=\"Camera\"></a><font color=\"red\">Camera</font></h2><h4 id=\"Camera-1\"><a href=\"#Camera-1\" class=\"headerlink\" title=\"Camera\"></a><strong>Camera</strong></h4><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_11-53-42.png\"></p>\n<p>相机，用于渲染视野，一般配合Spring Arm一起使用。</p>\n<h4 id=\"Spring-Arm\"><a href=\"#Spring-Arm\" class=\"headerlink\" title=\"Spring Arm\"></a><strong>Spring Arm</strong></h4><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_11-56-15.png\"></p>\n<p>弹簧悬臂，将相机附于其上可以实现相机跟随</p>\n<h2 id=\"Movement\"><a href=\"#Movement\" class=\"headerlink\" title=\"Movement\"></a><font color=\"red\">Movement</font></h2><h4 id=\"Rotating-Movement\"><a href=\"#Rotating-Movement\" class=\"headerlink\" title=\"Rotating Movement\"></a><strong>Rotating Movement</strong></h4><p>旋转控制，提供一系列参数对对蓝图类的旋转运动进行控制</p>\n<h2 id=\"Rendering\"><a href=\"#Rendering\" class=\"headerlink\" title=\"Rendering\"></a><font color=\"red\">Rendering</font></h2><h4 id=\"Static-Mesh\"><a href=\"#Static-Mesh\" class=\"headerlink\" title=\"Static Mesh\"></a><strong>Static Mesh</strong></h4><p>静态网格，网格控制蓝图的贴图材质、模型外观、阴影渲染等。</p>\n"},{"title":"【UE4】UE4联级粒子系统","date":"2019-11-17T12:36:30.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 一、粒子系统的一些基本概念\n\n## 1.Particle System(粒子系统)\n\n粒子系统如同贴图、模型一样属于UE4的驻留资产，不能单独存在于场景中，必须使用载体依托才能在场景中渲染出来，粒子系统包含粒子特效的所有配置。粒子系统在UE4中表现为如下样子：\n\n![](【UE4】UE4联级粒子系统/Snipaste_2019-11-14_09-41-14.png)\n\n### 创建粒子系统\n\n在内容浏览器中右键选择Particle System可以直接创建粒子系统。\n\n![](【UE4】UE4联级粒子系统/Snipaste_2019-11-14_10-14-27.png)\n\n## 2.Emitter Actor(粒子发射器)\n\n粒子发射器就是粒子系统的载体，粒子发射器承载粒子系统确定粒子系统在场景中的位置坐标等信息。但是似乎UE4没办法直接创建空的粒子发射器，UE4的粒子发射器在将粒子系统拖入场景中时，UE4会自动为该粒子系统创建一个粒子发射器。\n\n## 3.Particle System Component(粒子系统组件)\n\n粒子系统组件是一个包含了粒子系统的蓝图，粒子系统组件可以使用代码逻辑来控制粒子系统。\n\n# 二、Cascade(粒子编辑器)\n\n粒子系统的核心就是粒子编辑器，在粒子编辑器里我们可以创造出琳琅满目的粒子特效。\n\n粒子编辑器包含Toolbar、Emitters、Details、Viewport和Curve Editor等视图。\n\n## 1.ToolBar(工具栏)\n\n![](【UE4】UE4联级粒子系统/Snipaste_2019-11-14_11-50-46.png)\n\n## 2.Emitters\n\nEmitters是用于控制粒子属性的视图，Emitters的基本组成单元就是Emitter(发射器)，这里的Emitter和前面提到的Emitter Actor有一些差异，二者都是粒子发射器，但是Emitter是属于粒子系统内部的发射器，主要用于对粒子系统的某一部分的粒子发射，如爆炸的粒子特效中可以由烟、火光和火花等粒子部分组成，Emitter就是用于发射这些粒子部分的发射器，而Emitter Actor则是用于发射整个粒子系统的发射器。\n\n## 3.Emitter(发射器)\n\n在Emitters视图中每一列就是一个Emitter，一个Emitter控制一个粒子部分。一个Emitter拥有Required和Spawn两个固有组成模块，即每个Emitter被创建出来就拥有Required和Spawn模块，且这两个模块不能删除。\n\nEmitter的执行顺序是自左而右的。\n\n![](【UE4】UE4联级粒子系统/Snipaste_2019-11-14_10-25-52.png)\n\n### 创建Emitter\n\n直接在Emitters视图的空白出右键选择New Particle Sprite Emitter即可。\n\n### 赋值Emitter\n\n选中需要复制的Emitter右键/Emiter/Duplicate Emitter即可。\n\n### 删除Emitter\n\n选中需要删除的Emitter右键/Emitter/Delete Emitter，或直接按delete键。\n\n## 4.Emitter的分类\n\n直接创建的Emitter默认为普通Emitter即没有任何特殊属性的Emitter，要创建具有特殊属性的特殊的Emitter需要修改Emitter的TypeData属性，右键/TypeData选择需要的类型即可修改Emitter的类型。\n\n![](【UE4】UE4联级粒子系统/Snipaste_2019-11-14_10-51-44.png)\n\n### AnimTrail Data\n\n骨骼动画发射器，AnimTrail可以使粒子跟随人物骨骼运动而运动，如下图的跟随人物手臂运动的彩虹带\n\n![](【UE4】UE4联级粒子系统/Snipaste_2019-11-14_10-58-31.png)\n\nAnimTrail是配合UE4的动画系统一起使用的，使用AnimTrail我们需要选择一段动画片段如下图\n\n![](【UE4】UE4联级粒子系统/Snipaste_2019-11-15_15-05-48.png)\n\n发射器会在选定的时间片段内发射粒子，在右侧的Trail栏中选定粒子需要跟随的骨骼和骨骼需要绑定的粒子系统，就可以使粒子跟随着骨骼运动了。\n\n### Beam Data\n\n光束发射器，Beam有一个源点和一个目标点，粒子由源点发射运动到目标点销毁，Beam在粒子由源点运动到目标点的过程中可以设置粒子抖动，使粒子的运动具有抖动效果，如下图的闪电。\n\n![](【UE4】UE4联级粒子系统/Snipaste_2019-11-14_11-14-32.png)\n\nBeam拥有一个专属Module--Beam，在这个模块里可以为Beam添加Source(源点)、Target(目标点)和Noise(噪声)，Noise就是控制粒子抖动的Module，要想粒子出现抖动有几点是必须要做的，即勾选Noise模块的Low Freq/Low Freq Enabled、设置Frequency(噪声点的频率，影响粒子抖动的平滑程度)；Source和Target模块的Suorce Tangent/Distribution/Constant和Target Tangent/Distribution/Constant(影响源点到目标点的粒子抖动的曲率)，要想这两个设置起作用还必须设置Source/Source Tangent Method为User Set，目标点也是一样的设置；还有一点就是要想粒子从源点向目标点运动还需要设置Beam Data模块的Beam/Beam Method为Target。\n\n### GPU Sprites\n\nGPU Sprites是普通粒子的加强版，可以使粒子具有更完美的物理效果，但当对于普通粒子发射器来说更消耗GPU性能。\n\n**矢量场：**\n\n矢量场是GPU粒子独有的属性，GPU粒子在矢量成的控制下可以作出任意轨迹运用，如：\n\n![](【UE4】UE4联级粒子系统/Snipaste_2019-11-14_19-48-16.png)\n\n矢量场有多个属性控制模块\n\n![](【UE4】UE4联级粒子系统/Snipaste_2019-11-14_19-47-55.png)\n\n矢量场默认是看不见的，我们需要在Viewport里勾选View/Vector Fields，使矢量场可见。\n\n### Mesh Data\n\n网格发射器，Mesh可以使粒子使用模型网格，这样发射出来的粒子就是一个个具体的模型，如下图所示。\n\n<img src=\"【UE4】UE4联级粒子系统/Snipaste_2019-11-14_11-10-41.png\" style=\"zoom:50%;\" />\n\n### Ribbon Data\n\n光带发射器，Ribbon可以记录粒子的运行轨迹，并可以对其属性进行编辑，如下图使用粒子运行轨迹制作的光带。\n\n<img src=\"【UE4】UE4联级粒子系统/Snipaste_2019-11-14_11-03-35.png\" style=\"zoom:50%;\" />\n\nRibbon的粒子生成模块不是使用Spawn，而是Spawn PerUnit，由于Spawn是Emitter的固有Module所以无法移除，我们要启用Spawn PerUnit则需要将Spawn Module的Spawn/Distribution/Constant设置为0，达到间接禁用Spawn的效果。这样彩带粒子就是用Spawn PerUnit生成粒子了，想要彩带粒子跟随其他粒子运动我们还需要一个Module--Trail/Source，将Source Module里的Source/Source Mothod设置为PET2SRCM Particle，并且Source Name设置为需要跟随粒子部分的Emitter的名字，这样就可以产生一个跟随其他粒子的彩带了，当然这个彩带粒子是需要设置贴图的，否则尽管生成了，但是却没有渲染。\n\n## 4.Module(模块)\n\n模块用于控制粒子某一方面的属性，在Emitter中每一行就是一个Module，Module的种类很多，这里只列举自己使用过的Module。\n\nUE4Module的执行顺序是自上而下的所以当一个Emitter中有两个相同的Module时，下面的Module会覆盖上面的Module。\n\n### 添加Module\n\n选中需要添加Module的Emitter，右键选择需要的Module即可\n\n### 移除Module\n\n选中需要移除的Module右键/Delete Module，或直接按Delete键。\n\n### 拷贝Module\n\nShift+拖动即可拷贝一个Module到另一个Emitter中。\n\n### Required\n\nRequired控制粒子的显示方面的属性，如粒子贴图，显示模式等。\n\n- Sub UV栏控制贴图的逐帧融合。\n\n### Spawn\n\nSpawn控制粒子的发射方面的属性，如粒子发射量，发射模式等。\n\n- Spawn栏控制粒子持续性的发射；\n- Burst栏控制粒子间歇性的爆炸发射。\n\n### LifeTime\n\nLifeTime控制粒子的声明周期方面的属性。\n\n### Initial Size\n\nInitial Size控制粒子初始尺寸方面的属性。\n\n### Initial Velocity\n\nInitial Velocity控制粒子初始速度方面的属性。\n\n### Color Over Life\n\nColor Over Life控制粒子生命周期内的颜色变化方面的属性。\n\n生命周期的初始颜色是Color Over Life/Distribution/Constant Curve/Points/0/Out Val，\n\n生命周期的结束颜色是Color Over Life/Distribution/Constant Curve/Points/1/Out Val。\n\n### Initial Location\n\nInitial Location控制粒子发射的初始位置方面的属性，通过Start Location/Distribution/Max和Min可以控制粒子发射时的位置分布，如Max，Min都为0时粒子只从一个点发射出来，当设置了值，粒子会在设置的范围内随机发射出来。\n\n### Const Acceleration\n\nConst Acceleration控制粒子的运动的加速度。\n\n### Size By Speed\n\nSize By Speed控制粒子的尺寸随速度的变化，要想粒子的尺寸可以随速度变化需要将Required模块的Emitter/Screen Alignment设置为PSA Velocity。\n\n### Light\n\nLight控制粒子发光，但是似乎只有发生碰撞之后才会发光。\n\n### Actor Collision\n\nActor Collision控制粒子的物理碰撞。\n\n### Orbit\n\nObirt控制粒子的随机运动。\n\n# 三、LOD(细节层次)\n\n默认情况下任何创建出来的粒子系统默认为LOD0等级的细节层次，我们可以在Toolbar中的Add LOD添加细节层次，在LOD中切换细节层次。\n\n![](【UE4】UE4联级粒子系统/Snipaste_2019-11-15_15-41-29.png)\n\nDetails/LOD栏可以设置LOD切换与距离的关系，可以在不同的细节层次下修改Emitter不会对其他的细节层次产生影响，这样就可以很精确的控制各个细节层次了。","source":"_posts/【UE4】UE4联级粒子系统.md","raw":"---\ntitle: 【UE4】UE4联级粒子系统\ndate: 2019-11-17 20:36:30\ntags: UE4\ncategories: 学习笔记\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 一、粒子系统的一些基本概念\n\n## 1.Particle System(粒子系统)\n\n粒子系统如同贴图、模型一样属于UE4的驻留资产，不能单独存在于场景中，必须使用载体依托才能在场景中渲染出来，粒子系统包含粒子特效的所有配置。粒子系统在UE4中表现为如下样子：\n\n![](【UE4】UE4联级粒子系统/Snipaste_2019-11-14_09-41-14.png)\n\n### 创建粒子系统\n\n在内容浏览器中右键选择Particle System可以直接创建粒子系统。\n\n![](【UE4】UE4联级粒子系统/Snipaste_2019-11-14_10-14-27.png)\n\n## 2.Emitter Actor(粒子发射器)\n\n粒子发射器就是粒子系统的载体，粒子发射器承载粒子系统确定粒子系统在场景中的位置坐标等信息。但是似乎UE4没办法直接创建空的粒子发射器，UE4的粒子发射器在将粒子系统拖入场景中时，UE4会自动为该粒子系统创建一个粒子发射器。\n\n## 3.Particle System Component(粒子系统组件)\n\n粒子系统组件是一个包含了粒子系统的蓝图，粒子系统组件可以使用代码逻辑来控制粒子系统。\n\n# 二、Cascade(粒子编辑器)\n\n粒子系统的核心就是粒子编辑器，在粒子编辑器里我们可以创造出琳琅满目的粒子特效。\n\n粒子编辑器包含Toolbar、Emitters、Details、Viewport和Curve Editor等视图。\n\n## 1.ToolBar(工具栏)\n\n![](【UE4】UE4联级粒子系统/Snipaste_2019-11-14_11-50-46.png)\n\n## 2.Emitters\n\nEmitters是用于控制粒子属性的视图，Emitters的基本组成单元就是Emitter(发射器)，这里的Emitter和前面提到的Emitter Actor有一些差异，二者都是粒子发射器，但是Emitter是属于粒子系统内部的发射器，主要用于对粒子系统的某一部分的粒子发射，如爆炸的粒子特效中可以由烟、火光和火花等粒子部分组成，Emitter就是用于发射这些粒子部分的发射器，而Emitter Actor则是用于发射整个粒子系统的发射器。\n\n## 3.Emitter(发射器)\n\n在Emitters视图中每一列就是一个Emitter，一个Emitter控制一个粒子部分。一个Emitter拥有Required和Spawn两个固有组成模块，即每个Emitter被创建出来就拥有Required和Spawn模块，且这两个模块不能删除。\n\nEmitter的执行顺序是自左而右的。\n\n![](【UE4】UE4联级粒子系统/Snipaste_2019-11-14_10-25-52.png)\n\n### 创建Emitter\n\n直接在Emitters视图的空白出右键选择New Particle Sprite Emitter即可。\n\n### 赋值Emitter\n\n选中需要复制的Emitter右键/Emiter/Duplicate Emitter即可。\n\n### 删除Emitter\n\n选中需要删除的Emitter右键/Emitter/Delete Emitter，或直接按delete键。\n\n## 4.Emitter的分类\n\n直接创建的Emitter默认为普通Emitter即没有任何特殊属性的Emitter，要创建具有特殊属性的特殊的Emitter需要修改Emitter的TypeData属性，右键/TypeData选择需要的类型即可修改Emitter的类型。\n\n![](【UE4】UE4联级粒子系统/Snipaste_2019-11-14_10-51-44.png)\n\n### AnimTrail Data\n\n骨骼动画发射器，AnimTrail可以使粒子跟随人物骨骼运动而运动，如下图的跟随人物手臂运动的彩虹带\n\n![](【UE4】UE4联级粒子系统/Snipaste_2019-11-14_10-58-31.png)\n\nAnimTrail是配合UE4的动画系统一起使用的，使用AnimTrail我们需要选择一段动画片段如下图\n\n![](【UE4】UE4联级粒子系统/Snipaste_2019-11-15_15-05-48.png)\n\n发射器会在选定的时间片段内发射粒子，在右侧的Trail栏中选定粒子需要跟随的骨骼和骨骼需要绑定的粒子系统，就可以使粒子跟随着骨骼运动了。\n\n### Beam Data\n\n光束发射器，Beam有一个源点和一个目标点，粒子由源点发射运动到目标点销毁，Beam在粒子由源点运动到目标点的过程中可以设置粒子抖动，使粒子的运动具有抖动效果，如下图的闪电。\n\n![](【UE4】UE4联级粒子系统/Snipaste_2019-11-14_11-14-32.png)\n\nBeam拥有一个专属Module--Beam，在这个模块里可以为Beam添加Source(源点)、Target(目标点)和Noise(噪声)，Noise就是控制粒子抖动的Module，要想粒子出现抖动有几点是必须要做的，即勾选Noise模块的Low Freq/Low Freq Enabled、设置Frequency(噪声点的频率，影响粒子抖动的平滑程度)；Source和Target模块的Suorce Tangent/Distribution/Constant和Target Tangent/Distribution/Constant(影响源点到目标点的粒子抖动的曲率)，要想这两个设置起作用还必须设置Source/Source Tangent Method为User Set，目标点也是一样的设置；还有一点就是要想粒子从源点向目标点运动还需要设置Beam Data模块的Beam/Beam Method为Target。\n\n### GPU Sprites\n\nGPU Sprites是普通粒子的加强版，可以使粒子具有更完美的物理效果，但当对于普通粒子发射器来说更消耗GPU性能。\n\n**矢量场：**\n\n矢量场是GPU粒子独有的属性，GPU粒子在矢量成的控制下可以作出任意轨迹运用，如：\n\n![](【UE4】UE4联级粒子系统/Snipaste_2019-11-14_19-48-16.png)\n\n矢量场有多个属性控制模块\n\n![](【UE4】UE4联级粒子系统/Snipaste_2019-11-14_19-47-55.png)\n\n矢量场默认是看不见的，我们需要在Viewport里勾选View/Vector Fields，使矢量场可见。\n\n### Mesh Data\n\n网格发射器，Mesh可以使粒子使用模型网格，这样发射出来的粒子就是一个个具体的模型，如下图所示。\n\n<img src=\"【UE4】UE4联级粒子系统/Snipaste_2019-11-14_11-10-41.png\" style=\"zoom:50%;\" />\n\n### Ribbon Data\n\n光带发射器，Ribbon可以记录粒子的运行轨迹，并可以对其属性进行编辑，如下图使用粒子运行轨迹制作的光带。\n\n<img src=\"【UE4】UE4联级粒子系统/Snipaste_2019-11-14_11-03-35.png\" style=\"zoom:50%;\" />\n\nRibbon的粒子生成模块不是使用Spawn，而是Spawn PerUnit，由于Spawn是Emitter的固有Module所以无法移除，我们要启用Spawn PerUnit则需要将Spawn Module的Spawn/Distribution/Constant设置为0，达到间接禁用Spawn的效果。这样彩带粒子就是用Spawn PerUnit生成粒子了，想要彩带粒子跟随其他粒子运动我们还需要一个Module--Trail/Source，将Source Module里的Source/Source Mothod设置为PET2SRCM Particle，并且Source Name设置为需要跟随粒子部分的Emitter的名字，这样就可以产生一个跟随其他粒子的彩带了，当然这个彩带粒子是需要设置贴图的，否则尽管生成了，但是却没有渲染。\n\n## 4.Module(模块)\n\n模块用于控制粒子某一方面的属性，在Emitter中每一行就是一个Module，Module的种类很多，这里只列举自己使用过的Module。\n\nUE4Module的执行顺序是自上而下的所以当一个Emitter中有两个相同的Module时，下面的Module会覆盖上面的Module。\n\n### 添加Module\n\n选中需要添加Module的Emitter，右键选择需要的Module即可\n\n### 移除Module\n\n选中需要移除的Module右键/Delete Module，或直接按Delete键。\n\n### 拷贝Module\n\nShift+拖动即可拷贝一个Module到另一个Emitter中。\n\n### Required\n\nRequired控制粒子的显示方面的属性，如粒子贴图，显示模式等。\n\n- Sub UV栏控制贴图的逐帧融合。\n\n### Spawn\n\nSpawn控制粒子的发射方面的属性，如粒子发射量，发射模式等。\n\n- Spawn栏控制粒子持续性的发射；\n- Burst栏控制粒子间歇性的爆炸发射。\n\n### LifeTime\n\nLifeTime控制粒子的声明周期方面的属性。\n\n### Initial Size\n\nInitial Size控制粒子初始尺寸方面的属性。\n\n### Initial Velocity\n\nInitial Velocity控制粒子初始速度方面的属性。\n\n### Color Over Life\n\nColor Over Life控制粒子生命周期内的颜色变化方面的属性。\n\n生命周期的初始颜色是Color Over Life/Distribution/Constant Curve/Points/0/Out Val，\n\n生命周期的结束颜色是Color Over Life/Distribution/Constant Curve/Points/1/Out Val。\n\n### Initial Location\n\nInitial Location控制粒子发射的初始位置方面的属性，通过Start Location/Distribution/Max和Min可以控制粒子发射时的位置分布，如Max，Min都为0时粒子只从一个点发射出来，当设置了值，粒子会在设置的范围内随机发射出来。\n\n### Const Acceleration\n\nConst Acceleration控制粒子的运动的加速度。\n\n### Size By Speed\n\nSize By Speed控制粒子的尺寸随速度的变化，要想粒子的尺寸可以随速度变化需要将Required模块的Emitter/Screen Alignment设置为PSA Velocity。\n\n### Light\n\nLight控制粒子发光，但是似乎只有发生碰撞之后才会发光。\n\n### Actor Collision\n\nActor Collision控制粒子的物理碰撞。\n\n### Orbit\n\nObirt控制粒子的随机运动。\n\n# 三、LOD(细节层次)\n\n默认情况下任何创建出来的粒子系统默认为LOD0等级的细节层次，我们可以在Toolbar中的Add LOD添加细节层次，在LOD中切换细节层次。\n\n![](【UE4】UE4联级粒子系统/Snipaste_2019-11-15_15-41-29.png)\n\nDetails/LOD栏可以设置LOD切换与距离的关系，可以在不同的细节层次下修改Emitter不会对其他的细节层次产生影响，这样就可以很精确的控制各个细节层次了。","slug":"【UE4】UE4联级粒子系统","published":1,"updated":"2021-02-01T13:33:45.196Z","_id":"ckk9hocat0014dwr7cr2d29ag","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h1 id=\"一、粒子系统的一些基本概念\"><a href=\"#一、粒子系统的一些基本概念\" class=\"headerlink\" title=\"一、粒子系统的一些基本概念\"></a>一、粒子系统的一些基本概念</h1><h2 id=\"1-Particle-System-粒子系统\"><a href=\"#1-Particle-System-粒子系统\" class=\"headerlink\" title=\"1.Particle System(粒子系统)\"></a>1.Particle System(粒子系统)</h2><p>粒子系统如同贴图、模型一样属于UE4的驻留资产，不能单独存在于场景中，必须使用载体依托才能在场景中渲染出来，粒子系统包含粒子特效的所有配置。粒子系统在UE4中表现为如下样子：</p>\n<p><img src=\"/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-14_09-41-14.png\"></p>\n<h3 id=\"创建粒子系统\"><a href=\"#创建粒子系统\" class=\"headerlink\" title=\"创建粒子系统\"></a>创建粒子系统</h3><p>在内容浏览器中右键选择Particle System可以直接创建粒子系统。</p>\n<p><img src=\"/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-14_10-14-27.png\"></p>\n<h2 id=\"2-Emitter-Actor-粒子发射器\"><a href=\"#2-Emitter-Actor-粒子发射器\" class=\"headerlink\" title=\"2.Emitter Actor(粒子发射器)\"></a>2.Emitter Actor(粒子发射器)</h2><p>粒子发射器就是粒子系统的载体，粒子发射器承载粒子系统确定粒子系统在场景中的位置坐标等信息。但是似乎UE4没办法直接创建空的粒子发射器，UE4的粒子发射器在将粒子系统拖入场景中时，UE4会自动为该粒子系统创建一个粒子发射器。</p>\n<h2 id=\"3-Particle-System-Component-粒子系统组件\"><a href=\"#3-Particle-System-Component-粒子系统组件\" class=\"headerlink\" title=\"3.Particle System Component(粒子系统组件)\"></a>3.Particle System Component(粒子系统组件)</h2><p>粒子系统组件是一个包含了粒子系统的蓝图，粒子系统组件可以使用代码逻辑来控制粒子系统。</p>\n<h1 id=\"二、Cascade-粒子编辑器\"><a href=\"#二、Cascade-粒子编辑器\" class=\"headerlink\" title=\"二、Cascade(粒子编辑器)\"></a>二、Cascade(粒子编辑器)</h1><p>粒子系统的核心就是粒子编辑器，在粒子编辑器里我们可以创造出琳琅满目的粒子特效。</p>\n<p>粒子编辑器包含Toolbar、Emitters、Details、Viewport和Curve Editor等视图。</p>\n<h2 id=\"1-ToolBar-工具栏\"><a href=\"#1-ToolBar-工具栏\" class=\"headerlink\" title=\"1.ToolBar(工具栏)\"></a>1.ToolBar(工具栏)</h2><p><img src=\"/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-14_11-50-46.png\"></p>\n<h2 id=\"2-Emitters\"><a href=\"#2-Emitters\" class=\"headerlink\" title=\"2.Emitters\"></a>2.Emitters</h2><p>Emitters是用于控制粒子属性的视图，Emitters的基本组成单元就是Emitter(发射器)，这里的Emitter和前面提到的Emitter Actor有一些差异，二者都是粒子发射器，但是Emitter是属于粒子系统内部的发射器，主要用于对粒子系统的某一部分的粒子发射，如爆炸的粒子特效中可以由烟、火光和火花等粒子部分组成，Emitter就是用于发射这些粒子部分的发射器，而Emitter Actor则是用于发射整个粒子系统的发射器。</p>\n<h2 id=\"3-Emitter-发射器\"><a href=\"#3-Emitter-发射器\" class=\"headerlink\" title=\"3.Emitter(发射器)\"></a>3.Emitter(发射器)</h2><p>在Emitters视图中每一列就是一个Emitter，一个Emitter控制一个粒子部分。一个Emitter拥有Required和Spawn两个固有组成模块，即每个Emitter被创建出来就拥有Required和Spawn模块，且这两个模块不能删除。</p>\n<p>Emitter的执行顺序是自左而右的。</p>\n<p><img src=\"/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-14_10-25-52.png\"></p>\n<h3 id=\"创建Emitter\"><a href=\"#创建Emitter\" class=\"headerlink\" title=\"创建Emitter\"></a>创建Emitter</h3><p>直接在Emitters视图的空白出右键选择New Particle Sprite Emitter即可。</p>\n<h3 id=\"赋值Emitter\"><a href=\"#赋值Emitter\" class=\"headerlink\" title=\"赋值Emitter\"></a>赋值Emitter</h3><p>选中需要复制的Emitter右键/Emiter/Duplicate Emitter即可。</p>\n<h3 id=\"删除Emitter\"><a href=\"#删除Emitter\" class=\"headerlink\" title=\"删除Emitter\"></a>删除Emitter</h3><p>选中需要删除的Emitter右键/Emitter/Delete Emitter，或直接按delete键。</p>\n<h2 id=\"4-Emitter的分类\"><a href=\"#4-Emitter的分类\" class=\"headerlink\" title=\"4.Emitter的分类\"></a>4.Emitter的分类</h2><p>直接创建的Emitter默认为普通Emitter即没有任何特殊属性的Emitter，要创建具有特殊属性的特殊的Emitter需要修改Emitter的TypeData属性，右键/TypeData选择需要的类型即可修改Emitter的类型。</p>\n<p><img src=\"/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-14_10-51-44.png\"></p>\n<h3 id=\"AnimTrail-Data\"><a href=\"#AnimTrail-Data\" class=\"headerlink\" title=\"AnimTrail Data\"></a>AnimTrail Data</h3><p>骨骼动画发射器，AnimTrail可以使粒子跟随人物骨骼运动而运动，如下图的跟随人物手臂运动的彩虹带</p>\n<p><img src=\"/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-14_10-58-31.png\"></p>\n<p>AnimTrail是配合UE4的动画系统一起使用的，使用AnimTrail我们需要选择一段动画片段如下图</p>\n<p><img src=\"/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-15_15-05-48.png\"></p>\n<p>发射器会在选定的时间片段内发射粒子，在右侧的Trail栏中选定粒子需要跟随的骨骼和骨骼需要绑定的粒子系统，就可以使粒子跟随着骨骼运动了。</p>\n<h3 id=\"Beam-Data\"><a href=\"#Beam-Data\" class=\"headerlink\" title=\"Beam Data\"></a>Beam Data</h3><p>光束发射器，Beam有一个源点和一个目标点，粒子由源点发射运动到目标点销毁，Beam在粒子由源点运动到目标点的过程中可以设置粒子抖动，使粒子的运动具有抖动效果，如下图的闪电。</p>\n<p><img src=\"/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-14_11-14-32.png\"></p>\n<p>Beam拥有一个专属Module–Beam，在这个模块里可以为Beam添加Source(源点)、Target(目标点)和Noise(噪声)，Noise就是控制粒子抖动的Module，要想粒子出现抖动有几点是必须要做的，即勾选Noise模块的Low Freq/Low Freq Enabled、设置Frequency(噪声点的频率，影响粒子抖动的平滑程度)；Source和Target模块的Suorce Tangent/Distribution/Constant和Target Tangent/Distribution/Constant(影响源点到目标点的粒子抖动的曲率)，要想这两个设置起作用还必须设置Source/Source Tangent Method为User Set，目标点也是一样的设置；还有一点就是要想粒子从源点向目标点运动还需要设置Beam Data模块的Beam/Beam Method为Target。</p>\n<h3 id=\"GPU-Sprites\"><a href=\"#GPU-Sprites\" class=\"headerlink\" title=\"GPU Sprites\"></a>GPU Sprites</h3><p>GPU Sprites是普通粒子的加强版，可以使粒子具有更完美的物理效果，但当对于普通粒子发射器来说更消耗GPU性能。</p>\n<p><strong>矢量场：</strong></p>\n<p>矢量场是GPU粒子独有的属性，GPU粒子在矢量成的控制下可以作出任意轨迹运用，如：</p>\n<p><img src=\"/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-14_19-48-16.png\"></p>\n<p>矢量场有多个属性控制模块</p>\n<p><img src=\"/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-14_19-47-55.png\"></p>\n<p>矢量场默认是看不见的，我们需要在Viewport里勾选View/Vector Fields，使矢量场可见。</p>\n<h3 id=\"Mesh-Data\"><a href=\"#Mesh-Data\" class=\"headerlink\" title=\"Mesh Data\"></a>Mesh Data</h3><p>网格发射器，Mesh可以使粒子使用模型网格，这样发射出来的粒子就是一个个具体的模型，如下图所示。</p>\n<img src=\"/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-14_11-10-41.png\" style=\"zoom:50%;\">\n\n<h3 id=\"Ribbon-Data\"><a href=\"#Ribbon-Data\" class=\"headerlink\" title=\"Ribbon Data\"></a>Ribbon Data</h3><p>光带发射器，Ribbon可以记录粒子的运行轨迹，并可以对其属性进行编辑，如下图使用粒子运行轨迹制作的光带。</p>\n<img src=\"/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-14_11-03-35.png\" style=\"zoom:50%;\">\n\n<p>Ribbon的粒子生成模块不是使用Spawn，而是Spawn PerUnit，由于Spawn是Emitter的固有Module所以无法移除，我们要启用Spawn PerUnit则需要将Spawn Module的Spawn/Distribution/Constant设置为0，达到间接禁用Spawn的效果。这样彩带粒子就是用Spawn PerUnit生成粒子了，想要彩带粒子跟随其他粒子运动我们还需要一个Module–Trail/Source，将Source Module里的Source/Source Mothod设置为PET2SRCM Particle，并且Source Name设置为需要跟随粒子部分的Emitter的名字，这样就可以产生一个跟随其他粒子的彩带了，当然这个彩带粒子是需要设置贴图的，否则尽管生成了，但是却没有渲染。</p>\n<h2 id=\"4-Module-模块\"><a href=\"#4-Module-模块\" class=\"headerlink\" title=\"4.Module(模块)\"></a>4.Module(模块)</h2><p>模块用于控制粒子某一方面的属性，在Emitter中每一行就是一个Module，Module的种类很多，这里只列举自己使用过的Module。</p>\n<p>UE4Module的执行顺序是自上而下的所以当一个Emitter中有两个相同的Module时，下面的Module会覆盖上面的Module。</p>\n<h3 id=\"添加Module\"><a href=\"#添加Module\" class=\"headerlink\" title=\"添加Module\"></a>添加Module</h3><p>选中需要添加Module的Emitter，右键选择需要的Module即可</p>\n<h3 id=\"移除Module\"><a href=\"#移除Module\" class=\"headerlink\" title=\"移除Module\"></a>移除Module</h3><p>选中需要移除的Module右键/Delete Module，或直接按Delete键。</p>\n<h3 id=\"拷贝Module\"><a href=\"#拷贝Module\" class=\"headerlink\" title=\"拷贝Module\"></a>拷贝Module</h3><p>Shift+拖动即可拷贝一个Module到另一个Emitter中。</p>\n<h3 id=\"Required\"><a href=\"#Required\" class=\"headerlink\" title=\"Required\"></a>Required</h3><p>Required控制粒子的显示方面的属性，如粒子贴图，显示模式等。</p>\n<ul>\n<li>Sub UV栏控制贴图的逐帧融合。</li>\n</ul>\n<h3 id=\"Spawn\"><a href=\"#Spawn\" class=\"headerlink\" title=\"Spawn\"></a>Spawn</h3><p>Spawn控制粒子的发射方面的属性，如粒子发射量，发射模式等。</p>\n<ul>\n<li>Spawn栏控制粒子持续性的发射；</li>\n<li>Burst栏控制粒子间歇性的爆炸发射。</li>\n</ul>\n<h3 id=\"LifeTime\"><a href=\"#LifeTime\" class=\"headerlink\" title=\"LifeTime\"></a>LifeTime</h3><p>LifeTime控制粒子的声明周期方面的属性。</p>\n<h3 id=\"Initial-Size\"><a href=\"#Initial-Size\" class=\"headerlink\" title=\"Initial Size\"></a>Initial Size</h3><p>Initial Size控制粒子初始尺寸方面的属性。</p>\n<h3 id=\"Initial-Velocity\"><a href=\"#Initial-Velocity\" class=\"headerlink\" title=\"Initial Velocity\"></a>Initial Velocity</h3><p>Initial Velocity控制粒子初始速度方面的属性。</p>\n<h3 id=\"Color-Over-Life\"><a href=\"#Color-Over-Life\" class=\"headerlink\" title=\"Color Over Life\"></a>Color Over Life</h3><p>Color Over Life控制粒子生命周期内的颜色变化方面的属性。</p>\n<p>生命周期的初始颜色是Color Over Life/Distribution/Constant Curve/Points/0/Out Val，</p>\n<p>生命周期的结束颜色是Color Over Life/Distribution/Constant Curve/Points/1/Out Val。</p>\n<h3 id=\"Initial-Location\"><a href=\"#Initial-Location\" class=\"headerlink\" title=\"Initial Location\"></a>Initial Location</h3><p>Initial Location控制粒子发射的初始位置方面的属性，通过Start Location/Distribution/Max和Min可以控制粒子发射时的位置分布，如Max，Min都为0时粒子只从一个点发射出来，当设置了值，粒子会在设置的范围内随机发射出来。</p>\n<h3 id=\"Const-Acceleration\"><a href=\"#Const-Acceleration\" class=\"headerlink\" title=\"Const Acceleration\"></a>Const Acceleration</h3><p>Const Acceleration控制粒子的运动的加速度。</p>\n<h3 id=\"Size-By-Speed\"><a href=\"#Size-By-Speed\" class=\"headerlink\" title=\"Size By Speed\"></a>Size By Speed</h3><p>Size By Speed控制粒子的尺寸随速度的变化，要想粒子的尺寸可以随速度变化需要将Required模块的Emitter/Screen Alignment设置为PSA Velocity。</p>\n<h3 id=\"Light\"><a href=\"#Light\" class=\"headerlink\" title=\"Light\"></a>Light</h3><p>Light控制粒子发光，但是似乎只有发生碰撞之后才会发光。</p>\n<h3 id=\"Actor-Collision\"><a href=\"#Actor-Collision\" class=\"headerlink\" title=\"Actor Collision\"></a>Actor Collision</h3><p>Actor Collision控制粒子的物理碰撞。</p>\n<h3 id=\"Orbit\"><a href=\"#Orbit\" class=\"headerlink\" title=\"Orbit\"></a>Orbit</h3><p>Obirt控制粒子的随机运动。</p>\n<h1 id=\"三、LOD-细节层次\"><a href=\"#三、LOD-细节层次\" class=\"headerlink\" title=\"三、LOD(细节层次)\"></a>三、LOD(细节层次)</h1><p>默认情况下任何创建出来的粒子系统默认为LOD0等级的细节层次，我们可以在Toolbar中的Add LOD添加细节层次，在LOD中切换细节层次。</p>\n<p><img src=\"/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-15_15-41-29.png\"></p>\n<p>Details/LOD栏可以设置LOD切换与距离的关系，可以在不同的细节层次下修改Emitter不会对其他的细节层次产生影响，这样就可以很精确的控制各个细节层次了。</p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h1 id=\"一、粒子系统的一些基本概念\"><a href=\"#一、粒子系统的一些基本概念\" class=\"headerlink\" title=\"一、粒子系统的一些基本概念\"></a>一、粒子系统的一些基本概念</h1><h2 id=\"1-Particle-System-粒子系统\"><a href=\"#1-Particle-System-粒子系统\" class=\"headerlink\" title=\"1.Particle System(粒子系统)\"></a>1.Particle System(粒子系统)</h2><p>粒子系统如同贴图、模型一样属于UE4的驻留资产，不能单独存在于场景中，必须使用载体依托才能在场景中渲染出来，粒子系统包含粒子特效的所有配置。粒子系统在UE4中表现为如下样子：</p>\n<p><img src=\"/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-14_09-41-14.png\"></p>\n<h3 id=\"创建粒子系统\"><a href=\"#创建粒子系统\" class=\"headerlink\" title=\"创建粒子系统\"></a>创建粒子系统</h3><p>在内容浏览器中右键选择Particle System可以直接创建粒子系统。</p>\n<p><img src=\"/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-14_10-14-27.png\"></p>\n<h2 id=\"2-Emitter-Actor-粒子发射器\"><a href=\"#2-Emitter-Actor-粒子发射器\" class=\"headerlink\" title=\"2.Emitter Actor(粒子发射器)\"></a>2.Emitter Actor(粒子发射器)</h2><p>粒子发射器就是粒子系统的载体，粒子发射器承载粒子系统确定粒子系统在场景中的位置坐标等信息。但是似乎UE4没办法直接创建空的粒子发射器，UE4的粒子发射器在将粒子系统拖入场景中时，UE4会自动为该粒子系统创建一个粒子发射器。</p>\n<h2 id=\"3-Particle-System-Component-粒子系统组件\"><a href=\"#3-Particle-System-Component-粒子系统组件\" class=\"headerlink\" title=\"3.Particle System Component(粒子系统组件)\"></a>3.Particle System Component(粒子系统组件)</h2><p>粒子系统组件是一个包含了粒子系统的蓝图，粒子系统组件可以使用代码逻辑来控制粒子系统。</p>\n<h1 id=\"二、Cascade-粒子编辑器\"><a href=\"#二、Cascade-粒子编辑器\" class=\"headerlink\" title=\"二、Cascade(粒子编辑器)\"></a>二、Cascade(粒子编辑器)</h1><p>粒子系统的核心就是粒子编辑器，在粒子编辑器里我们可以创造出琳琅满目的粒子特效。</p>\n<p>粒子编辑器包含Toolbar、Emitters、Details、Viewport和Curve Editor等视图。</p>\n<h2 id=\"1-ToolBar-工具栏\"><a href=\"#1-ToolBar-工具栏\" class=\"headerlink\" title=\"1.ToolBar(工具栏)\"></a>1.ToolBar(工具栏)</h2><p><img src=\"/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-14_11-50-46.png\"></p>\n<h2 id=\"2-Emitters\"><a href=\"#2-Emitters\" class=\"headerlink\" title=\"2.Emitters\"></a>2.Emitters</h2><p>Emitters是用于控制粒子属性的视图，Emitters的基本组成单元就是Emitter(发射器)，这里的Emitter和前面提到的Emitter Actor有一些差异，二者都是粒子发射器，但是Emitter是属于粒子系统内部的发射器，主要用于对粒子系统的某一部分的粒子发射，如爆炸的粒子特效中可以由烟、火光和火花等粒子部分组成，Emitter就是用于发射这些粒子部分的发射器，而Emitter Actor则是用于发射整个粒子系统的发射器。</p>\n<h2 id=\"3-Emitter-发射器\"><a href=\"#3-Emitter-发射器\" class=\"headerlink\" title=\"3.Emitter(发射器)\"></a>3.Emitter(发射器)</h2><p>在Emitters视图中每一列就是一个Emitter，一个Emitter控制一个粒子部分。一个Emitter拥有Required和Spawn两个固有组成模块，即每个Emitter被创建出来就拥有Required和Spawn模块，且这两个模块不能删除。</p>\n<p>Emitter的执行顺序是自左而右的。</p>\n<p><img src=\"/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-14_10-25-52.png\"></p>\n<h3 id=\"创建Emitter\"><a href=\"#创建Emitter\" class=\"headerlink\" title=\"创建Emitter\"></a>创建Emitter</h3><p>直接在Emitters视图的空白出右键选择New Particle Sprite Emitter即可。</p>\n<h3 id=\"赋值Emitter\"><a href=\"#赋值Emitter\" class=\"headerlink\" title=\"赋值Emitter\"></a>赋值Emitter</h3><p>选中需要复制的Emitter右键/Emiter/Duplicate Emitter即可。</p>\n<h3 id=\"删除Emitter\"><a href=\"#删除Emitter\" class=\"headerlink\" title=\"删除Emitter\"></a>删除Emitter</h3><p>选中需要删除的Emitter右键/Emitter/Delete Emitter，或直接按delete键。</p>\n<h2 id=\"4-Emitter的分类\"><a href=\"#4-Emitter的分类\" class=\"headerlink\" title=\"4.Emitter的分类\"></a>4.Emitter的分类</h2><p>直接创建的Emitter默认为普通Emitter即没有任何特殊属性的Emitter，要创建具有特殊属性的特殊的Emitter需要修改Emitter的TypeData属性，右键/TypeData选择需要的类型即可修改Emitter的类型。</p>\n<p><img src=\"/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-14_10-51-44.png\"></p>\n<h3 id=\"AnimTrail-Data\"><a href=\"#AnimTrail-Data\" class=\"headerlink\" title=\"AnimTrail Data\"></a>AnimTrail Data</h3><p>骨骼动画发射器，AnimTrail可以使粒子跟随人物骨骼运动而运动，如下图的跟随人物手臂运动的彩虹带</p>\n<p><img src=\"/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-14_10-58-31.png\"></p>\n<p>AnimTrail是配合UE4的动画系统一起使用的，使用AnimTrail我们需要选择一段动画片段如下图</p>\n<p><img src=\"/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-15_15-05-48.png\"></p>\n<p>发射器会在选定的时间片段内发射粒子，在右侧的Trail栏中选定粒子需要跟随的骨骼和骨骼需要绑定的粒子系统，就可以使粒子跟随着骨骼运动了。</p>\n<h3 id=\"Beam-Data\"><a href=\"#Beam-Data\" class=\"headerlink\" title=\"Beam Data\"></a>Beam Data</h3><p>光束发射器，Beam有一个源点和一个目标点，粒子由源点发射运动到目标点销毁，Beam在粒子由源点运动到目标点的过程中可以设置粒子抖动，使粒子的运动具有抖动效果，如下图的闪电。</p>\n<p><img src=\"/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-14_11-14-32.png\"></p>\n<p>Beam拥有一个专属Module–Beam，在这个模块里可以为Beam添加Source(源点)、Target(目标点)和Noise(噪声)，Noise就是控制粒子抖动的Module，要想粒子出现抖动有几点是必须要做的，即勾选Noise模块的Low Freq/Low Freq Enabled、设置Frequency(噪声点的频率，影响粒子抖动的平滑程度)；Source和Target模块的Suorce Tangent/Distribution/Constant和Target Tangent/Distribution/Constant(影响源点到目标点的粒子抖动的曲率)，要想这两个设置起作用还必须设置Source/Source Tangent Method为User Set，目标点也是一样的设置；还有一点就是要想粒子从源点向目标点运动还需要设置Beam Data模块的Beam/Beam Method为Target。</p>\n<h3 id=\"GPU-Sprites\"><a href=\"#GPU-Sprites\" class=\"headerlink\" title=\"GPU Sprites\"></a>GPU Sprites</h3><p>GPU Sprites是普通粒子的加强版，可以使粒子具有更完美的物理效果，但当对于普通粒子发射器来说更消耗GPU性能。</p>\n<p><strong>矢量场：</strong></p>\n<p>矢量场是GPU粒子独有的属性，GPU粒子在矢量成的控制下可以作出任意轨迹运用，如：</p>\n<p><img src=\"/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-14_19-48-16.png\"></p>\n<p>矢量场有多个属性控制模块</p>\n<p><img src=\"/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-14_19-47-55.png\"></p>\n<p>矢量场默认是看不见的，我们需要在Viewport里勾选View/Vector Fields，使矢量场可见。</p>\n<h3 id=\"Mesh-Data\"><a href=\"#Mesh-Data\" class=\"headerlink\" title=\"Mesh Data\"></a>Mesh Data</h3><p>网格发射器，Mesh可以使粒子使用模型网格，这样发射出来的粒子就是一个个具体的模型，如下图所示。</p>\n<img src=\"/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-14_11-10-41.png\" style=\"zoom:50%;\">\n\n<h3 id=\"Ribbon-Data\"><a href=\"#Ribbon-Data\" class=\"headerlink\" title=\"Ribbon Data\"></a>Ribbon Data</h3><p>光带发射器，Ribbon可以记录粒子的运行轨迹，并可以对其属性进行编辑，如下图使用粒子运行轨迹制作的光带。</p>\n<img src=\"/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-14_11-03-35.png\" style=\"zoom:50%;\">\n\n<p>Ribbon的粒子生成模块不是使用Spawn，而是Spawn PerUnit，由于Spawn是Emitter的固有Module所以无法移除，我们要启用Spawn PerUnit则需要将Spawn Module的Spawn/Distribution/Constant设置为0，达到间接禁用Spawn的效果。这样彩带粒子就是用Spawn PerUnit生成粒子了，想要彩带粒子跟随其他粒子运动我们还需要一个Module–Trail/Source，将Source Module里的Source/Source Mothod设置为PET2SRCM Particle，并且Source Name设置为需要跟随粒子部分的Emitter的名字，这样就可以产生一个跟随其他粒子的彩带了，当然这个彩带粒子是需要设置贴图的，否则尽管生成了，但是却没有渲染。</p>\n<h2 id=\"4-Module-模块\"><a href=\"#4-Module-模块\" class=\"headerlink\" title=\"4.Module(模块)\"></a>4.Module(模块)</h2><p>模块用于控制粒子某一方面的属性，在Emitter中每一行就是一个Module，Module的种类很多，这里只列举自己使用过的Module。</p>\n<p>UE4Module的执行顺序是自上而下的所以当一个Emitter中有两个相同的Module时，下面的Module会覆盖上面的Module。</p>\n<h3 id=\"添加Module\"><a href=\"#添加Module\" class=\"headerlink\" title=\"添加Module\"></a>添加Module</h3><p>选中需要添加Module的Emitter，右键选择需要的Module即可</p>\n<h3 id=\"移除Module\"><a href=\"#移除Module\" class=\"headerlink\" title=\"移除Module\"></a>移除Module</h3><p>选中需要移除的Module右键/Delete Module，或直接按Delete键。</p>\n<h3 id=\"拷贝Module\"><a href=\"#拷贝Module\" class=\"headerlink\" title=\"拷贝Module\"></a>拷贝Module</h3><p>Shift+拖动即可拷贝一个Module到另一个Emitter中。</p>\n<h3 id=\"Required\"><a href=\"#Required\" class=\"headerlink\" title=\"Required\"></a>Required</h3><p>Required控制粒子的显示方面的属性，如粒子贴图，显示模式等。</p>\n<ul>\n<li>Sub UV栏控制贴图的逐帧融合。</li>\n</ul>\n<h3 id=\"Spawn\"><a href=\"#Spawn\" class=\"headerlink\" title=\"Spawn\"></a>Spawn</h3><p>Spawn控制粒子的发射方面的属性，如粒子发射量，发射模式等。</p>\n<ul>\n<li>Spawn栏控制粒子持续性的发射；</li>\n<li>Burst栏控制粒子间歇性的爆炸发射。</li>\n</ul>\n<h3 id=\"LifeTime\"><a href=\"#LifeTime\" class=\"headerlink\" title=\"LifeTime\"></a>LifeTime</h3><p>LifeTime控制粒子的声明周期方面的属性。</p>\n<h3 id=\"Initial-Size\"><a href=\"#Initial-Size\" class=\"headerlink\" title=\"Initial Size\"></a>Initial Size</h3><p>Initial Size控制粒子初始尺寸方面的属性。</p>\n<h3 id=\"Initial-Velocity\"><a href=\"#Initial-Velocity\" class=\"headerlink\" title=\"Initial Velocity\"></a>Initial Velocity</h3><p>Initial Velocity控制粒子初始速度方面的属性。</p>\n<h3 id=\"Color-Over-Life\"><a href=\"#Color-Over-Life\" class=\"headerlink\" title=\"Color Over Life\"></a>Color Over Life</h3><p>Color Over Life控制粒子生命周期内的颜色变化方面的属性。</p>\n<p>生命周期的初始颜色是Color Over Life/Distribution/Constant Curve/Points/0/Out Val，</p>\n<p>生命周期的结束颜色是Color Over Life/Distribution/Constant Curve/Points/1/Out Val。</p>\n<h3 id=\"Initial-Location\"><a href=\"#Initial-Location\" class=\"headerlink\" title=\"Initial Location\"></a>Initial Location</h3><p>Initial Location控制粒子发射的初始位置方面的属性，通过Start Location/Distribution/Max和Min可以控制粒子发射时的位置分布，如Max，Min都为0时粒子只从一个点发射出来，当设置了值，粒子会在设置的范围内随机发射出来。</p>\n<h3 id=\"Const-Acceleration\"><a href=\"#Const-Acceleration\" class=\"headerlink\" title=\"Const Acceleration\"></a>Const Acceleration</h3><p>Const Acceleration控制粒子的运动的加速度。</p>\n<h3 id=\"Size-By-Speed\"><a href=\"#Size-By-Speed\" class=\"headerlink\" title=\"Size By Speed\"></a>Size By Speed</h3><p>Size By Speed控制粒子的尺寸随速度的变化，要想粒子的尺寸可以随速度变化需要将Required模块的Emitter/Screen Alignment设置为PSA Velocity。</p>\n<h3 id=\"Light\"><a href=\"#Light\" class=\"headerlink\" title=\"Light\"></a>Light</h3><p>Light控制粒子发光，但是似乎只有发生碰撞之后才会发光。</p>\n<h3 id=\"Actor-Collision\"><a href=\"#Actor-Collision\" class=\"headerlink\" title=\"Actor Collision\"></a>Actor Collision</h3><p>Actor Collision控制粒子的物理碰撞。</p>\n<h3 id=\"Orbit\"><a href=\"#Orbit\" class=\"headerlink\" title=\"Orbit\"></a>Orbit</h3><p>Obirt控制粒子的随机运动。</p>\n<h1 id=\"三、LOD-细节层次\"><a href=\"#三、LOD-细节层次\" class=\"headerlink\" title=\"三、LOD(细节层次)\"></a>三、LOD(细节层次)</h1><p>默认情况下任何创建出来的粒子系统默认为LOD0等级的细节层次，我们可以在Toolbar中的Add LOD添加细节层次，在LOD中切换细节层次。</p>\n<p><img src=\"/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-15_15-41-29.png\"></p>\n<p>Details/LOD栏可以设置LOD切换与距离的关系，可以在不同的细节层次下修改Emitter不会对其他的细节层次产生影响，这样就可以很精确的控制各个细节层次了。</p>\n"},{"title":"【UE4】UE4读写Json文件","date":"2019-11-06T13:10:15.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 一、准备工作\n\n如果我们想要在UE4中读写Json文件，那么我们必须使UE4包含<font color=red>Json和JsonUtilities</font>这两个模块，那么UE4如何添加模块呢？\n\nUE4添加预定义模块的方法很简单，我只需打开工程的.Biuld.cs文件，在其中的`PublicDependencyModuleNames.AddRange()`函数中追加两个模块即可，如：\n\n```C++\nusing UnrealBuildTool;\n\npublic class DATA_sys : ModuleRules\n{\n\tpublic DATA_sys(ReadOnlyTargetRules Target) : base(Target)\n\t{\n\t\tPCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;\n\t\n\t\tPublicDependencyModuleNames.AddRange(new string[] { \"Core\", \"CoreUObject\", \"Engine\", \"InputCore\" ,\"Json\",\"JsonUtilities\"});\n\n\t\tPrivateDependencyModuleNames.AddRange(new string[] {  });\n\n\t\t// Uncomment if you are using Slate UI\n\t\t// PrivateDependencyModuleNames.AddRange(new string[] { \"Slate\", \"SlateCore\" });\n\t\t\n\t\t// Uncomment if you are using online features\n\t\t// PrivateDependencyModuleNames.Add(\"OnlineSubsystem\");\n\n\t\t// To include OnlineSubsystemSteam, add it to the plugins section in your uproject file with the Enabled attribute set to true\n\t}\n}\n```\n\n如果我们要添加自定义模块就有点麻烦了，当然这里就不赘述了。\n\n包含这两个模块之后，我们还需要用到<font color=red> Json.h、JsonObject.h、JsonSerializer.h</font>三个头文件，其中JsonSerializer.h是用于Json序列化与反序列化用的。\n\n至此我们就可以使用UE4自带的工具进行Json文件的读写工作了。\n\n# 二、Json文件写\n\n## 1.非序列化写入\n\n```C++\nvoid AMysqlJsonCpp::CreatJson()\n{\n\tFString filePath = FPaths::GameContentDir() + TEXT(\"MysqlConfig/Connect.json\");\n\tFString jsonStr;\n\tTSharedRef<TJsonWriter<>> jsonWriter = TJsonWriterFactory<>::Create(&jsonStr);\n\tjsonWriter->WriteObjectStart();\n\tjsonWriter->WriteValue(TEXT(\"server\"), TEXT(\"127.0.0.1\"));\n\tjsonWriter->WriteObjectEnd();\n\tjsonWriter->Close();\n\tFFileHelper::SaveStringToFile(jsonStr, *filePath);\n}\n```\n\n- `FPaths::GameContentDir()`返回当前工程目录的Content文件夹的路径，FPaths为UE4的路径读写工具；\n\n- `FString jsonStr`的作用是用于关联UE4的Json写工具TJsonWriter<>，作为输入流载体，且JsonStr必须是FString类型；\n\n- `TShareRef<T>`是UE4自身的共享指针类型；\n\n- `TJsonWriter<>`是UE4专门用于写Json的模板类，其中类型参数通常为TCHAR，其中有多个方法供开发者使用：\n\n  | 函数                                          | 作用                 |\n  | --------------------------------------------- | -------------------- |\n  | Close()                                       | 关闭写工具           |\n  | WriterArrayStart()                            | 开始一个Json数组     |\n  | WriterArrayEnd()                              | 结束一个Json数组     |\n  | WriterNull(FString)                           | 为一个键写一个空值   |\n  | WriterObjectStart()                           | 开始一个Json对象     |\n  | WriterObjectEnd()                             | 结束一个Json对象     |\n  | WriterValue(FString,FString/int32/float/bool) | 向Json文件写入键值对 |\n\n  \n\n- `TJsonWriterFactory<>::Create(FString)`是UE4用来生成Json写工具TJsonWriter<>的类，TJsonFactory<>只有一个方法就是Create；\n\n- `FFileHelper`UE4的文件读写工具，方法`SaveStringToFile(TJsonWriter*,FString*)`函数的作用就是将Json写工具中的Json数据写到FString字符串中的路径文件中。\n\n使用非序列化方式写入Json时，写入方式需要严格按照Json的语法格式来做，如最开始需要使用WriterObjectStart()创建一个根前括号，即Json语法中最外面一层的`{`，所有写入结束后需要使用WriterObjectEnd()声明根对象结束，即Json语法中的最外面一层的`}`，同理数组也需要按对象一样的方法进行处理。如此才能写入一个结构完整的Json文本。\n\n## 2.序列化写入\n\n```c++\nvoid AMyActor::Test()\n{\n\tTSharedPtr<FJsonObject> rootObj = MakeShareable(new FJsonObject());\n\trootObj->SetStringField(\"root\", \"1\");\n\tTArray<TSharedPtr<FJsonValue>> arrValue;\n\tTSharedPtr<FJsonValueString> tmp = MakeShareable(new FJsonValueString(\"array\"));\n\tarrValue.Add(tmp);\n\trootObj->SetArrayField(\"array\", arrValue);\n\tFString filePath = FPaths::GameContentDir() + TEXT(\"MysqlConfig/text.json\");\n\tFString jsonStr;\n\tTSharedRef<TJsonWriter<TCHAR>> jsonWriter = TJsonWriterFactory<TCHAR>::Create(&jsonStr);\n\tFJsonSerializer::Serialize(rootObj.ToSharedRef(), jsonWriter);\n\tFFileHelper::SaveStringToFile(jsonStr, *filePath);\n\tUE_LOG(LogTemp, Error, TEXT(\"%s\"),*filePath);\n}\n```\n\n序列化的写入方式则无需考虑按Json的语法结构进行写入，序列化的写入方式是通过一个FJsonObject对象进行Json文本的写入。\n\n- 首先使用MakeSahreable()函数创建一个FJsonObject对象并使用共享指针引用。\n- 然后我们便可以使用FJsonObject对象中的`SetArrayField(FString,TArray<FSharePtr<FJsonValue>>)`、`SetBoolFiled(FString,bool)`、`SetNumberField(FString,Number)`、`SetStringField(FString,FString)`、`SetObjectField(FString,TSharePtr<FJsonObject>)`、`SetField(FString,TSharePtr<FJsonValue>)`等函数向FJsonObject对象中写分别入数组、bool值、数字、字符串、对象和Json键值对。其中数组的写入较为麻烦，我们需要先向创建Json键值对类型共享指针的TArray数组`TArray<TSharePtr<FJsonValue>>`。并向数组中添加指向FJsonValue对象的共享指针后然后才可以使用SetArrayField进行数组的Json文本写入。\n- 我们序列化写好的FJsonObject对象需要转化为FString字符串才能向文本中写入数据，FJsonObject转化为FString输入流的方式就是`FJsonSerializer::Serialize(TSharePtr<FJsonObject>.ToShareRef(),TSharePtr<FJsonWriter>)`;其中`TSharePtr<FJsonWriter>`和非序列化写入一样需要绑定一个FString作为输入流载体。\n- 最后就可以通过FFileHelper::SaveStringToFile(FString,\\*FString)，前一个FString是输入流载体，后一个\\*FString是Json文件的存储路径。\n\n# 三、Json文件读\n\n## 1.反序列化读取\n\n\n\n```C++\nTArray<FName> AMysqlJsonCpp::ReadMysqlConnectConfig()\n{\n\tFString filePath = FPaths::GameContentDir() + TEXT(\"MysqlConfig/Connect.json\");\n\tif (FPaths::FileExists(filePath))\n\t{\n\t\tFString server;\n\t\tFString dbName;\n\t\tFString userId;\n\t\tFString passwd;\n\t\tTArray<FName> connectConfig;\n\t\tFString fileStr;\n\t\tFFileHelper::LoadFileToString(fileStr, *filePath);\n\t\tTSharedPtr<FJsonObject> rootObject = MakeShareable(new FJsonObject());\n\t\tTSharedRef<TJsonReader<>> jsonReader = TJsonReaderFactory<>::Create(fileStr);\n\t\tif (FJsonSerializer::Deserialize(jsonReader, rootObject))\n\t\t{\n\t\t\tserver = rootObject->GetStringField(\"server\");\n\t\t\tdbName = rootObject->GetStringField(\"dbName\");\n\t\t\tuserId = rootObject->GetStringField(\"userId\");\n\t\t\tpasswd = rootObject->GetStringField(\"passwd\");\n\t\t}\n\t\tconnectConfig.Add(FName(*server));\n\t\tconnectConfig.Add(FName(*dbName));\n\t\tconnectConfig.Add(FName(*userId));\n\t\tconnectConfig.Add(FName(*passwd));\n\t}\n\n\treturn TArray<FName>();\n}\n\n```\n\n- 首先Json文本的读取需要将Json文本以字符串的形式读入到一个FString的输入流载体中；\n- 然后我们需要将这个输入流载体绑定到TJsonReader<>读出工具上；\n- 然后使用`FJsonSerializer::Deserialize(TSharePtr<TJsonReader<>>,TSahrePtr<FJsonObject>)`将输入流载体的Json数据反序列化到FJsonObject对象中；\n- 最后我们就可以使用FJsonObject对象中的`GetArrayField(FString)`、`GetBoolFiled(FString)`、`GetNumberField(FString)`、`GetStringField(FString)`、`GetObjectField(FString)`、`GetField(FString)`等方法从Json对象中读取指定键的值了。","source":"_posts/【UE4】UE4读写Json文件.md","raw":"---\ntitle: 【UE4】UE4读写Json文件\ndate: 2019-11-06 21:10:15\ntags: UE4\ncategories: 知识记录\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 一、准备工作\n\n如果我们想要在UE4中读写Json文件，那么我们必须使UE4包含<font color=red>Json和JsonUtilities</font>这两个模块，那么UE4如何添加模块呢？\n\nUE4添加预定义模块的方法很简单，我只需打开工程的.Biuld.cs文件，在其中的`PublicDependencyModuleNames.AddRange()`函数中追加两个模块即可，如：\n\n```C++\nusing UnrealBuildTool;\n\npublic class DATA_sys : ModuleRules\n{\n\tpublic DATA_sys(ReadOnlyTargetRules Target) : base(Target)\n\t{\n\t\tPCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;\n\t\n\t\tPublicDependencyModuleNames.AddRange(new string[] { \"Core\", \"CoreUObject\", \"Engine\", \"InputCore\" ,\"Json\",\"JsonUtilities\"});\n\n\t\tPrivateDependencyModuleNames.AddRange(new string[] {  });\n\n\t\t// Uncomment if you are using Slate UI\n\t\t// PrivateDependencyModuleNames.AddRange(new string[] { \"Slate\", \"SlateCore\" });\n\t\t\n\t\t// Uncomment if you are using online features\n\t\t// PrivateDependencyModuleNames.Add(\"OnlineSubsystem\");\n\n\t\t// To include OnlineSubsystemSteam, add it to the plugins section in your uproject file with the Enabled attribute set to true\n\t}\n}\n```\n\n如果我们要添加自定义模块就有点麻烦了，当然这里就不赘述了。\n\n包含这两个模块之后，我们还需要用到<font color=red> Json.h、JsonObject.h、JsonSerializer.h</font>三个头文件，其中JsonSerializer.h是用于Json序列化与反序列化用的。\n\n至此我们就可以使用UE4自带的工具进行Json文件的读写工作了。\n\n# 二、Json文件写\n\n## 1.非序列化写入\n\n```C++\nvoid AMysqlJsonCpp::CreatJson()\n{\n\tFString filePath = FPaths::GameContentDir() + TEXT(\"MysqlConfig/Connect.json\");\n\tFString jsonStr;\n\tTSharedRef<TJsonWriter<>> jsonWriter = TJsonWriterFactory<>::Create(&jsonStr);\n\tjsonWriter->WriteObjectStart();\n\tjsonWriter->WriteValue(TEXT(\"server\"), TEXT(\"127.0.0.1\"));\n\tjsonWriter->WriteObjectEnd();\n\tjsonWriter->Close();\n\tFFileHelper::SaveStringToFile(jsonStr, *filePath);\n}\n```\n\n- `FPaths::GameContentDir()`返回当前工程目录的Content文件夹的路径，FPaths为UE4的路径读写工具；\n\n- `FString jsonStr`的作用是用于关联UE4的Json写工具TJsonWriter<>，作为输入流载体，且JsonStr必须是FString类型；\n\n- `TShareRef<T>`是UE4自身的共享指针类型；\n\n- `TJsonWriter<>`是UE4专门用于写Json的模板类，其中类型参数通常为TCHAR，其中有多个方法供开发者使用：\n\n  | 函数                                          | 作用                 |\n  | --------------------------------------------- | -------------------- |\n  | Close()                                       | 关闭写工具           |\n  | WriterArrayStart()                            | 开始一个Json数组     |\n  | WriterArrayEnd()                              | 结束一个Json数组     |\n  | WriterNull(FString)                           | 为一个键写一个空值   |\n  | WriterObjectStart()                           | 开始一个Json对象     |\n  | WriterObjectEnd()                             | 结束一个Json对象     |\n  | WriterValue(FString,FString/int32/float/bool) | 向Json文件写入键值对 |\n\n  \n\n- `TJsonWriterFactory<>::Create(FString)`是UE4用来生成Json写工具TJsonWriter<>的类，TJsonFactory<>只有一个方法就是Create；\n\n- `FFileHelper`UE4的文件读写工具，方法`SaveStringToFile(TJsonWriter*,FString*)`函数的作用就是将Json写工具中的Json数据写到FString字符串中的路径文件中。\n\n使用非序列化方式写入Json时，写入方式需要严格按照Json的语法格式来做，如最开始需要使用WriterObjectStart()创建一个根前括号，即Json语法中最外面一层的`{`，所有写入结束后需要使用WriterObjectEnd()声明根对象结束，即Json语法中的最外面一层的`}`，同理数组也需要按对象一样的方法进行处理。如此才能写入一个结构完整的Json文本。\n\n## 2.序列化写入\n\n```c++\nvoid AMyActor::Test()\n{\n\tTSharedPtr<FJsonObject> rootObj = MakeShareable(new FJsonObject());\n\trootObj->SetStringField(\"root\", \"1\");\n\tTArray<TSharedPtr<FJsonValue>> arrValue;\n\tTSharedPtr<FJsonValueString> tmp = MakeShareable(new FJsonValueString(\"array\"));\n\tarrValue.Add(tmp);\n\trootObj->SetArrayField(\"array\", arrValue);\n\tFString filePath = FPaths::GameContentDir() + TEXT(\"MysqlConfig/text.json\");\n\tFString jsonStr;\n\tTSharedRef<TJsonWriter<TCHAR>> jsonWriter = TJsonWriterFactory<TCHAR>::Create(&jsonStr);\n\tFJsonSerializer::Serialize(rootObj.ToSharedRef(), jsonWriter);\n\tFFileHelper::SaveStringToFile(jsonStr, *filePath);\n\tUE_LOG(LogTemp, Error, TEXT(\"%s\"),*filePath);\n}\n```\n\n序列化的写入方式则无需考虑按Json的语法结构进行写入，序列化的写入方式是通过一个FJsonObject对象进行Json文本的写入。\n\n- 首先使用MakeSahreable()函数创建一个FJsonObject对象并使用共享指针引用。\n- 然后我们便可以使用FJsonObject对象中的`SetArrayField(FString,TArray<FSharePtr<FJsonValue>>)`、`SetBoolFiled(FString,bool)`、`SetNumberField(FString,Number)`、`SetStringField(FString,FString)`、`SetObjectField(FString,TSharePtr<FJsonObject>)`、`SetField(FString,TSharePtr<FJsonValue>)`等函数向FJsonObject对象中写分别入数组、bool值、数字、字符串、对象和Json键值对。其中数组的写入较为麻烦，我们需要先向创建Json键值对类型共享指针的TArray数组`TArray<TSharePtr<FJsonValue>>`。并向数组中添加指向FJsonValue对象的共享指针后然后才可以使用SetArrayField进行数组的Json文本写入。\n- 我们序列化写好的FJsonObject对象需要转化为FString字符串才能向文本中写入数据，FJsonObject转化为FString输入流的方式就是`FJsonSerializer::Serialize(TSharePtr<FJsonObject>.ToShareRef(),TSharePtr<FJsonWriter>)`;其中`TSharePtr<FJsonWriter>`和非序列化写入一样需要绑定一个FString作为输入流载体。\n- 最后就可以通过FFileHelper::SaveStringToFile(FString,\\*FString)，前一个FString是输入流载体，后一个\\*FString是Json文件的存储路径。\n\n# 三、Json文件读\n\n## 1.反序列化读取\n\n\n\n```C++\nTArray<FName> AMysqlJsonCpp::ReadMysqlConnectConfig()\n{\n\tFString filePath = FPaths::GameContentDir() + TEXT(\"MysqlConfig/Connect.json\");\n\tif (FPaths::FileExists(filePath))\n\t{\n\t\tFString server;\n\t\tFString dbName;\n\t\tFString userId;\n\t\tFString passwd;\n\t\tTArray<FName> connectConfig;\n\t\tFString fileStr;\n\t\tFFileHelper::LoadFileToString(fileStr, *filePath);\n\t\tTSharedPtr<FJsonObject> rootObject = MakeShareable(new FJsonObject());\n\t\tTSharedRef<TJsonReader<>> jsonReader = TJsonReaderFactory<>::Create(fileStr);\n\t\tif (FJsonSerializer::Deserialize(jsonReader, rootObject))\n\t\t{\n\t\t\tserver = rootObject->GetStringField(\"server\");\n\t\t\tdbName = rootObject->GetStringField(\"dbName\");\n\t\t\tuserId = rootObject->GetStringField(\"userId\");\n\t\t\tpasswd = rootObject->GetStringField(\"passwd\");\n\t\t}\n\t\tconnectConfig.Add(FName(*server));\n\t\tconnectConfig.Add(FName(*dbName));\n\t\tconnectConfig.Add(FName(*userId));\n\t\tconnectConfig.Add(FName(*passwd));\n\t}\n\n\treturn TArray<FName>();\n}\n\n```\n\n- 首先Json文本的读取需要将Json文本以字符串的形式读入到一个FString的输入流载体中；\n- 然后我们需要将这个输入流载体绑定到TJsonReader<>读出工具上；\n- 然后使用`FJsonSerializer::Deserialize(TSharePtr<TJsonReader<>>,TSahrePtr<FJsonObject>)`将输入流载体的Json数据反序列化到FJsonObject对象中；\n- 最后我们就可以使用FJsonObject对象中的`GetArrayField(FString)`、`GetBoolFiled(FString)`、`GetNumberField(FString)`、`GetStringField(FString)`、`GetObjectField(FString)`、`GetField(FString)`等方法从Json对象中读取指定键的值了。","slug":"【UE4】UE4读写Json文件","published":1,"updated":"2021-02-01T13:32:55.185Z","_id":"ckk9hocau0017dwr75lwb8vmf","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h1 id=\"一、准备工作\"><a href=\"#一、准备工作\" class=\"headerlink\" title=\"一、准备工作\"></a>一、准备工作</h1><p>如果我们想要在UE4中读写Json文件，那么我们必须使UE4包含<font color=\"red\">Json和JsonUtilities</font>这两个模块，那么UE4如何添加模块呢？</p>\n<p>UE4添加预定义模块的方法很简单，我只需打开工程的.Biuld.cs文件，在其中的<code>PublicDependencyModuleNames.AddRange()</code>函数中追加两个模块即可，如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">using</span> UnrealBuildTool;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DATA_sys</span> :</span> ModuleRules<br>&#123;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">DATA_sys</span><span class=\"hljs-params\">(ReadOnlyTargetRules Target)</span> : <span class=\"hljs-title\">base</span><span class=\"hljs-params\">(Target)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tPCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;<br>\t<br>\t\tPublicDependencyModuleNames.AddRange(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">string</span>[] &#123; <span class=\"hljs-string\">&quot;Core&quot;</span>, <span class=\"hljs-string\">&quot;CoreUObject&quot;</span>, <span class=\"hljs-string\">&quot;Engine&quot;</span>, <span class=\"hljs-string\">&quot;InputCore&quot;</span> ,<span class=\"hljs-string\">&quot;Json&quot;</span>,<span class=\"hljs-string\">&quot;JsonUtilities&quot;</span>&#125;);<br><br>\t\tPrivateDependencyModuleNames.AddRange(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">string</span>[] &#123;  &#125;);<br><br>\t\t<span class=\"hljs-comment\">// Uncomment if you are using Slate UI</span><br>\t\t<span class=\"hljs-comment\">// PrivateDependencyModuleNames.AddRange(new string[] &#123; &quot;Slate&quot;, &quot;SlateCore&quot; &#125;);</span><br>\t\t<br>\t\t<span class=\"hljs-comment\">// Uncomment if you are using online features</span><br>\t\t<span class=\"hljs-comment\">// PrivateDependencyModuleNames.Add(&quot;OnlineSubsystem&quot;);</span><br><br>\t\t<span class=\"hljs-comment\">// To include OnlineSubsystemSteam, add it to the plugins section in your uproject file with the Enabled attribute set to true</span><br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>如果我们要添加自定义模块就有点麻烦了，当然这里就不赘述了。</p>\n<p>包含这两个模块之后，我们还需要用到<font color=\"red\"> Json.h、JsonObject.h、JsonSerializer.h</font>三个头文件，其中JsonSerializer.h是用于Json序列化与反序列化用的。</p>\n<p>至此我们就可以使用UE4自带的工具进行Json文件的读写工作了。</p>\n<h1 id=\"二、Json文件写\"><a href=\"#二、Json文件写\" class=\"headerlink\" title=\"二、Json文件写\"></a>二、Json文件写</h1><h2 id=\"1-非序列化写入\"><a href=\"#1-非序列化写入\" class=\"headerlink\" title=\"1.非序列化写入\"></a>1.非序列化写入</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">AMysqlJsonCpp::CreatJson</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tFString filePath = FPaths::GameContentDir() + TEXT(<span class=\"hljs-string\">&quot;MysqlConfig/Connect.json&quot;</span>);<br>\tFString jsonStr;<br>\tTSharedRef&lt;TJsonWriter&lt;&gt;&gt; jsonWriter = TJsonWriterFactory&lt;&gt;::Create(&amp;jsonStr);<br>\tjsonWriter-&gt;WriteObjectStart();<br>\tjsonWriter-&gt;WriteValue(TEXT(<span class=\"hljs-string\">&quot;server&quot;</span>), TEXT(<span class=\"hljs-string\">&quot;127.0.0.1&quot;</span>));<br>\tjsonWriter-&gt;WriteObjectEnd();<br>\tjsonWriter-&gt;Close();<br>\tFFileHelper::SaveStringToFile(jsonStr, *filePath);<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><p><code>FPaths::GameContentDir()</code>返回当前工程目录的Content文件夹的路径，FPaths为UE4的路径读写工具；</p>\n</li>\n<li><p><code>FString jsonStr</code>的作用是用于关联UE4的Json写工具TJsonWriter&lt;&gt;，作为输入流载体，且JsonStr必须是FString类型；</p>\n</li>\n<li><p><code>TShareRef&lt;T&gt;</code>是UE4自身的共享指针类型；</p>\n</li>\n<li><p><code>TJsonWriter&lt;&gt;</code>是UE4专门用于写Json的模板类，其中类型参数通常为TCHAR，其中有多个方法供开发者使用：</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Close()</td>\n<td>关闭写工具</td>\n</tr>\n<tr>\n<td>WriterArrayStart()</td>\n<td>开始一个Json数组</td>\n</tr>\n<tr>\n<td>WriterArrayEnd()</td>\n<td>结束一个Json数组</td>\n</tr>\n<tr>\n<td>WriterNull(FString)</td>\n<td>为一个键写一个空值</td>\n</tr>\n<tr>\n<td>WriterObjectStart()</td>\n<td>开始一个Json对象</td>\n</tr>\n<tr>\n<td>WriterObjectEnd()</td>\n<td>结束一个Json对象</td>\n</tr>\n<tr>\n<td>WriterValue(FString,FString/int32/float/bool)</td>\n<td>向Json文件写入键值对</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<ul>\n<li><p><code>TJsonWriterFactory&lt;&gt;::Create(FString)</code>是UE4用来生成Json写工具TJsonWriter&lt;&gt;的类，TJsonFactory&lt;&gt;只有一个方法就是Create；</p>\n</li>\n<li><p><code>FFileHelper</code>UE4的文件读写工具，方法<code>SaveStringToFile(TJsonWriter*,FString*)</code>函数的作用就是将Json写工具中的Json数据写到FString字符串中的路径文件中。</p>\n</li>\n</ul>\n<p>使用非序列化方式写入Json时，写入方式需要严格按照Json的语法格式来做，如最开始需要使用WriterObjectStart()创建一个根前括号，即Json语法中最外面一层的<code>&#123;</code>，所有写入结束后需要使用WriterObjectEnd()声明根对象结束，即Json语法中的最外面一层的<code>&#125;</code>，同理数组也需要按对象一样的方法进行处理。如此才能写入一个结构完整的Json文本。</p>\n<h2 id=\"2-序列化写入\"><a href=\"#2-序列化写入\" class=\"headerlink\" title=\"2.序列化写入\"></a>2.序列化写入</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">AMyActor::Test</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tTSharedPtr&lt;FJsonObject&gt; rootObj = MakeShareable(<span class=\"hljs-keyword\">new</span> FJsonObject());<br>\trootObj-&gt;SetStringField(<span class=\"hljs-string\">&quot;root&quot;</span>, <span class=\"hljs-string\">&quot;1&quot;</span>);<br>\tTArray&lt;TSharedPtr&lt;FJsonValue&gt;&gt; arrValue;<br>\tTSharedPtr&lt;FJsonValueString&gt; tmp = MakeShareable(<span class=\"hljs-keyword\">new</span> FJsonValueString(<span class=\"hljs-string\">&quot;array&quot;</span>));<br>\tarrValue.Add(tmp);<br>\trootObj-&gt;SetArrayField(<span class=\"hljs-string\">&quot;array&quot;</span>, arrValue);<br>\tFString filePath = FPaths::GameContentDir() + TEXT(<span class=\"hljs-string\">&quot;MysqlConfig/text.json&quot;</span>);<br>\tFString jsonStr;<br>\tTSharedRef&lt;TJsonWriter&lt;TCHAR&gt;&gt; jsonWriter = TJsonWriterFactory&lt;TCHAR&gt;::Create(&amp;jsonStr);<br>\tFJsonSerializer::Serialize(rootObj.ToSharedRef(), jsonWriter);<br>\tFFileHelper::SaveStringToFile(jsonStr, *filePath);<br>\tUE_LOG(LogTemp, Error, TEXT(<span class=\"hljs-string\">&quot;%s&quot;</span>),*filePath);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>序列化的写入方式则无需考虑按Json的语法结构进行写入，序列化的写入方式是通过一个FJsonObject对象进行Json文本的写入。</p>\n<ul>\n<li>首先使用MakeSahreable()函数创建一个FJsonObject对象并使用共享指针引用。</li>\n<li>然后我们便可以使用FJsonObject对象中的<code>SetArrayField(FString,TArray&lt;FSharePtr&lt;FJsonValue&gt;&gt;)</code>、<code>SetBoolFiled(FString,bool)</code>、<code>SetNumberField(FString,Number)</code>、<code>SetStringField(FString,FString)</code>、<code>SetObjectField(FString,TSharePtr&lt;FJsonObject&gt;)</code>、<code>SetField(FString,TSharePtr&lt;FJsonValue&gt;)</code>等函数向FJsonObject对象中写分别入数组、bool值、数字、字符串、对象和Json键值对。其中数组的写入较为麻烦，我们需要先向创建Json键值对类型共享指针的TArray数组<code>TArray&lt;TSharePtr&lt;FJsonValue&gt;&gt;</code>。并向数组中添加指向FJsonValue对象的共享指针后然后才可以使用SetArrayField进行数组的Json文本写入。</li>\n<li>我们序列化写好的FJsonObject对象需要转化为FString字符串才能向文本中写入数据，FJsonObject转化为FString输入流的方式就是<code>FJsonSerializer::Serialize(TSharePtr&lt;FJsonObject&gt;.ToShareRef(),TSharePtr&lt;FJsonWriter&gt;)</code>;其中<code>TSharePtr&lt;FJsonWriter&gt;</code>和非序列化写入一样需要绑定一个FString作为输入流载体。</li>\n<li>最后就可以通过FFileHelper::SaveStringToFile(FString,*FString)，前一个FString是输入流载体，后一个*FString是Json文件的存储路径。</li>\n</ul>\n<h1 id=\"三、Json文件读\"><a href=\"#三、Json文件读\" class=\"headerlink\" title=\"三、Json文件读\"></a>三、Json文件读</h1><h2 id=\"1-反序列化读取\"><a href=\"#1-反序列化读取\" class=\"headerlink\" title=\"1.反序列化读取\"></a>1.反序列化读取</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\">TArray&lt;FName&gt; <span class=\"hljs-title\">AMysqlJsonCpp::ReadMysqlConnectConfig</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tFString filePath = FPaths::GameContentDir() + TEXT(<span class=\"hljs-string\">&quot;MysqlConfig/Connect.json&quot;</span>);<br>\t<span class=\"hljs-keyword\">if</span> (FPaths::FileExists(filePath))<br>\t&#123;<br>\t\tFString server;<br>\t\tFString dbName;<br>\t\tFString userId;<br>\t\tFString passwd;<br>\t\tTArray&lt;FName&gt; connectConfig;<br>\t\tFString fileStr;<br>\t\tFFileHelper::LoadFileToString(fileStr, *filePath);<br>\t\tTSharedPtr&lt;FJsonObject&gt; rootObject = MakeShareable(<span class=\"hljs-keyword\">new</span> FJsonObject());<br>\t\tTSharedRef&lt;TJsonReader&lt;&gt;&gt; jsonReader = TJsonReaderFactory&lt;&gt;::Create(fileStr);<br>\t\t<span class=\"hljs-keyword\">if</span> (FJsonSerializer::Deserialize(jsonReader, rootObject))<br>\t\t&#123;<br>\t\t\tserver = rootObject-&gt;GetStringField(<span class=\"hljs-string\">&quot;server&quot;</span>);<br>\t\t\tdbName = rootObject-&gt;GetStringField(<span class=\"hljs-string\">&quot;dbName&quot;</span>);<br>\t\t\tuserId = rootObject-&gt;GetStringField(<span class=\"hljs-string\">&quot;userId&quot;</span>);<br>\t\t\tpasswd = rootObject-&gt;GetStringField(<span class=\"hljs-string\">&quot;passwd&quot;</span>);<br>\t\t&#125;<br>\t\tconnectConfig.Add(FName(*server));<br>\t\tconnectConfig.Add(FName(*dbName));<br>\t\tconnectConfig.Add(FName(*userId));<br>\t\tconnectConfig.Add(FName(*passwd));<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> TArray&lt;FName&gt;();<br>&#125;<br><br></code></pre></td></tr></table></figure>\n<ul>\n<li>首先Json文本的读取需要将Json文本以字符串的形式读入到一个FString的输入流载体中；</li>\n<li>然后我们需要将这个输入流载体绑定到TJsonReader&lt;&gt;读出工具上；</li>\n<li>然后使用<code>FJsonSerializer::Deserialize(TSharePtr&lt;TJsonReader&lt;&gt;&gt;,TSahrePtr&lt;FJsonObject&gt;)</code>将输入流载体的Json数据反序列化到FJsonObject对象中；</li>\n<li>最后我们就可以使用FJsonObject对象中的<code>GetArrayField(FString)</code>、<code>GetBoolFiled(FString)</code>、<code>GetNumberField(FString)</code>、<code>GetStringField(FString)</code>、<code>GetObjectField(FString)</code>、<code>GetField(FString)</code>等方法从Json对象中读取指定键的值了。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h1 id=\"一、准备工作\"><a href=\"#一、准备工作\" class=\"headerlink\" title=\"一、准备工作\"></a>一、准备工作</h1><p>如果我们想要在UE4中读写Json文件，那么我们必须使UE4包含<font color=\"red\">Json和JsonUtilities</font>这两个模块，那么UE4如何添加模块呢？</p>\n<p>UE4添加预定义模块的方法很简单，我只需打开工程的.Biuld.cs文件，在其中的<code>PublicDependencyModuleNames.AddRange()</code>函数中追加两个模块即可，如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">using</span> UnrealBuildTool;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DATA_sys</span> :</span> ModuleRules<br>&#123;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">DATA_sys</span><span class=\"hljs-params\">(ReadOnlyTargetRules Target)</span> : <span class=\"hljs-title\">base</span><span class=\"hljs-params\">(Target)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tPCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;<br>\t<br>\t\tPublicDependencyModuleNames.AddRange(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">string</span>[] &#123; <span class=\"hljs-string\">&quot;Core&quot;</span>, <span class=\"hljs-string\">&quot;CoreUObject&quot;</span>, <span class=\"hljs-string\">&quot;Engine&quot;</span>, <span class=\"hljs-string\">&quot;InputCore&quot;</span> ,<span class=\"hljs-string\">&quot;Json&quot;</span>,<span class=\"hljs-string\">&quot;JsonUtilities&quot;</span>&#125;);<br><br>\t\tPrivateDependencyModuleNames.AddRange(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">string</span>[] &#123;  &#125;);<br><br>\t\t<span class=\"hljs-comment\">// Uncomment if you are using Slate UI</span><br>\t\t<span class=\"hljs-comment\">// PrivateDependencyModuleNames.AddRange(new string[] &#123; &quot;Slate&quot;, &quot;SlateCore&quot; &#125;);</span><br>\t\t<br>\t\t<span class=\"hljs-comment\">// Uncomment if you are using online features</span><br>\t\t<span class=\"hljs-comment\">// PrivateDependencyModuleNames.Add(&quot;OnlineSubsystem&quot;);</span><br><br>\t\t<span class=\"hljs-comment\">// To include OnlineSubsystemSteam, add it to the plugins section in your uproject file with the Enabled attribute set to true</span><br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>如果我们要添加自定义模块就有点麻烦了，当然这里就不赘述了。</p>\n<p>包含这两个模块之后，我们还需要用到<font color=\"red\"> Json.h、JsonObject.h、JsonSerializer.h</font>三个头文件，其中JsonSerializer.h是用于Json序列化与反序列化用的。</p>\n<p>至此我们就可以使用UE4自带的工具进行Json文件的读写工作了。</p>\n<h1 id=\"二、Json文件写\"><a href=\"#二、Json文件写\" class=\"headerlink\" title=\"二、Json文件写\"></a>二、Json文件写</h1><h2 id=\"1-非序列化写入\"><a href=\"#1-非序列化写入\" class=\"headerlink\" title=\"1.非序列化写入\"></a>1.非序列化写入</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">AMysqlJsonCpp::CreatJson</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tFString filePath = FPaths::GameContentDir() + TEXT(<span class=\"hljs-string\">&quot;MysqlConfig/Connect.json&quot;</span>);<br>\tFString jsonStr;<br>\tTSharedRef&lt;TJsonWriter&lt;&gt;&gt; jsonWriter = TJsonWriterFactory&lt;&gt;::Create(&amp;jsonStr);<br>\tjsonWriter-&gt;WriteObjectStart();<br>\tjsonWriter-&gt;WriteValue(TEXT(<span class=\"hljs-string\">&quot;server&quot;</span>), TEXT(<span class=\"hljs-string\">&quot;127.0.0.1&quot;</span>));<br>\tjsonWriter-&gt;WriteObjectEnd();<br>\tjsonWriter-&gt;Close();<br>\tFFileHelper::SaveStringToFile(jsonStr, *filePath);<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><p><code>FPaths::GameContentDir()</code>返回当前工程目录的Content文件夹的路径，FPaths为UE4的路径读写工具；</p>\n</li>\n<li><p><code>FString jsonStr</code>的作用是用于关联UE4的Json写工具TJsonWriter&lt;&gt;，作为输入流载体，且JsonStr必须是FString类型；</p>\n</li>\n<li><p><code>TShareRef&lt;T&gt;</code>是UE4自身的共享指针类型；</p>\n</li>\n<li><p><code>TJsonWriter&lt;&gt;</code>是UE4专门用于写Json的模板类，其中类型参数通常为TCHAR，其中有多个方法供开发者使用：</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Close()</td>\n<td>关闭写工具</td>\n</tr>\n<tr>\n<td>WriterArrayStart()</td>\n<td>开始一个Json数组</td>\n</tr>\n<tr>\n<td>WriterArrayEnd()</td>\n<td>结束一个Json数组</td>\n</tr>\n<tr>\n<td>WriterNull(FString)</td>\n<td>为一个键写一个空值</td>\n</tr>\n<tr>\n<td>WriterObjectStart()</td>\n<td>开始一个Json对象</td>\n</tr>\n<tr>\n<td>WriterObjectEnd()</td>\n<td>结束一个Json对象</td>\n</tr>\n<tr>\n<td>WriterValue(FString,FString/int32/float/bool)</td>\n<td>向Json文件写入键值对</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<ul>\n<li><p><code>TJsonWriterFactory&lt;&gt;::Create(FString)</code>是UE4用来生成Json写工具TJsonWriter&lt;&gt;的类，TJsonFactory&lt;&gt;只有一个方法就是Create；</p>\n</li>\n<li><p><code>FFileHelper</code>UE4的文件读写工具，方法<code>SaveStringToFile(TJsonWriter*,FString*)</code>函数的作用就是将Json写工具中的Json数据写到FString字符串中的路径文件中。</p>\n</li>\n</ul>\n<p>使用非序列化方式写入Json时，写入方式需要严格按照Json的语法格式来做，如最开始需要使用WriterObjectStart()创建一个根前括号，即Json语法中最外面一层的<code>&#123;</code>，所有写入结束后需要使用WriterObjectEnd()声明根对象结束，即Json语法中的最外面一层的<code>&#125;</code>，同理数组也需要按对象一样的方法进行处理。如此才能写入一个结构完整的Json文本。</p>\n<h2 id=\"2-序列化写入\"><a href=\"#2-序列化写入\" class=\"headerlink\" title=\"2.序列化写入\"></a>2.序列化写入</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">AMyActor::Test</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tTSharedPtr&lt;FJsonObject&gt; rootObj = MakeShareable(<span class=\"hljs-keyword\">new</span> FJsonObject());<br>\trootObj-&gt;SetStringField(<span class=\"hljs-string\">&quot;root&quot;</span>, <span class=\"hljs-string\">&quot;1&quot;</span>);<br>\tTArray&lt;TSharedPtr&lt;FJsonValue&gt;&gt; arrValue;<br>\tTSharedPtr&lt;FJsonValueString&gt; tmp = MakeShareable(<span class=\"hljs-keyword\">new</span> FJsonValueString(<span class=\"hljs-string\">&quot;array&quot;</span>));<br>\tarrValue.Add(tmp);<br>\trootObj-&gt;SetArrayField(<span class=\"hljs-string\">&quot;array&quot;</span>, arrValue);<br>\tFString filePath = FPaths::GameContentDir() + TEXT(<span class=\"hljs-string\">&quot;MysqlConfig/text.json&quot;</span>);<br>\tFString jsonStr;<br>\tTSharedRef&lt;TJsonWriter&lt;TCHAR&gt;&gt; jsonWriter = TJsonWriterFactory&lt;TCHAR&gt;::Create(&amp;jsonStr);<br>\tFJsonSerializer::Serialize(rootObj.ToSharedRef(), jsonWriter);<br>\tFFileHelper::SaveStringToFile(jsonStr, *filePath);<br>\tUE_LOG(LogTemp, Error, TEXT(<span class=\"hljs-string\">&quot;%s&quot;</span>),*filePath);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>序列化的写入方式则无需考虑按Json的语法结构进行写入，序列化的写入方式是通过一个FJsonObject对象进行Json文本的写入。</p>\n<ul>\n<li>首先使用MakeSahreable()函数创建一个FJsonObject对象并使用共享指针引用。</li>\n<li>然后我们便可以使用FJsonObject对象中的<code>SetArrayField(FString,TArray&lt;FSharePtr&lt;FJsonValue&gt;&gt;)</code>、<code>SetBoolFiled(FString,bool)</code>、<code>SetNumberField(FString,Number)</code>、<code>SetStringField(FString,FString)</code>、<code>SetObjectField(FString,TSharePtr&lt;FJsonObject&gt;)</code>、<code>SetField(FString,TSharePtr&lt;FJsonValue&gt;)</code>等函数向FJsonObject对象中写分别入数组、bool值、数字、字符串、对象和Json键值对。其中数组的写入较为麻烦，我们需要先向创建Json键值对类型共享指针的TArray数组<code>TArray&lt;TSharePtr&lt;FJsonValue&gt;&gt;</code>。并向数组中添加指向FJsonValue对象的共享指针后然后才可以使用SetArrayField进行数组的Json文本写入。</li>\n<li>我们序列化写好的FJsonObject对象需要转化为FString字符串才能向文本中写入数据，FJsonObject转化为FString输入流的方式就是<code>FJsonSerializer::Serialize(TSharePtr&lt;FJsonObject&gt;.ToShareRef(),TSharePtr&lt;FJsonWriter&gt;)</code>;其中<code>TSharePtr&lt;FJsonWriter&gt;</code>和非序列化写入一样需要绑定一个FString作为输入流载体。</li>\n<li>最后就可以通过FFileHelper::SaveStringToFile(FString,*FString)，前一个FString是输入流载体，后一个*FString是Json文件的存储路径。</li>\n</ul>\n<h1 id=\"三、Json文件读\"><a href=\"#三、Json文件读\" class=\"headerlink\" title=\"三、Json文件读\"></a>三、Json文件读</h1><h2 id=\"1-反序列化读取\"><a href=\"#1-反序列化读取\" class=\"headerlink\" title=\"1.反序列化读取\"></a>1.反序列化读取</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\">TArray&lt;FName&gt; <span class=\"hljs-title\">AMysqlJsonCpp::ReadMysqlConnectConfig</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tFString filePath = FPaths::GameContentDir() + TEXT(<span class=\"hljs-string\">&quot;MysqlConfig/Connect.json&quot;</span>);<br>\t<span class=\"hljs-keyword\">if</span> (FPaths::FileExists(filePath))<br>\t&#123;<br>\t\tFString server;<br>\t\tFString dbName;<br>\t\tFString userId;<br>\t\tFString passwd;<br>\t\tTArray&lt;FName&gt; connectConfig;<br>\t\tFString fileStr;<br>\t\tFFileHelper::LoadFileToString(fileStr, *filePath);<br>\t\tTSharedPtr&lt;FJsonObject&gt; rootObject = MakeShareable(<span class=\"hljs-keyword\">new</span> FJsonObject());<br>\t\tTSharedRef&lt;TJsonReader&lt;&gt;&gt; jsonReader = TJsonReaderFactory&lt;&gt;::Create(fileStr);<br>\t\t<span class=\"hljs-keyword\">if</span> (FJsonSerializer::Deserialize(jsonReader, rootObject))<br>\t\t&#123;<br>\t\t\tserver = rootObject-&gt;GetStringField(<span class=\"hljs-string\">&quot;server&quot;</span>);<br>\t\t\tdbName = rootObject-&gt;GetStringField(<span class=\"hljs-string\">&quot;dbName&quot;</span>);<br>\t\t\tuserId = rootObject-&gt;GetStringField(<span class=\"hljs-string\">&quot;userId&quot;</span>);<br>\t\t\tpasswd = rootObject-&gt;GetStringField(<span class=\"hljs-string\">&quot;passwd&quot;</span>);<br>\t\t&#125;<br>\t\tconnectConfig.Add(FName(*server));<br>\t\tconnectConfig.Add(FName(*dbName));<br>\t\tconnectConfig.Add(FName(*userId));<br>\t\tconnectConfig.Add(FName(*passwd));<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> TArray&lt;FName&gt;();<br>&#125;<br><br></code></pre></td></tr></table></figure>\n<ul>\n<li>首先Json文本的读取需要将Json文本以字符串的形式读入到一个FString的输入流载体中；</li>\n<li>然后我们需要将这个输入流载体绑定到TJsonReader&lt;&gt;读出工具上；</li>\n<li>然后使用<code>FJsonSerializer::Deserialize(TSharePtr&lt;TJsonReader&lt;&gt;&gt;,TSahrePtr&lt;FJsonObject&gt;)</code>将输入流载体的Json数据反序列化到FJsonObject对象中；</li>\n<li>最后我们就可以使用FJsonObject对象中的<code>GetArrayField(FString)</code>、<code>GetBoolFiled(FString)</code>、<code>GetNumberField(FString)</code>、<code>GetStringField(FString)</code>、<code>GetObjectField(FString)</code>、<code>GetField(FString)</code>等方法从Json对象中读取指定键的值了。</li>\n</ul>\n"},{"title":"【UE4】UE4连接MySQL","date":"2019-11-06T13:10:30.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 一、使用MySQLIntegration插件连接Mysql\n\n- Update Data from Query Async组件后面必须再跟一个其他的节点，节点才能正常执行\n- UE4 C++编程中不能出现私有私有变量？\n- UE4 C++静态变量？\n- MySQL Integration插件只支持sql语句，不支持存储过程\n- 在蓝图中实现的C++函数在蓝图中没法使用？\n- 暴露给蓝图的变量和函数必须是公有且非静态的\n- UE4 C++类创建对象，大象无形31页\n- UE4 C++编程中if else语句必须加{}\n\n## 1.MySQL Integration安装\n\nMySQL Integration插件可以直接在UE4商城中搜索到，直接下载安装即可，如何是从外部导入的离线包，直接将插件文件夹丢入UE4安装目录下的Engine\\Plugins文件夹下即可。\n\n## 2.激活MySQL Integration\n\n激活插件直接在UE4中的Edit/Plugins/Installed下找到MySQL Integration勾选Enabled即可，勾选插件之后UE4会提示需要重启UE4才可激活，重启软件就可以激活插件了。\n\n## 3.MySQL Integration提供的蓝图组件\n\n官方文档： https://sameek4.github.io/KodeSpire/Pages/MySQLIntegration.html \n\n### Set Connection Properties(Mysql连接)\n\nSet Connection Properties组件提供UE4对Mysql的连接服务。\n\n![](【UE4】UE4连接MySQL/Snipaste_2019-11-05_17-54-58.png)\n\n**输入：**\n\n- server：数据库的连接ip；\n- DBName：数据库的名字；\n- User ID：登录数据库用户名；\n- Password：登录数据库的用户密码；\n- Extra Param：SetConnectionProperties提供的额外参数传入；\n- Is Trusted：启用windows用户名和密码登录数据库。\n\n### Check  Connection State(Mysql连接状态检查)\n\n此组件提供对Mysql连接的状态的查询服务。\n\n![](【UE4】UE4连接MySQL/Snipaste_2019-11-05_18-02-53.png)\n\n**输出：**\n\n- Error Message：输出错误信息；\n\n- Return Value：输出连接状态；\n\n  包含如下状态值(类型为插件定义的EMysqlConnectionStateEnum枚举)：\n\n  - Broken：数据库损坏；\n  - Closed：连接关闭；\n  - connecting：正在连接；\n  - Eecuting：正在发送命令；\n  - Fetching：数据库正在检索数据；\n  - Open：连接以正常打开，可以正常使用数据库。\n\n### Update Data from Query Async(异步发送非查询sql命令)\n\n![](【UE4】UE4连接MySQL/Snipaste_2019-11-05_18-14-47.png)\n\n此组件提供非查询的sql命令发送服务，即发送insert，delete，create等命令。\n\n### Update Data from Query (同步发送非查询sql命令)\n\n![](【UE4】UE4连接MySQL/Snipaste_2019-11-05_18-17-44.png)\n\n**输入：**\n\n- Query：sql命令字符串；\n\n**输出：**\n\n- Success Status：命令的执行状态\n\n  有三种执行状态值，类型为插件自定义的EMysqlSuccessStateEnum枚举，\n\n  - Executing：sql命令正在发送；\n  - Success：sql命令执行成功；\n  - Failed：sql命令执行失败。\n\n- Error Message：输出错误信息。\n\n### Check Query EXecution State(检查上一条命令的执行状态)\n\n此组件提任何sql命令的执行状态检查，<font color=red>但仅限检查Check Query EXecution State执行前的上一条sql语句的状态检查。</font>\n\n![](【UE4】UE4连接MySQL/Snipaste_2019-11-05_18-26-48.png)\n\n输出内容和Update Data from Query一致。\n\n### Select Data from Query Async(异步发送查询命令)\n\n此组件仅限发送select语句，其他语句发送无效，<font color=red> 查询到的数据会存储到插件自带的数据结构中，可以使用下面介绍的Get Selected Table组件进行数据访问。</font>\n\n![](【UE4】UE4连接MySQL/Snipaste_2019-11-05_18-27-48.png)\n\n## Get Selected Table(读取数据表)\n\n![](【UE4】UE4连接MySQL/Snipaste_2019-11-05_18-34-52.png)\n\n**输出:**\n\n- Result by Column：以列的形式返回数据，<font color=red>返回一个MySQLDataTableStructures的结构体数据，每一个结构体就是一列，MySQLDataTableStructures结构体包含两个成员ColumnName(列名)和ColumnData(列数据)，其中ColumnData是一个FString类型的TArray数组，数组中每一个元数就是该列中某一行的数据。</font>\n- Result by Row：以行的形式返回数据，返回一个<font color=red> 返回一个MySQLDataRowStructures类型的结构体数组，每一个结构体就是一行，MySQLDataRowStructures结构体包含一个FString类型的TArray数组，数组中每一个元素就是该行中某一列的数据。</font>\n\n## 4.MySQL Integration的注意事项\n\n### MySQL Integration不支持存储过程\n\nMySQL Integration插件不支持数据库的存储过程的语法，在Query引脚输入“Call ProdureceName(ParameterList) ”是没有办法唤醒数据库中的存储过程的，所以很多的数据库中的查询和插入逻辑就需要在外部实现了。\n\n### MySQL Integration不提供C++函数\n\nMySQL Integration插件只提供蓝图组件不提供C++函数，也就是说数据库的连接查询等只能使用蓝图来实现，但大多数情况我们又必须在C++中访问数据库，在这钟情况下我们该如何做呢？\n\n目前，我只想到一种方法，就是在C++中创建访问数据库的类在类中声明数据库的访问函数，用这个类的蓝图子类来重写该数据库访问函数，以实现父类中该数据库访问函数，这是由C++继承中的重写的特性实现的。\n\n具体做法如下：\n\n首先在C++中创建一个专门负责连接数据库的类并在类中声明连接函数。\n\n```C++\n#include \"MysqlJsonCpp.h\"\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MysqlConnector.generated.h\"\n\nUCLASS()\nclass DATA_SYS_API AMysqlConnector : public AActor\n{\n\tGENERATED_BODY()\npublic:\t\n\n\tUPROPERTY(BlueprintReadWrite,Category = \"VariableRW\")\n\tFString errorMessage;\n\tUPROPERTY(BlueprintReadWrite, Category = \"VariableRW\")\n\tFString stateMessage;\n\nprotected:\n\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\n\tAMysqlConnector();\n\tvirtual void Tick(float DeltaTime) override;\n\n\t//从配置文件ConnectConfig.json中读取Mysql连接配置文件\n\tvoid ConnectMysqlByConfig();\n    \n\t//使用MySQLIntegration插件连接Mysql\n\tUFUNCTION(BlueprintImplementableEvent,Category = \"OverridFunction\")\n\tvoid Connect(FName server, FName dbName, FName userId, FName passwd);\n    \n\t//使用MySQLIntegration插件检查连接状态\n\tUFUNCTION(BlueprintImplementableEvent, Category = \"OverridFunction\")\n\tbool ConnectState(FString &errorMessageParam,FString &stateMessageParam);\n\t//获取连接状态\n\tbool GetConnectState();\n};\n```\n\n上面的void Connect(FName server, FName dbName, FName userId, FName passwd);函数就是需要用蓝图实现的数据库连接函数，<font color =red> 这里要注意，这个函数只能在C++中声明，不可以实现，否则父类调用此函数时将无法关联到子类的重写，并且这个函数需要使用`BlueprintImplementableEvent`参数暴露给蓝图</font>。\n\n<font color =red> 这里还需要注意，如果这个函数中使用了变量的引用，那么这个变量也需要使用`UPROPERTY(BlueprintReadWrite, Category = \"VariableRW\")`暴漏给蓝图，如上面的`FString errorMessage;`一样。</font>\n\n这样我们就可以创建一个蓝图类来继承这个类，\n\n![](【UE4】UE4连接MySQL/Snipaste_2019-11-05_19-12-00.png)\n\n然后在该蓝图类的MyBlueprint/Functions/Override下看到我们在C++类中声明的函数，直接重写实现即可，如：\n\n![](【UE4】UE4连接MySQL/Snipaste_2019-11-05_19-14-07.png)\n\n实现时候我们就可以在C++中调用这个函数了，这个函数就会通过重写关联到蓝图自类中的重写过程，如此数据库便连接上了。\n\n# 二、使用C++库连接Mysql\n\n目前卡在#include<mysql.h>编译不通过。","source":"_posts/【UE4】UE4连接MySQL.md","raw":"---\ntitle: 【UE4】UE4连接MySQL\ndate: 2019-11-06 21:10:30\ntags: UE4\ncategories: 知识记录\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 一、使用MySQLIntegration插件连接Mysql\n\n- Update Data from Query Async组件后面必须再跟一个其他的节点，节点才能正常执行\n- UE4 C++编程中不能出现私有私有变量？\n- UE4 C++静态变量？\n- MySQL Integration插件只支持sql语句，不支持存储过程\n- 在蓝图中实现的C++函数在蓝图中没法使用？\n- 暴露给蓝图的变量和函数必须是公有且非静态的\n- UE4 C++类创建对象，大象无形31页\n- UE4 C++编程中if else语句必须加{}\n\n## 1.MySQL Integration安装\n\nMySQL Integration插件可以直接在UE4商城中搜索到，直接下载安装即可，如何是从外部导入的离线包，直接将插件文件夹丢入UE4安装目录下的Engine\\Plugins文件夹下即可。\n\n## 2.激活MySQL Integration\n\n激活插件直接在UE4中的Edit/Plugins/Installed下找到MySQL Integration勾选Enabled即可，勾选插件之后UE4会提示需要重启UE4才可激活，重启软件就可以激活插件了。\n\n## 3.MySQL Integration提供的蓝图组件\n\n官方文档： https://sameek4.github.io/KodeSpire/Pages/MySQLIntegration.html \n\n### Set Connection Properties(Mysql连接)\n\nSet Connection Properties组件提供UE4对Mysql的连接服务。\n\n![](【UE4】UE4连接MySQL/Snipaste_2019-11-05_17-54-58.png)\n\n**输入：**\n\n- server：数据库的连接ip；\n- DBName：数据库的名字；\n- User ID：登录数据库用户名；\n- Password：登录数据库的用户密码；\n- Extra Param：SetConnectionProperties提供的额外参数传入；\n- Is Trusted：启用windows用户名和密码登录数据库。\n\n### Check  Connection State(Mysql连接状态检查)\n\n此组件提供对Mysql连接的状态的查询服务。\n\n![](【UE4】UE4连接MySQL/Snipaste_2019-11-05_18-02-53.png)\n\n**输出：**\n\n- Error Message：输出错误信息；\n\n- Return Value：输出连接状态；\n\n  包含如下状态值(类型为插件定义的EMysqlConnectionStateEnum枚举)：\n\n  - Broken：数据库损坏；\n  - Closed：连接关闭；\n  - connecting：正在连接；\n  - Eecuting：正在发送命令；\n  - Fetching：数据库正在检索数据；\n  - Open：连接以正常打开，可以正常使用数据库。\n\n### Update Data from Query Async(异步发送非查询sql命令)\n\n![](【UE4】UE4连接MySQL/Snipaste_2019-11-05_18-14-47.png)\n\n此组件提供非查询的sql命令发送服务，即发送insert，delete，create等命令。\n\n### Update Data from Query (同步发送非查询sql命令)\n\n![](【UE4】UE4连接MySQL/Snipaste_2019-11-05_18-17-44.png)\n\n**输入：**\n\n- Query：sql命令字符串；\n\n**输出：**\n\n- Success Status：命令的执行状态\n\n  有三种执行状态值，类型为插件自定义的EMysqlSuccessStateEnum枚举，\n\n  - Executing：sql命令正在发送；\n  - Success：sql命令执行成功；\n  - Failed：sql命令执行失败。\n\n- Error Message：输出错误信息。\n\n### Check Query EXecution State(检查上一条命令的执行状态)\n\n此组件提任何sql命令的执行状态检查，<font color=red>但仅限检查Check Query EXecution State执行前的上一条sql语句的状态检查。</font>\n\n![](【UE4】UE4连接MySQL/Snipaste_2019-11-05_18-26-48.png)\n\n输出内容和Update Data from Query一致。\n\n### Select Data from Query Async(异步发送查询命令)\n\n此组件仅限发送select语句，其他语句发送无效，<font color=red> 查询到的数据会存储到插件自带的数据结构中，可以使用下面介绍的Get Selected Table组件进行数据访问。</font>\n\n![](【UE4】UE4连接MySQL/Snipaste_2019-11-05_18-27-48.png)\n\n## Get Selected Table(读取数据表)\n\n![](【UE4】UE4连接MySQL/Snipaste_2019-11-05_18-34-52.png)\n\n**输出:**\n\n- Result by Column：以列的形式返回数据，<font color=red>返回一个MySQLDataTableStructures的结构体数据，每一个结构体就是一列，MySQLDataTableStructures结构体包含两个成员ColumnName(列名)和ColumnData(列数据)，其中ColumnData是一个FString类型的TArray数组，数组中每一个元数就是该列中某一行的数据。</font>\n- Result by Row：以行的形式返回数据，返回一个<font color=red> 返回一个MySQLDataRowStructures类型的结构体数组，每一个结构体就是一行，MySQLDataRowStructures结构体包含一个FString类型的TArray数组，数组中每一个元素就是该行中某一列的数据。</font>\n\n## 4.MySQL Integration的注意事项\n\n### MySQL Integration不支持存储过程\n\nMySQL Integration插件不支持数据库的存储过程的语法，在Query引脚输入“Call ProdureceName(ParameterList) ”是没有办法唤醒数据库中的存储过程的，所以很多的数据库中的查询和插入逻辑就需要在外部实现了。\n\n### MySQL Integration不提供C++函数\n\nMySQL Integration插件只提供蓝图组件不提供C++函数，也就是说数据库的连接查询等只能使用蓝图来实现，但大多数情况我们又必须在C++中访问数据库，在这钟情况下我们该如何做呢？\n\n目前，我只想到一种方法，就是在C++中创建访问数据库的类在类中声明数据库的访问函数，用这个类的蓝图子类来重写该数据库访问函数，以实现父类中该数据库访问函数，这是由C++继承中的重写的特性实现的。\n\n具体做法如下：\n\n首先在C++中创建一个专门负责连接数据库的类并在类中声明连接函数。\n\n```C++\n#include \"MysqlJsonCpp.h\"\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MysqlConnector.generated.h\"\n\nUCLASS()\nclass DATA_SYS_API AMysqlConnector : public AActor\n{\n\tGENERATED_BODY()\npublic:\t\n\n\tUPROPERTY(BlueprintReadWrite,Category = \"VariableRW\")\n\tFString errorMessage;\n\tUPROPERTY(BlueprintReadWrite, Category = \"VariableRW\")\n\tFString stateMessage;\n\nprotected:\n\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\n\tAMysqlConnector();\n\tvirtual void Tick(float DeltaTime) override;\n\n\t//从配置文件ConnectConfig.json中读取Mysql连接配置文件\n\tvoid ConnectMysqlByConfig();\n    \n\t//使用MySQLIntegration插件连接Mysql\n\tUFUNCTION(BlueprintImplementableEvent,Category = \"OverridFunction\")\n\tvoid Connect(FName server, FName dbName, FName userId, FName passwd);\n    \n\t//使用MySQLIntegration插件检查连接状态\n\tUFUNCTION(BlueprintImplementableEvent, Category = \"OverridFunction\")\n\tbool ConnectState(FString &errorMessageParam,FString &stateMessageParam);\n\t//获取连接状态\n\tbool GetConnectState();\n};\n```\n\n上面的void Connect(FName server, FName dbName, FName userId, FName passwd);函数就是需要用蓝图实现的数据库连接函数，<font color =red> 这里要注意，这个函数只能在C++中声明，不可以实现，否则父类调用此函数时将无法关联到子类的重写，并且这个函数需要使用`BlueprintImplementableEvent`参数暴露给蓝图</font>。\n\n<font color =red> 这里还需要注意，如果这个函数中使用了变量的引用，那么这个变量也需要使用`UPROPERTY(BlueprintReadWrite, Category = \"VariableRW\")`暴漏给蓝图，如上面的`FString errorMessage;`一样。</font>\n\n这样我们就可以创建一个蓝图类来继承这个类，\n\n![](【UE4】UE4连接MySQL/Snipaste_2019-11-05_19-12-00.png)\n\n然后在该蓝图类的MyBlueprint/Functions/Override下看到我们在C++类中声明的函数，直接重写实现即可，如：\n\n![](【UE4】UE4连接MySQL/Snipaste_2019-11-05_19-14-07.png)\n\n实现时候我们就可以在C++中调用这个函数了，这个函数就会通过重写关联到蓝图自类中的重写过程，如此数据库便连接上了。\n\n# 二、使用C++库连接Mysql\n\n目前卡在#include<mysql.h>编译不通过。","slug":"【UE4】UE4连接MySQL","published":1,"updated":"2021-02-01T13:33:37.109Z","_id":"ckk9hocau001adwr74wos09iu","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h1 id=\"一、使用MySQLIntegration插件连接Mysql\"><a href=\"#一、使用MySQLIntegration插件连接Mysql\" class=\"headerlink\" title=\"一、使用MySQLIntegration插件连接Mysql\"></a>一、使用MySQLIntegration插件连接Mysql</h1><ul>\n<li>Update Data from Query Async组件后面必须再跟一个其他的节点，节点才能正常执行</li>\n<li>UE4 C++编程中不能出现私有私有变量？</li>\n<li>UE4 C++静态变量？</li>\n<li>MySQL Integration插件只支持sql语句，不支持存储过程</li>\n<li>在蓝图中实现的C++函数在蓝图中没法使用？</li>\n<li>暴露给蓝图的变量和函数必须是公有且非静态的</li>\n<li>UE4 C++类创建对象，大象无形31页</li>\n<li>UE4 C++编程中if else语句必须加{}</li>\n</ul>\n<h2 id=\"1-MySQL-Integration安装\"><a href=\"#1-MySQL-Integration安装\" class=\"headerlink\" title=\"1.MySQL Integration安装\"></a>1.MySQL Integration安装</h2><p>MySQL Integration插件可以直接在UE4商城中搜索到，直接下载安装即可，如何是从外部导入的离线包，直接将插件文件夹丢入UE4安装目录下的Engine\\Plugins文件夹下即可。</p>\n<h2 id=\"2-激活MySQL-Integration\"><a href=\"#2-激活MySQL-Integration\" class=\"headerlink\" title=\"2.激活MySQL Integration\"></a>2.激活MySQL Integration</h2><p>激活插件直接在UE4中的Edit/Plugins/Installed下找到MySQL Integration勾选Enabled即可，勾选插件之后UE4会提示需要重启UE4才可激活，重启软件就可以激活插件了。</p>\n<h2 id=\"3-MySQL-Integration提供的蓝图组件\"><a href=\"#3-MySQL-Integration提供的蓝图组件\" class=\"headerlink\" title=\"3.MySQL Integration提供的蓝图组件\"></a>3.MySQL Integration提供的蓝图组件</h2><p>官方文档： <a href=\"https://sameek4.github.io/KodeSpire/Pages/MySQLIntegration.html\">https://sameek4.github.io/KodeSpire/Pages/MySQLIntegration.html</a> </p>\n<h3 id=\"Set-Connection-Properties-Mysql连接\"><a href=\"#Set-Connection-Properties-Mysql连接\" class=\"headerlink\" title=\"Set Connection Properties(Mysql连接)\"></a>Set Connection Properties(Mysql连接)</h3><p>Set Connection Properties组件提供UE4对Mysql的连接服务。</p>\n<p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%BF%9E%E6%8E%A5MySQL/Snipaste_2019-11-05_17-54-58.png\"></p>\n<p><strong>输入：</strong></p>\n<ul>\n<li>server：数据库的连接ip；</li>\n<li>DBName：数据库的名字；</li>\n<li>User ID：登录数据库用户名；</li>\n<li>Password：登录数据库的用户密码；</li>\n<li>Extra Param：SetConnectionProperties提供的额外参数传入；</li>\n<li>Is Trusted：启用windows用户名和密码登录数据库。</li>\n</ul>\n<h3 id=\"Check-Connection-State-Mysql连接状态检查\"><a href=\"#Check-Connection-State-Mysql连接状态检查\" class=\"headerlink\" title=\"Check  Connection State(Mysql连接状态检查)\"></a>Check  Connection State(Mysql连接状态检查)</h3><p>此组件提供对Mysql连接的状态的查询服务。</p>\n<p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%BF%9E%E6%8E%A5MySQL/Snipaste_2019-11-05_18-02-53.png\"></p>\n<p><strong>输出：</strong></p>\n<ul>\n<li><p>Error Message：输出错误信息；</p>\n</li>\n<li><p>Return Value：输出连接状态；</p>\n<p>包含如下状态值(类型为插件定义的EMysqlConnectionStateEnum枚举)：</p>\n<ul>\n<li>Broken：数据库损坏；</li>\n<li>Closed：连接关闭；</li>\n<li>connecting：正在连接；</li>\n<li>Eecuting：正在发送命令；</li>\n<li>Fetching：数据库正在检索数据；</li>\n<li>Open：连接以正常打开，可以正常使用数据库。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Update-Data-from-Query-Async-异步发送非查询sql命令\"><a href=\"#Update-Data-from-Query-Async-异步发送非查询sql命令\" class=\"headerlink\" title=\"Update Data from Query Async(异步发送非查询sql命令)\"></a>Update Data from Query Async(异步发送非查询sql命令)</h3><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%BF%9E%E6%8E%A5MySQL/Snipaste_2019-11-05_18-14-47.png\"></p>\n<p>此组件提供非查询的sql命令发送服务，即发送insert，delete，create等命令。</p>\n<h3 id=\"Update-Data-from-Query-同步发送非查询sql命令\"><a href=\"#Update-Data-from-Query-同步发送非查询sql命令\" class=\"headerlink\" title=\"Update Data from Query (同步发送非查询sql命令)\"></a>Update Data from Query (同步发送非查询sql命令)</h3><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%BF%9E%E6%8E%A5MySQL/Snipaste_2019-11-05_18-17-44.png\"></p>\n<p><strong>输入：</strong></p>\n<ul>\n<li>Query：sql命令字符串；</li>\n</ul>\n<p><strong>输出：</strong></p>\n<ul>\n<li><p>Success Status：命令的执行状态</p>\n<p>有三种执行状态值，类型为插件自定义的EMysqlSuccessStateEnum枚举，</p>\n<ul>\n<li>Executing：sql命令正在发送；</li>\n<li>Success：sql命令执行成功；</li>\n<li>Failed：sql命令执行失败。</li>\n</ul>\n</li>\n<li><p>Error Message：输出错误信息。</p>\n</li>\n</ul>\n<h3 id=\"Check-Query-EXecution-State-检查上一条命令的执行状态\"><a href=\"#Check-Query-EXecution-State-检查上一条命令的执行状态\" class=\"headerlink\" title=\"Check Query EXecution State(检查上一条命令的执行状态)\"></a>Check Query EXecution State(检查上一条命令的执行状态)</h3><p>此组件提任何sql命令的执行状态检查，<font color=\"red\">但仅限检查Check Query EXecution State执行前的上一条sql语句的状态检查。</font></p>\n<p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%BF%9E%E6%8E%A5MySQL/Snipaste_2019-11-05_18-26-48.png\"></p>\n<p>输出内容和Update Data from Query一致。</p>\n<h3 id=\"Select-Data-from-Query-Async-异步发送查询命令\"><a href=\"#Select-Data-from-Query-Async-异步发送查询命令\" class=\"headerlink\" title=\"Select Data from Query Async(异步发送查询命令)\"></a>Select Data from Query Async(异步发送查询命令)</h3><p>此组件仅限发送select语句，其他语句发送无效，<font color=\"red\"> 查询到的数据会存储到插件自带的数据结构中，可以使用下面介绍的Get Selected Table组件进行数据访问。</font></p>\n<p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%BF%9E%E6%8E%A5MySQL/Snipaste_2019-11-05_18-27-48.png\"></p>\n<h2 id=\"Get-Selected-Table-读取数据表\"><a href=\"#Get-Selected-Table-读取数据表\" class=\"headerlink\" title=\"Get Selected Table(读取数据表)\"></a>Get Selected Table(读取数据表)</h2><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%BF%9E%E6%8E%A5MySQL/Snipaste_2019-11-05_18-34-52.png\"></p>\n<p><strong>输出:</strong></p>\n<ul>\n<li>Result by Column：以列的形式返回数据，<font color=\"red\">返回一个MySQLDataTableStructures的结构体数据，每一个结构体就是一列，MySQLDataTableStructures结构体包含两个成员ColumnName(列名)和ColumnData(列数据)，其中ColumnData是一个FString类型的TArray数组，数组中每一个元数就是该列中某一行的数据。</font></li>\n<li>Result by Row：以行的形式返回数据，返回一个<font color=\"red\"> 返回一个MySQLDataRowStructures类型的结构体数组，每一个结构体就是一行，MySQLDataRowStructures结构体包含一个FString类型的TArray数组，数组中每一个元素就是该行中某一列的数据。</font></li>\n</ul>\n<h2 id=\"4-MySQL-Integration的注意事项\"><a href=\"#4-MySQL-Integration的注意事项\" class=\"headerlink\" title=\"4.MySQL Integration的注意事项\"></a>4.MySQL Integration的注意事项</h2><h3 id=\"MySQL-Integration不支持存储过程\"><a href=\"#MySQL-Integration不支持存储过程\" class=\"headerlink\" title=\"MySQL Integration不支持存储过程\"></a>MySQL Integration不支持存储过程</h3><p>MySQL Integration插件不支持数据库的存储过程的语法，在Query引脚输入“Call ProdureceName(ParameterList) ”是没有办法唤醒数据库中的存储过程的，所以很多的数据库中的查询和插入逻辑就需要在外部实现了。</p>\n<h3 id=\"MySQL-Integration不提供C-函数\"><a href=\"#MySQL-Integration不提供C-函数\" class=\"headerlink\" title=\"MySQL Integration不提供C++函数\"></a>MySQL Integration不提供C++函数</h3><p>MySQL Integration插件只提供蓝图组件不提供C++函数，也就是说数据库的连接查询等只能使用蓝图来实现，但大多数情况我们又必须在C++中访问数据库，在这钟情况下我们该如何做呢？</p>\n<p>目前，我只想到一种方法，就是在C++中创建访问数据库的类在类中声明数据库的访问函数，用这个类的蓝图子类来重写该数据库访问函数，以实现父类中该数据库访问函数，这是由C++继承中的重写的特性实现的。</p>\n<p>具体做法如下：</p>\n<p>首先在C++中创建一个专门负责连接数据库的类并在类中声明连接函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;MysqlJsonCpp.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;CoreMinimal.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;GameFramework/Actor.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;MysqlConnector.generated.h&quot;</span></span><br><br>UCLASS()<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DATA_SYS_API</span> <span class=\"hljs-title\">AMysqlConnector</span> :</span> <span class=\"hljs-keyword\">public</span> AActor<br>&#123;<br>\tGENERATED_BODY()<br><span class=\"hljs-keyword\">public</span>:\t<br><br>\tUPROPERTY(BlueprintReadWrite,Category = <span class=\"hljs-string\">&quot;VariableRW&quot;</span>)<br>\tFString errorMessage;<br>\tUPROPERTY(BlueprintReadWrite, Category = <span class=\"hljs-string\">&quot;VariableRW&quot;</span>)<br>\tFString stateMessage;<br><br><span class=\"hljs-keyword\">protected</span>:<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">BeginPlay</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">override</span></span>;<br><br><span class=\"hljs-keyword\">public</span>:\t<br><br>\tAMysqlConnector();<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Tick</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">float</span> DeltaTime)</span> <span class=\"hljs-keyword\">override</span></span>;<br><br>\t<span class=\"hljs-comment\">//从配置文件ConnectConfig.json中读取Mysql连接配置文件</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ConnectMysqlByConfig</span><span class=\"hljs-params\">()</span></span>;<br>    <br>\t<span class=\"hljs-comment\">//使用MySQLIntegration插件连接Mysql</span><br>\tUFUNCTION(BlueprintImplementableEvent,Category = <span class=\"hljs-string\">&quot;OverridFunction&quot;</span>)<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Connect</span><span class=\"hljs-params\">(FName server, FName dbName, FName userId, FName passwd)</span></span>;<br>    <br>\t<span class=\"hljs-comment\">//使用MySQLIntegration插件检查连接状态</span><br>\tUFUNCTION(BlueprintImplementableEvent, Category = <span class=\"hljs-string\">&quot;OverridFunction&quot;</span>)<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">ConnectState</span><span class=\"hljs-params\">(FString &amp;errorMessageParam,FString &amp;stateMessageParam)</span></span>;<br>\t<span class=\"hljs-comment\">//获取连接状态</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">GetConnectState</span><span class=\"hljs-params\">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>上面的void Connect(FName server, FName dbName, FName userId, FName passwd);函数就是需要用蓝图实现的数据库连接函数，<font color=\"red\"> 这里要注意，这个函数只能在C++中声明，不可以实现，否则父类调用此函数时将无法关联到子类的重写，并且这个函数需要使用<code>BlueprintImplementableEvent</code>参数暴露给蓝图</font>。</p>\n<p><font color=\"red\"> 这里还需要注意，如果这个函数中使用了变量的引用，那么这个变量也需要使用<code>UPROPERTY(BlueprintReadWrite, Category = &quot;VariableRW&quot;)</code>暴漏给蓝图，如上面的<code>FString errorMessage;</code>一样。</font></p>\n<p>这样我们就可以创建一个蓝图类来继承这个类，</p>\n<p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%BF%9E%E6%8E%A5MySQL/Snipaste_2019-11-05_19-12-00.png\"></p>\n<p>然后在该蓝图类的MyBlueprint/Functions/Override下看到我们在C++类中声明的函数，直接重写实现即可，如：</p>\n<p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%BF%9E%E6%8E%A5MySQL/Snipaste_2019-11-05_19-14-07.png\"></p>\n<p>实现时候我们就可以在C++中调用这个函数了，这个函数就会通过重写关联到蓝图自类中的重写过程，如此数据库便连接上了。</p>\n<h1 id=\"二、使用C-库连接Mysql\"><a href=\"#二、使用C-库连接Mysql\" class=\"headerlink\" title=\"二、使用C++库连接Mysql\"></a>二、使用C++库连接Mysql</h1><p>目前卡在#include&lt;mysql.h&gt;编译不通过。</p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h1 id=\"一、使用MySQLIntegration插件连接Mysql\"><a href=\"#一、使用MySQLIntegration插件连接Mysql\" class=\"headerlink\" title=\"一、使用MySQLIntegration插件连接Mysql\"></a>一、使用MySQLIntegration插件连接Mysql</h1><ul>\n<li>Update Data from Query Async组件后面必须再跟一个其他的节点，节点才能正常执行</li>\n<li>UE4 C++编程中不能出现私有私有变量？</li>\n<li>UE4 C++静态变量？</li>\n<li>MySQL Integration插件只支持sql语句，不支持存储过程</li>\n<li>在蓝图中实现的C++函数在蓝图中没法使用？</li>\n<li>暴露给蓝图的变量和函数必须是公有且非静态的</li>\n<li>UE4 C++类创建对象，大象无形31页</li>\n<li>UE4 C++编程中if else语句必须加{}</li>\n</ul>\n<h2 id=\"1-MySQL-Integration安装\"><a href=\"#1-MySQL-Integration安装\" class=\"headerlink\" title=\"1.MySQL Integration安装\"></a>1.MySQL Integration安装</h2><p>MySQL Integration插件可以直接在UE4商城中搜索到，直接下载安装即可，如何是从外部导入的离线包，直接将插件文件夹丢入UE4安装目录下的Engine\\Plugins文件夹下即可。</p>\n<h2 id=\"2-激活MySQL-Integration\"><a href=\"#2-激活MySQL-Integration\" class=\"headerlink\" title=\"2.激活MySQL Integration\"></a>2.激活MySQL Integration</h2><p>激活插件直接在UE4中的Edit/Plugins/Installed下找到MySQL Integration勾选Enabled即可，勾选插件之后UE4会提示需要重启UE4才可激活，重启软件就可以激活插件了。</p>\n<h2 id=\"3-MySQL-Integration提供的蓝图组件\"><a href=\"#3-MySQL-Integration提供的蓝图组件\" class=\"headerlink\" title=\"3.MySQL Integration提供的蓝图组件\"></a>3.MySQL Integration提供的蓝图组件</h2><p>官方文档： <a href=\"https://sameek4.github.io/KodeSpire/Pages/MySQLIntegration.html\">https://sameek4.github.io/KodeSpire/Pages/MySQLIntegration.html</a> </p>\n<h3 id=\"Set-Connection-Properties-Mysql连接\"><a href=\"#Set-Connection-Properties-Mysql连接\" class=\"headerlink\" title=\"Set Connection Properties(Mysql连接)\"></a>Set Connection Properties(Mysql连接)</h3><p>Set Connection Properties组件提供UE4对Mysql的连接服务。</p>\n<p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%BF%9E%E6%8E%A5MySQL/Snipaste_2019-11-05_17-54-58.png\"></p>\n<p><strong>输入：</strong></p>\n<ul>\n<li>server：数据库的连接ip；</li>\n<li>DBName：数据库的名字；</li>\n<li>User ID：登录数据库用户名；</li>\n<li>Password：登录数据库的用户密码；</li>\n<li>Extra Param：SetConnectionProperties提供的额外参数传入；</li>\n<li>Is Trusted：启用windows用户名和密码登录数据库。</li>\n</ul>\n<h3 id=\"Check-Connection-State-Mysql连接状态检查\"><a href=\"#Check-Connection-State-Mysql连接状态检查\" class=\"headerlink\" title=\"Check  Connection State(Mysql连接状态检查)\"></a>Check  Connection State(Mysql连接状态检查)</h3><p>此组件提供对Mysql连接的状态的查询服务。</p>\n<p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%BF%9E%E6%8E%A5MySQL/Snipaste_2019-11-05_18-02-53.png\"></p>\n<p><strong>输出：</strong></p>\n<ul>\n<li><p>Error Message：输出错误信息；</p>\n</li>\n<li><p>Return Value：输出连接状态；</p>\n<p>包含如下状态值(类型为插件定义的EMysqlConnectionStateEnum枚举)：</p>\n<ul>\n<li>Broken：数据库损坏；</li>\n<li>Closed：连接关闭；</li>\n<li>connecting：正在连接；</li>\n<li>Eecuting：正在发送命令；</li>\n<li>Fetching：数据库正在检索数据；</li>\n<li>Open：连接以正常打开，可以正常使用数据库。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Update-Data-from-Query-Async-异步发送非查询sql命令\"><a href=\"#Update-Data-from-Query-Async-异步发送非查询sql命令\" class=\"headerlink\" title=\"Update Data from Query Async(异步发送非查询sql命令)\"></a>Update Data from Query Async(异步发送非查询sql命令)</h3><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%BF%9E%E6%8E%A5MySQL/Snipaste_2019-11-05_18-14-47.png\"></p>\n<p>此组件提供非查询的sql命令发送服务，即发送insert，delete，create等命令。</p>\n<h3 id=\"Update-Data-from-Query-同步发送非查询sql命令\"><a href=\"#Update-Data-from-Query-同步发送非查询sql命令\" class=\"headerlink\" title=\"Update Data from Query (同步发送非查询sql命令)\"></a>Update Data from Query (同步发送非查询sql命令)</h3><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%BF%9E%E6%8E%A5MySQL/Snipaste_2019-11-05_18-17-44.png\"></p>\n<p><strong>输入：</strong></p>\n<ul>\n<li>Query：sql命令字符串；</li>\n</ul>\n<p><strong>输出：</strong></p>\n<ul>\n<li><p>Success Status：命令的执行状态</p>\n<p>有三种执行状态值，类型为插件自定义的EMysqlSuccessStateEnum枚举，</p>\n<ul>\n<li>Executing：sql命令正在发送；</li>\n<li>Success：sql命令执行成功；</li>\n<li>Failed：sql命令执行失败。</li>\n</ul>\n</li>\n<li><p>Error Message：输出错误信息。</p>\n</li>\n</ul>\n<h3 id=\"Check-Query-EXecution-State-检查上一条命令的执行状态\"><a href=\"#Check-Query-EXecution-State-检查上一条命令的执行状态\" class=\"headerlink\" title=\"Check Query EXecution State(检查上一条命令的执行状态)\"></a>Check Query EXecution State(检查上一条命令的执行状态)</h3><p>此组件提任何sql命令的执行状态检查，<font color=\"red\">但仅限检查Check Query EXecution State执行前的上一条sql语句的状态检查。</font></p>\n<p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%BF%9E%E6%8E%A5MySQL/Snipaste_2019-11-05_18-26-48.png\"></p>\n<p>输出内容和Update Data from Query一致。</p>\n<h3 id=\"Select-Data-from-Query-Async-异步发送查询命令\"><a href=\"#Select-Data-from-Query-Async-异步发送查询命令\" class=\"headerlink\" title=\"Select Data from Query Async(异步发送查询命令)\"></a>Select Data from Query Async(异步发送查询命令)</h3><p>此组件仅限发送select语句，其他语句发送无效，<font color=\"red\"> 查询到的数据会存储到插件自带的数据结构中，可以使用下面介绍的Get Selected Table组件进行数据访问。</font></p>\n<p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%BF%9E%E6%8E%A5MySQL/Snipaste_2019-11-05_18-27-48.png\"></p>\n<h2 id=\"Get-Selected-Table-读取数据表\"><a href=\"#Get-Selected-Table-读取数据表\" class=\"headerlink\" title=\"Get Selected Table(读取数据表)\"></a>Get Selected Table(读取数据表)</h2><p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%BF%9E%E6%8E%A5MySQL/Snipaste_2019-11-05_18-34-52.png\"></p>\n<p><strong>输出:</strong></p>\n<ul>\n<li>Result by Column：以列的形式返回数据，<font color=\"red\">返回一个MySQLDataTableStructures的结构体数据，每一个结构体就是一列，MySQLDataTableStructures结构体包含两个成员ColumnName(列名)和ColumnData(列数据)，其中ColumnData是一个FString类型的TArray数组，数组中每一个元数就是该列中某一行的数据。</font></li>\n<li>Result by Row：以行的形式返回数据，返回一个<font color=\"red\"> 返回一个MySQLDataRowStructures类型的结构体数组，每一个结构体就是一行，MySQLDataRowStructures结构体包含一个FString类型的TArray数组，数组中每一个元素就是该行中某一列的数据。</font></li>\n</ul>\n<h2 id=\"4-MySQL-Integration的注意事项\"><a href=\"#4-MySQL-Integration的注意事项\" class=\"headerlink\" title=\"4.MySQL Integration的注意事项\"></a>4.MySQL Integration的注意事项</h2><h3 id=\"MySQL-Integration不支持存储过程\"><a href=\"#MySQL-Integration不支持存储过程\" class=\"headerlink\" title=\"MySQL Integration不支持存储过程\"></a>MySQL Integration不支持存储过程</h3><p>MySQL Integration插件不支持数据库的存储过程的语法，在Query引脚输入“Call ProdureceName(ParameterList) ”是没有办法唤醒数据库中的存储过程的，所以很多的数据库中的查询和插入逻辑就需要在外部实现了。</p>\n<h3 id=\"MySQL-Integration不提供C-函数\"><a href=\"#MySQL-Integration不提供C-函数\" class=\"headerlink\" title=\"MySQL Integration不提供C++函数\"></a>MySQL Integration不提供C++函数</h3><p>MySQL Integration插件只提供蓝图组件不提供C++函数，也就是说数据库的连接查询等只能使用蓝图来实现，但大多数情况我们又必须在C++中访问数据库，在这钟情况下我们该如何做呢？</p>\n<p>目前，我只想到一种方法，就是在C++中创建访问数据库的类在类中声明数据库的访问函数，用这个类的蓝图子类来重写该数据库访问函数，以实现父类中该数据库访问函数，这是由C++继承中的重写的特性实现的。</p>\n<p>具体做法如下：</p>\n<p>首先在C++中创建一个专门负责连接数据库的类并在类中声明连接函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;MysqlJsonCpp.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;CoreMinimal.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;GameFramework/Actor.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;MysqlConnector.generated.h&quot;</span></span><br><br>UCLASS()<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DATA_SYS_API</span> <span class=\"hljs-title\">AMysqlConnector</span> :</span> <span class=\"hljs-keyword\">public</span> AActor<br>&#123;<br>\tGENERATED_BODY()<br><span class=\"hljs-keyword\">public</span>:\t<br><br>\tUPROPERTY(BlueprintReadWrite,Category = <span class=\"hljs-string\">&quot;VariableRW&quot;</span>)<br>\tFString errorMessage;<br>\tUPROPERTY(BlueprintReadWrite, Category = <span class=\"hljs-string\">&quot;VariableRW&quot;</span>)<br>\tFString stateMessage;<br><br><span class=\"hljs-keyword\">protected</span>:<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">BeginPlay</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">override</span></span>;<br><br><span class=\"hljs-keyword\">public</span>:\t<br><br>\tAMysqlConnector();<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Tick</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">float</span> DeltaTime)</span> <span class=\"hljs-keyword\">override</span></span>;<br><br>\t<span class=\"hljs-comment\">//从配置文件ConnectConfig.json中读取Mysql连接配置文件</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ConnectMysqlByConfig</span><span class=\"hljs-params\">()</span></span>;<br>    <br>\t<span class=\"hljs-comment\">//使用MySQLIntegration插件连接Mysql</span><br>\tUFUNCTION(BlueprintImplementableEvent,Category = <span class=\"hljs-string\">&quot;OverridFunction&quot;</span>)<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Connect</span><span class=\"hljs-params\">(FName server, FName dbName, FName userId, FName passwd)</span></span>;<br>    <br>\t<span class=\"hljs-comment\">//使用MySQLIntegration插件检查连接状态</span><br>\tUFUNCTION(BlueprintImplementableEvent, Category = <span class=\"hljs-string\">&quot;OverridFunction&quot;</span>)<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">ConnectState</span><span class=\"hljs-params\">(FString &amp;errorMessageParam,FString &amp;stateMessageParam)</span></span>;<br>\t<span class=\"hljs-comment\">//获取连接状态</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">GetConnectState</span><span class=\"hljs-params\">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>上面的void Connect(FName server, FName dbName, FName userId, FName passwd);函数就是需要用蓝图实现的数据库连接函数，<font color=\"red\"> 这里要注意，这个函数只能在C++中声明，不可以实现，否则父类调用此函数时将无法关联到子类的重写，并且这个函数需要使用<code>BlueprintImplementableEvent</code>参数暴露给蓝图</font>。</p>\n<p><font color=\"red\"> 这里还需要注意，如果这个函数中使用了变量的引用，那么这个变量也需要使用<code>UPROPERTY(BlueprintReadWrite, Category = &quot;VariableRW&quot;)</code>暴漏给蓝图，如上面的<code>FString errorMessage;</code>一样。</font></p>\n<p>这样我们就可以创建一个蓝图类来继承这个类，</p>\n<p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%BF%9E%E6%8E%A5MySQL/Snipaste_2019-11-05_19-12-00.png\"></p>\n<p>然后在该蓝图类的MyBlueprint/Functions/Override下看到我们在C++类中声明的函数，直接重写实现即可，如：</p>\n<p><img src=\"/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%BF%9E%E6%8E%A5MySQL/Snipaste_2019-11-05_19-14-07.png\"></p>\n<p>实现时候我们就可以在C++中调用这个函数了，这个函数就会通过重写关联到蓝图自类中的重写过程，如此数据库便连接上了。</p>\n<h1 id=\"二、使用C-库连接Mysql\"><a href=\"#二、使用C-库连接Mysql\" class=\"headerlink\" title=\"二、使用C++库连接Mysql\"></a>二、使用C++库连接Mysql</h1><p>目前卡在#include&lt;mysql.h&gt;编译不通过。</p>\n"},{"title":"【Unity3d】Animation","date":"2019-08-23T14:04:47.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n﻿1.总索引\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2019061314131628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n1.1.视图简介\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190520144632375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190520143240580.png)\n2.动画分类\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613141413854.png)\n\n2.1.普通动画\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613141551260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\t2.2.人物角色动画\n\t![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613141959166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\t2.2.1.人物角色动画的导入\n\t![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613142213379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n+大图导向\n\t-骨骼映射视图的打开 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190531125401236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\t-骨骼映射视图和骨骼映射表的修改![在这里插入图片描述](https://img-blog.csdnimg.cn/20190531125301603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n-三种动画的导入方式\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613142757765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)-模型导入注意事项\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613142937598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190531130631610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\t![在这里插入图片描述](https://img-blog.csdnimg.cn/20190531130654193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n2.3.IK动画\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613143849254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n2.4.TimeLine\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613143939800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n+大图导向\n\t-存储\n\t![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613144055967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\t-Playable Track\n\t![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613144133197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n3.AnimatorController(状态机)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613144259619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n3.1.状态机的打开方式\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613144350891.png)\n3.2.Animator视图简介\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613144502456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n3.3.作用\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613144550261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n3.4.精细控制\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613144641944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n+大图导向\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613144744729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n3.5.混合树\n![在这里插入图片描述](https://img-blog.csdnimg.cn/201906131452528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n3.5.1.四种2D混合树\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613145340965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n3.5.2.大图导向\n -混合树的创建\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613145440631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n -1D混合树Inspector\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613144953557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n -2D混合树Inspector\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613145057715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n3.6.Avatar Mask骨骼遮罩\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613145729200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n4.MacthTarget场景动画匹配技术\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613145909634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n4.1.核心方法\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613150056658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n4.2.MacthTarget函数细述\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613150207340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n4.3.难点\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613150430468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n+大图导向\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2019061315050794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n5.相机运动\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613150709467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n+大图导向\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613150735692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n6.学习过程中遇到的问题\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613150827535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n7.函数方法\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613150913675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n8.动画的Inspector\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613151018312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)","source":"_posts/【Unity3d】Animation.md","raw":"---\ntitle: 【Unity3d】Animation\ndate: 2019-08-23 22:04:47\ntags: Unity3d\ncategories: 学习笔记\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n﻿1.总索引\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2019061314131628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n1.1.视图简介\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190520144632375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190520143240580.png)\n2.动画分类\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613141413854.png)\n\n2.1.普通动画\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613141551260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\t2.2.人物角色动画\n\t![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613141959166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\t2.2.1.人物角色动画的导入\n\t![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613142213379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n+大图导向\n\t-骨骼映射视图的打开 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190531125401236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\t-骨骼映射视图和骨骼映射表的修改![在这里插入图片描述](https://img-blog.csdnimg.cn/20190531125301603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n-三种动画的导入方式\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613142757765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)-模型导入注意事项\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613142937598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190531130631610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\t![在这里插入图片描述](https://img-blog.csdnimg.cn/20190531130654193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n2.3.IK动画\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613143849254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n2.4.TimeLine\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613143939800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n+大图导向\n\t-存储\n\t![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613144055967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\t-Playable Track\n\t![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613144133197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n3.AnimatorController(状态机)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613144259619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n3.1.状态机的打开方式\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613144350891.png)\n3.2.Animator视图简介\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613144502456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n3.3.作用\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613144550261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n3.4.精细控制\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613144641944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n+大图导向\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613144744729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n3.5.混合树\n![在这里插入图片描述](https://img-blog.csdnimg.cn/201906131452528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n3.5.1.四种2D混合树\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613145340965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n3.5.2.大图导向\n -混合树的创建\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613145440631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n -1D混合树Inspector\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613144953557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n -2D混合树Inspector\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613145057715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n3.6.Avatar Mask骨骼遮罩\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613145729200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n4.MacthTarget场景动画匹配技术\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613145909634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n4.1.核心方法\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613150056658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n4.2.MacthTarget函数细述\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613150207340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n4.3.难点\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613150430468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n+大图导向\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2019061315050794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n5.相机运动\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613150709467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n+大图导向\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613150735692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n6.学习过程中遇到的问题\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613150827535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n7.函数方法\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613150913675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n8.动画的Inspector\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613151018312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)","slug":"【Unity3d】Animation","published":1,"updated":"2021-02-01T13:34:01.038Z","_id":"ckk9hocav001ddwr74z0y3xk5","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p>﻿1.总索引<br><img src=\"https://img-blog.csdnimg.cn/2019061314131628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>1.1.视图简介<br><img src=\"https://img-blog.csdnimg.cn/20190520144632375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/20190520143240580.png\" alt=\"在这里插入图片描述\"><br>2.动画分类<br><img src=\"https://img-blog.csdnimg.cn/20190613141413854.png\" alt=\"在这里插入图片描述\"></p>\n<p>2.1.普通动画<br><img src=\"https://img-blog.csdnimg.cn/20190613141551260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>    2.2.人物角色动画<br>    <img src=\"https://img-blog.csdnimg.cn/20190613141959166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>    2.2.1.人物角色动画的导入<br>    <img src=\"https://img-blog.csdnimg.cn/20190613142213379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>+大图导向<br>    -骨骼映射视图的打开 <img src=\"https://img-blog.csdnimg.cn/20190531125401236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>    -骨骼映射视图和骨骼映射表的修改<img src=\"https://img-blog.csdnimg.cn/20190531125301603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>-三种动画的导入方式<br><img src=\"https://img-blog.csdnimg.cn/20190613142757765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\">-模型导入注意事项<br><img src=\"https://img-blog.csdnimg.cn/20190613142937598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/20190531130631610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>    <img src=\"https://img-blog.csdnimg.cn/20190531130654193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>2.3.IK动画<br><img src=\"https://img-blog.csdnimg.cn/20190613143849254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>2.4.TimeLine<br><img src=\"https://img-blog.csdnimg.cn/20190613143939800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>+大图导向<br>    -存储<br>    <img src=\"https://img-blog.csdnimg.cn/20190613144055967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>    -Playable Track<br>    <img src=\"https://img-blog.csdnimg.cn/20190613144133197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>3.AnimatorController(状态机)<br><img src=\"https://img-blog.csdnimg.cn/20190613144259619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>3.1.状态机的打开方式<br><img src=\"https://img-blog.csdnimg.cn/20190613144350891.png\" alt=\"在这里插入图片描述\"><br>3.2.Animator视图简介<br><img src=\"https://img-blog.csdnimg.cn/20190613144502456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>3.3.作用<br><img src=\"https://img-blog.csdnimg.cn/20190613144550261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>3.4.精细控制<br><img src=\"https://img-blog.csdnimg.cn/20190613144641944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>+大图导向<br><img src=\"https://img-blog.csdnimg.cn/20190613144744729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>3.5.混合树<br><img src=\"https://img-blog.csdnimg.cn/201906131452528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>3.5.1.四种2D混合树<br><img src=\"https://img-blog.csdnimg.cn/20190613145340965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>3.5.2.大图导向<br> -混合树的创建<br> <img src=\"https://img-blog.csdnimg.cn/20190613145440631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br> -1D混合树Inspector<br> <img src=\"https://img-blog.csdnimg.cn/20190613144953557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br> -2D混合树Inspector<br> <img src=\"https://img-blog.csdnimg.cn/20190613145057715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>3.6.Avatar Mask骨骼遮罩<br><img src=\"https://img-blog.csdnimg.cn/20190613145729200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>4.MacthTarget场景动画匹配技术<br><img src=\"https://img-blog.csdnimg.cn/20190613145909634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>4.1.核心方法<br><img src=\"https://img-blog.csdnimg.cn/20190613150056658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>4.2.MacthTarget函数细述<br><img src=\"https://img-blog.csdnimg.cn/20190613150207340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>4.3.难点<br><img src=\"https://img-blog.csdnimg.cn/20190613150430468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>+大图导向<br><img src=\"https://img-blog.csdnimg.cn/2019061315050794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>5.相机运动<br><img src=\"https://img-blog.csdnimg.cn/20190613150709467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>+大图导向<br><img src=\"https://img-blog.csdnimg.cn/20190613150735692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>6.学习过程中遇到的问题<br><img src=\"https://img-blog.csdnimg.cn/20190613150827535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>7.函数方法<br><img src=\"https://img-blog.csdnimg.cn/20190613150913675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>8.动画的Inspector<br><img src=\"https://img-blog.csdnimg.cn/20190613151018312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p>﻿1.总索引<br><img src=\"https://img-blog.csdnimg.cn/2019061314131628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>1.1.视图简介<br><img src=\"https://img-blog.csdnimg.cn/20190520144632375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/20190520143240580.png\" alt=\"在这里插入图片描述\"><br>2.动画分类<br><img src=\"https://img-blog.csdnimg.cn/20190613141413854.png\" alt=\"在这里插入图片描述\"></p>\n<p>2.1.普通动画<br><img src=\"https://img-blog.csdnimg.cn/20190613141551260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>    2.2.人物角色动画<br>    <img src=\"https://img-blog.csdnimg.cn/20190613141959166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>    2.2.1.人物角色动画的导入<br>    <img src=\"https://img-blog.csdnimg.cn/20190613142213379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>+大图导向<br>    -骨骼映射视图的打开 <img src=\"https://img-blog.csdnimg.cn/20190531125401236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>    -骨骼映射视图和骨骼映射表的修改<img src=\"https://img-blog.csdnimg.cn/20190531125301603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>-三种动画的导入方式<br><img src=\"https://img-blog.csdnimg.cn/20190613142757765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\">-模型导入注意事项<br><img src=\"https://img-blog.csdnimg.cn/20190613142937598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/20190531130631610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>    <img src=\"https://img-blog.csdnimg.cn/20190531130654193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>2.3.IK动画<br><img src=\"https://img-blog.csdnimg.cn/20190613143849254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>2.4.TimeLine<br><img src=\"https://img-blog.csdnimg.cn/20190613143939800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>+大图导向<br>    -存储<br>    <img src=\"https://img-blog.csdnimg.cn/20190613144055967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>    -Playable Track<br>    <img src=\"https://img-blog.csdnimg.cn/20190613144133197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>3.AnimatorController(状态机)<br><img src=\"https://img-blog.csdnimg.cn/20190613144259619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>3.1.状态机的打开方式<br><img src=\"https://img-blog.csdnimg.cn/20190613144350891.png\" alt=\"在这里插入图片描述\"><br>3.2.Animator视图简介<br><img src=\"https://img-blog.csdnimg.cn/20190613144502456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>3.3.作用<br><img src=\"https://img-blog.csdnimg.cn/20190613144550261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>3.4.精细控制<br><img src=\"https://img-blog.csdnimg.cn/20190613144641944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>+大图导向<br><img src=\"https://img-blog.csdnimg.cn/20190613144744729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>3.5.混合树<br><img src=\"https://img-blog.csdnimg.cn/201906131452528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>3.5.1.四种2D混合树<br><img src=\"https://img-blog.csdnimg.cn/20190613145340965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>3.5.2.大图导向<br> -混合树的创建<br> <img src=\"https://img-blog.csdnimg.cn/20190613145440631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br> -1D混合树Inspector<br> <img src=\"https://img-blog.csdnimg.cn/20190613144953557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br> -2D混合树Inspector<br> <img src=\"https://img-blog.csdnimg.cn/20190613145057715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>3.6.Avatar Mask骨骼遮罩<br><img src=\"https://img-blog.csdnimg.cn/20190613145729200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>4.MacthTarget场景动画匹配技术<br><img src=\"https://img-blog.csdnimg.cn/20190613145909634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>4.1.核心方法<br><img src=\"https://img-blog.csdnimg.cn/20190613150056658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>4.2.MacthTarget函数细述<br><img src=\"https://img-blog.csdnimg.cn/20190613150207340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>4.3.难点<br><img src=\"https://img-blog.csdnimg.cn/20190613150430468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>+大图导向<br><img src=\"https://img-blog.csdnimg.cn/2019061315050794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>5.相机运动<br><img src=\"https://img-blog.csdnimg.cn/20190613150709467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>+大图导向<br><img src=\"https://img-blog.csdnimg.cn/20190613150735692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>6.学习过程中遇到的问题<br><img src=\"https://img-blog.csdnimg.cn/20190613150827535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>7.函数方法<br><img src=\"https://img-blog.csdnimg.cn/20190613150913675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>8.动画的Inspector<br><img src=\"https://img-blog.csdnimg.cn/20190613151018312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n"},{"title":"【Unity3d】Lightmap","date":"2019-08-25T11:40:08.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n![](【Unity3d】Lightmap/Unity_Lightmap.png)","source":"_posts/【Unity3d】Lightmap.md","raw":"---\ntitle: 【Unity3d】Lightmap\ndate: 2019-08-25 19:40:08\ntags: Unity3d\ncategories: 学习笔记\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n![](【Unity3d】Lightmap/Unity_Lightmap.png)","slug":"【Unity3d】Lightmap","published":1,"updated":"2021-02-01T13:34:11.534Z","_id":"ckk9hocaw001gdwr7gjee96ri","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p><img src=\"/2019/08/25/%E3%80%90Unity3d%E3%80%91Lightmap/Unity_Lightmap.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p><img src=\"/2019/08/25/%E3%80%90Unity3d%E3%80%91Lightmap/Unity_Lightmap.png\"></p>\n"},{"title":"【Unity3d】Space","date":"2019-08-25T11:43:04.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n![](【Unity3d】Space/Unity3d_Space.png)","source":"_posts/【Unity3d】Space.md","raw":"---\ntitle: 【Unity3d】Space\ndate: 2019-08-25 19:43:04\ntags: Unity3d\ncategories: 学习笔记\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n![](【Unity3d】Space/Unity3d_Space.png)","slug":"【Unity3d】Space","published":1,"updated":"2021-02-01T13:34:20.804Z","_id":"ckk9hocax001jdwr7fgmhft5u","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p><img src=\"/2019/08/25/%E3%80%90Unity3d%E3%80%91Space/Unity3d_Space.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p><img src=\"/2019/08/25/%E3%80%90Unity3d%E3%80%91Space/Unity3d_Space.png\"></p>\n"},{"title":"【Unity3d】Unity常用技巧笔记","date":"2019-08-27T03:34:44.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 为Image组件添加sprite\n\n![](【Unity3d】Unity常用技巧笔记/Snipaste_2019-08-27_11-35-00.png)","source":"_posts/【Unity3d】Unity常用技巧笔记.md","raw":"---\ntitle: 【Unity3d】Unity常用技巧笔记\ndate: 2019-08-27 11:34:44\ntags: Unity3d\ncategories: 学习笔记\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 为Image组件添加sprite\n\n![](【Unity3d】Unity常用技巧笔记/Snipaste_2019-08-27_11-35-00.png)","slug":"【Unity3d】Unity常用技巧笔记","published":1,"updated":"2021-02-01T13:34:35.317Z","_id":"ckk9hocay001mdwr78pvk8fc4","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h1 id=\"为Image组件添加sprite\"><a href=\"#为Image组件添加sprite\" class=\"headerlink\" title=\"为Image组件添加sprite\"></a>为Image组件添加sprite</h1><p><img src=\"/2019/08/27/%E3%80%90Unity3d%E3%80%91Unity%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%E7%AC%94%E8%AE%B0/Snipaste_2019-08-27_11-35-00.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h1 id=\"为Image组件添加sprite\"><a href=\"#为Image组件添加sprite\" class=\"headerlink\" title=\"为Image组件添加sprite\"></a>为Image组件添加sprite</h1><p><img src=\"/2019/08/27/%E3%80%90Unity3d%E3%80%91Unity%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%E7%AC%94%E8%AE%B0/Snipaste_2019-08-27_11-35-00.png\"></p>\n"},{"title":"【Unity3d】简单的存档与读档","date":"2019-08-23T14:24:08.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />﻿\n\n在Unity3d中，游戏的存档与读档主要由PlayerPrefs类来完成，在Windows下PlayerPrefs存档主要存储在注册表中，路径为HKCU\\Software\\[company name]\\[product name] ，这里的company name和product name由作者自己确定，在Edit->Project Settings->Player中可以设置\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190622143530421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\nPlayerSettings视图\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190622143747327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n那么如何设计游戏存档呢？\n以笔者个人的经验而言，在游戏设计之初，我们就应该想好需要存档的数据，为需要保存的数据或状态设计可供读取的状态标志，以便以后在设计存档时，提供给PlayerPrefs类的方法使用。\nPlayerPrefs类提供如下方法供设计者使用\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190622144312778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n可以看到，PlayerPrefs类中没有提供对bool型数据的存储方法，由此可以看出为需要保存的数据或状态设计可供读取的状态标志的重要性，否则那些由bool型数据确定的状态将无法被存档。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190622151126795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n下面给一段示例代码：\n\n```\n /*\n     * inventory.charge--int--能量电池数量\n     * inventory.playerTransform--float--玩家位置\n     * talk.yeshu--int--man的任务进度\n     * talk.wyeshu--int--women的任务进度\n      */\n    void gameSave() {\n        PlayerPrefs.SetInt(\"charge\", inventory.charge);\n        PlayerPrefs.SetInt(\"yeshu\", talk.yeshu);\n        PlayerPrefs.SetInt(\"wyeshu\", talk.wyeshu);\n        PlayerPrefs.SetFloat(\"playerPosition.x\", inventory.playerTransform.position.x);\n        PlayerPrefs.SetFloat(\"playerPosition.y\", inventory.playerTransform.position.y);\n        PlayerPrefs.SetFloat(\"playerPosition.z\", inventory.playerTransform.position.z);\n        PlayerPrefs.Save();\n    }\n    void gameRead() {\n        if (PlayerPrefs.HasKey(\"charge\"))//存档读取的一般方式\n            inventory.charge = PlayerPrefs.GetInt(\"charge\");\n        if (PlayerPrefs.HasKey(\"yeshu\"))\n            talk.yeshu = PlayerPrefs.GetInt(\"yehsu\");\n        if (PlayerPrefs.HasKey(\"wyeshu\"))\n            talk.wyeshu = PlayerPrefs.GetInt(\"wyeshu\");\n        if (PlayerPrefs.HasKey(\"playerPosition.x\"))\n            x = PlayerPrefs.GetFloat(\"playerPosition.x\");\n        if (PlayerPrefs.HasKey(\"playerPosition.y\"))\n            y = PlayerPrefs.GetFloat(\"playerPosition.y\");\n        if (PlayerPrefs.HasKey(\"playerPosition.z\"))\n            z = PlayerPrefs.GetFloat(\"playerPosition.z\");\n        inventory.playerTransform.position = new Vector3(x, y, z);\n\n    }\n```\n\n那么对于已经产生的注册表我们如何查看呢？\n在Windows下通过注册表编辑器查看注册表，通过Win+R将呼出“运行”，输入“regedit”即可打开注册表编辑器在HKCU\\Software\\[company name]\\[product name] 路径下即可找到我们已经生成的注册表\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190622151747405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)","source":"_posts/【Unity3d】存档与读档.md","raw":"---\ntitle: 【Unity3d】简单的存档与读档\ndate: 2019-08-23 22:24:08\ntags: Unity3d\ncategories: 学习笔记\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />﻿\n\n在Unity3d中，游戏的存档与读档主要由PlayerPrefs类来完成，在Windows下PlayerPrefs存档主要存储在注册表中，路径为HKCU\\Software\\[company name]\\[product name] ，这里的company name和product name由作者自己确定，在Edit->Project Settings->Player中可以设置\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190622143530421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\nPlayerSettings视图\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190622143747327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n那么如何设计游戏存档呢？\n以笔者个人的经验而言，在游戏设计之初，我们就应该想好需要存档的数据，为需要保存的数据或状态设计可供读取的状态标志，以便以后在设计存档时，提供给PlayerPrefs类的方法使用。\nPlayerPrefs类提供如下方法供设计者使用\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190622144312778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n可以看到，PlayerPrefs类中没有提供对bool型数据的存储方法，由此可以看出为需要保存的数据或状态设计可供读取的状态标志的重要性，否则那些由bool型数据确定的状态将无法被存档。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190622151126795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n下面给一段示例代码：\n\n```\n /*\n     * inventory.charge--int--能量电池数量\n     * inventory.playerTransform--float--玩家位置\n     * talk.yeshu--int--man的任务进度\n     * talk.wyeshu--int--women的任务进度\n      */\n    void gameSave() {\n        PlayerPrefs.SetInt(\"charge\", inventory.charge);\n        PlayerPrefs.SetInt(\"yeshu\", talk.yeshu);\n        PlayerPrefs.SetInt(\"wyeshu\", talk.wyeshu);\n        PlayerPrefs.SetFloat(\"playerPosition.x\", inventory.playerTransform.position.x);\n        PlayerPrefs.SetFloat(\"playerPosition.y\", inventory.playerTransform.position.y);\n        PlayerPrefs.SetFloat(\"playerPosition.z\", inventory.playerTransform.position.z);\n        PlayerPrefs.Save();\n    }\n    void gameRead() {\n        if (PlayerPrefs.HasKey(\"charge\"))//存档读取的一般方式\n            inventory.charge = PlayerPrefs.GetInt(\"charge\");\n        if (PlayerPrefs.HasKey(\"yeshu\"))\n            talk.yeshu = PlayerPrefs.GetInt(\"yehsu\");\n        if (PlayerPrefs.HasKey(\"wyeshu\"))\n            talk.wyeshu = PlayerPrefs.GetInt(\"wyeshu\");\n        if (PlayerPrefs.HasKey(\"playerPosition.x\"))\n            x = PlayerPrefs.GetFloat(\"playerPosition.x\");\n        if (PlayerPrefs.HasKey(\"playerPosition.y\"))\n            y = PlayerPrefs.GetFloat(\"playerPosition.y\");\n        if (PlayerPrefs.HasKey(\"playerPosition.z\"))\n            z = PlayerPrefs.GetFloat(\"playerPosition.z\");\n        inventory.playerTransform.position = new Vector3(x, y, z);\n\n    }\n```\n\n那么对于已经产生的注册表我们如何查看呢？\n在Windows下通过注册表编辑器查看注册表，通过Win+R将呼出“运行”，输入“regedit”即可打开注册表编辑器在HKCU\\Software\\[company name]\\[product name] 路径下即可找到我们已经生成的注册表\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190622151747405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)","slug":"【Unity3d】存档与读档","published":1,"updated":"2021-02-01T13:34:42.652Z","_id":"ckk9hocay001pdwr79y3y9y8t","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">﻿\n\n<p>在Unity3d中，游戏的存档与读档主要由PlayerPrefs类来完成，在Windows下PlayerPrefs存档主要存储在注册表中，路径为HKCU\\Software[company name][product name] ，这里的company name和product name由作者自己确定，在Edit-&gt;Project Settings-&gt;Player中可以设置<br><img src=\"https://img-blog.csdnimg.cn/20190622143530421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>PlayerSettings视图<br><img src=\"https://img-blog.csdnimg.cn/20190622143747327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>那么如何设计游戏存档呢？<br>以笔者个人的经验而言，在游戏设计之初，我们就应该想好需要存档的数据，为需要保存的数据或状态设计可供读取的状态标志，以便以后在设计存档时，提供给PlayerPrefs类的方法使用。<br>PlayerPrefs类提供如下方法供设计者使用<br><img src=\"https://img-blog.csdnimg.cn/20190622144312778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>可以看到，PlayerPrefs类中没有提供对bool型数据的存储方法，由此可以看出为需要保存的数据或状态设计可供读取的状态标志的重要性，否则那些由bool型数据确定的状态将无法被存档。<br><img src=\"https://img-blog.csdnimg.cn/20190622151126795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>下面给一段示例代码：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs reasonml\"><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">    * inventory.charge--int--能量电池数量</span><br><span class=\"hljs-comment\">    * inventory.playerTransform--float--玩家位置</span><br><span class=\"hljs-comment\">    * talk.yeshu--int--man的任务进度</span><br><span class=\"hljs-comment\">    * talk.wyeshu--int--women的任务进度</span><br><span class=\"hljs-comment\">     */</span><br>   void game<span class=\"hljs-constructor\">Save()</span> &#123;<br>       PlayerPrefs.<span class=\"hljs-constructor\">SetInt(<span class=\"hljs-string\">&quot;charge&quot;</span>, <span class=\"hljs-params\">inventory</span>.<span class=\"hljs-params\">charge</span>)</span>;<br>       PlayerPrefs.<span class=\"hljs-constructor\">SetInt(<span class=\"hljs-string\">&quot;yeshu&quot;</span>, <span class=\"hljs-params\">talk</span>.<span class=\"hljs-params\">yeshu</span>)</span>;<br>       PlayerPrefs.<span class=\"hljs-constructor\">SetInt(<span class=\"hljs-string\">&quot;wyeshu&quot;</span>, <span class=\"hljs-params\">talk</span>.<span class=\"hljs-params\">wyeshu</span>)</span>;<br>       PlayerPrefs.<span class=\"hljs-constructor\">SetFloat(<span class=\"hljs-string\">&quot;playerPosition.x&quot;</span>, <span class=\"hljs-params\">inventory</span>.<span class=\"hljs-params\">playerTransform</span>.<span class=\"hljs-params\">position</span>.<span class=\"hljs-params\">x</span>)</span>;<br>       PlayerPrefs.<span class=\"hljs-constructor\">SetFloat(<span class=\"hljs-string\">&quot;playerPosition.y&quot;</span>, <span class=\"hljs-params\">inventory</span>.<span class=\"hljs-params\">playerTransform</span>.<span class=\"hljs-params\">position</span>.<span class=\"hljs-params\">y</span>)</span>;<br>       PlayerPrefs.<span class=\"hljs-constructor\">SetFloat(<span class=\"hljs-string\">&quot;playerPosition.z&quot;</span>, <span class=\"hljs-params\">inventory</span>.<span class=\"hljs-params\">playerTransform</span>.<span class=\"hljs-params\">position</span>.<span class=\"hljs-params\">z</span>)</span>;<br>       PlayerPrefs.<span class=\"hljs-constructor\">Save()</span>;<br>   &#125;<br>   void game<span class=\"hljs-constructor\">Read()</span> &#123;<br>       <span class=\"hljs-keyword\">if</span> (PlayerPrefs.<span class=\"hljs-constructor\">HasKey(<span class=\"hljs-string\">&quot;charge&quot;</span>)</span>)<span class=\"hljs-comment\">//存档读取的一般方式</span><br>           inventory.charge = PlayerPrefs.<span class=\"hljs-constructor\">GetInt(<span class=\"hljs-string\">&quot;charge&quot;</span>)</span>;<br>       <span class=\"hljs-keyword\">if</span> (PlayerPrefs.<span class=\"hljs-constructor\">HasKey(<span class=\"hljs-string\">&quot;yeshu&quot;</span>)</span>)<br>           talk.yeshu = PlayerPrefs.<span class=\"hljs-constructor\">GetInt(<span class=\"hljs-string\">&quot;yehsu&quot;</span>)</span>;<br>       <span class=\"hljs-keyword\">if</span> (PlayerPrefs.<span class=\"hljs-constructor\">HasKey(<span class=\"hljs-string\">&quot;wyeshu&quot;</span>)</span>)<br>           talk.wyeshu = PlayerPrefs.<span class=\"hljs-constructor\">GetInt(<span class=\"hljs-string\">&quot;wyeshu&quot;</span>)</span>;<br>       <span class=\"hljs-keyword\">if</span> (PlayerPrefs.<span class=\"hljs-constructor\">HasKey(<span class=\"hljs-string\">&quot;playerPosition.x&quot;</span>)</span>)<br>           x = PlayerPrefs.<span class=\"hljs-constructor\">GetFloat(<span class=\"hljs-string\">&quot;playerPosition.x&quot;</span>)</span>;<br>       <span class=\"hljs-keyword\">if</span> (PlayerPrefs.<span class=\"hljs-constructor\">HasKey(<span class=\"hljs-string\">&quot;playerPosition.y&quot;</span>)</span>)<br>           y = PlayerPrefs.<span class=\"hljs-constructor\">GetFloat(<span class=\"hljs-string\">&quot;playerPosition.y&quot;</span>)</span>;<br>       <span class=\"hljs-keyword\">if</span> (PlayerPrefs.<span class=\"hljs-constructor\">HasKey(<span class=\"hljs-string\">&quot;playerPosition.z&quot;</span>)</span>)<br>           z = PlayerPrefs.<span class=\"hljs-constructor\">GetFloat(<span class=\"hljs-string\">&quot;playerPosition.z&quot;</span>)</span>;<br>       inventory.playerTransform.position = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Vector3(<span class=\"hljs-params\">x</span>, <span class=\"hljs-params\">y</span>, <span class=\"hljs-params\">z</span>)</span>;<br><br>   &#125;<br></code></pre></td></tr></table></figure>\n<p>那么对于已经产生的注册表我们如何查看呢？<br>在Windows下通过注册表编辑器查看注册表，通过Win+R将呼出“运行”，输入“regedit”即可打开注册表编辑器在HKCU\\Software[company name][product name] 路径下即可找到我们已经生成的注册表<br><img src=\"https://img-blog.csdnimg.cn/20190622151747405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">﻿\n\n<p>在Unity3d中，游戏的存档与读档主要由PlayerPrefs类来完成，在Windows下PlayerPrefs存档主要存储在注册表中，路径为HKCU\\Software[company name][product name] ，这里的company name和product name由作者自己确定，在Edit-&gt;Project Settings-&gt;Player中可以设置<br><img src=\"https://img-blog.csdnimg.cn/20190622143530421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>PlayerSettings视图<br><img src=\"https://img-blog.csdnimg.cn/20190622143747327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>那么如何设计游戏存档呢？<br>以笔者个人的经验而言，在游戏设计之初，我们就应该想好需要存档的数据，为需要保存的数据或状态设计可供读取的状态标志，以便以后在设计存档时，提供给PlayerPrefs类的方法使用。<br>PlayerPrefs类提供如下方法供设计者使用<br><img src=\"https://img-blog.csdnimg.cn/20190622144312778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>可以看到，PlayerPrefs类中没有提供对bool型数据的存储方法，由此可以看出为需要保存的数据或状态设计可供读取的状态标志的重要性，否则那些由bool型数据确定的状态将无法被存档。<br><img src=\"https://img-blog.csdnimg.cn/20190622151126795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>下面给一段示例代码：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs reasonml\"><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">    * inventory.charge--int--能量电池数量</span><br><span class=\"hljs-comment\">    * inventory.playerTransform--float--玩家位置</span><br><span class=\"hljs-comment\">    * talk.yeshu--int--man的任务进度</span><br><span class=\"hljs-comment\">    * talk.wyeshu--int--women的任务进度</span><br><span class=\"hljs-comment\">     */</span><br>   void game<span class=\"hljs-constructor\">Save()</span> &#123;<br>       PlayerPrefs.<span class=\"hljs-constructor\">SetInt(<span class=\"hljs-string\">&quot;charge&quot;</span>, <span class=\"hljs-params\">inventory</span>.<span class=\"hljs-params\">charge</span>)</span>;<br>       PlayerPrefs.<span class=\"hljs-constructor\">SetInt(<span class=\"hljs-string\">&quot;yeshu&quot;</span>, <span class=\"hljs-params\">talk</span>.<span class=\"hljs-params\">yeshu</span>)</span>;<br>       PlayerPrefs.<span class=\"hljs-constructor\">SetInt(<span class=\"hljs-string\">&quot;wyeshu&quot;</span>, <span class=\"hljs-params\">talk</span>.<span class=\"hljs-params\">wyeshu</span>)</span>;<br>       PlayerPrefs.<span class=\"hljs-constructor\">SetFloat(<span class=\"hljs-string\">&quot;playerPosition.x&quot;</span>, <span class=\"hljs-params\">inventory</span>.<span class=\"hljs-params\">playerTransform</span>.<span class=\"hljs-params\">position</span>.<span class=\"hljs-params\">x</span>)</span>;<br>       PlayerPrefs.<span class=\"hljs-constructor\">SetFloat(<span class=\"hljs-string\">&quot;playerPosition.y&quot;</span>, <span class=\"hljs-params\">inventory</span>.<span class=\"hljs-params\">playerTransform</span>.<span class=\"hljs-params\">position</span>.<span class=\"hljs-params\">y</span>)</span>;<br>       PlayerPrefs.<span class=\"hljs-constructor\">SetFloat(<span class=\"hljs-string\">&quot;playerPosition.z&quot;</span>, <span class=\"hljs-params\">inventory</span>.<span class=\"hljs-params\">playerTransform</span>.<span class=\"hljs-params\">position</span>.<span class=\"hljs-params\">z</span>)</span>;<br>       PlayerPrefs.<span class=\"hljs-constructor\">Save()</span>;<br>   &#125;<br>   void game<span class=\"hljs-constructor\">Read()</span> &#123;<br>       <span class=\"hljs-keyword\">if</span> (PlayerPrefs.<span class=\"hljs-constructor\">HasKey(<span class=\"hljs-string\">&quot;charge&quot;</span>)</span>)<span class=\"hljs-comment\">//存档读取的一般方式</span><br>           inventory.charge = PlayerPrefs.<span class=\"hljs-constructor\">GetInt(<span class=\"hljs-string\">&quot;charge&quot;</span>)</span>;<br>       <span class=\"hljs-keyword\">if</span> (PlayerPrefs.<span class=\"hljs-constructor\">HasKey(<span class=\"hljs-string\">&quot;yeshu&quot;</span>)</span>)<br>           talk.yeshu = PlayerPrefs.<span class=\"hljs-constructor\">GetInt(<span class=\"hljs-string\">&quot;yehsu&quot;</span>)</span>;<br>       <span class=\"hljs-keyword\">if</span> (PlayerPrefs.<span class=\"hljs-constructor\">HasKey(<span class=\"hljs-string\">&quot;wyeshu&quot;</span>)</span>)<br>           talk.wyeshu = PlayerPrefs.<span class=\"hljs-constructor\">GetInt(<span class=\"hljs-string\">&quot;wyeshu&quot;</span>)</span>;<br>       <span class=\"hljs-keyword\">if</span> (PlayerPrefs.<span class=\"hljs-constructor\">HasKey(<span class=\"hljs-string\">&quot;playerPosition.x&quot;</span>)</span>)<br>           x = PlayerPrefs.<span class=\"hljs-constructor\">GetFloat(<span class=\"hljs-string\">&quot;playerPosition.x&quot;</span>)</span>;<br>       <span class=\"hljs-keyword\">if</span> (PlayerPrefs.<span class=\"hljs-constructor\">HasKey(<span class=\"hljs-string\">&quot;playerPosition.y&quot;</span>)</span>)<br>           y = PlayerPrefs.<span class=\"hljs-constructor\">GetFloat(<span class=\"hljs-string\">&quot;playerPosition.y&quot;</span>)</span>;<br>       <span class=\"hljs-keyword\">if</span> (PlayerPrefs.<span class=\"hljs-constructor\">HasKey(<span class=\"hljs-string\">&quot;playerPosition.z&quot;</span>)</span>)<br>           z = PlayerPrefs.<span class=\"hljs-constructor\">GetFloat(<span class=\"hljs-string\">&quot;playerPosition.z&quot;</span>)</span>;<br>       inventory.playerTransform.position = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Vector3(<span class=\"hljs-params\">x</span>, <span class=\"hljs-params\">y</span>, <span class=\"hljs-params\">z</span>)</span>;<br><br>   &#125;<br></code></pre></td></tr></table></figure>\n<p>那么对于已经产生的注册表我们如何查看呢？<br>在Windows下通过注册表编辑器查看注册表，通过Win+R将呼出“运行”，输入“regedit”即可打开注册表编辑器在HKCU\\Software[company name][product name] 路径下即可找到我们已经生成的注册表<br><img src=\"https://img-blog.csdnimg.cn/20190622151747405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n"},{"title":"【Unity3d】游戏截屏","date":"2019-08-23T14:26:13.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />﻿\n\n在Unity3d中游戏截屏操作比较简单，主要使用通过Application类下的CaptureScreenhot方法实现：\n\n```\nif (Input.GetKeyDown(KeyCode.P)) {\n            Application.CaptureScreenshot(\"截图\" +screenhotNom+\".jpg\");\n            screenhotNom++;//截图序号\n        }\n```\n\n截取的图片以设计者规定名字存储在与exe文件一起生成的的Data文件下，没有导出的项目直接存储到工程文件夹下\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190622155156312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n","source":"_posts/【Unity3d】游戏截屏.md","raw":"---\ntitle: 【Unity3d】游戏截屏\ndate: 2019-08-23 22:26:13\ntags: Unity3d\ncategories: 学习笔记\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />﻿\n\n在Unity3d中游戏截屏操作比较简单，主要使用通过Application类下的CaptureScreenhot方法实现：\n\n```\nif (Input.GetKeyDown(KeyCode.P)) {\n            Application.CaptureScreenshot(\"截图\" +screenhotNom+\".jpg\");\n            screenhotNom++;//截图序号\n        }\n```\n\n截取的图片以设计者规定名字存储在与exe文件一起生成的的Data文件下，没有导出的项目直接存储到工程文件夹下\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190622155156312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n","slug":"【Unity3d】游戏截屏","published":1,"updated":"2021-02-01T13:34:49.735Z","_id":"ckk9hocaz001sdwr73i2j20dm","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">﻿\n\n<p>在Unity3d中游戏截屏操作比较简单，主要使用通过Application类下的CaptureScreenhot方法实现：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs reasonml\"><span class=\"hljs-keyword\">if</span> (Input.<span class=\"hljs-constructor\">GetKeyDown(KeyCode.P)</span>) &#123;<br>            Application.<span class=\"hljs-constructor\">CaptureScreenshot(<span class=\"hljs-string\">&quot;截图&quot;</span> +<span class=\"hljs-params\">screenhotNom</span>+<span class=\"hljs-string\">&quot;.jpg&quot;</span>)</span>;<br>            screenhotNom++;<span class=\"hljs-comment\">//截图序号</span><br>        &#125;<br></code></pre></td></tr></table></figure>\n<p>截取的图片以设计者规定名字存储在与exe文件一起生成的的Data文件下，没有导出的项目直接存储到工程文件夹下<br><img src=\"https://img-blog.csdnimg.cn/20190622155156312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">﻿\n\n<p>在Unity3d中游戏截屏操作比较简单，主要使用通过Application类下的CaptureScreenhot方法实现：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs reasonml\"><span class=\"hljs-keyword\">if</span> (Input.<span class=\"hljs-constructor\">GetKeyDown(KeyCode.P)</span>) &#123;<br>            Application.<span class=\"hljs-constructor\">CaptureScreenshot(<span class=\"hljs-string\">&quot;截图&quot;</span> +<span class=\"hljs-params\">screenhotNom</span>+<span class=\"hljs-string\">&quot;.jpg&quot;</span>)</span>;<br>            screenhotNom++;<span class=\"hljs-comment\">//截图序号</span><br>        &#125;<br></code></pre></td></tr></table></figure>\n<p>截取的图片以设计者规定名字存储在与exe文件一起生成的的Data文件下，没有导出的项目直接存储到工程文件夹下<br><img src=\"https://img-blog.csdnimg.cn/20190622155156312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n"},{"title":"【shell】shell基础","date":"2019-09-30T01:02:57.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n由于本文内有大量的markdwon转义未处理，导致远程同步不通过，所以本文引入外部ULR预览\n\n<https://blog.csdn.net/qq_39108291/article/details/101797244>\n\n","source":"_posts/【shell】shell基础.md","raw":"---\ntitle: 【shell】shell基础\ndate: 2019-09-30 09:02:57\ntags: shell\ncategories: 学习笔记\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n由于本文内有大量的markdwon转义未处理，导致远程同步不通过，所以本文引入外部ULR预览\n\n<https://blog.csdn.net/qq_39108291/article/details/101797244>\n\n","slug":"【shell】shell基础","published":1,"updated":"2021-02-01T13:32:49.325Z","_id":"ckk9hocb0001vdwr79ntm2hb7","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p>由于本文内有大量的markdwon转义未处理，导致远程同步不通过，所以本文引入外部ULR预览</p>\n<p><a href=\"https://blog.csdn.net/qq_39108291/article/details/101797244\">https://blog.csdn.net/qq_39108291/article/details/101797244</a></p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p>由于本文内有大量的markdwon转义未处理，导致远程同步不通过，所以本文引入外部ULR预览</p>\n<p><a href=\"https://blog.csdn.net/qq_39108291/article/details/101797244\">https://blog.csdn.net/qq_39108291/article/details/101797244</a></p>\n"},{"title":"【待解决】一些待解决的难题","date":"2019-10-10T14:15:48.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n这里记录一些待解决的程序难题\n\n# 1.\n\n1.这两种内存分配的方式，有什么不一样，\n2.初始化的s最后结果有什么不一样\n\n```C++\nint main()\n{\n\tstruct a {\n\t\tint id;\n\t\tstring s;\n\t};\n\ta *ptr1 = new a();\n\tptr1->s = \"hello\";\n\ta *ptr2 = (a*)malloc(sizeof(a));\n\tptr2->s = \"hello\";//这一句却会报异常，为什么？\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n\n# 2.\n\nList容器中empty()判空和size()==0判空有什么不同\n\n# 3.\n\n为什么函数外的指针的值没有变化\n\n```C++\nvoid getmemory(char *p)\n{\n\tp = new char[100];\n\tstrcpy_s(p,12, \"hello world\");\n\tprintf(\"%s\\n\", p);\n\treturn;\n}\nint main()\n{\n\tchar *p = NULL;\n\tgetmemory(p);\n\tprintf(\"%s\\n\", p);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n而下面代码却可以改变\n\n```C++\nvoid getmemory(char **p)\n{\n\t*p = (char*)malloc(100);\n\tstrcpy_s(*p, 12,\"hello world\");\n\tprintf(\"%s\\n\", *p);\n\treturn;\n}\nint main()\n{\n\tchar *p = NULL;\n\tgetmemory(&p);\n\tprintf(\"%s\\n\", p);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n# 4.\n\nUE4热加载\n\n# 5.\n\nUE4 delegate，UScriptStruct，UProperty\n\n# 6.\n\n寻路算法","source":"_posts/【待解决】一些待解决的难题.md","raw":"---\ntitle: 【待解决】一些待解决的难题\ndate: 2019-10-10 22:15:48\ntags: 程序问题\ncategories: 待解决\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n这里记录一些待解决的程序难题\n\n# 1.\n\n1.这两种内存分配的方式，有什么不一样，\n2.初始化的s最后结果有什么不一样\n\n```C++\nint main()\n{\n\tstruct a {\n\t\tint id;\n\t\tstring s;\n\t};\n\ta *ptr1 = new a();\n\tptr1->s = \"hello\";\n\ta *ptr2 = (a*)malloc(sizeof(a));\n\tptr2->s = \"hello\";//这一句却会报异常，为什么？\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n\n# 2.\n\nList容器中empty()判空和size()==0判空有什么不同\n\n# 3.\n\n为什么函数外的指针的值没有变化\n\n```C++\nvoid getmemory(char *p)\n{\n\tp = new char[100];\n\tstrcpy_s(p,12, \"hello world\");\n\tprintf(\"%s\\n\", p);\n\treturn;\n}\nint main()\n{\n\tchar *p = NULL;\n\tgetmemory(p);\n\tprintf(\"%s\\n\", p);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n而下面代码却可以改变\n\n```C++\nvoid getmemory(char **p)\n{\n\t*p = (char*)malloc(100);\n\tstrcpy_s(*p, 12,\"hello world\");\n\tprintf(\"%s\\n\", *p);\n\treturn;\n}\nint main()\n{\n\tchar *p = NULL;\n\tgetmemory(&p);\n\tprintf(\"%s\\n\", p);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n# 4.\n\nUE4热加载\n\n# 5.\n\nUE4 delegate，UScriptStruct，UProperty\n\n# 6.\n\n寻路算法","slug":"【待解决】一些待解决的难题","published":1,"updated":"2021-05-13T06:01:29.095Z","_id":"ckk9hocb1001xdwr744r64o2j","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p>这里记录一些待解决的程序难题</p>\n<h1 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1.\"></a>1.</h1><p>1.这两种内存分配的方式，有什么不一样，<br>2.初始化的s最后结果有什么不一样</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">a</span> &#123;</span><br>\t\t<span class=\"hljs-keyword\">int</span> id;<br>\t\t<span class=\"hljs-built_in\">string</span> s;<br>\t&#125;;<br>\ta *ptr1 = <span class=\"hljs-keyword\">new</span> a();<br>\tptr1-&gt;s = <span class=\"hljs-string\">&quot;hello&quot;</span>;<br>\ta *ptr2 = (a*)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(a));<br>\tptr2-&gt;s = <span class=\"hljs-string\">&quot;hello&quot;</span>;<span class=\"hljs-comment\">//这一句却会报异常，为什么？</span><br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<h1 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2.\"></a>2.</h1><p>List容器中empty()判空和size()==0判空有什么不同</p>\n<h1 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"3.\"></a>3.</h1><p>为什么函数外的指针的值没有变化</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">getmemory</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">char</span> *p)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tp = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">char</span>[<span class=\"hljs-number\">100</span>];<br>\tstrcpy_s(p,<span class=\"hljs-number\">12</span>, <span class=\"hljs-string\">&quot;hello world&quot;</span>);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s\\n&quot;</span>, p);<br>\t<span class=\"hljs-keyword\">return</span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">char</span> *p = <span class=\"hljs-literal\">NULL</span>;<br>\tgetmemory(p);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s\\n&quot;</span>, p);<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>而下面代码却可以改变</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">getmemory</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">char</span> **p)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t*p = (<span class=\"hljs-keyword\">char</span>*)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-number\">100</span>);<br>\tstrcpy_s(*p, <span class=\"hljs-number\">12</span>,<span class=\"hljs-string\">&quot;hello world&quot;</span>);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s\\n&quot;</span>, *p);<br>\t<span class=\"hljs-keyword\">return</span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">char</span> *p = <span class=\"hljs-literal\">NULL</span>;<br>\tgetmemory(&amp;p);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s\\n&quot;</span>, p);<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"4\"><a href=\"#4\" class=\"headerlink\" title=\"4.\"></a>4.</h1><p>UE4热加载</p>\n<h1 id=\"5\"><a href=\"#5\" class=\"headerlink\" title=\"5.\"></a>5.</h1><p>UE4 delegate，UScriptStruct，UProperty</p>\n<h1 id=\"6\"><a href=\"#6\" class=\"headerlink\" title=\"6.\"></a>6.</h1><p>寻路算法</p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p>这里记录一些待解决的程序难题</p>\n<h1 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1.\"></a>1.</h1><p>1.这两种内存分配的方式，有什么不一样，<br>2.初始化的s最后结果有什么不一样</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">a</span> &#123;</span><br>\t\t<span class=\"hljs-keyword\">int</span> id;<br>\t\t<span class=\"hljs-built_in\">string</span> s;<br>\t&#125;;<br>\ta *ptr1 = <span class=\"hljs-keyword\">new</span> a();<br>\tptr1-&gt;s = <span class=\"hljs-string\">&quot;hello&quot;</span>;<br>\ta *ptr2 = (a*)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(a));<br>\tptr2-&gt;s = <span class=\"hljs-string\">&quot;hello&quot;</span>;<span class=\"hljs-comment\">//这一句却会报异常，为什么？</span><br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<h1 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2.\"></a>2.</h1><p>List容器中empty()判空和size()==0判空有什么不同</p>\n<h1 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"3.\"></a>3.</h1><p>为什么函数外的指针的值没有变化</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">getmemory</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">char</span> *p)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tp = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">char</span>[<span class=\"hljs-number\">100</span>];<br>\tstrcpy_s(p,<span class=\"hljs-number\">12</span>, <span class=\"hljs-string\">&quot;hello world&quot;</span>);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s\\n&quot;</span>, p);<br>\t<span class=\"hljs-keyword\">return</span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">char</span> *p = <span class=\"hljs-literal\">NULL</span>;<br>\tgetmemory(p);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s\\n&quot;</span>, p);<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>而下面代码却可以改变</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">getmemory</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">char</span> **p)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t*p = (<span class=\"hljs-keyword\">char</span>*)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-number\">100</span>);<br>\tstrcpy_s(*p, <span class=\"hljs-number\">12</span>,<span class=\"hljs-string\">&quot;hello world&quot;</span>);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s\\n&quot;</span>, *p);<br>\t<span class=\"hljs-keyword\">return</span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">char</span> *p = <span class=\"hljs-literal\">NULL</span>;<br>\tgetmemory(&amp;p);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s\\n&quot;</span>, p);<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"4\"><a href=\"#4\" class=\"headerlink\" title=\"4.\"></a>4.</h1><p>UE4热加载</p>\n<h1 id=\"5\"><a href=\"#5\" class=\"headerlink\" title=\"5.\"></a>5.</h1><p>UE4 delegate，UScriptStruct，UProperty</p>\n<h1 id=\"6\"><a href=\"#6\" class=\"headerlink\" title=\"6.\"></a>6.</h1><p>寻路算法</p>\n"},{"title":"【日记】在武汉跑秋招的日子","date":"2019-10-12T09:06:06.000Z","password":"snoopy","abstract":"这里不可以看哦！","message":"绕路吧！","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n​\t今天是十月十二号，阴，天灰蒙蒙的，仿佛和我此时的心境一般，此时我心身具备，虽然在国庆结束的前一天我拿到了第一个offer，可能也是唯一的一个offer了，尽管这份工作是那么的不尽人意。\n\n![](【日记】在武汉跑秋招的日子/QQ图片20191012190626.jpg)\n\n​\t我呢，现在是三峡大学计算机与信息学院在校2020应届生，为了秋招我从今年5月份开始准备，当时打算的就业方向是Unity3d客户端开发，哎！现在想想当时自己是不是太幼稚了，完全没有考虑过就业形势，而是全凭自己的兴趣一头扎入进去，就开始不闻窗外的苦学。结果真正到了秋招的时候，自己完全蒙了，去武汉大学和华中科技大学的校招的游戏公司一双手数足以，去三峡大学招聘的只需要三个手指😂。结果可想而知，九月份奋斗了一个月，也就吃了一个月的灰。\n\n![](【日记】在武汉跑秋招的日子/QQ图片20191012190452.jpg)\n\n​\t我东谷伯伯说的好啊，穷人的孩子，不该有梦想，带着梦想的穷孩子只会过得很累。家里没有足够的经济支持你去追求这些梦想。穷人的孩子更多的应该是考虑现实，而不是追求兴趣，选专业就应该选好就业的，无论兴趣如何。因为生活在一个穷困的家庭，没有钱是万万不能的。你需要的是尽早的就业来当起这个家。可笑的是，我现在才明白，难道我选择专业的时候选择了兴趣，选择就业的时候选择兴趣，真的错了吗？\n\n​\t九月五号，我和儒哥踏上了前往武汉的动车，两个小时的动车路程加一个小时的地铁路程加十几分钟的滴滴路程，我们来的早已预约好的租房“武汉市洪山区竹苑小区四栋一单元302号房”，涉世不深的我第一次被社会割肉，房租交了1100软妹币，押金交了1300软妹币，大出血啊！从家里带的5000软妹币瞬间去掉一半，更可恶的是，第一个星期进去仅仅五天，水电费就花掉50，一个月下来水电费足足花了200。\n\n![](【日记】在武汉跑秋招的日子/QQ图片20191012190616.jpg)\n\n​\t入住第二天，上午我们来到了武大，只能说名校果然是名校，那环境，那楼宇，那面积，那宿舍都不是普通本科能比的，这天正好碰到武大有一场音乐艺术展，于是就去，里面一排排的钢琴，尽管看不懂，但是依旧觉得牛逼。纵穿武大，便来到了东湖，不得不说武汉的风景确实没得说。下午我们来到了华科，华科也不是一般的大，而且规划工整，那路是横七竖八，笔直笔直的，那绿植覆盖面积，走在校园里几乎不用晒太阳。我们也是骑着一个哈罗单车足足逛了一下午。到了晚上便开始了我们来到武行的第一场宣讲会--oppo华科宣讲会。\n\n![](【日记】在武汉跑秋招的日子/Snipaste_2019-09-08_09-15-55.png)\n\n![](【日记】在武汉跑秋招的日子/Snipaste_2019-09-08_09-23-19.png)\n\n![](【日记】在武汉跑秋招的日子/QQ图片20191012190552.jpg)\n\n![](【日记】在武汉跑秋招的日子/QQ图片20191012190600.jpg)\n\n![](【日记】在武汉跑秋招的日子/QQ图片20191012190518.jpg)\n\n![](【日记】在武汉跑秋招的日子/Snipaste_2019-09-08_09-28-22.png)\n\n![](【日记】在武汉跑秋招的日子/Snipaste_2019-09-08_09-34-22.png)\n\n​\t只有当自己切真切实的接触到了这些名校，切真切实的接触到了名校中的那些人，才会明白在大学四年里所说的那些名校差距原来如此之大。可能是高中三年太辛苦，亦或是预科一年太放纵，大学三年啊，我终究是没有学会多少东西。可这又怎能让我信服呢？我真的没有学到什么东西吗？大一，因为读了一年预科，我不再是出来扎到，于是乎我做了班级负责人，然后觉得太累，于是正式选举班委时选择了副班长，学生组织，我选择了院新媒体。一年来，我参加比赛，制作视频，最后也是拿了个校三等奖学金。大二，我成了新媒体摄像部的部长，我把精力都用来管理部门，教导干事，于是乎我们部门成了优秀部门。同年借着新媒体和宋哥，我们成立的木瓜传媒工作室，对外接单，曾三次远赴神农架，总盈利13000软妹币，同样也顺利拿下了那年的三等奖学金。大三,我和儒哥一起在必胜客兼职了半年，同时我做到了经济独立11一个月，差一个月的经济独立一年。同时在富云达学习了半年，也开始为找工作而忧心，大三呆在学校的时间确实少了很多，尽管没拿到奖学金，但是成绩确实是提升了很多。如此充实的大学生活，我真的什么也没学到吗？\n\n![](【日记】在武汉跑秋招的日子/QQ图片20191012190504.jpg)\n\n​\t事实证明，我真的很差劲，九月份，我和儒哥都开始了自己的秋招之旅，一整个九月，我跑了好几家游戏公司，成都摩丰，长沙的沃尔信息，武汉的微派网络，众娱，广州的速游网络，北京的多乐游戏，结果是一家没进。反观儒哥，他搞Web，结果一面就进了快客云，实习工资3700。顿时我被打击到哭泣，对没错因为恰逢中秋，我哭了，在和妈打的电话中哭得很彻底。这一次我想家了，想家想到了骨子里，这还是自从我小学六年级第一次离开父母留校寄宿以来最想家的一次，即使当年预科父亲送我来到宜昌离开我回家那次都没有这一次那么想家。想家也许是每一个在外漂泊的游子必定要经历的吧。\n\n​\t第二天我买上了回家的车票，早上九点到晚上十一点，我到家了，我终于暂时卸下了三个多月来的忧心忡忡。母亲知道我要回来就上山区采了皇竹笋，做了一顿竹笋酿，那是我这么久以来吃的最无忧无虑的一顿，心里没有忧愁，嘴里尽是美味，对面坐者母亲，顶上是家，可能这才是我想要的生活吧。每天能有一些时间在家陪陪父母，也不失是一种幸福。父母操劳了半辈子，送我和弟弟读书，弟弟不争气跑去复读了，我作为长子找工作的事本不应该让父母操心，因为父母操心也不打劲，只能为我干着急。于是我开始反思，走游戏开发这条路我真的走对了吗？我是不是应该换条路走呢？比如C++。\n\n![](【日记】在武汉跑秋招的日子/QQ图片20191012190448.jpg)\n\n![](【日记】在武汉跑秋招的日子/QQ图片20191012190414.jpg)\n\n![](【日记】在武汉跑秋招的日子/QQ图片20191012190444.jpg)\n\n​\t在家里的几天是我整个大三以来过的最舒心的几天，可是时间转瞬即逝，我又踏上了秋招之旅。九月25日，依旧没找到工作的我决定返校回去深造C++，然后国庆之后转行寻找C++的岗位。回到学校才发现学生时代的生活真的很美好，相比社会的残酷，校园原来真的是一个乐园，只是十几年的学生生活让我忽略了这一点。只剩最后一年的大学生活了，现在明白过来也为时不晚，且行还须且珍惜。\n\n​\t国庆过了，房租也到期了，我开始了寄居生活，儒哥找到了工作于是就在公司附近租了个房子，我便开始寄居在儒哥的房子里，十月七号，我拿到了第一个offer，蛛网传媒，这是一家半个游戏公司的公司，因为他们做游戏却不是做自己的游戏，并且他们不仅仅做游戏，还做其他的软件，类似一家外包公司。实习工资3000软妹币加餐补300。也许是我自己把待遇开低了，唉~也罢，谁让我九月份受够了打击呢？于此同时九月份投的很多家公司也都邮来了面试通知，我去了，却都凉凉了，在和我们班那些去华清远见培训的同学聊面试题的时候，我才知道自己的C++是有多菜，我真的没有什么可值得骄傲的，可笑的是，八月的时候我居然笑着说“找工作不难，难的是找一个好工作”，我啊，似乎是出来些什么问题了。\n\n![](【日记】在武汉跑秋招的日子/QQ图片20191012190638.jpg)\n\n​\t今天是十月十二号，我已经和房东商量好了，明天搬过去，住在武汉市银河湾，离公司蛮近的。后天就要去上班了，我的进修之旅还远没结束。\n\n​\t经历了这么多，那些平时不爱学习，成绩不好的同学反而找到了一个不错的工作，我这个自以为比他们优秀的学生却秋招那么惨，最终去了一家连自己都不觉得有多好的小公司，尽管我已经很努力的准备了三个月，很努力的学了三个月，可最终的结果却是那么的不尽人意，我很失落，我有问题，我的身上肯定出了什么问题，以至于我得到了一个如此不满意的结果。\n\n![](【日记】在武汉跑秋招的日子/QQ图片20191012190641.jpg)\n\n​\t也许生活就是这样雕琢一个孩子的吧，这次秋招我才意识到，自己眼中的优秀就是个屁，也许我该拾起初高中的那股劲了，大学的自己似乎过于放纵了，以至于成就了一个失败的自己。我的身上出问题了，我要找出来，我不比他们差，我不应该如此生活，我需要变强的，变得很强很强。现在得我真的没有资格说累，“累”，那是给别人说的。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/【日记】在武汉跑秋招的日子.md","raw":"---\ntitle: 【日记】在武汉跑秋招的日子\ndate: 2019-10-12 17:06:06\ntags: 大事件\ncategories: 日记\npassword: snoopy\nabstract: 这里不可以看哦！\nmessage: 绕路吧！\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n​\t今天是十月十二号，阴，天灰蒙蒙的，仿佛和我此时的心境一般，此时我心身具备，虽然在国庆结束的前一天我拿到了第一个offer，可能也是唯一的一个offer了，尽管这份工作是那么的不尽人意。\n\n![](【日记】在武汉跑秋招的日子/QQ图片20191012190626.jpg)\n\n​\t我呢，现在是三峡大学计算机与信息学院在校2020应届生，为了秋招我从今年5月份开始准备，当时打算的就业方向是Unity3d客户端开发，哎！现在想想当时自己是不是太幼稚了，完全没有考虑过就业形势，而是全凭自己的兴趣一头扎入进去，就开始不闻窗外的苦学。结果真正到了秋招的时候，自己完全蒙了，去武汉大学和华中科技大学的校招的游戏公司一双手数足以，去三峡大学招聘的只需要三个手指😂。结果可想而知，九月份奋斗了一个月，也就吃了一个月的灰。\n\n![](【日记】在武汉跑秋招的日子/QQ图片20191012190452.jpg)\n\n​\t我东谷伯伯说的好啊，穷人的孩子，不该有梦想，带着梦想的穷孩子只会过得很累。家里没有足够的经济支持你去追求这些梦想。穷人的孩子更多的应该是考虑现实，而不是追求兴趣，选专业就应该选好就业的，无论兴趣如何。因为生活在一个穷困的家庭，没有钱是万万不能的。你需要的是尽早的就业来当起这个家。可笑的是，我现在才明白，难道我选择专业的时候选择了兴趣，选择就业的时候选择兴趣，真的错了吗？\n\n​\t九月五号，我和儒哥踏上了前往武汉的动车，两个小时的动车路程加一个小时的地铁路程加十几分钟的滴滴路程，我们来的早已预约好的租房“武汉市洪山区竹苑小区四栋一单元302号房”，涉世不深的我第一次被社会割肉，房租交了1100软妹币，押金交了1300软妹币，大出血啊！从家里带的5000软妹币瞬间去掉一半，更可恶的是，第一个星期进去仅仅五天，水电费就花掉50，一个月下来水电费足足花了200。\n\n![](【日记】在武汉跑秋招的日子/QQ图片20191012190616.jpg)\n\n​\t入住第二天，上午我们来到了武大，只能说名校果然是名校，那环境，那楼宇，那面积，那宿舍都不是普通本科能比的，这天正好碰到武大有一场音乐艺术展，于是就去，里面一排排的钢琴，尽管看不懂，但是依旧觉得牛逼。纵穿武大，便来到了东湖，不得不说武汉的风景确实没得说。下午我们来到了华科，华科也不是一般的大，而且规划工整，那路是横七竖八，笔直笔直的，那绿植覆盖面积，走在校园里几乎不用晒太阳。我们也是骑着一个哈罗单车足足逛了一下午。到了晚上便开始了我们来到武行的第一场宣讲会--oppo华科宣讲会。\n\n![](【日记】在武汉跑秋招的日子/Snipaste_2019-09-08_09-15-55.png)\n\n![](【日记】在武汉跑秋招的日子/Snipaste_2019-09-08_09-23-19.png)\n\n![](【日记】在武汉跑秋招的日子/QQ图片20191012190552.jpg)\n\n![](【日记】在武汉跑秋招的日子/QQ图片20191012190600.jpg)\n\n![](【日记】在武汉跑秋招的日子/QQ图片20191012190518.jpg)\n\n![](【日记】在武汉跑秋招的日子/Snipaste_2019-09-08_09-28-22.png)\n\n![](【日记】在武汉跑秋招的日子/Snipaste_2019-09-08_09-34-22.png)\n\n​\t只有当自己切真切实的接触到了这些名校，切真切实的接触到了名校中的那些人，才会明白在大学四年里所说的那些名校差距原来如此之大。可能是高中三年太辛苦，亦或是预科一年太放纵，大学三年啊，我终究是没有学会多少东西。可这又怎能让我信服呢？我真的没有学到什么东西吗？大一，因为读了一年预科，我不再是出来扎到，于是乎我做了班级负责人，然后觉得太累，于是正式选举班委时选择了副班长，学生组织，我选择了院新媒体。一年来，我参加比赛，制作视频，最后也是拿了个校三等奖学金。大二，我成了新媒体摄像部的部长，我把精力都用来管理部门，教导干事，于是乎我们部门成了优秀部门。同年借着新媒体和宋哥，我们成立的木瓜传媒工作室，对外接单，曾三次远赴神农架，总盈利13000软妹币，同样也顺利拿下了那年的三等奖学金。大三,我和儒哥一起在必胜客兼职了半年，同时我做到了经济独立11一个月，差一个月的经济独立一年。同时在富云达学习了半年，也开始为找工作而忧心，大三呆在学校的时间确实少了很多，尽管没拿到奖学金，但是成绩确实是提升了很多。如此充实的大学生活，我真的什么也没学到吗？\n\n![](【日记】在武汉跑秋招的日子/QQ图片20191012190504.jpg)\n\n​\t事实证明，我真的很差劲，九月份，我和儒哥都开始了自己的秋招之旅，一整个九月，我跑了好几家游戏公司，成都摩丰，长沙的沃尔信息，武汉的微派网络，众娱，广州的速游网络，北京的多乐游戏，结果是一家没进。反观儒哥，他搞Web，结果一面就进了快客云，实习工资3700。顿时我被打击到哭泣，对没错因为恰逢中秋，我哭了，在和妈打的电话中哭得很彻底。这一次我想家了，想家想到了骨子里，这还是自从我小学六年级第一次离开父母留校寄宿以来最想家的一次，即使当年预科父亲送我来到宜昌离开我回家那次都没有这一次那么想家。想家也许是每一个在外漂泊的游子必定要经历的吧。\n\n​\t第二天我买上了回家的车票，早上九点到晚上十一点，我到家了，我终于暂时卸下了三个多月来的忧心忡忡。母亲知道我要回来就上山区采了皇竹笋，做了一顿竹笋酿，那是我这么久以来吃的最无忧无虑的一顿，心里没有忧愁，嘴里尽是美味，对面坐者母亲，顶上是家，可能这才是我想要的生活吧。每天能有一些时间在家陪陪父母，也不失是一种幸福。父母操劳了半辈子，送我和弟弟读书，弟弟不争气跑去复读了，我作为长子找工作的事本不应该让父母操心，因为父母操心也不打劲，只能为我干着急。于是我开始反思，走游戏开发这条路我真的走对了吗？我是不是应该换条路走呢？比如C++。\n\n![](【日记】在武汉跑秋招的日子/QQ图片20191012190448.jpg)\n\n![](【日记】在武汉跑秋招的日子/QQ图片20191012190414.jpg)\n\n![](【日记】在武汉跑秋招的日子/QQ图片20191012190444.jpg)\n\n​\t在家里的几天是我整个大三以来过的最舒心的几天，可是时间转瞬即逝，我又踏上了秋招之旅。九月25日，依旧没找到工作的我决定返校回去深造C++，然后国庆之后转行寻找C++的岗位。回到学校才发现学生时代的生活真的很美好，相比社会的残酷，校园原来真的是一个乐园，只是十几年的学生生活让我忽略了这一点。只剩最后一年的大学生活了，现在明白过来也为时不晚，且行还须且珍惜。\n\n​\t国庆过了，房租也到期了，我开始了寄居生活，儒哥找到了工作于是就在公司附近租了个房子，我便开始寄居在儒哥的房子里，十月七号，我拿到了第一个offer，蛛网传媒，这是一家半个游戏公司的公司，因为他们做游戏却不是做自己的游戏，并且他们不仅仅做游戏，还做其他的软件，类似一家外包公司。实习工资3000软妹币加餐补300。也许是我自己把待遇开低了，唉~也罢，谁让我九月份受够了打击呢？于此同时九月份投的很多家公司也都邮来了面试通知，我去了，却都凉凉了，在和我们班那些去华清远见培训的同学聊面试题的时候，我才知道自己的C++是有多菜，我真的没有什么可值得骄傲的，可笑的是，八月的时候我居然笑着说“找工作不难，难的是找一个好工作”，我啊，似乎是出来些什么问题了。\n\n![](【日记】在武汉跑秋招的日子/QQ图片20191012190638.jpg)\n\n​\t今天是十月十二号，我已经和房东商量好了，明天搬过去，住在武汉市银河湾，离公司蛮近的。后天就要去上班了，我的进修之旅还远没结束。\n\n​\t经历了这么多，那些平时不爱学习，成绩不好的同学反而找到了一个不错的工作，我这个自以为比他们优秀的学生却秋招那么惨，最终去了一家连自己都不觉得有多好的小公司，尽管我已经很努力的准备了三个月，很努力的学了三个月，可最终的结果却是那么的不尽人意，我很失落，我有问题，我的身上肯定出了什么问题，以至于我得到了一个如此不满意的结果。\n\n![](【日记】在武汉跑秋招的日子/QQ图片20191012190641.jpg)\n\n​\t也许生活就是这样雕琢一个孩子的吧，这次秋招我才意识到，自己眼中的优秀就是个屁，也许我该拾起初高中的那股劲了，大学的自己似乎过于放纵了，以至于成就了一个失败的自己。我的身上出问题了，我要找出来，我不比他们差，我不应该如此生活，我需要变强的，变得很强很强。现在得我真的没有资格说累，“累”，那是给别人说的。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"【日记】在武汉跑秋招的日子","published":1,"updated":"2021-02-01T15:28:31.122Z","_id":"ckk9hocb20021dwr72cg209tu","comments":1,"layout":"post","photos":[],"link":"","content":"<script src=\"/crypto-js.js\"></script><script src=\"/mcommon.js\"></script><h3 id=\"encrypt-message\">绕路吧！</h3><link rel=\"stylesheet\" href=\"//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css\"> <link rel=\"stylesheet\" href=\"//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css\"> <script src=\"//cdn.bootcss.com/jquery/1.11.3/jquery.min.js\"></script> <script src=\"//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js\"></script> <div id=\"security\"> <div> <div class=\"input-group\"> <input type=\"text\" class=\"form-control\" aria-label=\"Enter the password.\" id=\"pass\"/> <div class=\"input-group-btn\"> <button type=\"button\" class=\"btn btn-default\" onclick=\"decryptAES()\">Decrypt</button> </div> </div> </div> </div> <div id=\"encrypt-blog\" style=\"display:none\"> U2FsdGVkX1+o4KYraDGhsUa1vfelrJISwVG6HY48UKAMBuyOSXjYFc8KJ/VJAUAQnlr5arLy2y/6zjl9tPV9T2XKs8C95pWT6586ainVo7WKtqNOSaZ3z0lOR89jP7gi89eBYK+/fRByvpQHHEpNP2pdIP19Xa/Px7KgXrZ65NmbBL9wHUvpbA00H2Nk8xKG14b0KYZTura8GCoSCg5FS+qZMWRygqzMpJqVJd+aGVPhUbddpibDr85s37sJPrRS3h10GXUf/XFCS/rN+XVdOH5HEQX4oarT3WDi5bX8XMZbgIVOZ8niffa1AEE2Kf6VLbsOdH9qbGr00+pFZxe/h53usmSHCBPWnRJ6GUa1PBiCIqVTBHd/iNQSWK0BtM0NohfWrujM6P1pNk9MnQhnazIgteqk/Eu0p7ZATSTDzMc7YNTm+uGIs7zLUuTHOxU2QIgH6MDI5DHHlYBXR+u2TXHP4+C99jgjg9pgXbY9mHto+GY+UVLRvx4S1lGpTbe0aqXk/TlbhvJYmePWmPv9qRcJyH9JLdd8aKQfPPpz2psnkCZpO+N1KtmuznSQARnL08GTvBSRLZtdg2hapL6F5++OHSWvA7u+XIN672rH1ZWjmzknOezJUoI2Pm+wgckP6c5YadEXmcL/3pn140DFI9P7aIKmdfr/C+Qsg6RtA6ghYO7CBx1bOm8j8jkd+/CHpO63E7ILrDb5qzKjii6wLp2NUrvk0lQKB7PKdEl+wWNW9cSTP3FZqy0JN/UsWulSFJ1LfE3SkT/AoGr8+4MqyOdCcOImHNPMwpj+ImG3Rzi0U/WXn5RHCwdrKgXNVV0ZKX4BclB0HsJyFINn4ooJZxRSGbqHfJufDiL2PRvf2HSwMYfBESehPGC2JqszYu2C2W26yjqyqEldceOIniODjJLaKmU0Ra93cYpMzWT0k4h+YaNlo3itAYobRKUF+Dsn6jgmQhXOiaC7L+r4Ubr0x4dQUY7rsIA5N4e8dWmh+UtAIXY6suehzCVih9N3LQB51eCBzt6guIq4ncMjvK9jFChAniXqbcXraJthQoIA1zMOCNXGoigH4hEBSY1/s80kbqXXvTw7u2Q6TI4a5yXDRh42TrPVE3qqfCkZkb8A6CUwMdWBQgalLdW6buDk1VluOQ6lbyR/urWZlBJkqZWwXc5gb+/jmnpXEzryLaECrxqFuRXxhYJH4ryTJ6b+V5iiwV8y7ebFLj/F5V7YbT8S3t/IWp2vafJgbT+SAs/eEY7VFbnX3SjquxwaoHQuiy85/bas+FNtUGTvBiMU11dQzK7V9KgwDqyWRUxmJpXpR/N/4xTXAp/s7n980XjyfavoVfaC+HIUy4zlxBR366x9hOd2t0eq3KNIS1jUqVAqcNRdzOeZCRMP1UIPsojDrgRBqvl2I0wZ8mNKwvCmT7NpFvb1YS3oxTO71avYbQ2kcPQe9JKnB89nKSLtLUyYID6Ux2/34UnzpqtT7+B9FnmyXLiMFsA5p75Onm2XKZwFy05kQ3c2ZQNpx/k9DcbocWKfTMRd4N0aflMCPReyt7x3nirnk3pCtqoy82fAjY5LLTRR9sPEFQB+YqCdoIltcZcAztliFB6TeOP0DhsbJB3T8IRc9lkqGtzLkX5asWZRYhug50TR6B8sdIjzwRH5WnrEOgx5CD5+vMvRl1/Ye1qPjba1KEADPOx0b6zsQ5EN32aVZZezN5ypGbaOXfLJu+38R5SazQF9Bn+UamUy6LicfjQvBU21Nw0cXOjgeTTJPEPRMYgt+LmHQF0jBf/MkpLyQnUPgmWD0U8PsnO7qGQ34CBil1uPxel/+PiOfzOmg3+DrhHuIgHUCyE3xfT3heoTwawLZ4DwNYjIfir1vMzNDEikwFwFc9cKgNqM9QLj+zdr/xllQOsPVaIB2zcIYBU5OgriRPvsUFZ2JwHBWJWbOf5JolrY8YTYGzfBHpIq+qAWqVcfW+7CudcSlUpp8bWeV8jWMlY5oqovmoaKZQzJKtEgJdYy2RSQGgbiZD4Fj6ZAcWGeNIaO9JvYAFibVrh2mLdt33cbot5W83YH/i+krPMaeYZTV1UyP4WD/hypZ8vbsQ7jdHV174qoSDCjoCV7brqn9YJW96Xma0Hp41sMCLXWmXtHcER2WxEqPB3vLpfhZadZbDmydwjrlXPbolr52IrH88lQ+aVXSft12XvGPM8aWM+JokKfkNEReeh9v6+HjXsYsFsajOlyCMq8v5NvRYPKvKo4EOe9Kq2bnVZClugswGhlv4dKUcgOwbmOJZy5zAPUwztui/xfpnPir+ekuiv1YhI+hCYIfpnIA/p4HFOStjYBOXUwwdiUAUo04z+kEwu9DPiwJLZwUquB7+ruvdFuYCJfEQhxuXrM4qt7o0CqMXVBVfrRNHC4T4poWv9TS6m+NxrEFpqa9ay3Y1hox+CBYxBMvkUWnSmUjKWMG30G+IyCbPdefNAJvs9Q02QlczXxQoUmK54N+AgWZMJzpayo+sHi7L6146gHdMokrc3A9FULJnivp29NjipP4F6sa3GLjRWxFLp44LSImzukopwZ/1InkVUgeQo/hsnAZzhhaboqe5vQnda6A6o0zWEnmEdfk6Q0PaD7Yd6PnEketf0YOhRyq9P+0E5hMWLdfIOdfcEVB8ynMUhztSMW61/YPeeEUnl9FueaQNyM84HC5aObwGWTJnT1kY+z1Z3j5NjEEwf0sfrgWSdlCvqSMmIqta7ZmbN5naaH05eOI8qkQ8925bmKq3rCGXtVovxPUDkQG9JjO6ca5Slwo+13Ui0t4InSITwA/W2poDRnpnX+Yqmd0ZKG00nqi3fnNH3SMRR9ULY8GwnpB1swTb3i7Bp166/839HemUo6OC6eRyU39QdFXDuoV7zOOBdQaC7o2B3jVcbXr/5TClZbfRbTPT8s0i2ErPdyI+WRQIooXiyhXrtNJI+5BWy/jtETSpWto2Bw4ODP26ZfX/B/1cUGJaeNSpjYBCEoflB5Abi5N2ft6wdDVgOLUeLSkYd7CqKplChqxlHQ3HpR6HbPYQ3do7Ir0duZa3ywoAyr+8jeel831gMj1YIlcV9HLzF6eslvLG3Rfpe8gb7kOn+gGn2iMc8C77N3ZmlpFsh+IC2Ji+YYY7rM/Krrx+a4OAf/AKAim8cDkou55beJ9ysw8pk6AaocYvQj0ULcAC4OMhNONxMNcfEqEdAy5+TbGDkEgxKwbOpUOuAcJRPBXcy1zxItI8XicKJOPbxA6kAt3Ocjvd7xT8Rmowx9vvqhRc4ffRVdg0eOoRnM6I+zxKYssR9EcPqxwDB3qN7yUaWRyiM6bB/aAA6yWL5d1Q90wZ1xacuVyw44bQr+GDBbpNGJ5cwH1ayL/LGWufy5mDT6UPxW3wtGqnRRAHPNXRgEQwDju0V6XzxzEJ3KKh+MQr6otvLcQHmOQ3+Nd1SkhQ+wMUsR7ptqhNy94uKyArWmB14UEW2q1wLs9ofx3CvSeJyb9yWALqjmHQt8PECKwjTVh/KogQpv7VGHPcx0Zo+c2eIAXjEUs1kCeOO+dfJ6WAgQKFgER5kgMftWd7RA24OuhPx6zwr72WVKwTaCNu5/I01qbhRz6t/N3rAdfTvc5CHaUSDpWz2IisIm3LZ0LB9a9yvd/MUAcU6KU6z9cp3lET5lrFxP2da4RoBCXQLlCgyobXxQhe6iHgYdRq6bkMHQI8NvQN+fmgrLDCw07KAepTT0HBJ08LdCj5iqiBucYS4sSWrizyvYRR+QBRQsR3dPBuKRh8Ui2C+pINz0xitG8i26XhClRCCQA7YJXeXvgzt/lEZchioxuf7zAy3Pm3+DJsbHfKaJ5EJAWtlPl1sKzRmoTb7frPTMNlMr238tnrQxRKiGKYgaTceiEWddlGgofueRhEMW/zqNtYasClW9Vd4oVnjcWB+uxRSFXZxAoRkN8bnCsRZsVBtT/EBuM1axlCWoU/u3Udwc92QpKZk31BujFoW6glBts0S1DaMIRu1joutNjL5sZX2VuhxRBPDukWMQH8z0P+NloJzRw0xD3RxlwcZXdBjkC1nlzFX8OwzPF0TZ5OwxJfypDrvC7M0YRIwvIOu2IBOhcEGm95adaFtrmrlMFvYh3nTL4w1SEdI+V/GX84U1Wkng1fxJxshC+2m7M7tNReQL09uniExBgclOP6B6CK/xo9lgADilAsBAghy9sKmc2wPsjny5AJWZ8+E8uGEFGiCmtk9Ta13Ejki4G7cfF1SOGpTCcLzLT84cLGDrQh0P50lEKuG2a0W/WOOaipnVbhY0u5TsfwtsLDifieHO2PgR2FyQn2h//yBSaFvnQ+2ojljhjBqDH26KxeI+Y8Q2zD2mRNUcq8QHMzNVHkSCDOPywQAh6hsr+HKzf2kA9dQWE17I1HcPHVYdp3Ti3UmNNgNE0NCaOXjle/ZUQ2A8//YgEAc+PCItxUYTScLu/PMVpzbJMxZBheC2v4Oinf/sViW4k8+VgCZh8X6n6alAKMZSrCgraPZcCPGblreV8QFWEpg2XT7YDdEjmaWBv/xw00+8U5ZXbP7tPZmCLGysIkjSBNkBcTF2F1SgrFhmt/vCEl/Kc4BNwlZIaGd9BN2Q7yWYqFFB7yURv7mOBLNXCAHSZEHGlRpKtSn71DC8i/hYKco3Y5gLR90je5FeBRhX1OEyuiPgmHNe6ieCsxOjM0Wz/mPmXgm2c1hTx1epnlX2r7pDdzxw1O9nHt6bBsXr0pgUXij7DOh93gU7LxZdaYsnh6PMKsRI8+B2ijsfM5jrL4kTu/mp4X7zrFAl9hmk9vW7siBMlonkeH3lDejimZwaQP6KyZCywCGnGzgdWIqZzCYYnx/wzHt6AUEPA8AeTwlsnrCkCjPtshTsjgT+SMxg2bscTJInk2/BuABjPH3xjFu5TvdQaF8D/iIM6krlHGvTMTRg8p+JeqyFav4LN76t4THDQvxZJa1JbFSUppT1pvoTEo70T5jjwwblZ7CgaIPt7ssKcS13K23THNVGWiRZgzNtp0+rwOk0A7YOq4WvGv/Courz6HP30fBP3qzkJGA1F+//N85aP8yUQxAa96+U5z/UMmqI/yFg/oAChxoP5023sH8QfMJAmMdPTmMTg9nBEQtpxJo45Ui9xy6TvdjLXU63kegcalmiEuo2+obJTknYujbVmfQKC/SiQ1wLIKwnRkkMg6A/HdRl51TrZm/xSUGJ0bUYtN8rbFd7ZvBYM1aeElInTl43otplLye2v8OBgXbICNBsAOFM7XGDRH8Yv2HPdQptwzFR7uKvX+NSzCgdVfbMlujcV5Owp3HZzWcJzUNbSHiOHE2KM/zieIJJbHEMcv4Kk8VDBGad8sV4cSV5J16A9hYSnVcjAOHjMF9jZzLHVXg3+ttTRhMriCkbS8AdIsrcC+/DjNgPsCc1xwtjHQcy5+oChnxncb6ZWwMMBavIHUMzGQIPg9+7snE79Frl1bKnWm/NNYQCUyA7M/wF8QH5fKd9rBqtdXshLGEoQNmS+HIFPZxVd4PfayyPZrsZZ02YWJMtiUjh2nvhNsfagYioXw8XRNPb8sovmnf2LnDG+SEGHaKeIytqGzsQ0F7aNz1huWkEex+ziTop3thBPDvzYNrJZt3n7H9or0LOaqzVKEdbI020akdQnZ39qt5GP73ZDLJSRIAblx/bi+4ThwdPxgKQ1d01g+nA2jT5hGQSVKEJ7qqm0xGEz/05L9ZRIi93wbf48AvRSmLg+M3I4oTfkF3+yAogJ4TuLmPemlyFSJ4OwNrIz7FW27Di0vfOgvCpH+KrQa2Jyusiy/OCVwI2IIr0T9LR6yh0TN4di3WkYFmdSVvGVRvd1xbiv/CkcO9vN+gfs92oeFk8FZ1Uq8wdtV1VUoS3xm+hEeLbTZtOYMjzFfMhiBpToUCYh1M46PbAgI93uwit+3w2K5WYA6K2rZj0TXjvqQZfQp4GvBPFzVYOJgwwTr03WIuXyWRqP/ZMa+42xRhLiUV/x2SIsteMUtcp7GTNDdPxxEamPSphIJBkTyQkMSZGbEilHRkDNbTYDO8C7LgGb+zppAprccbLTBsJCRasPWwULsoK+YOk5CNUB+KTK2UGeynqpQVekjBf2WDJlIcn81xQlgJEcgONVxCs3p1howek0IBO0HNjA/M0E+P+9xliGNkAGNKAb+3IjayHXs309b5ICUu3z81zj2SJqKgxedgJ/IHJBTjHgG1IGJnyrjSDwNXwBy0nJ3kQVfZmC1gXX022Y17VyJsKF6IDFIfhhXuWzxJWkvuPDpJiiSzQpe9ypiJzLASNEMcByhKMIkYH0mrgZ2COTJIPyiILNfKEmFMYu5le8MafgL8bUmHgEdgkix3FkOIHylwtetnmfafxse2alMCUYPfrvmsr3tnHDZBE2jAW7N4aLEUUif65E5PjOv6EoLq5WOOUfIIRssRPBxmlp8hJoqsJs/8ZgzSdRPxxU+q06fcKiu0Y1cbnUUL6fdIaBRupkCYwqoHyhU9B06z+CcjPqbTwalNrrLKmw3TX3G0m28TP3xwNyEzI1yGFNWSMLNQfoaf7d6H13EzFUT/z5t4YXVndZ5mR++4gAFSFQ1x7qU4dXVDNMD3O2bwdPnFzB/j+6/NXR75c2wpO9q50oLlXi80xT1Bt57shnVP3Agoq+kvJYCgqooFFQhRRiS+WPYe7bR7xUsNOdYFmNxkT4qUK194GiCACwkwgzoo1Df5IxgclkmePUqqYw54E4ysh8JNYBCeo861OJYWafZh68XdjR0fUmG/tsKq1sLqffDptUgpHhGn8qr07En8MBM89sEV3wTUrvj4kFRJbJq9m3A7hFHi8/7zM3OH6aGjN39ob/zKycO8cBOMOV/kBdgHXLCxYxxPb8/+tBo3K6sz45kYpTAsLKWwP3q4cPZ36+DbF2cKqrObia7GuUabAQxYFRdsNp2ortVVoZnXEAmCApux4iqrfKZKwz60DBLRFPOquDt8YzU0vqvC+icUmyZ6m/whSw8Bi2RUtrka2Hljj/oXpbkVwEUMSIMenP456hbf4xl7MaRl1CQdVx4SFvntnrEIy2o85oPMmdSxZyjr8lM9kmDBprCIvJgCCQVK3CwN22vxH8rd++aP6nx0nMts1X1qN5h880ZZMGkxIzW8Jv8Xg5LYQUu9gY8mZuerIgSgh1RMm2bbFN5whFhE8sxFsQ+jXE2nHB468ii7rLDeSCN0MGHq66nEhOHH9VryeawaXaJGNgrlH/fDA3zseMto9abJDneJuQsJky9xPoKn5fcWiY3pwPc165+RbFLhxvGipsmaqw+eTg4EyFlcQTIG8ejpn1XLpEiIkPJz9ijGJI8TEWpTk7zHtjmLHRZyDGIj5PHHGL6R9A/VptBAmL1F6ko3itGxh7XhVnKsoAGJMns757SWTVVkJ0uFxM1SXv3m4HWZJiQTLprJC+m42q9rI7OK80knRruFozcM+LLH+omkKCsAYYs31tnGeSdVnJVYTLp1yhr/T8anTH2MuOuAvPK3W87idFsLPAL+biW3icbo8IoBgXh9Q7iV9UV9+rEKBXdzahG6jHwyu9UvCSFQZdRgIGitqiheGFdrRAqLh5r6U7jdX4mKJG+YWGaXoY+V5xMsuB/CXTpf21XVMwC+/4wYDiZHFFQBbMgYrxhu/npfe5DqYIQj7pwPW1IYELwJygaVu7r7m2ZiOBz/Vc2crVCf+nXeIa6TXbumW3zWorbJYJrCKhcDbbWmPyaIsvpY75asYEEZebW2lh3810Rjhb7LNn1eWBWHm3ch1a3zbSSJtEE6SJL4gS3FUYpNXUhObSY7F+1VU37HQKS623nvKJShWOlYNnyDx/WZeBwrMJa9O1kZJfgY8kvPDMQylyYnK86zMLRPDeEFfXWYlXSJcEopxXpbYCU0lOtlS6ujGxRZH/dw7gPbCYV66y5hiC1Bo50AXUO8TIXLy97mfdPCiQJCC0NLit+lKRgbFtfNjE0NOjT5UNCDLEsbHS/URFGGk+jhuu/i2nqpqTtUSwyY6zzikLeoV2eSiCVYr2cEKeHYXZ8G+fC3jRCrq+iaqkfuLTfFIteHmZKuIyCWRgQMYV9HlRavmG3tkuugRK02fGMxlINq+VLrJYbtfmlDw5RpZM+XRcatgDdgiF1wVDHYMUga9LMKS6jYYQ0UO87suoOuBTlfCmmT67whhaly6CB0U+ltoFeDG+xi+jQc42yb4SUZ0rhVJKSRFc4JAe0uzojfFTpCUBtzmJQHxeSS+FeELaR564r9eXTDTKNeTUpCO2NW+IZE5sy2TiEWMmxdw1Vg50TGHTTfIo5XY/nLA/kRHw2vQX28eQC/sAPMEJqZW7GHv8+7sVEo2Gc6MRsbCmYlXmB4dXXldcVVO6Idfzc+WMwfpnWe/DtLxeCcqS3CF3AhJNmrZe6hMBwy3QS9e8UR2tfz6o5K6CZekmA+sID2xIX4TahtJxIkRmKAT0ldSIEGWPu3mu5rk8wlGf7luMfWh4NWC5v7KoCQ/8WbfSjIaQ4oCQDyXMslqg96X90NtoW4TU29jqTyzB/UteYvsG3pY0UoIg2KLUWuKYl1QV7ZDqx3m+SsB3PDJQ/WC3tvg7r6lUsbpMnEbG4cnFbW+KPCw3KJ6DNv4hl5OH8pJ78Jjh9A3LSkqY6JKUY+2I82IhbbI510yikEsb9CAvYiexOE6LuaEjlqZ89wsOAeIVqueNDKzwD7Lqo6yOLEteCAv85uxpWY1954ZOpzTngZHXHKH4juLMULsCHxoscfjvXunCFVP8m+saOKNbDKaOgtxNX+MbYP49KyPQWH3l0Q0qA/9Ex0tBayb9VpZj5bKCht1iGjkzaxfSMCxqjOxAG59vsznYbGuP+uP9ITDwNGbG3Jesl9Fft2TgRTHn6muXkHDeIRHUo6EAEXXt/INoVVbEKs5ttKPddyW7HkmpsfF6FyncV/GDY/1UjqfXPYusT1vZuuedBDuUW2Rj70xb+1gx+G7MtqO0MJcuVj17/uLziwXwYl7W0VHeMzUA1bgvbbfHtg713vCwLKekGf8n4NL+SHEYezUIrLIflxWkj9u3T4voQENp2YcEFbHTXH2Ahd6motWaUnOlMmVnU51LNLBjjQ2fxygo0+UL1QHLOUlUgjl0obo79cN7fQe25MNfYxnjPVeyin9MNWD4Y/c6m+WzYM7ibD2fnWGDffUUK9qXriNw6qMDHir09N+MO06Hxp+ZJNB7VoIbWqPSwSqCyguV/RPLt+JFtADA6uZf01n5YWEk2EsN3vrI2fVxiumMca6J9NVeIylgsccfogI8uIajdPX/+xH6AiB0fS/leezFWxOv4fvJ92UU8d2h1o1qL42wn+tywkqSzboVNdcynOy7kjvnwG8d96xntGG/n1fvVTXExQI5sV7ICCLsJ02WdQeUJgh+S9WY1dEeyQIeGfdJV7dzVOguKfEz1n9D09wuMe+Uc2CuaUZq6/Az8X/L0KYxdyF7qS3pcbrhRkFNANSX+XCCUNrmTQrgvOOJGCmRS30Wz1tObh9gtoK89vfnQH2SxTSCAjsqZGtBabCAVhe9TDPrqqKDjc3F2eo2p3WJhcrcenIbYCmRQVW4ta2ezuLtzKaFHrbqsHd+c0GrLLFzq6pRj+3mhm7paU37btOSf7R9ya5zgYvClMWVJ5DbDu7oWyiSLysJYp85P4BgLMw6zq9rvgC6VeuW0YQJRXIlIFkkgfIXu5e6HghTjW0pKOxN7lAFDZlUYvMEiCpHArv8nZ0RJqN0Lv3aSAd/uaxcB12VdWfvFpkOqFaSCgNRQ63lUMF++FP6xoD8i7nAeMYawxuvykHZX65t6N49WGYpta2MHncJk1OMRCa3x+YNyBa4swMQmFvDFgasCI3GlNmlv6QEZwu5fEF6rUnSlUp+2ZgAhsuU8TpI0TLaf4uA5GHX7GUr6Qmqxtr1kEZsGjy8nnIJZR8nmnkmC+EanoHnNv2+BXGUqXg9OtfTlPLPdOtbv4w/P3revwgknBkqBM/mYksX+lHGNknFF+zbcKmDZOUw18AYPHlz/Vete3Jugmo65nzH0GDqO4ZeCoeCEDRgJiWeDvW6tOiGdcm7j9XFlk5OE0JQzmqjNGgHxrq2ftOvN58y05Ao/X6Jiwr1/Ty5CeVdr5w5q2HFgHjbJs/luHyt8wXT+xu/yE5EkXat79o+W4N2GBLU/3THC7Ae8CM6T2C9X84PX3rUWNU8PDFOSV6jEYsUuJHaoy2M3/SENglHlbKhrXbSy4KCiMddzdCKsYA+8e+rK3tUTedFHqPL1ryVQP2fl9rfZdBd9+org0d0MTEPWGigcceKMt2uP3XM+TgVPTkzolHGlUcXu+UlMIvZ1mhHnwFo0Nnbs3nscrOW8xCLEXwEOUkkHPOcxviaVTuWGWjIRTxIEemm3xNlbqKwY5N+Dd/5JyDVcWQvU/ug01eE6IVUTEWGSrGM57WtkKr1I4GjtgzoVoDAH1uxIJpVJjW5VBk2T3ljQLywzN1UTUEGHK+LKG37QklmdbmXAdh8jMI/1n5DGX6xmk+usE740SKp9+yuN4QhSWxHmKcoviwr6+MhmQ85v03R6SlhMTkBXTS5VaKtVJtCO44IBcYrkfncr4Kd+JS84noLtw7wSnpLf8mkPkOnVmE94CUiKn8PBXLdd6qfnHFEAYOlAYICGzl+zSJypMCOV3Tl/wn16kzW1ZaPcH7nOaF/+DEzr5G9GXiUoYlfM9imhIXan4KmerNkTot4grPvA14m1dsa9/HL32y+bRyla+DlWlLh3l65b05rDpdA+xR6H1AfZq0pGm0KYVQ+2a9CxOIn9V0KV0inX0MToCLGLCK6WFm8+DZqVgulKWKShUw6rOU0k8XK3qHYk2eDVPUnhlGi0kbgW0M+nU9lpMvnF8TIXq/a8uw/ttFnMDgQ3cXmODFhqB+b9dR70QgxQmUf//nUAzZ5CrOLEUmQR/SAdfE4i3fq07oWJwZOyms9uXOzn13O4hpWr89iVGG0GS2dlKB1hCSJ4x822ZtooCTVHvRonidpDIEFCN3jdvf0jv5wavS6LdOLkPFljH6NW3sVZr98V5Em/RUocf1GcJXImN6sYJ79JRUefH/FbqWbypuBg39rdsJ07xIfeoPapORb2SkpDOdhPKG04KYin7EnNmVDt7p4+WZl4fqeBvUDuauSRc62RQCVryq2q7nQj9S8uCCmaOeVvyW1rn/eB9ribMu1rg5XHNeuo5+G4g+RRmgecBOfHgDsKVrYr+gpiZWzBCoxFU55/AkeU2LarQGNlWXLPQNou0dsGnIJ/OQqvsrRi5E0PpiShwhgspPf4ILho0OusXOmwiO6ms3Klxjyqn1yoGt4IL5IowfQuyF1BO1m1VVjANU83lJSAacO8iLOD4QfWbwMUIODg5Ye5rk3m6dyOYCjBwIBGTim6jYASepUCpU2rYnqPhhGxd43caAXAiXymqUx+wD9KRnd0bkNGkh/KIG6Y2RDLKjvyuYqC9v3jrAk8jS2tBMk+AoXV19nQSiYSy5Nlw/UZaQi5y4llqBwNNUyNs75pWZEFMu+aaWUvPPnIkV1xf5p7dBHwbeP7Lz8i37LuOWN4lPB/XYG7Ftx04YsrXBTdWrxlhzxgJx6st5FLEWACE7rha2TGpjGmJbr/kE8vjIz+p3/l9DJ0GtvTbDNcuBji+gJCqeFjeylodp9I5tXtCEgRFKtlshHlQtR3/WmeJvr4+nvWormaN5ASKo1AaFQzlt1D6dmRXnzTeLZSU5LduTeurhmAxRJTzoOcyD3LuTI1U+pFqOOxzp6+Q/rPmtsWCa8OsbVjdnhPS+hHyK/i2j0ngGRdLSPauoR/LVy7ZgvYG2QhdSWtAC4Fj37ZaC+h3TmYMes6pNzzU0TjkYS3h9uuVXHN30QE5KhZxWWfI5DQoYUwrEDmkaAuhqikLePPV0BAco0xqIdxyuw9Fx2d4IP6fXf+xWgQRTpITGTNV0z0p0nBMNPv977yweh7Yvx9qr/NwfAqF3ywcccS10Zg8/N1clAm9pKXKHxektA9SNbEIhyKADVynvnJfa5165J3CjZZ36RRZ2lCnhfUk2f7UAojtNc1mP3FxImCMyzJvxLnJQyvkQJXIH83uQAIZkULBAo4icKE5Dn5gx9OqF47JCC00AaUKWXqj/HUuRVK9nPYxki10LtTZvx3NIZ8YY0pOPLc2JOfxwttETrDPtrgwHLYBloKHbmagWyLGy5htOiJ/t03fD0QeMI1UrclLQlkoenql/dVucb5+Sy12+qJ2I5BjEX6c9CKXGJrZ+X61AQgaSOIfMQrCV2FBduRI5vSqmWRqvMYUj7QFUg0Okhgzchp72zs5jMTxgZf0ttM5uM4LPSphgV6fO4xQYTPmbc3hx6qZCf3gj4I3I7oIc2+1GFleexyZLZDa4kGJJYq0YI8IKwoXvBaabVL3SLRAFSwpKx+DD72E3gTnQInuz5srnG/XSxox8cpnh8Glr9C9tBpKcYXOn1NfiBOsQWsLRHXhCUKZZmXvkPM/cbZdKSq/5PgSXAmT1MdAfcPLon+DM+/YZHxRwXin4eni0wUbVoT19MnD0iuDyjLnZf6z6NyjSmUJf9q/IbbwsCpxQ2lqDJfhU2sXfTnaMBpctTjnELB7kUUZ45m0WILgciAlpcDki4lzxMWnyZQNSu6ucBrExBK2DlyVZ1/qhMFRgzNBGRERgWjN8oT6++szOvbtiiVtEOyDq2ihASvFu5K7zes7mwbZtp8n5hB8VXHNtLvILXMrA3qo9De9O3tpiL7axb18fntPAvexjeUAKwvub6lEACyXdEcXzDFFCI6SpkmXK3++Q6vKdsy+6Idok9yEtoYRZkV1w2c/k/B5kgmnIoprVJzdYbA0jSV+txNp6wxsM/NLHOC/dqmdUBrUyvkKRxyRyb6qUKHHCGuwem/m5hH1Nm+L4ktD27KmsuGCP7MWwMh+sH8/CYxDZ2c6QTVpf1NT3dJ+zKbISvn2xQ3UmV+8xoFBEroyNXb2clbz4pobuu4aCHzX+9cU2gyBKdheolAPHLI/jKKESMOYB5tq/om6C2Ruqbv0/cz3SS5jEfIyzVFiOQnAwb8wNsbIkom81QgIlLiHnN2mU1MIvwwqzVUPx0HQNGhvLKyF7VjDrslvf85nendhJn+8UpU2qG3s7yOmVa76P3gsd3ttLfwUzVKb63zDOJ17OmXt81psE5tBFIQxljR/ilYe38p63dzH7ct1LpHlw8CqwQACjx8lmXPiAI3SwDQqn5hGuVFpPloWYDxmp9eVrRePHxZCmYVGnraBh2uTMoDI6FLx//pQxbEoOh86mVc2SROtrJaqfZLP4p1xFna1iwa7t4M0rP/cLdJaKjoqqg1qQMBhsxcde3nn0UEulL9bDVrzm+GQwqLTujfEk9fs/z7X78ET/Z3Zo7+tv1YPZ7E9mFlVJ/kOSlvD5YlRpPce0JX+7uCSxq0jUQlatrHtt5il+wlmNnZGaz7jzdeDwHOUJfBkm/Age9Xxar53egrK36S5w+zxeFr/ocPMPZMOZZq7ldbXxzd9Jar5vDLygx9jyeeAcr35rW5Y+MFhuH+fpHrJ/93oO6nMYKMHH2GtWkjKvYD5PQF1G84IAutpnZ/vCQeoTaQu//EEC6mBx2X3VZvgnJ6y/SeDpp09t2CWwM3d71MC/pz3h7DYezo9T4xBBR0f7uCL6rOnH8sPhrvSZAH7xvVH2d9U7i0ds2tjWDSswqTdSSUfIKNuqaGbSAQL+NFaK44VANRsVJk0r3naixzbrbJ3UmcMbEn/RyQia6+hRrfH65KHq6ogKVotst18plbnxQ+PJXGucdbQZGVi6LdUCpUk9/e9ZWJI2yxvXbEYtxi7IHhboT1tF3qDxt7wKCbRkFM+SOtCjWWnTTMbdh7RJPePP52TdSytamc5B/bGaY3kKxqIIMpqWvYR3y31TAafm7jOdduihwpoN0dhiQY7etAuZ6jyZIk+Bs2U7eqXJATsKtQJUzLFOxHgSu3mYDY1+SuEHNFQyThzk+1FM7+C4G9NdOuh7evHMVRNEBlSyR/29yEN+iZvE6Lfis2Bgp02hGKfhVQaSPD+O/Ag8xtG7AKESqZCbX4LZSqx4icItOeoxIOZ1ajXUE7WnKRi4Gd7bWQ9vbciSqo/zgAxT9q3Nr6RkMpZ/tBq8HKdinkauLX2kTk2/sWMx8h3IMvAoSCr0Vm+Xd9OaXF9PkWz5/5BVtd8r18xp3ZCkmjFvukLgkib8Endl6C7QyEzJuHqBPrd8wX0n+5Bumq/NBwV2HDO25nGdP/q5aof9lTjkJx4lqEG0pG6b2ZWqKfnKh1LNBDHWF9GIH/2adrtHk3qvZrrY9y0MwfRlU2TpRLzDtjgamobeECFfGfaDkfe6hSBD7Gkp/0ChqggyMZMIj9r9PdH/gfLAK3OnZjK8D/VWEH8CmmfalUPfXoyouXO/94invtcAh/h6aP8BTzFyAxxriwC0XIxArS3ejxsyx6AOvlQN/Y5eeSWuVSvltXSewk+aUn1rCeb1+XvKJTfwD1AjniOwAJ4vfnpsRua0Kp5VXCVdu5K4wP4/+VNxZRI4E0Lzzlt2WKDStpTAJHCHiIpRP7h1Xe5jgFZhYGjgDOfg4Wi8X3sSVeKjdAmhlHQA3euGMarlXe9TdCn3aA3H09f2H3kmRtPxLOzP7FyT/5ucoM/hnizdagcWiWqCiCcyBZX3l/97OqPY6nd2NWf3QGM2rJlevpv2ARFJyhs7oq4qTt5YAHB6ObqBSGpeNb1SN6yOX7ILJsSJhCgr/hygTT5cX0UTNJqikuzR0S2L/HCcZXoqo2BxkZFz0fM0AlvchfwESzyN/h/SvoSEcTvOxDqjDUGEmjOHY+zpNtasOdiXJ7MdpC0kk0B3VzorCp6BZNiCHmarL924cpM+/A+gxqee3TG9lSbswLXyUcXFJjol+ER7EfOcTkkOvU/IQHEQtQYTGOYto//hsypjFjqQb/L2rH1i+ZAw7jfUTfxyCaY73k+jfVvDrtBcYvcBvfJN6YZcMr7b5rXZZuVnDybTP9+tVrAWfj+rhpkSPbxWBFzXHkWm8OWj8tpM0RpTvdOkcEMN22JpcxnRodHgDsao6R9WFIGT1vp6r5+480ctiGUdIw7yKlDXqq0DRtdv7QzZB9q7CSuGeUFqtcDL9g7sk/XTHLLt4NIpQBCX5ySZLtWUPUXlqBFKAJr7ZrHerHF8zfD45AYsxX9nqTRJ1GzQ9aaC1wAVdfwdaOjXolY8Rk1LcRrS8sgp65LOdQqjRpdtECX41o+FE5nlWSIRB8aWXEGV4QU78nWhboqm0qtodL8NgButlo9LU5Rya7mDKfc5cYDtOC19tF2ioaxRlOvNp0Ly3XBX7BDSg+xmlyINw8F32AVke582Fhxs+V8Utx3w3S6W3mePIHcKceIcoqK6pZmf7lO6oHcBszSAuFw/5yKgdOFo5wRqIDiiMCwR910XSwpcFbX8qnmY1pOc2iTLkVScp5PMfVYBCD2F/2/1lHCMDbHzTsuUqS6M7jgAzhc6b0+Re5egubVabSk0fhbGcF84pe8IqcHUMljTARwd+EbiGUAeqDYRXU6d+doP/R3tsyYaBACtAhIyuBpc29ZsXFJlPt/nnQxEP5HKwf8LOEaBHyljtFrc8JTFJwtpWuzeGAUpGD6GR+s6fzJvTTvusuoBG2dflwahMMG4qLYWAZ3uQQ9ANa+qCdcx7HB527WuYYcDnGYqoQpN6yI8ICHUliz8qYdO6Zl8iv0/Q45Brj80UBUxZmi9KdNTVw68Swv7KfvZxy91UDt4DLMt/wyYtIGScKnRyXqx/A56yzxrm6BYDgih6ejv6Kj9cYzRUgzVQn9SaU3UGqI+DEcElwfKSLdWG/Tcc1f4BKK2ScdFZbjrIYXDOFYzJYsK1z9PbmB4IBXmWXRzcvSO3vSjSwUJe6oVuxVcMSI/1I4zkalOy6sjekcx6p15cf2jLqQXTP9XjunOFt+vtKP/FrQMzVyY6czqLOl16/+AVtkKwrLkukVfhXAXYTlWRQ4xvmgXizPS5o7WZ0NmHq+Om2YCAfdPNF/Q93//ZystAr9MNsDbAJyKN5xZroeXAD9oEKIuskAD7yvtl/PfLYQgDOyGQvgvw8Ewb0q5ba2kf9wp7J6ZxemT9zdBdjT5mqx1IAGSGeau80+VrZ06L+9DDFU7sQyZdpj8rC9LCgUPG+nLSosTRi9ZHd1cflNXM9xjUyUAsUfKFQMPg+Aoi4O1zJE+RGbYncGPnlFelvdUiwa2AY1rW98Cf5qrm6OXaiWmuT0PB8r0CRi2ZFOBq0M0oHslAoeS/s05fbBU1s3bCF2oL/DaJS4HA1eTiyIusgnCPHfaxOZ4Qem17ReFTbPHRMmM2xNX/vJQMA3PG7IGyXQHmu9SyQ7cIzDWRxDj/KIM9KH7Phm5mL3OTiIHc3mEHYuZVj2pIQc9VaTgje3+64T6xGMUMj6z7EZhNBmE1oLy74cqVaW+Ta7ECnrUtO1VRRt+hOLLEP/86xJpBFIzZqb5mC574yKK3ihH9gYiP16d9xW/IZIw6maQIlXBBbYWVoEyEWO2CbkWRLRoFfHbT1Y56dVH+QBMOL9Ld/+IFyRv8M8jzo429YJxNirbHoKzi9S3YB9NdcfNZqwg3wUCdh2cVl5vRbpO9JB3XsB9mv7Eq7NaPUvDs/nUirXlW3Ss2rlwpbH1R3WWOQuWYyJ6/6l+SJpqtk7y6TfQtp+EOKtAeei8rdcCT8Td4gS1iLHGMv4eoBYovRXDglUt4+tchlHXTB0gMXwWyr4vyvsGjqMuiwyZ1C6iGulj0o6O+qNNdLYJDSWUkS2dgzIvKlAGcZci3Oni6+wHAOMgx5ZkrAF6GZal8EM/D5v00HWtbHYo/NJhTt7nVWdOXfXZtjrZIFNpR6+WyClbzqs3cMY/dIglCPKyIDNYyOKX0HP5W36Th36tmcvBh08OWcWJRDse69ORA2J/8d5CsL7qtUXCR1+WaM6Cyb1WjQ63LBUc9oo7w8+vdCkjW7ZiNGVckZrcPKQAPVu6CH6bf6MlksvbrAJ4tBTEPGBl1nns4mwOV51BIQbeRWbDt1OqNNDMTgqdG7cyybkZi4dED8ZEtpRtG0NH+n0TFDPfsgudi+TG7JGWdnNlKA0ZG5G78lTU6Ulx4C8lVeJyC2KTdak7eLWuioEUUn4XHQ0TEWbQAwHU0701dLKLgCUEMw5WtMGhIAnHf0jR1tUj8IcWNTT0+59XB/3OhwSuxvPEe/dJBb75juFU77QQQ+uykAF+Yr9zSI0waewUPFncoT52IH8c5XHe81KzbAxPaE0InOcPCnJnqkIyKfwE7B7ExKFG6rmLZIEBIfDPSKh5BSfpIqT0lPZXDsRO1oLH4CTy3zIg+sAudeijJuAsmeFFo6kGeEHVkexfs5YempHr6QqBeq6TpDc5AzN1lX/9W5m8Tk7+Beduv0bt4ZJRn25NP2Nykyo0KM2LirUtU9JqTvCTV3GJV4MkkGpZVG4Tkk/RW1St72pCqbYgfvpJqdIoq0A5G8FpEpufT3QAFBYU7AGJ4tYahSlkqArePY/COpvk2vmkyFMuyC7pD0gWhND8toFV1h0cuBZNXTFqMqRFq6tVH+x3qJ0VIt1EBrsvS0RfwqpfsHJsHHSkAm1uoaeAU9VCIxgygqa0EbkEjsopnQYwzIn7I/jcUBj64o0V63Q+M35/ke6f6AHjda1doRLHTJfRXMCvgl2Cxusc/sY8hyosbiMQgXb94zs0xriL9pPN1Axq6SmblbRKTUkYfXIwqkbdKFZj2zgOd32vBclX9cwoinsyO83qIZR+jxUrYSAK8yQ2IokZ3bVa9hyeWtEXBujAqgFXbISh9op3bFqJwKvLLAJ4jSsLAKQ9ZE4l+2jyFObvcZy7eviTV77XJSwKTFsbM6Xnxqd/G5VKeXbwXAp1JDcfBTuihcxii7zqDKBNYkGYtGRgUCAL2LbitYUeG5o2yfuGzu60yCzQg+vT2qS2wifJesvZqgvTy7hVHWTHQFT9K26GrhqvORVIEUg/9XwKd9uGJJK/1szYUKWFAh6IUkW9FXuSp0Te+oEVY2azmDHvy5+ZcFrWRH083GzzrX3MgOhBe6lim01ir/aOtX1WhvprnHFaGOqnzEy5tWDY/zuIGJByo/TEuakOwXMkKb3kGN5UHCPc1sV+sXQ81ZHk3DMDzgSZMmlUnzni98z5YdbSGadEHlxU5D3IG49SSRNaWOJJig08Ueu+bwgut7+UwjbWc6eaDTJg23+aQK3fQNnasTNO+QZibxjMT6pWjQsUz4jx6FYqrwTua57ciwQ9tdxhfjhXdQi6C0c4idS5gVykahaHI0RGQ+hd0zkzbuFQA74B0Sy3sGESDEjXvloe+3OxzvPjmhahGNxQlL+oZYDovP/7uacqSlma8kPXPMTQiYAE504CWHIv1QHueGUt84/VY7JTn5BEVBqUm56dzVPfA/ZU7AALJZNglTfkAorY6NNGo/LsNSL2QNoi6+Xq7HGBbWe+i2K+f+X+3GttlnGsNeQDQo9HK2VYriQgdmAYgW/IXgfBxCC3gZTMbtarbXeWsIm2z576K5ukWbqytEjf3JCuD58uGXrX9yzKWt2XX1+O88Tf6SXAAOiQiJcI0RftObl0e5/mTQeqUCrX4vvP8TqvFe6XQD55Alv/hCxtB7P/RKQRsvHmg+s6u172QTTEtvHbyssy4XFVJoqJBIJuniB7B5BdTa9xTGmkKDhDHzyyPAXTzaXOEG9+3tH3Yjtl+mO5cV4Pvq7xwt5d0xnj7sqNov8zNKugGpH/Tt626hpx7t9slev+dcePluS8sdC1hFn2+/3844ssOKYQpztThVnWNdDl071pH+FN3uyBfS9wCJFU+7SlTk39zZnG9XfqOket3aCpNTewpNaVDhEnvEK/d9q50DUloGWT5acNjUnX60aouWKqe+4A45XQvlcjY3Z+4kZhVNZni15uUqBdDLBacxnhQ+cIsvZ3dEVIclr4OaFBjYt5W0R6xC4DEmeAub/fvtTBOdCopSbzj/Vd1dC0WFlnut/AEzlbTl2S8LxqWDGobuqdXkhMhF7QAykrBw3ZEeKkzUTZn6RY1Bt3eTWnQjD4dZQzGi3rWPHBmhQPe6enmI0N+Ciig4yTaaA2q5N1FeUZE91b8vFuHqSOa7ZM2P3VMW/WLA8cMlHlgBOw57v3FtDsnPxnDGqErpgWWvieq/A8twdjOWNftokU3pKbIVAi8FtQ9WyVstZxGL5qXIFA9hw2Yl7W7NfneNqA3vzwkmlYMd8uWTZsKPXxY/dDyfPNGUyMHfqe6GfZqmo40p0mpUfVZbyHuxKGbHW9nygaBF9TYdgTCJoebQPZwt+qulbVUoXkbo5MaK+8TMAj5Nz4dHQ9zaND1yud1yZIPhJjhX8SNE32nIQ5qRwWDtMaSub4YyE+d24cbe3j67VFds93twOU8RQp3kqE4GMui1a0hzNXnICc4NFPRhuGXL9xIRnSZqhctpBqVeHTNSwEDT0q2WlhF7gm8Jmj1pjz3n2hpCef30JFPU3cTUFYUsRAxIgHulLOEVR9yxT1pVK1cYo7YJz65/LOwq+Knwx8QdQ3Mw6YPRpHR7GNtuI11Yp04zbRqjkbrcVwuUz1YoRK83iU34D9sd+lUjQwHZJL7uDoIMqQc1HgTmI5mmfrFnhL22xBv1KntZPSRr3cJEzbZv4XiV71B0tuWk7Vcf5k1yzVfjioviFpRng5ZmAa/1EnTEFmBFD+N545sYzJv4V+TfAYOzk1psovKb4AqaHgP7gxDpcfiOvhQBMLRA7vxcmDix45CJmzTnEGnm7XbT9PYT+cO+dPYay96u8ohBme1Ccec9PXBYGLjCZYEfQ+vvK7UUiqVcDDW5al0/euKvUoKNMrBQN04dc681tV4CvBvW+fHLxwjTc0UvmP20W2qhKp6sq3HRXlFYOTOPRDyiPaBk4lm1s+bSY9Botyd2nIQboigVOtC4vl+CACBJzloNkIZ9Dhrjd1/B2oTwQCS5ZreBtyHtwXPt0tpmaju9gYr0rYVbxMS9KFfb/XCnmj2+Br7129CKV558B7TtUsbZ5XPTuhyVEuJDKIl/C8UWsMDwd966A9Cqmy6OLWvfF3HHFtUpy2GKUP4GvM9sge9gOAGRFVCCh6V61tLmLHW+VLBLC5jpFGcyGyX3LNHdt7jmhEgr2kvK2VKxCOlsU8Ehq0mTI2sn83cH4HSFxzMOIiyFehzbX4KWGHHMOoDjnh7bRyNaBZcgneQVl1Bf7gVCEHvituZI/58cR/3iO/yga4p4vRpewX7iTsCQ/rbJUffNWl9NRQX7BC1WNE82/5lyhn+O3/zu41NBVW/UKdeXrwJjMtOqW3hOYfIQFfMTzjFFAuzYNzOEbYiQBXmkhhxsxPC+dkHFvYzk9TJUNmlISoG8RyY0Z7VKlo4uOXNS2ZnMmyfsObp40KEQ7c/YAop0u8ZsL1Z+V2F9jmCv0PzLWGMTNu6rPf6jG2mXVQ8W7tV0lkIPI1NcJ28LX8dsBUG8NWVUU5VCxkTRMdjtFLOD1jHN8rRRS7S+xED8akjmLfsgP1eVZqkkJ8d6YoUYTtidGqiDxEZdYzA3teDnJsVYirfxJ79rSGL5c4CrzKP60DispPdcSesX45cVjXdceiGHmm8uV1AQm/HXfdlIkH4S4tAafa+ruN0H4R3XuLUKGJoh8XXwFnT/y0UAQdOE6XFcPcfWU9RchCBygIvZAw2esWqyouYYlGchIp4LL9woq1DSDJwBUwS4mpaA/x1Ide0VLYgsUFq4d59EmX16/sLJNAZ0zub6lXtO+EPo0We1NIBZyRWdm5HWMciNv8SKGdhqYi6vlyIFlkX6K+EHVU0tSbfn5IcvG9DnveR6/tSgAhBw34ml5G2OFrTFUM/FnSDj2O81I8dbXqfrwYYEPRWHdSMnp1OUYWPsmAFmMYBdLko2lPgcHepwNmipeS/OrVmSJRC6i+fkV4XQKKelGKFOTw72wso6pHYrIY2MLZ9JGAF+QT+DT39SirLPpzWCrzjtmlT02vJxobck0FD3Jzr5E82s62fwtUuwlkGiVPH8ovA9LhEKQ/zSnbZFHpoOGuxixISh8qrPkZ4uekr1HYxWTWvayU3hufDaxE+6UV1aXvXnTrkDA+YnUwP3LzK52VU99Ds3aZSbCfNQJD0pbB+s8PgLdFHuNzMEQ4vfNIOCTWg1uFQiNxfPKbBWoQQhovScZxUgcCCnG2MtX7w+hgNEpskFDI4yH11I9obkKnX3vAoHyG5EEKh9lRcyRby+N+tvUIiVvAgwYj/Ps3fw/Bm00UvBPwvkpKhnaPng3STk9D0dBn1NNm2mHVXAmqx0u3gyAmo0OlAfiBIMU6N3RZkUEk6n9ywxh31a/mpWu4BTiHLBUBX879BALxXwiP6Mg67VAAhwSIb5zjeOMHaUICTDkFIG9yUENuMTl7Inuzr3nebErOl7h5rt6WRL/1C+HSTjl/ge4myepz7OfmmIE0uF5XVoQ4MFQorFK279FkBks4SjnPsjS+EujIoFMyK8JMxw3vuQ2QQvlqlamm2vV/vWuDhcfB050YE3Eb9aOskR7RJ5KRZ/3ZuEfiOKXOUgAjGkV6+ZlWa0qC2zpwj44dSD3VPsGpBRNGylQ6B/R2TyhkdaW7oKoq6n0N24wobnqY9jfTUC0ivtNlfLMpPzp32c+SNt2oEjqs6ZEd8GIx9lwtC7YEIVdBzyDcvlD8kByszfjO721S+sXAyvlqtO23+7tYjgCdkGgy33QDDD53YhA1EDU/cTNea/HO5w+IkmfwE6kfuB8pmCCIW1BJYVbSVR6A462ReOzYPcW9b+8A8vBp54XbBGb6pjq/HvW/dMUe3zR8yGWbRQVWeqsXmK5KlVJSfCWDz0I5HpYlo9WbQHzDR2mFYU380W/3c4zccOGBGGjwFjsF6FiyoCbPcgbtE38yMEbrAa2Vx6kEaxWEp+SAu3m6p64D5KvbCMzs9ewwGbYAJ34mU1004AvoNBNwvUIVQ6On0rzZMHTZ2v3TbmrRXd0xY29OMRTNWkaW99SDOEub0c90YyRzBSrSkdEvSaJBSKbiT3lzuhdPG275qbv1KjJswMQwTctKcbmFrilnP7ZBkeHMv0vJlX/JvYci8fqhUDCQdY4YedR6IHVPuK8wCk/zsDbtxh51N+XF1W4bc3lMTSa65QrZQgWDIw3DHwVddOKA1ICNOc3xo1OCzB7sZ1bl4Bllbcu8+tDlcK+NpnA7VufafMsRVygguZXEB0T2HaGPvbHp8vtG57ux1CfV5E9cbrMZRUua47QNYTtk2W7MVjG9Chvjt4Eg4+BoiZuzqoADaW0CflH5p2tW26Ed1XVH84V55Vm1w5JheGHNgjqgvgBYEKQzBOs7i6NclxswKmI4pSIo69KHWwpMKfopo+70fyTMw5zPShNfA7d20gmIAV8qhEFSojtXApoT7z8Se67TRahvhLVuvJvMD3hMemhANQMOjW/aDL8C5WDaGl7TnFvYVmtsiWdY17JyOps8MlYMJLDWsHy43CmA4hW8hdtA/d8xWLIuJxW0WxSWIKNJFFBkO8wkbkFlcr4kD8kAr+EfoPwtTuUci9ZTz6VtWCPSl2uLh3+y0btTJ56cTTH6/MSUevSRa4aa/a1haR9qwYNO9slqCSgq2bE6DwKDeC5DcWkd57y3beA3hpnzaTKdob55e9tbGz0NoVScOCi2QSlCHEx0pr7jIzFhvJkJW4dZsAIZ5JKKuZuJCNAbWjX3uKeHV2DJZAyHT3jdZjptg2Xrnpq+tOhTvJsfpJNUi4oGzAglO1iyCRB/4hjelOPG3AcmIqRTw1nJm3sIUrn7G1Lb4Ktt9KJ8P2C3T1gB7kRhHuRxKEvLc5YtBPXSNbSs9FojiscizCB5sVj8LvoynurBgEGge7r9Kb6HVCMQKLgf5iWa2N+WjbSn9mGeew03zYrKKANqcv8S8rU6H+5xSY6z87TBphsP4e348Z3s/rrobVsBNWfPkM27UpCyoWnbT8Ni0ZJlLFs/y6i5IDXeWU/XdizWePi8HGw/IFZHKYYfqGqIAL+4pj+M2TP//cPQgopVvIv50A+/oIUDpmDXImniGNvufS8Hub+M6rXqz+QdtoSVMucRco1qbQ/Tq3mnw0+bxKMY4vI1YwDfiTrWAw+syKOrYABclIGTj67knvObQJFwrnLIHjh1f42azaQbzJW06n+BpmbfaJQgmI1t90cDxjjXJeufz+P7W/ptxibetN7pDT1rMjHmygzvBldIOW/XuFc8m9j0jmZlFA3gyWXt8nAjwQmBKfiCD+nH60tyBOJFCnQ9R9jKcbWk9ldexUfnYoyAECxmc9QiJ6lagLh9AJQNvo0s0KMwq+BpvEEOfJ7CWU69oFXWBtxj813Pm8qt0OM74OGm9PVYbh5KW4D0CFxNAdakoXQtpoV5LI5CqOOkW1Myfbei0eGiaQEDK+ZNZS3OiWwgaho/fNk3LtupRWD8vlnprmq/xqrOtDs2reH15N26W+baJGZPEFQHeAHbJidi3OGKC2qeC7dicwobYHKfnzfqHwis9ZdzsI3z+uTjUtKCmxQsk81DkZcZTOvaeY4pwxOS3MNSSdMcYFvAb+J+QqOUdQFQpOtNwhrVerWEnQ/qufEQyNLbXGKjytEd6uiRvgoj4P9w7IefwX+FkCb+kg49FqOkQ93ToeSbttx+/ekbbnjSL21qq0eYijRSA9umSZ7jIhVKyfWbRA6Tsy3omyr2XdEtWazW74P90pd6L7+FSHHWf+35+AdqIDIlJ9xumIXfDAhPXaU+9gUHL8Yp74A6iy3JMJOoObR5pkkxq5JknizOvBEq3bEii+138qDaxPMgi05GjegPAplU10UZhmtOxd5TyOBmhRNx4M0ViixCYGTEq86MWrmk6NuvZKtjg1ITAd1zs/j2gF9/weszV3iTIk9F1PTuS0I5HjqrLKlB4s2GHvTCWzvAB5Vu0wEQvU1+pIjtLYhn3oRKGWoZmMKk486y/AHgaJsF+AkuhP8i3ZEpRRixoPOLj9nqMF1eOWjrsIXDJqCziBdezFDMCiMcGbyJIkho69km4AgmcIjDI0NMwU1tlcULCbI8cKxLMV4yMwl0YWxVmF2rCyrleRl7ktp5Qim8Ndg+R9ts+qamhS3vIVKp1CTYSfWBrH3wz4PkBJrjg/GFiSBpoUfmZqNHpA8s5XerqGIdxh3o+tKXI3yFPMHP5048tfqq8JzVCArDJFgKyXarmsObMF8/aDW+srSUFLqfXm7eeVv5KXm7B336M5z4Y7f+UdeKkC+gdMNRdj90wOGMAde1ZFx5RWRRlMO7MVIF5aJju0xfldAAigWnxf43vZ9tkC3hxqSL9JDfD8qP1sDW3on4wvkvImGCeEDUrZj0cVwll9mt+/aBS8v2/GxCBlx7w636ejQNNcDvwabvT2JkiDvB8KbmSOCrV0014cAHrkl9uS5pe7jGSCfPfq+2C/WTjcdt0YBfn9cW735glkzZ8k5rSX6PX+khiRuDTmDmZ1z1K0IdcnF2ivKIeYxCzmZtZbeN8RucFYWLZqAEqLVHoaI/fAcGVuTVCMB2VPhO5Vlt+R75TB8C3dffkWGmbqkHO1ue5jFuJRSoSwkJ16Y5HdswGYkw+klAf6z3mzxrgNG+rCFPBQo/0whM/twDfDrotd6e+jBpkE7G6rbFhAJKlahLMSeXzDp+s3vgozuxiI3OYj1Fw6k/r20QXZYvbNx7H8sUOJyLYQdLzOpoT/3l6xwghw4DjMN8HfoCxD0RW1GWruGaK7MphjIrb1K++rUWohQ+rlNdXUh+d+9N38uaFvzGyKJh81l7WL8W74u4QOcj2o2eX2v/Rle1lwi6f8xMxRgV37qwaRRX/wcMD61kam55G6xbaN8JL51Cc1FdiYudLQWyG4mTDMQQFk5CN76YeYAX+uthltMsf8T36r/Z4HSYX3/QI7pdpMv/8XawPWZ2wXNs3H5tofzMlxx3OebBmzEz35DSQSbIgbSFpGfHtOujJTjab8L6DU4CVf6bmgkxbr9IsrRVZZ7WLnyUa7T1iEQ67dTIBiXGbn8Atjf9zTpuJ8Gn+VYCvJ81+N6L+BliNly4nSyDOs9+ml8zynnyXDIEML8i8T8D2IN/VQS6P9S3/B3mOMTqv+UwzzBlLHfNzXf7K7wTx32X7DDkiTro2dGW3QWwwAH1j/nskWOHl1+wmRuRMchYVMh4EcZd4d1NeK1AMIy9kvgarccnBQ+15gSnsSJvCoudIPD3S7+d6h4NOjbfnAgqJOReVU9QvLiZTiIS8tDWO0xpNoSFqaFVm7GDEcnFInf3P19m3nuHxkGzyGNLu+Gkn6Wp9AP0gOr9h5o7L+ZzwrG7pdLV4LaPrSOigzyBaUKjVjjhcoHm/Nj6L8HgUOj085UaIy0xOr+9ZtGK6rdH1ZkLRi/eBJOm9AQqD28QVCl+rb4u7Q+tjErQBOVe3E+WXsjXT10Z2Y1dogbosHKuWE6Zg4SbaaCP9DptNMTqUHBJUWW0eBsPKaXY3fLEEhC/ktwmlxgR5tQvHUWED6zh8rNGxFl9uLVHJHgFF12uaJDOjK/CudNAMDPKJCyURuGB0BHDTTvoOVIXWGJY6JDEvXUHO+g5aiYDzEHY0/7R39f84/OnsoqCnUajr9UOUBjZgFrR2izsiVYuu6BLNc/PP7DpyeS5yHwmidj5ouoMCb0M5wTXsh6zFsQBgxN3oG4KSey+FpIMXH34ZIXm5+pqo/N2FffzBxAD1bZlWt/XoXEveGplxjP3p5icfpZ/61tPK3E1JOZS1AtKdB4IrsWxyKMJCvT/VJOofK7nOZFFGYEZU7FMRmS+LpXjxoDSvzA/9AX2irYOtLsy+eJSPjnrFCp+52frS85EDPQnxYgi/x30snmAt7v3m2Bp1I3ZnyXQyC+hJj5QbdhNf9W55MPxRSwZxhYX8J3vHOw7WNsoRjjSM7wy+awD70Lz5IMGVfEq92V/szXTl0O/rD5NUka65TBzrWHOvSUFeaMOX9nRAYVPDyxYS+HL/h8WUmSE1t1FVGbk8hz9JF8pv1cZ8mO4qeXPAOiC5W0Gk9l55EC9poVEo7GfPkb+q2SJ7gEJMoxg4uhxXMXTqnMHJ97qiNfMZezmlNFMmf7J/rTzT+B1GOdPZRVKaiaM4jVYCJ/rIuRrR0hrc0tVZPMFERBMFG+EvvCkhefuwyDxRSzOISGCn6lMdoNRXixKEfd9oWwc9nbJU84okCun+cFhUuTH2O15GDRxygRrdRTIWmoMJh67e8giBSUs2lfD+N8T/d5kP1rNEwXdduDfp5k8NmER1d3NTL66Pu+ujKhDsHa++7KRI4KltIcL9AhPs0NP3fmo0EduMv9E4nl7EA8j8PHJrkKDi5v8rD8waX6X2J1CC0aQMGNp0hwaRJ3redjkTDvxmS6nFjxHfqPqILMnfRFO93/4owftBh7BM/MeweZsWQ42iIF8wRCYHK8hQ2wwcPkcL70R35n6AgGsy7Nr2g4Y1ISha/RZwv2igcXkrj1D6iUePuQ0/8YflyaalU9hnBBSOBwTVxeCBuGYZbvWoqb19MG+aSbMaFIk/WQ6fPDeAgN1ODT9R23qFUdqUaw1NAHmaDM9Ma3f6ih6tLGlkwqjkY+OJV1V8OqtiuSDztO6KU3MU/1KsTyUNgnI+CNsbeTABaSLpg57iKn3WoaSO4qmENYgbWX+L3RT1RwzgXWFOVRMbtLaymrodHBmBYZlSq9xc8PMlWoZi7hGm9Fa9HE7trVMbGhC4gsc1tm4vEHuOen1k62vMOYy4ninF11mbxJ35afG96OPod7CPPb9rvmHhvUCDm8itxowOFWmQHBl9WuPFa1Jn48soG7ZjrYaFvnip8cicwwsyAudVGvi7QpBKGhzmQRQysjhX6nJeYTCQAXsXZ4AY00grgasQG9pKlPRwAQ2oajSlmR7E0YCZsj4p8Y4JX2AJCN6D2waZ0Tp4GEj5c9PRed0c/WnIr3nYx2fwTC3Q9kygWH8hKPMpq2EMB2c9wcoEmuJO9uDldUaooPCdYaStwdlH2UjK7UFFXk6flRrjRIIiYwT7kt8P5C0T8qjUXhPuDm1dh4sBCirvkdPStNhw+OrNfotRUcRP4gZLB2duzUNRGN3PCgEGcItjsHFZaC0s6ySucuJOG6XXgs+3ls+eTRB1f5ySU0HWHj8BvMcHl7cQKaOVOi+ln3zsOqJn0rdMzSJwVFAebVh/sbSMuFFowfWkra8jE1fNHqT38k7pBow4PeFAmi/gU3pmEz3BvuMW9WrR7ybu2OIdRo8Cp8vfuez8NgffhkxtlwYuNnoWbh+is5QHqxKKEOeVMbYL++enO+42tNHFtC5gysZuspSkjCbXTupw0Pk7b6Bf4/83wFLnMBQ6/rHVGtzik7z1QbMEeCIOi8GXxs0TtmITgLHIbPS75hssK9MuVGgZmZGUYfmx0FnkCfDdjXDnVbOw3WPhkvKWMTreO7Dxl/NcMKVJDSbCLjCjHHjl6UV5j+einglDjr9Fj+lS1ACJLLTmDaR8Fb+Bvqo8PlDHJC+XKY+IW5ERTbNotNp8iLqsvYaRhQ6QevtMgiXBwIXI955I+YS802lcjHSP1nvZtaYlEYZ7TGorFpv7EWVPKF21x45GjN5bL9j1173jPA97JjAWF8WgYRUCGrPkk8qwBOmfEpnz2AFTlz26YYO8FnkIoCqmKXtKCNYM8LV063I8D9a53QuvqVBeirzXvRBRGEMag2iGJNUnPBPV88Vj18Prcnbf0vL0Ta9CVLnt0A2iXW2DiiQlnLi4RcDrNsCKOAJ6t2BsOhf2kd5mfF+Cquq9osZUzc9/xb4FrA51SgNVeK3b5k4yNVSz1UQyT/H9oqrGnEa8Qr4tb57Im/kFl+xvuWPd950CziP2Dw7MBMhkJIr6X6rLXArClPIGGOIKGbpC7Bd5JvPqUTqJdPLZHIQThUll8eKY+T43ajjbkWmipI+9CHF4b4WL6s73jiShcf/z+TFnkJbGv1RBOnxRpOprA9bMbvhgFkA2ExCz5aWPBWtS9Z+WEoVRj2Jl/E38tfkj1YOPtniLiUssSqMNotzlCGwZhhDvD+ALmvcjoZVWH3VjbljJwXi+foOcH6RK4cPaWKecMlIZXxYH6L6t54KRNbVp4AK26VGkOZJn6BFOq4eSdt3kcuFhiKknm+u2c8bBUtQDllfgPMo3FlJBSqwQAZrSHlZSBgm5TBdtu2LA+7UXdyDLjJHdL63X5+bwyHuiDl9176RcA6XZMC2Y9bCCi8eqX8gM0cbYdLpWQM5dMR6mCK+KoW4qAvPTx0fisPGnwB4qSMuLrv6USbZShZPOfQc2GHz2SO5NA317QZPnusmqg8Nwkvq2rWOVHfWyhC8CqdhlRk49L3EUc8+FOJKFltBM50aH2/DgQhpc67I8zc4r7avA3uSFadw2LUnrtZjckZeES22WlW0+AuXlGOTqcCmDJCuK06TpVjcef5H4+UF/R/Tk9SAWkW6xvcV6OkbGPUvhNec2uuSlXH1Ov0sZ8rHwGsO4GH9OgvifdgJOt8obkdBPyzutL+FaT/lt99cHiTFYsHBpprVfi9GRzGxjhcuz7BL7oHs4CdVvRgp3XNrFKlebQjh7rKlAz6dch/eYsZN5RfKHoptVhGHn2NF6mnLSXN57Ob99UFtrZubwuv+H40qI+KFzwLtDAVRgXXCx4ceL8cFYbUCaMZwNsR17aEj04t0v3rWEDsvpoSoW94WEZYfYE/lNhAQNNpZ0Ty0tEl0ulvGMyCLMfjJqf47q5C/8UffCQTKxpvRXhzAb9AawR07/mzerJoTBAd/J9Oebv1pQwXcO0e8lWc+soiqaJDMjL0EWNaeud3GRB2g6uKtMufxyGpI/rjCBBW9rfELHVnYMSXlX1GLCcFtuTag4UDZVy+5FUabx5rYCl2H51XAt/r5NcOPrAB1n2Wrj1ktPE8ymYTv7wtJ6Kzry1oIwvy1lpGG1bs/pv9c/h1m/3qWGATcMKTHaAMP2CdzbJPPqOiy/O65+xDwCR+IWBHfHyGoR0zgGPTk/SgEM8qBrroWjTyRoB4BHlHI5OfrggB8LYY2ziMvcho6BY/d36rTHlBHOxRMWz3Vn1nYpyyERRJ7iY7Kc+nUXMp0o83l8evKIhT4qNShiSZMx1b3xYhhs8ZdVwL5XRiz9BHYkH5uLq4YimOrxxNS0/MF5lNwjK98KasEdAnBRODMeNPsl6VJL1+QSh53l+WaTUYfitj476bzQCp/jTtwftOCWnzqRgjf3lM8PBRD0QpCjQyk/O/yOif/jOWM/kn3Pz0u5L83M4vj1a1yN99INUdIyi91ff50d7triAjO6jev3xLwSGCMIrKSwd1OjJoUKt0YoFNrOOv4KrMiGJAXQICU86WYHLhkrFfRcBUb6m2QwnlonWuyplLo0Jr7RYtmBY4YRzV669bVWpeoL5mvqG4DVhLygJGOz/0UVoSm+YGkiFQV0j/NqCsu3J26PDfQ+ViXJLxz+BjGN3t4kEqcvfulFgpp457EqTQOZBgl99Zk6uF+0E4wpGDCy31ymnawe5Gub1MjhlqdYDeyJ9P8AIk1H5y4596gnFbI+YuOiIxYac0qSFeSgM5EUxD/4F+anCx/69CAu397gUzqfggCLveU2PVSuclY7iT/9necPcCLZqD9Defwce+wph2jr+B9lchKgQZ34SfYQyCQsA+PmJL7QrhN8UUn62L9wzJOMsZmWLy6qKCSKW8zNy6snatTZSfJIzVJRLS+L3rRw/svL90Uzy053JnO44ppKdLsxpQNBoGmBYBsHEu1q/iqCyXfXQJpwLu2BiKtZv3sOwsYbpQeqhG6GZNY32KSgQAGQuh5+Mn2qR8nDoju/MlHY4TjupFS7aWwqwzqlApVkU1r/Sk41e1uWaa1X/IIzAypzIX0W1eJ9N7AzrkL+jNMJc9Sy/RiWgjSq0f8Q2Gg/4sPnR/laO7okrojalMgF3UT7JkmbVsnEdDdixPuTzNk57QYpfJd2g7iV06U0mrRSd961qV2TU9UvoEu/FhqmI3yJsXdEGqPb/RfTo9lVQCSJ9YJGywa6st+E45/kaLb6GMGcDl0+sMMN8WwZoxlkEGI3hDUUhzLh4r/jB1TGWKPsNvop9AUQx+jIQG5MttrGS/+CK53qU5p3pMfUDRRSUbp3biZciEAa7VDaO7AU27omts2DLD8LjtQpHWalIPskqwnaSf5hH8GfATgHuEGPposvwpdt4fMtqWjBylqrib3Y7PtqpTeS1MfB5NibkKfQMe74vFUqFoo7L6bTzRJMvegio9xw0gWmqbl2F4ZtLpB0i6pegWjNHbMVEMM6YMJfTaY6q45SXP6PR2+4qmKDMDZwfu8zKtSXJ1irtVUm8WbPJ52ZlEbACdITNhI1/IcasJPDPiqknoTt1Z0XctHiuqssQJtvzlATNvxA8d8BXvjUZoMF6zz66arJfXdgQxapl1hywA7/onaEpactwSZhr98V7/bk/2uVcOUA3UPfLoBB8TXnkv1uLDkfpQwZ/mGUafJ1B9jg6CUi4yo3MPfFvbebi0UYt4FT1FymyuqeWeeOqewrY0iUxo/7a9147AtuYZAf3/yhj19kNWKVP3ffSPA4sEd54I2mbZXDfMxYaoVK/qcmRBvPrVxYEXSu6MU1hUVrsNWEWI8VGPrbFI5+oq8TJWZSIgBAqRQgyQjBdjhTDoaPgfC+KcSNQe63Ow/c/0MXB4Y8d9PNa1QuKPxR33WNq5jEtC7Q5ebaRa4L9E8Ky6HRtkmacTcus+GHIBUqlgGiTYm2+m3D41xHCZJFfYhwMTfAotkAZSSxDwlxp+U/6ODM1Vwq2NEIBbm2cXTh7OMmqZ/P+93IUguOJkK9Ex+KSzYpVRga4hJk5glZSK7u7Qg05exAP6kv7l9zbDP7CrjxZWo7eTq9Lcr8VAvQDmmuzHWk6CpJzbI9OVF5V+Z5A+2DDvgI/uw/KfvbJvE6Ja6uXfMJdh+1HH0NhON4pe6etG16zTc1w2ABICN3wHmdA/78K5E9iCuFXu3IIiJ6BaAuxyQV9HmsxWixiwre5TGrPVGjn9VktocLbcfLMf583Qp4Ehigwhgxk7UyLzbPSdcE12DuylBm0MkmQ0Lj5gMhqSUe1adJSUU5K6iBoR0YO+k32/Jtr0qNVUCCuoRKtwziBxxg/t9sc+tpdkGmkarD+/zAcfhV5bX8PRn43KekCSR/+1V2nX8eoe/2s2I/xGDFeKUL06O2ca5IIMmBppkNzfycVwMlkmduYojwo0iLvt4zkiZCl2pzceV/Lz0NxXaQ0cmOQhV/IHLfmbxSWm9VOk81D1yD5Ltcq5GFVHCXP7SuzWB9bJKi1FBNTKtwGmKmm3ykuaWr5l075DRg0OwLThaIeIRHdFXspvOD1ckt0e11oSoIwk69Xr8k8vYcXcpH2l9RLXv2ZPsdI2P9VpG+M1VIrPyNjRCWh0QtHzM6ntt9dsNJKmdKPFI7BOO7RU0GxNzIUug8xuksea1WNoRn20UZ4GYIAompOnQ1S8N+gOA/2WkEmJziLrWZJA8zcPbSxbj03Iub6K/DdUiFyDvkPY1CMXPjNvylVx8ah7EwgMgoZoGfVY46QtkWBtyG/xDjsY6v0GkfECKeV9KG1kXCgTyyfmYQnu9a3H5AUpXzHflnb7DHZVsAy54OOkKoA5HaaxcvVHKE3JUmN3kfNUfG2xVBcebZUOPtiPhRdCPepdsNSeglMKd8Z3zr70pO1s73ff83ddY46XAP+/4qopwkN605PTh5PdkT8rJFmSryOae/GyNw9zYRfs+ckKt+Yp+BRhAHhJ15SVTpU/z400H7+5srqtbN0C8qgbh/RDOOW5R/oAlpa8AeTnUeYyUgdpjyiPsCOg6PgdnWm7SBmLux5N6XH4e3DIke/JSSOw0FrevHQpLP7xleC41RYW5rSZShX1oxB+69DbZDx/KvuEnG24tM2gWvejqGWC2/N6/XhtZmQ+Opezsx05W/4Fk/HH+pw37auNM49/XmbE751neWtocV1PE7n0SqX1uzka4lUzrr++3hVWuelcea7zjE363SHstEzDi40aeCJ+WcR2DL5zxYyuZwmbn6j96jQdsetoIay/2+WmAfXeDBYjsQY0ktzGWTikIjJyyL1+tVzHCTgAnDWUZG33A1hrZ7vw+yrjLeVwEZeXEPwACDRzZIU3AlnpQR9zCyXvZ1Ndbhm5EtmFCE149w88jqtuPoD10sril5O4kb5XdiZhnQsSqTmj32Vj45vLvkP6Fj7I2axgblIC9YrXNk0JrxGao4FUIFK/sug7xBG+g/CZF5PZcKoyNSU6fPF6EWlRsLZpZMGF9pemb4cwUrPE4OAINmlFdPUp1ti/NvJYawSAmOs4wAxko5Q0L0IV07bjox3x5CmYZtl2rbmGBke8NxW47lXx8+mPh8inYeExIHxnq6zF854tQsX/W1L1rDPqQYlOLqOt3NCV+utWE8ck3KlOFNPMghsVaIQFyG7NmPiuW4oxEXW1rOhVC+KZP45eo3ryr15yPgbLac+5oIvBp3aIn4bYWUfw/O9RqKnFGLbxm4BCoh6DyvygHoOYbrM7tn11P7eVG0eHlzFo+4aOtKUKi/ZjIEyuhef1W2RLm6WaiVfVVnlnXLeEjlQb8ftlBhxLo6ns+IuEPbb6YXiQ8C9e8ISpuwWqbgE1tcaYezRFpsRRRfpW3QauIvWAbXP5dCWL7sHAokQhwQ0d1RtCJEqbZewm3lvsqgVljSCGoEcY1KegkRh+YDYjzKyVQGP3gYGxNLWBPOzYf24IHEmlcl1UqhlSUl0sqWUtNNrQixNIi+Xpwfcp/+IHUAax9rYGlzpXadqCjunNVg2Mgnz3ouecXzs0jrg+1vFWtSJxIHq2LyzimB5bHpp1M6oKZnAztP6dRkQir0AEobHDar071pwMPS3GcYVXdTl1RYLLy6+PP6Ej8U9HpnkPln+d0B+smm/GyF6ntEUwVEkay0m30cCWy8VqCHwqqiWV+Fu57egNCxa5c6cfhkmRKIQEFlu1CeuScmnT9dylWxyeUDVTHoI6lqX6aDuaOkCjTpirltYpOhLuJ0RtaQTn2+C6/m5iLaq/E6TE+eVjdbEULtVx3vpCvRsuXiHJZEMcqG+geGC8a9h2AoulRcBc3AA0NOarukFrTbJOh3bACr1HtXZgYJEF4SC/9z1NNyF9Cm44ZDXESmB7Yi2VsFFd/xladRn419XfZut5Vpam928/mZAFls2dRQHJX7etav+DHVXuxKjTdHjDg9wNe/dQUcPoLwv+zEVaE//QSjZtLJWIBvTh9JsGwHGMJyaGV4Fm9Z+rGFRJM55RtS/Ub61O6KaHMLPWxvzCnTW3HJ+WDF8EnHx25e0wgWFeWZzl4149Fyzet7HoQGMOfbgvqnhQGm1fKWGx2mZ9HguJMzRHj58wGk4KPlJjiX/LH63ljFIHpnLjp0azi1GngZ1CaZTryLcgLvFAimBc/KIzcdj8hcsX8q82BsLngaNHtFkQt+69Jv8esI8mmMFT5LuwveFiGvblHSSx6EYVIpeudWXUswzeIuZobK2jv+2PnKc3Q9uKtZSnPKPEra6/P0il7JPFem0OZ0kl2jAGU+QA97eLo+7+UR0uj0kBWdE6V8HrAIv1bmAvve4D7D6vBxURNMIP9lw+4WfG7pMiks1RfHKpHzbsSLboItogs2m4KgLNIXtgl5BoRlgtk2uj0JUbRaqCeuJA89Z9+vW5VOvkeJQVECOACzZgiVyyrTUU9hWOfGr52ApCYy32pJQuDr0OZ+2ET0E+SPfLAcmsZlVCr77Qw1RdSdUN0vBtoi6lGzBUujRiUkCb8C26uZyMV3wLAy3N7vtSsPEtN6iYviTAUPerdKWouEjXCOlkAMYVUmjc1A9dAxPGSjqDBlOPhqp03sidNzt9Dg6XkiV59ZXwzJzmsasJu97m5V38/RcEowhRI5Ebks2YnJ6ZBBoW37WLV/AFATzt9m7/N2CkyOCydAcpteTInZtO4QLSLS5S/8Vm7baJMKWL1Kh8rHjHXtn4JNJN1ZWizVKdAAIQh0tieRFw52U4LvIjK8jaEA4EH1evRDEmQi6mkuOsDz/gEUTW1HTvj/lIMXmAdsZAyimHEjQiPteZ5LGSJgsV9Gx9rMEhUn2djnVpxVrLxJvtBgSouqcCr7kmTwHgGEp+YNGh2Ka4p+CYs6w5u8G2D80ES1ryHLxcG8N1VV11i9v28UCbogFt+blvoonWQuhyH0YGNSLtaPq0R/+OqUd3SQS2lPgleNozP3LW+2oczN2xFZ2MbN/gt3zHX9vbjzFQLNypoclr+wD+k/j0/V2KhgQVY8QiaWCuHhgdRHYlfg8uNl6cqo9C9Ce/R5PHMs278URPUNjApOwqMCe3hxsHzHOlySYwN+baEO7QWbB40O0/EFvsGI/zw7BNP3PNMuC2KniHM7hosYG+sECtpcGQcqSYABYv9MnltZPWBrJtBxZXLIaNomD6XSwzfesEDEalnTOEfu6UKj2/OozY8m1thixOZQyXEW+guOzyofGftDFzu2tNd6UoFq9aCgG2F91l9VC5Za5k0WDlJpfU0FBAc2tXUzhLH9vS/C9FYQVpYXjIaroZOjkm7nrlDzraZk5uFjFxn0ZBU/TwRxvwZtPBXuQyPoBjbJkUarj19oucAT9mETESvnH+/A5jlIqCx5qHGhAI/R5k7mXXcIZ7jL9NOf75Vcsthzxa30E/ZtWmxF0OlilBmsAbDKKFDe93VjZtrnNoSv4RiswHHGgbfHOcXCQD2atGJxCYpdApVglqagddrWjXrfSEDWWkUtp6d0eRcAAF9lOFWwnN97vJfR18bJj4ou6Ypu80H/9eXLjaAAVq9JjLwalDX+dN4NbCFjp3ARKnNS4VNbJ0kSRAtav5oikXNcYtXcVYkktA+Ts1GuntFZWM82v4lKzN1EaW3KPC8Qg1jm547iIbA4timmdtFl/n5W9coJGB8UiqA/n78MQjELJYoIp5WE6DpZCtG760XnU31Wjp6mrPGTN2hRx0+4Mo3cE74ZFeyR3WJoIX0K/z/1N5oQR5V+GZtrS/pCqE7ssvFKi3ZRo1JnbHAUzboVH1JrAYNXJQ1G4OETfPxv+1GQ7pSBWZF4U9Il3+C1a+ldZH6Jy1uT+cH89hPa6Pa+GsfKQPd1jjjUrXFX52e3GGF/mkWOCy8b56JlK+839Rp3e2YU5UAcJP6y2qa5F+Ch7EOhRkunyD8de9/xSQvxFD3a6Sl1qRUxgkvwC51kAVHMqCuoI+6/0IZuBrM0YoEQB1vMLOlvPWMkVOraOBanoGcyHLm5Ux24Gi37hv/mAjbjRTw91Q4622UClenBcGBEfoF9BD6p/ChNyP0wKGqTp4HKbXYpF0ornLuQM4PAdk7SPMRCYvXnmm6DWOv73w0EJV0uTGH/UC8a10hdpaShOx7MAKYkX4Yal2ENmLANkAHdWrTK7wC60VJocDzQ2wz9wfeGNBsv6BOtDhturPO5b8JLjhV9+WwCBkohSlqAc/SKCSlxMPyRqEKamefcL6AjUDSPYDJrgQFKLh+oU9Fg77wXZ5FoTfhaWjORN3muTxp1N6rKZO54AQkyWcYyVyV9brh+KvhE0Vy5Ixdw43jlnbhjiM0CxdKOQkh9B4CZQ3dWWOpuv1Rt4aJKZMKT0Ol6eZxugTwhwY9R+sh6A0vtktAPSlDC7ODJXfxh2IQly6IMsXumtiIpKr1Z7EpZOxyLg7cRDOC5XYlB5o2bGmIUNz/Ie0cTSuo05ZNvCHP+yPDEAsR2F/+ELV9WVe+ndGAPAgV1JtQuoOy7Tu0UKikSw+ekvLAw90PPHgZxdFPwGNddRqvnFJHnZ9dBfTLZSql3AlxZQB9UclVAIF2XmGGSoWt2TPCCt4Y3K9K562wM5YoYZBu1UA1l0T8hhYVIV5cH/45b082y+2mlNRxkFgB7opny3/J1bG3PNP+TR/VEcs5ZseS8uj1Z1//6EIEU1zRhYS2ZaMhV3KvIX2Et8GsZf2f8446qXqQTxjPtOSUX3hgo03uEPseT9T2Ty5L47HMi0Z+BkyaePPqlpAxzvI/qjlqOhrw+6HxcUp4bv03tp4IeiCsQOiu5/It41PbHwxpnrzZD0pVI2AQvqvUr2gxuM7jYgC3+pl3Q42QfKx4969SQm/8MSWn+StkvfURaQfHiJzBYJd7ZrViWL+Q8IBP2BkB6z3LuXH5m3SLEpD4ZWQxGbykPyIz980IxTGC9FnIMRaDKK0JZPUWchVWq8jZAxBxU1Wvw51jVMPyQHWrsS+yp8sN45Ga2sda+BI1HZ9AQGCLU3KMSDMXpp9ggbyUkcdky3AMZCLgfU5kCrhkexVCXU3XRZCBWzOjK/KUHiUcKRK7sP2J7+NQnyi23ToXCGeUO6DJ15INjKBNR9EwxTe5JY7ySENMeovHKGiIsKWUF/Z5QtLyFKOG0U5kCIKdwHCZkmzhcmqhTUV/rd+vcvaEi6fpdkskddPNkHOH/Mo9Q7hrxm5WG1VHxa/OfF9LgQYtCVTsde7Fx6sD6AVwpZwohx/K6boO5t4YnJdrG44ldAkaoqv8QzDTXSbLUyDdOdxA5Tn5Wt9l8ycNfWGms7D4P0k4HxtyrQpAhFyu5Zqu/BCAnyb1wOGi542ipyGAAolb7R66DQKJhP55Am9MuyLUWOR5IRn5NWs+elOyzj4Rbc6w7eK1z6rRRqF0w0+WVLxSzAWCAw0ZjCCPP2GjnQh4RZA8DWpzygPxF2SjnAao8F20FcXnAPxS0yLtepIErgfJBRgSPXdI2LOvqM8DpJwAQrztsgqyxfL8xNP2sZ9Xnu74OtFDp48egGr4y0cgTCv3gSZab0dcgzIfTklA57E1TPKRs5oo1305nMviIni6kCtcr2CVuVcGeZGz1ZvC8ro3NcemHJC+NFBHnoBsuMiZjexeS1q5XNWyZeikvUQu+b2KMDkRqdbif6czwfN9+RqTn0fsvsK0XlBY2HeM3qKWFDABHdlRsH3hd2sTEd87Ysg74FQLltykxNH6FrQE4l/KLlTYPu3FHIkzuZFyjlV47UhpmUsryqa58w4ZTKbajm2G1thS4PKymb6JqOFDScwH7oDhTOYmz5RPxvqGDLYwGkgpvO908ZguIg4+765DT3/LPuRyhSfoiTtCaDFZ+7L41yoO6cj8na1kDwV3WC2rkzgbVF5TUQBa25YcGbdx2hVi8fyhAhnwbOIrS7HJcsIRfgrtd0P2gqc5819vDU99nu/LE6bpQ8ohTs4jODf8IzsHMqTOuBbnbIqgRQ+ctEnH8kb09Ik5tIBFnfs//7745+VD8Q007buzznpf2IV9nmLmpNR9Yav1yea+RHTSYrUoOtfscAKY93OEhcUaoCfIBdvDeiNjpSeXzpWtJenav9IJH7E++frBRaICMN7sseORi1NG5u3Zq0C+h6R7sJxUe+V/HR22+C+pg2nzYUbjhirwt1rHkNRgfQSElHmxStimjvQs5SXiBLs11dWlaoz5OeygxPZQfHGrOQuR6MLLLHBSgrJBK8VabhZKezkBulSw0qXb6BGm9FsvyDOFSRQ0Q7QjglXRVrO9MDx2OK7reBaREB5276L/8vQ5BS1lL4mpSk0S3JqppLJ7WAyOuhSD7Gc1FrCKab4ocBVegkZYDtaEtpdGhZl5aa4MKfP3Qjt607UBg/Ig7uhXOVIyMTsRj7zcZxK8nXCZ7iN12SibUr4ux0FKqH2LYdOY0gcewMrGRO8eBQ7FKe3YQ+oUEIu9WMTPmSYyOZy9m1pH42XDKONewMJ4mJWZnp7n48SRcVyu85nojoi7aPEYmevixI6tt6cJImHdly+jTqye869YxZ8rIe9N5XXAHS+iRdGFlgaOEtDv6ECCD0+uhMzZ+RAeJ+qosxYxl8MwEGKlPoykmAwenhQDZ7fXCQBgBkgJPcpTYTqDMLonnezK6uug6FERlNLbSlHuyF5vPZNDbOa8Za6pVhEbZmPicv6xHZdOlQVevG9CKvJZX8Q2cKN4w+y1UwJIxJPu0iHKCQWUkdt+a+TJeDhMY7zre0V5mW4mhnJpvOoLjBBGwZHRfPOXVOX144dqWeSHzxk8kZfLRDEB/Nlgfe3S2TtJ/rp60cRvxAXZSktb2Xv11EDYivHp+YcgGeiOiqx7xXhkyDBGGog+pYm4FzBkDgc2MahUbq5KQTUShkb3trQcBw7X/69l5R2XgjI8IroHsb5iNdvdpfE9/riORESAcSq2462cvz/e3Qckl/qs6/DHEzAGdQHZfZnl/BPUWjeHKv4WKLEwZ1btVm3vLH3Qe7SwJ2mFs5UChaGr4PUl3gHEe820o2Z3l4Yc1IipWE5WPzF/RaQUg9PbthUmEyIJOPHjSnfyPPzAnW1D5fdE42jXUVtgrCNOpJcPS+I8TKKiEOzC9MOaH4H3r25H6KQsfIR9 </div>","site":{"data":{}},"excerpt":"这里不可以看哦！","more":"这里不可以看哦！","origin":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p>​    今天是十月十二号，阴，天灰蒙蒙的，仿佛和我此时的心境一般，此时我心身具备，虽然在国庆结束的前一天我拿到了第一个offer，可能也是唯一的一个offer了，尽管这份工作是那么的不尽人意。</p>\n<p><img src=\"/2019/10/12/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E6%AD%A6%E6%B1%89%E8%B7%91%E7%A7%8B%E6%8B%9B%E7%9A%84%E6%97%A5%E5%AD%90/QQ%E5%9B%BE%E7%89%8720191012190626.jpg\"></p>\n<p>​    我呢，现在是三峡大学计算机与信息学院在校2020应届生，为了秋招我从今年5月份开始准备，当时打算的就业方向是Unity3d客户端开发，哎！现在想想当时自己是不是太幼稚了，完全没有考虑过就业形势，而是全凭自己的兴趣一头扎入进去，就开始不闻窗外的苦学。结果真正到了秋招的时候，自己完全蒙了，去武汉大学和华中科技大学的校招的游戏公司一双手数足以，去三峡大学招聘的只需要三个手指😂。结果可想而知，九月份奋斗了一个月，也就吃了一个月的灰。</p>\n<p><img src=\"/2019/10/12/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E6%AD%A6%E6%B1%89%E8%B7%91%E7%A7%8B%E6%8B%9B%E7%9A%84%E6%97%A5%E5%AD%90/QQ%E5%9B%BE%E7%89%8720191012190452.jpg\"></p>\n<p>​    我东谷伯伯说的好啊，穷人的孩子，不该有梦想，带着梦想的穷孩子只会过得很累。家里没有足够的经济支持你去追求这些梦想。穷人的孩子更多的应该是考虑现实，而不是追求兴趣，选专业就应该选好就业的，无论兴趣如何。因为生活在一个穷困的家庭，没有钱是万万不能的。你需要的是尽早的就业来当起这个家。可笑的是，我现在才明白，难道我选择专业的时候选择了兴趣，选择就业的时候选择兴趣，真的错了吗？</p>\n<p>​    九月五号，我和儒哥踏上了前往武汉的动车，两个小时的动车路程加一个小时的地铁路程加十几分钟的滴滴路程，我们来的早已预约好的租房“武汉市洪山区竹苑小区四栋一单元302号房”，涉世不深的我第一次被社会割肉，房租交了1100软妹币，押金交了1300软妹币，大出血啊！从家里带的5000软妹币瞬间去掉一半，更可恶的是，第一个星期进去仅仅五天，水电费就花掉50，一个月下来水电费足足花了200。</p>\n<p><img src=\"/2019/10/12/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E6%AD%A6%E6%B1%89%E8%B7%91%E7%A7%8B%E6%8B%9B%E7%9A%84%E6%97%A5%E5%AD%90/QQ%E5%9B%BE%E7%89%8720191012190616.jpg\"></p>\n<p>​    入住第二天，上午我们来到了武大，只能说名校果然是名校，那环境，那楼宇，那面积，那宿舍都不是普通本科能比的，这天正好碰到武大有一场音乐艺术展，于是就去，里面一排排的钢琴，尽管看不懂，但是依旧觉得牛逼。纵穿武大，便来到了东湖，不得不说武汉的风景确实没得说。下午我们来到了华科，华科也不是一般的大，而且规划工整，那路是横七竖八，笔直笔直的，那绿植覆盖面积，走在校园里几乎不用晒太阳。我们也是骑着一个哈罗单车足足逛了一下午。到了晚上便开始了我们来到武行的第一场宣讲会–oppo华科宣讲会。</p>\n<p><img src=\"/2019/10/12/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E6%AD%A6%E6%B1%89%E8%B7%91%E7%A7%8B%E6%8B%9B%E7%9A%84%E6%97%A5%E5%AD%90/Snipaste_2019-09-08_09-15-55.png\"></p>\n<p><img src=\"/2019/10/12/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E6%AD%A6%E6%B1%89%E8%B7%91%E7%A7%8B%E6%8B%9B%E7%9A%84%E6%97%A5%E5%AD%90/Snipaste_2019-09-08_09-23-19.png\"></p>\n<p><img src=\"/2019/10/12/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E6%AD%A6%E6%B1%89%E8%B7%91%E7%A7%8B%E6%8B%9B%E7%9A%84%E6%97%A5%E5%AD%90/QQ%E5%9B%BE%E7%89%8720191012190552.jpg\"></p>\n<p><img src=\"/2019/10/12/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E6%AD%A6%E6%B1%89%E8%B7%91%E7%A7%8B%E6%8B%9B%E7%9A%84%E6%97%A5%E5%AD%90/QQ%E5%9B%BE%E7%89%8720191012190600.jpg\"></p>\n<p><img src=\"/2019/10/12/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E6%AD%A6%E6%B1%89%E8%B7%91%E7%A7%8B%E6%8B%9B%E7%9A%84%E6%97%A5%E5%AD%90/QQ%E5%9B%BE%E7%89%8720191012190518.jpg\"></p>\n<p><img src=\"/2019/10/12/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E6%AD%A6%E6%B1%89%E8%B7%91%E7%A7%8B%E6%8B%9B%E7%9A%84%E6%97%A5%E5%AD%90/Snipaste_2019-09-08_09-28-22.png\"></p>\n<p><img src=\"/2019/10/12/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E6%AD%A6%E6%B1%89%E8%B7%91%E7%A7%8B%E6%8B%9B%E7%9A%84%E6%97%A5%E5%AD%90/Snipaste_2019-09-08_09-34-22.png\"></p>\n<p>​    只有当自己切真切实的接触到了这些名校，切真切实的接触到了名校中的那些人，才会明白在大学四年里所说的那些名校差距原来如此之大。可能是高中三年太辛苦，亦或是预科一年太放纵，大学三年啊，我终究是没有学会多少东西。可这又怎能让我信服呢？我真的没有学到什么东西吗？大一，因为读了一年预科，我不再是出来扎到，于是乎我做了班级负责人，然后觉得太累，于是正式选举班委时选择了副班长，学生组织，我选择了院新媒体。一年来，我参加比赛，制作视频，最后也是拿了个校三等奖学金。大二，我成了新媒体摄像部的部长，我把精力都用来管理部门，教导干事，于是乎我们部门成了优秀部门。同年借着新媒体和宋哥，我们成立的木瓜传媒工作室，对外接单，曾三次远赴神农架，总盈利13000软妹币，同样也顺利拿下了那年的三等奖学金。大三,我和儒哥一起在必胜客兼职了半年，同时我做到了经济独立11一个月，差一个月的经济独立一年。同时在富云达学习了半年，也开始为找工作而忧心，大三呆在学校的时间确实少了很多，尽管没拿到奖学金，但是成绩确实是提升了很多。如此充实的大学生活，我真的什么也没学到吗？</p>\n<p><img src=\"/2019/10/12/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E6%AD%A6%E6%B1%89%E8%B7%91%E7%A7%8B%E6%8B%9B%E7%9A%84%E6%97%A5%E5%AD%90/QQ%E5%9B%BE%E7%89%8720191012190504.jpg\"></p>\n<p>​    事实证明，我真的很差劲，九月份，我和儒哥都开始了自己的秋招之旅，一整个九月，我跑了好几家游戏公司，成都摩丰，长沙的沃尔信息，武汉的微派网络，众娱，广州的速游网络，北京的多乐游戏，结果是一家没进。反观儒哥，他搞Web，结果一面就进了快客云，实习工资3700。顿时我被打击到哭泣，对没错因为恰逢中秋，我哭了，在和妈打的电话中哭得很彻底。这一次我想家了，想家想到了骨子里，这还是自从我小学六年级第一次离开父母留校寄宿以来最想家的一次，即使当年预科父亲送我来到宜昌离开我回家那次都没有这一次那么想家。想家也许是每一个在外漂泊的游子必定要经历的吧。</p>\n<p>​    第二天我买上了回家的车票，早上九点到晚上十一点，我到家了，我终于暂时卸下了三个多月来的忧心忡忡。母亲知道我要回来就上山区采了皇竹笋，做了一顿竹笋酿，那是我这么久以来吃的最无忧无虑的一顿，心里没有忧愁，嘴里尽是美味，对面坐者母亲，顶上是家，可能这才是我想要的生活吧。每天能有一些时间在家陪陪父母，也不失是一种幸福。父母操劳了半辈子，送我和弟弟读书，弟弟不争气跑去复读了，我作为长子找工作的事本不应该让父母操心，因为父母操心也不打劲，只能为我干着急。于是我开始反思，走游戏开发这条路我真的走对了吗？我是不是应该换条路走呢？比如C++。</p>\n<p><img src=\"/2019/10/12/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E6%AD%A6%E6%B1%89%E8%B7%91%E7%A7%8B%E6%8B%9B%E7%9A%84%E6%97%A5%E5%AD%90/QQ%E5%9B%BE%E7%89%8720191012190448.jpg\"></p>\n<p><img src=\"/2019/10/12/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E6%AD%A6%E6%B1%89%E8%B7%91%E7%A7%8B%E6%8B%9B%E7%9A%84%E6%97%A5%E5%AD%90/QQ%E5%9B%BE%E7%89%8720191012190414.jpg\"></p>\n<p><img src=\"/2019/10/12/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E6%AD%A6%E6%B1%89%E8%B7%91%E7%A7%8B%E6%8B%9B%E7%9A%84%E6%97%A5%E5%AD%90/QQ%E5%9B%BE%E7%89%8720191012190444.jpg\"></p>\n<p>​    在家里的几天是我整个大三以来过的最舒心的几天，可是时间转瞬即逝，我又踏上了秋招之旅。九月25日，依旧没找到工作的我决定返校回去深造C++，然后国庆之后转行寻找C++的岗位。回到学校才发现学生时代的生活真的很美好，相比社会的残酷，校园原来真的是一个乐园，只是十几年的学生生活让我忽略了这一点。只剩最后一年的大学生活了，现在明白过来也为时不晚，且行还须且珍惜。</p>\n<p>​    国庆过了，房租也到期了，我开始了寄居生活，儒哥找到了工作于是就在公司附近租了个房子，我便开始寄居在儒哥的房子里，十月七号，我拿到了第一个offer，蛛网传媒，这是一家半个游戏公司的公司，因为他们做游戏却不是做自己的游戏，并且他们不仅仅做游戏，还做其他的软件，类似一家外包公司。实习工资3000软妹币加餐补300。也许是我自己把待遇开低了，唉~也罢，谁让我九月份受够了打击呢？于此同时九月份投的很多家公司也都邮来了面试通知，我去了，却都凉凉了，在和我们班那些去华清远见培训的同学聊面试题的时候，我才知道自己的C++是有多菜，我真的没有什么可值得骄傲的，可笑的是，八月的时候我居然笑着说“找工作不难，难的是找一个好工作”，我啊，似乎是出来些什么问题了。</p>\n<p><img src=\"/2019/10/12/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E6%AD%A6%E6%B1%89%E8%B7%91%E7%A7%8B%E6%8B%9B%E7%9A%84%E6%97%A5%E5%AD%90/QQ%E5%9B%BE%E7%89%8720191012190638.jpg\"></p>\n<p>​    今天是十月十二号，我已经和房东商量好了，明天搬过去，住在武汉市银河湾，离公司蛮近的。后天就要去上班了，我的进修之旅还远没结束。</p>\n<p>​    经历了这么多，那些平时不爱学习，成绩不好的同学反而找到了一个不错的工作，我这个自以为比他们优秀的学生却秋招那么惨，最终去了一家连自己都不觉得有多好的小公司，尽管我已经很努力的准备了三个月，很努力的学了三个月，可最终的结果却是那么的不尽人意，我很失落，我有问题，我的身上肯定出了什么问题，以至于我得到了一个如此不满意的结果。</p>\n<p><img src=\"/2019/10/12/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E6%AD%A6%E6%B1%89%E8%B7%91%E7%A7%8B%E6%8B%9B%E7%9A%84%E6%97%A5%E5%AD%90/QQ%E5%9B%BE%E7%89%8720191012190641.jpg\"></p>\n<p>​    也许生活就是这样雕琢一个孩子的吧，这次秋招我才意识到，自己眼中的优秀就是个屁，也许我该拾起初高中的那股劲了，大学的自己似乎过于放纵了，以至于成就了一个失败的自己。我的身上出问题了，我要找出来，我不比他们差，我不应该如此生活，我需要变强的，变得很强很强。现在得我真的没有资格说累，“累”，那是给别人说的。</p>\n","encrypt":true,"template":"<link rel=\"stylesheet\" href=\"//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css\"> <link rel=\"stylesheet\" href=\"//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css\"> <script src=\"//cdn.bootcss.com/jquery/1.11.3/jquery.min.js\"></script> <script src=\"//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js\"></script> <div id=\"security\"> <div> <div class=\"input-group\"> <input type=\"text\" class=\"form-control\" aria-label=\"Enter the password.\" id=\"pass\"/> <div class=\"input-group-btn\"> <button type=\"button\" class=\"btn btn-default\" onclick=\"decryptAES()\">Decrypt</button> </div> </div> </div> </div> <div id=\"encrypt-blog\" style=\"display:none\"> {{content}} </div>"},{"title":"程序编程高级","date":"2019-08-25T11:23:48.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n![](【程序编程】程序编程高级/程序编程高级.png)","source":"_posts/【程序编程】程序编程高级.md","raw":"---\ntitle: 程序编程高级\ndate: 2019-08-25 19:23:48\ntags: 程序编程原理\ncategories: 学习笔记\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n![](【程序编程】程序编程高级/程序编程高级.png)","slug":"【程序编程】程序编程高级","published":1,"updated":"2021-02-01T13:34:59.914Z","_id":"ckk9hocb30024dwr7gbbne02d","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p><img src=\"/2019/08/25/%E3%80%90%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E3%80%91%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p><img src=\"/2019/08/25/%E3%80%90%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E3%80%91%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7.png\"></p>\n"},{"title":"【算法】一些牛逼轰轰的算法记录","date":"2019-10-08T14:07:36.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 1.判断点是否在三角形内\n\n## 衍生：快速计算三角形面积\n\n```C++\n#include <iostream>\n#include <string>\n#include <math.h>\n#define S_FLOAT 0.00000001\n\nusing namespace std;\n//点类型\ntypedef struct Point\n{\n\tfloat x;\n\tfloat y;\n\tPoint() {}\n\tPoint(float x,float y)\n\t{\n\t\tthis->x = x;\n\t\tthis->y = y;\n\t}\n};\n//计算三角形面积\nfloat GetTriangleSquar(const Point a, const Point b, const Point c)\n{\n\tPoint AB, BC;\n\tAB.x = b.x - a.x;\n\tAB.y = b.y - a.y;\n\tBC.x = c.x - b.x;\n\tBC.y = c.y - b.y;\n\treturn fabs(AB.x*BC.y - AB.y*BC.x) / 2;\n}\n//判断点是否在三角形内\nstring IsInTriang(Point a, Point b, Point c, Point d)\n{\n\tfloat Sabc, Sabd, Sacd, Sbcd;\n\tSabc = GetTriangleSquar(a, b, c);\n\tSabd = GetTriangleSquar(a, b, d);\n\tSacd = GetTriangleSquar(a, c, d);\n\tSbcd = GetTriangleSquar(b, c, d);\n\tfloat Sums = Sabd + Sacd + Sbcd;\n\tcout << \"Sabd:\" << Sabd << endl << \"Sacd:\" << Sacd << endl << \"Sbcd:\" << Sbcd << endl;\n\tcout<< \"Sabc:\"<<Sabc<<endl<<\"Sums:\"<<Sums << endl;\n\tif ((-S_FLOAT < (Sabc - Sums) && (Sabc - Sums) < S_FLOAT))\n\t\treturn \"Yes\";\n\telse return \"No\";\n}\n//测试函数\nvoid Test()\n{\n\tPoint a(2, 2), b(0, 0), c(4, 0), d(2, 1);\n\tcout << IsInTriang(a, b, c, d) << endl;\n}\nint main()\n{\n\tTest();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n# 2.PNPoly算法-判断点是否在多边形内\n\n```c++\nbool PointInPolygon(Point point, Polygon polygon) {\n  vector<Point> points = polygon.getPoints();\n  int i, j, nvert = points.size();\n  bool c = false;\n\n  for(i = 0, j = nvert - 1; i < nvert; j = i++) {\n    if( ( (points[i].y >= point.y ) != (points[j].y >= point.y) ) &&\n        (point.x <= (points[j].x - points[i].x) * (point.y - points[i].y) / (points[j].y - points[i].y) + points[i].x)\n      )\n      c = !c;\n  }\n\n  return c;\n}\n```\n\n","source":"_posts/【算法】一些牛逼轰轰的算法记录.md","raw":"---\ntitle: 【算法】一些牛逼轰轰的算法记录\ndate: 2019-10-08 22:07:36\ntags: 算法\ncategories: 知识记录\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 1.判断点是否在三角形内\n\n## 衍生：快速计算三角形面积\n\n```C++\n#include <iostream>\n#include <string>\n#include <math.h>\n#define S_FLOAT 0.00000001\n\nusing namespace std;\n//点类型\ntypedef struct Point\n{\n\tfloat x;\n\tfloat y;\n\tPoint() {}\n\tPoint(float x,float y)\n\t{\n\t\tthis->x = x;\n\t\tthis->y = y;\n\t}\n};\n//计算三角形面积\nfloat GetTriangleSquar(const Point a, const Point b, const Point c)\n{\n\tPoint AB, BC;\n\tAB.x = b.x - a.x;\n\tAB.y = b.y - a.y;\n\tBC.x = c.x - b.x;\n\tBC.y = c.y - b.y;\n\treturn fabs(AB.x*BC.y - AB.y*BC.x) / 2;\n}\n//判断点是否在三角形内\nstring IsInTriang(Point a, Point b, Point c, Point d)\n{\n\tfloat Sabc, Sabd, Sacd, Sbcd;\n\tSabc = GetTriangleSquar(a, b, c);\n\tSabd = GetTriangleSquar(a, b, d);\n\tSacd = GetTriangleSquar(a, c, d);\n\tSbcd = GetTriangleSquar(b, c, d);\n\tfloat Sums = Sabd + Sacd + Sbcd;\n\tcout << \"Sabd:\" << Sabd << endl << \"Sacd:\" << Sacd << endl << \"Sbcd:\" << Sbcd << endl;\n\tcout<< \"Sabc:\"<<Sabc<<endl<<\"Sums:\"<<Sums << endl;\n\tif ((-S_FLOAT < (Sabc - Sums) && (Sabc - Sums) < S_FLOAT))\n\t\treturn \"Yes\";\n\telse return \"No\";\n}\n//测试函数\nvoid Test()\n{\n\tPoint a(2, 2), b(0, 0), c(4, 0), d(2, 1);\n\tcout << IsInTriang(a, b, c, d) << endl;\n}\nint main()\n{\n\tTest();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n# 2.PNPoly算法-判断点是否在多边形内\n\n```c++\nbool PointInPolygon(Point point, Polygon polygon) {\n  vector<Point> points = polygon.getPoints();\n  int i, j, nvert = points.size();\n  bool c = false;\n\n  for(i = 0, j = nvert - 1; i < nvert; j = i++) {\n    if( ( (points[i].y >= point.y ) != (points[j].y >= point.y) ) &&\n        (point.x <= (points[j].x - points[i].x) * (point.y - points[i].y) / (points[j].y - points[i].y) + points[i].x)\n      )\n      c = !c;\n  }\n\n  return c;\n}\n```\n\n","slug":"【算法】一些牛逼轰轰的算法记录","published":1,"updated":"2021-03-26T03:42:12.593Z","_id":"ckk9hocbe0038dwr7g7g7hmyk","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h1 id=\"1-判断点是否在三角形内\"><a href=\"#1-判断点是否在三角形内\" class=\"headerlink\" title=\"1.判断点是否在三角形内\"></a>1.判断点是否在三角形内</h1><h2 id=\"衍生：快速计算三角形面积\"><a href=\"#衍生：快速计算三角形面积\" class=\"headerlink\" title=\"衍生：快速计算三角形面积\"></a>衍生：快速计算三角形面积</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;string&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;math.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> S_FLOAT 0.00000001</span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;<br><span class=\"hljs-comment\">//点类型</span><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Point</span></span><br><span class=\"hljs-class\">&#123;</span><br>\t<span class=\"hljs-keyword\">float</span> x;<br>\t<span class=\"hljs-keyword\">float</span> y;<br>\tPoint() &#123;&#125;<br>\tPoint(<span class=\"hljs-keyword\">float</span> x,<span class=\"hljs-keyword\">float</span> y)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;x = x;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;y = y;<br>\t&#125;<br>&#125;;<br><span class=\"hljs-comment\">//计算三角形面积</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">float</span> <span class=\"hljs-title\">GetTriangleSquar</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> Point a, <span class=\"hljs-keyword\">const</span> Point b, <span class=\"hljs-keyword\">const</span> Point c)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tPoint AB, BC;<br>\tAB.x = b.x - a.x;<br>\tAB.y = b.y - a.y;<br>\tBC.x = c.x - b.x;<br>\tBC.y = c.y - b.y;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">fabs</span>(AB.x*BC.y - AB.y*BC.x) / <span class=\"hljs-number\">2</span>;<br>&#125;<br><span class=\"hljs-comment\">//判断点是否在三角形内</span><br><span class=\"hljs-function\"><span class=\"hljs-built_in\">string</span> <span class=\"hljs-title\">IsInTriang</span><span class=\"hljs-params\">(Point a, Point b, Point c, Point d)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">float</span> Sabc, Sabd, Sacd, Sbcd;<br>\tSabc = GetTriangleSquar(a, b, c);<br>\tSabd = GetTriangleSquar(a, b, d);<br>\tSacd = GetTriangleSquar(a, c, d);<br>\tSbcd = GetTriangleSquar(b, c, d);<br>\t<span class=\"hljs-keyword\">float</span> Sums = Sabd + Sacd + Sbcd;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;Sabd:&quot;</span> &lt;&lt; Sabd &lt;&lt; <span class=\"hljs-built_in\">endl</span> &lt;&lt; <span class=\"hljs-string\">&quot;Sacd:&quot;</span> &lt;&lt; Sacd &lt;&lt; <span class=\"hljs-built_in\">endl</span> &lt;&lt; <span class=\"hljs-string\">&quot;Sbcd:&quot;</span> &lt;&lt; Sbcd &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t<span class=\"hljs-built_in\">cout</span>&lt;&lt; <span class=\"hljs-string\">&quot;Sabc:&quot;</span>&lt;&lt;Sabc&lt;&lt;<span class=\"hljs-built_in\">endl</span>&lt;&lt;<span class=\"hljs-string\">&quot;Sums:&quot;</span>&lt;&lt;Sums &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t<span class=\"hljs-keyword\">if</span> ((-S_FLOAT &lt; (Sabc - Sums) &amp;&amp; (Sabc - Sums) &lt; S_FLOAT))<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Yes&quot;</span>;<br>\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;No&quot;</span>;<br>&#125;<br><span class=\"hljs-comment\">//测试函数</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Test</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tPoint a(2, 2), b(0, 0), c(4, 0), d(2, 1);<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; IsInTriang(a, b, c, d) &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tTest();<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"2-PNPoly算法-判断点是否在多边形内\"><a href=\"#2-PNPoly算法-判断点是否在多边形内\" class=\"headerlink\" title=\"2.PNPoly算法-判断点是否在多边形内\"></a>2.PNPoly算法-判断点是否在多边形内</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">PointInPolygon</span><span class=\"hljs-params\">(Point point, Polygon polygon)</span> </span>&#123;<br>  <span class=\"hljs-built_in\">vector</span>&lt;Point&gt; points = polygon.getPoints();<br>  <span class=\"hljs-keyword\">int</span> i, j, nvert = points.size();<br>  <span class=\"hljs-keyword\">bool</span> c = <span class=\"hljs-literal\">false</span>;<br><br>  <span class=\"hljs-keyword\">for</span>(i = <span class=\"hljs-number\">0</span>, j = nvert - <span class=\"hljs-number\">1</span>; i &lt; nvert; j = i++) &#123;<br>    <span class=\"hljs-keyword\">if</span>( ( (points[i].y &gt;= point.y ) != (points[j].y &gt;= point.y) ) &amp;&amp;<br>        (point.x &lt;= (points[j].x - points[i].x) * (point.y - points[i].y) / (points[j].y - points[i].y) + points[i].x)<br>      )<br>      c = !c;<br>  &#125;<br><br>  <span class=\"hljs-keyword\">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h1 id=\"1-判断点是否在三角形内\"><a href=\"#1-判断点是否在三角形内\" class=\"headerlink\" title=\"1.判断点是否在三角形内\"></a>1.判断点是否在三角形内</h1><h2 id=\"衍生：快速计算三角形面积\"><a href=\"#衍生：快速计算三角形面积\" class=\"headerlink\" title=\"衍生：快速计算三角形面积\"></a>衍生：快速计算三角形面积</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;string&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;math.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> S_FLOAT 0.00000001</span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;<br><span class=\"hljs-comment\">//点类型</span><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Point</span></span><br><span class=\"hljs-class\">&#123;</span><br>\t<span class=\"hljs-keyword\">float</span> x;<br>\t<span class=\"hljs-keyword\">float</span> y;<br>\tPoint() &#123;&#125;<br>\tPoint(<span class=\"hljs-keyword\">float</span> x,<span class=\"hljs-keyword\">float</span> y)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;x = x;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;y = y;<br>\t&#125;<br>&#125;;<br><span class=\"hljs-comment\">//计算三角形面积</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">float</span> <span class=\"hljs-title\">GetTriangleSquar</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> Point a, <span class=\"hljs-keyword\">const</span> Point b, <span class=\"hljs-keyword\">const</span> Point c)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tPoint AB, BC;<br>\tAB.x = b.x - a.x;<br>\tAB.y = b.y - a.y;<br>\tBC.x = c.x - b.x;<br>\tBC.y = c.y - b.y;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">fabs</span>(AB.x*BC.y - AB.y*BC.x) / <span class=\"hljs-number\">2</span>;<br>&#125;<br><span class=\"hljs-comment\">//判断点是否在三角形内</span><br><span class=\"hljs-function\"><span class=\"hljs-built_in\">string</span> <span class=\"hljs-title\">IsInTriang</span><span class=\"hljs-params\">(Point a, Point b, Point c, Point d)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">float</span> Sabc, Sabd, Sacd, Sbcd;<br>\tSabc = GetTriangleSquar(a, b, c);<br>\tSabd = GetTriangleSquar(a, b, d);<br>\tSacd = GetTriangleSquar(a, c, d);<br>\tSbcd = GetTriangleSquar(b, c, d);<br>\t<span class=\"hljs-keyword\">float</span> Sums = Sabd + Sacd + Sbcd;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;Sabd:&quot;</span> &lt;&lt; Sabd &lt;&lt; <span class=\"hljs-built_in\">endl</span> &lt;&lt; <span class=\"hljs-string\">&quot;Sacd:&quot;</span> &lt;&lt; Sacd &lt;&lt; <span class=\"hljs-built_in\">endl</span> &lt;&lt; <span class=\"hljs-string\">&quot;Sbcd:&quot;</span> &lt;&lt; Sbcd &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t<span class=\"hljs-built_in\">cout</span>&lt;&lt; <span class=\"hljs-string\">&quot;Sabc:&quot;</span>&lt;&lt;Sabc&lt;&lt;<span class=\"hljs-built_in\">endl</span>&lt;&lt;<span class=\"hljs-string\">&quot;Sums:&quot;</span>&lt;&lt;Sums &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t<span class=\"hljs-keyword\">if</span> ((-S_FLOAT &lt; (Sabc - Sums) &amp;&amp; (Sabc - Sums) &lt; S_FLOAT))<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Yes&quot;</span>;<br>\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;No&quot;</span>;<br>&#125;<br><span class=\"hljs-comment\">//测试函数</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Test</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tPoint a(2, 2), b(0, 0), c(4, 0), d(2, 1);<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; IsInTriang(a, b, c, d) &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tTest();<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"2-PNPoly算法-判断点是否在多边形内\"><a href=\"#2-PNPoly算法-判断点是否在多边形内\" class=\"headerlink\" title=\"2.PNPoly算法-判断点是否在多边形内\"></a>2.PNPoly算法-判断点是否在多边形内</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">PointInPolygon</span><span class=\"hljs-params\">(Point point, Polygon polygon)</span> </span>&#123;<br>  <span class=\"hljs-built_in\">vector</span>&lt;Point&gt; points = polygon.getPoints();<br>  <span class=\"hljs-keyword\">int</span> i, j, nvert = points.size();<br>  <span class=\"hljs-keyword\">bool</span> c = <span class=\"hljs-literal\">false</span>;<br><br>  <span class=\"hljs-keyword\">for</span>(i = <span class=\"hljs-number\">0</span>, j = nvert - <span class=\"hljs-number\">1</span>; i &lt; nvert; j = i++) &#123;<br>    <span class=\"hljs-keyword\">if</span>( ( (points[i].y &gt;= point.y ) != (points[j].y &gt;= point.y) ) &amp;&amp;<br>        (point.x &lt;= (points[j].x - points[i].x) * (point.y - points[i].y) / (points[j].y - points[i].y) + points[i].x)<br>      )<br>      c = !c;<br>  &#125;<br><br>  <span class=\"hljs-keyword\">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure>\n"},{"title":"【计算机图形学】多边形填充算法","date":"2019-08-23T13:55:31.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n首先对于如下的多边形：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190618080545123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n# 1.有效边表填充算法\n\n## **1.1.有效边表填充算法分为如下几个步骤**：\n\n​\t1.1.1.将多边形所有的边分别与扫描线1计算交点，得到交点集，与扫描线计算的边没有顺序要求。\n​\t1.1.2.将点集按标x的大小递增排序，得到有序点集。\n​\t1.1.3.将有序点集两两配对，得到对应的像素区间。\n​\t1.1.4.将像素区间内的像素填充颜色，至此第一条扫描线上处于多边形内的的像素填充完毕。\n​\t1.1.5.扫描线标号加1，重复以上步骤，直至到最后一条扫描线。\n​\t如：对于扫描线3（y=3）与多边形所有的边计算交点，得到与P3P4交于点（4.5，3），与P3P2交于点（2.4，3），与P5P6交于点（8.8，3），与P5P4交于点（7，3）。\n​\t圆整处理得到点集（5，3）、（2，3）、（9，3）、（7，3）。\n​\t递增排序得到有序点集（2，3）、（5，3）、（7，3）、（9，3）。\n​\t两两配对得到扫描线3上的填充像素区间[2，5]、[7，9]。\n​\t填充区间内的所有像素。\n​\t得到如图所示的填充效果：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190617115850448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n全部填充得到如下效果：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190617115915999.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n## **1.2.至此我们发现如下疑问：**\n\n​\t1.2.1.像素填充的多边形面积大于多边形实际面积。\n​\t可能上图不太明显，我们举一个明显一点的例子，如下正方形：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190617115935411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n我们填充后的效果为：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190617115949648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n​\t而正方形的实际面积是4，在显示器上一个像素为一面积，正方形应该占4个像素点，而实际却占了9个像素点，对于这种问题，有效边表填充算法采用“左闭右开”，“下闭上开”的原则进行像素点的填充，按照此原则，正方形的填充效果如下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190617120002618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n1.2.1.对于点集（1，3）、（1，8）它们分别为扫描线1与P3P2、P3P4、P5P4、P5P6的交点，而在实际计算中它们仍只是两个点，如果处理不当，计算机可能会两两配对得到区间（3，8）而填充到错误的像素区间。\n对于此问题，有效边表填充算法采用分类连接点进行处理。\n有效边表填充算法将多边形的各个连接点分为三类连接点：\n\n### **+普通连接点：**\n\n​\t连接点所在的两条边分别处于其所在的扫描线的上方和下方，如P2点。\n\n### **+局部最低点：**\n\n​\t连接点所在的两条边都处于其所在的扫描线的上方，如P3、P5点。\n\n### **+局部最高点：**\n\n​\t连接点所在的两条边都处于其所在的扫描线的下方，如：P4、P1、P6点。\n​\t在填充开始前，有效边填充算法先对多边形所有的连接点进行分类，判断其在点集中的数量。\n有效边填充算法采用如下原则对多边形的连接点进行处理：\n\n### **1.2.2.普通连接点的处理原则**\n\n​\t以P2为例，根据“下闭上开”原则，对于P3P2上的点P2不予填充，P2P1上的点P2需要填充，P2点只填充1次，顾在扫描线7的填充像素点集中P2点的个数记为1，即可以不处理。\n\n### **1.2.3.局部最低点的处理原则**\n\n​\t以P3为例，根据“下闭上开”原则，对于P3P2上的点P3需要填充，P3P4上的点P3也需要填充，P3填充2次，扫描线1的填充像素点集中，再添加一个P3点，使其中有两个P3点，在像素点集中将P3点的个数记为2，P5点进行同样的处理，这样当算法进行两两配对时，得到的像素区间为[3，3]、[5，5]，如此即可避免出现[3，8]的点集区间，解决此类情况的填充错误。\n\n## **1.2.4.局部最高点的处理原则**\n\n​\t以P1点为例，根据“下闭上开”原则，对于P2P1上的P1点不予填充，P0P1上的P1点也不予填充，P1填充0次，扫描线12的像素填充点集中P1点的个数记为0，即从点集中删除P1点，这样的处理符合多边形整体的“下闭上开”原则。\n至此，多边形的有效边表填充算法的填充原理已经完成。\n但是，我们在填充多边形之前还需要进行一项很重要的工作—---根据多边形计算其有效边表，首先我们要了解什么是有效边。\n**有效边**：多边形与当前扫描线相交的边称为有效边，有效边的引入可以有效的避免扫描边与多边形的所有的边进行交点计算，提高算法的效率。\n**有效边表**：有效边按与扫描线交点x坐标递增顺序存放的链表。\n**有效边表节点结构**：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190618080124847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n示例：扫描线1的有效边表如下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190618081306344.png)\n**桶表**：有效边表按扫描线自增顺序存放的表，可以是链表，也可以是顺序表。\n**桶表的结构**：\n​\t如：多边形P0-P6的桶表为：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190618082918644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n​\t有效边表可以有效的减少计算量，提升多边形的填充效率，如所有的扫描线中，计算机只需要计算扫描线1、扫描线7和扫描线8，且扫描线1只需和边P2P3、P3P4、P4P5、P5P6计算交点，而无需与所有边计算交点，有效边填充算法是目前最有效的多边形填充算法之一。\n至此，多边形的有效边填充算法全部完成。\n\n# 2.边缘填充算法\n\n## **2.1.算法原理：**\n\n​\t先计算多边形每条边与扫描线的交点，然后将交点右侧的所有像素颜色全部取补色。\n\n## **2.2.补色的定义：**\n\n​\t对于黑白图像，白色的补色为黑色，黑色补色为白色，对于彩色图像，前景色取补就是将前景色置为背景色，背景色取补就是将背景声置为前景色。\n示例：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190618092226427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n​\t边缘填充算法的填充效率受到右侧填充像素的数量影响，当多边形靠近屏幕左侧时，计算机将填充大量无用像素，大大降低的算法的性能，浪费了系统资源。\n于是有人提出这样的改进：首先在进行多边形填充之前，先扫描一遍多边形，得出多边形的包围盒，并在适当的位置加入一条栅栏。\n包围盒：包围多边形的最小矩形。\n\n## **2.3.加入包围盒和栅栏的边缘填充算法原理：**\n\n​\t每次填充前先判断当前边在栅栏的左侧还是右侧，若在左侧，则取补边以右，栅栏以左的像素；若在右侧，则取补边以右，栅栏以左的像素。\n示例：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190621084324207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n​\t可以看出，加入包围盒和栅栏的边缘填充算法极大的减少了需要填充像素的数量，对填充效率的提升是显著的。\n​\t观察边缘填充算法的两幅图，我们是可以察觉到的，边缘填充算法，对多边形的顶点与边的填充不甚理想，边缘填充算法没有给定具体填充时，直线上的点是否包含在填充范围内，笔者试过两种情况的对比------填充时包含直线上的点和填充时不包含直线上的点，得出的结果，多边形的顶点与边的填充都不理想，但是，填充时包含直线上的点的填充方法的最总结果，使多边形在整体上满足“左闭右开”，“下闭上开”原则，顾才用此方法作图。然而，边缘填充算法的填充原理是没有考虑边界的，即多边形的所有像素都填充为一个颜色，无论多边形内部还是多边形的边和顶点，在实际填充效果中，多边形所有像素都填充为一个颜色的填充方式，顶点和边对整体的效果不大，即可以忽略，所以边缘填充算法依旧是效率极高的填充算法之一。\n\n# 3.种子填充算法\n\n3.1.种子填充算法是区域填充算法中的一种，种子填充算法分为：四邻接点种子填充算法和八邻接点种子填充算法。\n在此之前，我们需要了解一些概念：\n\n### **3.1.1.四邻接点：**\n\n​\t任易一个种子像素，其左右上下这四个像素成为这个种子像素的四邻接点。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190621092132813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n### **3.1.2.八邻接点：**\n\n​\t任易一个种子像素，其左右上下及左上、右下、右上、左上这八个像素成为这个种子像素的八邻接点。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190621092334685.png)\n\n### **3.1.3.四连通域：**\n\n​\t多边形中能被四邻接点遍历填充的区域。\n\n### **3.1.4.八连通域：**\n\n​\t多边形中能被八邻接点遍历填充的区域。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190621094757411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n### **3.1.5.四连通边界：**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190621094925910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n### **3.1.6.八连通边界：**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190621095031628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n## **3.2.适用场景：**\n\n​\t区域填充算法适用于多边形的边界与内部使用不同的填充色的场景。\n\n## **3.3.多边形边界的颜色：**\n\n​\t边界的颜色由绘制多边形时的画笔确定。\n\n## **3.4.多边形内部的颜色填充步骤**\n\n​\t3.4.1.在多边形内部任易选择一个像素作为种子像素。\n​\t3.4.2.将种子像素入栈。\n​\t3.4.3.如果栈不为空，则将栈顶元素出栈。\n​\t3.4.4.按填充色绘制出栈像素。\n​\t3.4.5.按四邻接点（左、上、右、下）（或八邻接点（左、左上、上、右上、右、右下、下、左下））顺序搜索与出栈像素相邻的4（或8）个像素，若该像素的颜色不是填充色并且也不是边界色，则把该像素入栈，否则丢弃该像素。\n​\t不难想象，当多边形的面积极大时，入栈的像素像素将是巨量，有的像素可能即是一个像素的邻接点又是另一个像素的邻接点，以致部分像素入栈多次，此情况下填充过程将大量占用栈存储空间，甚至过量占用空间，致使栈空间不足，导致其他程序无空间可用，如此既不能完成填充，又会造成空间溢出，甚至系统崩溃，所以种子填充算法的缺点极为严重。\n\n## **3.5.改进------扫描种子填充算法**\n\n​\t3.5.1.在多边形内部选择一个像素作为种子像素。\n​\t3.5.2.将种子像素入栈。\n​\t3.5.3.若栈不为空，则将栈顶元素出栈\n​\t3.5.4.沿出栈像素所在扫描线，对出栈像素左右像素依次填充，直至遇到边界像素为止。\n​\t3.5.5.记录该区间的范围，将最左端的像素记为Xl，将最右端的像素记为Xr。\n​\t3.5.6.检查与当前扫描线相邻的上下两条扫描线中在区间[Xl，Xr]里的有关像素是否全为边界像素或以填充像素，若存在非边界且未填充的像素，则把区间最右端像素取作种子像素入栈。\n​\t扫描种子填充像素每次只将区间最右端的像素入栈，极大的减少了入栈像素，不仅减少了栈空间的占用，还有效的提高了填充效率和填充速度。\n\n\n\n","source":"_posts/【计算机图形学】多变形填充算法原理.md","raw":"---\ntitle: 【计算机图形学】多边形填充算法\ndate: 2019-08-23 21:55:31\ntags: 图形学\ncategories: 学习笔记\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n首先对于如下的多边形：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190618080545123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n# 1.有效边表填充算法\n\n## **1.1.有效边表填充算法分为如下几个步骤**：\n\n​\t1.1.1.将多边形所有的边分别与扫描线1计算交点，得到交点集，与扫描线计算的边没有顺序要求。\n​\t1.1.2.将点集按标x的大小递增排序，得到有序点集。\n​\t1.1.3.将有序点集两两配对，得到对应的像素区间。\n​\t1.1.4.将像素区间内的像素填充颜色，至此第一条扫描线上处于多边形内的的像素填充完毕。\n​\t1.1.5.扫描线标号加1，重复以上步骤，直至到最后一条扫描线。\n​\t如：对于扫描线3（y=3）与多边形所有的边计算交点，得到与P3P4交于点（4.5，3），与P3P2交于点（2.4，3），与P5P6交于点（8.8，3），与P5P4交于点（7，3）。\n​\t圆整处理得到点集（5，3）、（2，3）、（9，3）、（7，3）。\n​\t递增排序得到有序点集（2，3）、（5，3）、（7，3）、（9，3）。\n​\t两两配对得到扫描线3上的填充像素区间[2，5]、[7，9]。\n​\t填充区间内的所有像素。\n​\t得到如图所示的填充效果：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190617115850448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n全部填充得到如下效果：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190617115915999.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n## **1.2.至此我们发现如下疑问：**\n\n​\t1.2.1.像素填充的多边形面积大于多边形实际面积。\n​\t可能上图不太明显，我们举一个明显一点的例子，如下正方形：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190617115935411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n我们填充后的效果为：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190617115949648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n​\t而正方形的实际面积是4，在显示器上一个像素为一面积，正方形应该占4个像素点，而实际却占了9个像素点，对于这种问题，有效边表填充算法采用“左闭右开”，“下闭上开”的原则进行像素点的填充，按照此原则，正方形的填充效果如下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190617120002618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n1.2.1.对于点集（1，3）、（1，8）它们分别为扫描线1与P3P2、P3P4、P5P4、P5P6的交点，而在实际计算中它们仍只是两个点，如果处理不当，计算机可能会两两配对得到区间（3，8）而填充到错误的像素区间。\n对于此问题，有效边表填充算法采用分类连接点进行处理。\n有效边表填充算法将多边形的各个连接点分为三类连接点：\n\n### **+普通连接点：**\n\n​\t连接点所在的两条边分别处于其所在的扫描线的上方和下方，如P2点。\n\n### **+局部最低点：**\n\n​\t连接点所在的两条边都处于其所在的扫描线的上方，如P3、P5点。\n\n### **+局部最高点：**\n\n​\t连接点所在的两条边都处于其所在的扫描线的下方，如：P4、P1、P6点。\n​\t在填充开始前，有效边填充算法先对多边形所有的连接点进行分类，判断其在点集中的数量。\n有效边填充算法采用如下原则对多边形的连接点进行处理：\n\n### **1.2.2.普通连接点的处理原则**\n\n​\t以P2为例，根据“下闭上开”原则，对于P3P2上的点P2不予填充，P2P1上的点P2需要填充，P2点只填充1次，顾在扫描线7的填充像素点集中P2点的个数记为1，即可以不处理。\n\n### **1.2.3.局部最低点的处理原则**\n\n​\t以P3为例，根据“下闭上开”原则，对于P3P2上的点P3需要填充，P3P4上的点P3也需要填充，P3填充2次，扫描线1的填充像素点集中，再添加一个P3点，使其中有两个P3点，在像素点集中将P3点的个数记为2，P5点进行同样的处理，这样当算法进行两两配对时，得到的像素区间为[3，3]、[5，5]，如此即可避免出现[3，8]的点集区间，解决此类情况的填充错误。\n\n## **1.2.4.局部最高点的处理原则**\n\n​\t以P1点为例，根据“下闭上开”原则，对于P2P1上的P1点不予填充，P0P1上的P1点也不予填充，P1填充0次，扫描线12的像素填充点集中P1点的个数记为0，即从点集中删除P1点，这样的处理符合多边形整体的“下闭上开”原则。\n至此，多边形的有效边表填充算法的填充原理已经完成。\n但是，我们在填充多边形之前还需要进行一项很重要的工作—---根据多边形计算其有效边表，首先我们要了解什么是有效边。\n**有效边**：多边形与当前扫描线相交的边称为有效边，有效边的引入可以有效的避免扫描边与多边形的所有的边进行交点计算，提高算法的效率。\n**有效边表**：有效边按与扫描线交点x坐标递增顺序存放的链表。\n**有效边表节点结构**：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190618080124847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n示例：扫描线1的有效边表如下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190618081306344.png)\n**桶表**：有效边表按扫描线自增顺序存放的表，可以是链表，也可以是顺序表。\n**桶表的结构**：\n​\t如：多边形P0-P6的桶表为：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190618082918644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n​\t有效边表可以有效的减少计算量，提升多边形的填充效率，如所有的扫描线中，计算机只需要计算扫描线1、扫描线7和扫描线8，且扫描线1只需和边P2P3、P3P4、P4P5、P5P6计算交点，而无需与所有边计算交点，有效边填充算法是目前最有效的多边形填充算法之一。\n至此，多边形的有效边填充算法全部完成。\n\n# 2.边缘填充算法\n\n## **2.1.算法原理：**\n\n​\t先计算多边形每条边与扫描线的交点，然后将交点右侧的所有像素颜色全部取补色。\n\n## **2.2.补色的定义：**\n\n​\t对于黑白图像，白色的补色为黑色，黑色补色为白色，对于彩色图像，前景色取补就是将前景色置为背景色，背景色取补就是将背景声置为前景色。\n示例：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190618092226427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n​\t边缘填充算法的填充效率受到右侧填充像素的数量影响，当多边形靠近屏幕左侧时，计算机将填充大量无用像素，大大降低的算法的性能，浪费了系统资源。\n于是有人提出这样的改进：首先在进行多边形填充之前，先扫描一遍多边形，得出多边形的包围盒，并在适当的位置加入一条栅栏。\n包围盒：包围多边形的最小矩形。\n\n## **2.3.加入包围盒和栅栏的边缘填充算法原理：**\n\n​\t每次填充前先判断当前边在栅栏的左侧还是右侧，若在左侧，则取补边以右，栅栏以左的像素；若在右侧，则取补边以右，栅栏以左的像素。\n示例：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190621084324207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n​\t可以看出，加入包围盒和栅栏的边缘填充算法极大的减少了需要填充像素的数量，对填充效率的提升是显著的。\n​\t观察边缘填充算法的两幅图，我们是可以察觉到的，边缘填充算法，对多边形的顶点与边的填充不甚理想，边缘填充算法没有给定具体填充时，直线上的点是否包含在填充范围内，笔者试过两种情况的对比------填充时包含直线上的点和填充时不包含直线上的点，得出的结果，多边形的顶点与边的填充都不理想，但是，填充时包含直线上的点的填充方法的最总结果，使多边形在整体上满足“左闭右开”，“下闭上开”原则，顾才用此方法作图。然而，边缘填充算法的填充原理是没有考虑边界的，即多边形的所有像素都填充为一个颜色，无论多边形内部还是多边形的边和顶点，在实际填充效果中，多边形所有像素都填充为一个颜色的填充方式，顶点和边对整体的效果不大，即可以忽略，所以边缘填充算法依旧是效率极高的填充算法之一。\n\n# 3.种子填充算法\n\n3.1.种子填充算法是区域填充算法中的一种，种子填充算法分为：四邻接点种子填充算法和八邻接点种子填充算法。\n在此之前，我们需要了解一些概念：\n\n### **3.1.1.四邻接点：**\n\n​\t任易一个种子像素，其左右上下这四个像素成为这个种子像素的四邻接点。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190621092132813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n### **3.1.2.八邻接点：**\n\n​\t任易一个种子像素，其左右上下及左上、右下、右上、左上这八个像素成为这个种子像素的八邻接点。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190621092334685.png)\n\n### **3.1.3.四连通域：**\n\n​\t多边形中能被四邻接点遍历填充的区域。\n\n### **3.1.4.八连通域：**\n\n​\t多边形中能被八邻接点遍历填充的区域。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190621094757411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n### **3.1.5.四连通边界：**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190621094925910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n### **3.1.6.八连通边界：**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190621095031628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n## **3.2.适用场景：**\n\n​\t区域填充算法适用于多边形的边界与内部使用不同的填充色的场景。\n\n## **3.3.多边形边界的颜色：**\n\n​\t边界的颜色由绘制多边形时的画笔确定。\n\n## **3.4.多边形内部的颜色填充步骤**\n\n​\t3.4.1.在多边形内部任易选择一个像素作为种子像素。\n​\t3.4.2.将种子像素入栈。\n​\t3.4.3.如果栈不为空，则将栈顶元素出栈。\n​\t3.4.4.按填充色绘制出栈像素。\n​\t3.4.5.按四邻接点（左、上、右、下）（或八邻接点（左、左上、上、右上、右、右下、下、左下））顺序搜索与出栈像素相邻的4（或8）个像素，若该像素的颜色不是填充色并且也不是边界色，则把该像素入栈，否则丢弃该像素。\n​\t不难想象，当多边形的面积极大时，入栈的像素像素将是巨量，有的像素可能即是一个像素的邻接点又是另一个像素的邻接点，以致部分像素入栈多次，此情况下填充过程将大量占用栈存储空间，甚至过量占用空间，致使栈空间不足，导致其他程序无空间可用，如此既不能完成填充，又会造成空间溢出，甚至系统崩溃，所以种子填充算法的缺点极为严重。\n\n## **3.5.改进------扫描种子填充算法**\n\n​\t3.5.1.在多边形内部选择一个像素作为种子像素。\n​\t3.5.2.将种子像素入栈。\n​\t3.5.3.若栈不为空，则将栈顶元素出栈\n​\t3.5.4.沿出栈像素所在扫描线，对出栈像素左右像素依次填充，直至遇到边界像素为止。\n​\t3.5.5.记录该区间的范围，将最左端的像素记为Xl，将最右端的像素记为Xr。\n​\t3.5.6.检查与当前扫描线相邻的上下两条扫描线中在区间[Xl，Xr]里的有关像素是否全为边界像素或以填充像素，若存在非边界且未填充的像素，则把区间最右端像素取作种子像素入栈。\n​\t扫描种子填充像素每次只将区间最右端的像素入栈，极大的减少了入栈像素，不仅减少了栈空间的占用，还有效的提高了填充效率和填充速度。\n\n\n\n","slug":"【计算机图形学】多变形填充算法原理","published":1,"updated":"2021-02-01T13:35:36.186Z","_id":"ckk9hocbh003cdwr70i2k320s","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p>首先对于如下的多边形：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190618080545123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"1-有效边表填充算法\"><a href=\"#1-有效边表填充算法\" class=\"headerlink\" title=\"1.有效边表填充算法\"></a>1.有效边表填充算法</h1><h2 id=\"1-1-有效边表填充算法分为如下几个步骤：\"><a href=\"#1-1-有效边表填充算法分为如下几个步骤：\" class=\"headerlink\" title=\"1.1.有效边表填充算法分为如下几个步骤：\"></a><strong>1.1.有效边表填充算法分为如下几个步骤</strong>：</h2><p>​    1.1.1.将多边形所有的边分别与扫描线1计算交点，得到交点集，与扫描线计算的边没有顺序要求。<br>​    1.1.2.将点集按标x的大小递增排序，得到有序点集。<br>​    1.1.3.将有序点集两两配对，得到对应的像素区间。<br>​    1.1.4.将像素区间内的像素填充颜色，至此第一条扫描线上处于多边形内的的像素填充完毕。<br>​    1.1.5.扫描线标号加1，重复以上步骤，直至到最后一条扫描线。<br>​    如：对于扫描线3（y=3）与多边形所有的边计算交点，得到与P3P4交于点（4.5，3），与P3P2交于点（2.4，3），与P5P6交于点（8.8，3），与P5P4交于点（7，3）。<br>​    圆整处理得到点集（5，3）、（2，3）、（9，3）、（7，3）。<br>​    递增排序得到有序点集（2，3）、（5，3）、（7，3）、（9，3）。<br>​    两两配对得到扫描线3上的填充像素区间[2，5]、[7，9]。<br>​    填充区间内的所有像素。<br>​    得到如图所示的填充效果：<br><img src=\"https://img-blog.csdnimg.cn/20190617115850448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>全部填充得到如下效果：<br><img src=\"https://img-blog.csdnimg.cn/20190617115915999.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"1-2-至此我们发现如下疑问：\"><a href=\"#1-2-至此我们发现如下疑问：\" class=\"headerlink\" title=\"1.2.至此我们发现如下疑问：\"></a><strong>1.2.至此我们发现如下疑问：</strong></h2><p>​    1.2.1.像素填充的多边形面积大于多边形实际面积。<br>​    可能上图不太明显，我们举一个明显一点的例子，如下正方形：<br><img src=\"https://img-blog.csdnimg.cn/20190617115935411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>我们填充后的效果为：<br><img src=\"https://img-blog.csdnimg.cn/20190617115949648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>​    而正方形的实际面积是4，在显示器上一个像素为一面积，正方形应该占4个像素点，而实际却占了9个像素点，对于这种问题，有效边表填充算法采用“左闭右开”，“下闭上开”的原则进行像素点的填充，按照此原则，正方形的填充效果如下：<br><img src=\"https://img-blog.csdnimg.cn/20190617120002618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>1.2.1.对于点集（1，3）、（1，8）它们分别为扫描线1与P3P2、P3P4、P5P4、P5P6的交点，而在实际计算中它们仍只是两个点，如果处理不当，计算机可能会两两配对得到区间（3，8）而填充到错误的像素区间。<br>对于此问题，有效边表填充算法采用分类连接点进行处理。<br>有效边表填充算法将多边形的各个连接点分为三类连接点：</p>\n<h3 id=\"普通连接点：\"><a href=\"#普通连接点：\" class=\"headerlink\" title=\"+普通连接点：\"></a><strong>+普通连接点：</strong></h3><p>​    连接点所在的两条边分别处于其所在的扫描线的上方和下方，如P2点。</p>\n<h3 id=\"局部最低点：\"><a href=\"#局部最低点：\" class=\"headerlink\" title=\"+局部最低点：\"></a><strong>+局部最低点：</strong></h3><p>​    连接点所在的两条边都处于其所在的扫描线的上方，如P3、P5点。</p>\n<h3 id=\"局部最高点：\"><a href=\"#局部最高点：\" class=\"headerlink\" title=\"+局部最高点：\"></a><strong>+局部最高点：</strong></h3><p>​    连接点所在的两条边都处于其所在的扫描线的下方，如：P4、P1、P6点。<br>​    在填充开始前，有效边填充算法先对多边形所有的连接点进行分类，判断其在点集中的数量。<br>有效边填充算法采用如下原则对多边形的连接点进行处理：</p>\n<h3 id=\"1-2-2-普通连接点的处理原则\"><a href=\"#1-2-2-普通连接点的处理原则\" class=\"headerlink\" title=\"1.2.2.普通连接点的处理原则\"></a><strong>1.2.2.普通连接点的处理原则</strong></h3><p>​    以P2为例，根据“下闭上开”原则，对于P3P2上的点P2不予填充，P2P1上的点P2需要填充，P2点只填充1次，顾在扫描线7的填充像素点集中P2点的个数记为1，即可以不处理。</p>\n<h3 id=\"1-2-3-局部最低点的处理原则\"><a href=\"#1-2-3-局部最低点的处理原则\" class=\"headerlink\" title=\"1.2.3.局部最低点的处理原则\"></a><strong>1.2.3.局部最低点的处理原则</strong></h3><p>​    以P3为例，根据“下闭上开”原则，对于P3P2上的点P3需要填充，P3P4上的点P3也需要填充，P3填充2次，扫描线1的填充像素点集中，再添加一个P3点，使其中有两个P3点，在像素点集中将P3点的个数记为2，P5点进行同样的处理，这样当算法进行两两配对时，得到的像素区间为[3，3]、[5，5]，如此即可避免出现[3，8]的点集区间，解决此类情况的填充错误。</p>\n<h2 id=\"1-2-4-局部最高点的处理原则\"><a href=\"#1-2-4-局部最高点的处理原则\" class=\"headerlink\" title=\"1.2.4.局部最高点的处理原则\"></a><strong>1.2.4.局部最高点的处理原则</strong></h2><p>​    以P1点为例，根据“下闭上开”原则，对于P2P1上的P1点不予填充，P0P1上的P1点也不予填充，P1填充0次，扫描线12的像素填充点集中P1点的个数记为0，即从点集中删除P1点，这样的处理符合多边形整体的“下闭上开”原则。<br>至此，多边形的有效边表填充算法的填充原理已经完成。<br>但是，我们在填充多边形之前还需要进行一项很重要的工作——根据多边形计算其有效边表，首先我们要了解什么是有效边。<br><strong>有效边</strong>：多边形与当前扫描线相交的边称为有效边，有效边的引入可以有效的避免扫描边与多边形的所有的边进行交点计算，提高算法的效率。<br><strong>有效边表</strong>：有效边按与扫描线交点x坐标递增顺序存放的链表。<br><strong>有效边表节点结构</strong>：<br><img src=\"https://img-blog.csdnimg.cn/20190618080124847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>示例：扫描线1的有效边表如下：<br><img src=\"https://img-blog.csdnimg.cn/20190618081306344.png\" alt=\"在这里插入图片描述\"><br><strong>桶表</strong>：有效边表按扫描线自增顺序存放的表，可以是链表，也可以是顺序表。<br><strong>桶表的结构</strong>：<br>​    如：多边形P0-P6的桶表为：<br><img src=\"https://img-blog.csdnimg.cn/20190618082918644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>​    有效边表可以有效的减少计算量，提升多边形的填充效率，如所有的扫描线中，计算机只需要计算扫描线1、扫描线7和扫描线8，且扫描线1只需和边P2P3、P3P4、P4P5、P5P6计算交点，而无需与所有边计算交点，有效边填充算法是目前最有效的多边形填充算法之一。<br>至此，多边形的有效边填充算法全部完成。</p>\n<h1 id=\"2-边缘填充算法\"><a href=\"#2-边缘填充算法\" class=\"headerlink\" title=\"2.边缘填充算法\"></a>2.边缘填充算法</h1><h2 id=\"2-1-算法原理：\"><a href=\"#2-1-算法原理：\" class=\"headerlink\" title=\"2.1.算法原理：\"></a><strong>2.1.算法原理：</strong></h2><p>​    先计算多边形每条边与扫描线的交点，然后将交点右侧的所有像素颜色全部取补色。</p>\n<h2 id=\"2-2-补色的定义：\"><a href=\"#2-2-补色的定义：\" class=\"headerlink\" title=\"2.2.补色的定义：\"></a><strong>2.2.补色的定义：</strong></h2><p>​    对于黑白图像，白色的补色为黑色，黑色补色为白色，对于彩色图像，前景色取补就是将前景色置为背景色，背景色取补就是将背景声置为前景色。<br>示例：<br><img src=\"https://img-blog.csdnimg.cn/20190618092226427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>​    边缘填充算法的填充效率受到右侧填充像素的数量影响，当多边形靠近屏幕左侧时，计算机将填充大量无用像素，大大降低的算法的性能，浪费了系统资源。<br>于是有人提出这样的改进：首先在进行多边形填充之前，先扫描一遍多边形，得出多边形的包围盒，并在适当的位置加入一条栅栏。<br>包围盒：包围多边形的最小矩形。</p>\n<h2 id=\"2-3-加入包围盒和栅栏的边缘填充算法原理：\"><a href=\"#2-3-加入包围盒和栅栏的边缘填充算法原理：\" class=\"headerlink\" title=\"2.3.加入包围盒和栅栏的边缘填充算法原理：\"></a><strong>2.3.加入包围盒和栅栏的边缘填充算法原理：</strong></h2><p>​    每次填充前先判断当前边在栅栏的左侧还是右侧，若在左侧，则取补边以右，栅栏以左的像素；若在右侧，则取补边以右，栅栏以左的像素。<br>示例：<br><img src=\"https://img-blog.csdnimg.cn/20190621084324207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>​    可以看出，加入包围盒和栅栏的边缘填充算法极大的减少了需要填充像素的数量，对填充效率的提升是显著的。<br>​    观察边缘填充算法的两幅图，我们是可以察觉到的，边缘填充算法，对多边形的顶点与边的填充不甚理想，边缘填充算法没有给定具体填充时，直线上的点是否包含在填充范围内，笔者试过两种情况的对比——填充时包含直线上的点和填充时不包含直线上的点，得出的结果，多边形的顶点与边的填充都不理想，但是，填充时包含直线上的点的填充方法的最总结果，使多边形在整体上满足“左闭右开”，“下闭上开”原则，顾才用此方法作图。然而，边缘填充算法的填充原理是没有考虑边界的，即多边形的所有像素都填充为一个颜色，无论多边形内部还是多边形的边和顶点，在实际填充效果中，多边形所有像素都填充为一个颜色的填充方式，顶点和边对整体的效果不大，即可以忽略，所以边缘填充算法依旧是效率极高的填充算法之一。</p>\n<h1 id=\"3-种子填充算法\"><a href=\"#3-种子填充算法\" class=\"headerlink\" title=\"3.种子填充算法\"></a>3.种子填充算法</h1><p>3.1.种子填充算法是区域填充算法中的一种，种子填充算法分为：四邻接点种子填充算法和八邻接点种子填充算法。<br>在此之前，我们需要了解一些概念：</p>\n<h3 id=\"3-1-1-四邻接点：\"><a href=\"#3-1-1-四邻接点：\" class=\"headerlink\" title=\"3.1.1.四邻接点：\"></a><strong>3.1.1.四邻接点：</strong></h3><p>​    任易一个种子像素，其左右上下这四个像素成为这个种子像素的四邻接点。<br><img src=\"https://img-blog.csdnimg.cn/20190621092132813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"3-1-2-八邻接点：\"><a href=\"#3-1-2-八邻接点：\" class=\"headerlink\" title=\"3.1.2.八邻接点：\"></a><strong>3.1.2.八邻接点：</strong></h3><p>​    任易一个种子像素，其左右上下及左上、右下、右上、左上这八个像素成为这个种子像素的八邻接点。<br><img src=\"https://img-blog.csdnimg.cn/20190621092334685.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"3-1-3-四连通域：\"><a href=\"#3-1-3-四连通域：\" class=\"headerlink\" title=\"3.1.3.四连通域：\"></a><strong>3.1.3.四连通域：</strong></h3><p>​    多边形中能被四邻接点遍历填充的区域。</p>\n<h3 id=\"3-1-4-八连通域：\"><a href=\"#3-1-4-八连通域：\" class=\"headerlink\" title=\"3.1.4.八连通域：\"></a><strong>3.1.4.八连通域：</strong></h3><p>​    多边形中能被八邻接点遍历填充的区域。<br><img src=\"https://img-blog.csdnimg.cn/20190621094757411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"3-1-5-四连通边界：\"><a href=\"#3-1-5-四连通边界：\" class=\"headerlink\" title=\"3.1.5.四连通边界：\"></a><strong>3.1.5.四连通边界：</strong></h3><p><img src=\"https://img-blog.csdnimg.cn/20190621094925910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"3-1-6-八连通边界：\"><a href=\"#3-1-6-八连通边界：\" class=\"headerlink\" title=\"3.1.6.八连通边界：\"></a><strong>3.1.6.八连通边界：</strong></h3><p><img src=\"https://img-blog.csdnimg.cn/20190621095031628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"3-2-适用场景：\"><a href=\"#3-2-适用场景：\" class=\"headerlink\" title=\"3.2.适用场景：\"></a><strong>3.2.适用场景：</strong></h2><p>​    区域填充算法适用于多边形的边界与内部使用不同的填充色的场景。</p>\n<h2 id=\"3-3-多边形边界的颜色：\"><a href=\"#3-3-多边形边界的颜色：\" class=\"headerlink\" title=\"3.3.多边形边界的颜色：\"></a><strong>3.3.多边形边界的颜色：</strong></h2><p>​    边界的颜色由绘制多边形时的画笔确定。</p>\n<h2 id=\"3-4-多边形内部的颜色填充步骤\"><a href=\"#3-4-多边形内部的颜色填充步骤\" class=\"headerlink\" title=\"3.4.多边形内部的颜色填充步骤\"></a><strong>3.4.多边形内部的颜色填充步骤</strong></h2><p>​    3.4.1.在多边形内部任易选择一个像素作为种子像素。<br>​    3.4.2.将种子像素入栈。<br>​    3.4.3.如果栈不为空，则将栈顶元素出栈。<br>​    3.4.4.按填充色绘制出栈像素。<br>​    3.4.5.按四邻接点（左、上、右、下）（或八邻接点（左、左上、上、右上、右、右下、下、左下））顺序搜索与出栈像素相邻的4（或8）个像素，若该像素的颜色不是填充色并且也不是边界色，则把该像素入栈，否则丢弃该像素。<br>​    不难想象，当多边形的面积极大时，入栈的像素像素将是巨量，有的像素可能即是一个像素的邻接点又是另一个像素的邻接点，以致部分像素入栈多次，此情况下填充过程将大量占用栈存储空间，甚至过量占用空间，致使栈空间不足，导致其他程序无空间可用，如此既不能完成填充，又会造成空间溢出，甚至系统崩溃，所以种子填充算法的缺点极为严重。</p>\n<h2 id=\"3-5-改进——扫描种子填充算法\"><a href=\"#3-5-改进——扫描种子填充算法\" class=\"headerlink\" title=\"3.5.改进——扫描种子填充算法\"></a><strong>3.5.改进——扫描种子填充算法</strong></h2><p>​    3.5.1.在多边形内部选择一个像素作为种子像素。<br>​    3.5.2.将种子像素入栈。<br>​    3.5.3.若栈不为空，则将栈顶元素出栈<br>​    3.5.4.沿出栈像素所在扫描线，对出栈像素左右像素依次填充，直至遇到边界像素为止。<br>​    3.5.5.记录该区间的范围，将最左端的像素记为Xl，将最右端的像素记为Xr。<br>​    3.5.6.检查与当前扫描线相邻的上下两条扫描线中在区间[Xl，Xr]里的有关像素是否全为边界像素或以填充像素，若存在非边界且未填充的像素，则把区间最右端像素取作种子像素入栈。<br>​    扫描种子填充像素每次只将区间最右端的像素入栈，极大的减少了入栈像素，不仅减少了栈空间的占用，还有效的提高了填充效率和填充速度。</p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p>首先对于如下的多边形：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190618080545123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"1-有效边表填充算法\"><a href=\"#1-有效边表填充算法\" class=\"headerlink\" title=\"1.有效边表填充算法\"></a>1.有效边表填充算法</h1><h2 id=\"1-1-有效边表填充算法分为如下几个步骤：\"><a href=\"#1-1-有效边表填充算法分为如下几个步骤：\" class=\"headerlink\" title=\"1.1.有效边表填充算法分为如下几个步骤：\"></a><strong>1.1.有效边表填充算法分为如下几个步骤</strong>：</h2><p>​    1.1.1.将多边形所有的边分别与扫描线1计算交点，得到交点集，与扫描线计算的边没有顺序要求。<br>​    1.1.2.将点集按标x的大小递增排序，得到有序点集。<br>​    1.1.3.将有序点集两两配对，得到对应的像素区间。<br>​    1.1.4.将像素区间内的像素填充颜色，至此第一条扫描线上处于多边形内的的像素填充完毕。<br>​    1.1.5.扫描线标号加1，重复以上步骤，直至到最后一条扫描线。<br>​    如：对于扫描线3（y=3）与多边形所有的边计算交点，得到与P3P4交于点（4.5，3），与P3P2交于点（2.4，3），与P5P6交于点（8.8，3），与P5P4交于点（7，3）。<br>​    圆整处理得到点集（5，3）、（2，3）、（9，3）、（7，3）。<br>​    递增排序得到有序点集（2，3）、（5，3）、（7，3）、（9，3）。<br>​    两两配对得到扫描线3上的填充像素区间[2，5]、[7，9]。<br>​    填充区间内的所有像素。<br>​    得到如图所示的填充效果：<br><img src=\"https://img-blog.csdnimg.cn/20190617115850448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>全部填充得到如下效果：<br><img src=\"https://img-blog.csdnimg.cn/20190617115915999.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"1-2-至此我们发现如下疑问：\"><a href=\"#1-2-至此我们发现如下疑问：\" class=\"headerlink\" title=\"1.2.至此我们发现如下疑问：\"></a><strong>1.2.至此我们发现如下疑问：</strong></h2><p>​    1.2.1.像素填充的多边形面积大于多边形实际面积。<br>​    可能上图不太明显，我们举一个明显一点的例子，如下正方形：<br><img src=\"https://img-blog.csdnimg.cn/20190617115935411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>我们填充后的效果为：<br><img src=\"https://img-blog.csdnimg.cn/20190617115949648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>​    而正方形的实际面积是4，在显示器上一个像素为一面积，正方形应该占4个像素点，而实际却占了9个像素点，对于这种问题，有效边表填充算法采用“左闭右开”，“下闭上开”的原则进行像素点的填充，按照此原则，正方形的填充效果如下：<br><img src=\"https://img-blog.csdnimg.cn/20190617120002618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>1.2.1.对于点集（1，3）、（1，8）它们分别为扫描线1与P3P2、P3P4、P5P4、P5P6的交点，而在实际计算中它们仍只是两个点，如果处理不当，计算机可能会两两配对得到区间（3，8）而填充到错误的像素区间。<br>对于此问题，有效边表填充算法采用分类连接点进行处理。<br>有效边表填充算法将多边形的各个连接点分为三类连接点：</p>\n<h3 id=\"普通连接点：\"><a href=\"#普通连接点：\" class=\"headerlink\" title=\"+普通连接点：\"></a><strong>+普通连接点：</strong></h3><p>​    连接点所在的两条边分别处于其所在的扫描线的上方和下方，如P2点。</p>\n<h3 id=\"局部最低点：\"><a href=\"#局部最低点：\" class=\"headerlink\" title=\"+局部最低点：\"></a><strong>+局部最低点：</strong></h3><p>​    连接点所在的两条边都处于其所在的扫描线的上方，如P3、P5点。</p>\n<h3 id=\"局部最高点：\"><a href=\"#局部最高点：\" class=\"headerlink\" title=\"+局部最高点：\"></a><strong>+局部最高点：</strong></h3><p>​    连接点所在的两条边都处于其所在的扫描线的下方，如：P4、P1、P6点。<br>​    在填充开始前，有效边填充算法先对多边形所有的连接点进行分类，判断其在点集中的数量。<br>有效边填充算法采用如下原则对多边形的连接点进行处理：</p>\n<h3 id=\"1-2-2-普通连接点的处理原则\"><a href=\"#1-2-2-普通连接点的处理原则\" class=\"headerlink\" title=\"1.2.2.普通连接点的处理原则\"></a><strong>1.2.2.普通连接点的处理原则</strong></h3><p>​    以P2为例，根据“下闭上开”原则，对于P3P2上的点P2不予填充，P2P1上的点P2需要填充，P2点只填充1次，顾在扫描线7的填充像素点集中P2点的个数记为1，即可以不处理。</p>\n<h3 id=\"1-2-3-局部最低点的处理原则\"><a href=\"#1-2-3-局部最低点的处理原则\" class=\"headerlink\" title=\"1.2.3.局部最低点的处理原则\"></a><strong>1.2.3.局部最低点的处理原则</strong></h3><p>​    以P3为例，根据“下闭上开”原则，对于P3P2上的点P3需要填充，P3P4上的点P3也需要填充，P3填充2次，扫描线1的填充像素点集中，再添加一个P3点，使其中有两个P3点，在像素点集中将P3点的个数记为2，P5点进行同样的处理，这样当算法进行两两配对时，得到的像素区间为[3，3]、[5，5]，如此即可避免出现[3，8]的点集区间，解决此类情况的填充错误。</p>\n<h2 id=\"1-2-4-局部最高点的处理原则\"><a href=\"#1-2-4-局部最高点的处理原则\" class=\"headerlink\" title=\"1.2.4.局部最高点的处理原则\"></a><strong>1.2.4.局部最高点的处理原则</strong></h2><p>​    以P1点为例，根据“下闭上开”原则，对于P2P1上的P1点不予填充，P0P1上的P1点也不予填充，P1填充0次，扫描线12的像素填充点集中P1点的个数记为0，即从点集中删除P1点，这样的处理符合多边形整体的“下闭上开”原则。<br>至此，多边形的有效边表填充算法的填充原理已经完成。<br>但是，我们在填充多边形之前还需要进行一项很重要的工作——根据多边形计算其有效边表，首先我们要了解什么是有效边。<br><strong>有效边</strong>：多边形与当前扫描线相交的边称为有效边，有效边的引入可以有效的避免扫描边与多边形的所有的边进行交点计算，提高算法的效率。<br><strong>有效边表</strong>：有效边按与扫描线交点x坐标递增顺序存放的链表。<br><strong>有效边表节点结构</strong>：<br><img src=\"https://img-blog.csdnimg.cn/20190618080124847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>示例：扫描线1的有效边表如下：<br><img src=\"https://img-blog.csdnimg.cn/20190618081306344.png\" alt=\"在这里插入图片描述\"><br><strong>桶表</strong>：有效边表按扫描线自增顺序存放的表，可以是链表，也可以是顺序表。<br><strong>桶表的结构</strong>：<br>​    如：多边形P0-P6的桶表为：<br><img src=\"https://img-blog.csdnimg.cn/20190618082918644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>​    有效边表可以有效的减少计算量，提升多边形的填充效率，如所有的扫描线中，计算机只需要计算扫描线1、扫描线7和扫描线8，且扫描线1只需和边P2P3、P3P4、P4P5、P5P6计算交点，而无需与所有边计算交点，有效边填充算法是目前最有效的多边形填充算法之一。<br>至此，多边形的有效边填充算法全部完成。</p>\n<h1 id=\"2-边缘填充算法\"><a href=\"#2-边缘填充算法\" class=\"headerlink\" title=\"2.边缘填充算法\"></a>2.边缘填充算法</h1><h2 id=\"2-1-算法原理：\"><a href=\"#2-1-算法原理：\" class=\"headerlink\" title=\"2.1.算法原理：\"></a><strong>2.1.算法原理：</strong></h2><p>​    先计算多边形每条边与扫描线的交点，然后将交点右侧的所有像素颜色全部取补色。</p>\n<h2 id=\"2-2-补色的定义：\"><a href=\"#2-2-补色的定义：\" class=\"headerlink\" title=\"2.2.补色的定义：\"></a><strong>2.2.补色的定义：</strong></h2><p>​    对于黑白图像，白色的补色为黑色，黑色补色为白色，对于彩色图像，前景色取补就是将前景色置为背景色，背景色取补就是将背景声置为前景色。<br>示例：<br><img src=\"https://img-blog.csdnimg.cn/20190618092226427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>​    边缘填充算法的填充效率受到右侧填充像素的数量影响，当多边形靠近屏幕左侧时，计算机将填充大量无用像素，大大降低的算法的性能，浪费了系统资源。<br>于是有人提出这样的改进：首先在进行多边形填充之前，先扫描一遍多边形，得出多边形的包围盒，并在适当的位置加入一条栅栏。<br>包围盒：包围多边形的最小矩形。</p>\n<h2 id=\"2-3-加入包围盒和栅栏的边缘填充算法原理：\"><a href=\"#2-3-加入包围盒和栅栏的边缘填充算法原理：\" class=\"headerlink\" title=\"2.3.加入包围盒和栅栏的边缘填充算法原理：\"></a><strong>2.3.加入包围盒和栅栏的边缘填充算法原理：</strong></h2><p>​    每次填充前先判断当前边在栅栏的左侧还是右侧，若在左侧，则取补边以右，栅栏以左的像素；若在右侧，则取补边以右，栅栏以左的像素。<br>示例：<br><img src=\"https://img-blog.csdnimg.cn/20190621084324207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>​    可以看出，加入包围盒和栅栏的边缘填充算法极大的减少了需要填充像素的数量，对填充效率的提升是显著的。<br>​    观察边缘填充算法的两幅图，我们是可以察觉到的，边缘填充算法，对多边形的顶点与边的填充不甚理想，边缘填充算法没有给定具体填充时，直线上的点是否包含在填充范围内，笔者试过两种情况的对比——填充时包含直线上的点和填充时不包含直线上的点，得出的结果，多边形的顶点与边的填充都不理想，但是，填充时包含直线上的点的填充方法的最总结果，使多边形在整体上满足“左闭右开”，“下闭上开”原则，顾才用此方法作图。然而，边缘填充算法的填充原理是没有考虑边界的，即多边形的所有像素都填充为一个颜色，无论多边形内部还是多边形的边和顶点，在实际填充效果中，多边形所有像素都填充为一个颜色的填充方式，顶点和边对整体的效果不大，即可以忽略，所以边缘填充算法依旧是效率极高的填充算法之一。</p>\n<h1 id=\"3-种子填充算法\"><a href=\"#3-种子填充算法\" class=\"headerlink\" title=\"3.种子填充算法\"></a>3.种子填充算法</h1><p>3.1.种子填充算法是区域填充算法中的一种，种子填充算法分为：四邻接点种子填充算法和八邻接点种子填充算法。<br>在此之前，我们需要了解一些概念：</p>\n<h3 id=\"3-1-1-四邻接点：\"><a href=\"#3-1-1-四邻接点：\" class=\"headerlink\" title=\"3.1.1.四邻接点：\"></a><strong>3.1.1.四邻接点：</strong></h3><p>​    任易一个种子像素，其左右上下这四个像素成为这个种子像素的四邻接点。<br><img src=\"https://img-blog.csdnimg.cn/20190621092132813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"3-1-2-八邻接点：\"><a href=\"#3-1-2-八邻接点：\" class=\"headerlink\" title=\"3.1.2.八邻接点：\"></a><strong>3.1.2.八邻接点：</strong></h3><p>​    任易一个种子像素，其左右上下及左上、右下、右上、左上这八个像素成为这个种子像素的八邻接点。<br><img src=\"https://img-blog.csdnimg.cn/20190621092334685.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"3-1-3-四连通域：\"><a href=\"#3-1-3-四连通域：\" class=\"headerlink\" title=\"3.1.3.四连通域：\"></a><strong>3.1.3.四连通域：</strong></h3><p>​    多边形中能被四邻接点遍历填充的区域。</p>\n<h3 id=\"3-1-4-八连通域：\"><a href=\"#3-1-4-八连通域：\" class=\"headerlink\" title=\"3.1.4.八连通域：\"></a><strong>3.1.4.八连通域：</strong></h3><p>​    多边形中能被八邻接点遍历填充的区域。<br><img src=\"https://img-blog.csdnimg.cn/20190621094757411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"3-1-5-四连通边界：\"><a href=\"#3-1-5-四连通边界：\" class=\"headerlink\" title=\"3.1.5.四连通边界：\"></a><strong>3.1.5.四连通边界：</strong></h3><p><img src=\"https://img-blog.csdnimg.cn/20190621094925910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"3-1-6-八连通边界：\"><a href=\"#3-1-6-八连通边界：\" class=\"headerlink\" title=\"3.1.6.八连通边界：\"></a><strong>3.1.6.八连通边界：</strong></h3><p><img src=\"https://img-blog.csdnimg.cn/20190621095031628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"3-2-适用场景：\"><a href=\"#3-2-适用场景：\" class=\"headerlink\" title=\"3.2.适用场景：\"></a><strong>3.2.适用场景：</strong></h2><p>​    区域填充算法适用于多边形的边界与内部使用不同的填充色的场景。</p>\n<h2 id=\"3-3-多边形边界的颜色：\"><a href=\"#3-3-多边形边界的颜色：\" class=\"headerlink\" title=\"3.3.多边形边界的颜色：\"></a><strong>3.3.多边形边界的颜色：</strong></h2><p>​    边界的颜色由绘制多边形时的画笔确定。</p>\n<h2 id=\"3-4-多边形内部的颜色填充步骤\"><a href=\"#3-4-多边形内部的颜色填充步骤\" class=\"headerlink\" title=\"3.4.多边形内部的颜色填充步骤\"></a><strong>3.4.多边形内部的颜色填充步骤</strong></h2><p>​    3.4.1.在多边形内部任易选择一个像素作为种子像素。<br>​    3.4.2.将种子像素入栈。<br>​    3.4.3.如果栈不为空，则将栈顶元素出栈。<br>​    3.4.4.按填充色绘制出栈像素。<br>​    3.4.5.按四邻接点（左、上、右、下）（或八邻接点（左、左上、上、右上、右、右下、下、左下））顺序搜索与出栈像素相邻的4（或8）个像素，若该像素的颜色不是填充色并且也不是边界色，则把该像素入栈，否则丢弃该像素。<br>​    不难想象，当多边形的面积极大时，入栈的像素像素将是巨量，有的像素可能即是一个像素的邻接点又是另一个像素的邻接点，以致部分像素入栈多次，此情况下填充过程将大量占用栈存储空间，甚至过量占用空间，致使栈空间不足，导致其他程序无空间可用，如此既不能完成填充，又会造成空间溢出，甚至系统崩溃，所以种子填充算法的缺点极为严重。</p>\n<h2 id=\"3-5-改进——扫描种子填充算法\"><a href=\"#3-5-改进——扫描种子填充算法\" class=\"headerlink\" title=\"3.5.改进——扫描种子填充算法\"></a><strong>3.5.改进——扫描种子填充算法</strong></h2><p>​    3.5.1.在多边形内部选择一个像素作为种子像素。<br>​    3.5.2.将种子像素入栈。<br>​    3.5.3.若栈不为空，则将栈顶元素出栈<br>​    3.5.4.沿出栈像素所在扫描线，对出栈像素左右像素依次填充，直至遇到边界像素为止。<br>​    3.5.5.记录该区间的范围，将最左端的像素记为Xl，将最右端的像素记为Xr。<br>​    3.5.6.检查与当前扫描线相邻的上下两条扫描线中在区间[Xl，Xr]里的有关像素是否全为边界像素或以填充像素，若存在非边界且未填充的像素，则把区间最右端像素取作种子像素入栈。<br>​    扫描种子填充像素每次只将区间最右端的像素入栈，极大的减少了入栈像素，不仅减少了栈空间的占用，还有效的提高了填充效率和填充速度。</p>\n"},{"title":"【C++】C++STL标准模板库","date":"2019-10-06T02:20:37.000Z","_content":"\n\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 一、STL的基本概念\n\n## 1.什么是STL\n\n STL (Standard Template Librany）标准准模板庠是惠普实验室开发的一系列软件的统称。现在主要出现在C++中，但在被引入C++之前该技木就已存在了很长一段吋间了。\n\nSTL的从广义上讲分为三类: algorithm (算法)、container (容器)和iterator (迭代器)，容器和算法通过迭代器可以进行无缝链接。几乎所有的代码都釆用了模板类和模板函数的方式,这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。在C++标准中，STL 被组织为下面的13个尖文件:`<algorithm>`、`<deque>`、`<functional>`、`<iterator>`、`<vector>`、`<list>`、 `<map>`、`<memory>`、`<numerio>`、`<queue>`、`<set>`、\t`<stack>` 和`<utility>`。\n\n![](【C++】C++STL标准模板库/Snipaste_2019-10-06_10-41-56.png)\n\n我们详细的说六大组件：\n\n- 容器(Container)\n- 算法(Algorithm)\n- 迭代器(Iterator)\n- 仿函数(Function object)\n- 适配器(Adaptor)\n- 空间配置器(allocator)\n\n## 2.STL的好处\n\n- STL是C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。\n\n- STL的一个重要特点是数据结构和算法的分离。尽管这是个简单的概念，但是这种分离确实使得STL变得非常通用。\n  例如，在STL 的vector容器中，可以放入元素、 基础数据类型变量、元素的地址;\n  STL的sort()函数可以用来操作vector,list等容器。\n\n- 程序员可以不用思考STL具体的实现过程，只要能够熟综使用STL就OK了。这样他们就可以把精力放在程序开发的别的方面。\n\n- STL 具有高可重用性，高性能，高移植性，跨平台的优点。\n\n    高可重用性: STL 中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。关于模板的知识，已经给大家介绍了。\n\n  高性能:如map可以高效地从十万条记录里面查找出指定的记录，因为map是采用红黑树的变体实现的。\n\n  高移植性:如在项目A上用STL编写的模块，可以直接移植到项目B上。\n\n  跨平台:如用windows的Visual Studio编写的代码可以在Mac OS的XCode上直接运行。\n\n- 了解到STL的这些好处，我们知道STL无疑是最值得C++程序员骄傲的一部分。每一个C++程序员都应该好好学习STL.只有能够熟练使用STL的程序员，才是好的C++程序员。\n\n# 二、容器\n\n## 1.容器\n\n  在实际的开发过程中，数据结构本身的重要性不会逊于操作于数据结构的算法的重要性，当程序中存在着对时间要求很高的部分时，数据结构的选择就显得更加重要。\n\n  经典的数据结构数量有限，但是我们常常重复着一些为了实现向量、链表等结构而编写的代码，这些代码都十分相似，只是为了适应不同数据的变化而在细节上有所出入。STL容器就为我们提供了这样的方便，它允许我们重复利用己有的实现构造自己的特定类型下的数据结构，通过设置-些模板，STL 容器对最常用的数据结构提供了支持，这些模板的参数允许我们指定容器中元素的数据类型，可以将我们许多重复而乏味的工作简化。\n\n​\t容器部分主要由头文件`<vector>`, `<list>`, `<deque>`, `<set>`, `<map>`, `<stack>`和`<queue>`组成。对于常用的一些容器和容器适配器(可以看作由其它容器实现的容器)，可以通过下表总结一:下它们和相应头文件的对应关系。\n\n![](【C++】C++STL标准模板库/Snipaste_2019-10-06_10-41-56.png)\n\n## 2.容器的分类\n\n### 序列式容器(Sequence containers) \n\n每个元素都有固定位置--取决于插入时机和地点，和元素值无关。如：vector、deque、 Iist。\n\n### 关联式容器(Associated containers) \n\n元素位置取决于特定的排序准则，和插入顺序无关。如：sset、multiset、 map、multimapu。\n\n![](【C++】C++STL标准模板库/Snipaste_2019-10-06_14-36-13.png)\n\n## 3.string类\n\n### string类的本质\n\n`string`类本质上其实就是`char*`的容器，是`cahr*`的封装。\n\n### string类的遍历\n\n**使用[]遍历：**\n\n```C++\nstring str = \"string_str\";\nfor (int i = 0; i < str.length(); i++)\n\tcout << str[i];\n```\n\n**使用迭代器遍历：**\n\n```C++\nstring str = \"string_str\";\nfor(string::iteratori=str.begin();i<str.end();i++)\n\tcout <<*i;\n```\n\n<font color=red> 注意这里的`i`是一个指向string::iterator类型的指针。</font>\n\n**使用at()遍历：**\n\n```C++\nstring str = \"string_str\";\nfor (int i = 0; i < str.length(); i++)\n\tcout << str.at(i);\n```\n\n`at()`与`[]`不同的是，当访问发生越界等错误时，`at()`会自动抛出异常，而`[]`不会抛出异常而中断程序。\n\n### string解封成char*\n\nC++为string类提供了一个专门的函数<font color = red> **str.c_str()**</font>，str是string类型的对象，但是需要注意的是`str.c_str()`返回的是一个<font color = red> const char*</font>，不能再被赋值给其他非常量指针，但是我们可以直接将`str.c_str()`当作`char*`来使用，如：`str.c_str()[1]`，即通过`char*`指针访问str中的第二个元素。\n\n### string类中一些常用函数\n\n|      | 函数名                                       | 作用                                                         |\n| ---- | -------------------------------------------- | ------------------------------------------------------------ |\n| 复制 | str.copy(char *buf,int cout)                 | 从字符串str中拷贝cout个字符到char数组buf中                   |\n| 连接 | str.append(string strs)                      | 将字符串strs连接到str之后，支持string和char*                 |\n| 查找 | int str.find(char *strs,int index)           | 从字符串str中的第index索引开始查找strs子串或字符，返回查找到的第一个匹配值的索引，返回的索引也可以使用迭代器来接收 |\n| 替换 | str.replace(int index,int length,char *strs) | 在字符串str中，从index索引开始用strs字符串替换length个长度的子串 |\n| 删除 | str.erase(int index,int length)              | 删除字符出str从index位置开始的length长度的字符               |\n| 插入 | str.insert(int index,char *strs)             | 从str字符串的index位置开始插入字串strs                       |\n\n###  string类中常用算法函数\n\n```C++\nstring str = \"string_str_io_stdsfx.h_iostream\";\ntransform(str.begin(), str.end(), str.begin(), toupper);\ncout << str << endl;\n```\n\ntransform算法包含在`#include <algorithm>`头文件中\n\n**transform算法的使用：**\n\n**原型：**transform(first,last,result,op);\n\nfirst是容器的首迭代器，last为容器的末迭代器，result为存放结果的容器，op为要进行操作的一元函数对象或sturct、class。\n\n**代码解释：**str.begin()返回一个指向str首部位置的迭代器，str.end()返回一个指向str尾部位置的迭代器，因为我们把输出结果继续存放在str中，且迭代器始于容器相联系的，所以存放结果的容器也是str.begin()，而我们对str做的操作是将小写字母装换为大写，C++提供了标准的转换函数,所以操作函数为toupper。\n\n**transform算法的另一个重载形式：**\n\n**原型：**transform(first1,last1,first2,result,binary_op);\n\nfirst1是第一个容器的首迭代 器，last1为第一个容器的末迭代器，first2为第二个容器的首迭代器，result为存放结果的容器，binary_op为要进行操作的二元函数 对象或sturct、class。\n\n需要注意的是，两个容器first1和first2中的元素数量必须相等，否则会抛异常。\n\n## 4.vector容器\n\n- vector是将元素置于一个<font color=red> **动态数组**</font>中加以管理的容器\n- vector支持随机存取元素，支持索引存取（[],at()）和迭代器存取\n- vector在尾部添加和移除元素速度快，在中部和头部速度慢\n- 使用vector容易需要包含`#include<vector>`头文件\n\n### vector常用方法\n\n<table>\n  <tr>\n    <th> </th>\n    <th>函数</th>\n    <th>作用</th>\n  </tr>\n  <tr>\n    <td rowspan=\"4\">读取与赋值</td>\n    <td>front(void)</td>\n    <td>获取容器首元素，既可以作左值也可以作右值</td>\n  </tr>\n  <tr>\n    <td>back(void)</td>\n    <td>获取容器尾元素，既可以作左值也可以作右值</td>\n  </tr>\n  <tr>\n    <td>push_back(T t)</td>\n    <td>在容器的尾部添加元素</td>\n  </tr>\n  <tr>\n    <td>pop_back(T t)</td>\n    <td>删除容器最后一个元素</td> \n  </tr>\n  <tr>\n    <td rowspan=\"4\">只读</td>\n    <td>begin(void)</td>\n    <td>获取容器首部迭代器</td> \n  </tr>\n  <tr>\n    <td>end(void)</td>\n    <td>获取容器尾部迭代器</td> \n  </tr>\n  <tr>\n    <td>rbegin(void)</td>\n    <td>获取逆序首部迭代器，实际指向容器的尾部，只能使用vector&#60int&#62::reverse_iterator逆序迭代器接收</td> \n  </tr>\n  <tr>\n    <td>rend(void)</td>\n    <td>获取逆序尾部部迭代器，实际指向容器的首部，只能使用vector&#60int&#62::reverse_iterator逆序迭代器接收</td> \n  </tr>\n  <tr>\n    <td rowspan=\"2\">删除</td>\n    <td>erase(iterator pos)</td>\n    <td>删除迭代器pos指向位置的元素</td> \n  </tr>\n  <tr>\n    <td>erase(iterator begin,iterator end)</td>\n    <td>从迭代器begin指向位置开始到end指向位置结束，区间删除元素</td> \n  </tr>\n  <tr>\n    <td>插入</td>\n    <td>insert(iterator pos,T t)</td>\n    <td>在pos迭代器指向的位置插入元素t，insert中的迭代器pos只能是begin()或end()否则会报错，似乎不止其他的迭代器</td> \n  </tr>\n    <td>判空</td>\n    <td>empty(void)</td>\n    <td>容器判空</td> \n  </tr>\n</table>\n### Vector浅析\n\nvector的最重要的实现组成其实只有三个指针，上源码：\n\n```c++\n// CLASS TEMPLATE vector\ntemplate<class _Ty,class _Alloc = allocator<_Ty>>\nclass vector : public _Vector_alloc<_Vec_base_types<_Ty, _Alloc>>\n{\t\n    //...\n}\n```\n\n类体这里就省略了，如果仔细看源码就会发现vector的类体里主要实现的大多只是一些供外部调用的函数而已，而vector的最底层的一些实现其实在它的基类中就已经完成了，如`_Vector_alloc`类，而`_Vector_alloc`中也没有包含最重要的三个指针，我们在vector.cpp中搜索`_Myfirst`可以发现，`_Myfirst`,`_Mylast`,`_Myend`三个指针在`_Vector_val`这个类中，而`_Vector_alloc`中包含了对`_Vector_val`的操作。\n\n```c++\n// CLASS TEMPLATE _Vector_val\ntemplate<class _Val_types>\nclass _Vector_val : public _Container_base\n{\t// base class for vector to hold data\npublic:\n\tusing value_type = typename _Val_types::value_type;\n\tusing size_type = typename _Val_types::size_type;\n\tusing difference_type = typename _Val_types::difference_type;\n\tusing pointer = typename _Val_types::pointer;\n\tusing const_pointer = typename _Val_types::const_pointer;\n\tusing reference = value_type&;\n\tusing const_reference = const value_type&;\n\n\t_Vector_val()\n\t\t: _Myfirst(),\n\t\t_Mylast(),\n\t\t_Myend()\n\t\t{\t// initialize values\n\t\t}\n\n\tpointer _Myfirst;\t// pointer to beginning of array\n\tpointer _Mylast;\t// pointer to current end of sequence\n\tpointer _Myend;\t// pointer to end of array\n};\n```\n\n在vector中有两个关键的数字，<font color=red>size与capacity</font>，其中`size=_Mylast-_Myfirst`，`capacity=_Myend-Myfirst`，三个指针指向的内存位置如下：\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210330094505.png)\n\nsize的计算源码：\n\n```c++\n_NODISCARD size_type size() const noexcept\n{\t// return length of sequence\n\treturn (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));\n}\n```\n\ncapacity的计算源码：\n\n```c++\n_NODISCARD size_type capacity() const noexcept\n{\t// return current length of allocated storage\n\treturn (static_cast<size_type>(this->_Myend() - this->_Myfirst()));\n}\n```\n\n我们都知道vector的性能优越，而支撑着vector的优越性能的就是这两数据，size和capacity，size是vector中实际元素的个数，即vector总容量中的已用容量(used部分)，而capacity则是vector初始化时设置的总容量(等于used部分加unsed部分)，C++分配给vector的实际内存总是比定义时的要大一点，这是因为vector占用的内存是一整块连续的内存，预分配多一些内存可以降低vector之后的二次分配时的时间成本。所以capacity>=size，档capacity=size时表示容易已满，若需要继续添加元素则需要整体移动vector，此时花费的成本会较高，所以种情况应尽量避免。\n\n## 5.deque容器\n\n- deque容器是一个双端数组，在双端数组的两端均可以插入和删除元素\n- 使用deque容器需要包头文件`#include<deque>`\n\ndeque容器可以说是vector容器的升级版，deque的用法基本和vector一致，但是deque不仅提供push_back()，pop_back()还提供<font color = red> **push_front()**</font> 和<font color = red> **pop_front()**</font>。\n\n## 6.stack容器\n\n- stack容器是一个栈模型\n- 使用stack容器需要包含头文件`#include<stack>`\n\n### stack常用方法\n\n| 函数      | 作用         |\n| --------- | ------------ |\n| push(T t) | 元素入栈顶   |\n| pop()     | 栈顶元素出栈 |\n| top()     | 获取栈顶元素 |\n\n## 7.queue容器\n\n- queue容器是一个队列模型\n- 使用queue容器需要包含头文件`#include<queue>`\n\n### queue常用方法\n\n| 函数      | 作用                                   |\n| --------- | -------------------------------------- |\n| push(T t) | 元素入队尾                             |\n| pop()     | 队首元素出队                           |\n| front()   | 获取队首元素，既可以作左值也可以作右值 |\n| back()    | 获取队尾元素，既可以作左值也可以作右值 |\n\n## 8.list容器\n\n- list容器是一个双向链表模型，可以高效的进行元素的插入和删除操作\n- list容器不支持随机访问，即不支持[],at()和iterator + n(如：begin()+1)等形式的访问\n- 使用list容器需要包含头文件`#include<list>`\n\nlist容器除了不支持随机访问外，用法和deque容器的用法基本一致，除此之外list容器还提供一个<font color = red> **remove(T t)**</font>函数来根据元素内容删除元素\n\n使用list容器时有一点需要注意<font color = red> **list容器在使用erase删除元素时，遵循左闭右开的原则**</font>，如：\n\n```C++\nlist<int> li;\nfor (int i = 0; i < 5; i++)\n\tli.push_back(i);\nfor (list<int>::iterator it = li.begin(); it != li.end(); it++)\n\tcout << *it;\ncout << endl;\nlist<int>::iterator it1 = li.begin();//it1指向元素0\nlist<int>::iterator it2 = li.begin();\nit2++; it2++; it2++;//此时it2指向元素3\nli.erase(it1, it2);\nfor (list<int>::iterator it = li.begin(); it != li.end(); it++)\n\tcout << *it;\ncout << endl;\n```\n\n**输出结果：**\n\n```\n01234\n34\n```\n\n可以看到erase在删除0-3的元素时删除了0，1，2而没有删除3，即左闭右开。\n\n### list浅析\n\nlist在实现结构上和vector很类似，只是list比vector多了一个`_List_buy`中间层，list的实现的核心组成有两个，`_List_val`和`_List_node`前者主要与数据结构规模和头节点相关，后者主要与数据存储、prev和next相关。上`_List_val`的源码：\n\n```c++\ntemplate<class _Val_types>\nclass _List_val : public _Container_base\n{\t// base class for list to hold data\npublic:\n\tusing _Nodeptr = typename _Val_types::_Nodeptr;\n\n\tusing value_type = typename _Val_types::value_type;\n\tusing size_type = typename _Val_types::size_type;\n\tusing difference_type = typename _Val_types::difference_type;\n\tusing pointer = typename _Val_types::pointer;\n\tusing const_pointer = typename _Val_types::const_pointer;\n\tusing reference = value_type&;\n\tusing const_reference = const value_type&;\n\n\t_List_val()\n\t\t: _Myhead(),\n\t\t_Mysize(0)\n\t\t{\t// initialize data\n\t\t}\n\n\t_Nodeptr _Myhead;\t// pointer to head node\n\tsize_type _Mysize;\t// number of elements\n};\n```\n\n可以看到list中包含了一个指向头节点的指针`_Myhead`，也就是说即使我们创建的一个空list也至少包含一个空的头节点，list使用头节点的目的就是更方便的构建容器，`_Mysize`记录的就是list的当前元素个数。\n\nlist节点_List_node`的底层数据结构是一个结构体：\n\n```c++\ntemplate<class _Value_type,class _Voidptr>\nstruct _List_node\n{\t// list node\n\tusing _Nodeptr = _Rebind_pointer_t<_Voidptr, _List_node>;\n\t_Nodeptr _Next;\t// successor node, or first element if head\n\t_Nodeptr _Prev;\t// predecessor node, or last element if head\n\t_Value_type _Myval;\t// the stored value, unused if head\n\n\t_List_node& operator=(const _List_node&) = delete;\n\n\ttemplate<class _Alloc>\n\tstatic void _Freenode0(_Alloc& _Al, _Nodeptr _Ptr) noexcept\n\t{\n\t\tusing _Alnode = _Rebind_alloc_t<_Alloc, _List_node>;\n\t\tusing _Alnode_traits = allocator_traits<_Alnode>;\n\t\t_Alnode _Node_alloc(_Al);\n\t\t_Alnode_traits::destroy(_Node_alloc, _STD addressof(_Ptr->_Next));\n\t\t_Alnode_traits::destroy(_Node_alloc, _STD addressof(_Ptr->_Prev));\n\t\t_Alnode_traits::deallocate(_Node_alloc, _Ptr, 1);\n\t}\n};\n```\n\n`_List_node`的核心组成就是`_Next`，`_Prev`，`_Myval`，`_Next`是下一个节点的指针，`_Prev`是指向上一个节点的指针，`_Myval`是存储数据的容器。\n\n## 9.priority_queue容器\n\n- `priority_queue`容器是一个具有优先级的队列，又叫优先级队列适配器，分为最大优先级队列和最小优先级队列两种\n\n- priority_queue容器是一种特殊的queue容器，所以也需要包含头文件`#include<queue>`\n\n默认的定义`priority_queue<T> pr`的优先级队列是最大优先级队列，显示定义最小优先级队列：`priority_queue<int,vector<int>,less<int>> pr`，`less`是一个谓词后面再学习，显示定义最大优先级队列：`priority_queue<int,vector<int>,greater<int>> pr`，其中使用`greater`需要包含头文件`#include<functional>`。\n\n`priority_queue`容器的用法基本和`queue`一致，除此之外，`priority_queue`容器提供一个`top()`函数来获取队首元素，而`queue`容器没有这个方法。\n\n**示例：**\n\n```C++\npriority_queue<int,vector<int>,greater<int>> pr;\npr.push(12);\npr.push(4);\npr.push(10);\npr.push(20);\ncout << \"最小元素：\" <<pr.top() << endl;\nwhile (pr.size() > 0)\n{\n\tcout << pr.top() << \",\";\n\tpr.pop();\n}\n```\n\n**输出结果：**\n\n```\n最小元素：4\n4,10,12,20,\n```\n\n## 10.set容器\n\n- `set`是一个<font color=red>**集合**</font>容器，其中所包含的元素是<font color=red>**唯一**</font>的，<font color=red>**集合中的元素按一定的顺序排序**</font>，元素的插入过程是按排序规则插入，所以不能指定位置插入\n- `set`采用红黑树变体的数据结构实现，红黑树属于平衡二叉树，在插入和删除操作上比`vector`容器速度更快\n- `set`容器不支持[]和at()来存取元素\n- <font color=red>**set不支持直接修改容器中的元素**</font>，因为元素是自动排序的，如果希望修改一个元素值，就必须删除这个元素再插入新元素\n- 要使用`set`容器需要包含头文件`#include<set>`\n\n### set容器的基本特性\n\n默认情况下，直接定义的set容器采用最小优先排序，和priority_queue容器恰好相反，`set<T> se`就是隐式的`set<T,less<T>> se`，定义最大优先排序的set容器需要显示定义：`set<T,greater<T>> se`。\n\n我们来看一个例子：\n\n```C++\nset<string,greater<string>> se;//采用最大优先排序\nfor (int i = 0; i < 5; i++)//生成随机字符串元素\n{\n\tint tmp = rand();\n\tstring str = \"\";\n\twhile (str.length()<=3)\n\t{\n\t\tif(tmp >= 97 && tmp <= 122)\n\t\t\tstr += tmp;\n\t\ttmp = rand();\n\t}\n\tse.insert(str);\n}\nse.insert(\"strs\");//插入相同的字符串元素\nse.insert(\"strs\");\nse.insert(\"strs\");\nfor (set<string, greater<string>>::iterator it = se.begin(); it != se.end(); it++)\n\tcout << *it << endl;\n```\n\n**输出结果：**\n\n```\nwqye\nvfep\nstrs\nomsk\nkfnm\ncdsb\n```\n\n可以看到，容器里的字符串确实按照字符串的比较规则按从大到小的顺序排列着，并且无论我们插入多少个相同的元素，在容器内只会存储一个相同的元素值。\n\n值得注意的是：\n\n`set`容器只提供了`insert(T t)`函数来插入元素。\n\n### 自定义元素的排序\n\n自定义类作元素可能会出现类中有多个字段，而我们需要其中的某一个字段来作为关键字在`set`容器中排序，要实现这样的行为，我们就需要用到<font color=red>**仿函数**</font>了。\n\n#### 什么是仿函数？\n\n仿函数实质上就是一个做了`()`重载的结构体，因为重载了`()`使用起来类似函数，所以称之为仿函数。\n\n我们来看一个例子：\n\n```C++\nclass Student\n{\npublic:\n\tstring name;\n\tint age;\n\tbool isStudent;\n\tStudent(const string name, const int age, const bool isStudent)\n\t{\n\t\tthis->age = age;\n\t\tthis->name = name;\n\t\tthis->isStudent = isStudent;\n\t}\n};\nstruct AgeSort//仿函数\n{\n\tbool operator()(const Student &lift, const Student &right)\n\t{\n\t\treturn (lift.age < right.age);\n\t}\n};\nint main()\n{\n\tset<Student, AgeSort> se;\n\tStudent s1(\"Alian\", 23, true);\n\tStudent s2(\"Blank\", 20, true);\n\tStudent s3(\"Cary\", 43, false);\n\tStudent s4(\"Davel\", 23, true);\n\tse.insert(s1); se.insert(s2);\n\tse.insert(s3); se.insert(s4);\n\tfor (set<Student, AgeSort>::iterator it = se.begin(); it != se.end(); it++)\n\t\tcout << it->name << \"\\t\" << it->age << \"\\t\" << it->isStudent << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**输出结果：**\n\n```\nBlank   20      1\nAlian   23      1\nCary    43      0\n```\n\n其中`AgeSort`就是仿函数，它的比较关键字是`Student.age`，所以`set`容器对象se会以age作为排序关键字，其实我们之前使用的`less<>`和`greater<>`也是反函数，只不过是C++预定义好的仿函数。\n\n细心的朋友可能会发现，我们插入的s4对象居然不再容器里！！！这是因为set容器中的元素具有唯一性，而set容器是通过关键字来识别元素的，所当碰到关键字相同的元素时，set只会存储一个元素。\n\n那么这种情况该怎么解决呢？答案是set容器没有办法解决这种情况，如果有出现这种情况，就不能使用set容器而改用multiset容器。\n\n在后面的算法模块我们详细介绍仿函数。\n\n### set常用函数\n\n| 函数             | 作用                                                         |\n| ---------------- | ------------------------------------------------------------ |\n| find(T t)        | 查找元素t，返回指向t元素的迭代器，查找失败返回指向set.end()的迭代器 |\n| count(T t)       | 返回容器中元素t的个数，值要么是0，要么是1                    |\n| lower_bound(T t) | 返回一个指向>=t元素的迭代器，如果t存在则指向t，如果t不存在则指向t后面的一个元素 |\n| upper_bound(T t) | 返回一个指向>t元素的迭代器，即t元素后面的一个元素            |\n| equal_range(T t) | 返回一个包含两个set类型的迭代器的对组pair<set<T>::iterator,set<T>::iterator>第一个迭代器指向t元素，第二个迭代器指向t后面的一个元素，如果t不存在，则两个迭代器都指向t后面的一个元素 |\n\n### <font color=blue> 小知识</font>\n\n<font color=blue> 事实上容器中的`insert`函数是有返回值的，`insert`的返回值是一个对组(pair)类型的泛型`pair<set<T>::iterator, bool>`的对象，`pair`是一个只有两个字段的模板，我们可以直接定义`pair<set<T>::iterator, bool>`类型对象来接收`insert`函数的返回值，如：</font>\n\n```C++\npair<set<Student,AgeSort>::iterator, bool> pait=se.insert(s1);\n```\n\n<font color=blue> 我们可以通过`pair.first`和`pair.second`来访问对组中的两个元素，通过`pair.first`来访问对组中的第一个元素`set<Student,AgeSort>::iterator`类型的迭代器，通过`pair.first->first`，和`pair.first->second`可以访问迭代器所指向的容器元素，我们通过`pair.second`来访问对组中的第二个元素，bool型的元素记录的是insert函数插入是否成功，如果插入成功则记录true，否则记录false。</font>\n\n## 11.multiset容器\n\n- `multiset`容器可以说是set容器的升级版，multiset容器支持多个相同键值的元素的存储，所以要使用`multiset`需要包含头文件`#include<set>`\n\nmultiset的用法和set一致。\n\n## 12.map容器\n\n- `map`是标准的关联式容器，一个`map`元素是一个键值对(key,value),`map`提供基于键值的快速检索能力\n- `map`中<font color=red>` key`值是唯一的</font>\n- `map`容器中的元素也是按一定顺序排列的，元素插入过程是按排序规则插入的，所以不能指定位置插入\n- `map`容器的具体实现也是采用红黑二叉树变体的平衡二叉树的数据结构，在插入和删除的操作上比`vector`更快\n- 与`set`不同的是`map`支持直接存取`key`值对应的`value`，也支持[]操作符\n- 要使用`map`容器就需要包含头文件`#include<map>`\n\n### map的元素插入\n\n```C++\nint main()\n{\n\tmap<int, string> ma;\n\t//方法一\n\tma.insert(pair<int, string>(1, \"pair\"));\n\tma.insert(pair<int, string>(1, \"pair_02\"));\n\t//方法二\n\tma.insert(make_pair(2, \"make_pair\"));\n\tma.insert(make_pair(2, \"make_pair_02\"));\n\t//方法三\n\tma.insert(map<int, string>::value_type(3, \"value_type\"));\n\tma.insert(map<int, string>::value_type(3, \"value_type_02\"));\n\t//方法四\n\tma[4] = \"map\";\n\tma[4] = \"map_02\";\n\tfor (map<int, string>::iterator it = ma.begin(); it != ma.end(); it++)\n\t\tcout << it->first << \"\\t\" << it->second << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**输出结果：**\n\n```\n1       pair\n2       make_pair\n3       value_type\n4       map_02\n```\n\n上面四种方法都可以向map容器里添加元素，但是四者中也有一些微小的区别，前面三种方法在插入相同键值时，只会保存第一存储的结果，之后插入相同键值的元素时都会插入失败，而第四种方法则是后面赋值的元素覆盖前面赋值的元素。\n\nmap似乎没办法来指定是从大到小排序或是从小到大排序\n\nmap除了元素的形式不同，在其他方面map的用法基本和set一致\n\n## 13.multimap容器\n\n`multimap`容器和`multiset`容器一样，是`map`容器的升级版，支持一个键对应多个值，所以`multimap`的一个重要应用场景就是数据分组。\n\n## 14.容器在使用过程必须要注意的地方\n\n<font color=red> 因为在将元素添加到容器里时，C++执行的是容器的默认的拷贝构造函数，将元素拷贝到容器里，这个过程是一个浅拷贝，既然是浅拷贝就会面临浅拷贝的两次内存释放的问题，尤其是类元素，所以在添加一些具有指针字段的元素到容器里时，一定在类里定义一个深拷贝的拷贝构造函数和=的重载函数。</font>\n\n## 15.各个容器的比较\n\n|              | vector   | deque    | list     | set    | multiset | map         | multimap    |\n| ------------ | -------- | -------- | -------- | ------ | -------- | ----------- | ----------- |\n| 内存结构     | 单端数组 | 双端数组 | 双向链表 | 二叉树 | 二叉树   | 二叉树      | 二叉树      |\n| 随机存取     | 是       | 是       | 否       | 否     | 否       | 对key而言是 | 否          |\n| 元素检索     | 慢       | 慢       | 非常慢   | 快     | 快       | 对key而言快 | 对key而言快 |\n| 快速安插移除 | 尾端     | 头尾两端 | 任何位置 | -      | -        | -           | -           |\n\n# 三、算法\n\n## 1.算法\n\n​\t函数库对数据类型的选择对其可重用性起着至关重要的作用。举例来说，一个求方根的函数，在使用浮点数作为其参数类型的情况下的可重用性肯定比使用整型作为它的参数类性要高。而C++通过模板的机制允许推迟对某些类型的选择，直到真正想使用模板或者说对模板进行特化的时候，STL就利用了这一点提供了相当多的有用算法。它是在一个有效的框架中完成这些算法的--可以将所有的类型划分为少数的几类，然后就可以在模版的参数中使用一种类型替换掉同一种类中的其他类型。\n\n  STL提供了大约100个实现算法的模版函数，比如算法for_ each 将为指定序列中的每一个元素调用指定的函数，stable_ _sort 以你所指定的规则对序列进行稳定性排序等等，这样一-来,只要熟悉了STL之后，许多代码可以被大大的化简，只需要通过调用一-两个算法模板，就可以完成所需要的功能并大大地提升效率。\n\n  算法部分主要由头文件`<algorithm>`, `<numeric>`和`<functional>`组成。`<algorithm>`是所 有STL头文件中最大的一个(尽管它很好理解)，它是由一大堆模版函数组成的，可以认为每个函数在很大程度上都是独立的，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等等。`<numeric>`体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。`<functional>`中则定义了一些模板类，用以声明函数对象。\n\n## 2.算法的分类\n\n### 非可变序列算法\n\n计数算法：count,count_if等 \n\n搜索算法：search,find,find_if,find_list_of等\n\n比较算法：equal,mismatch,lexicographical_compare等\n\n### 可变排序算法\n\n删除算法：remove,remove_if,remove_copy等\n\n修改算法：for_each,transform等\n\n排序算法：sort,stable_sort,partial_sort等\n\n## 3.仿函数\n\n\n\n## 4.一些常用的算法模板\n\n### find算法\n\n**原型:**`iterator find(iterator begin,iterator end,T t)`\n\n在容器的begin迭代器所指向的位置开始到end所指向的位置结束，查找元素t，如果找到了，则返回指向t的迭代器。\n\n# 四、迭代器\n\n## 1.迭代器\n\n​\t迭代器从作用上来说是最基本的部分，可是理解起来比前两者都要费力一些。软件设计有一个基本原则，所有的问题都可以通过引进一个间接层来简化，这种简化在 STL中就是用迭代器来完成的。概括来说，迭代器在STL中用来将算法和容器联系起来，起着一种黏和剂的作用。几乎STL提供的所有算法都是通过送代器存取元素序列进行工作的，每一个容器都定义了其本身所专有的选代器，用以存取容器中的元素。\n\n​\t迭代器部分主要由头文件`<utility>`,`<iterator>`和`<memory>`组成。`<utility>`是-一个很小的头文件，它包括了贯穿使用在STL中的几个模板的声明，`<iterator>`中提供 了迭代器使用的许多方法，而对于`<memory>`的描述则十分的困难，它以不同寻常的方式为容器中的元素分配存储空间，同时也为某些算法执行期间产生的临时对象提供机制,`<memory>`中的主要部分是模板类`alocator`,它负责产生所有容器中的默认分配器。\n\n## 2.迭代器的基本原理\n\n- 迭代器是一个“可遍历STL容器内全部或部分元素”的对象\n\n- 迭代器指出容器中的一个特定位置\n\n- 迭代器就如同一个指针\n\n- 迭代器提供对一个容器中的对象的访问方法，并且可以定义了容器中对象的范围\n\n## 3.迭代器的分类\n\n**输入迭代器**:也有叫法称之为“只读迭代器”，它从容器中读取元素，只能一次读入一个元素向前移动，只支持一遍算法，同一个输入迭代器不能两遍遍历一个序列。\n\n**输出迭代器**:也有叫法称之为“只写迭代器”，它往容器中写入元素，只能一次写入一个元素向前移动，只支持一遍算法，同一个输出迭代器不能两遍遍历一个序列。\n\n**正向迭代器**:组合输入送代器和输出迭代器的功能,还可以多次解析一个迭代器指定的位置，可以对一个值进行多次读/写。\n\n**双向达代器**:组合正向迭代器的功能，还可以通过-操作符向后移动位置。\n\n**随机访问送代器**:组合双向送代器的功能，还可以向前向后跳过任意个位置，可以直接访问容器中任何位置的元素。\n\n# ","source":"_posts/【C++】C++STL标准模板库.md","raw":"---\ntitle: 【C++】C++STL标准模板库\ndate: 2019-10-06 10:20:37\ntags: CPlus\ncategories: 学习笔记\n---\n\n\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 一、STL的基本概念\n\n## 1.什么是STL\n\n STL (Standard Template Librany）标准准模板庠是惠普实验室开发的一系列软件的统称。现在主要出现在C++中，但在被引入C++之前该技木就已存在了很长一段吋间了。\n\nSTL的从广义上讲分为三类: algorithm (算法)、container (容器)和iterator (迭代器)，容器和算法通过迭代器可以进行无缝链接。几乎所有的代码都釆用了模板类和模板函数的方式,这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。在C++标准中，STL 被组织为下面的13个尖文件:`<algorithm>`、`<deque>`、`<functional>`、`<iterator>`、`<vector>`、`<list>`、 `<map>`、`<memory>`、`<numerio>`、`<queue>`、`<set>`、\t`<stack>` 和`<utility>`。\n\n![](【C++】C++STL标准模板库/Snipaste_2019-10-06_10-41-56.png)\n\n我们详细的说六大组件：\n\n- 容器(Container)\n- 算法(Algorithm)\n- 迭代器(Iterator)\n- 仿函数(Function object)\n- 适配器(Adaptor)\n- 空间配置器(allocator)\n\n## 2.STL的好处\n\n- STL是C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。\n\n- STL的一个重要特点是数据结构和算法的分离。尽管这是个简单的概念，但是这种分离确实使得STL变得非常通用。\n  例如，在STL 的vector容器中，可以放入元素、 基础数据类型变量、元素的地址;\n  STL的sort()函数可以用来操作vector,list等容器。\n\n- 程序员可以不用思考STL具体的实现过程，只要能够熟综使用STL就OK了。这样他们就可以把精力放在程序开发的别的方面。\n\n- STL 具有高可重用性，高性能，高移植性，跨平台的优点。\n\n    高可重用性: STL 中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。关于模板的知识，已经给大家介绍了。\n\n  高性能:如map可以高效地从十万条记录里面查找出指定的记录，因为map是采用红黑树的变体实现的。\n\n  高移植性:如在项目A上用STL编写的模块，可以直接移植到项目B上。\n\n  跨平台:如用windows的Visual Studio编写的代码可以在Mac OS的XCode上直接运行。\n\n- 了解到STL的这些好处，我们知道STL无疑是最值得C++程序员骄傲的一部分。每一个C++程序员都应该好好学习STL.只有能够熟练使用STL的程序员，才是好的C++程序员。\n\n# 二、容器\n\n## 1.容器\n\n  在实际的开发过程中，数据结构本身的重要性不会逊于操作于数据结构的算法的重要性，当程序中存在着对时间要求很高的部分时，数据结构的选择就显得更加重要。\n\n  经典的数据结构数量有限，但是我们常常重复着一些为了实现向量、链表等结构而编写的代码，这些代码都十分相似，只是为了适应不同数据的变化而在细节上有所出入。STL容器就为我们提供了这样的方便，它允许我们重复利用己有的实现构造自己的特定类型下的数据结构，通过设置-些模板，STL 容器对最常用的数据结构提供了支持，这些模板的参数允许我们指定容器中元素的数据类型，可以将我们许多重复而乏味的工作简化。\n\n​\t容器部分主要由头文件`<vector>`, `<list>`, `<deque>`, `<set>`, `<map>`, `<stack>`和`<queue>`组成。对于常用的一些容器和容器适配器(可以看作由其它容器实现的容器)，可以通过下表总结一:下它们和相应头文件的对应关系。\n\n![](【C++】C++STL标准模板库/Snipaste_2019-10-06_10-41-56.png)\n\n## 2.容器的分类\n\n### 序列式容器(Sequence containers) \n\n每个元素都有固定位置--取决于插入时机和地点，和元素值无关。如：vector、deque、 Iist。\n\n### 关联式容器(Associated containers) \n\n元素位置取决于特定的排序准则，和插入顺序无关。如：sset、multiset、 map、multimapu。\n\n![](【C++】C++STL标准模板库/Snipaste_2019-10-06_14-36-13.png)\n\n## 3.string类\n\n### string类的本质\n\n`string`类本质上其实就是`char*`的容器，是`cahr*`的封装。\n\n### string类的遍历\n\n**使用[]遍历：**\n\n```C++\nstring str = \"string_str\";\nfor (int i = 0; i < str.length(); i++)\n\tcout << str[i];\n```\n\n**使用迭代器遍历：**\n\n```C++\nstring str = \"string_str\";\nfor(string::iteratori=str.begin();i<str.end();i++)\n\tcout <<*i;\n```\n\n<font color=red> 注意这里的`i`是一个指向string::iterator类型的指针。</font>\n\n**使用at()遍历：**\n\n```C++\nstring str = \"string_str\";\nfor (int i = 0; i < str.length(); i++)\n\tcout << str.at(i);\n```\n\n`at()`与`[]`不同的是，当访问发生越界等错误时，`at()`会自动抛出异常，而`[]`不会抛出异常而中断程序。\n\n### string解封成char*\n\nC++为string类提供了一个专门的函数<font color = red> **str.c_str()**</font>，str是string类型的对象，但是需要注意的是`str.c_str()`返回的是一个<font color = red> const char*</font>，不能再被赋值给其他非常量指针，但是我们可以直接将`str.c_str()`当作`char*`来使用，如：`str.c_str()[1]`，即通过`char*`指针访问str中的第二个元素。\n\n### string类中一些常用函数\n\n|      | 函数名                                       | 作用                                                         |\n| ---- | -------------------------------------------- | ------------------------------------------------------------ |\n| 复制 | str.copy(char *buf,int cout)                 | 从字符串str中拷贝cout个字符到char数组buf中                   |\n| 连接 | str.append(string strs)                      | 将字符串strs连接到str之后，支持string和char*                 |\n| 查找 | int str.find(char *strs,int index)           | 从字符串str中的第index索引开始查找strs子串或字符，返回查找到的第一个匹配值的索引，返回的索引也可以使用迭代器来接收 |\n| 替换 | str.replace(int index,int length,char *strs) | 在字符串str中，从index索引开始用strs字符串替换length个长度的子串 |\n| 删除 | str.erase(int index,int length)              | 删除字符出str从index位置开始的length长度的字符               |\n| 插入 | str.insert(int index,char *strs)             | 从str字符串的index位置开始插入字串strs                       |\n\n###  string类中常用算法函数\n\n```C++\nstring str = \"string_str_io_stdsfx.h_iostream\";\ntransform(str.begin(), str.end(), str.begin(), toupper);\ncout << str << endl;\n```\n\ntransform算法包含在`#include <algorithm>`头文件中\n\n**transform算法的使用：**\n\n**原型：**transform(first,last,result,op);\n\nfirst是容器的首迭代器，last为容器的末迭代器，result为存放结果的容器，op为要进行操作的一元函数对象或sturct、class。\n\n**代码解释：**str.begin()返回一个指向str首部位置的迭代器，str.end()返回一个指向str尾部位置的迭代器，因为我们把输出结果继续存放在str中，且迭代器始于容器相联系的，所以存放结果的容器也是str.begin()，而我们对str做的操作是将小写字母装换为大写，C++提供了标准的转换函数,所以操作函数为toupper。\n\n**transform算法的另一个重载形式：**\n\n**原型：**transform(first1,last1,first2,result,binary_op);\n\nfirst1是第一个容器的首迭代 器，last1为第一个容器的末迭代器，first2为第二个容器的首迭代器，result为存放结果的容器，binary_op为要进行操作的二元函数 对象或sturct、class。\n\n需要注意的是，两个容器first1和first2中的元素数量必须相等，否则会抛异常。\n\n## 4.vector容器\n\n- vector是将元素置于一个<font color=red> **动态数组**</font>中加以管理的容器\n- vector支持随机存取元素，支持索引存取（[],at()）和迭代器存取\n- vector在尾部添加和移除元素速度快，在中部和头部速度慢\n- 使用vector容易需要包含`#include<vector>`头文件\n\n### vector常用方法\n\n<table>\n  <tr>\n    <th> </th>\n    <th>函数</th>\n    <th>作用</th>\n  </tr>\n  <tr>\n    <td rowspan=\"4\">读取与赋值</td>\n    <td>front(void)</td>\n    <td>获取容器首元素，既可以作左值也可以作右值</td>\n  </tr>\n  <tr>\n    <td>back(void)</td>\n    <td>获取容器尾元素，既可以作左值也可以作右值</td>\n  </tr>\n  <tr>\n    <td>push_back(T t)</td>\n    <td>在容器的尾部添加元素</td>\n  </tr>\n  <tr>\n    <td>pop_back(T t)</td>\n    <td>删除容器最后一个元素</td> \n  </tr>\n  <tr>\n    <td rowspan=\"4\">只读</td>\n    <td>begin(void)</td>\n    <td>获取容器首部迭代器</td> \n  </tr>\n  <tr>\n    <td>end(void)</td>\n    <td>获取容器尾部迭代器</td> \n  </tr>\n  <tr>\n    <td>rbegin(void)</td>\n    <td>获取逆序首部迭代器，实际指向容器的尾部，只能使用vector&#60int&#62::reverse_iterator逆序迭代器接收</td> \n  </tr>\n  <tr>\n    <td>rend(void)</td>\n    <td>获取逆序尾部部迭代器，实际指向容器的首部，只能使用vector&#60int&#62::reverse_iterator逆序迭代器接收</td> \n  </tr>\n  <tr>\n    <td rowspan=\"2\">删除</td>\n    <td>erase(iterator pos)</td>\n    <td>删除迭代器pos指向位置的元素</td> \n  </tr>\n  <tr>\n    <td>erase(iterator begin,iterator end)</td>\n    <td>从迭代器begin指向位置开始到end指向位置结束，区间删除元素</td> \n  </tr>\n  <tr>\n    <td>插入</td>\n    <td>insert(iterator pos,T t)</td>\n    <td>在pos迭代器指向的位置插入元素t，insert中的迭代器pos只能是begin()或end()否则会报错，似乎不止其他的迭代器</td> \n  </tr>\n    <td>判空</td>\n    <td>empty(void)</td>\n    <td>容器判空</td> \n  </tr>\n</table>\n### Vector浅析\n\nvector的最重要的实现组成其实只有三个指针，上源码：\n\n```c++\n// CLASS TEMPLATE vector\ntemplate<class _Ty,class _Alloc = allocator<_Ty>>\nclass vector : public _Vector_alloc<_Vec_base_types<_Ty, _Alloc>>\n{\t\n    //...\n}\n```\n\n类体这里就省略了，如果仔细看源码就会发现vector的类体里主要实现的大多只是一些供外部调用的函数而已，而vector的最底层的一些实现其实在它的基类中就已经完成了，如`_Vector_alloc`类，而`_Vector_alloc`中也没有包含最重要的三个指针，我们在vector.cpp中搜索`_Myfirst`可以发现，`_Myfirst`,`_Mylast`,`_Myend`三个指针在`_Vector_val`这个类中，而`_Vector_alloc`中包含了对`_Vector_val`的操作。\n\n```c++\n// CLASS TEMPLATE _Vector_val\ntemplate<class _Val_types>\nclass _Vector_val : public _Container_base\n{\t// base class for vector to hold data\npublic:\n\tusing value_type = typename _Val_types::value_type;\n\tusing size_type = typename _Val_types::size_type;\n\tusing difference_type = typename _Val_types::difference_type;\n\tusing pointer = typename _Val_types::pointer;\n\tusing const_pointer = typename _Val_types::const_pointer;\n\tusing reference = value_type&;\n\tusing const_reference = const value_type&;\n\n\t_Vector_val()\n\t\t: _Myfirst(),\n\t\t_Mylast(),\n\t\t_Myend()\n\t\t{\t// initialize values\n\t\t}\n\n\tpointer _Myfirst;\t// pointer to beginning of array\n\tpointer _Mylast;\t// pointer to current end of sequence\n\tpointer _Myend;\t// pointer to end of array\n};\n```\n\n在vector中有两个关键的数字，<font color=red>size与capacity</font>，其中`size=_Mylast-_Myfirst`，`capacity=_Myend-Myfirst`，三个指针指向的内存位置如下：\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210330094505.png)\n\nsize的计算源码：\n\n```c++\n_NODISCARD size_type size() const noexcept\n{\t// return length of sequence\n\treturn (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));\n}\n```\n\ncapacity的计算源码：\n\n```c++\n_NODISCARD size_type capacity() const noexcept\n{\t// return current length of allocated storage\n\treturn (static_cast<size_type>(this->_Myend() - this->_Myfirst()));\n}\n```\n\n我们都知道vector的性能优越，而支撑着vector的优越性能的就是这两数据，size和capacity，size是vector中实际元素的个数，即vector总容量中的已用容量(used部分)，而capacity则是vector初始化时设置的总容量(等于used部分加unsed部分)，C++分配给vector的实际内存总是比定义时的要大一点，这是因为vector占用的内存是一整块连续的内存，预分配多一些内存可以降低vector之后的二次分配时的时间成本。所以capacity>=size，档capacity=size时表示容易已满，若需要继续添加元素则需要整体移动vector，此时花费的成本会较高，所以种情况应尽量避免。\n\n## 5.deque容器\n\n- deque容器是一个双端数组，在双端数组的两端均可以插入和删除元素\n- 使用deque容器需要包头文件`#include<deque>`\n\ndeque容器可以说是vector容器的升级版，deque的用法基本和vector一致，但是deque不仅提供push_back()，pop_back()还提供<font color = red> **push_front()**</font> 和<font color = red> **pop_front()**</font>。\n\n## 6.stack容器\n\n- stack容器是一个栈模型\n- 使用stack容器需要包含头文件`#include<stack>`\n\n### stack常用方法\n\n| 函数      | 作用         |\n| --------- | ------------ |\n| push(T t) | 元素入栈顶   |\n| pop()     | 栈顶元素出栈 |\n| top()     | 获取栈顶元素 |\n\n## 7.queue容器\n\n- queue容器是一个队列模型\n- 使用queue容器需要包含头文件`#include<queue>`\n\n### queue常用方法\n\n| 函数      | 作用                                   |\n| --------- | -------------------------------------- |\n| push(T t) | 元素入队尾                             |\n| pop()     | 队首元素出队                           |\n| front()   | 获取队首元素，既可以作左值也可以作右值 |\n| back()    | 获取队尾元素，既可以作左值也可以作右值 |\n\n## 8.list容器\n\n- list容器是一个双向链表模型，可以高效的进行元素的插入和删除操作\n- list容器不支持随机访问，即不支持[],at()和iterator + n(如：begin()+1)等形式的访问\n- 使用list容器需要包含头文件`#include<list>`\n\nlist容器除了不支持随机访问外，用法和deque容器的用法基本一致，除此之外list容器还提供一个<font color = red> **remove(T t)**</font>函数来根据元素内容删除元素\n\n使用list容器时有一点需要注意<font color = red> **list容器在使用erase删除元素时，遵循左闭右开的原则**</font>，如：\n\n```C++\nlist<int> li;\nfor (int i = 0; i < 5; i++)\n\tli.push_back(i);\nfor (list<int>::iterator it = li.begin(); it != li.end(); it++)\n\tcout << *it;\ncout << endl;\nlist<int>::iterator it1 = li.begin();//it1指向元素0\nlist<int>::iterator it2 = li.begin();\nit2++; it2++; it2++;//此时it2指向元素3\nli.erase(it1, it2);\nfor (list<int>::iterator it = li.begin(); it != li.end(); it++)\n\tcout << *it;\ncout << endl;\n```\n\n**输出结果：**\n\n```\n01234\n34\n```\n\n可以看到erase在删除0-3的元素时删除了0，1，2而没有删除3，即左闭右开。\n\n### list浅析\n\nlist在实现结构上和vector很类似，只是list比vector多了一个`_List_buy`中间层，list的实现的核心组成有两个，`_List_val`和`_List_node`前者主要与数据结构规模和头节点相关，后者主要与数据存储、prev和next相关。上`_List_val`的源码：\n\n```c++\ntemplate<class _Val_types>\nclass _List_val : public _Container_base\n{\t// base class for list to hold data\npublic:\n\tusing _Nodeptr = typename _Val_types::_Nodeptr;\n\n\tusing value_type = typename _Val_types::value_type;\n\tusing size_type = typename _Val_types::size_type;\n\tusing difference_type = typename _Val_types::difference_type;\n\tusing pointer = typename _Val_types::pointer;\n\tusing const_pointer = typename _Val_types::const_pointer;\n\tusing reference = value_type&;\n\tusing const_reference = const value_type&;\n\n\t_List_val()\n\t\t: _Myhead(),\n\t\t_Mysize(0)\n\t\t{\t// initialize data\n\t\t}\n\n\t_Nodeptr _Myhead;\t// pointer to head node\n\tsize_type _Mysize;\t// number of elements\n};\n```\n\n可以看到list中包含了一个指向头节点的指针`_Myhead`，也就是说即使我们创建的一个空list也至少包含一个空的头节点，list使用头节点的目的就是更方便的构建容器，`_Mysize`记录的就是list的当前元素个数。\n\nlist节点_List_node`的底层数据结构是一个结构体：\n\n```c++\ntemplate<class _Value_type,class _Voidptr>\nstruct _List_node\n{\t// list node\n\tusing _Nodeptr = _Rebind_pointer_t<_Voidptr, _List_node>;\n\t_Nodeptr _Next;\t// successor node, or first element if head\n\t_Nodeptr _Prev;\t// predecessor node, or last element if head\n\t_Value_type _Myval;\t// the stored value, unused if head\n\n\t_List_node& operator=(const _List_node&) = delete;\n\n\ttemplate<class _Alloc>\n\tstatic void _Freenode0(_Alloc& _Al, _Nodeptr _Ptr) noexcept\n\t{\n\t\tusing _Alnode = _Rebind_alloc_t<_Alloc, _List_node>;\n\t\tusing _Alnode_traits = allocator_traits<_Alnode>;\n\t\t_Alnode _Node_alloc(_Al);\n\t\t_Alnode_traits::destroy(_Node_alloc, _STD addressof(_Ptr->_Next));\n\t\t_Alnode_traits::destroy(_Node_alloc, _STD addressof(_Ptr->_Prev));\n\t\t_Alnode_traits::deallocate(_Node_alloc, _Ptr, 1);\n\t}\n};\n```\n\n`_List_node`的核心组成就是`_Next`，`_Prev`，`_Myval`，`_Next`是下一个节点的指针，`_Prev`是指向上一个节点的指针，`_Myval`是存储数据的容器。\n\n## 9.priority_queue容器\n\n- `priority_queue`容器是一个具有优先级的队列，又叫优先级队列适配器，分为最大优先级队列和最小优先级队列两种\n\n- priority_queue容器是一种特殊的queue容器，所以也需要包含头文件`#include<queue>`\n\n默认的定义`priority_queue<T> pr`的优先级队列是最大优先级队列，显示定义最小优先级队列：`priority_queue<int,vector<int>,less<int>> pr`，`less`是一个谓词后面再学习，显示定义最大优先级队列：`priority_queue<int,vector<int>,greater<int>> pr`，其中使用`greater`需要包含头文件`#include<functional>`。\n\n`priority_queue`容器的用法基本和`queue`一致，除此之外，`priority_queue`容器提供一个`top()`函数来获取队首元素，而`queue`容器没有这个方法。\n\n**示例：**\n\n```C++\npriority_queue<int,vector<int>,greater<int>> pr;\npr.push(12);\npr.push(4);\npr.push(10);\npr.push(20);\ncout << \"最小元素：\" <<pr.top() << endl;\nwhile (pr.size() > 0)\n{\n\tcout << pr.top() << \",\";\n\tpr.pop();\n}\n```\n\n**输出结果：**\n\n```\n最小元素：4\n4,10,12,20,\n```\n\n## 10.set容器\n\n- `set`是一个<font color=red>**集合**</font>容器，其中所包含的元素是<font color=red>**唯一**</font>的，<font color=red>**集合中的元素按一定的顺序排序**</font>，元素的插入过程是按排序规则插入，所以不能指定位置插入\n- `set`采用红黑树变体的数据结构实现，红黑树属于平衡二叉树，在插入和删除操作上比`vector`容器速度更快\n- `set`容器不支持[]和at()来存取元素\n- <font color=red>**set不支持直接修改容器中的元素**</font>，因为元素是自动排序的，如果希望修改一个元素值，就必须删除这个元素再插入新元素\n- 要使用`set`容器需要包含头文件`#include<set>`\n\n### set容器的基本特性\n\n默认情况下，直接定义的set容器采用最小优先排序，和priority_queue容器恰好相反，`set<T> se`就是隐式的`set<T,less<T>> se`，定义最大优先排序的set容器需要显示定义：`set<T,greater<T>> se`。\n\n我们来看一个例子：\n\n```C++\nset<string,greater<string>> se;//采用最大优先排序\nfor (int i = 0; i < 5; i++)//生成随机字符串元素\n{\n\tint tmp = rand();\n\tstring str = \"\";\n\twhile (str.length()<=3)\n\t{\n\t\tif(tmp >= 97 && tmp <= 122)\n\t\t\tstr += tmp;\n\t\ttmp = rand();\n\t}\n\tse.insert(str);\n}\nse.insert(\"strs\");//插入相同的字符串元素\nse.insert(\"strs\");\nse.insert(\"strs\");\nfor (set<string, greater<string>>::iterator it = se.begin(); it != se.end(); it++)\n\tcout << *it << endl;\n```\n\n**输出结果：**\n\n```\nwqye\nvfep\nstrs\nomsk\nkfnm\ncdsb\n```\n\n可以看到，容器里的字符串确实按照字符串的比较规则按从大到小的顺序排列着，并且无论我们插入多少个相同的元素，在容器内只会存储一个相同的元素值。\n\n值得注意的是：\n\n`set`容器只提供了`insert(T t)`函数来插入元素。\n\n### 自定义元素的排序\n\n自定义类作元素可能会出现类中有多个字段，而我们需要其中的某一个字段来作为关键字在`set`容器中排序，要实现这样的行为，我们就需要用到<font color=red>**仿函数**</font>了。\n\n#### 什么是仿函数？\n\n仿函数实质上就是一个做了`()`重载的结构体，因为重载了`()`使用起来类似函数，所以称之为仿函数。\n\n我们来看一个例子：\n\n```C++\nclass Student\n{\npublic:\n\tstring name;\n\tint age;\n\tbool isStudent;\n\tStudent(const string name, const int age, const bool isStudent)\n\t{\n\t\tthis->age = age;\n\t\tthis->name = name;\n\t\tthis->isStudent = isStudent;\n\t}\n};\nstruct AgeSort//仿函数\n{\n\tbool operator()(const Student &lift, const Student &right)\n\t{\n\t\treturn (lift.age < right.age);\n\t}\n};\nint main()\n{\n\tset<Student, AgeSort> se;\n\tStudent s1(\"Alian\", 23, true);\n\tStudent s2(\"Blank\", 20, true);\n\tStudent s3(\"Cary\", 43, false);\n\tStudent s4(\"Davel\", 23, true);\n\tse.insert(s1); se.insert(s2);\n\tse.insert(s3); se.insert(s4);\n\tfor (set<Student, AgeSort>::iterator it = se.begin(); it != se.end(); it++)\n\t\tcout << it->name << \"\\t\" << it->age << \"\\t\" << it->isStudent << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**输出结果：**\n\n```\nBlank   20      1\nAlian   23      1\nCary    43      0\n```\n\n其中`AgeSort`就是仿函数，它的比较关键字是`Student.age`，所以`set`容器对象se会以age作为排序关键字，其实我们之前使用的`less<>`和`greater<>`也是反函数，只不过是C++预定义好的仿函数。\n\n细心的朋友可能会发现，我们插入的s4对象居然不再容器里！！！这是因为set容器中的元素具有唯一性，而set容器是通过关键字来识别元素的，所当碰到关键字相同的元素时，set只会存储一个元素。\n\n那么这种情况该怎么解决呢？答案是set容器没有办法解决这种情况，如果有出现这种情况，就不能使用set容器而改用multiset容器。\n\n在后面的算法模块我们详细介绍仿函数。\n\n### set常用函数\n\n| 函数             | 作用                                                         |\n| ---------------- | ------------------------------------------------------------ |\n| find(T t)        | 查找元素t，返回指向t元素的迭代器，查找失败返回指向set.end()的迭代器 |\n| count(T t)       | 返回容器中元素t的个数，值要么是0，要么是1                    |\n| lower_bound(T t) | 返回一个指向>=t元素的迭代器，如果t存在则指向t，如果t不存在则指向t后面的一个元素 |\n| upper_bound(T t) | 返回一个指向>t元素的迭代器，即t元素后面的一个元素            |\n| equal_range(T t) | 返回一个包含两个set类型的迭代器的对组pair<set<T>::iterator,set<T>::iterator>第一个迭代器指向t元素，第二个迭代器指向t后面的一个元素，如果t不存在，则两个迭代器都指向t后面的一个元素 |\n\n### <font color=blue> 小知识</font>\n\n<font color=blue> 事实上容器中的`insert`函数是有返回值的，`insert`的返回值是一个对组(pair)类型的泛型`pair<set<T>::iterator, bool>`的对象，`pair`是一个只有两个字段的模板，我们可以直接定义`pair<set<T>::iterator, bool>`类型对象来接收`insert`函数的返回值，如：</font>\n\n```C++\npair<set<Student,AgeSort>::iterator, bool> pait=se.insert(s1);\n```\n\n<font color=blue> 我们可以通过`pair.first`和`pair.second`来访问对组中的两个元素，通过`pair.first`来访问对组中的第一个元素`set<Student,AgeSort>::iterator`类型的迭代器，通过`pair.first->first`，和`pair.first->second`可以访问迭代器所指向的容器元素，我们通过`pair.second`来访问对组中的第二个元素，bool型的元素记录的是insert函数插入是否成功，如果插入成功则记录true，否则记录false。</font>\n\n## 11.multiset容器\n\n- `multiset`容器可以说是set容器的升级版，multiset容器支持多个相同键值的元素的存储，所以要使用`multiset`需要包含头文件`#include<set>`\n\nmultiset的用法和set一致。\n\n## 12.map容器\n\n- `map`是标准的关联式容器，一个`map`元素是一个键值对(key,value),`map`提供基于键值的快速检索能力\n- `map`中<font color=red>` key`值是唯一的</font>\n- `map`容器中的元素也是按一定顺序排列的，元素插入过程是按排序规则插入的，所以不能指定位置插入\n- `map`容器的具体实现也是采用红黑二叉树变体的平衡二叉树的数据结构，在插入和删除的操作上比`vector`更快\n- 与`set`不同的是`map`支持直接存取`key`值对应的`value`，也支持[]操作符\n- 要使用`map`容器就需要包含头文件`#include<map>`\n\n### map的元素插入\n\n```C++\nint main()\n{\n\tmap<int, string> ma;\n\t//方法一\n\tma.insert(pair<int, string>(1, \"pair\"));\n\tma.insert(pair<int, string>(1, \"pair_02\"));\n\t//方法二\n\tma.insert(make_pair(2, \"make_pair\"));\n\tma.insert(make_pair(2, \"make_pair_02\"));\n\t//方法三\n\tma.insert(map<int, string>::value_type(3, \"value_type\"));\n\tma.insert(map<int, string>::value_type(3, \"value_type_02\"));\n\t//方法四\n\tma[4] = \"map\";\n\tma[4] = \"map_02\";\n\tfor (map<int, string>::iterator it = ma.begin(); it != ma.end(); it++)\n\t\tcout << it->first << \"\\t\" << it->second << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**输出结果：**\n\n```\n1       pair\n2       make_pair\n3       value_type\n4       map_02\n```\n\n上面四种方法都可以向map容器里添加元素，但是四者中也有一些微小的区别，前面三种方法在插入相同键值时，只会保存第一存储的结果，之后插入相同键值的元素时都会插入失败，而第四种方法则是后面赋值的元素覆盖前面赋值的元素。\n\nmap似乎没办法来指定是从大到小排序或是从小到大排序\n\nmap除了元素的形式不同，在其他方面map的用法基本和set一致\n\n## 13.multimap容器\n\n`multimap`容器和`multiset`容器一样，是`map`容器的升级版，支持一个键对应多个值，所以`multimap`的一个重要应用场景就是数据分组。\n\n## 14.容器在使用过程必须要注意的地方\n\n<font color=red> 因为在将元素添加到容器里时，C++执行的是容器的默认的拷贝构造函数，将元素拷贝到容器里，这个过程是一个浅拷贝，既然是浅拷贝就会面临浅拷贝的两次内存释放的问题，尤其是类元素，所以在添加一些具有指针字段的元素到容器里时，一定在类里定义一个深拷贝的拷贝构造函数和=的重载函数。</font>\n\n## 15.各个容器的比较\n\n|              | vector   | deque    | list     | set    | multiset | map         | multimap    |\n| ------------ | -------- | -------- | -------- | ------ | -------- | ----------- | ----------- |\n| 内存结构     | 单端数组 | 双端数组 | 双向链表 | 二叉树 | 二叉树   | 二叉树      | 二叉树      |\n| 随机存取     | 是       | 是       | 否       | 否     | 否       | 对key而言是 | 否          |\n| 元素检索     | 慢       | 慢       | 非常慢   | 快     | 快       | 对key而言快 | 对key而言快 |\n| 快速安插移除 | 尾端     | 头尾两端 | 任何位置 | -      | -        | -           | -           |\n\n# 三、算法\n\n## 1.算法\n\n​\t函数库对数据类型的选择对其可重用性起着至关重要的作用。举例来说，一个求方根的函数，在使用浮点数作为其参数类型的情况下的可重用性肯定比使用整型作为它的参数类性要高。而C++通过模板的机制允许推迟对某些类型的选择，直到真正想使用模板或者说对模板进行特化的时候，STL就利用了这一点提供了相当多的有用算法。它是在一个有效的框架中完成这些算法的--可以将所有的类型划分为少数的几类，然后就可以在模版的参数中使用一种类型替换掉同一种类中的其他类型。\n\n  STL提供了大约100个实现算法的模版函数，比如算法for_ each 将为指定序列中的每一个元素调用指定的函数，stable_ _sort 以你所指定的规则对序列进行稳定性排序等等，这样一-来,只要熟悉了STL之后，许多代码可以被大大的化简，只需要通过调用一-两个算法模板，就可以完成所需要的功能并大大地提升效率。\n\n  算法部分主要由头文件`<algorithm>`, `<numeric>`和`<functional>`组成。`<algorithm>`是所 有STL头文件中最大的一个(尽管它很好理解)，它是由一大堆模版函数组成的，可以认为每个函数在很大程度上都是独立的，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等等。`<numeric>`体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。`<functional>`中则定义了一些模板类，用以声明函数对象。\n\n## 2.算法的分类\n\n### 非可变序列算法\n\n计数算法：count,count_if等 \n\n搜索算法：search,find,find_if,find_list_of等\n\n比较算法：equal,mismatch,lexicographical_compare等\n\n### 可变排序算法\n\n删除算法：remove,remove_if,remove_copy等\n\n修改算法：for_each,transform等\n\n排序算法：sort,stable_sort,partial_sort等\n\n## 3.仿函数\n\n\n\n## 4.一些常用的算法模板\n\n### find算法\n\n**原型:**`iterator find(iterator begin,iterator end,T t)`\n\n在容器的begin迭代器所指向的位置开始到end所指向的位置结束，查找元素t，如果找到了，则返回指向t的迭代器。\n\n# 四、迭代器\n\n## 1.迭代器\n\n​\t迭代器从作用上来说是最基本的部分，可是理解起来比前两者都要费力一些。软件设计有一个基本原则，所有的问题都可以通过引进一个间接层来简化，这种简化在 STL中就是用迭代器来完成的。概括来说，迭代器在STL中用来将算法和容器联系起来，起着一种黏和剂的作用。几乎STL提供的所有算法都是通过送代器存取元素序列进行工作的，每一个容器都定义了其本身所专有的选代器，用以存取容器中的元素。\n\n​\t迭代器部分主要由头文件`<utility>`,`<iterator>`和`<memory>`组成。`<utility>`是-一个很小的头文件，它包括了贯穿使用在STL中的几个模板的声明，`<iterator>`中提供 了迭代器使用的许多方法，而对于`<memory>`的描述则十分的困难，它以不同寻常的方式为容器中的元素分配存储空间，同时也为某些算法执行期间产生的临时对象提供机制,`<memory>`中的主要部分是模板类`alocator`,它负责产生所有容器中的默认分配器。\n\n## 2.迭代器的基本原理\n\n- 迭代器是一个“可遍历STL容器内全部或部分元素”的对象\n\n- 迭代器指出容器中的一个特定位置\n\n- 迭代器就如同一个指针\n\n- 迭代器提供对一个容器中的对象的访问方法，并且可以定义了容器中对象的范围\n\n## 3.迭代器的分类\n\n**输入迭代器**:也有叫法称之为“只读迭代器”，它从容器中读取元素，只能一次读入一个元素向前移动，只支持一遍算法，同一个输入迭代器不能两遍遍历一个序列。\n\n**输出迭代器**:也有叫法称之为“只写迭代器”，它往容器中写入元素，只能一次写入一个元素向前移动，只支持一遍算法，同一个输出迭代器不能两遍遍历一个序列。\n\n**正向迭代器**:组合输入送代器和输出迭代器的功能,还可以多次解析一个迭代器指定的位置，可以对一个值进行多次读/写。\n\n**双向达代器**:组合正向迭代器的功能，还可以通过-操作符向后移动位置。\n\n**随机访问送代器**:组合双向送代器的功能，还可以向前向后跳过任意个位置，可以直接访问容器中任何位置的元素。\n\n# ","slug":"【C++】C++STL标准模板库","published":1,"updated":"2021-03-30T03:19:55.514Z","_id":"ckk9hocbh003edwr73uj5h7zl","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h1 id=\"一、STL的基本概念\"><a href=\"#一、STL的基本概念\" class=\"headerlink\" title=\"一、STL的基本概念\"></a>一、STL的基本概念</h1><h2 id=\"1-什么是STL\"><a href=\"#1-什么是STL\" class=\"headerlink\" title=\"1.什么是STL\"></a>1.什么是STL</h2><p> STL (Standard Template Librany）标准准模板庠是惠普实验室开发的一系列软件的统称。现在主要出现在C++中，但在被引入C++之前该技木就已存在了很长一段吋间了。</p>\n<p>STL的从广义上讲分为三类: algorithm (算法)、container (容器)和iterator (迭代器)，容器和算法通过迭代器可以进行无缝链接。几乎所有的代码都釆用了模板类和模板函数的方式,这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。在C++标准中，STL 被组织为下面的13个尖文件:<code>&lt;algorithm&gt;</code>、<code>&lt;deque&gt;</code>、<code>&lt;functional&gt;</code>、<code>&lt;iterator&gt;</code>、<code>&lt;vector&gt;</code>、<code>&lt;list&gt;</code>、 <code>&lt;map&gt;</code>、<code>&lt;memory&gt;</code>、<code>&lt;numerio&gt;</code>、<code>&lt;queue&gt;</code>、<code>&lt;set&gt;</code>、    <code>&lt;stack&gt;</code> 和<code>&lt;utility&gt;</code>。</p>\n<p><img src=\"/2019/10/06/%E3%80%90C++%E3%80%91C++STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/Snipaste_2019-10-06_10-41-56.png\"></p>\n<p>我们详细的说六大组件：</p>\n<ul>\n<li>容器(Container)</li>\n<li>算法(Algorithm)</li>\n<li>迭代器(Iterator)</li>\n<li>仿函数(Function object)</li>\n<li>适配器(Adaptor)</li>\n<li>空间配置器(allocator)</li>\n</ul>\n<h2 id=\"2-STL的好处\"><a href=\"#2-STL的好处\" class=\"headerlink\" title=\"2.STL的好处\"></a>2.STL的好处</h2><ul>\n<li><p>STL是C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。</p>\n</li>\n<li><p>STL的一个重要特点是数据结构和算法的分离。尽管这是个简单的概念，但是这种分离确实使得STL变得非常通用。<br>例如，在STL 的vector容器中，可以放入元素、 基础数据类型变量、元素的地址;<br>STL的sort()函数可以用来操作vector,list等容器。</p>\n</li>\n<li><p>程序员可以不用思考STL具体的实现过程，只要能够熟综使用STL就OK了。这样他们就可以把精力放在程序开发的别的方面。</p>\n</li>\n<li><p>STL 具有高可重用性，高性能，高移植性，跨平台的优点。</p>\n<p>  高可重用性: STL 中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。关于模板的知识，已经给大家介绍了。</p>\n<p>高性能:如map可以高效地从十万条记录里面查找出指定的记录，因为map是采用红黑树的变体实现的。</p>\n<p>高移植性:如在项目A上用STL编写的模块，可以直接移植到项目B上。</p>\n<p>跨平台:如用windows的Visual Studio编写的代码可以在Mac OS的XCode上直接运行。</p>\n</li>\n<li><p>了解到STL的这些好处，我们知道STL无疑是最值得C++程序员骄傲的一部分。每一个C++程序员都应该好好学习STL.只有能够熟练使用STL的程序员，才是好的C++程序员。</p>\n</li>\n</ul>\n<h1 id=\"二、容器\"><a href=\"#二、容器\" class=\"headerlink\" title=\"二、容器\"></a>二、容器</h1><h2 id=\"1-容器\"><a href=\"#1-容器\" class=\"headerlink\" title=\"1.容器\"></a>1.容器</h2><p>  在实际的开发过程中，数据结构本身的重要性不会逊于操作于数据结构的算法的重要性，当程序中存在着对时间要求很高的部分时，数据结构的选择就显得更加重要。</p>\n<p>  经典的数据结构数量有限，但是我们常常重复着一些为了实现向量、链表等结构而编写的代码，这些代码都十分相似，只是为了适应不同数据的变化而在细节上有所出入。STL容器就为我们提供了这样的方便，它允许我们重复利用己有的实现构造自己的特定类型下的数据结构，通过设置-些模板，STL 容器对最常用的数据结构提供了支持，这些模板的参数允许我们指定容器中元素的数据类型，可以将我们许多重复而乏味的工作简化。</p>\n<p>​    容器部分主要由头文件<code>&lt;vector&gt;</code>, <code>&lt;list&gt;</code>, <code>&lt;deque&gt;</code>, <code>&lt;set&gt;</code>, <code>&lt;map&gt;</code>, <code>&lt;stack&gt;</code>和<code>&lt;queue&gt;</code>组成。对于常用的一些容器和容器适配器(可以看作由其它容器实现的容器)，可以通过下表总结一:下它们和相应头文件的对应关系。</p>\n<p><img src=\"/2019/10/06/%E3%80%90C++%E3%80%91C++STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/Snipaste_2019-10-06_10-41-56.png\"></p>\n<h2 id=\"2-容器的分类\"><a href=\"#2-容器的分类\" class=\"headerlink\" title=\"2.容器的分类\"></a>2.容器的分类</h2><h3 id=\"序列式容器-Sequence-containers\"><a href=\"#序列式容器-Sequence-containers\" class=\"headerlink\" title=\"序列式容器(Sequence containers)\"></a>序列式容器(Sequence containers)</h3><p>每个元素都有固定位置–取决于插入时机和地点，和元素值无关。如：vector、deque、 Iist。</p>\n<h3 id=\"关联式容器-Associated-containers\"><a href=\"#关联式容器-Associated-containers\" class=\"headerlink\" title=\"关联式容器(Associated containers)\"></a>关联式容器(Associated containers)</h3><p>元素位置取决于特定的排序准则，和插入顺序无关。如：sset、multiset、 map、multimapu。</p>\n<p><img src=\"/2019/10/06/%E3%80%90C++%E3%80%91C++STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/Snipaste_2019-10-06_14-36-13.png\"></p>\n<h2 id=\"3-string类\"><a href=\"#3-string类\" class=\"headerlink\" title=\"3.string类\"></a>3.string类</h2><h3 id=\"string类的本质\"><a href=\"#string类的本质\" class=\"headerlink\" title=\"string类的本质\"></a>string类的本质</h3><p><code>string</code>类本质上其实就是<code>char*</code>的容器，是<code>cahr*</code>的封装。</p>\n<h3 id=\"string类的遍历\"><a href=\"#string类的遍历\" class=\"headerlink\" title=\"string类的遍历\"></a>string类的遍历</h3><p><strong>使用[]遍历：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-built_in\">string</span> str = <span class=\"hljs-string\">&quot;string_str&quot;</span>;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; str.length(); i++)<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; str[i];<br></code></pre></td></tr></table></figure>\n<p><strong>使用迭代器遍历：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-built_in\">string</span> str = <span class=\"hljs-string\">&quot;string_str&quot;</span>;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-built_in\">string</span>::iteratori=str.begin();i&lt;str.end();i++)<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt;*i;<br></code></pre></td></tr></table></figure>\n<p><font color=\"red\"> 注意这里的<code>i</code>是一个指向string::iterator类型的指针。</font></p>\n<p><strong>使用at()遍历：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-built_in\">string</span> str = <span class=\"hljs-string\">&quot;string_str&quot;</span>;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; str.length(); i++)<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; str.at(i);<br></code></pre></td></tr></table></figure>\n<p><code>at()</code>与<code>[]</code>不同的是，当访问发生越界等错误时，<code>at()</code>会自动抛出异常，而<code>[]</code>不会抛出异常而中断程序。</p>\n<h3 id=\"string解封成char\"><a href=\"#string解封成char\" class=\"headerlink\" title=\"string解封成char*\"></a>string解封成char*</h3><p>C++为string类提供了一个专门的函数<font color=\"red\"> <strong>str.c_str()</strong></font>，str是string类型的对象，但是需要注意的是<code>str.c_str()</code>返回的是一个<font color=\"red\"> const char*</font>，不能再被赋值给其他非常量指针，但是我们可以直接将<code>str.c_str()</code>当作<code>char*</code>来使用，如：<code>str.c_str()[1]</code>，即通过<code>char*</code>指针访问str中的第二个元素。</p>\n<h3 id=\"string类中一些常用函数\"><a href=\"#string类中一些常用函数\" class=\"headerlink\" title=\"string类中一些常用函数\"></a>string类中一些常用函数</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>函数名</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>复制</td>\n<td>str.copy(char *buf,int cout)</td>\n<td>从字符串str中拷贝cout个字符到char数组buf中</td>\n</tr>\n<tr>\n<td>连接</td>\n<td>str.append(string strs)</td>\n<td>将字符串strs连接到str之后，支持string和char*</td>\n</tr>\n<tr>\n<td>查找</td>\n<td>int str.find(char *strs,int index)</td>\n<td>从字符串str中的第index索引开始查找strs子串或字符，返回查找到的第一个匹配值的索引，返回的索引也可以使用迭代器来接收</td>\n</tr>\n<tr>\n<td>替换</td>\n<td>str.replace(int index,int length,char *strs)</td>\n<td>在字符串str中，从index索引开始用strs字符串替换length个长度的子串</td>\n</tr>\n<tr>\n<td>删除</td>\n<td>str.erase(int index,int length)</td>\n<td>删除字符出str从index位置开始的length长度的字符</td>\n</tr>\n<tr>\n<td>插入</td>\n<td>str.insert(int index,char *strs)</td>\n<td>从str字符串的index位置开始插入字串strs</td>\n</tr>\n</tbody></table>\n<h3 id=\"string类中常用算法函数\"><a href=\"#string类中常用算法函数\" class=\"headerlink\" title=\"string类中常用算法函数\"></a>string类中常用算法函数</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-built_in\">string</span> str = <span class=\"hljs-string\">&quot;string_str_io_stdsfx.h_iostream&quot;</span>;<br>transform(str.begin(), str.end(), str.begin(), <span class=\"hljs-built_in\">toupper</span>);<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; str &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br></code></pre></td></tr></table></figure>\n<p>transform算法包含在<code>#include &lt;algorithm&gt;</code>头文件中</p>\n<p><strong>transform算法的使用：</strong></p>\n<p><strong>原型：</strong>transform(first,last,result,op);</p>\n<p>first是容器的首迭代器，last为容器的末迭代器，result为存放结果的容器，op为要进行操作的一元函数对象或sturct、class。</p>\n<p><strong>代码解释：</strong>str.begin()返回一个指向str首部位置的迭代器，str.end()返回一个指向str尾部位置的迭代器，因为我们把输出结果继续存放在str中，且迭代器始于容器相联系的，所以存放结果的容器也是str.begin()，而我们对str做的操作是将小写字母装换为大写，C++提供了标准的转换函数,所以操作函数为toupper。</p>\n<p><strong>transform算法的另一个重载形式：</strong></p>\n<p><strong>原型：</strong>transform(first1,last1,first2,result,binary_op);</p>\n<p>first1是第一个容器的首迭代 器，last1为第一个容器的末迭代器，first2为第二个容器的首迭代器，result为存放结果的容器，binary_op为要进行操作的二元函数 对象或sturct、class。</p>\n<p>需要注意的是，两个容器first1和first2中的元素数量必须相等，否则会抛异常。</p>\n<h2 id=\"4-vector容器\"><a href=\"#4-vector容器\" class=\"headerlink\" title=\"4.vector容器\"></a>4.vector容器</h2><ul>\n<li>vector是将元素置于一个<font color=\"red\"> <strong>动态数组</strong></font>中加以管理的容器</li>\n<li>vector支持随机存取元素，支持索引存取（[],at()）和迭代器存取</li>\n<li>vector在尾部添加和移除元素速度快，在中部和头部速度慢</li>\n<li>使用vector容易需要包含<code>#include&lt;vector&gt;</code>头文件</li>\n</ul>\n<h3 id=\"vector常用方法\"><a href=\"#vector常用方法\" class=\"headerlink\" title=\"vector常用方法\"></a>vector常用方法</h3><table>\n  <tr>\n    <th> </th>\n    <th>函数</th>\n    <th>作用</th>\n  </tr>\n  <tr>\n    <td rowspan=\"4\">读取与赋值</td>\n    <td>front(void)</td>\n    <td>获取容器首元素，既可以作左值也可以作右值</td>\n  </tr>\n  <tr>\n    <td>back(void)</td>\n    <td>获取容器尾元素，既可以作左值也可以作右值</td>\n  </tr>\n  <tr>\n    <td>push_back(T t)</td>\n    <td>在容器的尾部添加元素</td>\n  </tr>\n  <tr>\n    <td>pop_back(T t)</td>\n    <td>删除容器最后一个元素</td> \n  </tr>\n  <tr>\n    <td rowspan=\"4\">只读</td>\n    <td>begin(void)</td>\n    <td>获取容器首部迭代器</td> \n  </tr>\n  <tr>\n    <td>end(void)</td>\n    <td>获取容器尾部迭代器</td> \n  </tr>\n  <tr>\n    <td>rbegin(void)</td>\n    <td>获取逆序首部迭代器，实际指向容器的尾部，只能使用vector&#60int&#62::reverse_iterator逆序迭代器接收</td> \n  </tr>\n  <tr>\n    <td>rend(void)</td>\n    <td>获取逆序尾部部迭代器，实际指向容器的首部，只能使用vector&#60int&#62::reverse_iterator逆序迭代器接收</td> \n  </tr>\n  <tr>\n    <td rowspan=\"2\">删除</td>\n    <td>erase(iterator pos)</td>\n    <td>删除迭代器pos指向位置的元素</td> \n  </tr>\n  <tr>\n    <td>erase(iterator begin,iterator end)</td>\n    <td>从迭代器begin指向位置开始到end指向位置结束，区间删除元素</td> \n  </tr>\n  <tr>\n    <td>插入</td>\n    <td>insert(iterator pos,T t)</td>\n    <td>在pos迭代器指向的位置插入元素t，insert中的迭代器pos只能是begin()或end()否则会报错，似乎不止其他的迭代器</td> \n  </tr>\n    <td>判空</td>\n    <td>empty(void)</td>\n    <td>容器判空</td> \n  \n</table>\n### Vector浅析\n\n<p>vector的最重要的实现组成其实只有三个指针，上源码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// CLASS TEMPLATE vector</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> _<span class=\"hljs-title\">Ty</span>,<span class=\"hljs-keyword\">class</span> _<span class=\"hljs-title\">Alloc</span> =</span> allocator&lt;_Ty&gt;&gt;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">vector</span> :</span> <span class=\"hljs-keyword\">public</span> _Vector_alloc&lt;_Vec_base_types&lt;_Ty, _Alloc&gt;&gt;<br>&#123;\t<br>    <span class=\"hljs-comment\">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>类体这里就省略了，如果仔细看源码就会发现vector的类体里主要实现的大多只是一些供外部调用的函数而已，而vector的最底层的一些实现其实在它的基类中就已经完成了，如<code>_Vector_alloc</code>类，而<code>_Vector_alloc</code>中也没有包含最重要的三个指针，我们在vector.cpp中搜索<code>_Myfirst</code>可以发现，<code>_Myfirst</code>,<code>_Mylast</code>,<code>_Myend</code>三个指针在<code>_Vector_val</code>这个类中，而<code>_Vector_alloc</code>中包含了对<code>_Vector_val</code>的操作。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// CLASS TEMPLATE _Vector_val</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> _<span class=\"hljs-title\">Val_types</span>&gt;</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> _<span class=\"hljs-title\">Vector_val</span> :</span> <span class=\"hljs-keyword\">public</span> _Container_base<br>&#123;\t<span class=\"hljs-comment\">// base class for vector to hold data</span><br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-keyword\">using</span> value_type = <span class=\"hljs-keyword\">typename</span> _Val_types::value_type;<br>\t<span class=\"hljs-keyword\">using</span> size_type = <span class=\"hljs-keyword\">typename</span> _Val_types::size_type;<br>\t<span class=\"hljs-keyword\">using</span> difference_type = <span class=\"hljs-keyword\">typename</span> _Val_types::difference_type;<br>\t<span class=\"hljs-keyword\">using</span> pointer = <span class=\"hljs-keyword\">typename</span> _Val_types::pointer;<br>\t<span class=\"hljs-keyword\">using</span> const_pointer = <span class=\"hljs-keyword\">typename</span> _Val_types::const_pointer;<br>\t<span class=\"hljs-keyword\">using</span> reference = value_type&amp;;<br>\t<span class=\"hljs-keyword\">using</span> const_reference = <span class=\"hljs-keyword\">const</span> value_type&amp;;<br><br>\t_Vector_val()<br>\t\t: _Myfirst(),<br>\t\t_Mylast(),<br>\t\t_Myend()<br>\t\t&#123;\t<span class=\"hljs-comment\">// initialize values</span><br>\t\t&#125;<br><br>\tpointer _Myfirst;\t<span class=\"hljs-comment\">// pointer to beginning of array</span><br>\tpointer _Mylast;\t<span class=\"hljs-comment\">// pointer to current end of sequence</span><br>\tpointer _Myend;\t<span class=\"hljs-comment\">// pointer to end of array</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>在vector中有两个关键的数字，<font color=\"red\">size与capacity</font>，其中<code>size=_Mylast-_Myfirst</code>，<code>capacity=_Myend-Myfirst</code>，三个指针指向的内存位置如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210330094505.png\"></p>\n<p>size的计算源码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">_NODISCARD size_type <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">noexcept</span></span><br><span class=\"hljs-function\"></span>&#123;\t<span class=\"hljs-comment\">// return length of sequence</span><br>\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-keyword\">static_cast</span>&lt;size_type&gt;(<span class=\"hljs-keyword\">this</span>-&gt;_Mylast() - <span class=\"hljs-keyword\">this</span>-&gt;_Myfirst()));<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>capacity的计算源码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">_NODISCARD size_type <span class=\"hljs-title\">capacity</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">noexcept</span></span><br><span class=\"hljs-function\"></span>&#123;\t<span class=\"hljs-comment\">// return current length of allocated storage</span><br>\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-keyword\">static_cast</span>&lt;size_type&gt;(<span class=\"hljs-keyword\">this</span>-&gt;_Myend() - <span class=\"hljs-keyword\">this</span>-&gt;_Myfirst()));<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>我们都知道vector的性能优越，而支撑着vector的优越性能的就是这两数据，size和capacity，size是vector中实际元素的个数，即vector总容量中的已用容量(used部分)，而capacity则是vector初始化时设置的总容量(等于used部分加unsed部分)，C++分配给vector的实际内存总是比定义时的要大一点，这是因为vector占用的内存是一整块连续的内存，预分配多一些内存可以降低vector之后的二次分配时的时间成本。所以capacity&gt;=size，档capacity=size时表示容易已满，若需要继续添加元素则需要整体移动vector，此时花费的成本会较高，所以种情况应尽量避免。</p>\n<h2 id=\"5-deque容器\"><a href=\"#5-deque容器\" class=\"headerlink\" title=\"5.deque容器\"></a>5.deque容器</h2><ul>\n<li>deque容器是一个双端数组，在双端数组的两端均可以插入和删除元素</li>\n<li>使用deque容器需要包头文件<code>#include&lt;deque&gt;</code></li>\n</ul>\n<p>deque容器可以说是vector容器的升级版，deque的用法基本和vector一致，但是deque不仅提供push_back()，pop_back()还提供<font color=\"red\"> <strong>push_front()</strong></font> 和<font color=\"red\"> <strong>pop_front()</strong></font>。</p>\n<h2 id=\"6-stack容器\"><a href=\"#6-stack容器\" class=\"headerlink\" title=\"6.stack容器\"></a>6.stack容器</h2><ul>\n<li>stack容器是一个栈模型</li>\n<li>使用stack容器需要包含头文件<code>#include&lt;stack&gt;</code></li>\n</ul>\n<h3 id=\"stack常用方法\"><a href=\"#stack常用方法\" class=\"headerlink\" title=\"stack常用方法\"></a>stack常用方法</h3><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>push(T t)</td>\n<td>元素入栈顶</td>\n</tr>\n<tr>\n<td>pop()</td>\n<td>栈顶元素出栈</td>\n</tr>\n<tr>\n<td>top()</td>\n<td>获取栈顶元素</td>\n</tr>\n</tbody></table>\n<h2 id=\"7-queue容器\"><a href=\"#7-queue容器\" class=\"headerlink\" title=\"7.queue容器\"></a>7.queue容器</h2><ul>\n<li>queue容器是一个队列模型</li>\n<li>使用queue容器需要包含头文件<code>#include&lt;queue&gt;</code></li>\n</ul>\n<h3 id=\"queue常用方法\"><a href=\"#queue常用方法\" class=\"headerlink\" title=\"queue常用方法\"></a>queue常用方法</h3><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>push(T t)</td>\n<td>元素入队尾</td>\n</tr>\n<tr>\n<td>pop()</td>\n<td>队首元素出队</td>\n</tr>\n<tr>\n<td>front()</td>\n<td>获取队首元素，既可以作左值也可以作右值</td>\n</tr>\n<tr>\n<td>back()</td>\n<td>获取队尾元素，既可以作左值也可以作右值</td>\n</tr>\n</tbody></table>\n<h2 id=\"8-list容器\"><a href=\"#8-list容器\" class=\"headerlink\" title=\"8.list容器\"></a>8.list容器</h2><ul>\n<li>list容器是一个双向链表模型，可以高效的进行元素的插入和删除操作</li>\n<li>list容器不支持随机访问，即不支持[],at()和iterator + n(如：begin()+1)等形式的访问</li>\n<li>使用list容器需要包含头文件<code>#include&lt;list&gt;</code></li>\n</ul>\n<p>list容器除了不支持随机访问外，用法和deque容器的用法基本一致，除此之外list容器还提供一个<font color=\"red\"> <strong>remove(T t)</strong></font>函数来根据元素内容删除元素</p>\n<p>使用list容器时有一点需要注意<font color=\"red\"> <strong>list容器在使用erase删除元素时，遵循左闭右开的原则</strong></font>，如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-built_in\">list</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; li;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">5</span>; i++)<br>\tli.push_back(i);<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">list</span>&lt;<span class=\"hljs-keyword\">int</span>&gt;::iterator it = li.begin(); it != li.end(); it++)<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; *it;<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">list</span>&lt;<span class=\"hljs-keyword\">int</span>&gt;::iterator it1 = li.begin();<span class=\"hljs-comment\">//it1指向元素0</span><br><span class=\"hljs-built_in\">list</span>&lt;<span class=\"hljs-keyword\">int</span>&gt;::iterator it2 = li.begin();<br>it2++; it2++; it2++;<span class=\"hljs-comment\">//此时it2指向元素3</span><br>li.erase(it1, it2);<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">list</span>&lt;<span class=\"hljs-keyword\">int</span>&gt;::iterator it = li.begin(); it != li.end(); it++)<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; *it;<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br></code></pre></td></tr></table></figure>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">01234<br>34<br></code></pre></td></tr></table></figure>\n<p>可以看到erase在删除0-3的元素时删除了0，1，2而没有删除3，即左闭右开。</p>\n<h3 id=\"list浅析\"><a href=\"#list浅析\" class=\"headerlink\" title=\"list浅析\"></a>list浅析</h3><p>list在实现结构上和vector很类似，只是list比vector多了一个<code>_List_buy</code>中间层，list的实现的核心组成有两个，<code>_List_val</code>和<code>_List_node</code>前者主要与数据结构规模和头节点相关，后者主要与数据存储、prev和next相关。上<code>_List_val</code>的源码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> _<span class=\"hljs-title\">Val_types</span>&gt;</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> _<span class=\"hljs-title\">List_val</span> :</span> <span class=\"hljs-keyword\">public</span> _Container_base<br>&#123;\t<span class=\"hljs-comment\">// base class for list to hold data</span><br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-keyword\">using</span> _Nodeptr = <span class=\"hljs-keyword\">typename</span> _Val_types::_Nodeptr;<br><br>\t<span class=\"hljs-keyword\">using</span> value_type = <span class=\"hljs-keyword\">typename</span> _Val_types::value_type;<br>\t<span class=\"hljs-keyword\">using</span> size_type = <span class=\"hljs-keyword\">typename</span> _Val_types::size_type;<br>\t<span class=\"hljs-keyword\">using</span> difference_type = <span class=\"hljs-keyword\">typename</span> _Val_types::difference_type;<br>\t<span class=\"hljs-keyword\">using</span> pointer = <span class=\"hljs-keyword\">typename</span> _Val_types::pointer;<br>\t<span class=\"hljs-keyword\">using</span> const_pointer = <span class=\"hljs-keyword\">typename</span> _Val_types::const_pointer;<br>\t<span class=\"hljs-keyword\">using</span> reference = value_type&amp;;<br>\t<span class=\"hljs-keyword\">using</span> const_reference = <span class=\"hljs-keyword\">const</span> value_type&amp;;<br><br>\t_List_val()<br>\t\t: _Myhead(),<br>\t\t_Mysize(<span class=\"hljs-number\">0</span>)<br>\t\t&#123;\t<span class=\"hljs-comment\">// initialize data</span><br>\t\t&#125;<br><br>\t_Nodeptr _Myhead;\t<span class=\"hljs-comment\">// pointer to head node</span><br>\tsize_type _Mysize;\t<span class=\"hljs-comment\">// number of elements</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>可以看到list中包含了一个指向头节点的指针<code>_Myhead</code>，也就是说即使我们创建的一个空list也至少包含一个空的头节点，list使用头节点的目的就是更方便的构建容器，<code>_Mysize</code>记录的就是list的当前元素个数。</p>\n<p>list节点_List_node`的底层数据结构是一个结构体：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> _<span class=\"hljs-title\">Value_type</span>,<span class=\"hljs-keyword\">class</span> _<span class=\"hljs-title\">Voidptr</span>&gt;</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> _<span class=\"hljs-title\">List_node</span></span><br><span class=\"hljs-class\">&#123;</span>\t<span class=\"hljs-comment\">// list node</span><br>\t<span class=\"hljs-keyword\">using</span> _Nodeptr = _Rebind_pointer_t&lt;_Voidptr, _List_node&gt;;<br>\t_Nodeptr _Next;\t<span class=\"hljs-comment\">// successor node, or first element if head</span><br>\t_Nodeptr _Prev;\t<span class=\"hljs-comment\">// predecessor node, or last element if head</span><br>\t_Value_type _Myval;\t<span class=\"hljs-comment\">// the stored value, unused if head</span><br><br>\t_List_node&amp; <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-keyword\">const</span> _List_node&amp;) = <span class=\"hljs-keyword\">delete</span>;<br><br>\t<span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> _<span class=\"hljs-title\">Alloc</span>&gt;</span><br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> _Freenode0(_Alloc&amp; _Al, _Nodeptr _Ptr) <span class=\"hljs-keyword\">noexcept</span><br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">using</span> _Alnode = _Rebind_alloc_t&lt;_Alloc, _List_node&gt;;<br>\t\t<span class=\"hljs-keyword\">using</span> _Alnode_traits = allocator_traits&lt;_Alnode&gt;;<br>\t\t_Alnode _Node_alloc(_Al);<br>\t\t_Alnode_traits::destroy(_Node_alloc, _STD addressof(_Ptr-&gt;_Next));<br>\t\t_Alnode_traits::destroy(_Node_alloc, _STD addressof(_Ptr-&gt;_Prev));<br>\t\t_Alnode_traits::deallocate(_Node_alloc, _Ptr, <span class=\"hljs-number\">1</span>);<br>\t&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p><code>_List_node</code>的核心组成就是<code>_Next</code>，<code>_Prev</code>，<code>_Myval</code>，<code>_Next</code>是下一个节点的指针，<code>_Prev</code>是指向上一个节点的指针，<code>_Myval</code>是存储数据的容器。</p>\n<h2 id=\"9-priority-queue容器\"><a href=\"#9-priority-queue容器\" class=\"headerlink\" title=\"9.priority_queue容器\"></a>9.priority_queue容器</h2><ul>\n<li><p><code>priority_queue</code>容器是一个具有优先级的队列，又叫优先级队列适配器，分为最大优先级队列和最小优先级队列两种</p>\n</li>\n<li><p>priority_queue容器是一种特殊的queue容器，所以也需要包含头文件<code>#include&lt;queue&gt;</code></p>\n</li>\n</ul>\n<p>默认的定义<code>priority_queue&lt;T&gt; pr</code>的优先级队列是最大优先级队列，显示定义最小优先级队列：<code>priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt; pr</code>，<code>less</code>是一个谓词后面再学习，显示定义最大优先级队列：<code>priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; pr</code>，其中使用<code>greater</code>需要包含头文件<code>#include&lt;functional&gt;</code>。</p>\n<p><code>priority_queue</code>容器的用法基本和<code>queue</code>一致，除此之外，<code>priority_queue</code>容器提供一个<code>top()</code>函数来获取队首元素，而<code>queue</code>容器没有这个方法。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-built_in\">priority_queue</span>&lt;<span class=\"hljs-keyword\">int</span>,<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-keyword\">int</span>&gt;,greater&lt;<span class=\"hljs-keyword\">int</span>&gt;&gt; pr;<br>pr.push(<span class=\"hljs-number\">12</span>);<br>pr.push(<span class=\"hljs-number\">4</span>);<br>pr.push(<span class=\"hljs-number\">10</span>);<br>pr.push(<span class=\"hljs-number\">20</span>);<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;最小元素：&quot;</span> &lt;&lt;pr.top() &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-keyword\">while</span> (pr.size() &gt; <span class=\"hljs-number\">0</span>)<br>&#123;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; pr.top() &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span>;<br>\tpr.pop();<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dns\">最小元素：<span class=\"hljs-number\">4</span><br><span class=\"hljs-number\">4,10,12,20</span>,<br></code></pre></td></tr></table></figure>\n<h2 id=\"10-set容器\"><a href=\"#10-set容器\" class=\"headerlink\" title=\"10.set容器\"></a>10.set容器</h2><ul>\n<li><code>set</code>是一个<font color=\"red\"><strong>集合</strong></font>容器，其中所包含的元素是<font color=\"red\"><strong>唯一</strong></font>的，<font color=\"red\"><strong>集合中的元素按一定的顺序排序</strong></font>，元素的插入过程是按排序规则插入，所以不能指定位置插入</li>\n<li><code>set</code>采用红黑树变体的数据结构实现，红黑树属于平衡二叉树，在插入和删除操作上比<code>vector</code>容器速度更快</li>\n<li><code>set</code>容器不支持[]和at()来存取元素</li>\n<li><font color=\"red\"><strong>set不支持直接修改容器中的元素</strong></font>，因为元素是自动排序的，如果希望修改一个元素值，就必须删除这个元素再插入新元素</li>\n<li>要使用<code>set</code>容器需要包含头文件<code>#include&lt;set&gt;</code></li>\n</ul>\n<h3 id=\"set容器的基本特性\"><a href=\"#set容器的基本特性\" class=\"headerlink\" title=\"set容器的基本特性\"></a>set容器的基本特性</h3><p>默认情况下，直接定义的set容器采用最小优先排序，和priority_queue容器恰好相反，<code>set&lt;T&gt; se</code>就是隐式的<code>set&lt;T,less&lt;T&gt;&gt; se</code>，定义最大优先排序的set容器需要显示定义：<code>set&lt;T,greater&lt;T&gt;&gt; se</code>。</p>\n<p>我们来看一个例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-built_in\">set</span>&lt;<span class=\"hljs-built_in\">string</span>,greater&lt;<span class=\"hljs-built_in\">string</span>&gt;&gt; se;<span class=\"hljs-comment\">//采用最大优先排序</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">5</span>; i++)<span class=\"hljs-comment\">//生成随机字符串元素</span><br>&#123;<br>\t<span class=\"hljs-keyword\">int</span> tmp = rand();<br>\t<span class=\"hljs-built_in\">string</span> str = <span class=\"hljs-string\">&quot;&quot;</span>;<br>\t<span class=\"hljs-keyword\">while</span> (str.length()&lt;=<span class=\"hljs-number\">3</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span>(tmp &gt;= <span class=\"hljs-number\">97</span> &amp;&amp; tmp &lt;= <span class=\"hljs-number\">122</span>)<br>\t\t\tstr += tmp;<br>\t\ttmp = rand();<br>\t&#125;<br>\tse.insert(str);<br>&#125;<br>se.insert(<span class=\"hljs-string\">&quot;strs&quot;</span>);<span class=\"hljs-comment\">//插入相同的字符串元素</span><br>se.insert(<span class=\"hljs-string\">&quot;strs&quot;</span>);<br>se.insert(<span class=\"hljs-string\">&quot;strs&quot;</span>);<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">set</span>&lt;<span class=\"hljs-built_in\">string</span>, greater&lt;<span class=\"hljs-built_in\">string</span>&gt;&gt;::iterator it = se.begin(); it != se.end(); it++)<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; *it &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br></code></pre></td></tr></table></figure>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs armasm\"><span class=\"hljs-symbol\">wqye</span><br><span class=\"hljs-symbol\">vfep</span><br><span class=\"hljs-symbol\">strs</span><br><span class=\"hljs-symbol\">omsk</span><br><span class=\"hljs-symbol\">kfnm</span><br><span class=\"hljs-symbol\">cdsb</span><br></code></pre></td></tr></table></figure>\n<p>可以看到，容器里的字符串确实按照字符串的比较规则按从大到小的顺序排列着，并且无论我们插入多少个相同的元素，在容器内只会存储一个相同的元素值。</p>\n<p>值得注意的是：</p>\n<p><code>set</code>容器只提供了<code>insert(T t)</code>函数来插入元素。</p>\n<h3 id=\"自定义元素的排序\"><a href=\"#自定义元素的排序\" class=\"headerlink\" title=\"自定义元素的排序\"></a>自定义元素的排序</h3><p>自定义类作元素可能会出现类中有多个字段，而我们需要其中的某一个字段来作为关键字在<code>set</code>容器中排序，要实现这样的行为，我们就需要用到<font color=\"red\"><strong>仿函数</strong></font>了。</p>\n<h4 id=\"什么是仿函数？\"><a href=\"#什么是仿函数？\" class=\"headerlink\" title=\"什么是仿函数？\"></a>什么是仿函数？</h4><p>仿函数实质上就是一个做了<code>()</code>重载的结构体，因为重载了<code>()</code>使用起来类似函数，所以称之为仿函数。</p>\n<p>我们来看一个例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Student</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">string</span> name;<br>\t<span class=\"hljs-keyword\">int</span> age;<br>\t<span class=\"hljs-keyword\">bool</span> isStudent;<br>\tStudent(<span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">string</span> name, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">int</span> age, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">bool</span> isStudent)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;age = age;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;name = name;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;isStudent = isStudent;<br>\t&#125;<br>&#125;;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">AgeSort</span>//仿函数</span><br><span class=\"hljs-class\">&#123;</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">operator</span><span class=\"hljs-params\">()</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> Student &amp;lift, <span class=\"hljs-keyword\">const</span> Student &amp;right)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> (lift.age &lt; right.age);<br>\t&#125;<br>&#125;;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">set</span>&lt;Student, AgeSort&gt; se;<br>\t<span class=\"hljs-function\">Student <span class=\"hljs-title\">s1</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;Alian&quot;</span>, <span class=\"hljs-number\">23</span>, <span class=\"hljs-literal\">true</span>)</span></span>;<br>\t<span class=\"hljs-function\">Student <span class=\"hljs-title\">s2</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;Blank&quot;</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-literal\">true</span>)</span></span>;<br>\t<span class=\"hljs-function\">Student <span class=\"hljs-title\">s3</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;Cary&quot;</span>, <span class=\"hljs-number\">43</span>, <span class=\"hljs-literal\">false</span>)</span></span>;<br>\t<span class=\"hljs-function\">Student <span class=\"hljs-title\">s4</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;Davel&quot;</span>, <span class=\"hljs-number\">23</span>, <span class=\"hljs-literal\">true</span>)</span></span>;<br>\tse.insert(s1); se.insert(s2);<br>\tse.insert(s3); se.insert(s4);<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">set</span>&lt;Student, AgeSort&gt;::iterator it = se.begin(); it != se.end(); it++)<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; it-&gt;name &lt;&lt; <span class=\"hljs-string\">&quot;\\t&quot;</span> &lt;&lt; it-&gt;age &lt;&lt; <span class=\"hljs-string\">&quot;\\t&quot;</span> &lt;&lt; it-&gt;isStudent &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">Blank</span>   <span class=\"hljs-number\">20</span>      <span class=\"hljs-number\">1</span><br><span class=\"hljs-attribute\">Alian</span>   <span class=\"hljs-number\">23</span>      <span class=\"hljs-number\">1</span><br><span class=\"hljs-attribute\">Cary</span>    <span class=\"hljs-number\">43</span>      <span class=\"hljs-number\">0</span><br></code></pre></td></tr></table></figure>\n<p>其中<code>AgeSort</code>就是仿函数，它的比较关键字是<code>Student.age</code>，所以<code>set</code>容器对象se会以age作为排序关键字，其实我们之前使用的<code>less&lt;&gt;</code>和<code>greater&lt;&gt;</code>也是反函数，只不过是C++预定义好的仿函数。</p>\n<p>细心的朋友可能会发现，我们插入的s4对象居然不再容器里！！！这是因为set容器中的元素具有唯一性，而set容器是通过关键字来识别元素的，所当碰到关键字相同的元素时，set只会存储一个元素。</p>\n<p>那么这种情况该怎么解决呢？答案是set容器没有办法解决这种情况，如果有出现这种情况，就不能使用set容器而改用multiset容器。</p>\n<p>在后面的算法模块我们详细介绍仿函数。</p>\n<h3 id=\"set常用函数\"><a href=\"#set常用函数\" class=\"headerlink\" title=\"set常用函数\"></a>set常用函数</h3><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>find(T t)</td>\n<td>查找元素t，返回指向t元素的迭代器，查找失败返回指向set.end()的迭代器</td>\n</tr>\n<tr>\n<td>count(T t)</td>\n<td>返回容器中元素t的个数，值要么是0，要么是1</td>\n</tr>\n<tr>\n<td>lower_bound(T t)</td>\n<td>返回一个指向&gt;=t元素的迭代器，如果t存在则指向t，如果t不存在则指向t后面的一个元素</td>\n</tr>\n<tr>\n<td>upper_bound(T t)</td>\n<td>返回一个指向&gt;t元素的迭代器，即t元素后面的一个元素</td>\n</tr>\n<tr>\n<td>equal_range(T t)</td>\n<td>返回一个包含两个set类型的迭代器的对组pair&lt;set<T>::iterator,set<T>::iterator&gt;第一个迭代器指向t元素，第二个迭代器指向t后面的一个元素，如果t不存在，则两个迭代器都指向t后面的一个元素</T></T></td>\n</tr>\n</tbody></table>\n<h3 id=\"小知识\"><a href=\"#小知识\" class=\"headerlink\" title=\" 小知识\"></a><font color=\"blue\"> 小知识</font></h3><p><font color=\"blue\"> 事实上容器中的<code>insert</code>函数是有返回值的，<code>insert</code>的返回值是一个对组(pair)类型的泛型<code>pair&lt;set&lt;T&gt;::iterator, bool&gt;</code>的对象，<code>pair</code>是一个只有两个字段的模板，我们可以直接定义<code>pair&lt;set&lt;T&gt;::iterator, bool&gt;</code>类型对象来接收<code>insert</code>函数的返回值，如：</font></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-built_in\">pair</span>&lt;<span class=\"hljs-built_in\">set</span>&lt;Student,AgeSort&gt;::iterator, <span class=\"hljs-keyword\">bool</span>&gt; pait=se.insert(s1);<br></code></pre></td></tr></table></figure>\n<p><font color=\"blue\"> 我们可以通过<code>pair.first</code>和<code>pair.second</code>来访问对组中的两个元素，通过<code>pair.first</code>来访问对组中的第一个元素<code>set&lt;Student,AgeSort&gt;::iterator</code>类型的迭代器，通过<code>pair.first-&gt;first</code>，和<code>pair.first-&gt;second</code>可以访问迭代器所指向的容器元素，我们通过<code>pair.second</code>来访问对组中的第二个元素，bool型的元素记录的是insert函数插入是否成功，如果插入成功则记录true，否则记录false。</font></p>\n<h2 id=\"11-multiset容器\"><a href=\"#11-multiset容器\" class=\"headerlink\" title=\"11.multiset容器\"></a>11.multiset容器</h2><ul>\n<li><code>multiset</code>容器可以说是set容器的升级版，multiset容器支持多个相同键值的元素的存储，所以要使用<code>multiset</code>需要包含头文件<code>#include&lt;set&gt;</code></li>\n</ul>\n<p>multiset的用法和set一致。</p>\n<h2 id=\"12-map容器\"><a href=\"#12-map容器\" class=\"headerlink\" title=\"12.map容器\"></a>12.map容器</h2><ul>\n<li><code>map</code>是标准的关联式容器，一个<code>map</code>元素是一个键值对(key,value),<code>map</code>提供基于键值的快速检索能力</li>\n<li><code>map</code>中<font color=\"red\"><code> key</code>值是唯一的</font></li>\n<li><code>map</code>容器中的元素也是按一定顺序排列的，元素插入过程是按排序规则插入的，所以不能指定位置插入</li>\n<li><code>map</code>容器的具体实现也是采用红黑二叉树变体的平衡二叉树的数据结构，在插入和删除的操作上比<code>vector</code>更快</li>\n<li>与<code>set</code>不同的是<code>map</code>支持直接存取<code>key</code>值对应的<code>value</code>，也支持[]操作符</li>\n<li>要使用<code>map</code>容器就需要包含头文件<code>#include&lt;map&gt;</code></li>\n</ul>\n<h3 id=\"map的元素插入\"><a href=\"#map的元素插入\" class=\"headerlink\" title=\"map的元素插入\"></a>map的元素插入</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">map</span>&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-built_in\">string</span>&gt; ma;<br>\t<span class=\"hljs-comment\">//方法一</span><br>\tma.insert(<span class=\"hljs-built_in\">pair</span>&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-built_in\">string</span>&gt;(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&quot;pair&quot;</span>));<br>\tma.insert(<span class=\"hljs-built_in\">pair</span>&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-built_in\">string</span>&gt;(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&quot;pair_02&quot;</span>));<br>\t<span class=\"hljs-comment\">//方法二</span><br>\tma.insert(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&quot;make_pair&quot;</span>));<br>\tma.insert(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&quot;make_pair_02&quot;</span>));<br>\t<span class=\"hljs-comment\">//方法三</span><br>\tma.insert(<span class=\"hljs-built_in\">map</span>&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-built_in\">string</span>&gt;::value_type(<span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">&quot;value_type&quot;</span>));<br>\tma.insert(<span class=\"hljs-built_in\">map</span>&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-built_in\">string</span>&gt;::value_type(<span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">&quot;value_type_02&quot;</span>));<br>\t<span class=\"hljs-comment\">//方法四</span><br>\tma[<span class=\"hljs-number\">4</span>] = <span class=\"hljs-string\">&quot;map&quot;</span>;<br>\tma[<span class=\"hljs-number\">4</span>] = <span class=\"hljs-string\">&quot;map_02&quot;</span>;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">map</span>&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-built_in\">string</span>&gt;::iterator it = ma.begin(); it != ma.end(); it++)<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class=\"hljs-string\">&quot;\\t&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">1 </span>      pair<br><span class=\"hljs-symbol\">2 </span>      make_pair<br><span class=\"hljs-symbol\">3 </span>      value_type<br><span class=\"hljs-symbol\">4 </span>      map_02<br></code></pre></td></tr></table></figure>\n<p>上面四种方法都可以向map容器里添加元素，但是四者中也有一些微小的区别，前面三种方法在插入相同键值时，只会保存第一存储的结果，之后插入相同键值的元素时都会插入失败，而第四种方法则是后面赋值的元素覆盖前面赋值的元素。</p>\n<p>map似乎没办法来指定是从大到小排序或是从小到大排序</p>\n<p>map除了元素的形式不同，在其他方面map的用法基本和set一致</p>\n<h2 id=\"13-multimap容器\"><a href=\"#13-multimap容器\" class=\"headerlink\" title=\"13.multimap容器\"></a>13.multimap容器</h2><p><code>multimap</code>容器和<code>multiset</code>容器一样，是<code>map</code>容器的升级版，支持一个键对应多个值，所以<code>multimap</code>的一个重要应用场景就是数据分组。</p>\n<h2 id=\"14-容器在使用过程必须要注意的地方\"><a href=\"#14-容器在使用过程必须要注意的地方\" class=\"headerlink\" title=\"14.容器在使用过程必须要注意的地方\"></a>14.容器在使用过程必须要注意的地方</h2><p><font color=\"red\"> 因为在将元素添加到容器里时，C++执行的是容器的默认的拷贝构造函数，将元素拷贝到容器里，这个过程是一个浅拷贝，既然是浅拷贝就会面临浅拷贝的两次内存释放的问题，尤其是类元素，所以在添加一些具有指针字段的元素到容器里时，一定在类里定义一个深拷贝的拷贝构造函数和=的重载函数。</font></p>\n<h2 id=\"15-各个容器的比较\"><a href=\"#15-各个容器的比较\" class=\"headerlink\" title=\"15.各个容器的比较\"></a>15.各个容器的比较</h2><table>\n<thead>\n<tr>\n<th></th>\n<th>vector</th>\n<th>deque</th>\n<th>list</th>\n<th>set</th>\n<th>multiset</th>\n<th>map</th>\n<th>multimap</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>内存结构</td>\n<td>单端数组</td>\n<td>双端数组</td>\n<td>双向链表</td>\n<td>二叉树</td>\n<td>二叉树</td>\n<td>二叉树</td>\n<td>二叉树</td>\n</tr>\n<tr>\n<td>随机存取</td>\n<td>是</td>\n<td>是</td>\n<td>否</td>\n<td>否</td>\n<td>否</td>\n<td>对key而言是</td>\n<td>否</td>\n</tr>\n<tr>\n<td>元素检索</td>\n<td>慢</td>\n<td>慢</td>\n<td>非常慢</td>\n<td>快</td>\n<td>快</td>\n<td>对key而言快</td>\n<td>对key而言快</td>\n</tr>\n<tr>\n<td>快速安插移除</td>\n<td>尾端</td>\n<td>头尾两端</td>\n<td>任何位置</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n</tr>\n</tbody></table>\n<h1 id=\"三、算法\"><a href=\"#三、算法\" class=\"headerlink\" title=\"三、算法\"></a>三、算法</h1><h2 id=\"1-算法\"><a href=\"#1-算法\" class=\"headerlink\" title=\"1.算法\"></a>1.算法</h2><p>​    函数库对数据类型的选择对其可重用性起着至关重要的作用。举例来说，一个求方根的函数，在使用浮点数作为其参数类型的情况下的可重用性肯定比使用整型作为它的参数类性要高。而C++通过模板的机制允许推迟对某些类型的选择，直到真正想使用模板或者说对模板进行特化的时候，STL就利用了这一点提供了相当多的有用算法。它是在一个有效的框架中完成这些算法的–可以将所有的类型划分为少数的几类，然后就可以在模版的参数中使用一种类型替换掉同一种类中的其他类型。</p>\n<p>  STL提供了大约100个实现算法的模版函数，比如算法for_ each 将为指定序列中的每一个元素调用指定的函数，stable_ _sort 以你所指定的规则对序列进行稳定性排序等等，这样一-来,只要熟悉了STL之后，许多代码可以被大大的化简，只需要通过调用一-两个算法模板，就可以完成所需要的功能并大大地提升效率。</p>\n<p>  算法部分主要由头文件<code>&lt;algorithm&gt;</code>, <code>&lt;numeric&gt;</code>和<code>&lt;functional&gt;</code>组成。<code>&lt;algorithm&gt;</code>是所 有STL头文件中最大的一个(尽管它很好理解)，它是由一大堆模版函数组成的，可以认为每个函数在很大程度上都是独立的，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等等。<code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。<code>&lt;functional&gt;</code>中则定义了一些模板类，用以声明函数对象。</p>\n<h2 id=\"2-算法的分类\"><a href=\"#2-算法的分类\" class=\"headerlink\" title=\"2.算法的分类\"></a>2.算法的分类</h2><h3 id=\"非可变序列算法\"><a href=\"#非可变序列算法\" class=\"headerlink\" title=\"非可变序列算法\"></a>非可变序列算法</h3><p>计数算法：count,count_if等 </p>\n<p>搜索算法：search,find,find_if,find_list_of等</p>\n<p>比较算法：equal,mismatch,lexicographical_compare等</p>\n<h3 id=\"可变排序算法\"><a href=\"#可变排序算法\" class=\"headerlink\" title=\"可变排序算法\"></a>可变排序算法</h3><p>删除算法：remove,remove_if,remove_copy等</p>\n<p>修改算法：for_each,transform等</p>\n<p>排序算法：sort,stable_sort,partial_sort等</p>\n<h2 id=\"3-仿函数\"><a href=\"#3-仿函数\" class=\"headerlink\" title=\"3.仿函数\"></a>3.仿函数</h2><h2 id=\"4-一些常用的算法模板\"><a href=\"#4-一些常用的算法模板\" class=\"headerlink\" title=\"4.一些常用的算法模板\"></a>4.一些常用的算法模板</h2><h3 id=\"find算法\"><a href=\"#find算法\" class=\"headerlink\" title=\"find算法\"></a>find算法</h3><p><strong>原型:</strong><code>iterator find(iterator begin,iterator end,T t)</code></p>\n<p>在容器的begin迭代器所指向的位置开始到end所指向的位置结束，查找元素t，如果找到了，则返回指向t的迭代器。</p>\n<h1 id=\"四、迭代器\"><a href=\"#四、迭代器\" class=\"headerlink\" title=\"四、迭代器\"></a>四、迭代器</h1><h2 id=\"1-迭代器\"><a href=\"#1-迭代器\" class=\"headerlink\" title=\"1.迭代器\"></a>1.迭代器</h2><p>​    迭代器从作用上来说是最基本的部分，可是理解起来比前两者都要费力一些。软件设计有一个基本原则，所有的问题都可以通过引进一个间接层来简化，这种简化在 STL中就是用迭代器来完成的。概括来说，迭代器在STL中用来将算法和容器联系起来，起着一种黏和剂的作用。几乎STL提供的所有算法都是通过送代器存取元素序列进行工作的，每一个容器都定义了其本身所专有的选代器，用以存取容器中的元素。</p>\n<p>​    迭代器部分主要由头文件<code>&lt;utility&gt;</code>,<code>&lt;iterator&gt;</code>和<code>&lt;memory&gt;</code>组成。<code>&lt;utility&gt;</code>是-一个很小的头文件，它包括了贯穿使用在STL中的几个模板的声明，<code>&lt;iterator&gt;</code>中提供 了迭代器使用的许多方法，而对于<code>&lt;memory&gt;</code>的描述则十分的困难，它以不同寻常的方式为容器中的元素分配存储空间，同时也为某些算法执行期间产生的临时对象提供机制,<code>&lt;memory&gt;</code>中的主要部分是模板类<code>alocator</code>,它负责产生所有容器中的默认分配器。</p>\n<h2 id=\"2-迭代器的基本原理\"><a href=\"#2-迭代器的基本原理\" class=\"headerlink\" title=\"2.迭代器的基本原理\"></a>2.迭代器的基本原理</h2><ul>\n<li><p>迭代器是一个“可遍历STL容器内全部或部分元素”的对象</p>\n</li>\n<li><p>迭代器指出容器中的一个特定位置</p>\n</li>\n<li><p>迭代器就如同一个指针</p>\n</li>\n<li><p>迭代器提供对一个容器中的对象的访问方法，并且可以定义了容器中对象的范围</p>\n</li>\n</ul>\n<h2 id=\"3-迭代器的分类\"><a href=\"#3-迭代器的分类\" class=\"headerlink\" title=\"3.迭代器的分类\"></a>3.迭代器的分类</h2><p><strong>输入迭代器</strong>:也有叫法称之为“只读迭代器”，它从容器中读取元素，只能一次读入一个元素向前移动，只支持一遍算法，同一个输入迭代器不能两遍遍历一个序列。</p>\n<p><strong>输出迭代器</strong>:也有叫法称之为“只写迭代器”，它往容器中写入元素，只能一次写入一个元素向前移动，只支持一遍算法，同一个输出迭代器不能两遍遍历一个序列。</p>\n<p><strong>正向迭代器</strong>:组合输入送代器和输出迭代器的功能,还可以多次解析一个迭代器指定的位置，可以对一个值进行多次读/写。</p>\n<p><strong>双向达代器</strong>:组合正向迭代器的功能，还可以通过-操作符向后移动位置。</p>\n<p><strong>随机访问送代器</strong>:组合双向送代器的功能，还可以向前向后跳过任意个位置，可以直接访问容器中任何位置的元素。</p>\n<h1 id><a href=\"#\" class=\"headerlink\" title></a></h1>","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h1 id=\"一、STL的基本概念\"><a href=\"#一、STL的基本概念\" class=\"headerlink\" title=\"一、STL的基本概念\"></a>一、STL的基本概念</h1><h2 id=\"1-什么是STL\"><a href=\"#1-什么是STL\" class=\"headerlink\" title=\"1.什么是STL\"></a>1.什么是STL</h2><p> STL (Standard Template Librany）标准准模板庠是惠普实验室开发的一系列软件的统称。现在主要出现在C++中，但在被引入C++之前该技木就已存在了很长一段吋间了。</p>\n<p>STL的从广义上讲分为三类: algorithm (算法)、container (容器)和iterator (迭代器)，容器和算法通过迭代器可以进行无缝链接。几乎所有的代码都釆用了模板类和模板函数的方式,这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。在C++标准中，STL 被组织为下面的13个尖文件:<code>&lt;algorithm&gt;</code>、<code>&lt;deque&gt;</code>、<code>&lt;functional&gt;</code>、<code>&lt;iterator&gt;</code>、<code>&lt;vector&gt;</code>、<code>&lt;list&gt;</code>、 <code>&lt;map&gt;</code>、<code>&lt;memory&gt;</code>、<code>&lt;numerio&gt;</code>、<code>&lt;queue&gt;</code>、<code>&lt;set&gt;</code>、    <code>&lt;stack&gt;</code> 和<code>&lt;utility&gt;</code>。</p>\n<p><img src=\"/2019/10/06/%E3%80%90C++%E3%80%91C++STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/Snipaste_2019-10-06_10-41-56.png\"></p>\n<p>我们详细的说六大组件：</p>\n<ul>\n<li>容器(Container)</li>\n<li>算法(Algorithm)</li>\n<li>迭代器(Iterator)</li>\n<li>仿函数(Function object)</li>\n<li>适配器(Adaptor)</li>\n<li>空间配置器(allocator)</li>\n</ul>\n<h2 id=\"2-STL的好处\"><a href=\"#2-STL的好处\" class=\"headerlink\" title=\"2.STL的好处\"></a>2.STL的好处</h2><ul>\n<li><p>STL是C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。</p>\n</li>\n<li><p>STL的一个重要特点是数据结构和算法的分离。尽管这是个简单的概念，但是这种分离确实使得STL变得非常通用。<br>例如，在STL 的vector容器中，可以放入元素、 基础数据类型变量、元素的地址;<br>STL的sort()函数可以用来操作vector,list等容器。</p>\n</li>\n<li><p>程序员可以不用思考STL具体的实现过程，只要能够熟综使用STL就OK了。这样他们就可以把精力放在程序开发的别的方面。</p>\n</li>\n<li><p>STL 具有高可重用性，高性能，高移植性，跨平台的优点。</p>\n<p>  高可重用性: STL 中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。关于模板的知识，已经给大家介绍了。</p>\n<p>高性能:如map可以高效地从十万条记录里面查找出指定的记录，因为map是采用红黑树的变体实现的。</p>\n<p>高移植性:如在项目A上用STL编写的模块，可以直接移植到项目B上。</p>\n<p>跨平台:如用windows的Visual Studio编写的代码可以在Mac OS的XCode上直接运行。</p>\n</li>\n<li><p>了解到STL的这些好处，我们知道STL无疑是最值得C++程序员骄傲的一部分。每一个C++程序员都应该好好学习STL.只有能够熟练使用STL的程序员，才是好的C++程序员。</p>\n</li>\n</ul>\n<h1 id=\"二、容器\"><a href=\"#二、容器\" class=\"headerlink\" title=\"二、容器\"></a>二、容器</h1><h2 id=\"1-容器\"><a href=\"#1-容器\" class=\"headerlink\" title=\"1.容器\"></a>1.容器</h2><p>  在实际的开发过程中，数据结构本身的重要性不会逊于操作于数据结构的算法的重要性，当程序中存在着对时间要求很高的部分时，数据结构的选择就显得更加重要。</p>\n<p>  经典的数据结构数量有限，但是我们常常重复着一些为了实现向量、链表等结构而编写的代码，这些代码都十分相似，只是为了适应不同数据的变化而在细节上有所出入。STL容器就为我们提供了这样的方便，它允许我们重复利用己有的实现构造自己的特定类型下的数据结构，通过设置-些模板，STL 容器对最常用的数据结构提供了支持，这些模板的参数允许我们指定容器中元素的数据类型，可以将我们许多重复而乏味的工作简化。</p>\n<p>​    容器部分主要由头文件<code>&lt;vector&gt;</code>, <code>&lt;list&gt;</code>, <code>&lt;deque&gt;</code>, <code>&lt;set&gt;</code>, <code>&lt;map&gt;</code>, <code>&lt;stack&gt;</code>和<code>&lt;queue&gt;</code>组成。对于常用的一些容器和容器适配器(可以看作由其它容器实现的容器)，可以通过下表总结一:下它们和相应头文件的对应关系。</p>\n<p><img src=\"/2019/10/06/%E3%80%90C++%E3%80%91C++STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/Snipaste_2019-10-06_10-41-56.png\"></p>\n<h2 id=\"2-容器的分类\"><a href=\"#2-容器的分类\" class=\"headerlink\" title=\"2.容器的分类\"></a>2.容器的分类</h2><h3 id=\"序列式容器-Sequence-containers\"><a href=\"#序列式容器-Sequence-containers\" class=\"headerlink\" title=\"序列式容器(Sequence containers)\"></a>序列式容器(Sequence containers)</h3><p>每个元素都有固定位置–取决于插入时机和地点，和元素值无关。如：vector、deque、 Iist。</p>\n<h3 id=\"关联式容器-Associated-containers\"><a href=\"#关联式容器-Associated-containers\" class=\"headerlink\" title=\"关联式容器(Associated containers)\"></a>关联式容器(Associated containers)</h3><p>元素位置取决于特定的排序准则，和插入顺序无关。如：sset、multiset、 map、multimapu。</p>\n<p><img src=\"/2019/10/06/%E3%80%90C++%E3%80%91C++STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/Snipaste_2019-10-06_14-36-13.png\"></p>\n<h2 id=\"3-string类\"><a href=\"#3-string类\" class=\"headerlink\" title=\"3.string类\"></a>3.string类</h2><h3 id=\"string类的本质\"><a href=\"#string类的本质\" class=\"headerlink\" title=\"string类的本质\"></a>string类的本质</h3><p><code>string</code>类本质上其实就是<code>char*</code>的容器，是<code>cahr*</code>的封装。</p>\n<h3 id=\"string类的遍历\"><a href=\"#string类的遍历\" class=\"headerlink\" title=\"string类的遍历\"></a>string类的遍历</h3><p><strong>使用[]遍历：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-built_in\">string</span> str = <span class=\"hljs-string\">&quot;string_str&quot;</span>;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; str.length(); i++)<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; str[i];<br></code></pre></td></tr></table></figure>\n<p><strong>使用迭代器遍历：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-built_in\">string</span> str = <span class=\"hljs-string\">&quot;string_str&quot;</span>;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-built_in\">string</span>::iteratori=str.begin();i&lt;str.end();i++)<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt;*i;<br></code></pre></td></tr></table></figure>\n<p><font color=\"red\"> 注意这里的<code>i</code>是一个指向string::iterator类型的指针。</font></p>\n<p><strong>使用at()遍历：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-built_in\">string</span> str = <span class=\"hljs-string\">&quot;string_str&quot;</span>;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; str.length(); i++)<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; str.at(i);<br></code></pre></td></tr></table></figure>\n<p><code>at()</code>与<code>[]</code>不同的是，当访问发生越界等错误时，<code>at()</code>会自动抛出异常，而<code>[]</code>不会抛出异常而中断程序。</p>\n<h3 id=\"string解封成char\"><a href=\"#string解封成char\" class=\"headerlink\" title=\"string解封成char*\"></a>string解封成char*</h3><p>C++为string类提供了一个专门的函数<font color=\"red\"> <strong>str.c_str()</strong></font>，str是string类型的对象，但是需要注意的是<code>str.c_str()</code>返回的是一个<font color=\"red\"> const char*</font>，不能再被赋值给其他非常量指针，但是我们可以直接将<code>str.c_str()</code>当作<code>char*</code>来使用，如：<code>str.c_str()[1]</code>，即通过<code>char*</code>指针访问str中的第二个元素。</p>\n<h3 id=\"string类中一些常用函数\"><a href=\"#string类中一些常用函数\" class=\"headerlink\" title=\"string类中一些常用函数\"></a>string类中一些常用函数</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>函数名</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>复制</td>\n<td>str.copy(char *buf,int cout)</td>\n<td>从字符串str中拷贝cout个字符到char数组buf中</td>\n</tr>\n<tr>\n<td>连接</td>\n<td>str.append(string strs)</td>\n<td>将字符串strs连接到str之后，支持string和char*</td>\n</tr>\n<tr>\n<td>查找</td>\n<td>int str.find(char *strs,int index)</td>\n<td>从字符串str中的第index索引开始查找strs子串或字符，返回查找到的第一个匹配值的索引，返回的索引也可以使用迭代器来接收</td>\n</tr>\n<tr>\n<td>替换</td>\n<td>str.replace(int index,int length,char *strs)</td>\n<td>在字符串str中，从index索引开始用strs字符串替换length个长度的子串</td>\n</tr>\n<tr>\n<td>删除</td>\n<td>str.erase(int index,int length)</td>\n<td>删除字符出str从index位置开始的length长度的字符</td>\n</tr>\n<tr>\n<td>插入</td>\n<td>str.insert(int index,char *strs)</td>\n<td>从str字符串的index位置开始插入字串strs</td>\n</tr>\n</tbody></table>\n<h3 id=\"string类中常用算法函数\"><a href=\"#string类中常用算法函数\" class=\"headerlink\" title=\"string类中常用算法函数\"></a>string类中常用算法函数</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-built_in\">string</span> str = <span class=\"hljs-string\">&quot;string_str_io_stdsfx.h_iostream&quot;</span>;<br>transform(str.begin(), str.end(), str.begin(), <span class=\"hljs-built_in\">toupper</span>);<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; str &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br></code></pre></td></tr></table></figure>\n<p>transform算法包含在<code>#include &lt;algorithm&gt;</code>头文件中</p>\n<p><strong>transform算法的使用：</strong></p>\n<p><strong>原型：</strong>transform(first,last,result,op);</p>\n<p>first是容器的首迭代器，last为容器的末迭代器，result为存放结果的容器，op为要进行操作的一元函数对象或sturct、class。</p>\n<p><strong>代码解释：</strong>str.begin()返回一个指向str首部位置的迭代器，str.end()返回一个指向str尾部位置的迭代器，因为我们把输出结果继续存放在str中，且迭代器始于容器相联系的，所以存放结果的容器也是str.begin()，而我们对str做的操作是将小写字母装换为大写，C++提供了标准的转换函数,所以操作函数为toupper。</p>\n<p><strong>transform算法的另一个重载形式：</strong></p>\n<p><strong>原型：</strong>transform(first1,last1,first2,result,binary_op);</p>\n<p>first1是第一个容器的首迭代 器，last1为第一个容器的末迭代器，first2为第二个容器的首迭代器，result为存放结果的容器，binary_op为要进行操作的二元函数 对象或sturct、class。</p>\n<p>需要注意的是，两个容器first1和first2中的元素数量必须相等，否则会抛异常。</p>\n<h2 id=\"4-vector容器\"><a href=\"#4-vector容器\" class=\"headerlink\" title=\"4.vector容器\"></a>4.vector容器</h2><ul>\n<li>vector是将元素置于一个<font color=\"red\"> <strong>动态数组</strong></font>中加以管理的容器</li>\n<li>vector支持随机存取元素，支持索引存取（[],at()）和迭代器存取</li>\n<li>vector在尾部添加和移除元素速度快，在中部和头部速度慢</li>\n<li>使用vector容易需要包含<code>#include&lt;vector&gt;</code>头文件</li>\n</ul>\n<h3 id=\"vector常用方法\"><a href=\"#vector常用方法\" class=\"headerlink\" title=\"vector常用方法\"></a>vector常用方法</h3><table>\n  <tr>\n    <th> </th>\n    <th>函数</th>\n    <th>作用</th>\n  </tr>\n  <tr>\n    <td rowspan=\"4\">读取与赋值</td>\n    <td>front(void)</td>\n    <td>获取容器首元素，既可以作左值也可以作右值</td>\n  </tr>\n  <tr>\n    <td>back(void)</td>\n    <td>获取容器尾元素，既可以作左值也可以作右值</td>\n  </tr>\n  <tr>\n    <td>push_back(T t)</td>\n    <td>在容器的尾部添加元素</td>\n  </tr>\n  <tr>\n    <td>pop_back(T t)</td>\n    <td>删除容器最后一个元素</td> \n  </tr>\n  <tr>\n    <td rowspan=\"4\">只读</td>\n    <td>begin(void)</td>\n    <td>获取容器首部迭代器</td> \n  </tr>\n  <tr>\n    <td>end(void)</td>\n    <td>获取容器尾部迭代器</td> \n  </tr>\n  <tr>\n    <td>rbegin(void)</td>\n    <td>获取逆序首部迭代器，实际指向容器的尾部，只能使用vector&#60int&#62::reverse_iterator逆序迭代器接收</td> \n  </tr>\n  <tr>\n    <td>rend(void)</td>\n    <td>获取逆序尾部部迭代器，实际指向容器的首部，只能使用vector&#60int&#62::reverse_iterator逆序迭代器接收</td> \n  </tr>\n  <tr>\n    <td rowspan=\"2\">删除</td>\n    <td>erase(iterator pos)</td>\n    <td>删除迭代器pos指向位置的元素</td> \n  </tr>\n  <tr>\n    <td>erase(iterator begin,iterator end)</td>\n    <td>从迭代器begin指向位置开始到end指向位置结束，区间删除元素</td> \n  </tr>\n  <tr>\n    <td>插入</td>\n    <td>insert(iterator pos,T t)</td>\n    <td>在pos迭代器指向的位置插入元素t，insert中的迭代器pos只能是begin()或end()否则会报错，似乎不止其他的迭代器</td> \n  </tr>\n    <td>判空</td>\n    <td>empty(void)</td>\n    <td>容器判空</td> \n  \n</table>\n### Vector浅析\n\n<p>vector的最重要的实现组成其实只有三个指针，上源码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// CLASS TEMPLATE vector</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> _<span class=\"hljs-title\">Ty</span>,<span class=\"hljs-keyword\">class</span> _<span class=\"hljs-title\">Alloc</span> =</span> allocator&lt;_Ty&gt;&gt;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">vector</span> :</span> <span class=\"hljs-keyword\">public</span> _Vector_alloc&lt;_Vec_base_types&lt;_Ty, _Alloc&gt;&gt;<br>&#123;\t<br>    <span class=\"hljs-comment\">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>类体这里就省略了，如果仔细看源码就会发现vector的类体里主要实现的大多只是一些供外部调用的函数而已，而vector的最底层的一些实现其实在它的基类中就已经完成了，如<code>_Vector_alloc</code>类，而<code>_Vector_alloc</code>中也没有包含最重要的三个指针，我们在vector.cpp中搜索<code>_Myfirst</code>可以发现，<code>_Myfirst</code>,<code>_Mylast</code>,<code>_Myend</code>三个指针在<code>_Vector_val</code>这个类中，而<code>_Vector_alloc</code>中包含了对<code>_Vector_val</code>的操作。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// CLASS TEMPLATE _Vector_val</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> _<span class=\"hljs-title\">Val_types</span>&gt;</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> _<span class=\"hljs-title\">Vector_val</span> :</span> <span class=\"hljs-keyword\">public</span> _Container_base<br>&#123;\t<span class=\"hljs-comment\">// base class for vector to hold data</span><br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-keyword\">using</span> value_type = <span class=\"hljs-keyword\">typename</span> _Val_types::value_type;<br>\t<span class=\"hljs-keyword\">using</span> size_type = <span class=\"hljs-keyword\">typename</span> _Val_types::size_type;<br>\t<span class=\"hljs-keyword\">using</span> difference_type = <span class=\"hljs-keyword\">typename</span> _Val_types::difference_type;<br>\t<span class=\"hljs-keyword\">using</span> pointer = <span class=\"hljs-keyword\">typename</span> _Val_types::pointer;<br>\t<span class=\"hljs-keyword\">using</span> const_pointer = <span class=\"hljs-keyword\">typename</span> _Val_types::const_pointer;<br>\t<span class=\"hljs-keyword\">using</span> reference = value_type&amp;;<br>\t<span class=\"hljs-keyword\">using</span> const_reference = <span class=\"hljs-keyword\">const</span> value_type&amp;;<br><br>\t_Vector_val()<br>\t\t: _Myfirst(),<br>\t\t_Mylast(),<br>\t\t_Myend()<br>\t\t&#123;\t<span class=\"hljs-comment\">// initialize values</span><br>\t\t&#125;<br><br>\tpointer _Myfirst;\t<span class=\"hljs-comment\">// pointer to beginning of array</span><br>\tpointer _Mylast;\t<span class=\"hljs-comment\">// pointer to current end of sequence</span><br>\tpointer _Myend;\t<span class=\"hljs-comment\">// pointer to end of array</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>在vector中有两个关键的数字，<font color=\"red\">size与capacity</font>，其中<code>size=_Mylast-_Myfirst</code>，<code>capacity=_Myend-Myfirst</code>，三个指针指向的内存位置如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210330094505.png\"></p>\n<p>size的计算源码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">_NODISCARD size_type <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">noexcept</span></span><br><span class=\"hljs-function\"></span>&#123;\t<span class=\"hljs-comment\">// return length of sequence</span><br>\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-keyword\">static_cast</span>&lt;size_type&gt;(<span class=\"hljs-keyword\">this</span>-&gt;_Mylast() - <span class=\"hljs-keyword\">this</span>-&gt;_Myfirst()));<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>capacity的计算源码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">_NODISCARD size_type <span class=\"hljs-title\">capacity</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">noexcept</span></span><br><span class=\"hljs-function\"></span>&#123;\t<span class=\"hljs-comment\">// return current length of allocated storage</span><br>\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-keyword\">static_cast</span>&lt;size_type&gt;(<span class=\"hljs-keyword\">this</span>-&gt;_Myend() - <span class=\"hljs-keyword\">this</span>-&gt;_Myfirst()));<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>我们都知道vector的性能优越，而支撑着vector的优越性能的就是这两数据，size和capacity，size是vector中实际元素的个数，即vector总容量中的已用容量(used部分)，而capacity则是vector初始化时设置的总容量(等于used部分加unsed部分)，C++分配给vector的实际内存总是比定义时的要大一点，这是因为vector占用的内存是一整块连续的内存，预分配多一些内存可以降低vector之后的二次分配时的时间成本。所以capacity&gt;=size，档capacity=size时表示容易已满，若需要继续添加元素则需要整体移动vector，此时花费的成本会较高，所以种情况应尽量避免。</p>\n<h2 id=\"5-deque容器\"><a href=\"#5-deque容器\" class=\"headerlink\" title=\"5.deque容器\"></a>5.deque容器</h2><ul>\n<li>deque容器是一个双端数组，在双端数组的两端均可以插入和删除元素</li>\n<li>使用deque容器需要包头文件<code>#include&lt;deque&gt;</code></li>\n</ul>\n<p>deque容器可以说是vector容器的升级版，deque的用法基本和vector一致，但是deque不仅提供push_back()，pop_back()还提供<font color=\"red\"> <strong>push_front()</strong></font> 和<font color=\"red\"> <strong>pop_front()</strong></font>。</p>\n<h2 id=\"6-stack容器\"><a href=\"#6-stack容器\" class=\"headerlink\" title=\"6.stack容器\"></a>6.stack容器</h2><ul>\n<li>stack容器是一个栈模型</li>\n<li>使用stack容器需要包含头文件<code>#include&lt;stack&gt;</code></li>\n</ul>\n<h3 id=\"stack常用方法\"><a href=\"#stack常用方法\" class=\"headerlink\" title=\"stack常用方法\"></a>stack常用方法</h3><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>push(T t)</td>\n<td>元素入栈顶</td>\n</tr>\n<tr>\n<td>pop()</td>\n<td>栈顶元素出栈</td>\n</tr>\n<tr>\n<td>top()</td>\n<td>获取栈顶元素</td>\n</tr>\n</tbody></table>\n<h2 id=\"7-queue容器\"><a href=\"#7-queue容器\" class=\"headerlink\" title=\"7.queue容器\"></a>7.queue容器</h2><ul>\n<li>queue容器是一个队列模型</li>\n<li>使用queue容器需要包含头文件<code>#include&lt;queue&gt;</code></li>\n</ul>\n<h3 id=\"queue常用方法\"><a href=\"#queue常用方法\" class=\"headerlink\" title=\"queue常用方法\"></a>queue常用方法</h3><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>push(T t)</td>\n<td>元素入队尾</td>\n</tr>\n<tr>\n<td>pop()</td>\n<td>队首元素出队</td>\n</tr>\n<tr>\n<td>front()</td>\n<td>获取队首元素，既可以作左值也可以作右值</td>\n</tr>\n<tr>\n<td>back()</td>\n<td>获取队尾元素，既可以作左值也可以作右值</td>\n</tr>\n</tbody></table>\n<h2 id=\"8-list容器\"><a href=\"#8-list容器\" class=\"headerlink\" title=\"8.list容器\"></a>8.list容器</h2><ul>\n<li>list容器是一个双向链表模型，可以高效的进行元素的插入和删除操作</li>\n<li>list容器不支持随机访问，即不支持[],at()和iterator + n(如：begin()+1)等形式的访问</li>\n<li>使用list容器需要包含头文件<code>#include&lt;list&gt;</code></li>\n</ul>\n<p>list容器除了不支持随机访问外，用法和deque容器的用法基本一致，除此之外list容器还提供一个<font color=\"red\"> <strong>remove(T t)</strong></font>函数来根据元素内容删除元素</p>\n<p>使用list容器时有一点需要注意<font color=\"red\"> <strong>list容器在使用erase删除元素时，遵循左闭右开的原则</strong></font>，如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-built_in\">list</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; li;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">5</span>; i++)<br>\tli.push_back(i);<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">list</span>&lt;<span class=\"hljs-keyword\">int</span>&gt;::iterator it = li.begin(); it != li.end(); it++)<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; *it;<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">list</span>&lt;<span class=\"hljs-keyword\">int</span>&gt;::iterator it1 = li.begin();<span class=\"hljs-comment\">//it1指向元素0</span><br><span class=\"hljs-built_in\">list</span>&lt;<span class=\"hljs-keyword\">int</span>&gt;::iterator it2 = li.begin();<br>it2++; it2++; it2++;<span class=\"hljs-comment\">//此时it2指向元素3</span><br>li.erase(it1, it2);<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">list</span>&lt;<span class=\"hljs-keyword\">int</span>&gt;::iterator it = li.begin(); it != li.end(); it++)<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; *it;<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br></code></pre></td></tr></table></figure>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">01234<br>34<br></code></pre></td></tr></table></figure>\n<p>可以看到erase在删除0-3的元素时删除了0，1，2而没有删除3，即左闭右开。</p>\n<h3 id=\"list浅析\"><a href=\"#list浅析\" class=\"headerlink\" title=\"list浅析\"></a>list浅析</h3><p>list在实现结构上和vector很类似，只是list比vector多了一个<code>_List_buy</code>中间层，list的实现的核心组成有两个，<code>_List_val</code>和<code>_List_node</code>前者主要与数据结构规模和头节点相关，后者主要与数据存储、prev和next相关。上<code>_List_val</code>的源码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> _<span class=\"hljs-title\">Val_types</span>&gt;</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> _<span class=\"hljs-title\">List_val</span> :</span> <span class=\"hljs-keyword\">public</span> _Container_base<br>&#123;\t<span class=\"hljs-comment\">// base class for list to hold data</span><br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-keyword\">using</span> _Nodeptr = <span class=\"hljs-keyword\">typename</span> _Val_types::_Nodeptr;<br><br>\t<span class=\"hljs-keyword\">using</span> value_type = <span class=\"hljs-keyword\">typename</span> _Val_types::value_type;<br>\t<span class=\"hljs-keyword\">using</span> size_type = <span class=\"hljs-keyword\">typename</span> _Val_types::size_type;<br>\t<span class=\"hljs-keyword\">using</span> difference_type = <span class=\"hljs-keyword\">typename</span> _Val_types::difference_type;<br>\t<span class=\"hljs-keyword\">using</span> pointer = <span class=\"hljs-keyword\">typename</span> _Val_types::pointer;<br>\t<span class=\"hljs-keyword\">using</span> const_pointer = <span class=\"hljs-keyword\">typename</span> _Val_types::const_pointer;<br>\t<span class=\"hljs-keyword\">using</span> reference = value_type&amp;;<br>\t<span class=\"hljs-keyword\">using</span> const_reference = <span class=\"hljs-keyword\">const</span> value_type&amp;;<br><br>\t_List_val()<br>\t\t: _Myhead(),<br>\t\t_Mysize(<span class=\"hljs-number\">0</span>)<br>\t\t&#123;\t<span class=\"hljs-comment\">// initialize data</span><br>\t\t&#125;<br><br>\t_Nodeptr _Myhead;\t<span class=\"hljs-comment\">// pointer to head node</span><br>\tsize_type _Mysize;\t<span class=\"hljs-comment\">// number of elements</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>可以看到list中包含了一个指向头节点的指针<code>_Myhead</code>，也就是说即使我们创建的一个空list也至少包含一个空的头节点，list使用头节点的目的就是更方便的构建容器，<code>_Mysize</code>记录的就是list的当前元素个数。</p>\n<p>list节点_List_node`的底层数据结构是一个结构体：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> _<span class=\"hljs-title\">Value_type</span>,<span class=\"hljs-keyword\">class</span> _<span class=\"hljs-title\">Voidptr</span>&gt;</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> _<span class=\"hljs-title\">List_node</span></span><br><span class=\"hljs-class\">&#123;</span>\t<span class=\"hljs-comment\">// list node</span><br>\t<span class=\"hljs-keyword\">using</span> _Nodeptr = _Rebind_pointer_t&lt;_Voidptr, _List_node&gt;;<br>\t_Nodeptr _Next;\t<span class=\"hljs-comment\">// successor node, or first element if head</span><br>\t_Nodeptr _Prev;\t<span class=\"hljs-comment\">// predecessor node, or last element if head</span><br>\t_Value_type _Myval;\t<span class=\"hljs-comment\">// the stored value, unused if head</span><br><br>\t_List_node&amp; <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-keyword\">const</span> _List_node&amp;) = <span class=\"hljs-keyword\">delete</span>;<br><br>\t<span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> _<span class=\"hljs-title\">Alloc</span>&gt;</span><br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> _Freenode0(_Alloc&amp; _Al, _Nodeptr _Ptr) <span class=\"hljs-keyword\">noexcept</span><br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">using</span> _Alnode = _Rebind_alloc_t&lt;_Alloc, _List_node&gt;;<br>\t\t<span class=\"hljs-keyword\">using</span> _Alnode_traits = allocator_traits&lt;_Alnode&gt;;<br>\t\t_Alnode _Node_alloc(_Al);<br>\t\t_Alnode_traits::destroy(_Node_alloc, _STD addressof(_Ptr-&gt;_Next));<br>\t\t_Alnode_traits::destroy(_Node_alloc, _STD addressof(_Ptr-&gt;_Prev));<br>\t\t_Alnode_traits::deallocate(_Node_alloc, _Ptr, <span class=\"hljs-number\">1</span>);<br>\t&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p><code>_List_node</code>的核心组成就是<code>_Next</code>，<code>_Prev</code>，<code>_Myval</code>，<code>_Next</code>是下一个节点的指针，<code>_Prev</code>是指向上一个节点的指针，<code>_Myval</code>是存储数据的容器。</p>\n<h2 id=\"9-priority-queue容器\"><a href=\"#9-priority-queue容器\" class=\"headerlink\" title=\"9.priority_queue容器\"></a>9.priority_queue容器</h2><ul>\n<li><p><code>priority_queue</code>容器是一个具有优先级的队列，又叫优先级队列适配器，分为最大优先级队列和最小优先级队列两种</p>\n</li>\n<li><p>priority_queue容器是一种特殊的queue容器，所以也需要包含头文件<code>#include&lt;queue&gt;</code></p>\n</li>\n</ul>\n<p>默认的定义<code>priority_queue&lt;T&gt; pr</code>的优先级队列是最大优先级队列，显示定义最小优先级队列：<code>priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt; pr</code>，<code>less</code>是一个谓词后面再学习，显示定义最大优先级队列：<code>priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; pr</code>，其中使用<code>greater</code>需要包含头文件<code>#include&lt;functional&gt;</code>。</p>\n<p><code>priority_queue</code>容器的用法基本和<code>queue</code>一致，除此之外，<code>priority_queue</code>容器提供一个<code>top()</code>函数来获取队首元素，而<code>queue</code>容器没有这个方法。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-built_in\">priority_queue</span>&lt;<span class=\"hljs-keyword\">int</span>,<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-keyword\">int</span>&gt;,greater&lt;<span class=\"hljs-keyword\">int</span>&gt;&gt; pr;<br>pr.push(<span class=\"hljs-number\">12</span>);<br>pr.push(<span class=\"hljs-number\">4</span>);<br>pr.push(<span class=\"hljs-number\">10</span>);<br>pr.push(<span class=\"hljs-number\">20</span>);<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;最小元素：&quot;</span> &lt;&lt;pr.top() &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-keyword\">while</span> (pr.size() &gt; <span class=\"hljs-number\">0</span>)<br>&#123;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; pr.top() &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span>;<br>\tpr.pop();<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dns\">最小元素：<span class=\"hljs-number\">4</span><br><span class=\"hljs-number\">4,10,12,20</span>,<br></code></pre></td></tr></table></figure>\n<h2 id=\"10-set容器\"><a href=\"#10-set容器\" class=\"headerlink\" title=\"10.set容器\"></a>10.set容器</h2><ul>\n<li><code>set</code>是一个<font color=\"red\"><strong>集合</strong></font>容器，其中所包含的元素是<font color=\"red\"><strong>唯一</strong></font>的，<font color=\"red\"><strong>集合中的元素按一定的顺序排序</strong></font>，元素的插入过程是按排序规则插入，所以不能指定位置插入</li>\n<li><code>set</code>采用红黑树变体的数据结构实现，红黑树属于平衡二叉树，在插入和删除操作上比<code>vector</code>容器速度更快</li>\n<li><code>set</code>容器不支持[]和at()来存取元素</li>\n<li><font color=\"red\"><strong>set不支持直接修改容器中的元素</strong></font>，因为元素是自动排序的，如果希望修改一个元素值，就必须删除这个元素再插入新元素</li>\n<li>要使用<code>set</code>容器需要包含头文件<code>#include&lt;set&gt;</code></li>\n</ul>\n<h3 id=\"set容器的基本特性\"><a href=\"#set容器的基本特性\" class=\"headerlink\" title=\"set容器的基本特性\"></a>set容器的基本特性</h3><p>默认情况下，直接定义的set容器采用最小优先排序，和priority_queue容器恰好相反，<code>set&lt;T&gt; se</code>就是隐式的<code>set&lt;T,less&lt;T&gt;&gt; se</code>，定义最大优先排序的set容器需要显示定义：<code>set&lt;T,greater&lt;T&gt;&gt; se</code>。</p>\n<p>我们来看一个例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-built_in\">set</span>&lt;<span class=\"hljs-built_in\">string</span>,greater&lt;<span class=\"hljs-built_in\">string</span>&gt;&gt; se;<span class=\"hljs-comment\">//采用最大优先排序</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">5</span>; i++)<span class=\"hljs-comment\">//生成随机字符串元素</span><br>&#123;<br>\t<span class=\"hljs-keyword\">int</span> tmp = rand();<br>\t<span class=\"hljs-built_in\">string</span> str = <span class=\"hljs-string\">&quot;&quot;</span>;<br>\t<span class=\"hljs-keyword\">while</span> (str.length()&lt;=<span class=\"hljs-number\">3</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span>(tmp &gt;= <span class=\"hljs-number\">97</span> &amp;&amp; tmp &lt;= <span class=\"hljs-number\">122</span>)<br>\t\t\tstr += tmp;<br>\t\ttmp = rand();<br>\t&#125;<br>\tse.insert(str);<br>&#125;<br>se.insert(<span class=\"hljs-string\">&quot;strs&quot;</span>);<span class=\"hljs-comment\">//插入相同的字符串元素</span><br>se.insert(<span class=\"hljs-string\">&quot;strs&quot;</span>);<br>se.insert(<span class=\"hljs-string\">&quot;strs&quot;</span>);<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">set</span>&lt;<span class=\"hljs-built_in\">string</span>, greater&lt;<span class=\"hljs-built_in\">string</span>&gt;&gt;::iterator it = se.begin(); it != se.end(); it++)<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; *it &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br></code></pre></td></tr></table></figure>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs armasm\"><span class=\"hljs-symbol\">wqye</span><br><span class=\"hljs-symbol\">vfep</span><br><span class=\"hljs-symbol\">strs</span><br><span class=\"hljs-symbol\">omsk</span><br><span class=\"hljs-symbol\">kfnm</span><br><span class=\"hljs-symbol\">cdsb</span><br></code></pre></td></tr></table></figure>\n<p>可以看到，容器里的字符串确实按照字符串的比较规则按从大到小的顺序排列着，并且无论我们插入多少个相同的元素，在容器内只会存储一个相同的元素值。</p>\n<p>值得注意的是：</p>\n<p><code>set</code>容器只提供了<code>insert(T t)</code>函数来插入元素。</p>\n<h3 id=\"自定义元素的排序\"><a href=\"#自定义元素的排序\" class=\"headerlink\" title=\"自定义元素的排序\"></a>自定义元素的排序</h3><p>自定义类作元素可能会出现类中有多个字段，而我们需要其中的某一个字段来作为关键字在<code>set</code>容器中排序，要实现这样的行为，我们就需要用到<font color=\"red\"><strong>仿函数</strong></font>了。</p>\n<h4 id=\"什么是仿函数？\"><a href=\"#什么是仿函数？\" class=\"headerlink\" title=\"什么是仿函数？\"></a>什么是仿函数？</h4><p>仿函数实质上就是一个做了<code>()</code>重载的结构体，因为重载了<code>()</code>使用起来类似函数，所以称之为仿函数。</p>\n<p>我们来看一个例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Student</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">string</span> name;<br>\t<span class=\"hljs-keyword\">int</span> age;<br>\t<span class=\"hljs-keyword\">bool</span> isStudent;<br>\tStudent(<span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">string</span> name, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">int</span> age, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">bool</span> isStudent)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;age = age;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;name = name;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;isStudent = isStudent;<br>\t&#125;<br>&#125;;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">AgeSort</span>//仿函数</span><br><span class=\"hljs-class\">&#123;</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">operator</span><span class=\"hljs-params\">()</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> Student &amp;lift, <span class=\"hljs-keyword\">const</span> Student &amp;right)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> (lift.age &lt; right.age);<br>\t&#125;<br>&#125;;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">set</span>&lt;Student, AgeSort&gt; se;<br>\t<span class=\"hljs-function\">Student <span class=\"hljs-title\">s1</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;Alian&quot;</span>, <span class=\"hljs-number\">23</span>, <span class=\"hljs-literal\">true</span>)</span></span>;<br>\t<span class=\"hljs-function\">Student <span class=\"hljs-title\">s2</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;Blank&quot;</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-literal\">true</span>)</span></span>;<br>\t<span class=\"hljs-function\">Student <span class=\"hljs-title\">s3</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;Cary&quot;</span>, <span class=\"hljs-number\">43</span>, <span class=\"hljs-literal\">false</span>)</span></span>;<br>\t<span class=\"hljs-function\">Student <span class=\"hljs-title\">s4</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;Davel&quot;</span>, <span class=\"hljs-number\">23</span>, <span class=\"hljs-literal\">true</span>)</span></span>;<br>\tse.insert(s1); se.insert(s2);<br>\tse.insert(s3); se.insert(s4);<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">set</span>&lt;Student, AgeSort&gt;::iterator it = se.begin(); it != se.end(); it++)<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; it-&gt;name &lt;&lt; <span class=\"hljs-string\">&quot;\\t&quot;</span> &lt;&lt; it-&gt;age &lt;&lt; <span class=\"hljs-string\">&quot;\\t&quot;</span> &lt;&lt; it-&gt;isStudent &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">Blank</span>   <span class=\"hljs-number\">20</span>      <span class=\"hljs-number\">1</span><br><span class=\"hljs-attribute\">Alian</span>   <span class=\"hljs-number\">23</span>      <span class=\"hljs-number\">1</span><br><span class=\"hljs-attribute\">Cary</span>    <span class=\"hljs-number\">43</span>      <span class=\"hljs-number\">0</span><br></code></pre></td></tr></table></figure>\n<p>其中<code>AgeSort</code>就是仿函数，它的比较关键字是<code>Student.age</code>，所以<code>set</code>容器对象se会以age作为排序关键字，其实我们之前使用的<code>less&lt;&gt;</code>和<code>greater&lt;&gt;</code>也是反函数，只不过是C++预定义好的仿函数。</p>\n<p>细心的朋友可能会发现，我们插入的s4对象居然不再容器里！！！这是因为set容器中的元素具有唯一性，而set容器是通过关键字来识别元素的，所当碰到关键字相同的元素时，set只会存储一个元素。</p>\n<p>那么这种情况该怎么解决呢？答案是set容器没有办法解决这种情况，如果有出现这种情况，就不能使用set容器而改用multiset容器。</p>\n<p>在后面的算法模块我们详细介绍仿函数。</p>\n<h3 id=\"set常用函数\"><a href=\"#set常用函数\" class=\"headerlink\" title=\"set常用函数\"></a>set常用函数</h3><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>find(T t)</td>\n<td>查找元素t，返回指向t元素的迭代器，查找失败返回指向set.end()的迭代器</td>\n</tr>\n<tr>\n<td>count(T t)</td>\n<td>返回容器中元素t的个数，值要么是0，要么是1</td>\n</tr>\n<tr>\n<td>lower_bound(T t)</td>\n<td>返回一个指向&gt;=t元素的迭代器，如果t存在则指向t，如果t不存在则指向t后面的一个元素</td>\n</tr>\n<tr>\n<td>upper_bound(T t)</td>\n<td>返回一个指向&gt;t元素的迭代器，即t元素后面的一个元素</td>\n</tr>\n<tr>\n<td>equal_range(T t)</td>\n<td>返回一个包含两个set类型的迭代器的对组pair&lt;set<T>::iterator,set<T>::iterator&gt;第一个迭代器指向t元素，第二个迭代器指向t后面的一个元素，如果t不存在，则两个迭代器都指向t后面的一个元素</T></T></td>\n</tr>\n</tbody></table>\n<h3 id=\"小知识\"><a href=\"#小知识\" class=\"headerlink\" title=\" 小知识\"></a><font color=\"blue\"> 小知识</font></h3><p><font color=\"blue\"> 事实上容器中的<code>insert</code>函数是有返回值的，<code>insert</code>的返回值是一个对组(pair)类型的泛型<code>pair&lt;set&lt;T&gt;::iterator, bool&gt;</code>的对象，<code>pair</code>是一个只有两个字段的模板，我们可以直接定义<code>pair&lt;set&lt;T&gt;::iterator, bool&gt;</code>类型对象来接收<code>insert</code>函数的返回值，如：</font></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-built_in\">pair</span>&lt;<span class=\"hljs-built_in\">set</span>&lt;Student,AgeSort&gt;::iterator, <span class=\"hljs-keyword\">bool</span>&gt; pait=se.insert(s1);<br></code></pre></td></tr></table></figure>\n<p><font color=\"blue\"> 我们可以通过<code>pair.first</code>和<code>pair.second</code>来访问对组中的两个元素，通过<code>pair.first</code>来访问对组中的第一个元素<code>set&lt;Student,AgeSort&gt;::iterator</code>类型的迭代器，通过<code>pair.first-&gt;first</code>，和<code>pair.first-&gt;second</code>可以访问迭代器所指向的容器元素，我们通过<code>pair.second</code>来访问对组中的第二个元素，bool型的元素记录的是insert函数插入是否成功，如果插入成功则记录true，否则记录false。</font></p>\n<h2 id=\"11-multiset容器\"><a href=\"#11-multiset容器\" class=\"headerlink\" title=\"11.multiset容器\"></a>11.multiset容器</h2><ul>\n<li><code>multiset</code>容器可以说是set容器的升级版，multiset容器支持多个相同键值的元素的存储，所以要使用<code>multiset</code>需要包含头文件<code>#include&lt;set&gt;</code></li>\n</ul>\n<p>multiset的用法和set一致。</p>\n<h2 id=\"12-map容器\"><a href=\"#12-map容器\" class=\"headerlink\" title=\"12.map容器\"></a>12.map容器</h2><ul>\n<li><code>map</code>是标准的关联式容器，一个<code>map</code>元素是一个键值对(key,value),<code>map</code>提供基于键值的快速检索能力</li>\n<li><code>map</code>中<font color=\"red\"><code> key</code>值是唯一的</font></li>\n<li><code>map</code>容器中的元素也是按一定顺序排列的，元素插入过程是按排序规则插入的，所以不能指定位置插入</li>\n<li><code>map</code>容器的具体实现也是采用红黑二叉树变体的平衡二叉树的数据结构，在插入和删除的操作上比<code>vector</code>更快</li>\n<li>与<code>set</code>不同的是<code>map</code>支持直接存取<code>key</code>值对应的<code>value</code>，也支持[]操作符</li>\n<li>要使用<code>map</code>容器就需要包含头文件<code>#include&lt;map&gt;</code></li>\n</ul>\n<h3 id=\"map的元素插入\"><a href=\"#map的元素插入\" class=\"headerlink\" title=\"map的元素插入\"></a>map的元素插入</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">map</span>&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-built_in\">string</span>&gt; ma;<br>\t<span class=\"hljs-comment\">//方法一</span><br>\tma.insert(<span class=\"hljs-built_in\">pair</span>&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-built_in\">string</span>&gt;(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&quot;pair&quot;</span>));<br>\tma.insert(<span class=\"hljs-built_in\">pair</span>&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-built_in\">string</span>&gt;(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&quot;pair_02&quot;</span>));<br>\t<span class=\"hljs-comment\">//方法二</span><br>\tma.insert(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&quot;make_pair&quot;</span>));<br>\tma.insert(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&quot;make_pair_02&quot;</span>));<br>\t<span class=\"hljs-comment\">//方法三</span><br>\tma.insert(<span class=\"hljs-built_in\">map</span>&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-built_in\">string</span>&gt;::value_type(<span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">&quot;value_type&quot;</span>));<br>\tma.insert(<span class=\"hljs-built_in\">map</span>&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-built_in\">string</span>&gt;::value_type(<span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">&quot;value_type_02&quot;</span>));<br>\t<span class=\"hljs-comment\">//方法四</span><br>\tma[<span class=\"hljs-number\">4</span>] = <span class=\"hljs-string\">&quot;map&quot;</span>;<br>\tma[<span class=\"hljs-number\">4</span>] = <span class=\"hljs-string\">&quot;map_02&quot;</span>;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">map</span>&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-built_in\">string</span>&gt;::iterator it = ma.begin(); it != ma.end(); it++)<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class=\"hljs-string\">&quot;\\t&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">1 </span>      pair<br><span class=\"hljs-symbol\">2 </span>      make_pair<br><span class=\"hljs-symbol\">3 </span>      value_type<br><span class=\"hljs-symbol\">4 </span>      map_02<br></code></pre></td></tr></table></figure>\n<p>上面四种方法都可以向map容器里添加元素，但是四者中也有一些微小的区别，前面三种方法在插入相同键值时，只会保存第一存储的结果，之后插入相同键值的元素时都会插入失败，而第四种方法则是后面赋值的元素覆盖前面赋值的元素。</p>\n<p>map似乎没办法来指定是从大到小排序或是从小到大排序</p>\n<p>map除了元素的形式不同，在其他方面map的用法基本和set一致</p>\n<h2 id=\"13-multimap容器\"><a href=\"#13-multimap容器\" class=\"headerlink\" title=\"13.multimap容器\"></a>13.multimap容器</h2><p><code>multimap</code>容器和<code>multiset</code>容器一样，是<code>map</code>容器的升级版，支持一个键对应多个值，所以<code>multimap</code>的一个重要应用场景就是数据分组。</p>\n<h2 id=\"14-容器在使用过程必须要注意的地方\"><a href=\"#14-容器在使用过程必须要注意的地方\" class=\"headerlink\" title=\"14.容器在使用过程必须要注意的地方\"></a>14.容器在使用过程必须要注意的地方</h2><p><font color=\"red\"> 因为在将元素添加到容器里时，C++执行的是容器的默认的拷贝构造函数，将元素拷贝到容器里，这个过程是一个浅拷贝，既然是浅拷贝就会面临浅拷贝的两次内存释放的问题，尤其是类元素，所以在添加一些具有指针字段的元素到容器里时，一定在类里定义一个深拷贝的拷贝构造函数和=的重载函数。</font></p>\n<h2 id=\"15-各个容器的比较\"><a href=\"#15-各个容器的比较\" class=\"headerlink\" title=\"15.各个容器的比较\"></a>15.各个容器的比较</h2><table>\n<thead>\n<tr>\n<th></th>\n<th>vector</th>\n<th>deque</th>\n<th>list</th>\n<th>set</th>\n<th>multiset</th>\n<th>map</th>\n<th>multimap</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>内存结构</td>\n<td>单端数组</td>\n<td>双端数组</td>\n<td>双向链表</td>\n<td>二叉树</td>\n<td>二叉树</td>\n<td>二叉树</td>\n<td>二叉树</td>\n</tr>\n<tr>\n<td>随机存取</td>\n<td>是</td>\n<td>是</td>\n<td>否</td>\n<td>否</td>\n<td>否</td>\n<td>对key而言是</td>\n<td>否</td>\n</tr>\n<tr>\n<td>元素检索</td>\n<td>慢</td>\n<td>慢</td>\n<td>非常慢</td>\n<td>快</td>\n<td>快</td>\n<td>对key而言快</td>\n<td>对key而言快</td>\n</tr>\n<tr>\n<td>快速安插移除</td>\n<td>尾端</td>\n<td>头尾两端</td>\n<td>任何位置</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n</tr>\n</tbody></table>\n<h1 id=\"三、算法\"><a href=\"#三、算法\" class=\"headerlink\" title=\"三、算法\"></a>三、算法</h1><h2 id=\"1-算法\"><a href=\"#1-算法\" class=\"headerlink\" title=\"1.算法\"></a>1.算法</h2><p>​    函数库对数据类型的选择对其可重用性起着至关重要的作用。举例来说，一个求方根的函数，在使用浮点数作为其参数类型的情况下的可重用性肯定比使用整型作为它的参数类性要高。而C++通过模板的机制允许推迟对某些类型的选择，直到真正想使用模板或者说对模板进行特化的时候，STL就利用了这一点提供了相当多的有用算法。它是在一个有效的框架中完成这些算法的–可以将所有的类型划分为少数的几类，然后就可以在模版的参数中使用一种类型替换掉同一种类中的其他类型。</p>\n<p>  STL提供了大约100个实现算法的模版函数，比如算法for_ each 将为指定序列中的每一个元素调用指定的函数，stable_ _sort 以你所指定的规则对序列进行稳定性排序等等，这样一-来,只要熟悉了STL之后，许多代码可以被大大的化简，只需要通过调用一-两个算法模板，就可以完成所需要的功能并大大地提升效率。</p>\n<p>  算法部分主要由头文件<code>&lt;algorithm&gt;</code>, <code>&lt;numeric&gt;</code>和<code>&lt;functional&gt;</code>组成。<code>&lt;algorithm&gt;</code>是所 有STL头文件中最大的一个(尽管它很好理解)，它是由一大堆模版函数组成的，可以认为每个函数在很大程度上都是独立的，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等等。<code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。<code>&lt;functional&gt;</code>中则定义了一些模板类，用以声明函数对象。</p>\n<h2 id=\"2-算法的分类\"><a href=\"#2-算法的分类\" class=\"headerlink\" title=\"2.算法的分类\"></a>2.算法的分类</h2><h3 id=\"非可变序列算法\"><a href=\"#非可变序列算法\" class=\"headerlink\" title=\"非可变序列算法\"></a>非可变序列算法</h3><p>计数算法：count,count_if等 </p>\n<p>搜索算法：search,find,find_if,find_list_of等</p>\n<p>比较算法：equal,mismatch,lexicographical_compare等</p>\n<h3 id=\"可变排序算法\"><a href=\"#可变排序算法\" class=\"headerlink\" title=\"可变排序算法\"></a>可变排序算法</h3><p>删除算法：remove,remove_if,remove_copy等</p>\n<p>修改算法：for_each,transform等</p>\n<p>排序算法：sort,stable_sort,partial_sort等</p>\n<h2 id=\"3-仿函数\"><a href=\"#3-仿函数\" class=\"headerlink\" title=\"3.仿函数\"></a>3.仿函数</h2><h2 id=\"4-一些常用的算法模板\"><a href=\"#4-一些常用的算法模板\" class=\"headerlink\" title=\"4.一些常用的算法模板\"></a>4.一些常用的算法模板</h2><h3 id=\"find算法\"><a href=\"#find算法\" class=\"headerlink\" title=\"find算法\"></a>find算法</h3><p><strong>原型:</strong><code>iterator find(iterator begin,iterator end,T t)</code></p>\n<p>在容器的begin迭代器所指向的位置开始到end所指向的位置结束，查找元素t，如果找到了，则返回指向t的迭代器。</p>\n<h1 id=\"四、迭代器\"><a href=\"#四、迭代器\" class=\"headerlink\" title=\"四、迭代器\"></a>四、迭代器</h1><h2 id=\"1-迭代器\"><a href=\"#1-迭代器\" class=\"headerlink\" title=\"1.迭代器\"></a>1.迭代器</h2><p>​    迭代器从作用上来说是最基本的部分，可是理解起来比前两者都要费力一些。软件设计有一个基本原则，所有的问题都可以通过引进一个间接层来简化，这种简化在 STL中就是用迭代器来完成的。概括来说，迭代器在STL中用来将算法和容器联系起来，起着一种黏和剂的作用。几乎STL提供的所有算法都是通过送代器存取元素序列进行工作的，每一个容器都定义了其本身所专有的选代器，用以存取容器中的元素。</p>\n<p>​    迭代器部分主要由头文件<code>&lt;utility&gt;</code>,<code>&lt;iterator&gt;</code>和<code>&lt;memory&gt;</code>组成。<code>&lt;utility&gt;</code>是-一个很小的头文件，它包括了贯穿使用在STL中的几个模板的声明，<code>&lt;iterator&gt;</code>中提供 了迭代器使用的许多方法，而对于<code>&lt;memory&gt;</code>的描述则十分的困难，它以不同寻常的方式为容器中的元素分配存储空间，同时也为某些算法执行期间产生的临时对象提供机制,<code>&lt;memory&gt;</code>中的主要部分是模板类<code>alocator</code>,它负责产生所有容器中的默认分配器。</p>\n<h2 id=\"2-迭代器的基本原理\"><a href=\"#2-迭代器的基本原理\" class=\"headerlink\" title=\"2.迭代器的基本原理\"></a>2.迭代器的基本原理</h2><ul>\n<li><p>迭代器是一个“可遍历STL容器内全部或部分元素”的对象</p>\n</li>\n<li><p>迭代器指出容器中的一个特定位置</p>\n</li>\n<li><p>迭代器就如同一个指针</p>\n</li>\n<li><p>迭代器提供对一个容器中的对象的访问方法，并且可以定义了容器中对象的范围</p>\n</li>\n</ul>\n<h2 id=\"3-迭代器的分类\"><a href=\"#3-迭代器的分类\" class=\"headerlink\" title=\"3.迭代器的分类\"></a>3.迭代器的分类</h2><p><strong>输入迭代器</strong>:也有叫法称之为“只读迭代器”，它从容器中读取元素，只能一次读入一个元素向前移动，只支持一遍算法，同一个输入迭代器不能两遍遍历一个序列。</p>\n<p><strong>输出迭代器</strong>:也有叫法称之为“只写迭代器”，它往容器中写入元素，只能一次写入一个元素向前移动，只支持一遍算法，同一个输出迭代器不能两遍遍历一个序列。</p>\n<p><strong>正向迭代器</strong>:组合输入送代器和输出迭代器的功能,还可以多次解析一个迭代器指定的位置，可以对一个值进行多次读/写。</p>\n<p><strong>双向达代器</strong>:组合正向迭代器的功能，还可以通过-操作符向后移动位置。</p>\n<p><strong>随机访问送代器</strong>:组合双向送代器的功能，还可以向前向后跳过任意个位置，可以直接访问容器中任何位置的元素。</p>\n<h1 id><a href=\"#\" class=\"headerlink\" title></a></h1>"},{"title":"【C++】C++进阶","date":"2019-08-23T14:27:29.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# ﻿1.C++介绍\n\n​\tC语言作为结构化和模块化语言适合规模较小的程序，对于大规模的复杂程序，能够高度抽象和建模的C++则更加适合，C++是C语言的加强版，以C语言为基础，并且完全兼容C语言的特性。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190623193001260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n# 2.C++对C语言的增强语法\n\n​\t2.1.命名空间\n​\t2.2.引用\n​\t2.3.函数与运算符的重载\n​\t2.4.面向对象的特性\n​\t2.5.泛型编程\n​\t2.6.异常处理\n​\t2.7.标准模板库\n下面笔者就者7个特性进行详细说明：\n\n# 3.命名空间\n\n​\t命名空间是C++提供的一种解决不同文件互相调用时符号名字冲突的方法，一个命名空间就是一个作用域，在不同的命名空间下允许相同的名字符号代表不同的实体。\n\n## 3.1命名空间的定义\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190623200228628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\t\t注意：命名空间的声明要在类和函数的外面定义，并且没有分号结束。\n\n## 3.2.命名空间成员的引用\n\n命名空间名::成员名\n如：\n\n```c++\n//1.cpp\n#include<iostream>\nusing namesapce std;\nnamespace A {\n\tint add(int a,int b);\n}\nint add(int a,int b);\nint mian(){\n\tint a = 1,b = 1;\n\tcout << add(a,b)<<\"  \"<<A::add(a,b)<< endl;\n\treturn 0;\n\t}\nint add(int a,int b){\n\treturn(a + b);\n}\n\n//2.cpp\n#include<iostream>\nnamespace A {\n\tint add(int a,int b){\n\t\treturn(a + b)；\n\t}\n}\n```\n\n命名空间的声明方式，我们需要用到命名空间中的什么方法就在{}内加入什么方法的声明，当然直接使用“using namespace A”来声明A命名空间也是可以的，但是这种命名方法会将A命名空间下的所有方法都作声明，包括我们可能没有使用的方法，当工程很大时，这种做法会导致代码臃肿。\n\n在很多人编程的时候，如果各程序员之间不一直进行密切的交流，极容易出现变量名或方法名类名等相同的情况，这样\t在多文档联合编译时，编译器会无法区分同名符号而报错，而命名空间就很好的解决了这种问题，我们为各个文档都定义一个唯一的命名空间，这样即使是相同符号也可以通过命名空间唯一标识了，命名空间的出现极大的改善了多人编程的困处。\n\n## 3.3.命名空间的别名\n\n命名空间是可以另起别命的，别命是已定义的命名空间的可代替的名字，一个命名空间可以有很多个别名，所有的别命和命名空间原名可以互换使用\n别命的定义：namespace 别命 = 命名空间原名;\n\t![在这里插入图片描述](https://img-blog.csdnimg.cn/2019062320111766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n## 3.4.命名空间的成员类型\n\n命名空间的成员类型可以是变量、常量、函数、结构体、联合体、枚举、类、嵌套的命名空间\n\n## 3.5.全局命名空间\n\n在全局作用域中定义的命名空间，大多数命名空间都属于全局命名空间。即自定义的命名空间是全局命名空间的扩张和细分。全局命名空间是隐式声明的，它存在于每一个程序中。\n由于全局命名空间是隐含的，它没有名字，所以使用“::成员名字”引用全局命名空间。\n\n## 3.6.匿名命名空间\n\n匿名命名空间与全局命名空间类似，也没有名字，但是匿名命名空间定义在局部作用域，不能用于多文件编译。\n匿名命名空间可以直接使用变量名引用成员。\n\n# 4.引用\n\n## 4.1.什么是引用？\n\n引用即别命，是某一个变量或对象的别命，绑定一个引用到一个变量或对象，即引用初始化，之后对引用的操作完全等价于对与其绑定的变量或对象的操作。\n\n## 4.2.引用的定义\n\n类型 &引用名 = 目标变量名;\n需要注意的是：\n\n- &不是求地址运算符，而是起标志作用\n- 引用的类型必须和其所绑定的变量类型相同\n- 声明应用的同时必须对其初始化，否则系统会报错\n- 引用相当于变量或对象的别命，因此不可将已绑定的引用再绑定其他变量或对象，也不可将一个引用绑定另一个引用。\n\n## 4.3.引用与指针的区别\n\n- 占用存储空间上：\n  引用占用一个地址空间，本地计算机的一个地址空间是多少位，引用就占多少位的地址空间。\n  而指针除了占用一个地址空间外，还占用一个数据空间用于存储其指向的变量或对象的地址。\n\n- 在操作上：\n  引用声明的同时必须对其初始化，且初始化后引用不可更改，引用不能为空。如：int &a ;是错误的用法，正确的用法应该是：int &a = b;\n  指针的声明可以在任何时候初始化，且指针在后续操作中可以变更其指向的变量或对象，指针可以为空。\n\n- 存储内容上\n  “sizeof引用”得到的是引用所指向的变量或对象的大小\n  “sizeof指针”得到的是指针本身的大小\n\n- 层级上\n  引用只能有一级，引用不可以再指向引用\n  指针理论上对级数没有限制\n\n- 可以将引用理解为不可更改的指针，即：类型* const 指针变量\n\n## 4.4.对数组的引用\n\n类型 （&引用名）[数组下标] = 数组名;\n如：对int a[3]数组的引用为int (&quote)[3] = a;即将引用名替换成数组名。\n这里要注意，“()”是不能省略的，因为如果省略()，则会改变优先级，变成int &(quote[3]) = a;而出现语法错误。\n\n## 4.5.对指针的引用\n\n类型* &引用名 = 指针名;\n如：int* &quote = p;\n\n## 4.6.引用的作用\n\n引用既可以作为别命使用，还可以作为函数的参数、函数的返回值使用。\n需要注意的是，引用作为函数的返回值时不能返回局部变量的引用。\n至此，我可能提出这样的疑问：引用能做的事指针也能做，引用不能做的事指针还能做，那么C++么什么要引入“引用”这个概念呢？\n这是因为，指针的操作太过于强大，正因如此对指针的使用存在一定的风险，所谓“收益与风险并存”，在很多高版本的编译器中已经不能再操作指针了，如VS2015，而C++之所以还保留着指针，是因为指针的魅力无比诱人，尽管有风险却不愿意就此抛弃。\n引用的另一个用处我们举一个例子来说明\n如：\n\n```c++\nint add_1(int b){\n\tb++;\n}\nint add_2(int &c){\n\tc++;\n}\nvoid mian(){\nint a = 1;\nint &a = a;\ncout<<add_1(a)<<endl;\ncout<<add_2(&a)<<endl;\n}\n```\n\n我们的输出结果是：1 2，为什么呢?因为普通的参数传递，传递的是参数的拷贝，如add_1我们对b++，实际进行运算的是形参b，而实参a却没有发生运算，所以cout<<add_1(a)输出1，而如果传递引用的话，我们在函数add_2中对引用的操作实质上就是对a进行运算，因为&a就是a。\n\n## 4.7.常引用\n\nconst 类型 &引用名 = 目标变量名\n常引用可以引用常量也可以引用变量，常引用不允许通过引用对其绑定的变量或对象进行修改。\n\n## ![在这里插入图片描述](https://img-blog.csdnimg.cn/2019062512243728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n# 5.函数重载\n\n## 5.1.C++重载的实现\n\n从本质上来说，C++之所以能实现函数的重载是因为C++编译器对函数名的处理方法进行了优化，我们来对比一下C语言编译器和C++编译器对函数名的编译\n\n- C语言编译器\n  对函数 int add(int a);编译后的名字为：add\n\n- C++编译器\n  对函数int add(int a);编译后的名字为：addi，对int add(int a,float b);编译后的名字为：addij，C++编译器使用函数名和参数类型的共同组合成编译后函数的唯一标识，即可实现函数的重载。\n\n## 5.2.重载的定义\n\n重载就是在相同的声明域中函数名相同而参数列表不同，通过函数的参数表唯一标识的函数。\n\n## 5.3.函数的默认参数\n\nC++可以使用默认参数，即在函数声明时为参数提供一个默认值，当函数调用时没有指定这个参数的值时，编译器会自动使用默认值替换。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190625221621705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n需要注意的是，默认参数只能放在声明或定义处，能放在声明处就放在声明处。如果某个参数是默认参数，那么其后的参数也必须都是默认参数，如：`int add(int a = 1,int b,int c);`编译器将报错，而`int add(int a,int b = 1,int c = 2);`则不会报错，因为参数在传递的时候是从左到右的，首先使用无默认参数的参数列表，当遇到没有传入实参的形参时开始使用默认参数的参数列表。使用默认参数的情况仅限于用在没有没有重载冲突的函数上，如：重载add函数，`int add(){...} int add(int a = 1,int b = 2){...}`,此时调用add();将调用不带参数的add()函数。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190625222013457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n## 5.4.内联函数\n\n### 5.4.1.为什么需要内联函数？\n\n在程序执行的过程中，当碰到函数调用时，系统要将程序当前状态保存到栈中，同时跳转到函数代码处执行函数体，此过程需要占用时间和空间，是的程序执行效率低下。当然我们声明一个内联函数只是建议编译器将此函数作为内联函数，但是编译器有自己的判断算法，在编译时编译器会自行判断我们声明的内联函数是否值得变为内联函数，以保证主程序体不会过于臃肿，所以我们声明的内联函数不一定会成为内联函数。\n\n### 5.4.2.内联函数的定义\n\ninline 返回值类型 函数名(参数列表){函数体;} \n\n### 5.4.3.内联函数是一种用空间换时间的措施，通常只有较短的函数才定义为内联函数。\n\n# 6.new和delete运算符\n\n## 6.1.new运算符\n\nnew运算符的功能是在堆区分配内存，通过new运算符获得的内存空间都处于堆上。delete运算符的功能正好与new相反，delete运算符的功能是释放new运算符的在堆区创建的内存，new运算符与delete运算符最好是配套出现，即使用new运算符创建了内存就一定要用delete运算符在不需要的时候此内存的时候将其释放，为什么呢？因为堆区的内存是不会随着程序结束而释放的，堆区的内存只要在操作系统关闭时才会释放，所以如果不手动释放new运算符在堆区创建的内存，则会造成大量无用数据占据着堆区内存，当堆区内存被占满时这会出现系统无堆区内存可用而出现系统死机。\n\n## 6.2.new/delete运算符的使用\n\nnew <数据类型> (参数)\ndelete <对象指针>/delete <对象数组指针>\n![在这里插入图片描述](https://img-blog.csdnimg.cn/201907121654256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n## 6.3.那么C++的new/delete与C语言的malloc/free有什么区别呢？\n\n- 它们都是动态管理内存的入口\n- malloc/free是C/C++标准库函数，而new/delete是C++操作符\n- malloc/free只是动态分分配/释放内存空间，而new/delete除了分配内存空间还会调用构造/析构函数进行初始化/清理（清理成员）\n- malloc/free需要手动计算类型大小且返回值为void，而new/delete可以自行计算类型大小返回对应类型的指针\n- new/delete在底层是调用了malloc/free的。可以认为是C++对malloc/free的封装\n- malloc/free申请空间后需要判空，new/delete则不需要\n- new直接跟类型，malloc跟字节数。\n  new/delete和malloc/free的区别是C++企业招聘时特别喜欢考的一项\n\n# 7.程序的内存空间\n\n## 7.1.指针的内存操作\n\n- 指针不仅可以可以指向变量还可以指向函数\n- 有new运算符在堆区创建的内存空间由位于栈区的指针确定入口\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190712165857369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n说到这，我们有必要了解一下计算机程序的内存结构，供程序运行的内存空间分为：堆区、栈区、.data段、.bss段、.ro段、.txt段，我使用一张图来说明\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190712170749180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n# 8.面向对象编程的特点\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2019071310135053.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n# 9.C++中的类\n\n## 9.1.类的定义\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2019071310150942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n## 9.2.访问权限\n\n- C++为类的成员添加了三种访问权限\n  public--公有成员：权限最高，在public修饰下的成员是类的外部接口，可以被类的成员函数和对象直接访问\n- protected--保护成员：权限居中，可以被类的成员函数和其派生类的成员函数直接访问，但不能被类的对象和派生类的对象直接访问。\n- private--私有成员：权限最低，只能通过类的成员函数访问。\n\n## 9.3.类的成员\n\n- 成员变量：类的成员变量用以描述一个对象的属性信息，与一般的变量声明相同，但类的成员变量只能在类的声明体中定义，类的成员变量一般在类的构造函数中初始化，但这不是必须的。\n- 成员函数：用来描述一个对象的行为动作，与一般的函数声明相同，但只能放在类的声明体中声明，成员函数可以在类内实现也可以在类外实现，但在类内实现则形成内联的成员函数，会使类变得冗杂，所以成员函数的实现最好在类外实现，类成员函数可以重载和带默认参数。\n\n## 9.4.类的成员函数与成员变量的声明与实现\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190713104139644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n## 9.5.struct和class的区别\n\n- C++对struct关键字扩展了其功能，和class的功能几乎等价\n- struct的成员默认访问权限是public，而class是private\n\n## 9.6.this指针\n\n- this指针是一个特殊的指针，指向对象的自身的首地址\n- 每一个对象的成员函数都有一个this指针，指向调用的对象，如果要引用整个对象则通过*this引用\n- this指针仅能在类的内部使用，即只能在类的声明体或成员函数中使用\n\n## 9.7.static关键字\n\n### 9.7.1.static修饰的成员变量--静态成员变量\n\n- static修饰的变量存储在静态变量区\n- 在类中static关键字修饰的变量被此类的所有对象共享，即所有对象共享这一个变量\n- static修饰的变量必须在类外初始化，不可以在定义的时候直接初始化\n- static修饰的公有成员变量可以直接通过类名来访问，没有staic修饰的成员变量只能通过对象才能访问\n  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190713105202141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n### 9.7.2.static修饰的成员函数--静态成员函数\n\n- static修饰的成员函数也可以直接通过类名访问\n- 静态成员函数只能访问静态成员变量\n\n### 9.7.3.类的静态与非静态部分\n\n- 静态部分只属于类，与类一起存放在内存的静态区，被所有对象共享\n- 非静态部分属于对象，每个对象都有自己的非静态部分，互不影响\n- 静态部分只能直接访问静态部分，非静态部分可以访问所有部分\n- 那么为什么静态部分只能直接访问静态部分，而非静态部分却可以访问所有部分呢？\n  那是因为，非静态成员变量/函数是属于对象的，只能通过对象来访问，而静态部分是属于类的，使用静态部分时\n\n没有确定对象的存在，所以不能确定静态部分应该访问哪个对象的非静态部分，而静态部分是属于类的，所有对象共享，所以通过对象使用非静态部分时，可以访问静态部分。\n思导图：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190623192350471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190712170853343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n","source":"_posts/【C++】C++进阶.md","raw":"---\ntitle: 【C++】C++进阶\ndate: 2019-08-23 22:27:29\ntags: CPlus\ncategories: 学习笔记\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# ﻿1.C++介绍\n\n​\tC语言作为结构化和模块化语言适合规模较小的程序，对于大规模的复杂程序，能够高度抽象和建模的C++则更加适合，C++是C语言的加强版，以C语言为基础，并且完全兼容C语言的特性。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190623193001260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n# 2.C++对C语言的增强语法\n\n​\t2.1.命名空间\n​\t2.2.引用\n​\t2.3.函数与运算符的重载\n​\t2.4.面向对象的特性\n​\t2.5.泛型编程\n​\t2.6.异常处理\n​\t2.7.标准模板库\n下面笔者就者7个特性进行详细说明：\n\n# 3.命名空间\n\n​\t命名空间是C++提供的一种解决不同文件互相调用时符号名字冲突的方法，一个命名空间就是一个作用域，在不同的命名空间下允许相同的名字符号代表不同的实体。\n\n## 3.1命名空间的定义\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190623200228628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\t\t注意：命名空间的声明要在类和函数的外面定义，并且没有分号结束。\n\n## 3.2.命名空间成员的引用\n\n命名空间名::成员名\n如：\n\n```c++\n//1.cpp\n#include<iostream>\nusing namesapce std;\nnamespace A {\n\tint add(int a,int b);\n}\nint add(int a,int b);\nint mian(){\n\tint a = 1,b = 1;\n\tcout << add(a,b)<<\"  \"<<A::add(a,b)<< endl;\n\treturn 0;\n\t}\nint add(int a,int b){\n\treturn(a + b);\n}\n\n//2.cpp\n#include<iostream>\nnamespace A {\n\tint add(int a,int b){\n\t\treturn(a + b)；\n\t}\n}\n```\n\n命名空间的声明方式，我们需要用到命名空间中的什么方法就在{}内加入什么方法的声明，当然直接使用“using namespace A”来声明A命名空间也是可以的，但是这种命名方法会将A命名空间下的所有方法都作声明，包括我们可能没有使用的方法，当工程很大时，这种做法会导致代码臃肿。\n\n在很多人编程的时候，如果各程序员之间不一直进行密切的交流，极容易出现变量名或方法名类名等相同的情况，这样\t在多文档联合编译时，编译器会无法区分同名符号而报错，而命名空间就很好的解决了这种问题，我们为各个文档都定义一个唯一的命名空间，这样即使是相同符号也可以通过命名空间唯一标识了，命名空间的出现极大的改善了多人编程的困处。\n\n## 3.3.命名空间的别名\n\n命名空间是可以另起别命的，别命是已定义的命名空间的可代替的名字，一个命名空间可以有很多个别名，所有的别命和命名空间原名可以互换使用\n别命的定义：namespace 别命 = 命名空间原名;\n\t![在这里插入图片描述](https://img-blog.csdnimg.cn/2019062320111766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n## 3.4.命名空间的成员类型\n\n命名空间的成员类型可以是变量、常量、函数、结构体、联合体、枚举、类、嵌套的命名空间\n\n## 3.5.全局命名空间\n\n在全局作用域中定义的命名空间，大多数命名空间都属于全局命名空间。即自定义的命名空间是全局命名空间的扩张和细分。全局命名空间是隐式声明的，它存在于每一个程序中。\n由于全局命名空间是隐含的，它没有名字，所以使用“::成员名字”引用全局命名空间。\n\n## 3.6.匿名命名空间\n\n匿名命名空间与全局命名空间类似，也没有名字，但是匿名命名空间定义在局部作用域，不能用于多文件编译。\n匿名命名空间可以直接使用变量名引用成员。\n\n# 4.引用\n\n## 4.1.什么是引用？\n\n引用即别命，是某一个变量或对象的别命，绑定一个引用到一个变量或对象，即引用初始化，之后对引用的操作完全等价于对与其绑定的变量或对象的操作。\n\n## 4.2.引用的定义\n\n类型 &引用名 = 目标变量名;\n需要注意的是：\n\n- &不是求地址运算符，而是起标志作用\n- 引用的类型必须和其所绑定的变量类型相同\n- 声明应用的同时必须对其初始化，否则系统会报错\n- 引用相当于变量或对象的别命，因此不可将已绑定的引用再绑定其他变量或对象，也不可将一个引用绑定另一个引用。\n\n## 4.3.引用与指针的区别\n\n- 占用存储空间上：\n  引用占用一个地址空间，本地计算机的一个地址空间是多少位，引用就占多少位的地址空间。\n  而指针除了占用一个地址空间外，还占用一个数据空间用于存储其指向的变量或对象的地址。\n\n- 在操作上：\n  引用声明的同时必须对其初始化，且初始化后引用不可更改，引用不能为空。如：int &a ;是错误的用法，正确的用法应该是：int &a = b;\n  指针的声明可以在任何时候初始化，且指针在后续操作中可以变更其指向的变量或对象，指针可以为空。\n\n- 存储内容上\n  “sizeof引用”得到的是引用所指向的变量或对象的大小\n  “sizeof指针”得到的是指针本身的大小\n\n- 层级上\n  引用只能有一级，引用不可以再指向引用\n  指针理论上对级数没有限制\n\n- 可以将引用理解为不可更改的指针，即：类型* const 指针变量\n\n## 4.4.对数组的引用\n\n类型 （&引用名）[数组下标] = 数组名;\n如：对int a[3]数组的引用为int (&quote)[3] = a;即将引用名替换成数组名。\n这里要注意，“()”是不能省略的，因为如果省略()，则会改变优先级，变成int &(quote[3]) = a;而出现语法错误。\n\n## 4.5.对指针的引用\n\n类型* &引用名 = 指针名;\n如：int* &quote = p;\n\n## 4.6.引用的作用\n\n引用既可以作为别命使用，还可以作为函数的参数、函数的返回值使用。\n需要注意的是，引用作为函数的返回值时不能返回局部变量的引用。\n至此，我可能提出这样的疑问：引用能做的事指针也能做，引用不能做的事指针还能做，那么C++么什么要引入“引用”这个概念呢？\n这是因为，指针的操作太过于强大，正因如此对指针的使用存在一定的风险，所谓“收益与风险并存”，在很多高版本的编译器中已经不能再操作指针了，如VS2015，而C++之所以还保留着指针，是因为指针的魅力无比诱人，尽管有风险却不愿意就此抛弃。\n引用的另一个用处我们举一个例子来说明\n如：\n\n```c++\nint add_1(int b){\n\tb++;\n}\nint add_2(int &c){\n\tc++;\n}\nvoid mian(){\nint a = 1;\nint &a = a;\ncout<<add_1(a)<<endl;\ncout<<add_2(&a)<<endl;\n}\n```\n\n我们的输出结果是：1 2，为什么呢?因为普通的参数传递，传递的是参数的拷贝，如add_1我们对b++，实际进行运算的是形参b，而实参a却没有发生运算，所以cout<<add_1(a)输出1，而如果传递引用的话，我们在函数add_2中对引用的操作实质上就是对a进行运算，因为&a就是a。\n\n## 4.7.常引用\n\nconst 类型 &引用名 = 目标变量名\n常引用可以引用常量也可以引用变量，常引用不允许通过引用对其绑定的变量或对象进行修改。\n\n## ![在这里插入图片描述](https://img-blog.csdnimg.cn/2019062512243728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n# 5.函数重载\n\n## 5.1.C++重载的实现\n\n从本质上来说，C++之所以能实现函数的重载是因为C++编译器对函数名的处理方法进行了优化，我们来对比一下C语言编译器和C++编译器对函数名的编译\n\n- C语言编译器\n  对函数 int add(int a);编译后的名字为：add\n\n- C++编译器\n  对函数int add(int a);编译后的名字为：addi，对int add(int a,float b);编译后的名字为：addij，C++编译器使用函数名和参数类型的共同组合成编译后函数的唯一标识，即可实现函数的重载。\n\n## 5.2.重载的定义\n\n重载就是在相同的声明域中函数名相同而参数列表不同，通过函数的参数表唯一标识的函数。\n\n## 5.3.函数的默认参数\n\nC++可以使用默认参数，即在函数声明时为参数提供一个默认值，当函数调用时没有指定这个参数的值时，编译器会自动使用默认值替换。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190625221621705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n需要注意的是，默认参数只能放在声明或定义处，能放在声明处就放在声明处。如果某个参数是默认参数，那么其后的参数也必须都是默认参数，如：`int add(int a = 1,int b,int c);`编译器将报错，而`int add(int a,int b = 1,int c = 2);`则不会报错，因为参数在传递的时候是从左到右的，首先使用无默认参数的参数列表，当遇到没有传入实参的形参时开始使用默认参数的参数列表。使用默认参数的情况仅限于用在没有没有重载冲突的函数上，如：重载add函数，`int add(){...} int add(int a = 1,int b = 2){...}`,此时调用add();将调用不带参数的add()函数。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190625222013457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n## 5.4.内联函数\n\n### 5.4.1.为什么需要内联函数？\n\n在程序执行的过程中，当碰到函数调用时，系统要将程序当前状态保存到栈中，同时跳转到函数代码处执行函数体，此过程需要占用时间和空间，是的程序执行效率低下。当然我们声明一个内联函数只是建议编译器将此函数作为内联函数，但是编译器有自己的判断算法，在编译时编译器会自行判断我们声明的内联函数是否值得变为内联函数，以保证主程序体不会过于臃肿，所以我们声明的内联函数不一定会成为内联函数。\n\n### 5.4.2.内联函数的定义\n\ninline 返回值类型 函数名(参数列表){函数体;} \n\n### 5.4.3.内联函数是一种用空间换时间的措施，通常只有较短的函数才定义为内联函数。\n\n# 6.new和delete运算符\n\n## 6.1.new运算符\n\nnew运算符的功能是在堆区分配内存，通过new运算符获得的内存空间都处于堆上。delete运算符的功能正好与new相反，delete运算符的功能是释放new运算符的在堆区创建的内存，new运算符与delete运算符最好是配套出现，即使用new运算符创建了内存就一定要用delete运算符在不需要的时候此内存的时候将其释放，为什么呢？因为堆区的内存是不会随着程序结束而释放的，堆区的内存只要在操作系统关闭时才会释放，所以如果不手动释放new运算符在堆区创建的内存，则会造成大量无用数据占据着堆区内存，当堆区内存被占满时这会出现系统无堆区内存可用而出现系统死机。\n\n## 6.2.new/delete运算符的使用\n\nnew <数据类型> (参数)\ndelete <对象指针>/delete <对象数组指针>\n![在这里插入图片描述](https://img-blog.csdnimg.cn/201907121654256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n## 6.3.那么C++的new/delete与C语言的malloc/free有什么区别呢？\n\n- 它们都是动态管理内存的入口\n- malloc/free是C/C++标准库函数，而new/delete是C++操作符\n- malloc/free只是动态分分配/释放内存空间，而new/delete除了分配内存空间还会调用构造/析构函数进行初始化/清理（清理成员）\n- malloc/free需要手动计算类型大小且返回值为void，而new/delete可以自行计算类型大小返回对应类型的指针\n- new/delete在底层是调用了malloc/free的。可以认为是C++对malloc/free的封装\n- malloc/free申请空间后需要判空，new/delete则不需要\n- new直接跟类型，malloc跟字节数。\n  new/delete和malloc/free的区别是C++企业招聘时特别喜欢考的一项\n\n# 7.程序的内存空间\n\n## 7.1.指针的内存操作\n\n- 指针不仅可以可以指向变量还可以指向函数\n- 有new运算符在堆区创建的内存空间由位于栈区的指针确定入口\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190712165857369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n说到这，我们有必要了解一下计算机程序的内存结构，供程序运行的内存空间分为：堆区、栈区、.data段、.bss段、.ro段、.txt段，我使用一张图来说明\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190712170749180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n# 8.面向对象编程的特点\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2019071310135053.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n# 9.C++中的类\n\n## 9.1.类的定义\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2019071310150942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n## 9.2.访问权限\n\n- C++为类的成员添加了三种访问权限\n  public--公有成员：权限最高，在public修饰下的成员是类的外部接口，可以被类的成员函数和对象直接访问\n- protected--保护成员：权限居中，可以被类的成员函数和其派生类的成员函数直接访问，但不能被类的对象和派生类的对象直接访问。\n- private--私有成员：权限最低，只能通过类的成员函数访问。\n\n## 9.3.类的成员\n\n- 成员变量：类的成员变量用以描述一个对象的属性信息，与一般的变量声明相同，但类的成员变量只能在类的声明体中定义，类的成员变量一般在类的构造函数中初始化，但这不是必须的。\n- 成员函数：用来描述一个对象的行为动作，与一般的函数声明相同，但只能放在类的声明体中声明，成员函数可以在类内实现也可以在类外实现，但在类内实现则形成内联的成员函数，会使类变得冗杂，所以成员函数的实现最好在类外实现，类成员函数可以重载和带默认参数。\n\n## 9.4.类的成员函数与成员变量的声明与实现\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190713104139644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n## 9.5.struct和class的区别\n\n- C++对struct关键字扩展了其功能，和class的功能几乎等价\n- struct的成员默认访问权限是public，而class是private\n\n## 9.6.this指针\n\n- this指针是一个特殊的指针，指向对象的自身的首地址\n- 每一个对象的成员函数都有一个this指针，指向调用的对象，如果要引用整个对象则通过*this引用\n- this指针仅能在类的内部使用，即只能在类的声明体或成员函数中使用\n\n## 9.7.static关键字\n\n### 9.7.1.static修饰的成员变量--静态成员变量\n\n- static修饰的变量存储在静态变量区\n- 在类中static关键字修饰的变量被此类的所有对象共享，即所有对象共享这一个变量\n- static修饰的变量必须在类外初始化，不可以在定义的时候直接初始化\n- static修饰的公有成员变量可以直接通过类名来访问，没有staic修饰的成员变量只能通过对象才能访问\n  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190713105202141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n### 9.7.2.static修饰的成员函数--静态成员函数\n\n- static修饰的成员函数也可以直接通过类名访问\n- 静态成员函数只能访问静态成员变量\n\n### 9.7.3.类的静态与非静态部分\n\n- 静态部分只属于类，与类一起存放在内存的静态区，被所有对象共享\n- 非静态部分属于对象，每个对象都有自己的非静态部分，互不影响\n- 静态部分只能直接访问静态部分，非静态部分可以访问所有部分\n- 那么为什么静态部分只能直接访问静态部分，而非静态部分却可以访问所有部分呢？\n  那是因为，非静态成员变量/函数是属于对象的，只能通过对象来访问，而静态部分是属于类的，使用静态部分时\n\n没有确定对象的存在，所以不能确定静态部分应该访问哪个对象的非静态部分，而静态部分是属于类的，所有对象共享，所以通过对象使用非静态部分时，可以访问静态部分。\n思导图：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190623192350471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190712170853343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70)\n\n","slug":"【C++】C++进阶","published":1,"updated":"2021-03-17T07:18:24.935Z","_id":"ckk9hocbi003idwr74vw2g9xb","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h1 id=\"1-C-介绍\"><a href=\"#1-C-介绍\" class=\"headerlink\" title=\"1.C++介绍\"></a>1.C++介绍</h1><p>​    C语言作为结构化和模块化语言适合规模较小的程序，对于大规模的复杂程序，能够高度抽象和建模的C++则更加适合，C++是C语言的加强版，以C语言为基础，并且完全兼容C语言的特性。<br><img src=\"https://img-blog.csdnimg.cn/20190623193001260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"2-C-对C语言的增强语法\"><a href=\"#2-C-对C语言的增强语法\" class=\"headerlink\" title=\"2.C++对C语言的增强语法\"></a>2.C++对C语言的增强语法</h1><p>​    2.1.命名空间<br>​    2.2.引用<br>​    2.3.函数与运算符的重载<br>​    2.4.面向对象的特性<br>​    2.5.泛型编程<br>​    2.6.异常处理<br>​    2.7.标准模板库<br>下面笔者就者7个特性进行详细说明：</p>\n<h1 id=\"3-命名空间\"><a href=\"#3-命名空间\" class=\"headerlink\" title=\"3.命名空间\"></a>3.命名空间</h1><p>​    命名空间是C++提供的一种解决不同文件互相调用时符号名字冲突的方法，一个命名空间就是一个作用域，在不同的命名空间下允许相同的名字符号代表不同的实体。</p>\n<h2 id=\"3-1命名空间的定义\"><a href=\"#3-1命名空间的定义\" class=\"headerlink\" title=\"3.1命名空间的定义\"></a>3.1命名空间的定义</h2><p><img src=\"https://img-blog.csdnimg.cn/20190623200228628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>        注意：命名空间的声明要在类和函数的外面定义，并且没有分号结束。</p>\n<h2 id=\"3-2-命名空间成员的引用\"><a href=\"#3-2-命名空间成员的引用\" class=\"headerlink\" title=\"3.2.命名空间成员的引用\"></a>3.2.命名空间成员的引用</h2><p>命名空间名::成员名<br>如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//1.cpp</span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> namesapce <span class=\"hljs-built_in\">std</span>;<br><span class=\"hljs-keyword\">namespace</span> A &#123;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a,<span class=\"hljs-keyword\">int</span> b)</span></span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a,<span class=\"hljs-keyword\">int</span> b)</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">mian</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t<span class=\"hljs-keyword\">int</span> a = <span class=\"hljs-number\">1</span>,b = <span class=\"hljs-number\">1</span>;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; add(a,b)&lt;&lt;<span class=\"hljs-string\">&quot;  &quot;</span>&lt;&lt;A::add(a,b)&lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a,<span class=\"hljs-keyword\">int</span> b)</span></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span>(a + b);<br>&#125;<br><br><span class=\"hljs-comment\">//2.cpp</span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">namespace</span> A &#123;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a,<span class=\"hljs-keyword\">int</span> b)</span></span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span>(a + b)；<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>命名空间的声明方式，我们需要用到命名空间中的什么方法就在{}内加入什么方法的声明，当然直接使用“using namespace A”来声明A命名空间也是可以的，但是这种命名方法会将A命名空间下的所有方法都作声明，包括我们可能没有使用的方法，当工程很大时，这种做法会导致代码臃肿。</p>\n<p>在很多人编程的时候，如果各程序员之间不一直进行密切的交流，极容易出现变量名或方法名类名等相同的情况，这样    在多文档联合编译时，编译器会无法区分同名符号而报错，而命名空间就很好的解决了这种问题，我们为各个文档都定义一个唯一的命名空间，这样即使是相同符号也可以通过命名空间唯一标识了，命名空间的出现极大的改善了多人编程的困处。</p>\n<h2 id=\"3-3-命名空间的别名\"><a href=\"#3-3-命名空间的别名\" class=\"headerlink\" title=\"3.3.命名空间的别名\"></a>3.3.命名空间的别名</h2><p>命名空间是可以另起别命的，别命是已定义的命名空间的可代替的名字，一个命名空间可以有很多个别名，所有的别命和命名空间原名可以互换使用<br>别命的定义：namespace 别命 = 命名空间原名;<br>    <img src=\"https://img-blog.csdnimg.cn/2019062320111766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"3-4-命名空间的成员类型\"><a href=\"#3-4-命名空间的成员类型\" class=\"headerlink\" title=\"3.4.命名空间的成员类型\"></a>3.4.命名空间的成员类型</h2><p>命名空间的成员类型可以是变量、常量、函数、结构体、联合体、枚举、类、嵌套的命名空间</p>\n<h2 id=\"3-5-全局命名空间\"><a href=\"#3-5-全局命名空间\" class=\"headerlink\" title=\"3.5.全局命名空间\"></a>3.5.全局命名空间</h2><p>在全局作用域中定义的命名空间，大多数命名空间都属于全局命名空间。即自定义的命名空间是全局命名空间的扩张和细分。全局命名空间是隐式声明的，它存在于每一个程序中。<br>由于全局命名空间是隐含的，它没有名字，所以使用“::成员名字”引用全局命名空间。</p>\n<h2 id=\"3-6-匿名命名空间\"><a href=\"#3-6-匿名命名空间\" class=\"headerlink\" title=\"3.6.匿名命名空间\"></a>3.6.匿名命名空间</h2><p>匿名命名空间与全局命名空间类似，也没有名字，但是匿名命名空间定义在局部作用域，不能用于多文件编译。<br>匿名命名空间可以直接使用变量名引用成员。</p>\n<h1 id=\"4-引用\"><a href=\"#4-引用\" class=\"headerlink\" title=\"4.引用\"></a>4.引用</h1><h2 id=\"4-1-什么是引用？\"><a href=\"#4-1-什么是引用？\" class=\"headerlink\" title=\"4.1.什么是引用？\"></a>4.1.什么是引用？</h2><p>引用即别命，是某一个变量或对象的别命，绑定一个引用到一个变量或对象，即引用初始化，之后对引用的操作完全等价于对与其绑定的变量或对象的操作。</p>\n<h2 id=\"4-2-引用的定义\"><a href=\"#4-2-引用的定义\" class=\"headerlink\" title=\"4.2.引用的定义\"></a>4.2.引用的定义</h2><p>类型 &amp;引用名 = 目标变量名;<br>需要注意的是：</p>\n<ul>\n<li>&amp;不是求地址运算符，而是起标志作用</li>\n<li>引用的类型必须和其所绑定的变量类型相同</li>\n<li>声明应用的同时必须对其初始化，否则系统会报错</li>\n<li>引用相当于变量或对象的别命，因此不可将已绑定的引用再绑定其他变量或对象，也不可将一个引用绑定另一个引用。</li>\n</ul>\n<h2 id=\"4-3-引用与指针的区别\"><a href=\"#4-3-引用与指针的区别\" class=\"headerlink\" title=\"4.3.引用与指针的区别\"></a>4.3.引用与指针的区别</h2><ul>\n<li><p>占用存储空间上：<br>引用占用一个地址空间，本地计算机的一个地址空间是多少位，引用就占多少位的地址空间。<br>而指针除了占用一个地址空间外，还占用一个数据空间用于存储其指向的变量或对象的地址。</p>\n</li>\n<li><p>在操作上：<br>引用声明的同时必须对其初始化，且初始化后引用不可更改，引用不能为空。如：int &amp;a ;是错误的用法，正确的用法应该是：int &amp;a = b;<br>指针的声明可以在任何时候初始化，且指针在后续操作中可以变更其指向的变量或对象，指针可以为空。</p>\n</li>\n<li><p>存储内容上<br>“sizeof引用”得到的是引用所指向的变量或对象的大小<br>“sizeof指针”得到的是指针本身的大小</p>\n</li>\n<li><p>层级上<br>引用只能有一级，引用不可以再指向引用<br>指针理论上对级数没有限制</p>\n</li>\n<li><p>可以将引用理解为不可更改的指针，即：类型* const 指针变量</p>\n</li>\n</ul>\n<h2 id=\"4-4-对数组的引用\"><a href=\"#4-4-对数组的引用\" class=\"headerlink\" title=\"4.4.对数组的引用\"></a>4.4.对数组的引用</h2><p>类型 （&amp;引用名）[数组下标] = 数组名;<br>如：对int a[3]数组的引用为int (&amp;quote)[3] = a;即将引用名替换成数组名。<br>这里要注意，“()”是不能省略的，因为如果省略()，则会改变优先级，变成int &amp;(quote[3]) = a;而出现语法错误。</p>\n<h2 id=\"4-5-对指针的引用\"><a href=\"#4-5-对指针的引用\" class=\"headerlink\" title=\"4.5.对指针的引用\"></a>4.5.对指针的引用</h2><p>类型* &amp;引用名 = 指针名;<br>如：int* &amp;quote = p;</p>\n<h2 id=\"4-6-引用的作用\"><a href=\"#4-6-引用的作用\" class=\"headerlink\" title=\"4.6.引用的作用\"></a>4.6.引用的作用</h2><p>引用既可以作为别命使用，还可以作为函数的参数、函数的返回值使用。<br>需要注意的是，引用作为函数的返回值时不能返回局部变量的引用。<br>至此，我可能提出这样的疑问：引用能做的事指针也能做，引用不能做的事指针还能做，那么C++么什么要引入“引用”这个概念呢？<br>这是因为，指针的操作太过于强大，正因如此对指针的使用存在一定的风险，所谓“收益与风险并存”，在很多高版本的编译器中已经不能再操作指针了，如VS2015，而C++之所以还保留着指针，是因为指针的魅力无比诱人，尽管有风险却不愿意就此抛弃。<br>引用的另一个用处我们举一个例子来说明<br>如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">add_1</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> b)</span></span>&#123;<br>\tb++;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">add_2</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> &amp;c)</span></span>&#123;<br>\tc++;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">mian</span><span class=\"hljs-params\">()</span></span>&#123;<br><span class=\"hljs-keyword\">int</span> a = <span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">int</span> &amp;a = a;<br><span class=\"hljs-built_in\">cout</span>&lt;&lt;add_1(a)&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span>&lt;&lt;add_2(&amp;a)&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>我们的输出结果是：1 2，为什么呢?因为普通的参数传递，传递的是参数的拷贝，如add_1我们对b++，实际进行运算的是形参b，而实参a却没有发生运算，所以cout&lt;&lt;add_1(a)输出1，而如果传递引用的话，我们在函数add_2中对引用的操作实质上就是对a进行运算，因为&amp;a就是a。</p>\n<h2 id=\"4-7-常引用\"><a href=\"#4-7-常引用\" class=\"headerlink\" title=\"4.7.常引用\"></a>4.7.常引用</h2><p>const 类型 &amp;引用名 = 目标变量名<br>常引用可以引用常量也可以引用变量，常引用不允许通过引用对其绑定的变量或对象进行修改。</p>\n<h2 id><a href=\"#\" class=\"headerlink\" title></a><img src=\"https://img-blog.csdnimg.cn/2019062512243728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></h2><h1 id=\"5-函数重载\"><a href=\"#5-函数重载\" class=\"headerlink\" title=\"5.函数重载\"></a>5.函数重载</h1><h2 id=\"5-1-C-重载的实现\"><a href=\"#5-1-C-重载的实现\" class=\"headerlink\" title=\"5.1.C++重载的实现\"></a>5.1.C++重载的实现</h2><p>从本质上来说，C++之所以能实现函数的重载是因为C++编译器对函数名的处理方法进行了优化，我们来对比一下C语言编译器和C++编译器对函数名的编译</p>\n<ul>\n<li><p>C语言编译器<br>对函数 int add(int a);编译后的名字为：add</p>\n</li>\n<li><p>C++编译器<br>对函数int add(int a);编译后的名字为：addi，对int add(int a,float b);编译后的名字为：addij，C++编译器使用函数名和参数类型的共同组合成编译后函数的唯一标识，即可实现函数的重载。</p>\n</li>\n</ul>\n<h2 id=\"5-2-重载的定义\"><a href=\"#5-2-重载的定义\" class=\"headerlink\" title=\"5.2.重载的定义\"></a>5.2.重载的定义</h2><p>重载就是在相同的声明域中函数名相同而参数列表不同，通过函数的参数表唯一标识的函数。</p>\n<h2 id=\"5-3-函数的默认参数\"><a href=\"#5-3-函数的默认参数\" class=\"headerlink\" title=\"5.3.函数的默认参数\"></a>5.3.函数的默认参数</h2><p>C++可以使用默认参数，即在函数声明时为参数提供一个默认值，当函数调用时没有指定这个参数的值时，编译器会自动使用默认值替换。<br><img src=\"https://img-blog.csdnimg.cn/20190625221621705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>需要注意的是，默认参数只能放在声明或定义处，能放在声明处就放在声明处。如果某个参数是默认参数，那么其后的参数也必须都是默认参数，如：<code>int add(int a = 1,int b,int c);</code>编译器将报错，而<code>int add(int a,int b = 1,int c = 2);</code>则不会报错，因为参数在传递的时候是从左到右的，首先使用无默认参数的参数列表，当遇到没有传入实参的形参时开始使用默认参数的参数列表。使用默认参数的情况仅限于用在没有没有重载冲突的函数上，如：重载add函数，<code>int add()&#123;...&#125; int add(int a = 1,int b = 2)&#123;...&#125;</code>,此时调用add();将调用不带参数的add()函数。<br><img src=\"https://img-blog.csdnimg.cn/20190625222013457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"5-4-内联函数\"><a href=\"#5-4-内联函数\" class=\"headerlink\" title=\"5.4.内联函数\"></a>5.4.内联函数</h2><h3 id=\"5-4-1-为什么需要内联函数？\"><a href=\"#5-4-1-为什么需要内联函数？\" class=\"headerlink\" title=\"5.4.1.为什么需要内联函数？\"></a>5.4.1.为什么需要内联函数？</h3><p>在程序执行的过程中，当碰到函数调用时，系统要将程序当前状态保存到栈中，同时跳转到函数代码处执行函数体，此过程需要占用时间和空间，是的程序执行效率低下。当然我们声明一个内联函数只是建议编译器将此函数作为内联函数，但是编译器有自己的判断算法，在编译时编译器会自行判断我们声明的内联函数是否值得变为内联函数，以保证主程序体不会过于臃肿，所以我们声明的内联函数不一定会成为内联函数。</p>\n<h3 id=\"5-4-2-内联函数的定义\"><a href=\"#5-4-2-内联函数的定义\" class=\"headerlink\" title=\"5.4.2.内联函数的定义\"></a>5.4.2.内联函数的定义</h3><p>inline 返回值类型 函数名(参数列表){函数体;} </p>\n<h3 id=\"5-4-3-内联函数是一种用空间换时间的措施，通常只有较短的函数才定义为内联函数。\"><a href=\"#5-4-3-内联函数是一种用空间换时间的措施，通常只有较短的函数才定义为内联函数。\" class=\"headerlink\" title=\"5.4.3.内联函数是一种用空间换时间的措施，通常只有较短的函数才定义为内联函数。\"></a>5.4.3.内联函数是一种用空间换时间的措施，通常只有较短的函数才定义为内联函数。</h3><h1 id=\"6-new和delete运算符\"><a href=\"#6-new和delete运算符\" class=\"headerlink\" title=\"6.new和delete运算符\"></a>6.new和delete运算符</h1><h2 id=\"6-1-new运算符\"><a href=\"#6-1-new运算符\" class=\"headerlink\" title=\"6.1.new运算符\"></a>6.1.new运算符</h2><p>new运算符的功能是在堆区分配内存，通过new运算符获得的内存空间都处于堆上。delete运算符的功能正好与new相反，delete运算符的功能是释放new运算符的在堆区创建的内存，new运算符与delete运算符最好是配套出现，即使用new运算符创建了内存就一定要用delete运算符在不需要的时候此内存的时候将其释放，为什么呢？因为堆区的内存是不会随着程序结束而释放的，堆区的内存只要在操作系统关闭时才会释放，所以如果不手动释放new运算符在堆区创建的内存，则会造成大量无用数据占据着堆区内存，当堆区内存被占满时这会出现系统无堆区内存可用而出现系统死机。</p>\n<h2 id=\"6-2-new-delete运算符的使用\"><a href=\"#6-2-new-delete运算符的使用\" class=\"headerlink\" title=\"6.2.new/delete运算符的使用\"></a>6.2.new/delete运算符的使用</h2><p>new &lt;数据类型&gt; (参数)<br>delete &lt;对象指针&gt;/delete &lt;对象数组指针&gt;<br><img src=\"https://img-blog.csdnimg.cn/201907121654256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"6-3-那么C-的new-delete与C语言的malloc-free有什么区别呢？\"><a href=\"#6-3-那么C-的new-delete与C语言的malloc-free有什么区别呢？\" class=\"headerlink\" title=\"6.3.那么C++的new/delete与C语言的malloc/free有什么区别呢？\"></a>6.3.那么C++的new/delete与C语言的malloc/free有什么区别呢？</h2><ul>\n<li>它们都是动态管理内存的入口</li>\n<li>malloc/free是C/C++标准库函数，而new/delete是C++操作符</li>\n<li>malloc/free只是动态分分配/释放内存空间，而new/delete除了分配内存空间还会调用构造/析构函数进行初始化/清理（清理成员）</li>\n<li>malloc/free需要手动计算类型大小且返回值为void，而new/delete可以自行计算类型大小返回对应类型的指针</li>\n<li>new/delete在底层是调用了malloc/free的。可以认为是C++对malloc/free的封装</li>\n<li>malloc/free申请空间后需要判空，new/delete则不需要</li>\n<li>new直接跟类型，malloc跟字节数。<br>new/delete和malloc/free的区别是C++企业招聘时特别喜欢考的一项</li>\n</ul>\n<h1 id=\"7-程序的内存空间\"><a href=\"#7-程序的内存空间\" class=\"headerlink\" title=\"7.程序的内存空间\"></a>7.程序的内存空间</h1><h2 id=\"7-1-指针的内存操作\"><a href=\"#7-1-指针的内存操作\" class=\"headerlink\" title=\"7.1.指针的内存操作\"></a>7.1.指针的内存操作</h2><ul>\n<li>指针不仅可以可以指向变量还可以指向函数</li>\n<li>有new运算符在堆区创建的内存空间由位于栈区的指针确定入口</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/20190712165857369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>说到这，我们有必要了解一下计算机程序的内存结构，供程序运行的内存空间分为：堆区、栈区、.data段、.bss段、.ro段、.txt段，我使用一张图来说明<br><img src=\"https://img-blog.csdnimg.cn/20190712170749180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"8-面向对象编程的特点\"><a href=\"#8-面向对象编程的特点\" class=\"headerlink\" title=\"8.面向对象编程的特点\"></a>8.面向对象编程的特点</h1><p><img src=\"https://img-blog.csdnimg.cn/2019071310135053.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"9-C-中的类\"><a href=\"#9-C-中的类\" class=\"headerlink\" title=\"9.C++中的类\"></a>9.C++中的类</h1><h2 id=\"9-1-类的定义\"><a href=\"#9-1-类的定义\" class=\"headerlink\" title=\"9.1.类的定义\"></a>9.1.类的定义</h2><p><img src=\"https://img-blog.csdnimg.cn/2019071310150942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"9-2-访问权限\"><a href=\"#9-2-访问权限\" class=\"headerlink\" title=\"9.2.访问权限\"></a>9.2.访问权限</h2><ul>\n<li>C++为类的成员添加了三种访问权限<br>public–公有成员：权限最高，在public修饰下的成员是类的外部接口，可以被类的成员函数和对象直接访问</li>\n<li>protected–保护成员：权限居中，可以被类的成员函数和其派生类的成员函数直接访问，但不能被类的对象和派生类的对象直接访问。</li>\n<li>private–私有成员：权限最低，只能通过类的成员函数访问。</li>\n</ul>\n<h2 id=\"9-3-类的成员\"><a href=\"#9-3-类的成员\" class=\"headerlink\" title=\"9.3.类的成员\"></a>9.3.类的成员</h2><ul>\n<li>成员变量：类的成员变量用以描述一个对象的属性信息，与一般的变量声明相同，但类的成员变量只能在类的声明体中定义，类的成员变量一般在类的构造函数中初始化，但这不是必须的。</li>\n<li>成员函数：用来描述一个对象的行为动作，与一般的函数声明相同，但只能放在类的声明体中声明，成员函数可以在类内实现也可以在类外实现，但在类内实现则形成内联的成员函数，会使类变得冗杂，所以成员函数的实现最好在类外实现，类成员函数可以重载和带默认参数。</li>\n</ul>\n<h2 id=\"9-4-类的成员函数与成员变量的声明与实现\"><a href=\"#9-4-类的成员函数与成员变量的声明与实现\" class=\"headerlink\" title=\"9.4.类的成员函数与成员变量的声明与实现\"></a>9.4.类的成员函数与成员变量的声明与实现</h2><p><img src=\"https://img-blog.csdnimg.cn/20190713104139644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"9-5-struct和class的区别\"><a href=\"#9-5-struct和class的区别\" class=\"headerlink\" title=\"9.5.struct和class的区别\"></a>9.5.struct和class的区别</h2><ul>\n<li>C++对struct关键字扩展了其功能，和class的功能几乎等价</li>\n<li>struct的成员默认访问权限是public，而class是private</li>\n</ul>\n<h2 id=\"9-6-this指针\"><a href=\"#9-6-this指针\" class=\"headerlink\" title=\"9.6.this指针\"></a>9.6.this指针</h2><ul>\n<li>this指针是一个特殊的指针，指向对象的自身的首地址</li>\n<li>每一个对象的成员函数都有一个this指针，指向调用的对象，如果要引用整个对象则通过*this引用</li>\n<li>this指针仅能在类的内部使用，即只能在类的声明体或成员函数中使用</li>\n</ul>\n<h2 id=\"9-7-static关键字\"><a href=\"#9-7-static关键字\" class=\"headerlink\" title=\"9.7.static关键字\"></a>9.7.static关键字</h2><h3 id=\"9-7-1-static修饰的成员变量–静态成员变量\"><a href=\"#9-7-1-static修饰的成员变量–静态成员变量\" class=\"headerlink\" title=\"9.7.1.static修饰的成员变量–静态成员变量\"></a>9.7.1.static修饰的成员变量–静态成员变量</h3><ul>\n<li>static修饰的变量存储在静态变量区</li>\n<li>在类中static关键字修饰的变量被此类的所有对象共享，即所有对象共享这一个变量</li>\n<li>static修饰的变量必须在类外初始化，不可以在定义的时候直接初始化</li>\n<li>static修饰的公有成员变量可以直接通过类名来访问，没有staic修饰的成员变量只能通过对象才能访问<br><img src=\"https://img-blog.csdnimg.cn/20190713105202141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></li>\n</ul>\n<h3 id=\"9-7-2-static修饰的成员函数–静态成员函数\"><a href=\"#9-7-2-static修饰的成员函数–静态成员函数\" class=\"headerlink\" title=\"9.7.2.static修饰的成员函数–静态成员函数\"></a>9.7.2.static修饰的成员函数–静态成员函数</h3><ul>\n<li>static修饰的成员函数也可以直接通过类名访问</li>\n<li>静态成员函数只能访问静态成员变量</li>\n</ul>\n<h3 id=\"9-7-3-类的静态与非静态部分\"><a href=\"#9-7-3-类的静态与非静态部分\" class=\"headerlink\" title=\"9.7.3.类的静态与非静态部分\"></a>9.7.3.类的静态与非静态部分</h3><ul>\n<li>静态部分只属于类，与类一起存放在内存的静态区，被所有对象共享</li>\n<li>非静态部分属于对象，每个对象都有自己的非静态部分，互不影响</li>\n<li>静态部分只能直接访问静态部分，非静态部分可以访问所有部分</li>\n<li>那么为什么静态部分只能直接访问静态部分，而非静态部分却可以访问所有部分呢？<br>那是因为，非静态成员变量/函数是属于对象的，只能通过对象来访问，而静态部分是属于类的，使用静态部分时</li>\n</ul>\n<p>没有确定对象的存在，所以不能确定静态部分应该访问哪个对象的非静态部分，而静态部分是属于类的，所有对象共享，所以通过对象使用非静态部分时，可以访问静态部分。<br>思导图：<br><img src=\"https://img-blog.csdnimg.cn/20190623192350471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/20190712170853343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h1 id=\"1-C-介绍\"><a href=\"#1-C-介绍\" class=\"headerlink\" title=\"1.C++介绍\"></a>1.C++介绍</h1><p>​    C语言作为结构化和模块化语言适合规模较小的程序，对于大规模的复杂程序，能够高度抽象和建模的C++则更加适合，C++是C语言的加强版，以C语言为基础，并且完全兼容C语言的特性。<br><img src=\"https://img-blog.csdnimg.cn/20190623193001260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"2-C-对C语言的增强语法\"><a href=\"#2-C-对C语言的增强语法\" class=\"headerlink\" title=\"2.C++对C语言的增强语法\"></a>2.C++对C语言的增强语法</h1><p>​    2.1.命名空间<br>​    2.2.引用<br>​    2.3.函数与运算符的重载<br>​    2.4.面向对象的特性<br>​    2.5.泛型编程<br>​    2.6.异常处理<br>​    2.7.标准模板库<br>下面笔者就者7个特性进行详细说明：</p>\n<h1 id=\"3-命名空间\"><a href=\"#3-命名空间\" class=\"headerlink\" title=\"3.命名空间\"></a>3.命名空间</h1><p>​    命名空间是C++提供的一种解决不同文件互相调用时符号名字冲突的方法，一个命名空间就是一个作用域，在不同的命名空间下允许相同的名字符号代表不同的实体。</p>\n<h2 id=\"3-1命名空间的定义\"><a href=\"#3-1命名空间的定义\" class=\"headerlink\" title=\"3.1命名空间的定义\"></a>3.1命名空间的定义</h2><p><img src=\"https://img-blog.csdnimg.cn/20190623200228628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>        注意：命名空间的声明要在类和函数的外面定义，并且没有分号结束。</p>\n<h2 id=\"3-2-命名空间成员的引用\"><a href=\"#3-2-命名空间成员的引用\" class=\"headerlink\" title=\"3.2.命名空间成员的引用\"></a>3.2.命名空间成员的引用</h2><p>命名空间名::成员名<br>如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//1.cpp</span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> namesapce <span class=\"hljs-built_in\">std</span>;<br><span class=\"hljs-keyword\">namespace</span> A &#123;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a,<span class=\"hljs-keyword\">int</span> b)</span></span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a,<span class=\"hljs-keyword\">int</span> b)</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">mian</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t<span class=\"hljs-keyword\">int</span> a = <span class=\"hljs-number\">1</span>,b = <span class=\"hljs-number\">1</span>;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; add(a,b)&lt;&lt;<span class=\"hljs-string\">&quot;  &quot;</span>&lt;&lt;A::add(a,b)&lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a,<span class=\"hljs-keyword\">int</span> b)</span></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span>(a + b);<br>&#125;<br><br><span class=\"hljs-comment\">//2.cpp</span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">namespace</span> A &#123;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a,<span class=\"hljs-keyword\">int</span> b)</span></span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span>(a + b)；<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>命名空间的声明方式，我们需要用到命名空间中的什么方法就在{}内加入什么方法的声明，当然直接使用“using namespace A”来声明A命名空间也是可以的，但是这种命名方法会将A命名空间下的所有方法都作声明，包括我们可能没有使用的方法，当工程很大时，这种做法会导致代码臃肿。</p>\n<p>在很多人编程的时候，如果各程序员之间不一直进行密切的交流，极容易出现变量名或方法名类名等相同的情况，这样    在多文档联合编译时，编译器会无法区分同名符号而报错，而命名空间就很好的解决了这种问题，我们为各个文档都定义一个唯一的命名空间，这样即使是相同符号也可以通过命名空间唯一标识了，命名空间的出现极大的改善了多人编程的困处。</p>\n<h2 id=\"3-3-命名空间的别名\"><a href=\"#3-3-命名空间的别名\" class=\"headerlink\" title=\"3.3.命名空间的别名\"></a>3.3.命名空间的别名</h2><p>命名空间是可以另起别命的，别命是已定义的命名空间的可代替的名字，一个命名空间可以有很多个别名，所有的别命和命名空间原名可以互换使用<br>别命的定义：namespace 别命 = 命名空间原名;<br>    <img src=\"https://img-blog.csdnimg.cn/2019062320111766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"3-4-命名空间的成员类型\"><a href=\"#3-4-命名空间的成员类型\" class=\"headerlink\" title=\"3.4.命名空间的成员类型\"></a>3.4.命名空间的成员类型</h2><p>命名空间的成员类型可以是变量、常量、函数、结构体、联合体、枚举、类、嵌套的命名空间</p>\n<h2 id=\"3-5-全局命名空间\"><a href=\"#3-5-全局命名空间\" class=\"headerlink\" title=\"3.5.全局命名空间\"></a>3.5.全局命名空间</h2><p>在全局作用域中定义的命名空间，大多数命名空间都属于全局命名空间。即自定义的命名空间是全局命名空间的扩张和细分。全局命名空间是隐式声明的，它存在于每一个程序中。<br>由于全局命名空间是隐含的，它没有名字，所以使用“::成员名字”引用全局命名空间。</p>\n<h2 id=\"3-6-匿名命名空间\"><a href=\"#3-6-匿名命名空间\" class=\"headerlink\" title=\"3.6.匿名命名空间\"></a>3.6.匿名命名空间</h2><p>匿名命名空间与全局命名空间类似，也没有名字，但是匿名命名空间定义在局部作用域，不能用于多文件编译。<br>匿名命名空间可以直接使用变量名引用成员。</p>\n<h1 id=\"4-引用\"><a href=\"#4-引用\" class=\"headerlink\" title=\"4.引用\"></a>4.引用</h1><h2 id=\"4-1-什么是引用？\"><a href=\"#4-1-什么是引用？\" class=\"headerlink\" title=\"4.1.什么是引用？\"></a>4.1.什么是引用？</h2><p>引用即别命，是某一个变量或对象的别命，绑定一个引用到一个变量或对象，即引用初始化，之后对引用的操作完全等价于对与其绑定的变量或对象的操作。</p>\n<h2 id=\"4-2-引用的定义\"><a href=\"#4-2-引用的定义\" class=\"headerlink\" title=\"4.2.引用的定义\"></a>4.2.引用的定义</h2><p>类型 &amp;引用名 = 目标变量名;<br>需要注意的是：</p>\n<ul>\n<li>&amp;不是求地址运算符，而是起标志作用</li>\n<li>引用的类型必须和其所绑定的变量类型相同</li>\n<li>声明应用的同时必须对其初始化，否则系统会报错</li>\n<li>引用相当于变量或对象的别命，因此不可将已绑定的引用再绑定其他变量或对象，也不可将一个引用绑定另一个引用。</li>\n</ul>\n<h2 id=\"4-3-引用与指针的区别\"><a href=\"#4-3-引用与指针的区别\" class=\"headerlink\" title=\"4.3.引用与指针的区别\"></a>4.3.引用与指针的区别</h2><ul>\n<li><p>占用存储空间上：<br>引用占用一个地址空间，本地计算机的一个地址空间是多少位，引用就占多少位的地址空间。<br>而指针除了占用一个地址空间外，还占用一个数据空间用于存储其指向的变量或对象的地址。</p>\n</li>\n<li><p>在操作上：<br>引用声明的同时必须对其初始化，且初始化后引用不可更改，引用不能为空。如：int &amp;a ;是错误的用法，正确的用法应该是：int &amp;a = b;<br>指针的声明可以在任何时候初始化，且指针在后续操作中可以变更其指向的变量或对象，指针可以为空。</p>\n</li>\n<li><p>存储内容上<br>“sizeof引用”得到的是引用所指向的变量或对象的大小<br>“sizeof指针”得到的是指针本身的大小</p>\n</li>\n<li><p>层级上<br>引用只能有一级，引用不可以再指向引用<br>指针理论上对级数没有限制</p>\n</li>\n<li><p>可以将引用理解为不可更改的指针，即：类型* const 指针变量</p>\n</li>\n</ul>\n<h2 id=\"4-4-对数组的引用\"><a href=\"#4-4-对数组的引用\" class=\"headerlink\" title=\"4.4.对数组的引用\"></a>4.4.对数组的引用</h2><p>类型 （&amp;引用名）[数组下标] = 数组名;<br>如：对int a[3]数组的引用为int (&amp;quote)[3] = a;即将引用名替换成数组名。<br>这里要注意，“()”是不能省略的，因为如果省略()，则会改变优先级，变成int &amp;(quote[3]) = a;而出现语法错误。</p>\n<h2 id=\"4-5-对指针的引用\"><a href=\"#4-5-对指针的引用\" class=\"headerlink\" title=\"4.5.对指针的引用\"></a>4.5.对指针的引用</h2><p>类型* &amp;引用名 = 指针名;<br>如：int* &amp;quote = p;</p>\n<h2 id=\"4-6-引用的作用\"><a href=\"#4-6-引用的作用\" class=\"headerlink\" title=\"4.6.引用的作用\"></a>4.6.引用的作用</h2><p>引用既可以作为别命使用，还可以作为函数的参数、函数的返回值使用。<br>需要注意的是，引用作为函数的返回值时不能返回局部变量的引用。<br>至此，我可能提出这样的疑问：引用能做的事指针也能做，引用不能做的事指针还能做，那么C++么什么要引入“引用”这个概念呢？<br>这是因为，指针的操作太过于强大，正因如此对指针的使用存在一定的风险，所谓“收益与风险并存”，在很多高版本的编译器中已经不能再操作指针了，如VS2015，而C++之所以还保留着指针，是因为指针的魅力无比诱人，尽管有风险却不愿意就此抛弃。<br>引用的另一个用处我们举一个例子来说明<br>如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">add_1</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> b)</span></span>&#123;<br>\tb++;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">add_2</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> &amp;c)</span></span>&#123;<br>\tc++;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">mian</span><span class=\"hljs-params\">()</span></span>&#123;<br><span class=\"hljs-keyword\">int</span> a = <span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">int</span> &amp;a = a;<br><span class=\"hljs-built_in\">cout</span>&lt;&lt;add_1(a)&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span>&lt;&lt;add_2(&amp;a)&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>我们的输出结果是：1 2，为什么呢?因为普通的参数传递，传递的是参数的拷贝，如add_1我们对b++，实际进行运算的是形参b，而实参a却没有发生运算，所以cout&lt;&lt;add_1(a)输出1，而如果传递引用的话，我们在函数add_2中对引用的操作实质上就是对a进行运算，因为&amp;a就是a。</p>\n<h2 id=\"4-7-常引用\"><a href=\"#4-7-常引用\" class=\"headerlink\" title=\"4.7.常引用\"></a>4.7.常引用</h2><p>const 类型 &amp;引用名 = 目标变量名<br>常引用可以引用常量也可以引用变量，常引用不允许通过引用对其绑定的变量或对象进行修改。</p>\n<h2 id><a href=\"#\" class=\"headerlink\" title></a><img src=\"https://img-blog.csdnimg.cn/2019062512243728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></h2><h1 id=\"5-函数重载\"><a href=\"#5-函数重载\" class=\"headerlink\" title=\"5.函数重载\"></a>5.函数重载</h1><h2 id=\"5-1-C-重载的实现\"><a href=\"#5-1-C-重载的实现\" class=\"headerlink\" title=\"5.1.C++重载的实现\"></a>5.1.C++重载的实现</h2><p>从本质上来说，C++之所以能实现函数的重载是因为C++编译器对函数名的处理方法进行了优化，我们来对比一下C语言编译器和C++编译器对函数名的编译</p>\n<ul>\n<li><p>C语言编译器<br>对函数 int add(int a);编译后的名字为：add</p>\n</li>\n<li><p>C++编译器<br>对函数int add(int a);编译后的名字为：addi，对int add(int a,float b);编译后的名字为：addij，C++编译器使用函数名和参数类型的共同组合成编译后函数的唯一标识，即可实现函数的重载。</p>\n</li>\n</ul>\n<h2 id=\"5-2-重载的定义\"><a href=\"#5-2-重载的定义\" class=\"headerlink\" title=\"5.2.重载的定义\"></a>5.2.重载的定义</h2><p>重载就是在相同的声明域中函数名相同而参数列表不同，通过函数的参数表唯一标识的函数。</p>\n<h2 id=\"5-3-函数的默认参数\"><a href=\"#5-3-函数的默认参数\" class=\"headerlink\" title=\"5.3.函数的默认参数\"></a>5.3.函数的默认参数</h2><p>C++可以使用默认参数，即在函数声明时为参数提供一个默认值，当函数调用时没有指定这个参数的值时，编译器会自动使用默认值替换。<br><img src=\"https://img-blog.csdnimg.cn/20190625221621705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>需要注意的是，默认参数只能放在声明或定义处，能放在声明处就放在声明处。如果某个参数是默认参数，那么其后的参数也必须都是默认参数，如：<code>int add(int a = 1,int b,int c);</code>编译器将报错，而<code>int add(int a,int b = 1,int c = 2);</code>则不会报错，因为参数在传递的时候是从左到右的，首先使用无默认参数的参数列表，当遇到没有传入实参的形参时开始使用默认参数的参数列表。使用默认参数的情况仅限于用在没有没有重载冲突的函数上，如：重载add函数，<code>int add()&#123;...&#125; int add(int a = 1,int b = 2)&#123;...&#125;</code>,此时调用add();将调用不带参数的add()函数。<br><img src=\"https://img-blog.csdnimg.cn/20190625222013457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"5-4-内联函数\"><a href=\"#5-4-内联函数\" class=\"headerlink\" title=\"5.4.内联函数\"></a>5.4.内联函数</h2><h3 id=\"5-4-1-为什么需要内联函数？\"><a href=\"#5-4-1-为什么需要内联函数？\" class=\"headerlink\" title=\"5.4.1.为什么需要内联函数？\"></a>5.4.1.为什么需要内联函数？</h3><p>在程序执行的过程中，当碰到函数调用时，系统要将程序当前状态保存到栈中，同时跳转到函数代码处执行函数体，此过程需要占用时间和空间，是的程序执行效率低下。当然我们声明一个内联函数只是建议编译器将此函数作为内联函数，但是编译器有自己的判断算法，在编译时编译器会自行判断我们声明的内联函数是否值得变为内联函数，以保证主程序体不会过于臃肿，所以我们声明的内联函数不一定会成为内联函数。</p>\n<h3 id=\"5-4-2-内联函数的定义\"><a href=\"#5-4-2-内联函数的定义\" class=\"headerlink\" title=\"5.4.2.内联函数的定义\"></a>5.4.2.内联函数的定义</h3><p>inline 返回值类型 函数名(参数列表){函数体;} </p>\n<h3 id=\"5-4-3-内联函数是一种用空间换时间的措施，通常只有较短的函数才定义为内联函数。\"><a href=\"#5-4-3-内联函数是一种用空间换时间的措施，通常只有较短的函数才定义为内联函数。\" class=\"headerlink\" title=\"5.4.3.内联函数是一种用空间换时间的措施，通常只有较短的函数才定义为内联函数。\"></a>5.4.3.内联函数是一种用空间换时间的措施，通常只有较短的函数才定义为内联函数。</h3><h1 id=\"6-new和delete运算符\"><a href=\"#6-new和delete运算符\" class=\"headerlink\" title=\"6.new和delete运算符\"></a>6.new和delete运算符</h1><h2 id=\"6-1-new运算符\"><a href=\"#6-1-new运算符\" class=\"headerlink\" title=\"6.1.new运算符\"></a>6.1.new运算符</h2><p>new运算符的功能是在堆区分配内存，通过new运算符获得的内存空间都处于堆上。delete运算符的功能正好与new相反，delete运算符的功能是释放new运算符的在堆区创建的内存，new运算符与delete运算符最好是配套出现，即使用new运算符创建了内存就一定要用delete运算符在不需要的时候此内存的时候将其释放，为什么呢？因为堆区的内存是不会随着程序结束而释放的，堆区的内存只要在操作系统关闭时才会释放，所以如果不手动释放new运算符在堆区创建的内存，则会造成大量无用数据占据着堆区内存，当堆区内存被占满时这会出现系统无堆区内存可用而出现系统死机。</p>\n<h2 id=\"6-2-new-delete运算符的使用\"><a href=\"#6-2-new-delete运算符的使用\" class=\"headerlink\" title=\"6.2.new/delete运算符的使用\"></a>6.2.new/delete运算符的使用</h2><p>new &lt;数据类型&gt; (参数)<br>delete &lt;对象指针&gt;/delete &lt;对象数组指针&gt;<br><img src=\"https://img-blog.csdnimg.cn/201907121654256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"6-3-那么C-的new-delete与C语言的malloc-free有什么区别呢？\"><a href=\"#6-3-那么C-的new-delete与C语言的malloc-free有什么区别呢？\" class=\"headerlink\" title=\"6.3.那么C++的new/delete与C语言的malloc/free有什么区别呢？\"></a>6.3.那么C++的new/delete与C语言的malloc/free有什么区别呢？</h2><ul>\n<li>它们都是动态管理内存的入口</li>\n<li>malloc/free是C/C++标准库函数，而new/delete是C++操作符</li>\n<li>malloc/free只是动态分分配/释放内存空间，而new/delete除了分配内存空间还会调用构造/析构函数进行初始化/清理（清理成员）</li>\n<li>malloc/free需要手动计算类型大小且返回值为void，而new/delete可以自行计算类型大小返回对应类型的指针</li>\n<li>new/delete在底层是调用了malloc/free的。可以认为是C++对malloc/free的封装</li>\n<li>malloc/free申请空间后需要判空，new/delete则不需要</li>\n<li>new直接跟类型，malloc跟字节数。<br>new/delete和malloc/free的区别是C++企业招聘时特别喜欢考的一项</li>\n</ul>\n<h1 id=\"7-程序的内存空间\"><a href=\"#7-程序的内存空间\" class=\"headerlink\" title=\"7.程序的内存空间\"></a>7.程序的内存空间</h1><h2 id=\"7-1-指针的内存操作\"><a href=\"#7-1-指针的内存操作\" class=\"headerlink\" title=\"7.1.指针的内存操作\"></a>7.1.指针的内存操作</h2><ul>\n<li>指针不仅可以可以指向变量还可以指向函数</li>\n<li>有new运算符在堆区创建的内存空间由位于栈区的指针确定入口</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/20190712165857369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>说到这，我们有必要了解一下计算机程序的内存结构，供程序运行的内存空间分为：堆区、栈区、.data段、.bss段、.ro段、.txt段，我使用一张图来说明<br><img src=\"https://img-blog.csdnimg.cn/20190712170749180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"8-面向对象编程的特点\"><a href=\"#8-面向对象编程的特点\" class=\"headerlink\" title=\"8.面向对象编程的特点\"></a>8.面向对象编程的特点</h1><p><img src=\"https://img-blog.csdnimg.cn/2019071310135053.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"9-C-中的类\"><a href=\"#9-C-中的类\" class=\"headerlink\" title=\"9.C++中的类\"></a>9.C++中的类</h1><h2 id=\"9-1-类的定义\"><a href=\"#9-1-类的定义\" class=\"headerlink\" title=\"9.1.类的定义\"></a>9.1.类的定义</h2><p><img src=\"https://img-blog.csdnimg.cn/2019071310150942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"9-2-访问权限\"><a href=\"#9-2-访问权限\" class=\"headerlink\" title=\"9.2.访问权限\"></a>9.2.访问权限</h2><ul>\n<li>C++为类的成员添加了三种访问权限<br>public–公有成员：权限最高，在public修饰下的成员是类的外部接口，可以被类的成员函数和对象直接访问</li>\n<li>protected–保护成员：权限居中，可以被类的成员函数和其派生类的成员函数直接访问，但不能被类的对象和派生类的对象直接访问。</li>\n<li>private–私有成员：权限最低，只能通过类的成员函数访问。</li>\n</ul>\n<h2 id=\"9-3-类的成员\"><a href=\"#9-3-类的成员\" class=\"headerlink\" title=\"9.3.类的成员\"></a>9.3.类的成员</h2><ul>\n<li>成员变量：类的成员变量用以描述一个对象的属性信息，与一般的变量声明相同，但类的成员变量只能在类的声明体中定义，类的成员变量一般在类的构造函数中初始化，但这不是必须的。</li>\n<li>成员函数：用来描述一个对象的行为动作，与一般的函数声明相同，但只能放在类的声明体中声明，成员函数可以在类内实现也可以在类外实现，但在类内实现则形成内联的成员函数，会使类变得冗杂，所以成员函数的实现最好在类外实现，类成员函数可以重载和带默认参数。</li>\n</ul>\n<h2 id=\"9-4-类的成员函数与成员变量的声明与实现\"><a href=\"#9-4-类的成员函数与成员变量的声明与实现\" class=\"headerlink\" title=\"9.4.类的成员函数与成员变量的声明与实现\"></a>9.4.类的成员函数与成员变量的声明与实现</h2><p><img src=\"https://img-blog.csdnimg.cn/20190713104139644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"9-5-struct和class的区别\"><a href=\"#9-5-struct和class的区别\" class=\"headerlink\" title=\"9.5.struct和class的区别\"></a>9.5.struct和class的区别</h2><ul>\n<li>C++对struct关键字扩展了其功能，和class的功能几乎等价</li>\n<li>struct的成员默认访问权限是public，而class是private</li>\n</ul>\n<h2 id=\"9-6-this指针\"><a href=\"#9-6-this指针\" class=\"headerlink\" title=\"9.6.this指针\"></a>9.6.this指针</h2><ul>\n<li>this指针是一个特殊的指针，指向对象的自身的首地址</li>\n<li>每一个对象的成员函数都有一个this指针，指向调用的对象，如果要引用整个对象则通过*this引用</li>\n<li>this指针仅能在类的内部使用，即只能在类的声明体或成员函数中使用</li>\n</ul>\n<h2 id=\"9-7-static关键字\"><a href=\"#9-7-static关键字\" class=\"headerlink\" title=\"9.7.static关键字\"></a>9.7.static关键字</h2><h3 id=\"9-7-1-static修饰的成员变量–静态成员变量\"><a href=\"#9-7-1-static修饰的成员变量–静态成员变量\" class=\"headerlink\" title=\"9.7.1.static修饰的成员变量–静态成员变量\"></a>9.7.1.static修饰的成员变量–静态成员变量</h3><ul>\n<li>static修饰的变量存储在静态变量区</li>\n<li>在类中static关键字修饰的变量被此类的所有对象共享，即所有对象共享这一个变量</li>\n<li>static修饰的变量必须在类外初始化，不可以在定义的时候直接初始化</li>\n<li>static修饰的公有成员变量可以直接通过类名来访问，没有staic修饰的成员变量只能通过对象才能访问<br><img src=\"https://img-blog.csdnimg.cn/20190713105202141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></li>\n</ul>\n<h3 id=\"9-7-2-static修饰的成员函数–静态成员函数\"><a href=\"#9-7-2-static修饰的成员函数–静态成员函数\" class=\"headerlink\" title=\"9.7.2.static修饰的成员函数–静态成员函数\"></a>9.7.2.static修饰的成员函数–静态成员函数</h3><ul>\n<li>static修饰的成员函数也可以直接通过类名访问</li>\n<li>静态成员函数只能访问静态成员变量</li>\n</ul>\n<h3 id=\"9-7-3-类的静态与非静态部分\"><a href=\"#9-7-3-类的静态与非静态部分\" class=\"headerlink\" title=\"9.7.3.类的静态与非静态部分\"></a>9.7.3.类的静态与非静态部分</h3><ul>\n<li>静态部分只属于类，与类一起存放在内存的静态区，被所有对象共享</li>\n<li>非静态部分属于对象，每个对象都有自己的非静态部分，互不影响</li>\n<li>静态部分只能直接访问静态部分，非静态部分可以访问所有部分</li>\n<li>那么为什么静态部分只能直接访问静态部分，而非静态部分却可以访问所有部分呢？<br>那是因为，非静态成员变量/函数是属于对象的，只能通过对象来访问，而静态部分是属于类的，使用静态部分时</li>\n</ul>\n<p>没有确定对象的存在，所以不能确定静态部分应该访问哪个对象的非静态部分，而静态部分是属于类的，所有对象共享，所以通过对象使用非静态部分时，可以访问静态部分。<br>思导图：<br><img src=\"https://img-blog.csdnimg.cn/20190623192350471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/20190712170853343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n"},{"title":"【UE4】UE4蓝图基础","date":"2019-10-28T13:17:08.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 一、蓝图可视化脚本与蓝图系统\n\n## 1.蓝图脚本\n\n蓝图可视化脚本简称“蓝图”或“蓝图脚本”，是一种需要编译的面向对象的可视化编程语言，蓝图完全集成在UE4中，蓝图通过节点与连线工作。\n\n### 蓝图脚本的节点\n\n- 触发事件，在蓝图脚本中以红色的节点出现\n- 函数，在看图脚本中以蓝色的节点出现\n- 变量，在蓝图脚本中中以黄色节点出现\n\n## 2.蓝图系统\n\n蓝图系统又称“蓝图”或“蓝图类”，蓝图类可以看成是一个包含游戏内容的容器，其中可以包含组件、脚本或可以仅仅包含数据。\n\n蓝图类有点类似Unity3d中的预设(prefb)，蓝图类可以类似预设一般保存对象状态，可以随时拖入场景中使用，只是在其他功能上不如预设，如预设在U3D中的打包中可以发挥出优秀的效果，但是蓝图类只能作为容器使用。\n\n<font color = red> 蓝图类包含蓝图脚本，每一个蓝图类都包含一个默认的蓝图脚本。</font>\n\n### 蓝图类的分类\n\n- **关卡蓝图**：关卡蓝图在每个Level中只能存在一个，负责整个关卡的运行逻辑，关卡的初始化，帧更新都在关卡蓝图里进行；\n- **普通蓝图**：普通蓝图就是UE4的预设，在普通蓝图中我们可以对其中的对象进行一些的配置，如设置网格，贴图，粒子特效，添加相机，添加物理材质和挂载蓝图脚本等等；\n- **游戏模式蓝图**：UE4中游戏模式也是以蓝图的形式存在的，游戏模式蓝图控制一系列游戏的规则；\n- **材质蓝图**：在UE4中贴图材质也是蓝图的形式存在的，在材质蓝图中我们可以如同建模软件一般对材质进行一系列更高级的材质配置，如下图的一个简单示例：\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-24_09-41-27.png)\n\n## 4.创建蓝图\n\n创建蓝图的方法很多，这里介绍比较常用的方法\n\n- 可以直接在Content Browser(内容浏览器)中右键创建一个空的蓝图类，空蓝图除了包含一个根组件外不再包含其他东西，当我们在空蓝图中创建了对象后可以通过拖拽的方式将对象拖动到根组件位置处，用游戏对象替换根组件作为根组件，这样创建空蓝图时的白色小球就会消失；\n- 在World Outliner(世界大纲)中选中游戏对象，可以通过工具栏中的Blueprints工具中的下面两个选项创建一个包含所选内容的蓝图类；\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-24_09-51-55.png)\n\n- 通过Blueprints工具的New Empty Blueprint Class也可以直接创建空蓝图类；\n- 然而关卡蓝图似乎只能通过Blueprints工具的Open Blueprint Class打开。\n\n# 二、变量与对象引用\n\n## 1.在蓝图中创建变量\n\n在蓝图中创建变量的方式有两种，其一：直接点击My BluePrint/Variables/+Variable，默认创建bool行的变量，可以点击变量前的色块更换变量类型。\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-25_17-18-23.png)\n\n其二：在蓝图脚本区域右键->输入Get New Var，可以直接在蓝图脚本中以节点的形式创建变量，在右侧细节面板中设置变量的值。\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-25_17-23-27.png)\n\n所有创建好的变量都会在My Blueprint面板Variables栏中显示。\n\n<font color=red> 在创建好的变量的Details/Variable/Variable Type选项中可以设置变量为普通变量、数组、Set容器和Map容器。</font>\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-27_11-01-39.png)\n\n## 2.在蓝图中使用变量\n\n可以直接在蓝图脚本区域右键->输入Get/Set [变量名]即可获取变量的获取/设置组件，也可以直接从左侧的My Blueprint面板Variables栏中拖拽变量到蓝图脚本区域选择Get/Set。\n\n## 3.生成时公开与私有变量\n\n蓝图中的公有与私有与程序中的公有私有有一些不同，蓝图中只分为生成时公开和私有两种访问权限。\n\n### 生成时公开(Expose on Spawn)\n\n勾选生成时公开后，在蓝图类使用Spawn Actor from Class组件生成蓝图类实例时，勾选生成时公开的变量将可以接受外部值输入。\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-28_16-45-41.png)\n\n如上图可以看到勾选生成时公开的变量会以输入接口的形式出现在Spawn Actor from Class节点里。这里需要注意的是，勾选Expose on Spawn，还需要勾选Instance Editable，否则会报警告。\n\n### 私有变量(Private)\n\n设置成私有变量的变量只能在蓝图类里访问，蓝图类的外部实例也无法访问这个变量，如上图，变量L没有设置成私有，所以可以通过Spawn Actor from Class组件生成的实例访问这个变量，而设置成私有的K变量搜索不到Set K节点。\n\n\n\n## 3.在蓝图中使用组件引用\n\n很多时候我们需要调节自身Actor上的组件的某些参数，那么我们就需要获得这个组件的引用以便获取组件上的参数进行调节，那么我们如何获得组件的引用呢？\n\n其实方法也很简单，在My Blueprint/Variabales下有一个子栏“Components”其中存放着当前Actor上的所有的组件的引用，使用方法就是直接将需要的组件引用拖拽到蓝图脚本区域即可。获得了组件引用我们就可以通过引用使用不同的方法获取组件上的不同的参数了。\n\n## 4.动态获取世界大纲中的Actor\n\n在蓝图脚本中有四个方法获取外部Actor：\n\n- Get All Actor of Class：通过类型来获取外部Actor\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-31-16.png)\n\n- Get All Actor with Tag：通过标签来获取外部Actor\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-31-23.png)\n\n- Get All Actor with Interface：通过外部接口在获取外部Actor\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-31-36.png)\n\n- Get Actors：通过层来获取Actor\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-31-47.png)\n\n\n\n# 三、蓝图的数据类型\n\n## 1.5个基本数据类型\n\nUE4蓝图中基本数据类型只有5个，需要注意的是蓝图中没有char、double、short、long等数据类型，在C++与蓝图的配合使用时需要注意这些类型的变量。\n\n### Boolean\n\n### Byte\n\n8位，一字节，0-255。\n\n### Integer\n\n32位整型，四字节。\n\n### Integer64\n\n64位整型，八字节，能存储更大的数。\n\n### Float\n\n32位单精度浮点型，其中1符号位、8指数位、23数值位，UE4中默认保留小数点后6位。UE4中只有Float类型没有Double类型。\n\n## 2.3种字符串\n\n### String\n\n蓝图中String类型就是蓝图C++中的FString类型，普通字符串，可以对其中的字符进行增删查改。\n\n### Name\n\nName是一种固定字符串类型，变量初始化以后不能在对其中的内容进行修改，且Name类型的字符串不区分大小写，多用于作为全局变量来唯一标识对象。Name类型的字符串在运行过程中存储于内存的字符串表中，使用效率高。\n\n### Text\n\nText是String的长度加强版，通常用于存储一段文字并可以进行国际化处理。\n\n## 3.Vector(维度向量)\n\n### Vector\n\n默认创建的Vector是Vector 3D，即三维量，包含x、y、z三个值，可以表示任何任何三维量，如：三维坐标和RGB等。\n\n### Vector 2D 和Vector 4\n\nVector 2D就是二维量，Vector 4就是四维量，常用于表示四元素。\n\n### Two Vectors\n\nTwo Vectors就是一个关于Vector的pair(对组)，pair在C++的STL种较为常用，是一个只包含两个元素的容器。\n\n## 4.Rotator(三维旋转量)\n\n包含：\n\nx：roll，翻滚角，以x为轴，进行yz平面的旋转；\n\ny：pitch，俯仰角，以y为轴，进行xz平面的旋转；\n\nz：yaw，航向角，以z为轴，进行xy平面的旋转。\n\n## 5.Transform\n\nTransfrom类型是一个3*3的矩阵，包含Location、Rotation和Scale三个三维向量。\n\n# 四、条件语句\n\n## 1.Branch(if条件判断)\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-39-15.png)\n\n传入一个bool值，进行分流，通常和比较组件配合使用，如：“==”、“>”等。\n\n## 2.Switch\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-25_19-14-34.png)\n\n- Selection：case判断的变量；\n- Default：默认执行分支；\n- Add pin：添加执行分支。\n\n# 五、循环语句\n\n## 1.For Loop(for循环)\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-39-35.png)\n\n- First Index/Last Index：提供循环的次数；\n- Loop Body：循环体执行分支；\n- Index：返回当前循环索引；\n- Conpleted：循环完毕后执行分支。\n\n## 2.For Loop whit Break(可跳出的for循环)\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-39-52.png)\n\n使用方法和For Loop类似。\n\n## 3.For Each Loop(数组遍历)\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-40-45.png)\n\n专门有用遍历数组的循环。\n\n- Array：需要遍历的数组；\n- Loop Body：循环体分支；\n- Array Element：遍历的数组元素；\n- Array Index：当前索引；\n- Completed：遍历结束执行分支。\n\n## 4.For Each Loop with Break(可跳出的数组遍历)\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-40-54.png)\n\n用法和Foreach Loop一样，只是多了一个跳出执行分支。\n\n## 5.Reverse for Each Loop(反向数组遍历)\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-40-59.png)\n\n## 6.While Loop(while循环)\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-27_11-04-21.png)\n\n# 六、数组\n\n## 1.创建数组\n\n创建数组要比创建变量多一个步骤，首先我们需要创建一个变量，然后再将这个变量的Details/Varialble Type选项的右侧色块选择九宫格，即可将对应变量转换成对应类型的数组。\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-02-54.png)\n\n## 2.为数组赋值\n\n### Add(Array)\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-21-48.png)\n\n传入一个数组和一个元素即可通过Add(Array)组件为组数赋值\n\n如：\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-24-33.png)\n\n循环完毕后数组Array内便存储有0-10的是个int型元素。\n\n## 3.获取元素\n\n### Get(a copy)\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-07-50.png)\n\n获取指定索引的元素的拷贝。\n\n### Get(a ref)\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-07-44.png)\n\n获取指定索引的元素的引用。\n\n## 4.插入元素\n\n### Add(Aray)\n\n直接在数组的末尾插入元素的方法也是使用Add(Array)组件，Add(Array)组件的的插入过程就是直接在数组的末尾插入元素。\n\n### Insert\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-37-55.png)\n\n指定位置插入使用Insert组件，输入参数从上至下依次为目标数组、要插入的元素、目标插入的索引位置。\n\n当要使用Insert组件在数组末尾插入，而又不知道数组大小时，可以使用Last Index组件直接获取输入数组的尾索引，当然直接使用只会在最后一个索引位置插入，而使最后一位元素向后移动一位，而达不到在数组尾部插入的效果，所以需要加一食用。\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-46-46.png)\n\n### Set Array Elem\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-25-34.png)\n\n设置输入数组指定索引的元素的值，Size to Fit选项可以设置如果指定索引不存在时数组自动扩充size大小。\n\n## 5.查找元素\n\n### Contains Item\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-50-31.png)\n\nContains Item组件可以查找指定数组中是否包含某一元素，但是Contains Item只返回bool的判断结果，不会返回目标的索引值。\n\n### Find Item\n\n![](B:/Git/Temp/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-59-54.png)\n\nFind Item则是从输入数组中查找指定元素并返回第一次查找到该元素的索引值。\n\n## 6.删除元素\n\n### Remove Index\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-12-59.png)\n\n通过索引删除元素\n\n### Remove Item\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-21-30.png)\n\n从输入数组中移除指定元素，Remove Item会删除数组中所有指定的元素，如果删除成功则返回true，失败则返回false。\n\n## 7.筛选元素\n\n### Filter Array\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-53-49.png)\n\n过滤数组可以按类型来筛选数组元素，用于父类型数组存储子类型元素时进行类型筛选，如：Actor数组筛选MyClass类型元素，Filter Array返回一个筛选后的新数组。\n\n## 8.清空数组\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-42-24.png)\n\n使用Clear组件可以将数组内的元素全部清空。\n\n## 9.获取数组长度\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-29-34.png)\n\n## 10.设置数组长度\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-30-00.png)\n\n# 七、结构体\n\n## 1.结构体创建\n\n蓝图中结构体的创建是没办法在蓝图脚本视图中创建的，UE4蓝图中结构体是与蓝图脚本同级的蓝图类，创建蓝图结构体的方法：在Content Browser中右键->Create Advanced Assect/Blueprint栏->Structure，即可创建一个结构体，创建出来的结构体默认拥有一个bool值得成员变量。\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-26_17-38-54.png)\n\n## 2.定义成员变量\n\n蓝图中得结构体只能创建成员变量，不能创建成员函数，成员变量可以直接设置默认值。\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-26_19-59-29.png)\n\n## 3.结构的使用\n\n将结构体创建好以后便可以直接在蓝图脚本中搜索到并使用了。\n\n# 八、枚举\n\n## 1.枚举的创建\n\n枚举的创建和使用和结构体区别不大，创建方式一如结构体一般,Content Browser中右键->Create Advanced Assect/Blueprint栏->Enumeration，创建好后UE4也会在一个新的视图中对枚举进行编辑，枚举的编辑操作也相当简单，只有向枚举中添加与删除元素的操作，这些元素都可以添加注解提示，枚举也可以添加整个枚举的注解提示。\n\n## 2.枚举的使用\n\n枚举的使用就如同变量的使用一般，没有什么可说的。\n\n# 九、接口\n\n## 1.接口的定义\n\n接口的定义和和蓝图函数库，蓝图宏库一样，但是接口的不像函数库和宏库一般可以再一个蓝图类中定义多个函数和宏，接口就是一个蓝图类，并且接口的编辑界面及其简约，可编辑视图只有一个My Blueprint和一个Detials,在My Blueprint/Functions栏可以新建接口函数，在对应的接口函数的Details/Graph可以设置一些接口函数的描述和Const属性，在Details/Inputs和Outputs栏可以设置接口函数的输入与输出参数。\n\n## 2.接口的继承\n\n接口是一个抽象蓝图，接口的实现必须通过继承接口的蓝图来实现，在蓝图中接口继承通过Toolbar/Class Settings/Interfaces栏即可添加接口到当前蓝图类是指继承此接口。\n\n## 3.接口的实现\n\n### 无返回值的接口实现\n\n在一个蓝图继承了一个无返回值得接口后，这个接口将以事件的形式出现在这个蓝图类的All Actions for this Blueprint里\n\n如：\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-27_10-32-38.png)\n\n蓝图以这个事件作为接口函数的入口，以此节点开始便可以开始实现各个蓝图类各自继承的接口函数的逻辑了。\n\n### 有返回值得接口实现\n\n有返回值的接口不会以事件的形式出现在Add Event里，而是会直接出现在My Blueprint/Interface栏里，我们双击即可打开接口函数的编辑视图，在视图中实现接口即可。\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-28_17-00-10.png)\n\n## 4.接口函数的调用\n\n蓝图通过`[接口名](Mesasge)`组件来调用接口中的函数，如下图中的Interface1(Message)和Interface2(Message)。\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-27_10-35-51.png)\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-27_10-38-13.png)\n\n接口的使用需要指定使用的接口是哪个蓝图类中实现的接口和接口需要传入的参数。在蓝图类的My Blueprint/Variables栏是可以搜索到我们自己创建的蓝图类的，通过过去蓝图类的引用便可以指定接口函数的实现者了。当然我们也可以使用Get All Actors with Interface组件来获取实现了指定接口的所有蓝图类，然后再对这些蓝图类中实现的函数进行调用。\n\n# 十、蓝图函数库\n\n<font color=red> 蓝图函数库是一个可以被所有蓝图类调用的函数集合，蓝图函数库里的方法全部都被定义为静态方法</font>，用于定义一些不与特定游戏对象绑定的功能性函数的实现。\n\n## 1.创建蓝图函数库\n\n创建蓝图函数库的方式和创建结构体类似，在Content Browser中右键->Create Advanced Assect/Blueprint栏->Bluprint Function LiberLibrary。\n\n## 2.实现蓝图函数库里的函数\n\n和结构体一样，创建好的蓝图函数库UE4会创建一个新的界面用于编辑库里函数；\n\n- 在My Blueprint/Functions栏可以申明函数\n- 在My Blueprint/Local Variables栏可以生命局部变量，在其Details中可以设置局部变量默认值；\n- 在对应函数的Details/Input和Output栏可以分别设置函数的输入输出参数\n- 在脚本编辑区可以实现函数逻辑。\n\n## 3.使用蓝图函数库里的函数\n\n要使用蓝图函数库里的函数，可直接在脚本编辑区右键输入函数名即可在Class栏中看到蓝图函数库里的函数了。\n\n# 十一、蓝图宏库\n\n宏在UE4中几乎无处不在，蓝图宏库是开发者使用蓝图自定义的一系列的宏的容器，蓝图宏库和蓝图函数库一样可以定义多个宏；\n\n- 蓝图宏库与蓝图函数库不同的是，蓝图宏库中的宏是在预编译过程中完成处理的，即蓝图宏库不需要编译；\n- 自定义的宏，可以有任意数量的输入输出引脚，即一个宏可以没有输出引脚，这样的宏可以只进行数据处理，一个宏也可以有多个输入输出引脚，这样的宏可以根据不同的逻辑选择不同的执行流，而蓝图函数库中的函数必须有且只有一个输入和一个输出引脚；\n- 与函数不同，宏中不可以再定义成员变量，即宏只负责处理逻辑，不提供暂存能力。\n\n## 1.创建蓝图宏库\n\n宏库的创建与函数库的创建是一样的，在Content Browser中右键->Create Advanced Assect/Blueprint栏->Bluprint Macro LiberLibrary。\n\n## 2.蓝图宏声明\n\n- 在My Blueprint/Macro中可以声明一个宏；\n- 在指定宏的Details/Inputs和Outputs中可以定义输入与输出引脚和参数。\n\n## 3.蓝图宏的使用\n\n和蓝图函数的使用方法一致。\n\n## 4.自定义流程控制\n\n除了蓝图提供给我们的条件语句和循环语句等流程控制语句外，我还可以使用宏编写自己的流程控制，因为宏可以有多个输入和输出引脚，使用方法就是使用宏的形式定义自己的流程控制逻辑，通过不同的输入给予不同输出，即可达到自定义流程控制的目的。\n\n# 十二、事件\n\n除了UE4蓝图中给我们提供大量的预定义事件，我也可以自定义事件。\n\n## 1.事件的定义\n\n事件的定义也很简单，在All Actions for this Buleprint中选择Add Custom Event，便可以创建一个自定义事件的入口，之后通过这个入口实现事件的内部逻辑，一个事件便定义完成。\n\n## 2.事件的调用\n\n事件调用必须通过实现这个事件的蓝图类才可以对其中的事件进行调用。如：\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-27_11-28-43.png)\n\nEvent Blueprint为实现自定义事件的蓝图类；\n\nPrint Str为自定义事件。\n\n## 3.事件调度器\n\n事件调度器的创建与使用请阅读目录：十七、蓝图类的通信/3.使用事件调度器进行通信\n\n# 十三、蓝图模块\n\n蓝图中可以将一个复杂了逻辑处理合并成一个节点模块，从而简化整体的执行流复杂度，使蓝图的执行流变得简单明了。我们可以将需要合并的执行流多选选中然后右键，即可在Organization栏中通过Collapse Nodes选项来合并执行流。\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-27_11-31-04.png)\n\n除了将执行流合并成节点外，蓝图还提供将多个执行流合并成一个函数或一个宏的功能。合并好的模块也可以在Organizition/Expand Node进行模块分离。\n\n# 十四、角色控制\n\n## 1.为角色添加跟随相机\n\n相对U3D来说，UE4的相机跟随要简单得多，UE4中直接将相机设置成了蓝图类的组件，当蓝图类时Player时，即可实现相机对Player的跟随了。\n\n相机跟随需要通过一个物理组件`Spring Arm`来链接相机和Player，将相机附着在Spring Arm下，即可在Spring Arm的作用下实现相机跟随。\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-24_10-45-29.png)\n\n## 2.为角色添加控制器\n\n在UE4的游戏制作过程中，我们不难发现当我们运行游戏时，在世界大纲中多出了很多东西，如下图：\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-24_10-53-34.png)\n\n其实，UE4为我们提供很多已经预制好的必须品，如上图的PlayerController(角色控制器)、PlayerCameraMenager(角色相机管理器)等。也就是说不可以直接使用UE4预制给我们的角色控制器来控制我们的Player，而不需要自己再去为Player蓝图配置角色控制器了，我们只需将Player的细节面板上的Auto Possess Player设置成Player0即可，Player0即表示本地角色。\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-24_10-53-06.png)\n\n需要注意的是，对于角色控制更优的方式是使用`Player Start`组件去持有Player蓝图类，再通过Player Controller来控制Player Start达到控制角色的目的。\n\n## 3.自定义游戏模式\n\n在我们创建一个UE4工程后，UE4会启用UE4默认的游戏模式`GameModeBase`，GameModeBase就控制着Player Controller、PlayerCameraMenager、PlayerState等运行时UE4动态生成的一些游戏物体，我们可以通过启用我们自定义的游戏模式来设置这些游戏物体按自己的定义的规则来生成运行。\n\n游戏模式也是一个蓝图类，创建游戏模式就是创建蓝图类，只是这个蓝图类需要继承自GameModeBase类，继承自GameModeBase类的蓝图就是一个游戏模式蓝图。不过在我们第一此=次打开游戏模式蓝图时，UE4会将游戏模式蓝图识别成一个普通蓝图，而进入普通蓝图的编辑模式，可能是bug吧，此时我们只需将蓝图关闭，再打开一次，UE4便可以识别出游戏模式蓝图了。\n\n游戏模式蓝图中可以定义自己的游戏模式规则，比如我们可以通过修改Spectator Class选项为自定义的游戏物体，这样在游戏运行时，UE4将不再生成DefaulPawn，而是会生成我们指定的游戏物体。\n\n![](【UE4】UE4蓝图基础\\Snipaste_2019-10-24_11-09-34.png)\n\n配置好游戏模式后我们还需要让当前项目使用我们自定义的游戏模式，通过Seettings ->Project Settings->Project/Maps&Modes->Dfault GameModes，选择我们自己的配置的游戏模式即可让当前项目启用我们自己定义的游戏模式了\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-24_11-12-38.png)\n\n## 4.操控角色控制器\n\n我们要操控角色控制器就需要配置键盘按键映射，配置好的键盘映射会以函数的形式加入蓝图脚本组件集中。\n\n我们在Seettings ->Project Settings->Engine/Input->Bindings/Axis Mappings设置键盘映射并可以配置映射的值，\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-24_14-55-47.png)\n\n配置好键盘映射以后便可以在蓝图脚本中使用这些函数主键来控制我们Player了，控制角色运动的方法很多，我这里以旋转力矩的方式来控制小球运动，具体的控制方法如下：\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-24_15-11-12.png)\n\n加入两个键盘映射函数组件(InputAxis MoveF/B,InputAxis MoveL/R)、两个添加角度力矩的组件(Add Torque in Radians,Add Torque in Radians)，但是添加角度力矩组件是需要一个控制目标的，我们需要从左侧的My Blueprint面板的Components中将需要控制的物体Player拖入脚本蓝图中，分别连接到添加角度力矩组件的Target上。\n\n这里还需要注意的一点是，在我们为Player添加相机时，相机使用的是相对于Player的局部坐标，使用局部坐标的相机会跟随Player旋转，而使用世界坐标的相机将会固定某一个角度跟随Player移动。切换方法为：下拉Spring Arm的细节面板/Transform/Rotation的三角箭头选择切换。\n\n并且相机默认情况下是启用了物理碰撞的，但大多数情况下我们是不需要让相机出现物理碰撞的，所以我们也应当取消相机的物理碰撞。操作方法为：取消Spring Arm的细节面板/Camera Collision/Do Collision Test选项。\n\n当然要想比较真实的模拟出物理效果，光这样是不行的，因为默认情况下Player是没有启动物理模拟的，我们需要启用Player的细节面板/Physics/Simulate Physics选项，并且将调节Player的细节面板/Linear Damping(线性摩檫)和Player的细节面板/Angular Damping(旋转摩檫)到适当的值，应为UE4默认是没有旋转摩檫的并且，默认线性摩檫为0.01。\n\n## <font color=Green> 小知识</font>\n\n- <font color=green> 大多数时候我们都需要勾选作用力函数组件的Acel Change选项，如：上面的Add Torque in Radians，勾选了Acel Change选项作用力组件会在作用目标物体时忽略物体的质量因素，因为存在质量影响的话，我们可能需要给一个极大的力才能推动目标物体；</font>\n- <font color=green> 有时可能默认大小的作用力对目标物体的移动作用达不到我们理想的效果，此时可以先将作用力加倍后在传递给作用力组件，蓝图脚本组件集中提供多种多样的乘积组件，我们上面使用的是float*float组件</font>；\n\n# 十五、触发器\n\n在游戏设计中触发器的使用是非常平凡的，而在蓝图中触发器的实现也并不复杂，我们来看一下具体操作：\n\n## 1.创建触发器\n\n- 蓝图模式中游戏的一切都是蓝图，触发器也不例外，所以要做一个触发器，首先我们的创建一个蓝图的壳子，并继承自Actor类\n- 触发器还需要一个极为重要的东西就是碰撞体，当然这里的碰撞体不是具有物理碰撞的网格碰撞体，而是蓝图的物理组件集中的Box Collison，一个没有物理碰撞效果专门用于触发器的盒碰撞体，我们给蓝图类添加这个组件，一个触发器便完成了\n\n## 2.使用触发器\n\n当触发器放置于场景中，有物体进入触发器碰撞盒时，触发器便会出自动发触发Event ActorBeginOverlap时间组件，之后我们便可以进行一系列逻辑操作了。\n\n# 十六、蓝图类的通信\n\n## 1.使用引用进行通信\n\n两个蓝图类要想通过引用进行通信，那么其中一个蓝图类就必须拥有另一个蓝图类的引用，如何获取一个蓝图类的引用呢？\n\n在My Blueprint/Variables栏中添加一个所需要引用的蓝图类类型的变量，勾选它的Details/Variable/Instance Editable选项，就可以在这个蓝图类的实例的Details/Default栏中看到引用变量(如果不勾选是没有default栏的)，如此便可以方便的获取另一个蓝图类的实例的引用了。\n\n通过引用两个蓝图类之间便可以进行单向的信息传递了。即拥有引用的蓝图类可以获取所引用蓝图的传递过来的信息，反向则不行。\n\n## 2.使用接口进行通信\n\n使用接口进行通信的好处是可以很便利的通过同一事件让各种不同的蓝图做出不同的反应，如：当受到子弹攻击时，墙会反弹子弹，人会受伤，通过接口通信来实现这个效果就是，创建一个受到子弹攻击的接口OnTakeAttack，然后分别让墙和人都继承这个接口并实现不同的效果，如此当受到子弹攻击时，我们便可以通过Get All Actor with Interface来调用实现这些接口的Actor来做出各自的反应。\n\n接口的实现与使用请阅读目录：九、接口。\n\n\n\n## 3.使用事件调度器通信\n\n事件调度器的通信过程是一个调度者与一个或多个被调度者之间的通信过程，类似观察者模式的通信过程。\n\n### 创建事件调度器\n\n使用事件调度器来进行蓝图通信，首先我们需要拥有一个事件调度器；\n\n事件调度器只能被拥有者调用，所以我们需要在调度者蓝图上创建事件调度器，在My Blueprint/Event Dispatchers栏可以新建一个蓝图调度器，此时这个蓝图便拥有了一个事件调度器，我们可以通过拖拽事件调度器到脚本编辑视图或直接在All Actions for this Blueprint中搜索，可以对事件调度器进行事件绑定(Bind)、事件解绑(Unbind)、解绑全部事件(Unbind all)，直接为事件调度器绑定新事件(Assign)和调用事件调度器(Call)。当一个事件调度器被调用后，与这个事件调度器绑定的事件都会被调用，一次来达到信息传递的目的。\n\n### 绑定事件\n\n调度者要事件调度器调用被调度者的事件，那么被调度者就需要向调度者的事件调度器上绑定事件，通过Bind Event to [事件调度器名]组件来绑定事件到事件调度器上。\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-28_15-51-30.png)\n\nTarget：输入事件调度器的拥有者对象\n\nEvent：需要绑定的事件\n\n如此一个基于事件调度器的通信机制便完成了。\n","source":"_posts/【UE4】UE4蓝图基础.md","raw":"---\ntitle: 【UE4】UE4蓝图基础\ndate: 2019-10-28 21:17:08\ntags: UE4\ncategories: 学习笔记\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 一、蓝图可视化脚本与蓝图系统\n\n## 1.蓝图脚本\n\n蓝图可视化脚本简称“蓝图”或“蓝图脚本”，是一种需要编译的面向对象的可视化编程语言，蓝图完全集成在UE4中，蓝图通过节点与连线工作。\n\n### 蓝图脚本的节点\n\n- 触发事件，在蓝图脚本中以红色的节点出现\n- 函数，在看图脚本中以蓝色的节点出现\n- 变量，在蓝图脚本中中以黄色节点出现\n\n## 2.蓝图系统\n\n蓝图系统又称“蓝图”或“蓝图类”，蓝图类可以看成是一个包含游戏内容的容器，其中可以包含组件、脚本或可以仅仅包含数据。\n\n蓝图类有点类似Unity3d中的预设(prefb)，蓝图类可以类似预设一般保存对象状态，可以随时拖入场景中使用，只是在其他功能上不如预设，如预设在U3D中的打包中可以发挥出优秀的效果，但是蓝图类只能作为容器使用。\n\n<font color = red> 蓝图类包含蓝图脚本，每一个蓝图类都包含一个默认的蓝图脚本。</font>\n\n### 蓝图类的分类\n\n- **关卡蓝图**：关卡蓝图在每个Level中只能存在一个，负责整个关卡的运行逻辑，关卡的初始化，帧更新都在关卡蓝图里进行；\n- **普通蓝图**：普通蓝图就是UE4的预设，在普通蓝图中我们可以对其中的对象进行一些的配置，如设置网格，贴图，粒子特效，添加相机，添加物理材质和挂载蓝图脚本等等；\n- **游戏模式蓝图**：UE4中游戏模式也是以蓝图的形式存在的，游戏模式蓝图控制一系列游戏的规则；\n- **材质蓝图**：在UE4中贴图材质也是蓝图的形式存在的，在材质蓝图中我们可以如同建模软件一般对材质进行一系列更高级的材质配置，如下图的一个简单示例：\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-24_09-41-27.png)\n\n## 4.创建蓝图\n\n创建蓝图的方法很多，这里介绍比较常用的方法\n\n- 可以直接在Content Browser(内容浏览器)中右键创建一个空的蓝图类，空蓝图除了包含一个根组件外不再包含其他东西，当我们在空蓝图中创建了对象后可以通过拖拽的方式将对象拖动到根组件位置处，用游戏对象替换根组件作为根组件，这样创建空蓝图时的白色小球就会消失；\n- 在World Outliner(世界大纲)中选中游戏对象，可以通过工具栏中的Blueprints工具中的下面两个选项创建一个包含所选内容的蓝图类；\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-24_09-51-55.png)\n\n- 通过Blueprints工具的New Empty Blueprint Class也可以直接创建空蓝图类；\n- 然而关卡蓝图似乎只能通过Blueprints工具的Open Blueprint Class打开。\n\n# 二、变量与对象引用\n\n## 1.在蓝图中创建变量\n\n在蓝图中创建变量的方式有两种，其一：直接点击My BluePrint/Variables/+Variable，默认创建bool行的变量，可以点击变量前的色块更换变量类型。\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-25_17-18-23.png)\n\n其二：在蓝图脚本区域右键->输入Get New Var，可以直接在蓝图脚本中以节点的形式创建变量，在右侧细节面板中设置变量的值。\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-25_17-23-27.png)\n\n所有创建好的变量都会在My Blueprint面板Variables栏中显示。\n\n<font color=red> 在创建好的变量的Details/Variable/Variable Type选项中可以设置变量为普通变量、数组、Set容器和Map容器。</font>\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-27_11-01-39.png)\n\n## 2.在蓝图中使用变量\n\n可以直接在蓝图脚本区域右键->输入Get/Set [变量名]即可获取变量的获取/设置组件，也可以直接从左侧的My Blueprint面板Variables栏中拖拽变量到蓝图脚本区域选择Get/Set。\n\n## 3.生成时公开与私有变量\n\n蓝图中的公有与私有与程序中的公有私有有一些不同，蓝图中只分为生成时公开和私有两种访问权限。\n\n### 生成时公开(Expose on Spawn)\n\n勾选生成时公开后，在蓝图类使用Spawn Actor from Class组件生成蓝图类实例时，勾选生成时公开的变量将可以接受外部值输入。\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-28_16-45-41.png)\n\n如上图可以看到勾选生成时公开的变量会以输入接口的形式出现在Spawn Actor from Class节点里。这里需要注意的是，勾选Expose on Spawn，还需要勾选Instance Editable，否则会报警告。\n\n### 私有变量(Private)\n\n设置成私有变量的变量只能在蓝图类里访问，蓝图类的外部实例也无法访问这个变量，如上图，变量L没有设置成私有，所以可以通过Spawn Actor from Class组件生成的实例访问这个变量，而设置成私有的K变量搜索不到Set K节点。\n\n\n\n## 3.在蓝图中使用组件引用\n\n很多时候我们需要调节自身Actor上的组件的某些参数，那么我们就需要获得这个组件的引用以便获取组件上的参数进行调节，那么我们如何获得组件的引用呢？\n\n其实方法也很简单，在My Blueprint/Variabales下有一个子栏“Components”其中存放着当前Actor上的所有的组件的引用，使用方法就是直接将需要的组件引用拖拽到蓝图脚本区域即可。获得了组件引用我们就可以通过引用使用不同的方法获取组件上的不同的参数了。\n\n## 4.动态获取世界大纲中的Actor\n\n在蓝图脚本中有四个方法获取外部Actor：\n\n- Get All Actor of Class：通过类型来获取外部Actor\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-31-16.png)\n\n- Get All Actor with Tag：通过标签来获取外部Actor\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-31-23.png)\n\n- Get All Actor with Interface：通过外部接口在获取外部Actor\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-31-36.png)\n\n- Get Actors：通过层来获取Actor\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-31-47.png)\n\n\n\n# 三、蓝图的数据类型\n\n## 1.5个基本数据类型\n\nUE4蓝图中基本数据类型只有5个，需要注意的是蓝图中没有char、double、short、long等数据类型，在C++与蓝图的配合使用时需要注意这些类型的变量。\n\n### Boolean\n\n### Byte\n\n8位，一字节，0-255。\n\n### Integer\n\n32位整型，四字节。\n\n### Integer64\n\n64位整型，八字节，能存储更大的数。\n\n### Float\n\n32位单精度浮点型，其中1符号位、8指数位、23数值位，UE4中默认保留小数点后6位。UE4中只有Float类型没有Double类型。\n\n## 2.3种字符串\n\n### String\n\n蓝图中String类型就是蓝图C++中的FString类型，普通字符串，可以对其中的字符进行增删查改。\n\n### Name\n\nName是一种固定字符串类型，变量初始化以后不能在对其中的内容进行修改，且Name类型的字符串不区分大小写，多用于作为全局变量来唯一标识对象。Name类型的字符串在运行过程中存储于内存的字符串表中，使用效率高。\n\n### Text\n\nText是String的长度加强版，通常用于存储一段文字并可以进行国际化处理。\n\n## 3.Vector(维度向量)\n\n### Vector\n\n默认创建的Vector是Vector 3D，即三维量，包含x、y、z三个值，可以表示任何任何三维量，如：三维坐标和RGB等。\n\n### Vector 2D 和Vector 4\n\nVector 2D就是二维量，Vector 4就是四维量，常用于表示四元素。\n\n### Two Vectors\n\nTwo Vectors就是一个关于Vector的pair(对组)，pair在C++的STL种较为常用，是一个只包含两个元素的容器。\n\n## 4.Rotator(三维旋转量)\n\n包含：\n\nx：roll，翻滚角，以x为轴，进行yz平面的旋转；\n\ny：pitch，俯仰角，以y为轴，进行xz平面的旋转；\n\nz：yaw，航向角，以z为轴，进行xy平面的旋转。\n\n## 5.Transform\n\nTransfrom类型是一个3*3的矩阵，包含Location、Rotation和Scale三个三维向量。\n\n# 四、条件语句\n\n## 1.Branch(if条件判断)\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-39-15.png)\n\n传入一个bool值，进行分流，通常和比较组件配合使用，如：“==”、“>”等。\n\n## 2.Switch\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-25_19-14-34.png)\n\n- Selection：case判断的变量；\n- Default：默认执行分支；\n- Add pin：添加执行分支。\n\n# 五、循环语句\n\n## 1.For Loop(for循环)\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-39-35.png)\n\n- First Index/Last Index：提供循环的次数；\n- Loop Body：循环体执行分支；\n- Index：返回当前循环索引；\n- Conpleted：循环完毕后执行分支。\n\n## 2.For Loop whit Break(可跳出的for循环)\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-39-52.png)\n\n使用方法和For Loop类似。\n\n## 3.For Each Loop(数组遍历)\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-40-45.png)\n\n专门有用遍历数组的循环。\n\n- Array：需要遍历的数组；\n- Loop Body：循环体分支；\n- Array Element：遍历的数组元素；\n- Array Index：当前索引；\n- Completed：遍历结束执行分支。\n\n## 4.For Each Loop with Break(可跳出的数组遍历)\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-40-54.png)\n\n用法和Foreach Loop一样，只是多了一个跳出执行分支。\n\n## 5.Reverse for Each Loop(反向数组遍历)\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-40-59.png)\n\n## 6.While Loop(while循环)\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-27_11-04-21.png)\n\n# 六、数组\n\n## 1.创建数组\n\n创建数组要比创建变量多一个步骤，首先我们需要创建一个变量，然后再将这个变量的Details/Varialble Type选项的右侧色块选择九宫格，即可将对应变量转换成对应类型的数组。\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-02-54.png)\n\n## 2.为数组赋值\n\n### Add(Array)\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-21-48.png)\n\n传入一个数组和一个元素即可通过Add(Array)组件为组数赋值\n\n如：\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-24-33.png)\n\n循环完毕后数组Array内便存储有0-10的是个int型元素。\n\n## 3.获取元素\n\n### Get(a copy)\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-07-50.png)\n\n获取指定索引的元素的拷贝。\n\n### Get(a ref)\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-07-44.png)\n\n获取指定索引的元素的引用。\n\n## 4.插入元素\n\n### Add(Aray)\n\n直接在数组的末尾插入元素的方法也是使用Add(Array)组件，Add(Array)组件的的插入过程就是直接在数组的末尾插入元素。\n\n### Insert\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-37-55.png)\n\n指定位置插入使用Insert组件，输入参数从上至下依次为目标数组、要插入的元素、目标插入的索引位置。\n\n当要使用Insert组件在数组末尾插入，而又不知道数组大小时，可以使用Last Index组件直接获取输入数组的尾索引，当然直接使用只会在最后一个索引位置插入，而使最后一位元素向后移动一位，而达不到在数组尾部插入的效果，所以需要加一食用。\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-46-46.png)\n\n### Set Array Elem\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-25-34.png)\n\n设置输入数组指定索引的元素的值，Size to Fit选项可以设置如果指定索引不存在时数组自动扩充size大小。\n\n## 5.查找元素\n\n### Contains Item\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-50-31.png)\n\nContains Item组件可以查找指定数组中是否包含某一元素，但是Contains Item只返回bool的判断结果，不会返回目标的索引值。\n\n### Find Item\n\n![](B:/Git/Temp/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-59-54.png)\n\nFind Item则是从输入数组中查找指定元素并返回第一次查找到该元素的索引值。\n\n## 6.删除元素\n\n### Remove Index\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-12-59.png)\n\n通过索引删除元素\n\n### Remove Item\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-21-30.png)\n\n从输入数组中移除指定元素，Remove Item会删除数组中所有指定的元素，如果删除成功则返回true，失败则返回false。\n\n## 7.筛选元素\n\n### Filter Array\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-53-49.png)\n\n过滤数组可以按类型来筛选数组元素，用于父类型数组存储子类型元素时进行类型筛选，如：Actor数组筛选MyClass类型元素，Filter Array返回一个筛选后的新数组。\n\n## 8.清空数组\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-42-24.png)\n\n使用Clear组件可以将数组内的元素全部清空。\n\n## 9.获取数组长度\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-29-34.png)\n\n## 10.设置数组长度\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-30-00.png)\n\n# 七、结构体\n\n## 1.结构体创建\n\n蓝图中结构体的创建是没办法在蓝图脚本视图中创建的，UE4蓝图中结构体是与蓝图脚本同级的蓝图类，创建蓝图结构体的方法：在Content Browser中右键->Create Advanced Assect/Blueprint栏->Structure，即可创建一个结构体，创建出来的结构体默认拥有一个bool值得成员变量。\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-26_17-38-54.png)\n\n## 2.定义成员变量\n\n蓝图中得结构体只能创建成员变量，不能创建成员函数，成员变量可以直接设置默认值。\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-26_19-59-29.png)\n\n## 3.结构的使用\n\n将结构体创建好以后便可以直接在蓝图脚本中搜索到并使用了。\n\n# 八、枚举\n\n## 1.枚举的创建\n\n枚举的创建和使用和结构体区别不大，创建方式一如结构体一般,Content Browser中右键->Create Advanced Assect/Blueprint栏->Enumeration，创建好后UE4也会在一个新的视图中对枚举进行编辑，枚举的编辑操作也相当简单，只有向枚举中添加与删除元素的操作，这些元素都可以添加注解提示，枚举也可以添加整个枚举的注解提示。\n\n## 2.枚举的使用\n\n枚举的使用就如同变量的使用一般，没有什么可说的。\n\n# 九、接口\n\n## 1.接口的定义\n\n接口的定义和和蓝图函数库，蓝图宏库一样，但是接口的不像函数库和宏库一般可以再一个蓝图类中定义多个函数和宏，接口就是一个蓝图类，并且接口的编辑界面及其简约，可编辑视图只有一个My Blueprint和一个Detials,在My Blueprint/Functions栏可以新建接口函数，在对应的接口函数的Details/Graph可以设置一些接口函数的描述和Const属性，在Details/Inputs和Outputs栏可以设置接口函数的输入与输出参数。\n\n## 2.接口的继承\n\n接口是一个抽象蓝图，接口的实现必须通过继承接口的蓝图来实现，在蓝图中接口继承通过Toolbar/Class Settings/Interfaces栏即可添加接口到当前蓝图类是指继承此接口。\n\n## 3.接口的实现\n\n### 无返回值的接口实现\n\n在一个蓝图继承了一个无返回值得接口后，这个接口将以事件的形式出现在这个蓝图类的All Actions for this Blueprint里\n\n如：\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-27_10-32-38.png)\n\n蓝图以这个事件作为接口函数的入口，以此节点开始便可以开始实现各个蓝图类各自继承的接口函数的逻辑了。\n\n### 有返回值得接口实现\n\n有返回值的接口不会以事件的形式出现在Add Event里，而是会直接出现在My Blueprint/Interface栏里，我们双击即可打开接口函数的编辑视图，在视图中实现接口即可。\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-28_17-00-10.png)\n\n## 4.接口函数的调用\n\n蓝图通过`[接口名](Mesasge)`组件来调用接口中的函数，如下图中的Interface1(Message)和Interface2(Message)。\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-27_10-35-51.png)\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-27_10-38-13.png)\n\n接口的使用需要指定使用的接口是哪个蓝图类中实现的接口和接口需要传入的参数。在蓝图类的My Blueprint/Variables栏是可以搜索到我们自己创建的蓝图类的，通过过去蓝图类的引用便可以指定接口函数的实现者了。当然我们也可以使用Get All Actors with Interface组件来获取实现了指定接口的所有蓝图类，然后再对这些蓝图类中实现的函数进行调用。\n\n# 十、蓝图函数库\n\n<font color=red> 蓝图函数库是一个可以被所有蓝图类调用的函数集合，蓝图函数库里的方法全部都被定义为静态方法</font>，用于定义一些不与特定游戏对象绑定的功能性函数的实现。\n\n## 1.创建蓝图函数库\n\n创建蓝图函数库的方式和创建结构体类似，在Content Browser中右键->Create Advanced Assect/Blueprint栏->Bluprint Function LiberLibrary。\n\n## 2.实现蓝图函数库里的函数\n\n和结构体一样，创建好的蓝图函数库UE4会创建一个新的界面用于编辑库里函数；\n\n- 在My Blueprint/Functions栏可以申明函数\n- 在My Blueprint/Local Variables栏可以生命局部变量，在其Details中可以设置局部变量默认值；\n- 在对应函数的Details/Input和Output栏可以分别设置函数的输入输出参数\n- 在脚本编辑区可以实现函数逻辑。\n\n## 3.使用蓝图函数库里的函数\n\n要使用蓝图函数库里的函数，可直接在脚本编辑区右键输入函数名即可在Class栏中看到蓝图函数库里的函数了。\n\n# 十一、蓝图宏库\n\n宏在UE4中几乎无处不在，蓝图宏库是开发者使用蓝图自定义的一系列的宏的容器，蓝图宏库和蓝图函数库一样可以定义多个宏；\n\n- 蓝图宏库与蓝图函数库不同的是，蓝图宏库中的宏是在预编译过程中完成处理的，即蓝图宏库不需要编译；\n- 自定义的宏，可以有任意数量的输入输出引脚，即一个宏可以没有输出引脚，这样的宏可以只进行数据处理，一个宏也可以有多个输入输出引脚，这样的宏可以根据不同的逻辑选择不同的执行流，而蓝图函数库中的函数必须有且只有一个输入和一个输出引脚；\n- 与函数不同，宏中不可以再定义成员变量，即宏只负责处理逻辑，不提供暂存能力。\n\n## 1.创建蓝图宏库\n\n宏库的创建与函数库的创建是一样的，在Content Browser中右键->Create Advanced Assect/Blueprint栏->Bluprint Macro LiberLibrary。\n\n## 2.蓝图宏声明\n\n- 在My Blueprint/Macro中可以声明一个宏；\n- 在指定宏的Details/Inputs和Outputs中可以定义输入与输出引脚和参数。\n\n## 3.蓝图宏的使用\n\n和蓝图函数的使用方法一致。\n\n## 4.自定义流程控制\n\n除了蓝图提供给我们的条件语句和循环语句等流程控制语句外，我还可以使用宏编写自己的流程控制，因为宏可以有多个输入和输出引脚，使用方法就是使用宏的形式定义自己的流程控制逻辑，通过不同的输入给予不同输出，即可达到自定义流程控制的目的。\n\n# 十二、事件\n\n除了UE4蓝图中给我们提供大量的预定义事件，我也可以自定义事件。\n\n## 1.事件的定义\n\n事件的定义也很简单，在All Actions for this Buleprint中选择Add Custom Event，便可以创建一个自定义事件的入口，之后通过这个入口实现事件的内部逻辑，一个事件便定义完成。\n\n## 2.事件的调用\n\n事件调用必须通过实现这个事件的蓝图类才可以对其中的事件进行调用。如：\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-27_11-28-43.png)\n\nEvent Blueprint为实现自定义事件的蓝图类；\n\nPrint Str为自定义事件。\n\n## 3.事件调度器\n\n事件调度器的创建与使用请阅读目录：十七、蓝图类的通信/3.使用事件调度器进行通信\n\n# 十三、蓝图模块\n\n蓝图中可以将一个复杂了逻辑处理合并成一个节点模块，从而简化整体的执行流复杂度，使蓝图的执行流变得简单明了。我们可以将需要合并的执行流多选选中然后右键，即可在Organization栏中通过Collapse Nodes选项来合并执行流。\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-27_11-31-04.png)\n\n除了将执行流合并成节点外，蓝图还提供将多个执行流合并成一个函数或一个宏的功能。合并好的模块也可以在Organizition/Expand Node进行模块分离。\n\n# 十四、角色控制\n\n## 1.为角色添加跟随相机\n\n相对U3D来说，UE4的相机跟随要简单得多，UE4中直接将相机设置成了蓝图类的组件，当蓝图类时Player时，即可实现相机对Player的跟随了。\n\n相机跟随需要通过一个物理组件`Spring Arm`来链接相机和Player，将相机附着在Spring Arm下，即可在Spring Arm的作用下实现相机跟随。\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-24_10-45-29.png)\n\n## 2.为角色添加控制器\n\n在UE4的游戏制作过程中，我们不难发现当我们运行游戏时，在世界大纲中多出了很多东西，如下图：\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-24_10-53-34.png)\n\n其实，UE4为我们提供很多已经预制好的必须品，如上图的PlayerController(角色控制器)、PlayerCameraMenager(角色相机管理器)等。也就是说不可以直接使用UE4预制给我们的角色控制器来控制我们的Player，而不需要自己再去为Player蓝图配置角色控制器了，我们只需将Player的细节面板上的Auto Possess Player设置成Player0即可，Player0即表示本地角色。\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-24_10-53-06.png)\n\n需要注意的是，对于角色控制更优的方式是使用`Player Start`组件去持有Player蓝图类，再通过Player Controller来控制Player Start达到控制角色的目的。\n\n## 3.自定义游戏模式\n\n在我们创建一个UE4工程后，UE4会启用UE4默认的游戏模式`GameModeBase`，GameModeBase就控制着Player Controller、PlayerCameraMenager、PlayerState等运行时UE4动态生成的一些游戏物体，我们可以通过启用我们自定义的游戏模式来设置这些游戏物体按自己的定义的规则来生成运行。\n\n游戏模式也是一个蓝图类，创建游戏模式就是创建蓝图类，只是这个蓝图类需要继承自GameModeBase类，继承自GameModeBase类的蓝图就是一个游戏模式蓝图。不过在我们第一此=次打开游戏模式蓝图时，UE4会将游戏模式蓝图识别成一个普通蓝图，而进入普通蓝图的编辑模式，可能是bug吧，此时我们只需将蓝图关闭，再打开一次，UE4便可以识别出游戏模式蓝图了。\n\n游戏模式蓝图中可以定义自己的游戏模式规则，比如我们可以通过修改Spectator Class选项为自定义的游戏物体，这样在游戏运行时，UE4将不再生成DefaulPawn，而是会生成我们指定的游戏物体。\n\n![](【UE4】UE4蓝图基础\\Snipaste_2019-10-24_11-09-34.png)\n\n配置好游戏模式后我们还需要让当前项目使用我们自定义的游戏模式，通过Seettings ->Project Settings->Project/Maps&Modes->Dfault GameModes，选择我们自己的配置的游戏模式即可让当前项目启用我们自己定义的游戏模式了\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-24_11-12-38.png)\n\n## 4.操控角色控制器\n\n我们要操控角色控制器就需要配置键盘按键映射，配置好的键盘映射会以函数的形式加入蓝图脚本组件集中。\n\n我们在Seettings ->Project Settings->Engine/Input->Bindings/Axis Mappings设置键盘映射并可以配置映射的值，\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-24_14-55-47.png)\n\n配置好键盘映射以后便可以在蓝图脚本中使用这些函数主键来控制我们Player了，控制角色运动的方法很多，我这里以旋转力矩的方式来控制小球运动，具体的控制方法如下：\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-24_15-11-12.png)\n\n加入两个键盘映射函数组件(InputAxis MoveF/B,InputAxis MoveL/R)、两个添加角度力矩的组件(Add Torque in Radians,Add Torque in Radians)，但是添加角度力矩组件是需要一个控制目标的，我们需要从左侧的My Blueprint面板的Components中将需要控制的物体Player拖入脚本蓝图中，分别连接到添加角度力矩组件的Target上。\n\n这里还需要注意的一点是，在我们为Player添加相机时，相机使用的是相对于Player的局部坐标，使用局部坐标的相机会跟随Player旋转，而使用世界坐标的相机将会固定某一个角度跟随Player移动。切换方法为：下拉Spring Arm的细节面板/Transform/Rotation的三角箭头选择切换。\n\n并且相机默认情况下是启用了物理碰撞的，但大多数情况下我们是不需要让相机出现物理碰撞的，所以我们也应当取消相机的物理碰撞。操作方法为：取消Spring Arm的细节面板/Camera Collision/Do Collision Test选项。\n\n当然要想比较真实的模拟出物理效果，光这样是不行的，因为默认情况下Player是没有启动物理模拟的，我们需要启用Player的细节面板/Physics/Simulate Physics选项，并且将调节Player的细节面板/Linear Damping(线性摩檫)和Player的细节面板/Angular Damping(旋转摩檫)到适当的值，应为UE4默认是没有旋转摩檫的并且，默认线性摩檫为0.01。\n\n## <font color=Green> 小知识</font>\n\n- <font color=green> 大多数时候我们都需要勾选作用力函数组件的Acel Change选项，如：上面的Add Torque in Radians，勾选了Acel Change选项作用力组件会在作用目标物体时忽略物体的质量因素，因为存在质量影响的话，我们可能需要给一个极大的力才能推动目标物体；</font>\n- <font color=green> 有时可能默认大小的作用力对目标物体的移动作用达不到我们理想的效果，此时可以先将作用力加倍后在传递给作用力组件，蓝图脚本组件集中提供多种多样的乘积组件，我们上面使用的是float*float组件</font>；\n\n# 十五、触发器\n\n在游戏设计中触发器的使用是非常平凡的，而在蓝图中触发器的实现也并不复杂，我们来看一下具体操作：\n\n## 1.创建触发器\n\n- 蓝图模式中游戏的一切都是蓝图，触发器也不例外，所以要做一个触发器，首先我们的创建一个蓝图的壳子，并继承自Actor类\n- 触发器还需要一个极为重要的东西就是碰撞体，当然这里的碰撞体不是具有物理碰撞的网格碰撞体，而是蓝图的物理组件集中的Box Collison，一个没有物理碰撞效果专门用于触发器的盒碰撞体，我们给蓝图类添加这个组件，一个触发器便完成了\n\n## 2.使用触发器\n\n当触发器放置于场景中，有物体进入触发器碰撞盒时，触发器便会出自动发触发Event ActorBeginOverlap时间组件，之后我们便可以进行一系列逻辑操作了。\n\n# 十六、蓝图类的通信\n\n## 1.使用引用进行通信\n\n两个蓝图类要想通过引用进行通信，那么其中一个蓝图类就必须拥有另一个蓝图类的引用，如何获取一个蓝图类的引用呢？\n\n在My Blueprint/Variables栏中添加一个所需要引用的蓝图类类型的变量，勾选它的Details/Variable/Instance Editable选项，就可以在这个蓝图类的实例的Details/Default栏中看到引用变量(如果不勾选是没有default栏的)，如此便可以方便的获取另一个蓝图类的实例的引用了。\n\n通过引用两个蓝图类之间便可以进行单向的信息传递了。即拥有引用的蓝图类可以获取所引用蓝图的传递过来的信息，反向则不行。\n\n## 2.使用接口进行通信\n\n使用接口进行通信的好处是可以很便利的通过同一事件让各种不同的蓝图做出不同的反应，如：当受到子弹攻击时，墙会反弹子弹，人会受伤，通过接口通信来实现这个效果就是，创建一个受到子弹攻击的接口OnTakeAttack，然后分别让墙和人都继承这个接口并实现不同的效果，如此当受到子弹攻击时，我们便可以通过Get All Actor with Interface来调用实现这些接口的Actor来做出各自的反应。\n\n接口的实现与使用请阅读目录：九、接口。\n\n\n\n## 3.使用事件调度器通信\n\n事件调度器的通信过程是一个调度者与一个或多个被调度者之间的通信过程，类似观察者模式的通信过程。\n\n### 创建事件调度器\n\n使用事件调度器来进行蓝图通信，首先我们需要拥有一个事件调度器；\n\n事件调度器只能被拥有者调用，所以我们需要在调度者蓝图上创建事件调度器，在My Blueprint/Event Dispatchers栏可以新建一个蓝图调度器，此时这个蓝图便拥有了一个事件调度器，我们可以通过拖拽事件调度器到脚本编辑视图或直接在All Actions for this Blueprint中搜索，可以对事件调度器进行事件绑定(Bind)、事件解绑(Unbind)、解绑全部事件(Unbind all)，直接为事件调度器绑定新事件(Assign)和调用事件调度器(Call)。当一个事件调度器被调用后，与这个事件调度器绑定的事件都会被调用，一次来达到信息传递的目的。\n\n### 绑定事件\n\n调度者要事件调度器调用被调度者的事件，那么被调度者就需要向调度者的事件调度器上绑定事件，通过Bind Event to [事件调度器名]组件来绑定事件到事件调度器上。\n\n![](【UE4】UE4蓝图基础/Snipaste_2019-10-28_15-51-30.png)\n\nTarget：输入事件调度器的拥有者对象\n\nEvent：需要绑定的事件\n\n如此一个基于事件调度器的通信机制便完成了。\n","slug":"【UE4】UE4蓝图基础","published":1,"updated":"2021-02-01T13:22:23.104Z","_id":"ckk9hocbj003ldwr7e8jt77cw","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h1 id=\"一、蓝图可视化脚本与蓝图系统\"><a href=\"#一、蓝图可视化脚本与蓝图系统\" class=\"headerlink\" title=\"一、蓝图可视化脚本与蓝图系统\"></a>一、蓝图可视化脚本与蓝图系统</h1><h2 id=\"1-蓝图脚本\"><a href=\"#1-蓝图脚本\" class=\"headerlink\" title=\"1.蓝图脚本\"></a>1.蓝图脚本</h2><p>蓝图可视化脚本简称“蓝图”或“蓝图脚本”，是一种需要编译的面向对象的可视化编程语言，蓝图完全集成在UE4中，蓝图通过节点与连线工作。</p>\n<h3 id=\"蓝图脚本的节点\"><a href=\"#蓝图脚本的节点\" class=\"headerlink\" title=\"蓝图脚本的节点\"></a>蓝图脚本的节点</h3><ul>\n<li>触发事件，在蓝图脚本中以红色的节点出现</li>\n<li>函数，在看图脚本中以蓝色的节点出现</li>\n<li>变量，在蓝图脚本中中以黄色节点出现</li>\n</ul>\n<h2 id=\"2-蓝图系统\"><a href=\"#2-蓝图系统\" class=\"headerlink\" title=\"2.蓝图系统\"></a>2.蓝图系统</h2><p>蓝图系统又称“蓝图”或“蓝图类”，蓝图类可以看成是一个包含游戏内容的容器，其中可以包含组件、脚本或可以仅仅包含数据。</p>\n<p>蓝图类有点类似Unity3d中的预设(prefb)，蓝图类可以类似预设一般保存对象状态，可以随时拖入场景中使用，只是在其他功能上不如预设，如预设在U3D中的打包中可以发挥出优秀的效果，但是蓝图类只能作为容器使用。</p>\n<p><font color=\"red\"> 蓝图类包含蓝图脚本，每一个蓝图类都包含一个默认的蓝图脚本。</font></p>\n<h3 id=\"蓝图类的分类\"><a href=\"#蓝图类的分类\" class=\"headerlink\" title=\"蓝图类的分类\"></a>蓝图类的分类</h3><ul>\n<li><strong>关卡蓝图</strong>：关卡蓝图在每个Level中只能存在一个，负责整个关卡的运行逻辑，关卡的初始化，帧更新都在关卡蓝图里进行；</li>\n<li><strong>普通蓝图</strong>：普通蓝图就是UE4的预设，在普通蓝图中我们可以对其中的对象进行一些的配置，如设置网格，贴图，粒子特效，添加相机，添加物理材质和挂载蓝图脚本等等；</li>\n<li><strong>游戏模式蓝图</strong>：UE4中游戏模式也是以蓝图的形式存在的，游戏模式蓝图控制一系列游戏的规则；</li>\n<li><strong>材质蓝图</strong>：在UE4中贴图材质也是蓝图的形式存在的，在材质蓝图中我们可以如同建模软件一般对材质进行一系列更高级的材质配置，如下图的一个简单示例：</li>\n</ul>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-24_09-41-27.png\"></p>\n<h2 id=\"4-创建蓝图\"><a href=\"#4-创建蓝图\" class=\"headerlink\" title=\"4.创建蓝图\"></a>4.创建蓝图</h2><p>创建蓝图的方法很多，这里介绍比较常用的方法</p>\n<ul>\n<li>可以直接在Content Browser(内容浏览器)中右键创建一个空的蓝图类，空蓝图除了包含一个根组件外不再包含其他东西，当我们在空蓝图中创建了对象后可以通过拖拽的方式将对象拖动到根组件位置处，用游戏对象替换根组件作为根组件，这样创建空蓝图时的白色小球就会消失；</li>\n<li>在World Outliner(世界大纲)中选中游戏对象，可以通过工具栏中的Blueprints工具中的下面两个选项创建一个包含所选内容的蓝图类；</li>\n</ul>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-24_09-51-55.png\"></p>\n<ul>\n<li>通过Blueprints工具的New Empty Blueprint Class也可以直接创建空蓝图类；</li>\n<li>然而关卡蓝图似乎只能通过Blueprints工具的Open Blueprint Class打开。</li>\n</ul>\n<h1 id=\"二、变量与对象引用\"><a href=\"#二、变量与对象引用\" class=\"headerlink\" title=\"二、变量与对象引用\"></a>二、变量与对象引用</h1><h2 id=\"1-在蓝图中创建变量\"><a href=\"#1-在蓝图中创建变量\" class=\"headerlink\" title=\"1.在蓝图中创建变量\"></a>1.在蓝图中创建变量</h2><p>在蓝图中创建变量的方式有两种，其一：直接点击My BluePrint/Variables/+Variable，默认创建bool行的变量，可以点击变量前的色块更换变量类型。</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_17-18-23.png\"></p>\n<p>其二：在蓝图脚本区域右键-&gt;输入Get New Var，可以直接在蓝图脚本中以节点的形式创建变量，在右侧细节面板中设置变量的值。</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_17-23-27.png\"></p>\n<p>所有创建好的变量都会在My Blueprint面板Variables栏中显示。</p>\n<p><font color=\"red\"> 在创建好的变量的Details/Variable/Variable Type选项中可以设置变量为普通变量、数组、Set容器和Map容器。</font></p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-27_11-01-39.png\"></p>\n<h2 id=\"2-在蓝图中使用变量\"><a href=\"#2-在蓝图中使用变量\" class=\"headerlink\" title=\"2.在蓝图中使用变量\"></a>2.在蓝图中使用变量</h2><p>可以直接在蓝图脚本区域右键-&gt;输入Get/Set [变量名]即可获取变量的获取/设置组件，也可以直接从左侧的My Blueprint面板Variables栏中拖拽变量到蓝图脚本区域选择Get/Set。</p>\n<h2 id=\"3-生成时公开与私有变量\"><a href=\"#3-生成时公开与私有变量\" class=\"headerlink\" title=\"3.生成时公开与私有变量\"></a>3.生成时公开与私有变量</h2><p>蓝图中的公有与私有与程序中的公有私有有一些不同，蓝图中只分为生成时公开和私有两种访问权限。</p>\n<h3 id=\"生成时公开-Expose-on-Spawn\"><a href=\"#生成时公开-Expose-on-Spawn\" class=\"headerlink\" title=\"生成时公开(Expose on Spawn)\"></a>生成时公开(Expose on Spawn)</h3><p>勾选生成时公开后，在蓝图类使用Spawn Actor from Class组件生成蓝图类实例时，勾选生成时公开的变量将可以接受外部值输入。<br><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-28_16-45-41.png\"></p>\n<p>如上图可以看到勾选生成时公开的变量会以输入接口的形式出现在Spawn Actor from Class节点里。这里需要注意的是，勾选Expose on Spawn，还需要勾选Instance Editable，否则会报警告。</p>\n<h3 id=\"私有变量-Private\"><a href=\"#私有变量-Private\" class=\"headerlink\" title=\"私有变量(Private)\"></a>私有变量(Private)</h3><p>设置成私有变量的变量只能在蓝图类里访问，蓝图类的外部实例也无法访问这个变量，如上图，变量L没有设置成私有，所以可以通过Spawn Actor from Class组件生成的实例访问这个变量，而设置成私有的K变量搜索不到Set K节点。</p>\n<h2 id=\"3-在蓝图中使用组件引用\"><a href=\"#3-在蓝图中使用组件引用\" class=\"headerlink\" title=\"3.在蓝图中使用组件引用\"></a>3.在蓝图中使用组件引用</h2><p>很多时候我们需要调节自身Actor上的组件的某些参数，那么我们就需要获得这个组件的引用以便获取组件上的参数进行调节，那么我们如何获得组件的引用呢？</p>\n<p>其实方法也很简单，在My Blueprint/Variabales下有一个子栏“Components”其中存放着当前Actor上的所有的组件的引用，使用方法就是直接将需要的组件引用拖拽到蓝图脚本区域即可。获得了组件引用我们就可以通过引用使用不同的方法获取组件上的不同的参数了。</p>\n<h2 id=\"4-动态获取世界大纲中的Actor\"><a href=\"#4-动态获取世界大纲中的Actor\" class=\"headerlink\" title=\"4.动态获取世界大纲中的Actor\"></a>4.动态获取世界大纲中的Actor</h2><p>在蓝图脚本中有四个方法获取外部Actor：</p>\n<ul>\n<li>Get All Actor of Class：通过类型来获取外部Actor</li>\n</ul>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_18-31-16.png\"></p>\n<ul>\n<li>Get All Actor with Tag：通过标签来获取外部Actor</li>\n</ul>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_18-31-23.png\"></p>\n<ul>\n<li>Get All Actor with Interface：通过外部接口在获取外部Actor</li>\n</ul>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_18-31-36.png\"></p>\n<ul>\n<li>Get Actors：通过层来获取Actor</li>\n</ul>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_18-31-47.png\"></p>\n<h1 id=\"三、蓝图的数据类型\"><a href=\"#三、蓝图的数据类型\" class=\"headerlink\" title=\"三、蓝图的数据类型\"></a>三、蓝图的数据类型</h1><h2 id=\"1-5个基本数据类型\"><a href=\"#1-5个基本数据类型\" class=\"headerlink\" title=\"1.5个基本数据类型\"></a>1.5个基本数据类型</h2><p>UE4蓝图中基本数据类型只有5个，需要注意的是蓝图中没有char、double、short、long等数据类型，在C++与蓝图的配合使用时需要注意这些类型的变量。</p>\n<h3 id=\"Boolean\"><a href=\"#Boolean\" class=\"headerlink\" title=\"Boolean\"></a>Boolean</h3><h3 id=\"Byte\"><a href=\"#Byte\" class=\"headerlink\" title=\"Byte\"></a>Byte</h3><p>8位，一字节，0-255。</p>\n<h3 id=\"Integer\"><a href=\"#Integer\" class=\"headerlink\" title=\"Integer\"></a>Integer</h3><p>32位整型，四字节。</p>\n<h3 id=\"Integer64\"><a href=\"#Integer64\" class=\"headerlink\" title=\"Integer64\"></a>Integer64</h3><p>64位整型，八字节，能存储更大的数。</p>\n<h3 id=\"Float\"><a href=\"#Float\" class=\"headerlink\" title=\"Float\"></a>Float</h3><p>32位单精度浮点型，其中1符号位、8指数位、23数值位，UE4中默认保留小数点后6位。UE4中只有Float类型没有Double类型。</p>\n<h2 id=\"2-3种字符串\"><a href=\"#2-3种字符串\" class=\"headerlink\" title=\"2.3种字符串\"></a>2.3种字符串</h2><h3 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h3><p>蓝图中String类型就是蓝图C++中的FString类型，普通字符串，可以对其中的字符进行增删查改。</p>\n<h3 id=\"Name\"><a href=\"#Name\" class=\"headerlink\" title=\"Name\"></a>Name</h3><p>Name是一种固定字符串类型，变量初始化以后不能在对其中的内容进行修改，且Name类型的字符串不区分大小写，多用于作为全局变量来唯一标识对象。Name类型的字符串在运行过程中存储于内存的字符串表中，使用效率高。</p>\n<h3 id=\"Text\"><a href=\"#Text\" class=\"headerlink\" title=\"Text\"></a>Text</h3><p>Text是String的长度加强版，通常用于存储一段文字并可以进行国际化处理。</p>\n<h2 id=\"3-Vector-维度向量\"><a href=\"#3-Vector-维度向量\" class=\"headerlink\" title=\"3.Vector(维度向量)\"></a>3.Vector(维度向量)</h2><h3 id=\"Vector\"><a href=\"#Vector\" class=\"headerlink\" title=\"Vector\"></a>Vector</h3><p>默认创建的Vector是Vector 3D，即三维量，包含x、y、z三个值，可以表示任何任何三维量，如：三维坐标和RGB等。</p>\n<h3 id=\"Vector-2D-和Vector-4\"><a href=\"#Vector-2D-和Vector-4\" class=\"headerlink\" title=\"Vector 2D 和Vector 4\"></a>Vector 2D 和Vector 4</h3><p>Vector 2D就是二维量，Vector 4就是四维量，常用于表示四元素。</p>\n<h3 id=\"Two-Vectors\"><a href=\"#Two-Vectors\" class=\"headerlink\" title=\"Two Vectors\"></a>Two Vectors</h3><p>Two Vectors就是一个关于Vector的pair(对组)，pair在C++的STL种较为常用，是一个只包含两个元素的容器。</p>\n<h2 id=\"4-Rotator-三维旋转量\"><a href=\"#4-Rotator-三维旋转量\" class=\"headerlink\" title=\"4.Rotator(三维旋转量)\"></a>4.Rotator(三维旋转量)</h2><p>包含：</p>\n<p>x：roll，翻滚角，以x为轴，进行yz平面的旋转；</p>\n<p>y：pitch，俯仰角，以y为轴，进行xz平面的旋转；</p>\n<p>z：yaw，航向角，以z为轴，进行xy平面的旋转。</p>\n<h2 id=\"5-Transform\"><a href=\"#5-Transform\" class=\"headerlink\" title=\"5.Transform\"></a>5.Transform</h2><p>Transfrom类型是一个3*3的矩阵，包含Location、Rotation和Scale三个三维向量。</p>\n<h1 id=\"四、条件语句\"><a href=\"#四、条件语句\" class=\"headerlink\" title=\"四、条件语句\"></a>四、条件语句</h1><h2 id=\"1-Branch-if条件判断\"><a href=\"#1-Branch-if条件判断\" class=\"headerlink\" title=\"1.Branch(if条件判断)\"></a>1.Branch(if条件判断)</h2><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_18-39-15.png\"></p>\n<p>传入一个bool值，进行分流，通常和比较组件配合使用，如：“==”、“&gt;”等。</p>\n<h2 id=\"2-Switch\"><a href=\"#2-Switch\" class=\"headerlink\" title=\"2.Switch\"></a>2.Switch</h2><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_19-14-34.png\"></p>\n<ul>\n<li>Selection：case判断的变量；</li>\n<li>Default：默认执行分支；</li>\n<li>Add pin：添加执行分支。</li>\n</ul>\n<h1 id=\"五、循环语句\"><a href=\"#五、循环语句\" class=\"headerlink\" title=\"五、循环语句\"></a>五、循环语句</h1><h2 id=\"1-For-Loop-for循环\"><a href=\"#1-For-Loop-for循环\" class=\"headerlink\" title=\"1.For Loop(for循环)\"></a>1.For Loop(for循环)</h2><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_18-39-35.png\"></p>\n<ul>\n<li>First Index/Last Index：提供循环的次数；</li>\n<li>Loop Body：循环体执行分支；</li>\n<li>Index：返回当前循环索引；</li>\n<li>Conpleted：循环完毕后执行分支。</li>\n</ul>\n<h2 id=\"2-For-Loop-whit-Break-可跳出的for循环\"><a href=\"#2-For-Loop-whit-Break-可跳出的for循环\" class=\"headerlink\" title=\"2.For Loop whit Break(可跳出的for循环)\"></a>2.For Loop whit Break(可跳出的for循环)</h2><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_18-39-52.png\"></p>\n<p>使用方法和For Loop类似。</p>\n<h2 id=\"3-For-Each-Loop-数组遍历\"><a href=\"#3-For-Each-Loop-数组遍历\" class=\"headerlink\" title=\"3.For Each Loop(数组遍历)\"></a>3.For Each Loop(数组遍历)</h2><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_18-40-45.png\"></p>\n<p>专门有用遍历数组的循环。</p>\n<ul>\n<li>Array：需要遍历的数组；</li>\n<li>Loop Body：循环体分支；</li>\n<li>Array Element：遍历的数组元素；</li>\n<li>Array Index：当前索引；</li>\n<li>Completed：遍历结束执行分支。</li>\n</ul>\n<h2 id=\"4-For-Each-Loop-with-Break-可跳出的数组遍历\"><a href=\"#4-For-Each-Loop-with-Break-可跳出的数组遍历\" class=\"headerlink\" title=\"4.For Each Loop with Break(可跳出的数组遍历)\"></a>4.For Each Loop with Break(可跳出的数组遍历)</h2><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_18-40-54.png\"></p>\n<p>用法和Foreach Loop一样，只是多了一个跳出执行分支。</p>\n<h2 id=\"5-Reverse-for-Each-Loop-反向数组遍历\"><a href=\"#5-Reverse-for-Each-Loop-反向数组遍历\" class=\"headerlink\" title=\"5.Reverse for Each Loop(反向数组遍历)\"></a>5.Reverse for Each Loop(反向数组遍历)</h2><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_18-40-59.png\"></p>\n<h2 id=\"6-While-Loop-while循环\"><a href=\"#6-While-Loop-while循环\" class=\"headerlink\" title=\"6.While Loop(while循环)\"></a>6.While Loop(while循环)</h2><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-27_11-04-21.png\"></p>\n<h1 id=\"六、数组\"><a href=\"#六、数组\" class=\"headerlink\" title=\"六、数组\"></a>六、数组</h1><h2 id=\"1-创建数组\"><a href=\"#1-创建数组\" class=\"headerlink\" title=\"1.创建数组\"></a>1.创建数组</h2><p>创建数组要比创建变量多一个步骤，首先我们需要创建一个变量，然后再将这个变量的Details/Varialble Type选项的右侧色块选择九宫格，即可将对应变量转换成对应类型的数组。</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_11-02-54.png\"></p>\n<h2 id=\"2-为数组赋值\"><a href=\"#2-为数组赋值\" class=\"headerlink\" title=\"2.为数组赋值\"></a>2.为数组赋值</h2><h3 id=\"Add-Array\"><a href=\"#Add-Array\" class=\"headerlink\" title=\"Add(Array)\"></a>Add(Array)</h3><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_11-21-48.png\"></p>\n<p>传入一个数组和一个元素即可通过Add(Array)组件为组数赋值</p>\n<p>如：</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_11-24-33.png\"></p>\n<p>循环完毕后数组Array内便存储有0-10的是个int型元素。</p>\n<h2 id=\"3-获取元素\"><a href=\"#3-获取元素\" class=\"headerlink\" title=\"3.获取元素\"></a>3.获取元素</h2><h3 id=\"Get-a-copy\"><a href=\"#Get-a-copy\" class=\"headerlink\" title=\"Get(a copy)\"></a>Get(a copy)</h3><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_12-07-50.png\"></p>\n<p>获取指定索引的元素的拷贝。</p>\n<h3 id=\"Get-a-ref\"><a href=\"#Get-a-ref\" class=\"headerlink\" title=\"Get(a ref)\"></a>Get(a ref)</h3><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_12-07-44.png\"></p>\n<p>获取指定索引的元素的引用。</p>\n<h2 id=\"4-插入元素\"><a href=\"#4-插入元素\" class=\"headerlink\" title=\"4.插入元素\"></a>4.插入元素</h2><h3 id=\"Add-Aray\"><a href=\"#Add-Aray\" class=\"headerlink\" title=\"Add(Aray)\"></a>Add(Aray)</h3><p>直接在数组的末尾插入元素的方法也是使用Add(Array)组件，Add(Array)组件的的插入过程就是直接在数组的末尾插入元素。</p>\n<h3 id=\"Insert\"><a href=\"#Insert\" class=\"headerlink\" title=\"Insert\"></a>Insert</h3><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_11-37-55.png\"></p>\n<p>指定位置插入使用Insert组件，输入参数从上至下依次为目标数组、要插入的元素、目标插入的索引位置。</p>\n<p>当要使用Insert组件在数组末尾插入，而又不知道数组大小时，可以使用Last Index组件直接获取输入数组的尾索引，当然直接使用只会在最后一个索引位置插入，而使最后一位元素向后移动一位，而达不到在数组尾部插入的效果，所以需要加一食用。</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_11-46-46.png\"></p>\n<h3 id=\"Set-Array-Elem\"><a href=\"#Set-Array-Elem\" class=\"headerlink\" title=\"Set Array Elem\"></a>Set Array Elem</h3><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_12-25-34.png\"></p>\n<p>设置输入数组指定索引的元素的值，Size to Fit选项可以设置如果指定索引不存在时数组自动扩充size大小。</p>\n<h2 id=\"5-查找元素\"><a href=\"#5-查找元素\" class=\"headerlink\" title=\"5.查找元素\"></a>5.查找元素</h2><h3 id=\"Contains-Item\"><a href=\"#Contains-Item\" class=\"headerlink\" title=\"Contains Item\"></a>Contains Item</h3><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_11-50-31.png\"></p>\n<p>Contains Item组件可以查找指定数组中是否包含某一元素，但是Contains Item只返回bool的判断结果，不会返回目标的索引值。</p>\n<h3 id=\"Find-Item\"><a href=\"#Find-Item\" class=\"headerlink\" title=\"Find Item\"></a>Find Item</h3><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Git/Temp/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-59-54.png\"></p>\n<p>Find Item则是从输入数组中查找指定元素并返回第一次查找到该元素的索引值。</p>\n<h2 id=\"6-删除元素\"><a href=\"#6-删除元素\" class=\"headerlink\" title=\"6.删除元素\"></a>6.删除元素</h2><h3 id=\"Remove-Index\"><a href=\"#Remove-Index\" class=\"headerlink\" title=\"Remove Index\"></a>Remove Index</h3><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_12-12-59.png\"></p>\n<p>通过索引删除元素</p>\n<h3 id=\"Remove-Item\"><a href=\"#Remove-Item\" class=\"headerlink\" title=\"Remove Item\"></a>Remove Item</h3><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_12-21-30.png\"></p>\n<p>从输入数组中移除指定元素，Remove Item会删除数组中所有指定的元素，如果删除成功则返回true，失败则返回false。</p>\n<h2 id=\"7-筛选元素\"><a href=\"#7-筛选元素\" class=\"headerlink\" title=\"7.筛选元素\"></a>7.筛选元素</h2><h3 id=\"Filter-Array\"><a href=\"#Filter-Array\" class=\"headerlink\" title=\"Filter Array\"></a>Filter Array</h3><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_11-53-49.png\"></p>\n<p>过滤数组可以按类型来筛选数组元素，用于父类型数组存储子类型元素时进行类型筛选，如：Actor数组筛选MyClass类型元素，Filter Array返回一个筛选后的新数组。</p>\n<h2 id=\"8-清空数组\"><a href=\"#8-清空数组\" class=\"headerlink\" title=\"8.清空数组\"></a>8.清空数组</h2><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_11-42-24.png\"></p>\n<p>使用Clear组件可以将数组内的元素全部清空。</p>\n<h2 id=\"9-获取数组长度\"><a href=\"#9-获取数组长度\" class=\"headerlink\" title=\"9.获取数组长度\"></a>9.获取数组长度</h2><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_12-29-34.png\"></p>\n<h2 id=\"10-设置数组长度\"><a href=\"#10-设置数组长度\" class=\"headerlink\" title=\"10.设置数组长度\"></a>10.设置数组长度</h2><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_12-30-00.png\"></p>\n<h1 id=\"七、结构体\"><a href=\"#七、结构体\" class=\"headerlink\" title=\"七、结构体\"></a>七、结构体</h1><h2 id=\"1-结构体创建\"><a href=\"#1-结构体创建\" class=\"headerlink\" title=\"1.结构体创建\"></a>1.结构体创建</h2><p>蓝图中结构体的创建是没办法在蓝图脚本视图中创建的，UE4蓝图中结构体是与蓝图脚本同级的蓝图类，创建蓝图结构体的方法：在Content Browser中右键-&gt;Create Advanced Assect/Blueprint栏-&gt;Structure，即可创建一个结构体，创建出来的结构体默认拥有一个bool值得成员变量。</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_17-38-54.png\"></p>\n<h2 id=\"2-定义成员变量\"><a href=\"#2-定义成员变量\" class=\"headerlink\" title=\"2.定义成员变量\"></a>2.定义成员变量</h2><p>蓝图中得结构体只能创建成员变量，不能创建成员函数，成员变量可以直接设置默认值。</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_19-59-29.png\"></p>\n<h2 id=\"3-结构的使用\"><a href=\"#3-结构的使用\" class=\"headerlink\" title=\"3.结构的使用\"></a>3.结构的使用</h2><p>将结构体创建好以后便可以直接在蓝图脚本中搜索到并使用了。</p>\n<h1 id=\"八、枚举\"><a href=\"#八、枚举\" class=\"headerlink\" title=\"八、枚举\"></a>八、枚举</h1><h2 id=\"1-枚举的创建\"><a href=\"#1-枚举的创建\" class=\"headerlink\" title=\"1.枚举的创建\"></a>1.枚举的创建</h2><p>枚举的创建和使用和结构体区别不大，创建方式一如结构体一般,Content Browser中右键-&gt;Create Advanced Assect/Blueprint栏-&gt;Enumeration，创建好后UE4也会在一个新的视图中对枚举进行编辑，枚举的编辑操作也相当简单，只有向枚举中添加与删除元素的操作，这些元素都可以添加注解提示，枚举也可以添加整个枚举的注解提示。</p>\n<h2 id=\"2-枚举的使用\"><a href=\"#2-枚举的使用\" class=\"headerlink\" title=\"2.枚举的使用\"></a>2.枚举的使用</h2><p>枚举的使用就如同变量的使用一般，没有什么可说的。</p>\n<h1 id=\"九、接口\"><a href=\"#九、接口\" class=\"headerlink\" title=\"九、接口\"></a>九、接口</h1><h2 id=\"1-接口的定义\"><a href=\"#1-接口的定义\" class=\"headerlink\" title=\"1.接口的定义\"></a>1.接口的定义</h2><p>接口的定义和和蓝图函数库，蓝图宏库一样，但是接口的不像函数库和宏库一般可以再一个蓝图类中定义多个函数和宏，接口就是一个蓝图类，并且接口的编辑界面及其简约，可编辑视图只有一个My Blueprint和一个Detials,在My Blueprint/Functions栏可以新建接口函数，在对应的接口函数的Details/Graph可以设置一些接口函数的描述和Const属性，在Details/Inputs和Outputs栏可以设置接口函数的输入与输出参数。</p>\n<h2 id=\"2-接口的继承\"><a href=\"#2-接口的继承\" class=\"headerlink\" title=\"2.接口的继承\"></a>2.接口的继承</h2><p>接口是一个抽象蓝图，接口的实现必须通过继承接口的蓝图来实现，在蓝图中接口继承通过Toolbar/Class Settings/Interfaces栏即可添加接口到当前蓝图类是指继承此接口。</p>\n<h2 id=\"3-接口的实现\"><a href=\"#3-接口的实现\" class=\"headerlink\" title=\"3.接口的实现\"></a>3.接口的实现</h2><h3 id=\"无返回值的接口实现\"><a href=\"#无返回值的接口实现\" class=\"headerlink\" title=\"无返回值的接口实现\"></a>无返回值的接口实现</h3><p>在一个蓝图继承了一个无返回值得接口后，这个接口将以事件的形式出现在这个蓝图类的All Actions for this Blueprint里</p>\n<p>如：</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-27_10-32-38.png\"></p>\n<p>蓝图以这个事件作为接口函数的入口，以此节点开始便可以开始实现各个蓝图类各自继承的接口函数的逻辑了。</p>\n<h3 id=\"有返回值得接口实现\"><a href=\"#有返回值得接口实现\" class=\"headerlink\" title=\"有返回值得接口实现\"></a>有返回值得接口实现</h3><p>有返回值的接口不会以事件的形式出现在Add Event里，而是会直接出现在My Blueprint/Interface栏里，我们双击即可打开接口函数的编辑视图，在视图中实现接口即可。</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-28_17-00-10.png\"></p>\n<h2 id=\"4-接口函数的调用\"><a href=\"#4-接口函数的调用\" class=\"headerlink\" title=\"4.接口函数的调用\"></a>4.接口函数的调用</h2><p>蓝图通过<code>[接口名](Mesasge)</code>组件来调用接口中的函数，如下图中的Interface1(Message)和Interface2(Message)。</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-27_10-35-51.png\"></p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-27_10-38-13.png\"></p>\n<p>接口的使用需要指定使用的接口是哪个蓝图类中实现的接口和接口需要传入的参数。在蓝图类的My Blueprint/Variables栏是可以搜索到我们自己创建的蓝图类的，通过过去蓝图类的引用便可以指定接口函数的实现者了。当然我们也可以使用Get All Actors with Interface组件来获取实现了指定接口的所有蓝图类，然后再对这些蓝图类中实现的函数进行调用。</p>\n<h1 id=\"十、蓝图函数库\"><a href=\"#十、蓝图函数库\" class=\"headerlink\" title=\"十、蓝图函数库\"></a>十、蓝图函数库</h1><p><font color=\"red\"> 蓝图函数库是一个可以被所有蓝图类调用的函数集合，蓝图函数库里的方法全部都被定义为静态方法</font>，用于定义一些不与特定游戏对象绑定的功能性函数的实现。</p>\n<h2 id=\"1-创建蓝图函数库\"><a href=\"#1-创建蓝图函数库\" class=\"headerlink\" title=\"1.创建蓝图函数库\"></a>1.创建蓝图函数库</h2><p>创建蓝图函数库的方式和创建结构体类似，在Content Browser中右键-&gt;Create Advanced Assect/Blueprint栏-&gt;Bluprint Function LiberLibrary。</p>\n<h2 id=\"2-实现蓝图函数库里的函数\"><a href=\"#2-实现蓝图函数库里的函数\" class=\"headerlink\" title=\"2.实现蓝图函数库里的函数\"></a>2.实现蓝图函数库里的函数</h2><p>和结构体一样，创建好的蓝图函数库UE4会创建一个新的界面用于编辑库里函数；</p>\n<ul>\n<li>在My Blueprint/Functions栏可以申明函数</li>\n<li>在My Blueprint/Local Variables栏可以生命局部变量，在其Details中可以设置局部变量默认值；</li>\n<li>在对应函数的Details/Input和Output栏可以分别设置函数的输入输出参数</li>\n<li>在脚本编辑区可以实现函数逻辑。</li>\n</ul>\n<h2 id=\"3-使用蓝图函数库里的函数\"><a href=\"#3-使用蓝图函数库里的函数\" class=\"headerlink\" title=\"3.使用蓝图函数库里的函数\"></a>3.使用蓝图函数库里的函数</h2><p>要使用蓝图函数库里的函数，可直接在脚本编辑区右键输入函数名即可在Class栏中看到蓝图函数库里的函数了。</p>\n<h1 id=\"十一、蓝图宏库\"><a href=\"#十一、蓝图宏库\" class=\"headerlink\" title=\"十一、蓝图宏库\"></a>十一、蓝图宏库</h1><p>宏在UE4中几乎无处不在，蓝图宏库是开发者使用蓝图自定义的一系列的宏的容器，蓝图宏库和蓝图函数库一样可以定义多个宏；</p>\n<ul>\n<li>蓝图宏库与蓝图函数库不同的是，蓝图宏库中的宏是在预编译过程中完成处理的，即蓝图宏库不需要编译；</li>\n<li>自定义的宏，可以有任意数量的输入输出引脚，即一个宏可以没有输出引脚，这样的宏可以只进行数据处理，一个宏也可以有多个输入输出引脚，这样的宏可以根据不同的逻辑选择不同的执行流，而蓝图函数库中的函数必须有且只有一个输入和一个输出引脚；</li>\n<li>与函数不同，宏中不可以再定义成员变量，即宏只负责处理逻辑，不提供暂存能力。</li>\n</ul>\n<h2 id=\"1-创建蓝图宏库\"><a href=\"#1-创建蓝图宏库\" class=\"headerlink\" title=\"1.创建蓝图宏库\"></a>1.创建蓝图宏库</h2><p>宏库的创建与函数库的创建是一样的，在Content Browser中右键-&gt;Create Advanced Assect/Blueprint栏-&gt;Bluprint Macro LiberLibrary。</p>\n<h2 id=\"2-蓝图宏声明\"><a href=\"#2-蓝图宏声明\" class=\"headerlink\" title=\"2.蓝图宏声明\"></a>2.蓝图宏声明</h2><ul>\n<li>在My Blueprint/Macro中可以声明一个宏；</li>\n<li>在指定宏的Details/Inputs和Outputs中可以定义输入与输出引脚和参数。</li>\n</ul>\n<h2 id=\"3-蓝图宏的使用\"><a href=\"#3-蓝图宏的使用\" class=\"headerlink\" title=\"3.蓝图宏的使用\"></a>3.蓝图宏的使用</h2><p>和蓝图函数的使用方法一致。</p>\n<h2 id=\"4-自定义流程控制\"><a href=\"#4-自定义流程控制\" class=\"headerlink\" title=\"4.自定义流程控制\"></a>4.自定义流程控制</h2><p>除了蓝图提供给我们的条件语句和循环语句等流程控制语句外，我还可以使用宏编写自己的流程控制，因为宏可以有多个输入和输出引脚，使用方法就是使用宏的形式定义自己的流程控制逻辑，通过不同的输入给予不同输出，即可达到自定义流程控制的目的。</p>\n<h1 id=\"十二、事件\"><a href=\"#十二、事件\" class=\"headerlink\" title=\"十二、事件\"></a>十二、事件</h1><p>除了UE4蓝图中给我们提供大量的预定义事件，我也可以自定义事件。</p>\n<h2 id=\"1-事件的定义\"><a href=\"#1-事件的定义\" class=\"headerlink\" title=\"1.事件的定义\"></a>1.事件的定义</h2><p>事件的定义也很简单，在All Actions for this Buleprint中选择Add Custom Event，便可以创建一个自定义事件的入口，之后通过这个入口实现事件的内部逻辑，一个事件便定义完成。</p>\n<h2 id=\"2-事件的调用\"><a href=\"#2-事件的调用\" class=\"headerlink\" title=\"2.事件的调用\"></a>2.事件的调用</h2><p>事件调用必须通过实现这个事件的蓝图类才可以对其中的事件进行调用。如：</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-27_11-28-43.png\"></p>\n<p>Event Blueprint为实现自定义事件的蓝图类；</p>\n<p>Print Str为自定义事件。</p>\n<h2 id=\"3-事件调度器\"><a href=\"#3-事件调度器\" class=\"headerlink\" title=\"3.事件调度器\"></a>3.事件调度器</h2><p>事件调度器的创建与使用请阅读目录：十七、蓝图类的通信/3.使用事件调度器进行通信</p>\n<h1 id=\"十三、蓝图模块\"><a href=\"#十三、蓝图模块\" class=\"headerlink\" title=\"十三、蓝图模块\"></a>十三、蓝图模块</h1><p>蓝图中可以将一个复杂了逻辑处理合并成一个节点模块，从而简化整体的执行流复杂度，使蓝图的执行流变得简单明了。我们可以将需要合并的执行流多选选中然后右键，即可在Organization栏中通过Collapse Nodes选项来合并执行流。</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-27_11-31-04.png\"></p>\n<p>除了将执行流合并成节点外，蓝图还提供将多个执行流合并成一个函数或一个宏的功能。合并好的模块也可以在Organizition/Expand Node进行模块分离。</p>\n<h1 id=\"十四、角色控制\"><a href=\"#十四、角色控制\" class=\"headerlink\" title=\"十四、角色控制\"></a>十四、角色控制</h1><h2 id=\"1-为角色添加跟随相机\"><a href=\"#1-为角色添加跟随相机\" class=\"headerlink\" title=\"1.为角色添加跟随相机\"></a>1.为角色添加跟随相机</h2><p>相对U3D来说，UE4的相机跟随要简单得多，UE4中直接将相机设置成了蓝图类的组件，当蓝图类时Player时，即可实现相机对Player的跟随了。</p>\n<p>相机跟随需要通过一个物理组件<code>Spring Arm</code>来链接相机和Player，将相机附着在Spring Arm下，即可在Spring Arm的作用下实现相机跟随。</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-24_10-45-29.png\"></p>\n<h2 id=\"2-为角色添加控制器\"><a href=\"#2-为角色添加控制器\" class=\"headerlink\" title=\"2.为角色添加控制器\"></a>2.为角色添加控制器</h2><p>在UE4的游戏制作过程中，我们不难发现当我们运行游戏时，在世界大纲中多出了很多东西，如下图：</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-24_10-53-34.png\"></p>\n<p>其实，UE4为我们提供很多已经预制好的必须品，如上图的PlayerController(角色控制器)、PlayerCameraMenager(角色相机管理器)等。也就是说不可以直接使用UE4预制给我们的角色控制器来控制我们的Player，而不需要自己再去为Player蓝图配置角色控制器了，我们只需将Player的细节面板上的Auto Possess Player设置成Player0即可，Player0即表示本地角色。</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-24_10-53-06.png\"></p>\n<p>需要注意的是，对于角色控制更优的方式是使用<code>Player Start</code>组件去持有Player蓝图类，再通过Player Controller来控制Player Start达到控制角色的目的。</p>\n<h2 id=\"3-自定义游戏模式\"><a href=\"#3-自定义游戏模式\" class=\"headerlink\" title=\"3.自定义游戏模式\"></a>3.自定义游戏模式</h2><p>在我们创建一个UE4工程后，UE4会启用UE4默认的游戏模式<code>GameModeBase</code>，GameModeBase就控制着Player Controller、PlayerCameraMenager、PlayerState等运行时UE4动态生成的一些游戏物体，我们可以通过启用我们自定义的游戏模式来设置这些游戏物体按自己的定义的规则来生成运行。</p>\n<p>游戏模式也是一个蓝图类，创建游戏模式就是创建蓝图类，只是这个蓝图类需要继承自GameModeBase类，继承自GameModeBase类的蓝图就是一个游戏模式蓝图。不过在我们第一此=次打开游戏模式蓝图时，UE4会将游戏模式蓝图识别成一个普通蓝图，而进入普通蓝图的编辑模式，可能是bug吧，此时我们只需将蓝图关闭，再打开一次，UE4便可以识别出游戏模式蓝图了。</p>\n<p>游戏模式蓝图中可以定义自己的游戏模式规则，比如我们可以通过修改Spectator Class选项为自定义的游戏物体，这样在游戏运行时，UE4将不再生成DefaulPawn，而是会生成我们指定的游戏物体。</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80%5CSnipaste_2019-10-24_11-09-34.png\"></p>\n<p>配置好游戏模式后我们还需要让当前项目使用我们自定义的游戏模式，通过Seettings -&gt;Project Settings-&gt;Project/Maps&amp;Modes-&gt;Dfault GameModes，选择我们自己的配置的游戏模式即可让当前项目启用我们自己定义的游戏模式了</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-24_11-12-38.png\"></p>\n<h2 id=\"4-操控角色控制器\"><a href=\"#4-操控角色控制器\" class=\"headerlink\" title=\"4.操控角色控制器\"></a>4.操控角色控制器</h2><p>我们要操控角色控制器就需要配置键盘按键映射，配置好的键盘映射会以函数的形式加入蓝图脚本组件集中。</p>\n<p>我们在Seettings -&gt;Project Settings-&gt;Engine/Input-&gt;Bindings/Axis Mappings设置键盘映射并可以配置映射的值，</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-24_14-55-47.png\"></p>\n<p>配置好键盘映射以后便可以在蓝图脚本中使用这些函数主键来控制我们Player了，控制角色运动的方法很多，我这里以旋转力矩的方式来控制小球运动，具体的控制方法如下：</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-24_15-11-12.png\"></p>\n<p>加入两个键盘映射函数组件(InputAxis MoveF/B,InputAxis MoveL/R)、两个添加角度力矩的组件(Add Torque in Radians,Add Torque in Radians)，但是添加角度力矩组件是需要一个控制目标的，我们需要从左侧的My Blueprint面板的Components中将需要控制的物体Player拖入脚本蓝图中，分别连接到添加角度力矩组件的Target上。</p>\n<p>这里还需要注意的一点是，在我们为Player添加相机时，相机使用的是相对于Player的局部坐标，使用局部坐标的相机会跟随Player旋转，而使用世界坐标的相机将会固定某一个角度跟随Player移动。切换方法为：下拉Spring Arm的细节面板/Transform/Rotation的三角箭头选择切换。</p>\n<p>并且相机默认情况下是启用了物理碰撞的，但大多数情况下我们是不需要让相机出现物理碰撞的，所以我们也应当取消相机的物理碰撞。操作方法为：取消Spring Arm的细节面板/Camera Collision/Do Collision Test选项。</p>\n<p>当然要想比较真实的模拟出物理效果，光这样是不行的，因为默认情况下Player是没有启动物理模拟的，我们需要启用Player的细节面板/Physics/Simulate Physics选项，并且将调节Player的细节面板/Linear Damping(线性摩檫)和Player的细节面板/Angular Damping(旋转摩檫)到适当的值，应为UE4默认是没有旋转摩檫的并且，默认线性摩檫为0.01。</p>\n<h2 id=\"小知识\"><a href=\"#小知识\" class=\"headerlink\" title=\" 小知识\"></a><font color=\"Green\"> 小知识</font></h2><ul>\n<li><font color=\"green\"> 大多数时候我们都需要勾选作用力函数组件的Acel Change选项，如：上面的Add Torque in Radians，勾选了Acel Change选项作用力组件会在作用目标物体时忽略物体的质量因素，因为存在质量影响的话，我们可能需要给一个极大的力才能推动目标物体；</font></li>\n<li><font color=\"green\"> 有时可能默认大小的作用力对目标物体的移动作用达不到我们理想的效果，此时可以先将作用力加倍后在传递给作用力组件，蓝图脚本组件集中提供多种多样的乘积组件，我们上面使用的是float*float组件</font>；</li>\n</ul>\n<h1 id=\"十五、触发器\"><a href=\"#十五、触发器\" class=\"headerlink\" title=\"十五、触发器\"></a>十五、触发器</h1><p>在游戏设计中触发器的使用是非常平凡的，而在蓝图中触发器的实现也并不复杂，我们来看一下具体操作：</p>\n<h2 id=\"1-创建触发器\"><a href=\"#1-创建触发器\" class=\"headerlink\" title=\"1.创建触发器\"></a>1.创建触发器</h2><ul>\n<li>蓝图模式中游戏的一切都是蓝图，触发器也不例外，所以要做一个触发器，首先我们的创建一个蓝图的壳子，并继承自Actor类</li>\n<li>触发器还需要一个极为重要的东西就是碰撞体，当然这里的碰撞体不是具有物理碰撞的网格碰撞体，而是蓝图的物理组件集中的Box Collison，一个没有物理碰撞效果专门用于触发器的盒碰撞体，我们给蓝图类添加这个组件，一个触发器便完成了</li>\n</ul>\n<h2 id=\"2-使用触发器\"><a href=\"#2-使用触发器\" class=\"headerlink\" title=\"2.使用触发器\"></a>2.使用触发器</h2><p>当触发器放置于场景中，有物体进入触发器碰撞盒时，触发器便会出自动发触发Event ActorBeginOverlap时间组件，之后我们便可以进行一系列逻辑操作了。</p>\n<h1 id=\"十六、蓝图类的通信\"><a href=\"#十六、蓝图类的通信\" class=\"headerlink\" title=\"十六、蓝图类的通信\"></a>十六、蓝图类的通信</h1><h2 id=\"1-使用引用进行通信\"><a href=\"#1-使用引用进行通信\" class=\"headerlink\" title=\"1.使用引用进行通信\"></a>1.使用引用进行通信</h2><p>两个蓝图类要想通过引用进行通信，那么其中一个蓝图类就必须拥有另一个蓝图类的引用，如何获取一个蓝图类的引用呢？</p>\n<p>在My Blueprint/Variables栏中添加一个所需要引用的蓝图类类型的变量，勾选它的Details/Variable/Instance Editable选项，就可以在这个蓝图类的实例的Details/Default栏中看到引用变量(如果不勾选是没有default栏的)，如此便可以方便的获取另一个蓝图类的实例的引用了。</p>\n<p>通过引用两个蓝图类之间便可以进行单向的信息传递了。即拥有引用的蓝图类可以获取所引用蓝图的传递过来的信息，反向则不行。</p>\n<h2 id=\"2-使用接口进行通信\"><a href=\"#2-使用接口进行通信\" class=\"headerlink\" title=\"2.使用接口进行通信\"></a>2.使用接口进行通信</h2><p>使用接口进行通信的好处是可以很便利的通过同一事件让各种不同的蓝图做出不同的反应，如：当受到子弹攻击时，墙会反弹子弹，人会受伤，通过接口通信来实现这个效果就是，创建一个受到子弹攻击的接口OnTakeAttack，然后分别让墙和人都继承这个接口并实现不同的效果，如此当受到子弹攻击时，我们便可以通过Get All Actor with Interface来调用实现这些接口的Actor来做出各自的反应。</p>\n<p>接口的实现与使用请阅读目录：九、接口。</p>\n<h2 id=\"3-使用事件调度器通信\"><a href=\"#3-使用事件调度器通信\" class=\"headerlink\" title=\"3.使用事件调度器通信\"></a>3.使用事件调度器通信</h2><p>事件调度器的通信过程是一个调度者与一个或多个被调度者之间的通信过程，类似观察者模式的通信过程。</p>\n<h3 id=\"创建事件调度器\"><a href=\"#创建事件调度器\" class=\"headerlink\" title=\"创建事件调度器\"></a>创建事件调度器</h3><p>使用事件调度器来进行蓝图通信，首先我们需要拥有一个事件调度器；</p>\n<p>事件调度器只能被拥有者调用，所以我们需要在调度者蓝图上创建事件调度器，在My Blueprint/Event Dispatchers栏可以新建一个蓝图调度器，此时这个蓝图便拥有了一个事件调度器，我们可以通过拖拽事件调度器到脚本编辑视图或直接在All Actions for this Blueprint中搜索，可以对事件调度器进行事件绑定(Bind)、事件解绑(Unbind)、解绑全部事件(Unbind all)，直接为事件调度器绑定新事件(Assign)和调用事件调度器(Call)。当一个事件调度器被调用后，与这个事件调度器绑定的事件都会被调用，一次来达到信息传递的目的。</p>\n<h3 id=\"绑定事件\"><a href=\"#绑定事件\" class=\"headerlink\" title=\"绑定事件\"></a>绑定事件</h3><p>调度者要事件调度器调用被调度者的事件，那么被调度者就需要向调度者的事件调度器上绑定事件，通过Bind Event to [事件调度器名]组件来绑定事件到事件调度器上。</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-28_15-51-30.png\"></p>\n<p>Target：输入事件调度器的拥有者对象</p>\n<p>Event：需要绑定的事件</p>\n<p>如此一个基于事件调度器的通信机制便完成了。</p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h1 id=\"一、蓝图可视化脚本与蓝图系统\"><a href=\"#一、蓝图可视化脚本与蓝图系统\" class=\"headerlink\" title=\"一、蓝图可视化脚本与蓝图系统\"></a>一、蓝图可视化脚本与蓝图系统</h1><h2 id=\"1-蓝图脚本\"><a href=\"#1-蓝图脚本\" class=\"headerlink\" title=\"1.蓝图脚本\"></a>1.蓝图脚本</h2><p>蓝图可视化脚本简称“蓝图”或“蓝图脚本”，是一种需要编译的面向对象的可视化编程语言，蓝图完全集成在UE4中，蓝图通过节点与连线工作。</p>\n<h3 id=\"蓝图脚本的节点\"><a href=\"#蓝图脚本的节点\" class=\"headerlink\" title=\"蓝图脚本的节点\"></a>蓝图脚本的节点</h3><ul>\n<li>触发事件，在蓝图脚本中以红色的节点出现</li>\n<li>函数，在看图脚本中以蓝色的节点出现</li>\n<li>变量，在蓝图脚本中中以黄色节点出现</li>\n</ul>\n<h2 id=\"2-蓝图系统\"><a href=\"#2-蓝图系统\" class=\"headerlink\" title=\"2.蓝图系统\"></a>2.蓝图系统</h2><p>蓝图系统又称“蓝图”或“蓝图类”，蓝图类可以看成是一个包含游戏内容的容器，其中可以包含组件、脚本或可以仅仅包含数据。</p>\n<p>蓝图类有点类似Unity3d中的预设(prefb)，蓝图类可以类似预设一般保存对象状态，可以随时拖入场景中使用，只是在其他功能上不如预设，如预设在U3D中的打包中可以发挥出优秀的效果，但是蓝图类只能作为容器使用。</p>\n<p><font color=\"red\"> 蓝图类包含蓝图脚本，每一个蓝图类都包含一个默认的蓝图脚本。</font></p>\n<h3 id=\"蓝图类的分类\"><a href=\"#蓝图类的分类\" class=\"headerlink\" title=\"蓝图类的分类\"></a>蓝图类的分类</h3><ul>\n<li><strong>关卡蓝图</strong>：关卡蓝图在每个Level中只能存在一个，负责整个关卡的运行逻辑，关卡的初始化，帧更新都在关卡蓝图里进行；</li>\n<li><strong>普通蓝图</strong>：普通蓝图就是UE4的预设，在普通蓝图中我们可以对其中的对象进行一些的配置，如设置网格，贴图，粒子特效，添加相机，添加物理材质和挂载蓝图脚本等等；</li>\n<li><strong>游戏模式蓝图</strong>：UE4中游戏模式也是以蓝图的形式存在的，游戏模式蓝图控制一系列游戏的规则；</li>\n<li><strong>材质蓝图</strong>：在UE4中贴图材质也是蓝图的形式存在的，在材质蓝图中我们可以如同建模软件一般对材质进行一系列更高级的材质配置，如下图的一个简单示例：</li>\n</ul>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-24_09-41-27.png\"></p>\n<h2 id=\"4-创建蓝图\"><a href=\"#4-创建蓝图\" class=\"headerlink\" title=\"4.创建蓝图\"></a>4.创建蓝图</h2><p>创建蓝图的方法很多，这里介绍比较常用的方法</p>\n<ul>\n<li>可以直接在Content Browser(内容浏览器)中右键创建一个空的蓝图类，空蓝图除了包含一个根组件外不再包含其他东西，当我们在空蓝图中创建了对象后可以通过拖拽的方式将对象拖动到根组件位置处，用游戏对象替换根组件作为根组件，这样创建空蓝图时的白色小球就会消失；</li>\n<li>在World Outliner(世界大纲)中选中游戏对象，可以通过工具栏中的Blueprints工具中的下面两个选项创建一个包含所选内容的蓝图类；</li>\n</ul>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-24_09-51-55.png\"></p>\n<ul>\n<li>通过Blueprints工具的New Empty Blueprint Class也可以直接创建空蓝图类；</li>\n<li>然而关卡蓝图似乎只能通过Blueprints工具的Open Blueprint Class打开。</li>\n</ul>\n<h1 id=\"二、变量与对象引用\"><a href=\"#二、变量与对象引用\" class=\"headerlink\" title=\"二、变量与对象引用\"></a>二、变量与对象引用</h1><h2 id=\"1-在蓝图中创建变量\"><a href=\"#1-在蓝图中创建变量\" class=\"headerlink\" title=\"1.在蓝图中创建变量\"></a>1.在蓝图中创建变量</h2><p>在蓝图中创建变量的方式有两种，其一：直接点击My BluePrint/Variables/+Variable，默认创建bool行的变量，可以点击变量前的色块更换变量类型。</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_17-18-23.png\"></p>\n<p>其二：在蓝图脚本区域右键-&gt;输入Get New Var，可以直接在蓝图脚本中以节点的形式创建变量，在右侧细节面板中设置变量的值。</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_17-23-27.png\"></p>\n<p>所有创建好的变量都会在My Blueprint面板Variables栏中显示。</p>\n<p><font color=\"red\"> 在创建好的变量的Details/Variable/Variable Type选项中可以设置变量为普通变量、数组、Set容器和Map容器。</font></p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-27_11-01-39.png\"></p>\n<h2 id=\"2-在蓝图中使用变量\"><a href=\"#2-在蓝图中使用变量\" class=\"headerlink\" title=\"2.在蓝图中使用变量\"></a>2.在蓝图中使用变量</h2><p>可以直接在蓝图脚本区域右键-&gt;输入Get/Set [变量名]即可获取变量的获取/设置组件，也可以直接从左侧的My Blueprint面板Variables栏中拖拽变量到蓝图脚本区域选择Get/Set。</p>\n<h2 id=\"3-生成时公开与私有变量\"><a href=\"#3-生成时公开与私有变量\" class=\"headerlink\" title=\"3.生成时公开与私有变量\"></a>3.生成时公开与私有变量</h2><p>蓝图中的公有与私有与程序中的公有私有有一些不同，蓝图中只分为生成时公开和私有两种访问权限。</p>\n<h3 id=\"生成时公开-Expose-on-Spawn\"><a href=\"#生成时公开-Expose-on-Spawn\" class=\"headerlink\" title=\"生成时公开(Expose on Spawn)\"></a>生成时公开(Expose on Spawn)</h3><p>勾选生成时公开后，在蓝图类使用Spawn Actor from Class组件生成蓝图类实例时，勾选生成时公开的变量将可以接受外部值输入。<br><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-28_16-45-41.png\"></p>\n<p>如上图可以看到勾选生成时公开的变量会以输入接口的形式出现在Spawn Actor from Class节点里。这里需要注意的是，勾选Expose on Spawn，还需要勾选Instance Editable，否则会报警告。</p>\n<h3 id=\"私有变量-Private\"><a href=\"#私有变量-Private\" class=\"headerlink\" title=\"私有变量(Private)\"></a>私有变量(Private)</h3><p>设置成私有变量的变量只能在蓝图类里访问，蓝图类的外部实例也无法访问这个变量，如上图，变量L没有设置成私有，所以可以通过Spawn Actor from Class组件生成的实例访问这个变量，而设置成私有的K变量搜索不到Set K节点。</p>\n<h2 id=\"3-在蓝图中使用组件引用\"><a href=\"#3-在蓝图中使用组件引用\" class=\"headerlink\" title=\"3.在蓝图中使用组件引用\"></a>3.在蓝图中使用组件引用</h2><p>很多时候我们需要调节自身Actor上的组件的某些参数，那么我们就需要获得这个组件的引用以便获取组件上的参数进行调节，那么我们如何获得组件的引用呢？</p>\n<p>其实方法也很简单，在My Blueprint/Variabales下有一个子栏“Components”其中存放着当前Actor上的所有的组件的引用，使用方法就是直接将需要的组件引用拖拽到蓝图脚本区域即可。获得了组件引用我们就可以通过引用使用不同的方法获取组件上的不同的参数了。</p>\n<h2 id=\"4-动态获取世界大纲中的Actor\"><a href=\"#4-动态获取世界大纲中的Actor\" class=\"headerlink\" title=\"4.动态获取世界大纲中的Actor\"></a>4.动态获取世界大纲中的Actor</h2><p>在蓝图脚本中有四个方法获取外部Actor：</p>\n<ul>\n<li>Get All Actor of Class：通过类型来获取外部Actor</li>\n</ul>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_18-31-16.png\"></p>\n<ul>\n<li>Get All Actor with Tag：通过标签来获取外部Actor</li>\n</ul>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_18-31-23.png\"></p>\n<ul>\n<li>Get All Actor with Interface：通过外部接口在获取外部Actor</li>\n</ul>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_18-31-36.png\"></p>\n<ul>\n<li>Get Actors：通过层来获取Actor</li>\n</ul>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_18-31-47.png\"></p>\n<h1 id=\"三、蓝图的数据类型\"><a href=\"#三、蓝图的数据类型\" class=\"headerlink\" title=\"三、蓝图的数据类型\"></a>三、蓝图的数据类型</h1><h2 id=\"1-5个基本数据类型\"><a href=\"#1-5个基本数据类型\" class=\"headerlink\" title=\"1.5个基本数据类型\"></a>1.5个基本数据类型</h2><p>UE4蓝图中基本数据类型只有5个，需要注意的是蓝图中没有char、double、short、long等数据类型，在C++与蓝图的配合使用时需要注意这些类型的变量。</p>\n<h3 id=\"Boolean\"><a href=\"#Boolean\" class=\"headerlink\" title=\"Boolean\"></a>Boolean</h3><h3 id=\"Byte\"><a href=\"#Byte\" class=\"headerlink\" title=\"Byte\"></a>Byte</h3><p>8位，一字节，0-255。</p>\n<h3 id=\"Integer\"><a href=\"#Integer\" class=\"headerlink\" title=\"Integer\"></a>Integer</h3><p>32位整型，四字节。</p>\n<h3 id=\"Integer64\"><a href=\"#Integer64\" class=\"headerlink\" title=\"Integer64\"></a>Integer64</h3><p>64位整型，八字节，能存储更大的数。</p>\n<h3 id=\"Float\"><a href=\"#Float\" class=\"headerlink\" title=\"Float\"></a>Float</h3><p>32位单精度浮点型，其中1符号位、8指数位、23数值位，UE4中默认保留小数点后6位。UE4中只有Float类型没有Double类型。</p>\n<h2 id=\"2-3种字符串\"><a href=\"#2-3种字符串\" class=\"headerlink\" title=\"2.3种字符串\"></a>2.3种字符串</h2><h3 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h3><p>蓝图中String类型就是蓝图C++中的FString类型，普通字符串，可以对其中的字符进行增删查改。</p>\n<h3 id=\"Name\"><a href=\"#Name\" class=\"headerlink\" title=\"Name\"></a>Name</h3><p>Name是一种固定字符串类型，变量初始化以后不能在对其中的内容进行修改，且Name类型的字符串不区分大小写，多用于作为全局变量来唯一标识对象。Name类型的字符串在运行过程中存储于内存的字符串表中，使用效率高。</p>\n<h3 id=\"Text\"><a href=\"#Text\" class=\"headerlink\" title=\"Text\"></a>Text</h3><p>Text是String的长度加强版，通常用于存储一段文字并可以进行国际化处理。</p>\n<h2 id=\"3-Vector-维度向量\"><a href=\"#3-Vector-维度向量\" class=\"headerlink\" title=\"3.Vector(维度向量)\"></a>3.Vector(维度向量)</h2><h3 id=\"Vector\"><a href=\"#Vector\" class=\"headerlink\" title=\"Vector\"></a>Vector</h3><p>默认创建的Vector是Vector 3D，即三维量，包含x、y、z三个值，可以表示任何任何三维量，如：三维坐标和RGB等。</p>\n<h3 id=\"Vector-2D-和Vector-4\"><a href=\"#Vector-2D-和Vector-4\" class=\"headerlink\" title=\"Vector 2D 和Vector 4\"></a>Vector 2D 和Vector 4</h3><p>Vector 2D就是二维量，Vector 4就是四维量，常用于表示四元素。</p>\n<h3 id=\"Two-Vectors\"><a href=\"#Two-Vectors\" class=\"headerlink\" title=\"Two Vectors\"></a>Two Vectors</h3><p>Two Vectors就是一个关于Vector的pair(对组)，pair在C++的STL种较为常用，是一个只包含两个元素的容器。</p>\n<h2 id=\"4-Rotator-三维旋转量\"><a href=\"#4-Rotator-三维旋转量\" class=\"headerlink\" title=\"4.Rotator(三维旋转量)\"></a>4.Rotator(三维旋转量)</h2><p>包含：</p>\n<p>x：roll，翻滚角，以x为轴，进行yz平面的旋转；</p>\n<p>y：pitch，俯仰角，以y为轴，进行xz平面的旋转；</p>\n<p>z：yaw，航向角，以z为轴，进行xy平面的旋转。</p>\n<h2 id=\"5-Transform\"><a href=\"#5-Transform\" class=\"headerlink\" title=\"5.Transform\"></a>5.Transform</h2><p>Transfrom类型是一个3*3的矩阵，包含Location、Rotation和Scale三个三维向量。</p>\n<h1 id=\"四、条件语句\"><a href=\"#四、条件语句\" class=\"headerlink\" title=\"四、条件语句\"></a>四、条件语句</h1><h2 id=\"1-Branch-if条件判断\"><a href=\"#1-Branch-if条件判断\" class=\"headerlink\" title=\"1.Branch(if条件判断)\"></a>1.Branch(if条件判断)</h2><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_18-39-15.png\"></p>\n<p>传入一个bool值，进行分流，通常和比较组件配合使用，如：“==”、“&gt;”等。</p>\n<h2 id=\"2-Switch\"><a href=\"#2-Switch\" class=\"headerlink\" title=\"2.Switch\"></a>2.Switch</h2><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_19-14-34.png\"></p>\n<ul>\n<li>Selection：case判断的变量；</li>\n<li>Default：默认执行分支；</li>\n<li>Add pin：添加执行分支。</li>\n</ul>\n<h1 id=\"五、循环语句\"><a href=\"#五、循环语句\" class=\"headerlink\" title=\"五、循环语句\"></a>五、循环语句</h1><h2 id=\"1-For-Loop-for循环\"><a href=\"#1-For-Loop-for循环\" class=\"headerlink\" title=\"1.For Loop(for循环)\"></a>1.For Loop(for循环)</h2><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_18-39-35.png\"></p>\n<ul>\n<li>First Index/Last Index：提供循环的次数；</li>\n<li>Loop Body：循环体执行分支；</li>\n<li>Index：返回当前循环索引；</li>\n<li>Conpleted：循环完毕后执行分支。</li>\n</ul>\n<h2 id=\"2-For-Loop-whit-Break-可跳出的for循环\"><a href=\"#2-For-Loop-whit-Break-可跳出的for循环\" class=\"headerlink\" title=\"2.For Loop whit Break(可跳出的for循环)\"></a>2.For Loop whit Break(可跳出的for循环)</h2><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_18-39-52.png\"></p>\n<p>使用方法和For Loop类似。</p>\n<h2 id=\"3-For-Each-Loop-数组遍历\"><a href=\"#3-For-Each-Loop-数组遍历\" class=\"headerlink\" title=\"3.For Each Loop(数组遍历)\"></a>3.For Each Loop(数组遍历)</h2><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_18-40-45.png\"></p>\n<p>专门有用遍历数组的循环。</p>\n<ul>\n<li>Array：需要遍历的数组；</li>\n<li>Loop Body：循环体分支；</li>\n<li>Array Element：遍历的数组元素；</li>\n<li>Array Index：当前索引；</li>\n<li>Completed：遍历结束执行分支。</li>\n</ul>\n<h2 id=\"4-For-Each-Loop-with-Break-可跳出的数组遍历\"><a href=\"#4-For-Each-Loop-with-Break-可跳出的数组遍历\" class=\"headerlink\" title=\"4.For Each Loop with Break(可跳出的数组遍历)\"></a>4.For Each Loop with Break(可跳出的数组遍历)</h2><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_18-40-54.png\"></p>\n<p>用法和Foreach Loop一样，只是多了一个跳出执行分支。</p>\n<h2 id=\"5-Reverse-for-Each-Loop-反向数组遍历\"><a href=\"#5-Reverse-for-Each-Loop-反向数组遍历\" class=\"headerlink\" title=\"5.Reverse for Each Loop(反向数组遍历)\"></a>5.Reverse for Each Loop(反向数组遍历)</h2><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_18-40-59.png\"></p>\n<h2 id=\"6-While-Loop-while循环\"><a href=\"#6-While-Loop-while循环\" class=\"headerlink\" title=\"6.While Loop(while循环)\"></a>6.While Loop(while循环)</h2><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-27_11-04-21.png\"></p>\n<h1 id=\"六、数组\"><a href=\"#六、数组\" class=\"headerlink\" title=\"六、数组\"></a>六、数组</h1><h2 id=\"1-创建数组\"><a href=\"#1-创建数组\" class=\"headerlink\" title=\"1.创建数组\"></a>1.创建数组</h2><p>创建数组要比创建变量多一个步骤，首先我们需要创建一个变量，然后再将这个变量的Details/Varialble Type选项的右侧色块选择九宫格，即可将对应变量转换成对应类型的数组。</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_11-02-54.png\"></p>\n<h2 id=\"2-为数组赋值\"><a href=\"#2-为数组赋值\" class=\"headerlink\" title=\"2.为数组赋值\"></a>2.为数组赋值</h2><h3 id=\"Add-Array\"><a href=\"#Add-Array\" class=\"headerlink\" title=\"Add(Array)\"></a>Add(Array)</h3><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_11-21-48.png\"></p>\n<p>传入一个数组和一个元素即可通过Add(Array)组件为组数赋值</p>\n<p>如：</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_11-24-33.png\"></p>\n<p>循环完毕后数组Array内便存储有0-10的是个int型元素。</p>\n<h2 id=\"3-获取元素\"><a href=\"#3-获取元素\" class=\"headerlink\" title=\"3.获取元素\"></a>3.获取元素</h2><h3 id=\"Get-a-copy\"><a href=\"#Get-a-copy\" class=\"headerlink\" title=\"Get(a copy)\"></a>Get(a copy)</h3><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_12-07-50.png\"></p>\n<p>获取指定索引的元素的拷贝。</p>\n<h3 id=\"Get-a-ref\"><a href=\"#Get-a-ref\" class=\"headerlink\" title=\"Get(a ref)\"></a>Get(a ref)</h3><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_12-07-44.png\"></p>\n<p>获取指定索引的元素的引用。</p>\n<h2 id=\"4-插入元素\"><a href=\"#4-插入元素\" class=\"headerlink\" title=\"4.插入元素\"></a>4.插入元素</h2><h3 id=\"Add-Aray\"><a href=\"#Add-Aray\" class=\"headerlink\" title=\"Add(Aray)\"></a>Add(Aray)</h3><p>直接在数组的末尾插入元素的方法也是使用Add(Array)组件，Add(Array)组件的的插入过程就是直接在数组的末尾插入元素。</p>\n<h3 id=\"Insert\"><a href=\"#Insert\" class=\"headerlink\" title=\"Insert\"></a>Insert</h3><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_11-37-55.png\"></p>\n<p>指定位置插入使用Insert组件，输入参数从上至下依次为目标数组、要插入的元素、目标插入的索引位置。</p>\n<p>当要使用Insert组件在数组末尾插入，而又不知道数组大小时，可以使用Last Index组件直接获取输入数组的尾索引，当然直接使用只会在最后一个索引位置插入，而使最后一位元素向后移动一位，而达不到在数组尾部插入的效果，所以需要加一食用。</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_11-46-46.png\"></p>\n<h3 id=\"Set-Array-Elem\"><a href=\"#Set-Array-Elem\" class=\"headerlink\" title=\"Set Array Elem\"></a>Set Array Elem</h3><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_12-25-34.png\"></p>\n<p>设置输入数组指定索引的元素的值，Size to Fit选项可以设置如果指定索引不存在时数组自动扩充size大小。</p>\n<h2 id=\"5-查找元素\"><a href=\"#5-查找元素\" class=\"headerlink\" title=\"5.查找元素\"></a>5.查找元素</h2><h3 id=\"Contains-Item\"><a href=\"#Contains-Item\" class=\"headerlink\" title=\"Contains Item\"></a>Contains Item</h3><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_11-50-31.png\"></p>\n<p>Contains Item组件可以查找指定数组中是否包含某一元素，但是Contains Item只返回bool的判断结果，不会返回目标的索引值。</p>\n<h3 id=\"Find-Item\"><a href=\"#Find-Item\" class=\"headerlink\" title=\"Find Item\"></a>Find Item</h3><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Git/Temp/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-59-54.png\"></p>\n<p>Find Item则是从输入数组中查找指定元素并返回第一次查找到该元素的索引值。</p>\n<h2 id=\"6-删除元素\"><a href=\"#6-删除元素\" class=\"headerlink\" title=\"6.删除元素\"></a>6.删除元素</h2><h3 id=\"Remove-Index\"><a href=\"#Remove-Index\" class=\"headerlink\" title=\"Remove Index\"></a>Remove Index</h3><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_12-12-59.png\"></p>\n<p>通过索引删除元素</p>\n<h3 id=\"Remove-Item\"><a href=\"#Remove-Item\" class=\"headerlink\" title=\"Remove Item\"></a>Remove Item</h3><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_12-21-30.png\"></p>\n<p>从输入数组中移除指定元素，Remove Item会删除数组中所有指定的元素，如果删除成功则返回true，失败则返回false。</p>\n<h2 id=\"7-筛选元素\"><a href=\"#7-筛选元素\" class=\"headerlink\" title=\"7.筛选元素\"></a>7.筛选元素</h2><h3 id=\"Filter-Array\"><a href=\"#Filter-Array\" class=\"headerlink\" title=\"Filter Array\"></a>Filter Array</h3><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_11-53-49.png\"></p>\n<p>过滤数组可以按类型来筛选数组元素，用于父类型数组存储子类型元素时进行类型筛选，如：Actor数组筛选MyClass类型元素，Filter Array返回一个筛选后的新数组。</p>\n<h2 id=\"8-清空数组\"><a href=\"#8-清空数组\" class=\"headerlink\" title=\"8.清空数组\"></a>8.清空数组</h2><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_11-42-24.png\"></p>\n<p>使用Clear组件可以将数组内的元素全部清空。</p>\n<h2 id=\"9-获取数组长度\"><a href=\"#9-获取数组长度\" class=\"headerlink\" title=\"9.获取数组长度\"></a>9.获取数组长度</h2><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_12-29-34.png\"></p>\n<h2 id=\"10-设置数组长度\"><a href=\"#10-设置数组长度\" class=\"headerlink\" title=\"10.设置数组长度\"></a>10.设置数组长度</h2><p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_12-30-00.png\"></p>\n<h1 id=\"七、结构体\"><a href=\"#七、结构体\" class=\"headerlink\" title=\"七、结构体\"></a>七、结构体</h1><h2 id=\"1-结构体创建\"><a href=\"#1-结构体创建\" class=\"headerlink\" title=\"1.结构体创建\"></a>1.结构体创建</h2><p>蓝图中结构体的创建是没办法在蓝图脚本视图中创建的，UE4蓝图中结构体是与蓝图脚本同级的蓝图类，创建蓝图结构体的方法：在Content Browser中右键-&gt;Create Advanced Assect/Blueprint栏-&gt;Structure，即可创建一个结构体，创建出来的结构体默认拥有一个bool值得成员变量。</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_17-38-54.png\"></p>\n<h2 id=\"2-定义成员变量\"><a href=\"#2-定义成员变量\" class=\"headerlink\" title=\"2.定义成员变量\"></a>2.定义成员变量</h2><p>蓝图中得结构体只能创建成员变量，不能创建成员函数，成员变量可以直接设置默认值。</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_19-59-29.png\"></p>\n<h2 id=\"3-结构的使用\"><a href=\"#3-结构的使用\" class=\"headerlink\" title=\"3.结构的使用\"></a>3.结构的使用</h2><p>将结构体创建好以后便可以直接在蓝图脚本中搜索到并使用了。</p>\n<h1 id=\"八、枚举\"><a href=\"#八、枚举\" class=\"headerlink\" title=\"八、枚举\"></a>八、枚举</h1><h2 id=\"1-枚举的创建\"><a href=\"#1-枚举的创建\" class=\"headerlink\" title=\"1.枚举的创建\"></a>1.枚举的创建</h2><p>枚举的创建和使用和结构体区别不大，创建方式一如结构体一般,Content Browser中右键-&gt;Create Advanced Assect/Blueprint栏-&gt;Enumeration，创建好后UE4也会在一个新的视图中对枚举进行编辑，枚举的编辑操作也相当简单，只有向枚举中添加与删除元素的操作，这些元素都可以添加注解提示，枚举也可以添加整个枚举的注解提示。</p>\n<h2 id=\"2-枚举的使用\"><a href=\"#2-枚举的使用\" class=\"headerlink\" title=\"2.枚举的使用\"></a>2.枚举的使用</h2><p>枚举的使用就如同变量的使用一般，没有什么可说的。</p>\n<h1 id=\"九、接口\"><a href=\"#九、接口\" class=\"headerlink\" title=\"九、接口\"></a>九、接口</h1><h2 id=\"1-接口的定义\"><a href=\"#1-接口的定义\" class=\"headerlink\" title=\"1.接口的定义\"></a>1.接口的定义</h2><p>接口的定义和和蓝图函数库，蓝图宏库一样，但是接口的不像函数库和宏库一般可以再一个蓝图类中定义多个函数和宏，接口就是一个蓝图类，并且接口的编辑界面及其简约，可编辑视图只有一个My Blueprint和一个Detials,在My Blueprint/Functions栏可以新建接口函数，在对应的接口函数的Details/Graph可以设置一些接口函数的描述和Const属性，在Details/Inputs和Outputs栏可以设置接口函数的输入与输出参数。</p>\n<h2 id=\"2-接口的继承\"><a href=\"#2-接口的继承\" class=\"headerlink\" title=\"2.接口的继承\"></a>2.接口的继承</h2><p>接口是一个抽象蓝图，接口的实现必须通过继承接口的蓝图来实现，在蓝图中接口继承通过Toolbar/Class Settings/Interfaces栏即可添加接口到当前蓝图类是指继承此接口。</p>\n<h2 id=\"3-接口的实现\"><a href=\"#3-接口的实现\" class=\"headerlink\" title=\"3.接口的实现\"></a>3.接口的实现</h2><h3 id=\"无返回值的接口实现\"><a href=\"#无返回值的接口实现\" class=\"headerlink\" title=\"无返回值的接口实现\"></a>无返回值的接口实现</h3><p>在一个蓝图继承了一个无返回值得接口后，这个接口将以事件的形式出现在这个蓝图类的All Actions for this Blueprint里</p>\n<p>如：</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-27_10-32-38.png\"></p>\n<p>蓝图以这个事件作为接口函数的入口，以此节点开始便可以开始实现各个蓝图类各自继承的接口函数的逻辑了。</p>\n<h3 id=\"有返回值得接口实现\"><a href=\"#有返回值得接口实现\" class=\"headerlink\" title=\"有返回值得接口实现\"></a>有返回值得接口实现</h3><p>有返回值的接口不会以事件的形式出现在Add Event里，而是会直接出现在My Blueprint/Interface栏里，我们双击即可打开接口函数的编辑视图，在视图中实现接口即可。</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-28_17-00-10.png\"></p>\n<h2 id=\"4-接口函数的调用\"><a href=\"#4-接口函数的调用\" class=\"headerlink\" title=\"4.接口函数的调用\"></a>4.接口函数的调用</h2><p>蓝图通过<code>[接口名](Mesasge)</code>组件来调用接口中的函数，如下图中的Interface1(Message)和Interface2(Message)。</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-27_10-35-51.png\"></p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-27_10-38-13.png\"></p>\n<p>接口的使用需要指定使用的接口是哪个蓝图类中实现的接口和接口需要传入的参数。在蓝图类的My Blueprint/Variables栏是可以搜索到我们自己创建的蓝图类的，通过过去蓝图类的引用便可以指定接口函数的实现者了。当然我们也可以使用Get All Actors with Interface组件来获取实现了指定接口的所有蓝图类，然后再对这些蓝图类中实现的函数进行调用。</p>\n<h1 id=\"十、蓝图函数库\"><a href=\"#十、蓝图函数库\" class=\"headerlink\" title=\"十、蓝图函数库\"></a>十、蓝图函数库</h1><p><font color=\"red\"> 蓝图函数库是一个可以被所有蓝图类调用的函数集合，蓝图函数库里的方法全部都被定义为静态方法</font>，用于定义一些不与特定游戏对象绑定的功能性函数的实现。</p>\n<h2 id=\"1-创建蓝图函数库\"><a href=\"#1-创建蓝图函数库\" class=\"headerlink\" title=\"1.创建蓝图函数库\"></a>1.创建蓝图函数库</h2><p>创建蓝图函数库的方式和创建结构体类似，在Content Browser中右键-&gt;Create Advanced Assect/Blueprint栏-&gt;Bluprint Function LiberLibrary。</p>\n<h2 id=\"2-实现蓝图函数库里的函数\"><a href=\"#2-实现蓝图函数库里的函数\" class=\"headerlink\" title=\"2.实现蓝图函数库里的函数\"></a>2.实现蓝图函数库里的函数</h2><p>和结构体一样，创建好的蓝图函数库UE4会创建一个新的界面用于编辑库里函数；</p>\n<ul>\n<li>在My Blueprint/Functions栏可以申明函数</li>\n<li>在My Blueprint/Local Variables栏可以生命局部变量，在其Details中可以设置局部变量默认值；</li>\n<li>在对应函数的Details/Input和Output栏可以分别设置函数的输入输出参数</li>\n<li>在脚本编辑区可以实现函数逻辑。</li>\n</ul>\n<h2 id=\"3-使用蓝图函数库里的函数\"><a href=\"#3-使用蓝图函数库里的函数\" class=\"headerlink\" title=\"3.使用蓝图函数库里的函数\"></a>3.使用蓝图函数库里的函数</h2><p>要使用蓝图函数库里的函数，可直接在脚本编辑区右键输入函数名即可在Class栏中看到蓝图函数库里的函数了。</p>\n<h1 id=\"十一、蓝图宏库\"><a href=\"#十一、蓝图宏库\" class=\"headerlink\" title=\"十一、蓝图宏库\"></a>十一、蓝图宏库</h1><p>宏在UE4中几乎无处不在，蓝图宏库是开发者使用蓝图自定义的一系列的宏的容器，蓝图宏库和蓝图函数库一样可以定义多个宏；</p>\n<ul>\n<li>蓝图宏库与蓝图函数库不同的是，蓝图宏库中的宏是在预编译过程中完成处理的，即蓝图宏库不需要编译；</li>\n<li>自定义的宏，可以有任意数量的输入输出引脚，即一个宏可以没有输出引脚，这样的宏可以只进行数据处理，一个宏也可以有多个输入输出引脚，这样的宏可以根据不同的逻辑选择不同的执行流，而蓝图函数库中的函数必须有且只有一个输入和一个输出引脚；</li>\n<li>与函数不同，宏中不可以再定义成员变量，即宏只负责处理逻辑，不提供暂存能力。</li>\n</ul>\n<h2 id=\"1-创建蓝图宏库\"><a href=\"#1-创建蓝图宏库\" class=\"headerlink\" title=\"1.创建蓝图宏库\"></a>1.创建蓝图宏库</h2><p>宏库的创建与函数库的创建是一样的，在Content Browser中右键-&gt;Create Advanced Assect/Blueprint栏-&gt;Bluprint Macro LiberLibrary。</p>\n<h2 id=\"2-蓝图宏声明\"><a href=\"#2-蓝图宏声明\" class=\"headerlink\" title=\"2.蓝图宏声明\"></a>2.蓝图宏声明</h2><ul>\n<li>在My Blueprint/Macro中可以声明一个宏；</li>\n<li>在指定宏的Details/Inputs和Outputs中可以定义输入与输出引脚和参数。</li>\n</ul>\n<h2 id=\"3-蓝图宏的使用\"><a href=\"#3-蓝图宏的使用\" class=\"headerlink\" title=\"3.蓝图宏的使用\"></a>3.蓝图宏的使用</h2><p>和蓝图函数的使用方法一致。</p>\n<h2 id=\"4-自定义流程控制\"><a href=\"#4-自定义流程控制\" class=\"headerlink\" title=\"4.自定义流程控制\"></a>4.自定义流程控制</h2><p>除了蓝图提供给我们的条件语句和循环语句等流程控制语句外，我还可以使用宏编写自己的流程控制，因为宏可以有多个输入和输出引脚，使用方法就是使用宏的形式定义自己的流程控制逻辑，通过不同的输入给予不同输出，即可达到自定义流程控制的目的。</p>\n<h1 id=\"十二、事件\"><a href=\"#十二、事件\" class=\"headerlink\" title=\"十二、事件\"></a>十二、事件</h1><p>除了UE4蓝图中给我们提供大量的预定义事件，我也可以自定义事件。</p>\n<h2 id=\"1-事件的定义\"><a href=\"#1-事件的定义\" class=\"headerlink\" title=\"1.事件的定义\"></a>1.事件的定义</h2><p>事件的定义也很简单，在All Actions for this Buleprint中选择Add Custom Event，便可以创建一个自定义事件的入口，之后通过这个入口实现事件的内部逻辑，一个事件便定义完成。</p>\n<h2 id=\"2-事件的调用\"><a href=\"#2-事件的调用\" class=\"headerlink\" title=\"2.事件的调用\"></a>2.事件的调用</h2><p>事件调用必须通过实现这个事件的蓝图类才可以对其中的事件进行调用。如：</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-27_11-28-43.png\"></p>\n<p>Event Blueprint为实现自定义事件的蓝图类；</p>\n<p>Print Str为自定义事件。</p>\n<h2 id=\"3-事件调度器\"><a href=\"#3-事件调度器\" class=\"headerlink\" title=\"3.事件调度器\"></a>3.事件调度器</h2><p>事件调度器的创建与使用请阅读目录：十七、蓝图类的通信/3.使用事件调度器进行通信</p>\n<h1 id=\"十三、蓝图模块\"><a href=\"#十三、蓝图模块\" class=\"headerlink\" title=\"十三、蓝图模块\"></a>十三、蓝图模块</h1><p>蓝图中可以将一个复杂了逻辑处理合并成一个节点模块，从而简化整体的执行流复杂度，使蓝图的执行流变得简单明了。我们可以将需要合并的执行流多选选中然后右键，即可在Organization栏中通过Collapse Nodes选项来合并执行流。</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-27_11-31-04.png\"></p>\n<p>除了将执行流合并成节点外，蓝图还提供将多个执行流合并成一个函数或一个宏的功能。合并好的模块也可以在Organizition/Expand Node进行模块分离。</p>\n<h1 id=\"十四、角色控制\"><a href=\"#十四、角色控制\" class=\"headerlink\" title=\"十四、角色控制\"></a>十四、角色控制</h1><h2 id=\"1-为角色添加跟随相机\"><a href=\"#1-为角色添加跟随相机\" class=\"headerlink\" title=\"1.为角色添加跟随相机\"></a>1.为角色添加跟随相机</h2><p>相对U3D来说，UE4的相机跟随要简单得多，UE4中直接将相机设置成了蓝图类的组件，当蓝图类时Player时，即可实现相机对Player的跟随了。</p>\n<p>相机跟随需要通过一个物理组件<code>Spring Arm</code>来链接相机和Player，将相机附着在Spring Arm下，即可在Spring Arm的作用下实现相机跟随。</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-24_10-45-29.png\"></p>\n<h2 id=\"2-为角色添加控制器\"><a href=\"#2-为角色添加控制器\" class=\"headerlink\" title=\"2.为角色添加控制器\"></a>2.为角色添加控制器</h2><p>在UE4的游戏制作过程中，我们不难发现当我们运行游戏时，在世界大纲中多出了很多东西，如下图：</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-24_10-53-34.png\"></p>\n<p>其实，UE4为我们提供很多已经预制好的必须品，如上图的PlayerController(角色控制器)、PlayerCameraMenager(角色相机管理器)等。也就是说不可以直接使用UE4预制给我们的角色控制器来控制我们的Player，而不需要自己再去为Player蓝图配置角色控制器了，我们只需将Player的细节面板上的Auto Possess Player设置成Player0即可，Player0即表示本地角色。</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-24_10-53-06.png\"></p>\n<p>需要注意的是，对于角色控制更优的方式是使用<code>Player Start</code>组件去持有Player蓝图类，再通过Player Controller来控制Player Start达到控制角色的目的。</p>\n<h2 id=\"3-自定义游戏模式\"><a href=\"#3-自定义游戏模式\" class=\"headerlink\" title=\"3.自定义游戏模式\"></a>3.自定义游戏模式</h2><p>在我们创建一个UE4工程后，UE4会启用UE4默认的游戏模式<code>GameModeBase</code>，GameModeBase就控制着Player Controller、PlayerCameraMenager、PlayerState等运行时UE4动态生成的一些游戏物体，我们可以通过启用我们自定义的游戏模式来设置这些游戏物体按自己的定义的规则来生成运行。</p>\n<p>游戏模式也是一个蓝图类，创建游戏模式就是创建蓝图类，只是这个蓝图类需要继承自GameModeBase类，继承自GameModeBase类的蓝图就是一个游戏模式蓝图。不过在我们第一此=次打开游戏模式蓝图时，UE4会将游戏模式蓝图识别成一个普通蓝图，而进入普通蓝图的编辑模式，可能是bug吧，此时我们只需将蓝图关闭，再打开一次，UE4便可以识别出游戏模式蓝图了。</p>\n<p>游戏模式蓝图中可以定义自己的游戏模式规则，比如我们可以通过修改Spectator Class选项为自定义的游戏物体，这样在游戏运行时，UE4将不再生成DefaulPawn，而是会生成我们指定的游戏物体。</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80%5CSnipaste_2019-10-24_11-09-34.png\"></p>\n<p>配置好游戏模式后我们还需要让当前项目使用我们自定义的游戏模式，通过Seettings -&gt;Project Settings-&gt;Project/Maps&amp;Modes-&gt;Dfault GameModes，选择我们自己的配置的游戏模式即可让当前项目启用我们自己定义的游戏模式了</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-24_11-12-38.png\"></p>\n<h2 id=\"4-操控角色控制器\"><a href=\"#4-操控角色控制器\" class=\"headerlink\" title=\"4.操控角色控制器\"></a>4.操控角色控制器</h2><p>我们要操控角色控制器就需要配置键盘按键映射，配置好的键盘映射会以函数的形式加入蓝图脚本组件集中。</p>\n<p>我们在Seettings -&gt;Project Settings-&gt;Engine/Input-&gt;Bindings/Axis Mappings设置键盘映射并可以配置映射的值，</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-24_14-55-47.png\"></p>\n<p>配置好键盘映射以后便可以在蓝图脚本中使用这些函数主键来控制我们Player了，控制角色运动的方法很多，我这里以旋转力矩的方式来控制小球运动，具体的控制方法如下：</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-24_15-11-12.png\"></p>\n<p>加入两个键盘映射函数组件(InputAxis MoveF/B,InputAxis MoveL/R)、两个添加角度力矩的组件(Add Torque in Radians,Add Torque in Radians)，但是添加角度力矩组件是需要一个控制目标的，我们需要从左侧的My Blueprint面板的Components中将需要控制的物体Player拖入脚本蓝图中，分别连接到添加角度力矩组件的Target上。</p>\n<p>这里还需要注意的一点是，在我们为Player添加相机时，相机使用的是相对于Player的局部坐标，使用局部坐标的相机会跟随Player旋转，而使用世界坐标的相机将会固定某一个角度跟随Player移动。切换方法为：下拉Spring Arm的细节面板/Transform/Rotation的三角箭头选择切换。</p>\n<p>并且相机默认情况下是启用了物理碰撞的，但大多数情况下我们是不需要让相机出现物理碰撞的，所以我们也应当取消相机的物理碰撞。操作方法为：取消Spring Arm的细节面板/Camera Collision/Do Collision Test选项。</p>\n<p>当然要想比较真实的模拟出物理效果，光这样是不行的，因为默认情况下Player是没有启动物理模拟的，我们需要启用Player的细节面板/Physics/Simulate Physics选项，并且将调节Player的细节面板/Linear Damping(线性摩檫)和Player的细节面板/Angular Damping(旋转摩檫)到适当的值，应为UE4默认是没有旋转摩檫的并且，默认线性摩檫为0.01。</p>\n<h2 id=\"小知识\"><a href=\"#小知识\" class=\"headerlink\" title=\" 小知识\"></a><font color=\"Green\"> 小知识</font></h2><ul>\n<li><font color=\"green\"> 大多数时候我们都需要勾选作用力函数组件的Acel Change选项，如：上面的Add Torque in Radians，勾选了Acel Change选项作用力组件会在作用目标物体时忽略物体的质量因素，因为存在质量影响的话，我们可能需要给一个极大的力才能推动目标物体；</font></li>\n<li><font color=\"green\"> 有时可能默认大小的作用力对目标物体的移动作用达不到我们理想的效果，此时可以先将作用力加倍后在传递给作用力组件，蓝图脚本组件集中提供多种多样的乘积组件，我们上面使用的是float*float组件</font>；</li>\n</ul>\n<h1 id=\"十五、触发器\"><a href=\"#十五、触发器\" class=\"headerlink\" title=\"十五、触发器\"></a>十五、触发器</h1><p>在游戏设计中触发器的使用是非常平凡的，而在蓝图中触发器的实现也并不复杂，我们来看一下具体操作：</p>\n<h2 id=\"1-创建触发器\"><a href=\"#1-创建触发器\" class=\"headerlink\" title=\"1.创建触发器\"></a>1.创建触发器</h2><ul>\n<li>蓝图模式中游戏的一切都是蓝图，触发器也不例外，所以要做一个触发器，首先我们的创建一个蓝图的壳子，并继承自Actor类</li>\n<li>触发器还需要一个极为重要的东西就是碰撞体，当然这里的碰撞体不是具有物理碰撞的网格碰撞体，而是蓝图的物理组件集中的Box Collison，一个没有物理碰撞效果专门用于触发器的盒碰撞体，我们给蓝图类添加这个组件，一个触发器便完成了</li>\n</ul>\n<h2 id=\"2-使用触发器\"><a href=\"#2-使用触发器\" class=\"headerlink\" title=\"2.使用触发器\"></a>2.使用触发器</h2><p>当触发器放置于场景中，有物体进入触发器碰撞盒时，触发器便会出自动发触发Event ActorBeginOverlap时间组件，之后我们便可以进行一系列逻辑操作了。</p>\n<h1 id=\"十六、蓝图类的通信\"><a href=\"#十六、蓝图类的通信\" class=\"headerlink\" title=\"十六、蓝图类的通信\"></a>十六、蓝图类的通信</h1><h2 id=\"1-使用引用进行通信\"><a href=\"#1-使用引用进行通信\" class=\"headerlink\" title=\"1.使用引用进行通信\"></a>1.使用引用进行通信</h2><p>两个蓝图类要想通过引用进行通信，那么其中一个蓝图类就必须拥有另一个蓝图类的引用，如何获取一个蓝图类的引用呢？</p>\n<p>在My Blueprint/Variables栏中添加一个所需要引用的蓝图类类型的变量，勾选它的Details/Variable/Instance Editable选项，就可以在这个蓝图类的实例的Details/Default栏中看到引用变量(如果不勾选是没有default栏的)，如此便可以方便的获取另一个蓝图类的实例的引用了。</p>\n<p>通过引用两个蓝图类之间便可以进行单向的信息传递了。即拥有引用的蓝图类可以获取所引用蓝图的传递过来的信息，反向则不行。</p>\n<h2 id=\"2-使用接口进行通信\"><a href=\"#2-使用接口进行通信\" class=\"headerlink\" title=\"2.使用接口进行通信\"></a>2.使用接口进行通信</h2><p>使用接口进行通信的好处是可以很便利的通过同一事件让各种不同的蓝图做出不同的反应，如：当受到子弹攻击时，墙会反弹子弹，人会受伤，通过接口通信来实现这个效果就是，创建一个受到子弹攻击的接口OnTakeAttack，然后分别让墙和人都继承这个接口并实现不同的效果，如此当受到子弹攻击时，我们便可以通过Get All Actor with Interface来调用实现这些接口的Actor来做出各自的反应。</p>\n<p>接口的实现与使用请阅读目录：九、接口。</p>\n<h2 id=\"3-使用事件调度器通信\"><a href=\"#3-使用事件调度器通信\" class=\"headerlink\" title=\"3.使用事件调度器通信\"></a>3.使用事件调度器通信</h2><p>事件调度器的通信过程是一个调度者与一个或多个被调度者之间的通信过程，类似观察者模式的通信过程。</p>\n<h3 id=\"创建事件调度器\"><a href=\"#创建事件调度器\" class=\"headerlink\" title=\"创建事件调度器\"></a>创建事件调度器</h3><p>使用事件调度器来进行蓝图通信，首先我们需要拥有一个事件调度器；</p>\n<p>事件调度器只能被拥有者调用，所以我们需要在调度者蓝图上创建事件调度器，在My Blueprint/Event Dispatchers栏可以新建一个蓝图调度器，此时这个蓝图便拥有了一个事件调度器，我们可以通过拖拽事件调度器到脚本编辑视图或直接在All Actions for this Blueprint中搜索，可以对事件调度器进行事件绑定(Bind)、事件解绑(Unbind)、解绑全部事件(Unbind all)，直接为事件调度器绑定新事件(Assign)和调用事件调度器(Call)。当一个事件调度器被调用后，与这个事件调度器绑定的事件都会被调用，一次来达到信息传递的目的。</p>\n<h3 id=\"绑定事件\"><a href=\"#绑定事件\" class=\"headerlink\" title=\"绑定事件\"></a>绑定事件</h3><p>调度者要事件调度器调用被调度者的事件，那么被调度者就需要向调度者的事件调度器上绑定事件，通过Bind Event to [事件调度器名]组件来绑定事件到事件调度器上。</p>\n<p><img src=\"/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-28_15-51-30.png\"></p>\n<p>Target：输入事件调度器的拥有者对象</p>\n<p>Event：需要绑定的事件</p>\n<p>如此一个基于事件调度器的通信机制便完成了。</p>\n"},{"title":"【C++】C++高级","date":"2019-09-14T01:01:06.000Z","_content":"\n\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 一、类\n\n## 1.浅拷贝与深拷贝\n\n### 浅拷贝\n\n<font color=red> C++在进行浅拷贝时，只拷贝栈区的内存空间，不拷贝堆区的内存空间，即浅拷贝只拷贝非指针的成员变量和指针本身，而不拷贝指针所指向的堆区的内容。</font>\n\n我们代码1.1为例\n\n```c++\n//代码1.1\nclass Obj\n{\npublic:\n\tObj(char *tp)\n\t{\n\t\tlen = strlen(tp);\n\t\tp = (char*)malloc(len + 1);\n\t\tstrcpy_s(p, len+1, tp);\n\t}\n\t~Obj()\n\t{\n\t\tif (p != NULL)\n\t\t{\n\t\t\tfree(p);\n\t\t\tp = NULL;\n\t\t\tlen = 0;\n\t\t}\n\t}\n\tvoid Show()\n\t{\n\t\tcout << *p << *(p + 1) << *(p + 2) << endl;\n\t}\nprivate:\n\tchar *p;\n\tint len;\n};\n\nvoid text(Obj &obj)\n{\n\tObj obj2 = obj;\n}\n\nint main()\n{\n\tObj obj1(\"asd\");\n\ttext(obj1);\n\tobj1.Show();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n我们作一个图示：\n\n![](B:\\Git\\Blog\\source\\_posts\\【C++】C++高级\\Snipaste_2019-10-01_16-21-15.png)\n\n​\t我们没有自定义Obj类的拷贝构造函数，所以当代码执行到`Obj obj2 = obj1;`时，编译器将调用默认的拷贝构造函数，然而，<font color=red> 编译器默认的拷贝构造函数是一个浅拷贝</font>，所以新创建的对象obj2没有自己的堆区空间，obj2.p指向的是obj1.p所指向的内存地址。\n\n​\t上面的代码编译是通不过的，<font color=red> 原因在于，对象析构时，同一个内存地址`0x0001`被对象obj1和obj2一起析构了两次</font>。当代码执行完`test(obj1)`时，对象obj2被析构，指针obj2.p所指向的内存地址`0x0001`被释放，所以当代码执行到`obj1.Show()`时，使用了已经被释放掉的内存`0x0001`地址，从而导致运行错误。\n\n​\t<font color=green> **这里我有一个疑问，既然浅拷贝在拷贝有指针的对象时，会出现两次析构而出错，所以浅拷贝只能拷贝没有指针成员的对象，那么浅拷贝和深拷贝似乎没有什么区别了，那么浅拷贝存在的意义是什么呢？**</font>\n\n### 深拷贝\n\nC++没有提供给开发者预定义的深拷贝方法，所以要想使用深拷贝，我们需要字写一个拷贝构造函数。\n\n深拷贝可以解决上面遇到的浅拷贝的问题，因为，<font color=red> 深拷贝会申请一新的内存空间用于存放拷贝过来的内容，即深拷贝拷贝对象的所有成员，包括指针所指向的内存空间也会一起被拷贝，被拷贝过来的指针会指向一个新的内存地址</font>。\n\n![](【C++】C++高级/Snipaste_2019-10-01_16-52-53.png)\n\n### 定义深拷贝构造函数\n\n```c++\n//代码1.2\nclass Obj\n{\npublic:\n\tObj(char *tp)\n\t{\n\t\tlen = strlen(tp);\n\t\tp = (char*)malloc(len + 1);\n\t\tstrcpy_s(p, len+1, tp);\n\t}\n    //------------------------------\n    //拷贝构造函数--深拷贝\n\tObj(const Obj &obj)\n\t{\n\t\tlen = obj.len;\n\t\tp = (char*)malloc(len + 1);\n\t\tstrcpy_s(p, len + 1, obj.p);\n\t}\n    //------------------------------\n\t~Obj()\n\t{\n\t\tif (p != NULL)\n\t\t{\n\t\t\tfree(p);\n\t\t\tp = NULL;\n\t\t\tlen = 0;\n\t\t}\n\t}\n\tvoid Show()\n\t{\n\t\tcout << *p << *(p + 1) << *(p + 2) << endl;\n\t}\nprivate:\n\tchar *p;\n\tint len;\n};\n```\n\n当一个类中定义了拷贝构造函数，则在对象拷贝时，编译器就不会在调用默认的拷贝构造函数转而调用自定义的拷贝构造函数，当我们把代码1.1中类的定义改为代码1.2中类的定义后，程序就可以正常执行了。\n\n<font color=red>使用深拷贝时，我们还需要注意下面的情况：</font>\n\n```c++\nObj obj1(\"asd\");\nObj obj3(\"fgh\");\nobj3 = obj1;\n```\n\n此时，在`obj3=obj1;`处依旧调用默认的拷贝构造函数，这里我们要弄清楚`obj3=obj1`和`Obj obj3 = obj1`之间的区别，`obj3=obj1`是将<font color=red>obj1赋值给obj3</font>，`=`赋值与拷贝构造函数没有什么关联，`=`在赋值时是C++编译器自己调用默认的拷贝构造函数---浅拷贝，和类中有无定义深拷贝无关；而`Obj obj3=obj1`则是<font color=red>使用obj1来构造obj3</font>，此时如果类中定义了深拷贝构造函数，就会使用深拷贝。要解决这个问题，就需要显示重载`=`运算符了。\n\n### <font color=blue>**小知识**</font>\n\n- <font color=blue>在定义拷贝构造函数时，必须使用引用传递，否则会出现无限拷贝的情况，因为，如果我们使用传值传递的话，在传递对象到拷贝构造函数时，又会调用拷贝构造函数将实参拷贝给形参，而这个过程又会将对象传递给拷贝构造函数，从而在此调用拷贝构造函数将实参拷贝给形参，如此无限循环</font>\n- <font color=blue>拷贝构造函数只能有一个参数，且必须是自身类的引用，否则编译器将识别被普通构造函数</font>\n\n## 2.初始化参数列表\n\n### 作用\n\n我们以下面的代码1.3来说明初始化参数列表\n\n```C++\nclass A\n{\npublic:\n\tA(int a)\n\t{\n\t\tthis->a = a;\n\t}\nprivate:\n\tint a;\n};\nclass B\n{\npublic :\n\tB(int i)\n\t{\n\t\tthis->i = i;\n\t}\n\tint i;\n\tA a;\n\n};\nint main()\n{\n\tB b(1);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**运行结果：**\n\n```\n错误\tC2512\t“A”: 没有合适的默认构造函数可用\n```\n\n​\t这个问题就在于，在类B中组合了一个A类的成员，编译器在构造B类对象时，同时会构造一个A类对象作为B类的成员，然而，因为A类自定义了一个有参的构造函数，所以在构造A类时，编译器不会使用默认构造函数，而是使用自定义的有参构造函数，问题就出在这里，编译器在构造A类时，没有参数传递到A类的有参构造函数中。初始化参数列表就是用于解决这种问题的。\n\n​\t需要说明的是，如果A类中没有自定义有参的构造函数，则在B类构造对象时编译器自动调用A类的默认构造函数构造A类对象成员，就不会报错。\n\n​\t初始化参数列表可以让我们在构造B类对象时，根据参数列表来构造不同的A类成员。\n\n### 使用\n\n初始化参数列表的使用如下面的`B(int i):a1(1),a2(2,\"asd\")`：\n\n```c++\nclass A\n{\npublic:\n\tA(int a)\n\t{\n\t\tthis->a = a;\n\t\tcout << \"构造小A\" << endl;\n\t}\n\tA(int a, string str)\n\t{\n\t\tthis->a = a;\n\t\tthis->str = str;\n\t\tcout << \"构造大A\" << endl;\n\t}\n\t~A()\n\t{\n\t\tcout << \"析构A\" << endl;\n\t}\n\tint a;\n\tstring str;\n};\nclass B\n{\npublic :\n\tB(int i):a1(1),a2(2,\"asd\")\n\t{\n\t\tthis->i = i;\n\t\tcout << \"构造B\" << endl;\n\t}\n\t~B()\n\t{\n\t\tcout << \"析构B\" << endl;\n\t}\n\n\tint i;\n\tA a1;\n\tA a2;\n};\nvoid test()\n{\n\tB b(1);\n\tcout << b.a1.str << endl;\n\tcout << b.a2.str << endl;\n}\nint main()\n{\n\ttest();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**输出结果：**\n\n```\n构造小A\n构造大A\n构造B\n\nasd\n析构B\n析构A\n析构A\n```\n\n​\t值得注意的是<font color=red> A类对象的构造顺序不是由初始化参数列表的顺序决定的，而是由对象的申明的前后顺序决定的</font>，如：`B(int i):a1(1),a2(2,\"asd\")`和`B(int i):a2(2,\"asd\"),a1(1)`的构造顺序是一样的，但是当我们将类B中组合的A类对象的申明顺序改为如下\n\n```c++\nclass B\n{\npublic :\n\tB(int i):a1(1),a2(2,\"asd\")\n\t{\n\t\tthis->i = i;\n\t\tcout << \"构造B\" << endl;\n\t}\n\t~B()\n\t{\n\t\tcout << \"析构B\" << endl;\n\t}\n\n\tint i;\n\tA a2;\n\tA a1;\n};\n```\n\n则构造顺序就变为“先构造a2再构造a1”了。\n\n<font color=red> 析构的顺序和构造的顺序相反。</font>\n\n### <font color=blue> 小知识</font>\n\n- <font color=blue> 当一个类中组合了其他的类对象作为成员时，拷贝构造函数也必须使用初始化参数列表，来构造对象成员然后拷贝</font>\n\n## 3.匿名对象的生命周期\n\n### 什么是匿名对象\n\n```C++\ncalss A\n{\npublic:\n\tint a;\n\tA(int a)\n\t{\n\t\tthis->a = a;\n\t}\n}\nvoid main()\n{\n    A(1);\n}\n```\n\n上面的语句`A(1)`创建的就是一个匿名临时的对象，<font color=red> 需要注意，如果一个类只有无参的构造函数，那么这个类将无法构建匿名对象</font>，匿名对象的生命周期就只在创建匿名对象的这条语句内，如果我们不使用一个对象来接收这个匿名对象，那么匿名对象会在语句结束时被销毁，当我们使用`A a = A(1);`不会出现匿名对象拷贝到类B对象b的情况，这种语句已经被C++优化成了类B的构造语句。说这么多其实匿名对象没什么卵用。\n\n## 4.new和delete\n\n1.new和delete的用法\n\n`new`可以为**基础类型**、**数组**、**类**分配内存空间，`new`分配的内存空间都分配在**堆**上。随意`new`出来的内存空间必须使用一个指针来指向，不能使用同类型的变量来接收，也禁止不接受。\n\n**new 基础类型**\n\n```c++\nint *p = new int;\ndelete p;\n```\n\n**new 数组**\n\n```c++\nint *p = new int[10];\ndelete[] p;\n```\n\n**new 类**\n\n```c++\n//C++\nA *p = new A();\ndelete p;\n//C\nA *pc = (A*)malloc(A);\nfree(pc);\n```\n\n### `new delete`和`malloc free`的区别\n\n- 在基础类型和基础类型数组方面`new delete`和`malloc free`几乎没有什么区别\n\n- `new`不仅会分配内存还会调用构造函数，而`malloc`只会分配内存\n\n- `delete`会调用析构函数来销毁对象，而`free`只是单纯的释放内存\n\n### <font color=blue> **小知识**</font>\n\n<font color=blue> `new delete`和`malloc free`是可以穿插使用的，即`new`可以和`free`搭配使用，`malloc`可以和`delete`搭配使用。</font>\n\n# 二、继承\n\n继承这边主要分析一下`虚继承`\n\n## 1.虚继承\n\n虚继承的出现主要是为解决如下的继承关系中的二义性问题\n\n![图1](【C++】C++高级/Snipaste_2019-10-02_15-50-39.png)\n\n当我们的类的继承过程中出现这种继承关系时，我们需要使类B和类C分别虚继承类A来解决二义性，具体操作如下：\n\n```c++\nclass A\n{\n   public:\n    \tint a;\n};\nclass B : virtual public A\n{\n\tpublic:\n\t\tint b;\n};\nclass C : virtual public A\n{\n\tpublic:\n\t\tint c;\n};\nclass D : public B,C\n{\n\tpublic:\n\t\tint d;\n};\nvoid main()\n{\n    D d;\n    d.a = 1;\n}\n```\n\n这里有一点要注意，虚继承的应用场景有限，虚继承只能解决这种情况：\n\n![](【C++】C++高级/Snipaste_2019-10-02_15-50-39.png)\n\n而不能解决这种情况：\n\n![](【C++】C++高级/Snipaste_2019-10-02_16-10-55.png)\n\n## 2.继承中的static关键字\n\n<font color=red> 类中的静态成员变量被类的所有对象共享，同时也被类的派生类的所有对象共享。</font>\n\n# 三、多态\n\n​\t在C++的几个特性中，封装、继承和抽象都相对好理解，而多态则不太好理解，这里就说说C++的多态。\n\n## 1.多态分两种：\n\n​\t静态多态：静态多态指的就是函数重载和运算符重载。\n\n```c++\nclass Animal\n{\npublic:\n\tstring name = \"动物\";\n\tvirtual void speak()\n\t{\n\t\tcout << name << \"在叫\" << endl;\n\t}\n};\n\nclass Dog : public Animal\n{\npublic:\n\tstring name = \"狗\";\n\tvoid speak()\n\t{\n\t\tcout << name << \"在叫\" <<endl;\n\t}\n};\n\nstring operator+(Animal animal,Dog dog)\n{\n\treturn animal.name + \"是\" + dog.name + \"的父类\";\n}\n\nvoid Run(Animal animal)\n{\n\tcout << animal.name <<\"在跑\" << endl;\n}\n\nvoid Run(Dog dog)\n{\n\tcout << dog.name << \"在跑\" << endl;\n}\n\nint main()\n{\n\tAnimal animal;\n\tDog dog;\n\tRun(animal);\n\tRun(dog);\n\tcout<<animal+dog<<endl;\n\tsystem(\"pause\");\n}\n```\n\n​\t动态多态：动态多态则是通过继承和虚函数实现标签相同的函数因为传入不同的对象来实现不同的功能。\n\n```c++\nclass Animal\n{\npublic:\n\tstring name = \"动物\";\n\tvirtual void speak()\n\t{\n\t\tcout << name << \"在叫\" << endl;\n\t}\n};\n\nclass Dog : public Animal\n{\npublic:\n\tstring name = \"狗\";\n\tvoid speak()\n\t{\n\t\tcout << name << \"在叫\" <<endl;\n\t}\n};\n\nvoid Speak(Animal *animal)\n{\n\tanimal->speak();\n}\n\nint main()\n{\n\tAnimal animal;\n\tDog dog;\n\tSpeak(&animal);\n\tSpeak(&dog);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n​\t动态多态中只能用父类对象的指针或引用来指向子类或自身对象。\n\n## 2.多态的实现原理\n\n​\tC++多态的实现依赖于类的虚函数表，当一个类中定义了虚函数，那么这个类就拥有的了一个记录这个虚函数入口地址的虚函数表，子类继承父类时也会继承父类的虚函数表，当子类重写父类的虚函数时，则子类的虚函数入口地址将覆盖父类的地址，如此当子类对象调用此函数时则从子类的虚函数表中寻找入口地址，当父类的对象调用此函数时则从父类的虚函数表中寻找入口地址。\n\n```\n当类创建虚函数时，编译器会在类中生成一个虚函数表\n虚函数表是一个存储类成员函数指针的数据结构\n虚函数表有编译器自动生成和维护\n虚成员函数会被编译器放入虚函数表中\n存在虚函数时，每一个对象中都会拥有一个指向虚函数表的虚函数表指针(vptr)\n```\n\n简单来说，多态实现的条件有三：\n\n- 要有继承\n\n- 要有虚函数重写\n\n- 要有父类指针(或引用)指向子类对象\n\n## 3.纯虚函数和抽象类\n\n​\t纯虚函数的定义：\n\n```c++\nvirtual void speak() = 0\n```\n\n​\t定义了纯虚函数的类就被成为抽象类，C++引入纯虚函数和抽象类的概念就是为了更好的使用多态，抽象类不能实例化对象，这个特性就规范了继承这个抽象类的子类必须重写父类的虚函数，因为如果继承了抽象类的子类不重写父类的虚函数，那么子类也是一个抽象类，子类便也不能实例化对象，如此便规范了多态实现，防止当子类很多时，出现某个子类在编写时忘记重写父类的虚函数，而导致这个子类没有实现多态。\n\n## 4.虚析构函数和纯虚析构函数\n\n- 虚析构函数的定义：\n\n```c++\nvirtual ~Animal();\n```\n\n- 纯虚析构函数的定义：\n\n```c++\nvirtual ~Animal() = 0;\n//纯虚析构函数必须要有申明也要有实现\nAnimal：：~Animal()\n{\n    //代码实现\n}\n```\n\n如果子类在堆区中定义了数据，那么我们使用父类指针或引用来使用多态时，父类指针或引用是无法寻找到子类在堆区中的数据并释放的。C++引入虚析构函数和纯虚析构函数就是为了解决此类问题。\n\n​\t我们来看一个例子：\n\n```c++\nclass Animal\n{\npublic:\n\tAnimal()\n\t{\n\t\tcout << \"这是Animal的构造函数\" << endl;\n\t}\n\t~Animal()\n\t{\n\t\tcout << \"这是Animal的析构函数\" << endl;\n\t}\n};\n\nclass Dog : public Animal\n{\npublic:\n\tint *p;\n\tDog()\n\t{\n\t\tp = new int;\n\t\tcout << \"这是Dog的构造函数\" << endl;\n\t}\n\t~Dog()\n\t{\n\t\tcout << \"这是Dog的析构函数\" << endl;\n\t\tif (p != NULL)\n\t\t{\t\t\n\t\t\tcout << \"释放堆区的p\" << endl;\n\t\t\tdelete p;\n\t\t\tp = NULL;\n\t\t}\n\t}\n};\n\nint main()\n{\n\tAnimal *animal = new Dog();\n\tdelete animal;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n输出结果：\n\n```\n这是Animal的构造函数\n这是Dog的构造函数\n这是Animal的析构函数\n```\n\n可以看到，delete animal后并没有调用Dog的析构函数，释放子类Dog在堆区申请的空间。这样便出现了内存泄漏。\n\n此时虚析构函数和纯虚析构函数便可以起作用了，我们再看一个例子：\n\n```c++\nclass Animal\n{\npublic:\n\tAnimal()\n\t{\n\t\tcout << \"这是Animal的构造函数\" << endl;\n\t}\n\tvirtual ~Animal()//把父类的析构函数改为虚析构函数\n\t{\n\t\tcout << \"这是Animal的析构函数\" << endl;\n\t}\n};\n\nclass Dog : public Animal\n{\npublic:\n\tint *p;\n\tDog()\n\t{\n\t\tp = new int;\n\t\tcout << \"这是Dog的构造函数\" << endl;\n\t}\n\t~Dog()\n\t{\n\t\tcout << \"这是Dog的析构函数\" << endl;\n\t\tif (p != NULL)\n\t\t{\t\t\n\t\t\tcout << \"释放堆区的p\" << endl;\n\t\t\tdelete p;\n\t\t\tp = NULL;\n\t\t}\n\t}\n};\n\nint main()\n{\n\tAnimal *animal = new Dog();\n\tdelete animal;\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n​\t输出结果：\n\n```\n这是Animal的构造函数\n这是Dog的构造函数\n这是Dog的析构函数\n释放堆区的p\n这是Animal的析构函数\n```\n\n​\t如此便可以释放子类Dog在堆区申请的空间了，纯虚析构函数和虚析构函数的作用是一样，只是纯虚析构函数有一个和纯虚函数一样的特性，即定义了纯虚析构函数的类也属于抽象类，纯虚析构函数必须实现，如果不实现所有继承了拥有纯虚析构函数的抽象类的派生类都属于抽象类。需要注意的是，因为纯虚析构函数的特性，纯虚析构函数的实现就必须在类外实现了。\n\n## 5.重载、重写、重定义\n\n**重载**\n\n重载发生在一个类的内部，拥有相同函数名，相同返回值而参数列表不同的函数之间互为重载关系。如：\n\n```c++\nclass A\n{\n\tpublic:\n\t\tvoid fun(){}\n\t\tvoid fun(int a){}\n};\n```\n\n<font color=red> 只有相同函数名而参数列表不同的函数才是重载，函数名相同参数列表也相同而返回值不同的函数在C++中是不允许的。</font>\n\n**重写**\n\n重写发生在基类和派生类之间，基类中定义虚函数(纯虚函数)，派生类中定义和虚函数拥有**相同函数名，相同参数列表和相同返回值**的函数，这种情况下发生函数重写。如：\n\n```c++\nclass A\n{\n    public:\n    \tvirtual void fun(){}\n};\nclass B : public A\n{\n\tpublic:\n\t\tvoid fun(){}//重写A类的fun函数\n\t\tvoid fun(int a){}//重定义一个新函数\n\t\tint fun(){return 0;}//这种情况C++不允许\n};\n```\n\n**重定义**\n\n重定义也是发生在基类和派生类之间，派生类拥有与基类函数名相同，返回值相同，而参数列表不同的函数，此时发生重定义。如：\n\n```c++\nclass A\n{\n  public:\n    void fun(){}\n};\nclass B : public A\n{\n\tpublic:\n\t\tvoid fun(int a){}//发生重定义\n};\n```\n\n<font color = red> 派生类中可以重定义基类的任何函数，包括虚函数和纯虚函数。</font>\n\n## 6.父类指针和子类指针步长不一致问题\n\n问题出现的场景是这样的：\n\n```c++\nclass A\n{\npublic:\n\tint a;\n\tvirtual void print() {}\n};\nclass B : virtual public A\n{\npublic:\n\tint b;\n\tB(int b)\n\t{\n\t\tthis->b = b;\n\t}\n\tvoid print()\n\t{\n\t\tcout << b << endl;\n\t}\n};\nint main()\n{\n\tA *a = NULL;\n\tB *b = NULL;\n\tB array[2]{ B(1),B(2) };\n\ta = array;\n\tb = array;\n\ta->print();\n\tb->print();\n\ta++; b++;\n\ta->print();//这一步会出现异常\n\tb->print();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n即父类指针a和子类指针b都指向一个子类对象数组，于是我们可以通过指针++的自增运算来逐步访问数组元素，问题就出在这，使用`sizeof()`计算两个类的大小分别得出，sizeof(A)=8;sizeof(B)=20;这就导致A类指针a每一次移步时只移动了8个字节，这个距离还远远没有达到下一个元素的首地址，所以访问会出错，这是因为指针每次移步移动的距离是指针类型的空间大小，如：A类大小为8，所以A类指针每移步一次走8个字节。\n\n可能会有疑问，为什么类B的大小是20？\n\n我们可以算一算，类B继承至类A所以类A中拥有的成员变量，类B也拥有，占8字节，这8字节分别是int变量4字节和虚函数表指针4字节；类B自身定义了一个int变量占4字节，由于类B重写了类A的虚函数，所以类B也拥有一个自己的虚函数表指针，占4字节；类B虚继承了类A，在这个过程中，C++编译器会给类B增加一个属性，占4字节，于是，**8+4+4+4+4=20**。\n\n------\n\n# 四、泛型编程\n\n## 1.函数模板\n\n### 函数模板的基本语法\n\n```c++\n//---------------函数模板\ntemplate <typename T>//告诉编译器我要开始泛型编程了，遇到T不要报错\nvoid Fun(T &a,T &b)\n{\n\tT t = a;\n\ta = b;\n\tb = t;\n}\n//----------------\nint main()\n{\n\tchar a = 97,b = 102;\n\tFun(a, b);//自动推导类型调用\n\tcout << a << \",\" << b << endl;\n\tstring x = \"xxx\", y = \"yyy\";\n\tFun<string>(x, y);//显示类型调用\n\tcout << x << \",\" << y << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n### 当函数模板遇到函数重载\n\n当函数模板遇到函数重载准许下面4条原则\n\n- 函数模板可以像普通函数一样被重载\n- C++编译器优先考虑普通函数\n- 如果函数模板可以产生一个更好的匹配，那么选择函数模板\n- 可以通过模板的空实参列表的语法限定编译器只通过函数模板匹配\n\n我们来看一个例子，逐一分析\n\n```c++\ntemplate <typename T>\nvoid Fun(T a,T b)\n{\n\ta = a + b;\n\tcout << \"我是函数模板\" << endl;\n}\ntemplate <typename T1,typename T2>\nvoid Fun(T1 a,T2 b)\n{\n\tT1 x = a;\n\tT2 y = b;\n\tcout << \"我是函数模板重载\" << endl;\n}\nvoid Fun(int a, int b)\n{\n\tcout << \"我是普通函数\" << endl;\n}\nvoid Fun2(int a, int b)\n{\n\tcout << a << \",\" << b << endl;\n}\nint main()\n{\n\tFun(1, 2);\n\tFun(0.1, 0.2);\n\tFun('c', 1);\n\tFun<>(1, 2);\n\tFun2(0.1, 0.2);\n\tFun2('a', 3);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**输出结果：**\n\n```\n我是普通函数\n我是函数模板\n我是函数模板重载\n我是函数模板\n0,0\n97,3\n```\n\n**分析：**\n\n- `Fun(1,2)`:有完全匹配的普通函数，所以调用`void Fun(int a, int b)`\n- `Fun(0.1,0.2)`:虽然普通函数`void Fun(int a, int b)`可以像`void Fun2(int a, int b)`一样进行隐式类型转换调用，倒是`Fun()`函数有更好的重载函数`void Fun(T1 a,T2 b)`模板匹配所以编译器优先调用`void Fun(T1 a,T2 b)`\n- `Fun('c',1)`:编译器能找到匹配的函数模板重载`void Fun(T1 a,T2 b)`所以优先调用函数模板\n- `Fun<>(1,2)`:使用了空参数列表，告诉编译器只匹配函数模板，即使代码段中有能完美匹配的普通函数，也只调用函数模板\n\n## 2.类模板\n\n### 定义\n\n```c++\ntemplate <typename T>//定义\nclass TemplateA\n{\npublic:\n\tTemplateA(T a)\n\t{\n\t\tthis->a = a;\n\t}\n\tvoid PrintA()\n\t{\n\t\tcout << \"a:\" << a << endl;\n\t}\nprivate:\n\tT a;\n};\n\nvoid Test(TemplateA<int> &a)//类模板作形参\n{\n\ta.PrintA();\n}\n\nint main()\n{\n\tTemplateA<int> a(1);//使用\n\tTemplateA<string> b(\"str\");\n\tTemplateA<bool> c(true);\n\tTest(a);\n\tb.PrintA();\n\tc.PrintA();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**输出结果：**\n\n```\na:1\na:str\na:1\n```\n\n类模板的定义和函数模板的定义类似\n\n### 使用\n\n类模板的使用必须显示的确定模板的类型参数，如：`TemplateA<string> b(\"str\")`\n\n### 类模板作参数\n\n类模板作参数也必须显示的确定模板那的类型参数，如：\n\n`void Test(TemplateA<int> &a)`以便编译器为形参确定内存空间。\n\n### 类模板派生普通类\n\n类模板也可以被继承，但是在继承时需要显示确定模板的类型参数\n\n```c++\ntemplate <typename T>\nclass TemplateA\n{\npublic:\n\tTemplateA(T a)\n\t{\n\t\tthis->a = a;\n\t}\n\tvoid PrintA()\n\t{\n\t\tcout << \"a:\" << a << endl;\n\t}\nprivate:\n\tT a;\n};\nclass B : public TemplateA<int>//类模板派生普通类\n{\npublic:\n\tB(int a, int b) :TemplateA(a)\n\t{\n\t\tthis->b = b;\n\t}\n\tvoid PrintB()\n\t{\n\t\tcout << \"b:\" << b << endl;\n\t}\nprivate:\n\tint b;\n};\n\nint main()\n{\n\tB b(1, 2);\n\tb.PrintA();\n\tb.PrintB();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n### 模板类派生模板类\n\n模板类不仅可以派生普通类，还可以派生模板类\n\n```c++\ntemplate <typename T>\nclass TemplateA\n{\npublic:\n\tTemplateA(T a)\n\t{\n\t\tthis->a = a;\n\t}\n\tvoid PrintA()\n\t{\n\t\tcout << \"a:\" << a << endl;\n\t}\nprivate:\n\tT a;\n};\ntemplate <typename T1,typename T2>\nclass TemplateB : public TemplateA<T2>//类模板派生类模板\n{\npublic:\n\tTemplateB(T2 a, T1 b) :TemplateA(a)\n\t{\n\t\tthis->b = b;\n\t}\n\tvoid PrintB()\n\t{\n\t\tcout << \"b:\" << b << endl;\n\t}\nprivate:\n\tT1 b;\n};\n\nint main()\n{\n\tTemplateB<string,char> b('A', \"TemplateB\");\n\tb.PrintA();\n\tb.PrintB();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**输出结果：**\n\n```\na:A\nb:TemplateB\n```\n\n### 类模板的主要作用\n\n类模板的主要作用就是将数据结构的表示和算法不受包含的元素类型的影响，即类模板将元素类型和数据结构算法分离开来了，使数据结构和算法成为真正意义上的数据结构和算法，如：链表不再因为`int`类型而定义一个`int`类型的链表，因`string`类型而定义一个`string`类型的链表，而是定义一个链表可以通用于所有类型。\n\n# 五、异常处理\n\n## 1.异常的基本语法\n\n```C++\nvoid Try(int x, int y)\n{\n\tif (y == 0)\n\t{\n\t\tcout << \"除数不能等于0，抛出异常\"<<endl;\n\t\tthrow y;//这里必须指明抛出异常的数据类型，否则程序无法处理异常，只能使用这个类型的变量，x和y的效果是一样的，不能直接抛出int，即这样是不行的throw int\n\t}\n\tcout << \"x/y=\" << x / y << endl;\n}\n\nvoid Test1()\n{\n\tTry(1, 2);\n\tTry(3, 0);\n}\n\nvoid Test2()\n{\n\ttry\n\t{\n\t\tTest1();\n\t}\n\tcatch (char e)\n\t{\n\t\tcout << \"处理char异常\" << endl;\n\t}\n\tcatch(...)\n\t{\n\t\tcout << \"无法处理的异常继续往上抛\" << endl;\n\t\tthrow;\n\t}\n}\n\nint main()\n{\n\ttry\n\t{\n\t\tTest2();\n\t}\n\tcatch(int e)\n\t{\n\t\tcout << \"处理int异常\" << endl;\n\t}\n\tcatch (...)\n\t{\n\t\tcout << \"处理其他异常\" << endl;\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**输出结果：**\n\n```\nx/y=0\n除数不能等于0，抛出异常\n无法处理的异常继续往上抛\n处理int异常\n```\n\n- 异常的抛出是可以跨函数的，如上面的代码，在`Try`函数里抛出的异常可以在`mian`函数中处理，中间跨过了`Test1`，`Test2`两个函数\n- 如果在一个函数内捕捉到异常但是却无法处理可以通过`throw`继续向上抛，直至main函数，如上面代码，`Test2`捕捉到异常但是没有处理继续向上抛给了main函数，如果main函数还是没有处理，则会直接中断程序\n- C++使用`cacth(...)`来捕捉其他没有捕捉到的异常，如上面代码，main函数中只捕捉了int类型的异常，如果出现其他类型的异常则有`cacth(...)`来捕捉\n- 异常处理是按照类型匹配来处理的，即`throw`的int类型的异常只有`cacth(int e)`能够接收得到，否则就只能使用`cacth(...)`来接收未知异常\n\n## 2.C++异常处理的特性\n\n​\tC++的异常处理具有跨函数性，这使得<font color=red> 异常引发</font>和<font color=red> 异常处理</font>分离开来，这样下层函数可以不用过多的在一异常处理，而把重点放在问题的逻辑处理上，异常处理可以由上层调用者专门来处理。\n\n## 3.异常接口申明\n\n**不抛出任何异常：**\n\n```C++\nvoid Try(int x, int y) throw()//异常接口申明\n{\n\tif (y == 0)\n\t{\n\t\tcout << \"除数不能等于0，抛出异常\"<<endl;\n\t\tthrow x;\n\t}\n\tcout << \"x/y=\" << x / y << endl;\n}\n```\n\n**只能抛出列表中类型的异常：**\n\n```C++\nvoid Try(int x, int y) throw(char,int*)\n{\n\tif (y == 0)\n\t{\n\t\tcout << \"除数不能等于0，抛出异常\"<<endl;\n\t\tthrow x;\n\t}\n\tcout << \"x/y=\" << x / y << endl;\n}\n```\n\n**可以抛出任何异常：**\n\n```C++\nvoid Try(int x, int y)\n{\n\tif (y == 0)\n\t{\n\t\tcout << \"除数不能等于0，抛出异常\"<<endl;\n\t\tthrow x;\n\t}\n\tcout << \"x/y=\" << x / y << endl;\n}\n```\n\n不过经过测试，三份代码无论是否写throw都是可以抛出并处理异常的，似乎这个语法没什么卵用，可能C++11摒弃了这种用法，但是考虑到兼容保留这个语法。\n\n## 4.异常接收的3种方式\n\n### 普通形参\n\n```c++\nclass A\n{\npublic:\n\tA() { cout << \"构造A\" << endl; }\n\tA(const A &a) { cout << \"拷贝A\" << endl; }\n\t~A() { cout << \"析构A\" << endl; }\n};\n\nvoid Try()\n{\n\tA a;\n\tthrow a;\n}\n\nint main()\n{\n\ttry\n\t{\n\t\tTry();\n\t}\n\tcatch(A e)//使用普通形参\n\t{\n\t\tcout << \"处理int异常\" << endl;\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**输出结果：**\n\n```\n构造A\n拷贝A\n拷贝A\n析构A\n处理int异常\n析构A\n析构A\n```\n\n可以看到a被拷贝两次，第一次从`A a`拷贝到`throw a`，第二次从`throw a`拷贝到`catch(A e)`，可以看出如果使用普通形参来接收异常，异常变量会由异常抛出处拷贝到异常接收处。\n\n### 引用\n\n将上面代码的`catch(A e)`改为`catch(A &e)`\n\n**输出结果：**\n\n```\n构造A\n拷贝A\n析构A\n处理int异常\n析构A\n```\n\n可以看到只拷贝了一次，即从`A a`拷贝到`throw a`。\n\n### 指针\n\n上面代码应该修改为如下\n\n```C++\nclass A\n{\npublic:\n\tA() { cout << \"构造A\" << endl; }\n\tA(const A &a) { cout << \"拷贝A\" << endl; }\n\t~A() { cout << \"析构A\" << endl; }\n};\n\nvoid Try()\n{\n\tA *a = new A();//对象必须创建在堆区，函数结束对象就会被销毁，而无法通过指针传递到catch中\n\tthrow a;\n}\n\nint main()\n{\n\ttry\n\t{\n\t\tTry();\n\t}\n\tcatch(A *e)\n\t{\n\t\tcout << \"处理int异常\" << endl;\n\t\tdelete e;//需要手动释放堆区的内存\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**输出结果：**\n\n```\n构造A\n处理int异常\n析构A\n```\n\n可以看到使用指针完全不需要拷贝，但是却需要消耗堆区的内存且容易造成内存泄露。\n\n### 总结\n\n总的来说，最优的方式还是使用引用。\n\n## 5.继承在异常处理中的应用\n\n在实际的项目中我们处理的异常并不是一些基础的数据类型，大多都是开发者的自定义类，这种情况在捕捉异常的时候就相当麻烦，尽管有些异常处理起来程序基本一致，但是却要将每一种异常一一捕捉并一一处理，下面的代码我们来模拟一下这种情况。\n\n```C++\nclass A//A类实现输入一个范围在0-10的奇数\n{\npublic:\n\tA(int a) \n\t{\n\t\tif (a % 2 != 0) {\n\t\t\tif (a < 0)throw LtZero();\n\t\t\tif (a > 10)throw GtTen();\n\t\t\telse num = a;\n\t\t}\n\t\telse throw Even();\n\t}\nprivate:\n\tint num;\n};\nclass LtZero//专门处理异常的异常类\n{};\nclass GtTen\n{};\nclass Even\n{};\n\nint main()\n{\n\ttry { A a(4); }\n\tcatch (LtZero &lz) { cout << \"输入的数小于0\" << endl; }\n\tcatch (GtTen &gt) { cout << \"输入的数大于10\" << endl; }\n\tcatch (Even &ev) { cout << \"输入的数是偶数\" << endl; }\n\tcatch (...) { cout << \"其他异常\" << endl; }\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n可以看到我们的异常处理模块相当繁杂，在实际开发项目中异常的数量远远不止上面模拟的三种，可能多达上百种或则更多，这是异常的处理将变得十分繁杂，那么如何处理呢？\n\n可能心细的读者会发现，我们在处理异常时使用了专门的异常处理类，而类是可以继承的，于是乎，继承在异常处理中的作用就体现出来了。\n\n我们再来看一份优化后的代码\n\n```c++\nclass A//A类实现输入一个范围在0-10的奇数\n{\npublic:\n\tA(int a) \n\t{\n\t\tif (a % 2 != 0) {\n\t\t\tif (a < 0)throw LtZero();\n\t\t\tif (a > 10)throw GtTen();\n\t\t\telse num = a;\n\t\t}\n\t\telse throw Even();\n\t}\n\n\tclass Even\n\t{\n\tpublic:\n\t\tvirtual void PrintErro()\n\t\t{\n\t\t\tcout<< \"输入的数是偶数\" << endl;\n\t\t}\n\t};\n\tclass LtZero:public Even\n\t{\n\tpublic:\n\t\tvoid PrintErro()\n\t\t{\n\t\t\tcout << \"输入的数小于0\" << endl;\n\t\t}\n\t};\n\tclass GtTen:public Even\n\t{\n\tpublic:\n\t\tvoid PrintErro()\n\t\t{\n\t\t\tcout << \"输入的数大于10\" << endl;\n\t\t}\n\t};\nprivate:\n\tint num;\n};\n\nint main()\n{\n\ttry { A a(4); }\n\tcatch (A::Even e) { e.PrintErro(); }\n\tcatch (...) { cout << \"其他异常\" << endl; }\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n可以看到我们的异常处理模块使用多态，繁杂程度被大幅缩水了，而我们的异常处理被集中在了异常处理类中，有时，如果我们的异常处理只对某一个类有效也是可以直接将异常处理类定义在抛出类里面的。\n\n## 6.标准异常库\n\nC++提供一些标准的异常库，头文件为：#include<stdexcep>\n\n# 六、标准IO流\n\n## 1.标准IO流流程\n\n![](【C++】C++高级/Snipaste_2019-10-06_10-03-47.png)\n\n## 2.标准输入流\n\n| 标准函数                             | 作用                                                         |\n| ------------------------------------ | ------------------------------------------------------------ |\n| cin                                  | cin>>操作支持任何基本类型的输入，但是遇到空格则结束读取      |\n| cin.get(char chr)                    | 从缓冲区中读取一个字符到chr中，因为C++定义的cin.get(char)中会返回一个函数自身的引用，所以此函数支持链式编程，即cin.get(a).get(b).get(c);b表示依次从缓冲区中读取三个字符到a，b，c中 |\n| cin.get(char* buf,int cout)          | 从缓冲区中读取cout个字符到buf数组中，因为函数似乎会在数组末尾添加点什么，所以实际读取的字符数量是cout-1个，此函数也支持链式编程 |\n| cin.get(char* buf,int cout,char chr) | 从缓冲区中读取cout个字符到buf数组中，如果碰到字符chr则结束读取 |\n| cin.getline(char buf,int cout)       | 从缓冲区中读取cout个字符到buf数组中                          |\n| cin.ignore(int num)                  | 忽略缓冲区当前读取指针开始的num个字符再读取                  |\n| cin.peek()                           | 判断缓冲区中是否有数据，如果有则返回第一个字符，如果没有则阻塞程序 |\n| cin.putback(char chr)                | 将读取出来的字符再返存回缓冲区，只能读取一个字符             |\n\n## 3.标准输出流\n\n| 标准函数                       | 作用                                                         |\n| ------------------------------ | ------------------------------------------------------------ |\n| cout                           | 输出缓冲区内容，支持任何基本类型数据的输出                   |\n| cout.flush(void)               | 刷新缓冲区，无视系统繁忙，强制输出缓冲区的字符，语法和cout一样“cout.flush()<<buf<<endl;” |\n| cout.put(char chr)             | 在标准输出设备输出指针的当前位置插入字符chr，语法和cout一致  |\n| cout.write(char *chr,int cout) | 输出*chr所指向空间中cout个数量的字符，即使越界也会继续输出，语法和cout一致 |\n| cout.width(int num)            | 输出num个字节宽度的字符，一般配合cout.fill(char chr)和其他cout函数一起使用 |\n| cout.fill(char chr)            | 配合cout.width(int num)和其他cout一起使用，在输出的num宽度的字符中将cout函数没有填充完的字符用chr填充 |\n| cout.setf(标记)                | 格式化cout输出，标记种类很多，具体的可以查阅资料，配合cout函数一起使用 |\n\n## 4.文件IO流\n\n​\t文件操作相对来说比较简单，总的来说就是5个步骤，即\n\n### 操作步骤\n\n- ​\t包含头文件<font color = red>#include<ftream></font>\n\n- ​\t创建流对象\n\n- ​\t打开文件\n\n- ​\t读写文件\n\n  ​\t<font color = red>需要注意的是C++中文件写的方式是使用符号“<<”，如：fout << \"文件内容\"<<endl;</font>\n\n  ​\t<font color = red>同理文件读也可以使用“>>”来读。</font>\n\n- ​\t关闭文件\n\n  **文件写**\n\n```c++\n#include <iostream>\n#include <string>\n#include <fstream>\n\nusing namespace std;\n\nvoid test()\n{\n\tofstream fout;\n\tfout.open(\"文件测试.txt\", ios::out);\n\tfout << \"姓名：张三\" << endl;\n\tfout << \"性别：男\" << endl;\n\tfout.close();\n}\n\nint main()\n{\n\ttest();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n​\t**输出结果：**\t\n\n![](【C++】C++高级/Snipaste_2019-09-14_16-29-43.png)\n\n### 4种文件读的方式\n\n```c++\n#include <iostream>\n#include <string>\n#include <fstream>\n\nusing namespace std;\n\nvoid test()\n{\n\tifstream fin;\n\tfin.open(\"文件测试.txt\", ios::in);\n\tif (!fin.is_open())//文件读需要多添加一步判断文件是否打开成功的步骤\n\t{\n\t\tcout << \"文件打开失败\" << endl;\n\t}\n\tchar str[1024];\n\tstring strs;\n\tchar chr;\n\t//第一中方式\n\t//while (fin >> str)//操作符\">>\"每次只能读取一行数据，读到文件尾“EOF”时结束\n\t//{\n\t//\tcout << str << endl;\n\t//}\n\n\t//第二种方式\n\t//while (fin.getline(str, 50))//ifstream::getline(char *str,int num);这个函数只支持字符数组，参数num指的是需要读取的字节数\n\t//{\n\t//\tcout << str << endl;\n\t//}\n\n\t//第三种方式\n\t//while (getline(fin, strs))//与第二种方式不同的是，这个getline函数是全局的，且只支持输出到string类型的对象中\n\t//{\n\t//\tcout << strs << endl;\n\t//}\n\n\t//第四中方式\n\twhile ((chr = fin.get()) != EOF)//get()函数每次只能读取一个字符\n\t{\n\t\tcout << chr ;\n\t}\n\tfin.close();\n}\n\nint main()\n{\n\ttest();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n### 文件的打开模式\n\n​\tC++提供6中文件的打开方式\n\n| 打开方式    | 解释                                               |\n| ----------- | -------------------------------------------------- |\n| ios::in     | 以读的形式打开                                     |\n| ios::out    | 以写的形式打开，会覆盖源文件                       |\n| ios::ate    | 以写的形式打开并初始文件位置：文件尾，会覆盖源文件 |\n| ios::app    | 以追加的方式打开文件                               |\n| ios::trunc  | 如果文件存在先删除再创建                           |\n| ios::binary | 以二进制的形式打开                                 |\n\n### 读写二进制文件\n\n```c++\n#include <iostream>\n#include <string>\n#include <fstream>\n\nusing namespace std;\n\nclass Person\n{\npublic:\n\tstring name = \"张三\";\n\tstring sex = \"男\";\n};\n\nvoid test()\n{\n\tofstream fout;\n\tfout.open(\"二进制文件测试.txt\", ios::out | ios::binary);\n\tPerson p;\n\tfout.write((char *)&p, sizeof(Person));//注意这里使用ofstream::write()来写\n\tfout.close;\n\n\tifstream fin;\n\tfin.open(\"二进制文件测试.txt\", ios::in | ios::binary);\n\tif (!fin.is_open())\n\t{\n\t\tcout << \"文件打开错误\" << endl;\n\t\treturn;\n\t}\n\tPerson pin;\n\tfin.read((char *)&pin, sizeof(Person));//注意这里使用ofstream::read()来读\n\tcout << \"姓名：\" << pin.name << endl;\n\tcout << \"性别：\" << pin.sex << endl;\n\tfin.close();\n}\n\nint main()\n{\n\ttest();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n","source":"_posts/【C++】C++高级.md","raw":"---\ntitle: 【C++】C++高级\ndate: 2019-09-14 09:01:06\ntags: CPlus\ncategories: 学习笔记\n---\n\n\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 一、类\n\n## 1.浅拷贝与深拷贝\n\n### 浅拷贝\n\n<font color=red> C++在进行浅拷贝时，只拷贝栈区的内存空间，不拷贝堆区的内存空间，即浅拷贝只拷贝非指针的成员变量和指针本身，而不拷贝指针所指向的堆区的内容。</font>\n\n我们代码1.1为例\n\n```c++\n//代码1.1\nclass Obj\n{\npublic:\n\tObj(char *tp)\n\t{\n\t\tlen = strlen(tp);\n\t\tp = (char*)malloc(len + 1);\n\t\tstrcpy_s(p, len+1, tp);\n\t}\n\t~Obj()\n\t{\n\t\tif (p != NULL)\n\t\t{\n\t\t\tfree(p);\n\t\t\tp = NULL;\n\t\t\tlen = 0;\n\t\t}\n\t}\n\tvoid Show()\n\t{\n\t\tcout << *p << *(p + 1) << *(p + 2) << endl;\n\t}\nprivate:\n\tchar *p;\n\tint len;\n};\n\nvoid text(Obj &obj)\n{\n\tObj obj2 = obj;\n}\n\nint main()\n{\n\tObj obj1(\"asd\");\n\ttext(obj1);\n\tobj1.Show();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n我们作一个图示：\n\n![](B:\\Git\\Blog\\source\\_posts\\【C++】C++高级\\Snipaste_2019-10-01_16-21-15.png)\n\n​\t我们没有自定义Obj类的拷贝构造函数，所以当代码执行到`Obj obj2 = obj1;`时，编译器将调用默认的拷贝构造函数，然而，<font color=red> 编译器默认的拷贝构造函数是一个浅拷贝</font>，所以新创建的对象obj2没有自己的堆区空间，obj2.p指向的是obj1.p所指向的内存地址。\n\n​\t上面的代码编译是通不过的，<font color=red> 原因在于，对象析构时，同一个内存地址`0x0001`被对象obj1和obj2一起析构了两次</font>。当代码执行完`test(obj1)`时，对象obj2被析构，指针obj2.p所指向的内存地址`0x0001`被释放，所以当代码执行到`obj1.Show()`时，使用了已经被释放掉的内存`0x0001`地址，从而导致运行错误。\n\n​\t<font color=green> **这里我有一个疑问，既然浅拷贝在拷贝有指针的对象时，会出现两次析构而出错，所以浅拷贝只能拷贝没有指针成员的对象，那么浅拷贝和深拷贝似乎没有什么区别了，那么浅拷贝存在的意义是什么呢？**</font>\n\n### 深拷贝\n\nC++没有提供给开发者预定义的深拷贝方法，所以要想使用深拷贝，我们需要字写一个拷贝构造函数。\n\n深拷贝可以解决上面遇到的浅拷贝的问题，因为，<font color=red> 深拷贝会申请一新的内存空间用于存放拷贝过来的内容，即深拷贝拷贝对象的所有成员，包括指针所指向的内存空间也会一起被拷贝，被拷贝过来的指针会指向一个新的内存地址</font>。\n\n![](【C++】C++高级/Snipaste_2019-10-01_16-52-53.png)\n\n### 定义深拷贝构造函数\n\n```c++\n//代码1.2\nclass Obj\n{\npublic:\n\tObj(char *tp)\n\t{\n\t\tlen = strlen(tp);\n\t\tp = (char*)malloc(len + 1);\n\t\tstrcpy_s(p, len+1, tp);\n\t}\n    //------------------------------\n    //拷贝构造函数--深拷贝\n\tObj(const Obj &obj)\n\t{\n\t\tlen = obj.len;\n\t\tp = (char*)malloc(len + 1);\n\t\tstrcpy_s(p, len + 1, obj.p);\n\t}\n    //------------------------------\n\t~Obj()\n\t{\n\t\tif (p != NULL)\n\t\t{\n\t\t\tfree(p);\n\t\t\tp = NULL;\n\t\t\tlen = 0;\n\t\t}\n\t}\n\tvoid Show()\n\t{\n\t\tcout << *p << *(p + 1) << *(p + 2) << endl;\n\t}\nprivate:\n\tchar *p;\n\tint len;\n};\n```\n\n当一个类中定义了拷贝构造函数，则在对象拷贝时，编译器就不会在调用默认的拷贝构造函数转而调用自定义的拷贝构造函数，当我们把代码1.1中类的定义改为代码1.2中类的定义后，程序就可以正常执行了。\n\n<font color=red>使用深拷贝时，我们还需要注意下面的情况：</font>\n\n```c++\nObj obj1(\"asd\");\nObj obj3(\"fgh\");\nobj3 = obj1;\n```\n\n此时，在`obj3=obj1;`处依旧调用默认的拷贝构造函数，这里我们要弄清楚`obj3=obj1`和`Obj obj3 = obj1`之间的区别，`obj3=obj1`是将<font color=red>obj1赋值给obj3</font>，`=`赋值与拷贝构造函数没有什么关联，`=`在赋值时是C++编译器自己调用默认的拷贝构造函数---浅拷贝，和类中有无定义深拷贝无关；而`Obj obj3=obj1`则是<font color=red>使用obj1来构造obj3</font>，此时如果类中定义了深拷贝构造函数，就会使用深拷贝。要解决这个问题，就需要显示重载`=`运算符了。\n\n### <font color=blue>**小知识**</font>\n\n- <font color=blue>在定义拷贝构造函数时，必须使用引用传递，否则会出现无限拷贝的情况，因为，如果我们使用传值传递的话，在传递对象到拷贝构造函数时，又会调用拷贝构造函数将实参拷贝给形参，而这个过程又会将对象传递给拷贝构造函数，从而在此调用拷贝构造函数将实参拷贝给形参，如此无限循环</font>\n- <font color=blue>拷贝构造函数只能有一个参数，且必须是自身类的引用，否则编译器将识别被普通构造函数</font>\n\n## 2.初始化参数列表\n\n### 作用\n\n我们以下面的代码1.3来说明初始化参数列表\n\n```C++\nclass A\n{\npublic:\n\tA(int a)\n\t{\n\t\tthis->a = a;\n\t}\nprivate:\n\tint a;\n};\nclass B\n{\npublic :\n\tB(int i)\n\t{\n\t\tthis->i = i;\n\t}\n\tint i;\n\tA a;\n\n};\nint main()\n{\n\tB b(1);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**运行结果：**\n\n```\n错误\tC2512\t“A”: 没有合适的默认构造函数可用\n```\n\n​\t这个问题就在于，在类B中组合了一个A类的成员，编译器在构造B类对象时，同时会构造一个A类对象作为B类的成员，然而，因为A类自定义了一个有参的构造函数，所以在构造A类时，编译器不会使用默认构造函数，而是使用自定义的有参构造函数，问题就出在这里，编译器在构造A类时，没有参数传递到A类的有参构造函数中。初始化参数列表就是用于解决这种问题的。\n\n​\t需要说明的是，如果A类中没有自定义有参的构造函数，则在B类构造对象时编译器自动调用A类的默认构造函数构造A类对象成员，就不会报错。\n\n​\t初始化参数列表可以让我们在构造B类对象时，根据参数列表来构造不同的A类成员。\n\n### 使用\n\n初始化参数列表的使用如下面的`B(int i):a1(1),a2(2,\"asd\")`：\n\n```c++\nclass A\n{\npublic:\n\tA(int a)\n\t{\n\t\tthis->a = a;\n\t\tcout << \"构造小A\" << endl;\n\t}\n\tA(int a, string str)\n\t{\n\t\tthis->a = a;\n\t\tthis->str = str;\n\t\tcout << \"构造大A\" << endl;\n\t}\n\t~A()\n\t{\n\t\tcout << \"析构A\" << endl;\n\t}\n\tint a;\n\tstring str;\n};\nclass B\n{\npublic :\n\tB(int i):a1(1),a2(2,\"asd\")\n\t{\n\t\tthis->i = i;\n\t\tcout << \"构造B\" << endl;\n\t}\n\t~B()\n\t{\n\t\tcout << \"析构B\" << endl;\n\t}\n\n\tint i;\n\tA a1;\n\tA a2;\n};\nvoid test()\n{\n\tB b(1);\n\tcout << b.a1.str << endl;\n\tcout << b.a2.str << endl;\n}\nint main()\n{\n\ttest();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**输出结果：**\n\n```\n构造小A\n构造大A\n构造B\n\nasd\n析构B\n析构A\n析构A\n```\n\n​\t值得注意的是<font color=red> A类对象的构造顺序不是由初始化参数列表的顺序决定的，而是由对象的申明的前后顺序决定的</font>，如：`B(int i):a1(1),a2(2,\"asd\")`和`B(int i):a2(2,\"asd\"),a1(1)`的构造顺序是一样的，但是当我们将类B中组合的A类对象的申明顺序改为如下\n\n```c++\nclass B\n{\npublic :\n\tB(int i):a1(1),a2(2,\"asd\")\n\t{\n\t\tthis->i = i;\n\t\tcout << \"构造B\" << endl;\n\t}\n\t~B()\n\t{\n\t\tcout << \"析构B\" << endl;\n\t}\n\n\tint i;\n\tA a2;\n\tA a1;\n};\n```\n\n则构造顺序就变为“先构造a2再构造a1”了。\n\n<font color=red> 析构的顺序和构造的顺序相反。</font>\n\n### <font color=blue> 小知识</font>\n\n- <font color=blue> 当一个类中组合了其他的类对象作为成员时，拷贝构造函数也必须使用初始化参数列表，来构造对象成员然后拷贝</font>\n\n## 3.匿名对象的生命周期\n\n### 什么是匿名对象\n\n```C++\ncalss A\n{\npublic:\n\tint a;\n\tA(int a)\n\t{\n\t\tthis->a = a;\n\t}\n}\nvoid main()\n{\n    A(1);\n}\n```\n\n上面的语句`A(1)`创建的就是一个匿名临时的对象，<font color=red> 需要注意，如果一个类只有无参的构造函数，那么这个类将无法构建匿名对象</font>，匿名对象的生命周期就只在创建匿名对象的这条语句内，如果我们不使用一个对象来接收这个匿名对象，那么匿名对象会在语句结束时被销毁，当我们使用`A a = A(1);`不会出现匿名对象拷贝到类B对象b的情况，这种语句已经被C++优化成了类B的构造语句。说这么多其实匿名对象没什么卵用。\n\n## 4.new和delete\n\n1.new和delete的用法\n\n`new`可以为**基础类型**、**数组**、**类**分配内存空间，`new`分配的内存空间都分配在**堆**上。随意`new`出来的内存空间必须使用一个指针来指向，不能使用同类型的变量来接收，也禁止不接受。\n\n**new 基础类型**\n\n```c++\nint *p = new int;\ndelete p;\n```\n\n**new 数组**\n\n```c++\nint *p = new int[10];\ndelete[] p;\n```\n\n**new 类**\n\n```c++\n//C++\nA *p = new A();\ndelete p;\n//C\nA *pc = (A*)malloc(A);\nfree(pc);\n```\n\n### `new delete`和`malloc free`的区别\n\n- 在基础类型和基础类型数组方面`new delete`和`malloc free`几乎没有什么区别\n\n- `new`不仅会分配内存还会调用构造函数，而`malloc`只会分配内存\n\n- `delete`会调用析构函数来销毁对象，而`free`只是单纯的释放内存\n\n### <font color=blue> **小知识**</font>\n\n<font color=blue> `new delete`和`malloc free`是可以穿插使用的，即`new`可以和`free`搭配使用，`malloc`可以和`delete`搭配使用。</font>\n\n# 二、继承\n\n继承这边主要分析一下`虚继承`\n\n## 1.虚继承\n\n虚继承的出现主要是为解决如下的继承关系中的二义性问题\n\n![图1](【C++】C++高级/Snipaste_2019-10-02_15-50-39.png)\n\n当我们的类的继承过程中出现这种继承关系时，我们需要使类B和类C分别虚继承类A来解决二义性，具体操作如下：\n\n```c++\nclass A\n{\n   public:\n    \tint a;\n};\nclass B : virtual public A\n{\n\tpublic:\n\t\tint b;\n};\nclass C : virtual public A\n{\n\tpublic:\n\t\tint c;\n};\nclass D : public B,C\n{\n\tpublic:\n\t\tint d;\n};\nvoid main()\n{\n    D d;\n    d.a = 1;\n}\n```\n\n这里有一点要注意，虚继承的应用场景有限，虚继承只能解决这种情况：\n\n![](【C++】C++高级/Snipaste_2019-10-02_15-50-39.png)\n\n而不能解决这种情况：\n\n![](【C++】C++高级/Snipaste_2019-10-02_16-10-55.png)\n\n## 2.继承中的static关键字\n\n<font color=red> 类中的静态成员变量被类的所有对象共享，同时也被类的派生类的所有对象共享。</font>\n\n# 三、多态\n\n​\t在C++的几个特性中，封装、继承和抽象都相对好理解，而多态则不太好理解，这里就说说C++的多态。\n\n## 1.多态分两种：\n\n​\t静态多态：静态多态指的就是函数重载和运算符重载。\n\n```c++\nclass Animal\n{\npublic:\n\tstring name = \"动物\";\n\tvirtual void speak()\n\t{\n\t\tcout << name << \"在叫\" << endl;\n\t}\n};\n\nclass Dog : public Animal\n{\npublic:\n\tstring name = \"狗\";\n\tvoid speak()\n\t{\n\t\tcout << name << \"在叫\" <<endl;\n\t}\n};\n\nstring operator+(Animal animal,Dog dog)\n{\n\treturn animal.name + \"是\" + dog.name + \"的父类\";\n}\n\nvoid Run(Animal animal)\n{\n\tcout << animal.name <<\"在跑\" << endl;\n}\n\nvoid Run(Dog dog)\n{\n\tcout << dog.name << \"在跑\" << endl;\n}\n\nint main()\n{\n\tAnimal animal;\n\tDog dog;\n\tRun(animal);\n\tRun(dog);\n\tcout<<animal+dog<<endl;\n\tsystem(\"pause\");\n}\n```\n\n​\t动态多态：动态多态则是通过继承和虚函数实现标签相同的函数因为传入不同的对象来实现不同的功能。\n\n```c++\nclass Animal\n{\npublic:\n\tstring name = \"动物\";\n\tvirtual void speak()\n\t{\n\t\tcout << name << \"在叫\" << endl;\n\t}\n};\n\nclass Dog : public Animal\n{\npublic:\n\tstring name = \"狗\";\n\tvoid speak()\n\t{\n\t\tcout << name << \"在叫\" <<endl;\n\t}\n};\n\nvoid Speak(Animal *animal)\n{\n\tanimal->speak();\n}\n\nint main()\n{\n\tAnimal animal;\n\tDog dog;\n\tSpeak(&animal);\n\tSpeak(&dog);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n​\t动态多态中只能用父类对象的指针或引用来指向子类或自身对象。\n\n## 2.多态的实现原理\n\n​\tC++多态的实现依赖于类的虚函数表，当一个类中定义了虚函数，那么这个类就拥有的了一个记录这个虚函数入口地址的虚函数表，子类继承父类时也会继承父类的虚函数表，当子类重写父类的虚函数时，则子类的虚函数入口地址将覆盖父类的地址，如此当子类对象调用此函数时则从子类的虚函数表中寻找入口地址，当父类的对象调用此函数时则从父类的虚函数表中寻找入口地址。\n\n```\n当类创建虚函数时，编译器会在类中生成一个虚函数表\n虚函数表是一个存储类成员函数指针的数据结构\n虚函数表有编译器自动生成和维护\n虚成员函数会被编译器放入虚函数表中\n存在虚函数时，每一个对象中都会拥有一个指向虚函数表的虚函数表指针(vptr)\n```\n\n简单来说，多态实现的条件有三：\n\n- 要有继承\n\n- 要有虚函数重写\n\n- 要有父类指针(或引用)指向子类对象\n\n## 3.纯虚函数和抽象类\n\n​\t纯虚函数的定义：\n\n```c++\nvirtual void speak() = 0\n```\n\n​\t定义了纯虚函数的类就被成为抽象类，C++引入纯虚函数和抽象类的概念就是为了更好的使用多态，抽象类不能实例化对象，这个特性就规范了继承这个抽象类的子类必须重写父类的虚函数，因为如果继承了抽象类的子类不重写父类的虚函数，那么子类也是一个抽象类，子类便也不能实例化对象，如此便规范了多态实现，防止当子类很多时，出现某个子类在编写时忘记重写父类的虚函数，而导致这个子类没有实现多态。\n\n## 4.虚析构函数和纯虚析构函数\n\n- 虚析构函数的定义：\n\n```c++\nvirtual ~Animal();\n```\n\n- 纯虚析构函数的定义：\n\n```c++\nvirtual ~Animal() = 0;\n//纯虚析构函数必须要有申明也要有实现\nAnimal：：~Animal()\n{\n    //代码实现\n}\n```\n\n如果子类在堆区中定义了数据，那么我们使用父类指针或引用来使用多态时，父类指针或引用是无法寻找到子类在堆区中的数据并释放的。C++引入虚析构函数和纯虚析构函数就是为了解决此类问题。\n\n​\t我们来看一个例子：\n\n```c++\nclass Animal\n{\npublic:\n\tAnimal()\n\t{\n\t\tcout << \"这是Animal的构造函数\" << endl;\n\t}\n\t~Animal()\n\t{\n\t\tcout << \"这是Animal的析构函数\" << endl;\n\t}\n};\n\nclass Dog : public Animal\n{\npublic:\n\tint *p;\n\tDog()\n\t{\n\t\tp = new int;\n\t\tcout << \"这是Dog的构造函数\" << endl;\n\t}\n\t~Dog()\n\t{\n\t\tcout << \"这是Dog的析构函数\" << endl;\n\t\tif (p != NULL)\n\t\t{\t\t\n\t\t\tcout << \"释放堆区的p\" << endl;\n\t\t\tdelete p;\n\t\t\tp = NULL;\n\t\t}\n\t}\n};\n\nint main()\n{\n\tAnimal *animal = new Dog();\n\tdelete animal;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n输出结果：\n\n```\n这是Animal的构造函数\n这是Dog的构造函数\n这是Animal的析构函数\n```\n\n可以看到，delete animal后并没有调用Dog的析构函数，释放子类Dog在堆区申请的空间。这样便出现了内存泄漏。\n\n此时虚析构函数和纯虚析构函数便可以起作用了，我们再看一个例子：\n\n```c++\nclass Animal\n{\npublic:\n\tAnimal()\n\t{\n\t\tcout << \"这是Animal的构造函数\" << endl;\n\t}\n\tvirtual ~Animal()//把父类的析构函数改为虚析构函数\n\t{\n\t\tcout << \"这是Animal的析构函数\" << endl;\n\t}\n};\n\nclass Dog : public Animal\n{\npublic:\n\tint *p;\n\tDog()\n\t{\n\t\tp = new int;\n\t\tcout << \"这是Dog的构造函数\" << endl;\n\t}\n\t~Dog()\n\t{\n\t\tcout << \"这是Dog的析构函数\" << endl;\n\t\tif (p != NULL)\n\t\t{\t\t\n\t\t\tcout << \"释放堆区的p\" << endl;\n\t\t\tdelete p;\n\t\t\tp = NULL;\n\t\t}\n\t}\n};\n\nint main()\n{\n\tAnimal *animal = new Dog();\n\tdelete animal;\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n​\t输出结果：\n\n```\n这是Animal的构造函数\n这是Dog的构造函数\n这是Dog的析构函数\n释放堆区的p\n这是Animal的析构函数\n```\n\n​\t如此便可以释放子类Dog在堆区申请的空间了，纯虚析构函数和虚析构函数的作用是一样，只是纯虚析构函数有一个和纯虚函数一样的特性，即定义了纯虚析构函数的类也属于抽象类，纯虚析构函数必须实现，如果不实现所有继承了拥有纯虚析构函数的抽象类的派生类都属于抽象类。需要注意的是，因为纯虚析构函数的特性，纯虚析构函数的实现就必须在类外实现了。\n\n## 5.重载、重写、重定义\n\n**重载**\n\n重载发生在一个类的内部，拥有相同函数名，相同返回值而参数列表不同的函数之间互为重载关系。如：\n\n```c++\nclass A\n{\n\tpublic:\n\t\tvoid fun(){}\n\t\tvoid fun(int a){}\n};\n```\n\n<font color=red> 只有相同函数名而参数列表不同的函数才是重载，函数名相同参数列表也相同而返回值不同的函数在C++中是不允许的。</font>\n\n**重写**\n\n重写发生在基类和派生类之间，基类中定义虚函数(纯虚函数)，派生类中定义和虚函数拥有**相同函数名，相同参数列表和相同返回值**的函数，这种情况下发生函数重写。如：\n\n```c++\nclass A\n{\n    public:\n    \tvirtual void fun(){}\n};\nclass B : public A\n{\n\tpublic:\n\t\tvoid fun(){}//重写A类的fun函数\n\t\tvoid fun(int a){}//重定义一个新函数\n\t\tint fun(){return 0;}//这种情况C++不允许\n};\n```\n\n**重定义**\n\n重定义也是发生在基类和派生类之间，派生类拥有与基类函数名相同，返回值相同，而参数列表不同的函数，此时发生重定义。如：\n\n```c++\nclass A\n{\n  public:\n    void fun(){}\n};\nclass B : public A\n{\n\tpublic:\n\t\tvoid fun(int a){}//发生重定义\n};\n```\n\n<font color = red> 派生类中可以重定义基类的任何函数，包括虚函数和纯虚函数。</font>\n\n## 6.父类指针和子类指针步长不一致问题\n\n问题出现的场景是这样的：\n\n```c++\nclass A\n{\npublic:\n\tint a;\n\tvirtual void print() {}\n};\nclass B : virtual public A\n{\npublic:\n\tint b;\n\tB(int b)\n\t{\n\t\tthis->b = b;\n\t}\n\tvoid print()\n\t{\n\t\tcout << b << endl;\n\t}\n};\nint main()\n{\n\tA *a = NULL;\n\tB *b = NULL;\n\tB array[2]{ B(1),B(2) };\n\ta = array;\n\tb = array;\n\ta->print();\n\tb->print();\n\ta++; b++;\n\ta->print();//这一步会出现异常\n\tb->print();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n即父类指针a和子类指针b都指向一个子类对象数组，于是我们可以通过指针++的自增运算来逐步访问数组元素，问题就出在这，使用`sizeof()`计算两个类的大小分别得出，sizeof(A)=8;sizeof(B)=20;这就导致A类指针a每一次移步时只移动了8个字节，这个距离还远远没有达到下一个元素的首地址，所以访问会出错，这是因为指针每次移步移动的距离是指针类型的空间大小，如：A类大小为8，所以A类指针每移步一次走8个字节。\n\n可能会有疑问，为什么类B的大小是20？\n\n我们可以算一算，类B继承至类A所以类A中拥有的成员变量，类B也拥有，占8字节，这8字节分别是int变量4字节和虚函数表指针4字节；类B自身定义了一个int变量占4字节，由于类B重写了类A的虚函数，所以类B也拥有一个自己的虚函数表指针，占4字节；类B虚继承了类A，在这个过程中，C++编译器会给类B增加一个属性，占4字节，于是，**8+4+4+4+4=20**。\n\n------\n\n# 四、泛型编程\n\n## 1.函数模板\n\n### 函数模板的基本语法\n\n```c++\n//---------------函数模板\ntemplate <typename T>//告诉编译器我要开始泛型编程了，遇到T不要报错\nvoid Fun(T &a,T &b)\n{\n\tT t = a;\n\ta = b;\n\tb = t;\n}\n//----------------\nint main()\n{\n\tchar a = 97,b = 102;\n\tFun(a, b);//自动推导类型调用\n\tcout << a << \",\" << b << endl;\n\tstring x = \"xxx\", y = \"yyy\";\n\tFun<string>(x, y);//显示类型调用\n\tcout << x << \",\" << y << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n### 当函数模板遇到函数重载\n\n当函数模板遇到函数重载准许下面4条原则\n\n- 函数模板可以像普通函数一样被重载\n- C++编译器优先考虑普通函数\n- 如果函数模板可以产生一个更好的匹配，那么选择函数模板\n- 可以通过模板的空实参列表的语法限定编译器只通过函数模板匹配\n\n我们来看一个例子，逐一分析\n\n```c++\ntemplate <typename T>\nvoid Fun(T a,T b)\n{\n\ta = a + b;\n\tcout << \"我是函数模板\" << endl;\n}\ntemplate <typename T1,typename T2>\nvoid Fun(T1 a,T2 b)\n{\n\tT1 x = a;\n\tT2 y = b;\n\tcout << \"我是函数模板重载\" << endl;\n}\nvoid Fun(int a, int b)\n{\n\tcout << \"我是普通函数\" << endl;\n}\nvoid Fun2(int a, int b)\n{\n\tcout << a << \",\" << b << endl;\n}\nint main()\n{\n\tFun(1, 2);\n\tFun(0.1, 0.2);\n\tFun('c', 1);\n\tFun<>(1, 2);\n\tFun2(0.1, 0.2);\n\tFun2('a', 3);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**输出结果：**\n\n```\n我是普通函数\n我是函数模板\n我是函数模板重载\n我是函数模板\n0,0\n97,3\n```\n\n**分析：**\n\n- `Fun(1,2)`:有完全匹配的普通函数，所以调用`void Fun(int a, int b)`\n- `Fun(0.1,0.2)`:虽然普通函数`void Fun(int a, int b)`可以像`void Fun2(int a, int b)`一样进行隐式类型转换调用，倒是`Fun()`函数有更好的重载函数`void Fun(T1 a,T2 b)`模板匹配所以编译器优先调用`void Fun(T1 a,T2 b)`\n- `Fun('c',1)`:编译器能找到匹配的函数模板重载`void Fun(T1 a,T2 b)`所以优先调用函数模板\n- `Fun<>(1,2)`:使用了空参数列表，告诉编译器只匹配函数模板，即使代码段中有能完美匹配的普通函数，也只调用函数模板\n\n## 2.类模板\n\n### 定义\n\n```c++\ntemplate <typename T>//定义\nclass TemplateA\n{\npublic:\n\tTemplateA(T a)\n\t{\n\t\tthis->a = a;\n\t}\n\tvoid PrintA()\n\t{\n\t\tcout << \"a:\" << a << endl;\n\t}\nprivate:\n\tT a;\n};\n\nvoid Test(TemplateA<int> &a)//类模板作形参\n{\n\ta.PrintA();\n}\n\nint main()\n{\n\tTemplateA<int> a(1);//使用\n\tTemplateA<string> b(\"str\");\n\tTemplateA<bool> c(true);\n\tTest(a);\n\tb.PrintA();\n\tc.PrintA();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**输出结果：**\n\n```\na:1\na:str\na:1\n```\n\n类模板的定义和函数模板的定义类似\n\n### 使用\n\n类模板的使用必须显示的确定模板的类型参数，如：`TemplateA<string> b(\"str\")`\n\n### 类模板作参数\n\n类模板作参数也必须显示的确定模板那的类型参数，如：\n\n`void Test(TemplateA<int> &a)`以便编译器为形参确定内存空间。\n\n### 类模板派生普通类\n\n类模板也可以被继承，但是在继承时需要显示确定模板的类型参数\n\n```c++\ntemplate <typename T>\nclass TemplateA\n{\npublic:\n\tTemplateA(T a)\n\t{\n\t\tthis->a = a;\n\t}\n\tvoid PrintA()\n\t{\n\t\tcout << \"a:\" << a << endl;\n\t}\nprivate:\n\tT a;\n};\nclass B : public TemplateA<int>//类模板派生普通类\n{\npublic:\n\tB(int a, int b) :TemplateA(a)\n\t{\n\t\tthis->b = b;\n\t}\n\tvoid PrintB()\n\t{\n\t\tcout << \"b:\" << b << endl;\n\t}\nprivate:\n\tint b;\n};\n\nint main()\n{\n\tB b(1, 2);\n\tb.PrintA();\n\tb.PrintB();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n### 模板类派生模板类\n\n模板类不仅可以派生普通类，还可以派生模板类\n\n```c++\ntemplate <typename T>\nclass TemplateA\n{\npublic:\n\tTemplateA(T a)\n\t{\n\t\tthis->a = a;\n\t}\n\tvoid PrintA()\n\t{\n\t\tcout << \"a:\" << a << endl;\n\t}\nprivate:\n\tT a;\n};\ntemplate <typename T1,typename T2>\nclass TemplateB : public TemplateA<T2>//类模板派生类模板\n{\npublic:\n\tTemplateB(T2 a, T1 b) :TemplateA(a)\n\t{\n\t\tthis->b = b;\n\t}\n\tvoid PrintB()\n\t{\n\t\tcout << \"b:\" << b << endl;\n\t}\nprivate:\n\tT1 b;\n};\n\nint main()\n{\n\tTemplateB<string,char> b('A', \"TemplateB\");\n\tb.PrintA();\n\tb.PrintB();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**输出结果：**\n\n```\na:A\nb:TemplateB\n```\n\n### 类模板的主要作用\n\n类模板的主要作用就是将数据结构的表示和算法不受包含的元素类型的影响，即类模板将元素类型和数据结构算法分离开来了，使数据结构和算法成为真正意义上的数据结构和算法，如：链表不再因为`int`类型而定义一个`int`类型的链表，因`string`类型而定义一个`string`类型的链表，而是定义一个链表可以通用于所有类型。\n\n# 五、异常处理\n\n## 1.异常的基本语法\n\n```C++\nvoid Try(int x, int y)\n{\n\tif (y == 0)\n\t{\n\t\tcout << \"除数不能等于0，抛出异常\"<<endl;\n\t\tthrow y;//这里必须指明抛出异常的数据类型，否则程序无法处理异常，只能使用这个类型的变量，x和y的效果是一样的，不能直接抛出int，即这样是不行的throw int\n\t}\n\tcout << \"x/y=\" << x / y << endl;\n}\n\nvoid Test1()\n{\n\tTry(1, 2);\n\tTry(3, 0);\n}\n\nvoid Test2()\n{\n\ttry\n\t{\n\t\tTest1();\n\t}\n\tcatch (char e)\n\t{\n\t\tcout << \"处理char异常\" << endl;\n\t}\n\tcatch(...)\n\t{\n\t\tcout << \"无法处理的异常继续往上抛\" << endl;\n\t\tthrow;\n\t}\n}\n\nint main()\n{\n\ttry\n\t{\n\t\tTest2();\n\t}\n\tcatch(int e)\n\t{\n\t\tcout << \"处理int异常\" << endl;\n\t}\n\tcatch (...)\n\t{\n\t\tcout << \"处理其他异常\" << endl;\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**输出结果：**\n\n```\nx/y=0\n除数不能等于0，抛出异常\n无法处理的异常继续往上抛\n处理int异常\n```\n\n- 异常的抛出是可以跨函数的，如上面的代码，在`Try`函数里抛出的异常可以在`mian`函数中处理，中间跨过了`Test1`，`Test2`两个函数\n- 如果在一个函数内捕捉到异常但是却无法处理可以通过`throw`继续向上抛，直至main函数，如上面代码，`Test2`捕捉到异常但是没有处理继续向上抛给了main函数，如果main函数还是没有处理，则会直接中断程序\n- C++使用`cacth(...)`来捕捉其他没有捕捉到的异常，如上面代码，main函数中只捕捉了int类型的异常，如果出现其他类型的异常则有`cacth(...)`来捕捉\n- 异常处理是按照类型匹配来处理的，即`throw`的int类型的异常只有`cacth(int e)`能够接收得到，否则就只能使用`cacth(...)`来接收未知异常\n\n## 2.C++异常处理的特性\n\n​\tC++的异常处理具有跨函数性，这使得<font color=red> 异常引发</font>和<font color=red> 异常处理</font>分离开来，这样下层函数可以不用过多的在一异常处理，而把重点放在问题的逻辑处理上，异常处理可以由上层调用者专门来处理。\n\n## 3.异常接口申明\n\n**不抛出任何异常：**\n\n```C++\nvoid Try(int x, int y) throw()//异常接口申明\n{\n\tif (y == 0)\n\t{\n\t\tcout << \"除数不能等于0，抛出异常\"<<endl;\n\t\tthrow x;\n\t}\n\tcout << \"x/y=\" << x / y << endl;\n}\n```\n\n**只能抛出列表中类型的异常：**\n\n```C++\nvoid Try(int x, int y) throw(char,int*)\n{\n\tif (y == 0)\n\t{\n\t\tcout << \"除数不能等于0，抛出异常\"<<endl;\n\t\tthrow x;\n\t}\n\tcout << \"x/y=\" << x / y << endl;\n}\n```\n\n**可以抛出任何异常：**\n\n```C++\nvoid Try(int x, int y)\n{\n\tif (y == 0)\n\t{\n\t\tcout << \"除数不能等于0，抛出异常\"<<endl;\n\t\tthrow x;\n\t}\n\tcout << \"x/y=\" << x / y << endl;\n}\n```\n\n不过经过测试，三份代码无论是否写throw都是可以抛出并处理异常的，似乎这个语法没什么卵用，可能C++11摒弃了这种用法，但是考虑到兼容保留这个语法。\n\n## 4.异常接收的3种方式\n\n### 普通形参\n\n```c++\nclass A\n{\npublic:\n\tA() { cout << \"构造A\" << endl; }\n\tA(const A &a) { cout << \"拷贝A\" << endl; }\n\t~A() { cout << \"析构A\" << endl; }\n};\n\nvoid Try()\n{\n\tA a;\n\tthrow a;\n}\n\nint main()\n{\n\ttry\n\t{\n\t\tTry();\n\t}\n\tcatch(A e)//使用普通形参\n\t{\n\t\tcout << \"处理int异常\" << endl;\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**输出结果：**\n\n```\n构造A\n拷贝A\n拷贝A\n析构A\n处理int异常\n析构A\n析构A\n```\n\n可以看到a被拷贝两次，第一次从`A a`拷贝到`throw a`，第二次从`throw a`拷贝到`catch(A e)`，可以看出如果使用普通形参来接收异常，异常变量会由异常抛出处拷贝到异常接收处。\n\n### 引用\n\n将上面代码的`catch(A e)`改为`catch(A &e)`\n\n**输出结果：**\n\n```\n构造A\n拷贝A\n析构A\n处理int异常\n析构A\n```\n\n可以看到只拷贝了一次，即从`A a`拷贝到`throw a`。\n\n### 指针\n\n上面代码应该修改为如下\n\n```C++\nclass A\n{\npublic:\n\tA() { cout << \"构造A\" << endl; }\n\tA(const A &a) { cout << \"拷贝A\" << endl; }\n\t~A() { cout << \"析构A\" << endl; }\n};\n\nvoid Try()\n{\n\tA *a = new A();//对象必须创建在堆区，函数结束对象就会被销毁，而无法通过指针传递到catch中\n\tthrow a;\n}\n\nint main()\n{\n\ttry\n\t{\n\t\tTry();\n\t}\n\tcatch(A *e)\n\t{\n\t\tcout << \"处理int异常\" << endl;\n\t\tdelete e;//需要手动释放堆区的内存\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**输出结果：**\n\n```\n构造A\n处理int异常\n析构A\n```\n\n可以看到使用指针完全不需要拷贝，但是却需要消耗堆区的内存且容易造成内存泄露。\n\n### 总结\n\n总的来说，最优的方式还是使用引用。\n\n## 5.继承在异常处理中的应用\n\n在实际的项目中我们处理的异常并不是一些基础的数据类型，大多都是开发者的自定义类，这种情况在捕捉异常的时候就相当麻烦，尽管有些异常处理起来程序基本一致，但是却要将每一种异常一一捕捉并一一处理，下面的代码我们来模拟一下这种情况。\n\n```C++\nclass A//A类实现输入一个范围在0-10的奇数\n{\npublic:\n\tA(int a) \n\t{\n\t\tif (a % 2 != 0) {\n\t\t\tif (a < 0)throw LtZero();\n\t\t\tif (a > 10)throw GtTen();\n\t\t\telse num = a;\n\t\t}\n\t\telse throw Even();\n\t}\nprivate:\n\tint num;\n};\nclass LtZero//专门处理异常的异常类\n{};\nclass GtTen\n{};\nclass Even\n{};\n\nint main()\n{\n\ttry { A a(4); }\n\tcatch (LtZero &lz) { cout << \"输入的数小于0\" << endl; }\n\tcatch (GtTen &gt) { cout << \"输入的数大于10\" << endl; }\n\tcatch (Even &ev) { cout << \"输入的数是偶数\" << endl; }\n\tcatch (...) { cout << \"其他异常\" << endl; }\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n可以看到我们的异常处理模块相当繁杂，在实际开发项目中异常的数量远远不止上面模拟的三种，可能多达上百种或则更多，这是异常的处理将变得十分繁杂，那么如何处理呢？\n\n可能心细的读者会发现，我们在处理异常时使用了专门的异常处理类，而类是可以继承的，于是乎，继承在异常处理中的作用就体现出来了。\n\n我们再来看一份优化后的代码\n\n```c++\nclass A//A类实现输入一个范围在0-10的奇数\n{\npublic:\n\tA(int a) \n\t{\n\t\tif (a % 2 != 0) {\n\t\t\tif (a < 0)throw LtZero();\n\t\t\tif (a > 10)throw GtTen();\n\t\t\telse num = a;\n\t\t}\n\t\telse throw Even();\n\t}\n\n\tclass Even\n\t{\n\tpublic:\n\t\tvirtual void PrintErro()\n\t\t{\n\t\t\tcout<< \"输入的数是偶数\" << endl;\n\t\t}\n\t};\n\tclass LtZero:public Even\n\t{\n\tpublic:\n\t\tvoid PrintErro()\n\t\t{\n\t\t\tcout << \"输入的数小于0\" << endl;\n\t\t}\n\t};\n\tclass GtTen:public Even\n\t{\n\tpublic:\n\t\tvoid PrintErro()\n\t\t{\n\t\t\tcout << \"输入的数大于10\" << endl;\n\t\t}\n\t};\nprivate:\n\tint num;\n};\n\nint main()\n{\n\ttry { A a(4); }\n\tcatch (A::Even e) { e.PrintErro(); }\n\tcatch (...) { cout << \"其他异常\" << endl; }\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n可以看到我们的异常处理模块使用多态，繁杂程度被大幅缩水了，而我们的异常处理被集中在了异常处理类中，有时，如果我们的异常处理只对某一个类有效也是可以直接将异常处理类定义在抛出类里面的。\n\n## 6.标准异常库\n\nC++提供一些标准的异常库，头文件为：#include<stdexcep>\n\n# 六、标准IO流\n\n## 1.标准IO流流程\n\n![](【C++】C++高级/Snipaste_2019-10-06_10-03-47.png)\n\n## 2.标准输入流\n\n| 标准函数                             | 作用                                                         |\n| ------------------------------------ | ------------------------------------------------------------ |\n| cin                                  | cin>>操作支持任何基本类型的输入，但是遇到空格则结束读取      |\n| cin.get(char chr)                    | 从缓冲区中读取一个字符到chr中，因为C++定义的cin.get(char)中会返回一个函数自身的引用，所以此函数支持链式编程，即cin.get(a).get(b).get(c);b表示依次从缓冲区中读取三个字符到a，b，c中 |\n| cin.get(char* buf,int cout)          | 从缓冲区中读取cout个字符到buf数组中，因为函数似乎会在数组末尾添加点什么，所以实际读取的字符数量是cout-1个，此函数也支持链式编程 |\n| cin.get(char* buf,int cout,char chr) | 从缓冲区中读取cout个字符到buf数组中，如果碰到字符chr则结束读取 |\n| cin.getline(char buf,int cout)       | 从缓冲区中读取cout个字符到buf数组中                          |\n| cin.ignore(int num)                  | 忽略缓冲区当前读取指针开始的num个字符再读取                  |\n| cin.peek()                           | 判断缓冲区中是否有数据，如果有则返回第一个字符，如果没有则阻塞程序 |\n| cin.putback(char chr)                | 将读取出来的字符再返存回缓冲区，只能读取一个字符             |\n\n## 3.标准输出流\n\n| 标准函数                       | 作用                                                         |\n| ------------------------------ | ------------------------------------------------------------ |\n| cout                           | 输出缓冲区内容，支持任何基本类型数据的输出                   |\n| cout.flush(void)               | 刷新缓冲区，无视系统繁忙，强制输出缓冲区的字符，语法和cout一样“cout.flush()<<buf<<endl;” |\n| cout.put(char chr)             | 在标准输出设备输出指针的当前位置插入字符chr，语法和cout一致  |\n| cout.write(char *chr,int cout) | 输出*chr所指向空间中cout个数量的字符，即使越界也会继续输出，语法和cout一致 |\n| cout.width(int num)            | 输出num个字节宽度的字符，一般配合cout.fill(char chr)和其他cout函数一起使用 |\n| cout.fill(char chr)            | 配合cout.width(int num)和其他cout一起使用，在输出的num宽度的字符中将cout函数没有填充完的字符用chr填充 |\n| cout.setf(标记)                | 格式化cout输出，标记种类很多，具体的可以查阅资料，配合cout函数一起使用 |\n\n## 4.文件IO流\n\n​\t文件操作相对来说比较简单，总的来说就是5个步骤，即\n\n### 操作步骤\n\n- ​\t包含头文件<font color = red>#include<ftream></font>\n\n- ​\t创建流对象\n\n- ​\t打开文件\n\n- ​\t读写文件\n\n  ​\t<font color = red>需要注意的是C++中文件写的方式是使用符号“<<”，如：fout << \"文件内容\"<<endl;</font>\n\n  ​\t<font color = red>同理文件读也可以使用“>>”来读。</font>\n\n- ​\t关闭文件\n\n  **文件写**\n\n```c++\n#include <iostream>\n#include <string>\n#include <fstream>\n\nusing namespace std;\n\nvoid test()\n{\n\tofstream fout;\n\tfout.open(\"文件测试.txt\", ios::out);\n\tfout << \"姓名：张三\" << endl;\n\tfout << \"性别：男\" << endl;\n\tfout.close();\n}\n\nint main()\n{\n\ttest();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n​\t**输出结果：**\t\n\n![](【C++】C++高级/Snipaste_2019-09-14_16-29-43.png)\n\n### 4种文件读的方式\n\n```c++\n#include <iostream>\n#include <string>\n#include <fstream>\n\nusing namespace std;\n\nvoid test()\n{\n\tifstream fin;\n\tfin.open(\"文件测试.txt\", ios::in);\n\tif (!fin.is_open())//文件读需要多添加一步判断文件是否打开成功的步骤\n\t{\n\t\tcout << \"文件打开失败\" << endl;\n\t}\n\tchar str[1024];\n\tstring strs;\n\tchar chr;\n\t//第一中方式\n\t//while (fin >> str)//操作符\">>\"每次只能读取一行数据，读到文件尾“EOF”时结束\n\t//{\n\t//\tcout << str << endl;\n\t//}\n\n\t//第二种方式\n\t//while (fin.getline(str, 50))//ifstream::getline(char *str,int num);这个函数只支持字符数组，参数num指的是需要读取的字节数\n\t//{\n\t//\tcout << str << endl;\n\t//}\n\n\t//第三种方式\n\t//while (getline(fin, strs))//与第二种方式不同的是，这个getline函数是全局的，且只支持输出到string类型的对象中\n\t//{\n\t//\tcout << strs << endl;\n\t//}\n\n\t//第四中方式\n\twhile ((chr = fin.get()) != EOF)//get()函数每次只能读取一个字符\n\t{\n\t\tcout << chr ;\n\t}\n\tfin.close();\n}\n\nint main()\n{\n\ttest();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n### 文件的打开模式\n\n​\tC++提供6中文件的打开方式\n\n| 打开方式    | 解释                                               |\n| ----------- | -------------------------------------------------- |\n| ios::in     | 以读的形式打开                                     |\n| ios::out    | 以写的形式打开，会覆盖源文件                       |\n| ios::ate    | 以写的形式打开并初始文件位置：文件尾，会覆盖源文件 |\n| ios::app    | 以追加的方式打开文件                               |\n| ios::trunc  | 如果文件存在先删除再创建                           |\n| ios::binary | 以二进制的形式打开                                 |\n\n### 读写二进制文件\n\n```c++\n#include <iostream>\n#include <string>\n#include <fstream>\n\nusing namespace std;\n\nclass Person\n{\npublic:\n\tstring name = \"张三\";\n\tstring sex = \"男\";\n};\n\nvoid test()\n{\n\tofstream fout;\n\tfout.open(\"二进制文件测试.txt\", ios::out | ios::binary);\n\tPerson p;\n\tfout.write((char *)&p, sizeof(Person));//注意这里使用ofstream::write()来写\n\tfout.close;\n\n\tifstream fin;\n\tfin.open(\"二进制文件测试.txt\", ios::in | ios::binary);\n\tif (!fin.is_open())\n\t{\n\t\tcout << \"文件打开错误\" << endl;\n\t\treturn;\n\t}\n\tPerson pin;\n\tfin.read((char *)&pin, sizeof(Person));//注意这里使用ofstream::read()来读\n\tcout << \"姓名：\" << pin.name << endl;\n\tcout << \"性别：\" << pin.sex << endl;\n\tfin.close();\n}\n\nint main()\n{\n\ttest();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n","slug":"【C++】C++高级","published":1,"updated":"2021-03-30T06:15:50.916Z","_id":"ckk9hocbm003xdwr7encjdct0","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h1 id=\"一、类\"><a href=\"#一、类\" class=\"headerlink\" title=\"一、类\"></a>一、类</h1><h2 id=\"1-浅拷贝与深拷贝\"><a href=\"#1-浅拷贝与深拷贝\" class=\"headerlink\" title=\"1.浅拷贝与深拷贝\"></a>1.浅拷贝与深拷贝</h2><h3 id=\"浅拷贝\"><a href=\"#浅拷贝\" class=\"headerlink\" title=\"浅拷贝\"></a>浅拷贝</h3><p><font color=\"red\"> C++在进行浅拷贝时，只拷贝栈区的内存空间，不拷贝堆区的内存空间，即浅拷贝只拷贝非指针的成员变量和指针本身，而不拷贝指针所指向的堆区的内容。</font></p>\n<p>我们代码1.1为例</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//代码1.1</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Obj</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\tObj(<span class=\"hljs-keyword\">char</span> *tp)<br>\t&#123;<br>\t\tlen = <span class=\"hljs-built_in\">strlen</span>(tp);<br>\t\tp = (<span class=\"hljs-keyword\">char</span>*)<span class=\"hljs-built_in\">malloc</span>(len + <span class=\"hljs-number\">1</span>);<br>\t\tstrcpy_s(p, len+<span class=\"hljs-number\">1</span>, tp);<br>\t&#125;<br>\t~Obj()<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (p != <span class=\"hljs-literal\">NULL</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">free</span>(p);<br>\t\t\tp = <span class=\"hljs-literal\">NULL</span>;<br>\t\t\tlen = <span class=\"hljs-number\">0</span>;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Show</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; *p &lt;&lt; *(p + <span class=\"hljs-number\">1</span>) &lt;&lt; *(p + <span class=\"hljs-number\">2</span>) &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-keyword\">char</span> *p;<br>\t<span class=\"hljs-keyword\">int</span> len;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">text</span><span class=\"hljs-params\">(Obj &amp;obj)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tObj obj2 = obj;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\">Obj <span class=\"hljs-title\">obj1</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;asd&quot;</span>)</span></span>;<br>\ttext(obj1);<br>\tobj1.Show();<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>我们作一个图示：</p>\n<p><img src=\"/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/Git\\Blog\\source_posts\\【C++】C++高级\\Snipaste_2019-10-01_16-21-15.png\"></p>\n<p>​    我们没有自定义Obj类的拷贝构造函数，所以当代码执行到<code>Obj obj2 = obj1;</code>时，编译器将调用默认的拷贝构造函数，然而，<font color=\"red\"> 编译器默认的拷贝构造函数是一个浅拷贝</font>，所以新创建的对象obj2没有自己的堆区空间，obj2.p指向的是obj1.p所指向的内存地址。</p>\n<p>​    上面的代码编译是通不过的，<font color=\"red\"> 原因在于，对象析构时，同一个内存地址<code>0x0001</code>被对象obj1和obj2一起析构了两次</font>。当代码执行完<code>test(obj1)</code>时，对象obj2被析构，指针obj2.p所指向的内存地址<code>0x0001</code>被释放，所以当代码执行到<code>obj1.Show()</code>时，使用了已经被释放掉的内存<code>0x0001</code>地址，从而导致运行错误。</p>\n<p>​    <font color=\"green\"> <strong>这里我有一个疑问，既然浅拷贝在拷贝有指针的对象时，会出现两次析构而出错，所以浅拷贝只能拷贝没有指针成员的对象，那么浅拷贝和深拷贝似乎没有什么区别了，那么浅拷贝存在的意义是什么呢？</strong></font></p>\n<h3 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h3><p>C++没有提供给开发者预定义的深拷贝方法，所以要想使用深拷贝，我们需要字写一个拷贝构造函数。</p>\n<p>深拷贝可以解决上面遇到的浅拷贝的问题，因为，<font color=\"red\"> 深拷贝会申请一新的内存空间用于存放拷贝过来的内容，即深拷贝拷贝对象的所有成员，包括指针所指向的内存空间也会一起被拷贝，被拷贝过来的指针会指向一个新的内存地址</font>。</p>\n<p><img src=\"/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/Snipaste_2019-10-01_16-52-53.png\"></p>\n<h3 id=\"定义深拷贝构造函数\"><a href=\"#定义深拷贝构造函数\" class=\"headerlink\" title=\"定义深拷贝构造函数\"></a>定义深拷贝构造函数</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//代码1.2</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Obj</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\tObj(<span class=\"hljs-keyword\">char</span> *tp)<br>\t&#123;<br>\t\tlen = <span class=\"hljs-built_in\">strlen</span>(tp);<br>\t\tp = (<span class=\"hljs-keyword\">char</span>*)<span class=\"hljs-built_in\">malloc</span>(len + <span class=\"hljs-number\">1</span>);<br>\t\tstrcpy_s(p, len+<span class=\"hljs-number\">1</span>, tp);<br>\t&#125;<br>    <span class=\"hljs-comment\">//------------------------------</span><br>    <span class=\"hljs-comment\">//拷贝构造函数--深拷贝</span><br>\tObj(<span class=\"hljs-keyword\">const</span> Obj &amp;obj)<br>\t&#123;<br>\t\tlen = obj.len;<br>\t\tp = (<span class=\"hljs-keyword\">char</span>*)<span class=\"hljs-built_in\">malloc</span>(len + <span class=\"hljs-number\">1</span>);<br>\t\tstrcpy_s(p, len + <span class=\"hljs-number\">1</span>, obj.p);<br>\t&#125;<br>    <span class=\"hljs-comment\">//------------------------------</span><br>\t~Obj()<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (p != <span class=\"hljs-literal\">NULL</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">free</span>(p);<br>\t\t\tp = <span class=\"hljs-literal\">NULL</span>;<br>\t\t\tlen = <span class=\"hljs-number\">0</span>;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Show</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; *p &lt;&lt; *(p + <span class=\"hljs-number\">1</span>) &lt;&lt; *(p + <span class=\"hljs-number\">2</span>) &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-keyword\">char</span> *p;<br>\t<span class=\"hljs-keyword\">int</span> len;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>当一个类中定义了拷贝构造函数，则在对象拷贝时，编译器就不会在调用默认的拷贝构造函数转而调用自定义的拷贝构造函数，当我们把代码1.1中类的定义改为代码1.2中类的定义后，程序就可以正常执行了。</p>\n<p><font color=\"red\">使用深拷贝时，我们还需要注意下面的情况：</font></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">Obj <span class=\"hljs-title\">obj1</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;asd&quot;</span>)</span></span>;<br><span class=\"hljs-function\">Obj <span class=\"hljs-title\">obj3</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;fgh&quot;</span>)</span></span>;<br>obj3 = obj1;<br></code></pre></td></tr></table></figure>\n<p>此时，在<code>obj3=obj1;</code>处依旧调用默认的拷贝构造函数，这里我们要弄清楚<code>obj3=obj1</code>和<code>Obj obj3 = obj1</code>之间的区别，<code>obj3=obj1</code>是将<font color=\"red\">obj1赋值给obj3</font>，<code>=</code>赋值与拷贝构造函数没有什么关联，<code>=</code>在赋值时是C++编译器自己调用默认的拷贝构造函数—浅拷贝，和类中有无定义深拷贝无关；而<code>Obj obj3=obj1</code>则是<font color=\"red\">使用obj1来构造obj3</font>，此时如果类中定义了深拷贝构造函数，就会使用深拷贝。要解决这个问题，就需要显示重载<code>=</code>运算符了。</p>\n<h3 id=\"小知识\"><a href=\"#小知识\" class=\"headerlink\" title=\"小知识\"></a><font color=\"blue\"><strong>小知识</strong></font></h3><ul>\n<li><font color=\"blue\">在定义拷贝构造函数时，必须使用引用传递，否则会出现无限拷贝的情况，因为，如果我们使用传值传递的话，在传递对象到拷贝构造函数时，又会调用拷贝构造函数将实参拷贝给形参，而这个过程又会将对象传递给拷贝构造函数，从而在此调用拷贝构造函数将实参拷贝给形参，如此无限循环</font></li>\n<li><font color=\"blue\">拷贝构造函数只能有一个参数，且必须是自身类的引用，否则编译器将识别被普通构造函数</font></li>\n</ul>\n<h2 id=\"2-初始化参数列表\"><a href=\"#2-初始化参数列表\" class=\"headerlink\" title=\"2.初始化参数列表\"></a>2.初始化参数列表</h2><h3 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h3><p>我们以下面的代码1.3来说明初始化参数列表</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\tA(<span class=\"hljs-keyword\">int</span> a)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;a = a;<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-keyword\">int</span> a;<br>&#125;;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">B</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span> :<br>\tB(<span class=\"hljs-keyword\">int</span> i)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;i = i;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">int</span> i;<br>\tA a;<br><br>&#125;;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\">B <span class=\"hljs-title\">b</span><span class=\"hljs-params\">(<span class=\"hljs-number\">1</span>)</span></span>;<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>运行结果：</strong></p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dns\">错误\tC2512\t“<span class=\"hljs-keyword\">A</span>”: 没有合适的默认构造函数可用<br></code></pre></td></tr></table></figure>\n<p>​    这个问题就在于，在类B中组合了一个A类的成员，编译器在构造B类对象时，同时会构造一个A类对象作为B类的成员，然而，因为A类自定义了一个有参的构造函数，所以在构造A类时，编译器不会使用默认构造函数，而是使用自定义的有参构造函数，问题就出在这里，编译器在构造A类时，没有参数传递到A类的有参构造函数中。初始化参数列表就是用于解决这种问题的。</p>\n<p>​    需要说明的是，如果A类中没有自定义有参的构造函数，则在B类构造对象时编译器自动调用A类的默认构造函数构造A类对象成员，就不会报错。</p>\n<p>​    初始化参数列表可以让我们在构造B类对象时，根据参数列表来构造不同的A类成员。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>初始化参数列表的使用如下面的<code>B(int i):a1(1),a2(2,&quot;asd&quot;)</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\tA(<span class=\"hljs-keyword\">int</span> a)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;a = a;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;构造小A&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>\tA(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-built_in\">string</span> str)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;a = a;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;str = str;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;构造大A&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>\t~A()<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;析构A&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">int</span> a;<br>\t<span class=\"hljs-built_in\">string</span> str;<br>&#125;;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">B</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span> :<br>\tB(<span class=\"hljs-keyword\">int</span> i):a1(<span class=\"hljs-number\">1</span>),a2(<span class=\"hljs-number\">2</span>,<span class=\"hljs-string\">&quot;asd&quot;</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;i = i;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;构造B&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>\t~B()<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;析构B&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">int</span> i;<br>\tA a1;<br>\tA a2;<br>&#125;;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\">B <span class=\"hljs-title\">b</span><span class=\"hljs-params\">(<span class=\"hljs-number\">1</span>)</span></span>;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; b.a1.str &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; b.a2.str &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\ttest();<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dns\">构造小<span class=\"hljs-keyword\">A</span><br>构造大<span class=\"hljs-keyword\">A</span><br>构造B<br><br>asd<br>析构B<br>析构<span class=\"hljs-keyword\">A</span><br>析构<span class=\"hljs-keyword\">A</span><br></code></pre></td></tr></table></figure>\n<p>​    值得注意的是<font color=\"red\"> A类对象的构造顺序不是由初始化参数列表的顺序决定的，而是由对象的申明的前后顺序决定的</font>，如：<code>B(int i):a1(1),a2(2,&quot;asd&quot;)</code>和<code>B(int i):a2(2,&quot;asd&quot;),a1(1)</code>的构造顺序是一样的，但是当我们将类B中组合的A类对象的申明顺序改为如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">B</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span> :<br>\tB(<span class=\"hljs-keyword\">int</span> i):a1(<span class=\"hljs-number\">1</span>),a2(<span class=\"hljs-number\">2</span>,<span class=\"hljs-string\">&quot;asd&quot;</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;i = i;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;构造B&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>\t~B()<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;析构B&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">int</span> i;<br>\tA a2;<br>\tA a1;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>则构造顺序就变为“先构造a2再构造a1”了。</p>\n<p><font color=\"red\"> 析构的顺序和构造的顺序相反。</font></p>\n<h3 id=\"小知识-1\"><a href=\"#小知识-1\" class=\"headerlink\" title=\" 小知识\"></a><font color=\"blue\"> 小知识</font></h3><ul>\n<li><font color=\"blue\"> 当一个类中组合了其他的类对象作为成员时，拷贝构造函数也必须使用初始化参数列表，来构造对象成员然后拷贝</font></li>\n</ul>\n<h2 id=\"3-匿名对象的生命周期\"><a href=\"#3-匿名对象的生命周期\" class=\"headerlink\" title=\"3.匿名对象的生命周期\"></a>3.匿名对象的生命周期</h2><h3 id=\"什么是匿名对象\"><a href=\"#什么是匿名对象\" class=\"headerlink\" title=\"什么是匿名对象\"></a>什么是匿名对象</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">calss A<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-keyword\">int</span> a;<br>\tA(<span class=\"hljs-keyword\">int</span> a)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;a = a;<br>\t&#125;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    A(<span class=\"hljs-number\">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>上面的语句<code>A(1)</code>创建的就是一个匿名临时的对象，<font color=\"red\"> 需要注意，如果一个类只有无参的构造函数，那么这个类将无法构建匿名对象</font>，匿名对象的生命周期就只在创建匿名对象的这条语句内，如果我们不使用一个对象来接收这个匿名对象，那么匿名对象会在语句结束时被销毁，当我们使用<code>A a = A(1);</code>不会出现匿名对象拷贝到类B对象b的情况，这种语句已经被C++优化成了类B的构造语句。说这么多其实匿名对象没什么卵用。</p>\n<h2 id=\"4-new和delete\"><a href=\"#4-new和delete\" class=\"headerlink\" title=\"4.new和delete\"></a>4.new和delete</h2><p>1.new和delete的用法</p>\n<p><code>new</code>可以为<strong>基础类型</strong>、<strong>数组</strong>、<strong>类</strong>分配内存空间，<code>new</code>分配的内存空间都分配在<strong>堆</strong>上。随意<code>new</code>出来的内存空间必须使用一个指针来指向，不能使用同类型的变量来接收，也禁止不接受。</p>\n<p><strong>new 基础类型</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">int</span> *p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>;<br><span class=\"hljs-keyword\">delete</span> p;<br></code></pre></td></tr></table></figure>\n<p><strong>new 数组</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">int</span> *p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[<span class=\"hljs-number\">10</span>];<br><span class=\"hljs-keyword\">delete</span>[] p;<br></code></pre></td></tr></table></figure>\n<p><strong>new 类</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//C++</span><br>A *p = <span class=\"hljs-keyword\">new</span> A();<br><span class=\"hljs-keyword\">delete</span> p;<br><span class=\"hljs-comment\">//C</span><br>A *pc = (A*)<span class=\"hljs-built_in\">malloc</span>(A);<br><span class=\"hljs-built_in\">free</span>(pc);<br></code></pre></td></tr></table></figure>\n<h3 id=\"new-delete和malloc-free的区别\"><a href=\"#new-delete和malloc-free的区别\" class=\"headerlink\" title=\"new delete和malloc free的区别\"></a><code>new delete</code>和<code>malloc free</code>的区别</h3><ul>\n<li><p>在基础类型和基础类型数组方面<code>new delete</code>和<code>malloc free</code>几乎没有什么区别</p>\n</li>\n<li><p><code>new</code>不仅会分配内存还会调用构造函数，而<code>malloc</code>只会分配内存</p>\n</li>\n<li><p><code>delete</code>会调用析构函数来销毁对象，而<code>free</code>只是单纯的释放内存</p>\n</li>\n</ul>\n<h3 id=\"小知识-2\"><a href=\"#小知识-2\" class=\"headerlink\" title=\" 小知识\"></a><font color=\"blue\"> <strong>小知识</strong></font></h3><p><font color=\"blue\"> <code>new delete</code>和<code>malloc free</code>是可以穿插使用的，即<code>new</code>可以和<code>free</code>搭配使用，<code>malloc</code>可以和<code>delete</code>搭配使用。</font></p>\n<h1 id=\"二、继承\"><a href=\"#二、继承\" class=\"headerlink\" title=\"二、继承\"></a>二、继承</h1><p>继承这边主要分析一下<code>虚继承</code></p>\n<h2 id=\"1-虚继承\"><a href=\"#1-虚继承\" class=\"headerlink\" title=\"1.虚继承\"></a>1.虚继承</h2><p>虚继承的出现主要是为解决如下的继承关系中的二义性问题</p>\n<p><img src=\"/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/Snipaste_2019-10-02_15-50-39.png\" alt=\"图1\"></p>\n<p>当我们的类的继承过程中出现这种继承关系时，我们需要使类B和类C分别虚继承类A来解决二义性，具体操作如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span></span><br><span class=\"hljs-class\">&#123;</span><br>   <span class=\"hljs-keyword\">public</span>:<br>    \t<span class=\"hljs-keyword\">int</span> a;<br>&#125;;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">B</span> :</span> <span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">public</span> A<br>&#123;<br>\t<span class=\"hljs-keyword\">public</span>:<br>\t\t<span class=\"hljs-keyword\">int</span> b;<br>&#125;;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">C</span> :</span> <span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">public</span> A<br>&#123;<br>\t<span class=\"hljs-keyword\">public</span>:<br>\t\t<span class=\"hljs-keyword\">int</span> c;<br>&#125;;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">D</span> :</span> <span class=\"hljs-keyword\">public</span> B,C<br>&#123;<br>\t<span class=\"hljs-keyword\">public</span>:<br>\t\t<span class=\"hljs-keyword\">int</span> d;<br>&#125;;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    D d;<br>    d.a = <span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这里有一点要注意，虚继承的应用场景有限，虚继承只能解决这种情况：</p>\n<p><img src=\"/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/Snipaste_2019-10-02_15-50-39.png\"></p>\n<p>而不能解决这种情况：</p>\n<p><img src=\"/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/Snipaste_2019-10-02_16-10-55.png\"></p>\n<h2 id=\"2-继承中的static关键字\"><a href=\"#2-继承中的static关键字\" class=\"headerlink\" title=\"2.继承中的static关键字\"></a>2.继承中的static关键字</h2><p><font color=\"red\"> 类中的静态成员变量被类的所有对象共享，同时也被类的派生类的所有对象共享。</font></p>\n<h1 id=\"三、多态\"><a href=\"#三、多态\" class=\"headerlink\" title=\"三、多态\"></a>三、多态</h1><p>​    在C++的几个特性中，封装、继承和抽象都相对好理解，而多态则不太好理解，这里就说说C++的多态。</p>\n<h2 id=\"1-多态分两种：\"><a href=\"#1-多态分两种：\" class=\"headerlink\" title=\"1.多态分两种：\"></a>1.多态分两种：</h2><p>​    静态多态：静态多态指的就是函数重载和运算符重载。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Animal</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">string</span> name = <span class=\"hljs-string\">&quot;动物&quot;</span>;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">speak</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; name &lt;&lt; <span class=\"hljs-string\">&quot;在叫&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Dog</span> :</span> <span class=\"hljs-keyword\">public</span> Animal<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">string</span> name = <span class=\"hljs-string\">&quot;狗&quot;</span>;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">speak</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; name &lt;&lt; <span class=\"hljs-string\">&quot;在叫&quot;</span> &lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-built_in\">string</span> <span class=\"hljs-keyword\">operator</span>+(Animal animal,Dog dog)<br>&#123;<br>\t<span class=\"hljs-keyword\">return</span> animal.name + <span class=\"hljs-string\">&quot;是&quot;</span> + dog.name + <span class=\"hljs-string\">&quot;的父类&quot;</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Run</span><span class=\"hljs-params\">(Animal animal)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; animal.name &lt;&lt;<span class=\"hljs-string\">&quot;在跑&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Run</span><span class=\"hljs-params\">(Dog dog)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; dog.name &lt;&lt; <span class=\"hljs-string\">&quot;在跑&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tAnimal animal;<br>\tDog dog;<br>\tRun(animal);<br>\tRun(dog);<br>\t<span class=\"hljs-built_in\">cout</span>&lt;&lt;animal+dog&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>​    动态多态：动态多态则是通过继承和虚函数实现标签相同的函数因为传入不同的对象来实现不同的功能。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Animal</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">string</span> name = <span class=\"hljs-string\">&quot;动物&quot;</span>;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">speak</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; name &lt;&lt; <span class=\"hljs-string\">&quot;在叫&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Dog</span> :</span> <span class=\"hljs-keyword\">public</span> Animal<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">string</span> name = <span class=\"hljs-string\">&quot;狗&quot;</span>;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">speak</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; name &lt;&lt; <span class=\"hljs-string\">&quot;在叫&quot;</span> &lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Speak</span><span class=\"hljs-params\">(Animal *animal)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tanimal-&gt;speak();<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tAnimal animal;<br>\tDog dog;<br>\tSpeak(&amp;animal);<br>\tSpeak(&amp;dog);<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>​    动态多态中只能用父类对象的指针或引用来指向子类或自身对象。</p>\n<h2 id=\"2-多态的实现原理\"><a href=\"#2-多态的实现原理\" class=\"headerlink\" title=\"2.多态的实现原理\"></a>2.多态的实现原理</h2><p>​    C++多态的实现依赖于类的虚函数表，当一个类中定义了虚函数，那么这个类就拥有的了一个记录这个虚函数入口地址的虚函数表，子类继承父类时也会继承父类的虚函数表，当子类重写父类的虚函数时，则子类的虚函数入口地址将覆盖父类的地址，如此当子类对象调用此函数时则从子类的虚函数表中寻找入口地址，当父类的对象调用此函数时则从父类的虚函数表中寻找入口地址。</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gcode\">当类创建虚函数时，编译器会在类中生成一个虚函数表<br>虚函数表是一个存储类成员函数指针的数据结构<br>虚函数表有编译器自动生成和维护<br>虚成员函数会被编译器放入虚函数表中<br>存在虚函数时，每一个对象中都会拥有一个指向虚函数表的虚函数表指针<span class=\"hljs-comment\">(vptr)</span><br></code></pre></td></tr></table></figure>\n<p>简单来说，多态实现的条件有三：</p>\n<ul>\n<li><p>要有继承</p>\n</li>\n<li><p>要有虚函数重写</p>\n</li>\n<li><p>要有父类指针(或引用)指向子类对象</p>\n</li>\n</ul>\n<h2 id=\"3-纯虚函数和抽象类\"><a href=\"#3-纯虚函数和抽象类\" class=\"headerlink\" title=\"3.纯虚函数和抽象类\"></a>3.纯虚函数和抽象类</h2><p>​    纯虚函数的定义：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">speak</span><span class=\"hljs-params\">()</span> </span>= <span class=\"hljs-number\">0</span><br></code></pre></td></tr></table></figure>\n<p>​    定义了纯虚函数的类就被成为抽象类，C++引入纯虚函数和抽象类的概念就是为了更好的使用多态，抽象类不能实例化对象，这个特性就规范了继承这个抽象类的子类必须重写父类的虚函数，因为如果继承了抽象类的子类不重写父类的虚函数，那么子类也是一个抽象类，子类便也不能实例化对象，如此便规范了多态实现，防止当子类很多时，出现某个子类在编写时忘记重写父类的虚函数，而导致这个子类没有实现多态。</p>\n<h2 id=\"4-虚析构函数和纯虚析构函数\"><a href=\"#4-虚析构函数和纯虚析构函数\" class=\"headerlink\" title=\"4.虚析构函数和纯虚析构函数\"></a>4.虚析构函数和纯虚析构函数</h2><ul>\n<li>虚析构函数的定义：</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">virtual</span> ~Animal();<br></code></pre></td></tr></table></figure>\n<ul>\n<li>纯虚析构函数的定义：</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">virtual</span> ~Animal() = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-comment\">//纯虚析构函数必须要有申明也要有实现</span><br>Animal：：~Animal()<br>&#123;<br>    <span class=\"hljs-comment\">//代码实现</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>如果子类在堆区中定义了数据，那么我们使用父类指针或引用来使用多态时，父类指针或引用是无法寻找到子类在堆区中的数据并释放的。C++引入虚析构函数和纯虚析构函数就是为了解决此类问题。</p>\n<p>​    我们来看一个例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Animal</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\tAnimal()<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;这是Animal的构造函数&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>\t~Animal()<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;这是Animal的析构函数&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Dog</span> :</span> <span class=\"hljs-keyword\">public</span> Animal<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-keyword\">int</span> *p;<br>\tDog()<br>\t&#123;<br>\t\tp = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;这是Dog的构造函数&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>\t~Dog()<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;这是Dog的析构函数&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t\t<span class=\"hljs-keyword\">if</span> (p != <span class=\"hljs-literal\">NULL</span>)<br>\t\t&#123;\t\t<br>\t\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;释放堆区的p&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t\t\t<span class=\"hljs-keyword\">delete</span> p;<br>\t\t\tp = <span class=\"hljs-literal\">NULL</span>;<br>\t\t&#125;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tAnimal *animal = <span class=\"hljs-keyword\">new</span> Dog();<br>\t<span class=\"hljs-keyword\">delete</span> animal;<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs inform7\">这是<span class=\"hljs-keyword\">Animal</span>的构造函数<br>这是Dog的构造函数<br>这是<span class=\"hljs-keyword\">Animal</span>的析构函数<br></code></pre></td></tr></table></figure>\n<p>可以看到，delete animal后并没有调用Dog的析构函数，释放子类Dog在堆区申请的空间。这样便出现了内存泄漏。</p>\n<p>此时虚析构函数和纯虚析构函数便可以起作用了，我们再看一个例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Animal</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\tAnimal()<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;这是Animal的构造函数&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">virtual</span> ~Animal()<span class=\"hljs-comment\">//把父类的析构函数改为虚析构函数</span><br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;这是Animal的析构函数&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Dog</span> :</span> <span class=\"hljs-keyword\">public</span> Animal<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-keyword\">int</span> *p;<br>\tDog()<br>\t&#123;<br>\t\tp = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;这是Dog的构造函数&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>\t~Dog()<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;这是Dog的析构函数&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t\t<span class=\"hljs-keyword\">if</span> (p != <span class=\"hljs-literal\">NULL</span>)<br>\t\t&#123;\t\t<br>\t\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;释放堆区的p&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t\t\t<span class=\"hljs-keyword\">delete</span> p;<br>\t\t\tp = <span class=\"hljs-literal\">NULL</span>;<br>\t\t&#125;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tAnimal *animal = <span class=\"hljs-keyword\">new</span> Dog();<br>\t<span class=\"hljs-keyword\">delete</span> animal;<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n<p>​    输出结果：</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs inform7\">这是<span class=\"hljs-keyword\">Animal</span>的构造函数<br>这是Dog的构造函数<br>这是Dog的析构函数<br>释放堆区的p<br>这是<span class=\"hljs-keyword\">Animal</span>的析构函数<br></code></pre></td></tr></table></figure>\n<p>​    如此便可以释放子类Dog在堆区申请的空间了，纯虚析构函数和虚析构函数的作用是一样，只是纯虚析构函数有一个和纯虚函数一样的特性，即定义了纯虚析构函数的类也属于抽象类，纯虚析构函数必须实现，如果不实现所有继承了拥有纯虚析构函数的抽象类的派生类都属于抽象类。需要注意的是，因为纯虚析构函数的特性，纯虚析构函数的实现就必须在类外实现了。</p>\n<h2 id=\"5-重载、重写、重定义\"><a href=\"#5-重载、重写、重定义\" class=\"headerlink\" title=\"5.重载、重写、重定义\"></a>5.重载、重写、重定义</h2><p><strong>重载</strong></p>\n<p>重载发生在一个类的内部，拥有相同函数名，相同返回值而参数列表不同的函数之间互为重载关系。如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span></span><br><span class=\"hljs-class\">&#123;</span><br>\t<span class=\"hljs-keyword\">public</span>:<br>\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">fun</span><span class=\"hljs-params\">()</span></span>&#123;&#125;<br>\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">fun</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a)</span></span>&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p><font color=\"red\"> 只有相同函数名而参数列表不同的函数才是重载，函数名相同参数列表也相同而返回值不同的函数在C++中是不允许的。</font></p>\n<p><strong>重写</strong></p>\n<p>重写发生在基类和派生类之间，基类中定义虚函数(纯虚函数)，派生类中定义和虚函数拥有<strong>相同函数名，相同参数列表和相同返回值</strong>的函数，这种情况下发生函数重写。如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span></span><br><span class=\"hljs-class\">&#123;</span><br>    <span class=\"hljs-keyword\">public</span>:<br>    \t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">fun</span><span class=\"hljs-params\">()</span></span>&#123;&#125;<br>&#125;;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">B</span> :</span> <span class=\"hljs-keyword\">public</span> A<br>&#123;<br>\t<span class=\"hljs-keyword\">public</span>:<br>\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">fun</span><span class=\"hljs-params\">()</span></span>&#123;&#125;<span class=\"hljs-comment\">//重写A类的fun函数</span><br>\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">fun</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a)</span></span>&#123;&#125;<span class=\"hljs-comment\">//重定义一个新函数</span><br>\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">fun</span><span class=\"hljs-params\">()</span></span>&#123;<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;&#125;<span class=\"hljs-comment\">//这种情况C++不允许</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<p><strong>重定义</strong></p>\n<p>重定义也是发生在基类和派生类之间，派生类拥有与基类函数名相同，返回值相同，而参数列表不同的函数，此时发生重定义。如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span></span><br><span class=\"hljs-class\">&#123;</span><br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">fun</span><span class=\"hljs-params\">()</span></span>&#123;&#125;<br>&#125;;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">B</span> :</span> <span class=\"hljs-keyword\">public</span> A<br>&#123;<br>\t<span class=\"hljs-keyword\">public</span>:<br>\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">fun</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a)</span></span>&#123;&#125;<span class=\"hljs-comment\">//发生重定义</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<p><font color=\"red\"> 派生类中可以重定义基类的任何函数，包括虚函数和纯虚函数。</font></p>\n<h2 id=\"6-父类指针和子类指针步长不一致问题\"><a href=\"#6-父类指针和子类指针步长不一致问题\" class=\"headerlink\" title=\"6.父类指针和子类指针步长不一致问题\"></a>6.父类指针和子类指针步长不一致问题</h2><p>问题出现的场景是这样的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-keyword\">int</span> a;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">()</span> </span>&#123;&#125;<br>&#125;;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">B</span> :</span> <span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">public</span> A<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-keyword\">int</span> b;<br>\tB(<span class=\"hljs-keyword\">int</span> b)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;b = b;<br>\t&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; b &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>&#125;;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tA *a = <span class=\"hljs-literal\">NULL</span>;<br>\tB *b = <span class=\"hljs-literal\">NULL</span>;<br>\tB <span class=\"hljs-built_in\">array</span>[<span class=\"hljs-number\">2</span>]&#123; B(<span class=\"hljs-number\">1</span>),B(<span class=\"hljs-number\">2</span>) &#125;;<br>\ta = <span class=\"hljs-built_in\">array</span>;<br>\tb = <span class=\"hljs-built_in\">array</span>;<br>\ta-&gt;print();<br>\tb-&gt;print();<br>\ta++; b++;<br>\ta-&gt;print();<span class=\"hljs-comment\">//这一步会出现异常</span><br>\tb-&gt;print();<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>即父类指针a和子类指针b都指向一个子类对象数组，于是我们可以通过指针++的自增运算来逐步访问数组元素，问题就出在这，使用<code>sizeof()</code>计算两个类的大小分别得出，sizeof(A)=8;sizeof(B)=20;这就导致A类指针a每一次移步时只移动了8个字节，这个距离还远远没有达到下一个元素的首地址，所以访问会出错，这是因为指针每次移步移动的距离是指针类型的空间大小，如：A类大小为8，所以A类指针每移步一次走8个字节。</p>\n<p>可能会有疑问，为什么类B的大小是20？</p>\n<p>我们可以算一算，类B继承至类A所以类A中拥有的成员变量，类B也拥有，占8字节，这8字节分别是int变量4字节和虚函数表指针4字节；类B自身定义了一个int变量占4字节，由于类B重写了类A的虚函数，所以类B也拥有一个自己的虚函数表指针，占4字节；类B虚继承了类A，在这个过程中，C++编译器会给类B增加一个属性，占4字节，于是，<strong>8+4+4+4+4=20</strong>。</p>\n<hr>\n<h1 id=\"四、泛型编程\"><a href=\"#四、泛型编程\" class=\"headerlink\" title=\"四、泛型编程\"></a>四、泛型编程</h1><h2 id=\"1-函数模板\"><a href=\"#1-函数模板\" class=\"headerlink\" title=\"1.函数模板\"></a>1.函数模板</h2><h3 id=\"函数模板的基本语法\"><a href=\"#函数模板的基本语法\" class=\"headerlink\" title=\"函数模板的基本语法\"></a>函数模板的基本语法</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//---------------函数模板</span><br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;<span class=\"hljs-comment\">//告诉编译器我要开始泛型编程了，遇到T不要报错</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Fun</span><span class=\"hljs-params\">(T &amp;a,T &amp;b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tT t = a;<br>\ta = b;<br>\tb = t;<br>&#125;<br><span class=\"hljs-comment\">//----------------</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">char</span> a = <span class=\"hljs-number\">97</span>,b = <span class=\"hljs-number\">102</span>;<br>\tFun(a, b);<span class=\"hljs-comment\">//自动推导类型调用</span><br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; a &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span> &lt;&lt; b &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t<span class=\"hljs-built_in\">string</span> x = <span class=\"hljs-string\">&quot;xxx&quot;</span>, y = <span class=\"hljs-string\">&quot;yyy&quot;</span>;<br>\tFun&lt;<span class=\"hljs-built_in\">string</span>&gt;(x, y);<span class=\"hljs-comment\">//显示类型调用</span><br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; x &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"当函数模板遇到函数重载\"><a href=\"#当函数模板遇到函数重载\" class=\"headerlink\" title=\"当函数模板遇到函数重载\"></a>当函数模板遇到函数重载</h3><p>当函数模板遇到函数重载准许下面4条原则</p>\n<ul>\n<li>函数模板可以像普通函数一样被重载</li>\n<li>C++编译器优先考虑普通函数</li>\n<li>如果函数模板可以产生一个更好的匹配，那么选择函数模板</li>\n<li>可以通过模板的空实参列表的语法限定编译器只通过函数模板匹配</li>\n</ul>\n<p>我们来看一个例子，逐一分析</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Fun</span><span class=\"hljs-params\">(T a,T b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\ta = a + b;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;我是函数模板&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>&#125;<br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T1,<span class=\"hljs-keyword\">typename</span> T2&gt;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Fun</span><span class=\"hljs-params\">(T1 a,T2 b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tT1 x = a;<br>\tT2 y = b;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;我是函数模板重载&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Fun</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;我是普通函数&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Fun2</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; a &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span> &lt;&lt; b &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tFun(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);<br>\tFun(<span class=\"hljs-number\">0.1</span>, <span class=\"hljs-number\">0.2</span>);<br>\tFun(<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-number\">1</span>);<br>\tFun&lt;&gt;(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);<br>\tFun2(<span class=\"hljs-number\">0.1</span>, <span class=\"hljs-number\">0.2</span>);<br>\tFun2(<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">3</span>);<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">我是普通函数<br>我是函数模板<br>我是函数模板重载<br>我是函数模板<br>0,0<br>97,3<br></code></pre></td></tr></table></figure>\n<p><strong>分析：</strong></p>\n<ul>\n<li><code>Fun(1,2)</code>:有完全匹配的普通函数，所以调用<code>void Fun(int a, int b)</code></li>\n<li><code>Fun(0.1,0.2)</code>:虽然普通函数<code>void Fun(int a, int b)</code>可以像<code>void Fun2(int a, int b)</code>一样进行隐式类型转换调用，倒是<code>Fun()</code>函数有更好的重载函数<code>void Fun(T1 a,T2 b)</code>模板匹配所以编译器优先调用<code>void Fun(T1 a,T2 b)</code></li>\n<li><code>Fun(&#39;c&#39;,1)</code>:编译器能找到匹配的函数模板重载<code>void Fun(T1 a,T2 b)</code>所以优先调用函数模板</li>\n<li><code>Fun&lt;&gt;(1,2)</code>:使用了空参数列表，告诉编译器只匹配函数模板，即使代码段中有能完美匹配的普通函数，也只调用函数模板</li>\n</ul>\n<h2 id=\"2-类模板\"><a href=\"#2-类模板\" class=\"headerlink\" title=\"2.类模板\"></a>2.类模板</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;<span class=\"hljs-comment\">//定义</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TemplateA</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\tTemplateA(T a)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;a = a;<br>\t&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">PrintA</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\tT a;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Test</span><span class=\"hljs-params\">(TemplateA&lt;<span class=\"hljs-keyword\">int</span>&gt; &amp;a)</span><span class=\"hljs-comment\">//类模板作形参</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\ta.PrintA();<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\">TemplateA&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">a</span><span class=\"hljs-params\">(<span class=\"hljs-number\">1</span>)</span></span>;<span class=\"hljs-comment\">//使用</span><br>\t<span class=\"hljs-function\">TemplateA&lt;<span class=\"hljs-built_in\">string</span>&gt; <span class=\"hljs-title\">b</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;str&quot;</span>)</span></span>;<br>\t<span class=\"hljs-function\">TemplateA&lt;<span class=\"hljs-keyword\">bool</span>&gt; <span class=\"hljs-title\">c</span><span class=\"hljs-params\">(<span class=\"hljs-literal\">true</span>)</span></span>;<br>\tTest(a);<br>\tb.PrintA();<br>\tc.PrintA();<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight avrasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs avrasm\"><span class=\"hljs-symbol\">a:</span><span class=\"hljs-number\">1</span><br><span class=\"hljs-symbol\">a:</span>str<br><span class=\"hljs-symbol\">a:</span><span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n<p>类模板的定义和函数模板的定义类似</p>\n<h3 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>类模板的使用必须显示的确定模板的类型参数，如：<code>TemplateA&lt;string&gt; b(&quot;str&quot;)</code></p>\n<h3 id=\"类模板作参数\"><a href=\"#类模板作参数\" class=\"headerlink\" title=\"类模板作参数\"></a>类模板作参数</h3><p>类模板作参数也必须显示的确定模板那的类型参数，如：</p>\n<p><code>void Test(TemplateA&lt;int&gt; &amp;a)</code>以便编译器为形参确定内存空间。</p>\n<h3 id=\"类模板派生普通类\"><a href=\"#类模板派生普通类\" class=\"headerlink\" title=\"类模板派生普通类\"></a>类模板派生普通类</h3><p>类模板也可以被继承，但是在继承时需要显示确定模板的类型参数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TemplateA</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\tTemplateA(T a)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;a = a;<br>\t&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">PrintA</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\tT a;<br>&#125;;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">B</span> :</span> <span class=\"hljs-keyword\">public</span> TemplateA&lt;<span class=\"hljs-keyword\">int</span>&gt;<span class=\"hljs-comment\">//类模板派生普通类</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\tB(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> b) :TemplateA(a)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;b = b;<br>\t&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">PrintB</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;b:&quot;</span> &lt;&lt; b &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-keyword\">int</span> b;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\">B <span class=\"hljs-title\">b</span><span class=\"hljs-params\">(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>)</span></span>;<br>\tb.PrintA();<br>\tb.PrintB();<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"模板类派生模板类\"><a href=\"#模板类派生模板类\" class=\"headerlink\" title=\"模板类派生模板类\"></a>模板类派生模板类</h3><p>模板类不仅可以派生普通类，还可以派生模板类</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TemplateA</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\tTemplateA(T a)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;a = a;<br>\t&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">PrintA</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\tT a;<br>&#125;;<br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T1,<span class=\"hljs-keyword\">typename</span> T2&gt;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TemplateB</span> :</span> <span class=\"hljs-keyword\">public</span> TemplateA&lt;T2&gt;<span class=\"hljs-comment\">//类模板派生类模板</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\tTemplateB(T2 a, T1 b) :TemplateA(a)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;b = b;<br>\t&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">PrintB</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;b:&quot;</span> &lt;&lt; b &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\tT1 b;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tTemplateB&lt;string,char&gt; b(&#x27;A&#x27;, &quot;TemplateB&quot;);<br>\tb.PrintA();<br>\tb.PrintB();<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight avrasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs avrasm\"><span class=\"hljs-symbol\">a:</span>A<br><span class=\"hljs-symbol\">b:</span>TemplateB<br></code></pre></td></tr></table></figure>\n<h3 id=\"类模板的主要作用\"><a href=\"#类模板的主要作用\" class=\"headerlink\" title=\"类模板的主要作用\"></a>类模板的主要作用</h3><p>类模板的主要作用就是将数据结构的表示和算法不受包含的元素类型的影响，即类模板将元素类型和数据结构算法分离开来了，使数据结构和算法成为真正意义上的数据结构和算法，如：链表不再因为<code>int</code>类型而定义一个<code>int</code>类型的链表，因<code>string</code>类型而定义一个<code>string</code>类型的链表，而是定义一个链表可以通用于所有类型。</p>\n<h1 id=\"五、异常处理\"><a href=\"#五、异常处理\" class=\"headerlink\" title=\"五、异常处理\"></a>五、异常处理</h1><h2 id=\"1-异常的基本语法\"><a href=\"#1-异常的基本语法\" class=\"headerlink\" title=\"1.异常的基本语法\"></a>1.异常的基本语法</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Try</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x, <span class=\"hljs-keyword\">int</span> y)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">if</span> (y == <span class=\"hljs-number\">0</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;除数不能等于0，抛出异常&quot;</span>&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br>\t\t<span class=\"hljs-keyword\">throw</span> y;<span class=\"hljs-comment\">//这里必须指明抛出异常的数据类型，否则程序无法处理异常，只能使用这个类型的变量，x和y的效果是一样的，不能直接抛出int，即这样是不行的throw int</span><br>\t&#125;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;x/y=&quot;</span> &lt;&lt; x / y &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Test1</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tTry(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);<br>\tTry(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">0</span>);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Test2</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">try</span><br>\t&#123;<br>\t\tTest1();<br>\t&#125;<br>\t<span class=\"hljs-keyword\">catch</span> (<span class=\"hljs-keyword\">char</span> e)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;处理char异常&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">catch</span>(...)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;无法处理的异常继续往上抛&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t\t<span class=\"hljs-keyword\">throw</span>;<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">try</span><br>\t&#123;<br>\t\tTest2();<br>\t&#125;<br>\t<span class=\"hljs-keyword\">catch</span>(<span class=\"hljs-keyword\">int</span> e)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;处理int异常&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">catch</span> (...)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;处理其他异常&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight gml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gml\"><span class=\"hljs-symbol\">x</span>/<span class=\"hljs-symbol\">y</span>=<span class=\"hljs-number\">0</span><br>除数不能等于<span class=\"hljs-number\">0</span>，抛出异常<br>无法处理的异常继续往上抛<br>处理int异常<br></code></pre></td></tr></table></figure>\n<ul>\n<li>异常的抛出是可以跨函数的，如上面的代码，在<code>Try</code>函数里抛出的异常可以在<code>mian</code>函数中处理，中间跨过了<code>Test1</code>，<code>Test2</code>两个函数</li>\n<li>如果在一个函数内捕捉到异常但是却无法处理可以通过<code>throw</code>继续向上抛，直至main函数，如上面代码，<code>Test2</code>捕捉到异常但是没有处理继续向上抛给了main函数，如果main函数还是没有处理，则会直接中断程序</li>\n<li>C++使用<code>cacth(...)</code>来捕捉其他没有捕捉到的异常，如上面代码，main函数中只捕捉了int类型的异常，如果出现其他类型的异常则有<code>cacth(...)</code>来捕捉</li>\n<li>异常处理是按照类型匹配来处理的，即<code>throw</code>的int类型的异常只有<code>cacth(int e)</code>能够接收得到，否则就只能使用<code>cacth(...)</code>来接收未知异常</li>\n</ul>\n<h2 id=\"2-C-异常处理的特性\"><a href=\"#2-C-异常处理的特性\" class=\"headerlink\" title=\"2.C++异常处理的特性\"></a>2.C++异常处理的特性</h2><p>​    C++的异常处理具有跨函数性，这使得<font color=\"red\"> 异常引发</font>和<font color=\"red\"> 异常处理</font>分离开来，这样下层函数可以不用过多的在一异常处理，而把重点放在问题的逻辑处理上，异常处理可以由上层调用者专门来处理。</p>\n<h2 id=\"3-异常接口申明\"><a href=\"#3-异常接口申明\" class=\"headerlink\" title=\"3.异常接口申明\"></a>3.异常接口申明</h2><p><strong>不抛出任何异常：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Try</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x, <span class=\"hljs-keyword\">int</span> y)</span> <span class=\"hljs-title\">throw</span><span class=\"hljs-params\">()</span><span class=\"hljs-comment\">//异常接口申明</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">if</span> (y == <span class=\"hljs-number\">0</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;除数不能等于0，抛出异常&quot;</span>&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br>\t\t<span class=\"hljs-keyword\">throw</span> x;<br>\t&#125;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;x/y=&quot;</span> &lt;&lt; x / y &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>只能抛出列表中类型的异常：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Try</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x, <span class=\"hljs-keyword\">int</span> y)</span> <span class=\"hljs-title\">throw</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">char</span>,<span class=\"hljs-keyword\">int</span>*)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">if</span> (y == <span class=\"hljs-number\">0</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;除数不能等于0，抛出异常&quot;</span>&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br>\t\t<span class=\"hljs-keyword\">throw</span> x;<br>\t&#125;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;x/y=&quot;</span> &lt;&lt; x / y &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>可以抛出任何异常：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Try</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x, <span class=\"hljs-keyword\">int</span> y)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">if</span> (y == <span class=\"hljs-number\">0</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;除数不能等于0，抛出异常&quot;</span>&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br>\t\t<span class=\"hljs-keyword\">throw</span> x;<br>\t&#125;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;x/y=&quot;</span> &lt;&lt; x / y &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>不过经过测试，三份代码无论是否写throw都是可以抛出并处理异常的，似乎这个语法没什么卵用，可能C++11摒弃了这种用法，但是考虑到兼容保留这个语法。</p>\n<h2 id=\"4-异常接收的3种方式\"><a href=\"#4-异常接收的3种方式\" class=\"headerlink\" title=\"4.异常接收的3种方式\"></a>4.异常接收的3种方式</h2><h3 id=\"普通形参\"><a href=\"#普通形参\" class=\"headerlink\" title=\"普通形参\"></a>普通形参</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\tA() &#123; <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;构造A&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>; &#125;<br>\tA(<span class=\"hljs-keyword\">const</span> A &amp;a) &#123; <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;拷贝A&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>; &#125;<br>\t~A() &#123; <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;析构A&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>; &#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Try</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tA a;<br>\t<span class=\"hljs-keyword\">throw</span> a;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">try</span><br>\t&#123;<br>\t\tTry();<br>\t&#125;<br>\t<span class=\"hljs-keyword\">catch</span>(A e)<span class=\"hljs-comment\">//使用普通形参</span><br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;处理int异常&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dns\">构造<span class=\"hljs-keyword\">A</span><br>拷贝<span class=\"hljs-keyword\">A</span><br>拷贝<span class=\"hljs-keyword\">A</span><br>析构<span class=\"hljs-keyword\">A</span><br>处理int异常<br>析构<span class=\"hljs-keyword\">A</span><br>析构<span class=\"hljs-keyword\">A</span><br></code></pre></td></tr></table></figure>\n<p>可以看到a被拷贝两次，第一次从<code>A a</code>拷贝到<code>throw a</code>，第二次从<code>throw a</code>拷贝到<code>catch(A e)</code>，可以看出如果使用普通形参来接收异常，异常变量会由异常抛出处拷贝到异常接收处。</p>\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><p>将上面代码的<code>catch(A e)</code>改为<code>catch(A &amp;e)</code></p>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dns\">构造<span class=\"hljs-keyword\">A</span><br>拷贝<span class=\"hljs-keyword\">A</span><br>析构<span class=\"hljs-keyword\">A</span><br>处理int异常<br>析构<span class=\"hljs-keyword\">A</span><br></code></pre></td></tr></table></figure>\n<p>可以看到只拷贝了一次，即从<code>A a</code>拷贝到<code>throw a</code>。</p>\n<h3 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h3><p>上面代码应该修改为如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\tA() &#123; <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;构造A&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>; &#125;<br>\tA(<span class=\"hljs-keyword\">const</span> A &amp;a) &#123; <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;拷贝A&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>; &#125;<br>\t~A() &#123; <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;析构A&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>; &#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Try</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tA *a = <span class=\"hljs-keyword\">new</span> A();<span class=\"hljs-comment\">//对象必须创建在堆区，函数结束对象就会被销毁，而无法通过指针传递到catch中</span><br>\t<span class=\"hljs-keyword\">throw</span> a;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">try</span><br>\t&#123;<br>\t\tTry();<br>\t&#125;<br>\t<span class=\"hljs-keyword\">catch</span>(A *e)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;处理int异常&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t\t<span class=\"hljs-keyword\">delete</span> e;<span class=\"hljs-comment\">//需要手动释放堆区的内存</span><br>\t&#125;<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dns\">构造<span class=\"hljs-keyword\">A</span><br>处理int异常<br>析构<span class=\"hljs-keyword\">A</span><br></code></pre></td></tr></table></figure>\n<p>可以看到使用指针完全不需要拷贝，但是却需要消耗堆区的内存且容易造成内存泄露。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>总的来说，最优的方式还是使用引用。</p>\n<h2 id=\"5-继承在异常处理中的应用\"><a href=\"#5-继承在异常处理中的应用\" class=\"headerlink\" title=\"5.继承在异常处理中的应用\"></a>5.继承在异常处理中的应用</h2><p>在实际的项目中我们处理的异常并不是一些基础的数据类型，大多都是开发者的自定义类，这种情况在捕捉异常的时候就相当麻烦，尽管有些异常处理起来程序基本一致，但是却要将每一种异常一一捕捉并一一处理，下面的代码我们来模拟一下这种情况。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span>//<span class=\"hljs-title\">A</span>类实现输入一个范围在0-10的奇数</span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\tA(<span class=\"hljs-keyword\">int</span> a) <br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (a % <span class=\"hljs-number\">2</span> != <span class=\"hljs-number\">0</span>) &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (a &lt; <span class=\"hljs-number\">0</span>)<span class=\"hljs-keyword\">throw</span> LtZero();<br>\t\t\t<span class=\"hljs-keyword\">if</span> (a &gt; <span class=\"hljs-number\">10</span>)<span class=\"hljs-keyword\">throw</span> GtTen();<br>\t\t\t<span class=\"hljs-keyword\">else</span> num = a;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">throw</span> Even();<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-keyword\">int</span> num;<br>&#125;;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LtZero</span>//专门处理异常的异常类</span><br><span class=\"hljs-class\">&#123;</span>&#125;;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GtTen</span></span><br><span class=\"hljs-class\">&#123;</span>&#125;;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Even</span></span><br><span class=\"hljs-class\">&#123;</span>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">try</span> &#123; <span class=\"hljs-function\">A <span class=\"hljs-title\">a</span><span class=\"hljs-params\">(<span class=\"hljs-number\">4</span>)</span></span>; &#125;<br>\t<span class=\"hljs-keyword\">catch</span> (LtZero &amp;lz) &#123; <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;输入的数小于0&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>; &#125;<br>\t<span class=\"hljs-keyword\">catch</span> (GtTen &amp;gt) &#123; <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;输入的数大于10&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>; &#125;<br>\t<span class=\"hljs-keyword\">catch</span> (Even &amp;ev) &#123; <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;输入的数是偶数&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>; &#125;<br>\t<span class=\"hljs-keyword\">catch</span> (...) &#123; <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;其他异常&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>; &#125;<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>可以看到我们的异常处理模块相当繁杂，在实际开发项目中异常的数量远远不止上面模拟的三种，可能多达上百种或则更多，这是异常的处理将变得十分繁杂，那么如何处理呢？</p>\n<p>可能心细的读者会发现，我们在处理异常时使用了专门的异常处理类，而类是可以继承的，于是乎，继承在异常处理中的作用就体现出来了。</p>\n<p>我们再来看一份优化后的代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span>//<span class=\"hljs-title\">A</span>类实现输入一个范围在0-10的奇数</span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\tA(<span class=\"hljs-keyword\">int</span> a) <br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (a % <span class=\"hljs-number\">2</span> != <span class=\"hljs-number\">0</span>) &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (a &lt; <span class=\"hljs-number\">0</span>)<span class=\"hljs-keyword\">throw</span> LtZero();<br>\t\t\t<span class=\"hljs-keyword\">if</span> (a &gt; <span class=\"hljs-number\">10</span>)<span class=\"hljs-keyword\">throw</span> GtTen();<br>\t\t\t<span class=\"hljs-keyword\">else</span> num = a;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">throw</span> Even();<br>\t&#125;<br><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Even</span></span><br><span class=\"hljs-class\">\t&#123;</span><br>\t<span class=\"hljs-keyword\">public</span>:<br>\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">PrintErro</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t\t</span>&#123;<br>\t\t\t<span class=\"hljs-built_in\">cout</span>&lt;&lt; <span class=\"hljs-string\">&quot;输入的数是偶数&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t\t&#125;<br>\t&#125;;<br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LtZero</span>:</span><span class=\"hljs-keyword\">public</span> Even<br>\t&#123;<br>\t<span class=\"hljs-keyword\">public</span>:<br>\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">PrintErro</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t\t</span>&#123;<br>\t\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;输入的数小于0&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t\t&#125;<br>\t&#125;;<br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GtTen</span>:</span><span class=\"hljs-keyword\">public</span> Even<br>\t&#123;<br>\t<span class=\"hljs-keyword\">public</span>:<br>\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">PrintErro</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t\t</span>&#123;<br>\t\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;输入的数大于10&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t\t&#125;<br>\t&#125;;<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-keyword\">int</span> num;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">try</span> &#123; <span class=\"hljs-function\">A <span class=\"hljs-title\">a</span><span class=\"hljs-params\">(<span class=\"hljs-number\">4</span>)</span></span>; &#125;<br>\t<span class=\"hljs-keyword\">catch</span> (A::Even e) &#123; e.PrintErro(); &#125;<br>\t<span class=\"hljs-keyword\">catch</span> (...) &#123; <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;其他异常&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>; &#125;<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>可以看到我们的异常处理模块使用多态，繁杂程度被大幅缩水了，而我们的异常处理被集中在了异常处理类中，有时，如果我们的异常处理只对某一个类有效也是可以直接将异常处理类定义在抛出类里面的。</p>\n<h2 id=\"6-标准异常库\"><a href=\"#6-标准异常库\" class=\"headerlink\" title=\"6.标准异常库\"></a>6.标准异常库</h2><p>C++提供一些标准的异常库，头文件为：#include<stdexcep></stdexcep></p>\n<h1 id=\"六、标准IO流\"><a href=\"#六、标准IO流\" class=\"headerlink\" title=\"六、标准IO流\"></a>六、标准IO流</h1><h2 id=\"1-标准IO流流程\"><a href=\"#1-标准IO流流程\" class=\"headerlink\" title=\"1.标准IO流流程\"></a>1.标准IO流流程</h2><p><img src=\"/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/Snipaste_2019-10-06_10-03-47.png\"></p>\n<h2 id=\"2-标准输入流\"><a href=\"#2-标准输入流\" class=\"headerlink\" title=\"2.标准输入流\"></a>2.标准输入流</h2><table>\n<thead>\n<tr>\n<th>标准函数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>cin</td>\n<td>cin&gt;&gt;操作支持任何基本类型的输入，但是遇到空格则结束读取</td>\n</tr>\n<tr>\n<td>cin.get(char chr)</td>\n<td>从缓冲区中读取一个字符到chr中，因为C++定义的cin.get(char)中会返回一个函数自身的引用，所以此函数支持链式编程，即cin.get(a).get(b).get(c);b表示依次从缓冲区中读取三个字符到a，b，c中</td>\n</tr>\n<tr>\n<td>cin.get(char* buf,int cout)</td>\n<td>从缓冲区中读取cout个字符到buf数组中，因为函数似乎会在数组末尾添加点什么，所以实际读取的字符数量是cout-1个，此函数也支持链式编程</td>\n</tr>\n<tr>\n<td>cin.get(char* buf,int cout,char chr)</td>\n<td>从缓冲区中读取cout个字符到buf数组中，如果碰到字符chr则结束读取</td>\n</tr>\n<tr>\n<td>cin.getline(char buf,int cout)</td>\n<td>从缓冲区中读取cout个字符到buf数组中</td>\n</tr>\n<tr>\n<td>cin.ignore(int num)</td>\n<td>忽略缓冲区当前读取指针开始的num个字符再读取</td>\n</tr>\n<tr>\n<td>cin.peek()</td>\n<td>判断缓冲区中是否有数据，如果有则返回第一个字符，如果没有则阻塞程序</td>\n</tr>\n<tr>\n<td>cin.putback(char chr)</td>\n<td>将读取出来的字符再返存回缓冲区，只能读取一个字符</td>\n</tr>\n</tbody></table>\n<h2 id=\"3-标准输出流\"><a href=\"#3-标准输出流\" class=\"headerlink\" title=\"3.标准输出流\"></a>3.标准输出流</h2><table>\n<thead>\n<tr>\n<th>标准函数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>cout</td>\n<td>输出缓冲区内容，支持任何基本类型数据的输出</td>\n</tr>\n<tr>\n<td>cout.flush(void)</td>\n<td>刷新缓冲区，无视系统繁忙，强制输出缓冲区的字符，语法和cout一样“cout.flush()&lt;&lt;buf&lt;&lt;endl;”</td>\n</tr>\n<tr>\n<td>cout.put(char chr)</td>\n<td>在标准输出设备输出指针的当前位置插入字符chr，语法和cout一致</td>\n</tr>\n<tr>\n<td>cout.write(char *chr,int cout)</td>\n<td>输出*chr所指向空间中cout个数量的字符，即使越界也会继续输出，语法和cout一致</td>\n</tr>\n<tr>\n<td>cout.width(int num)</td>\n<td>输出num个字节宽度的字符，一般配合cout.fill(char chr)和其他cout函数一起使用</td>\n</tr>\n<tr>\n<td>cout.fill(char chr)</td>\n<td>配合cout.width(int num)和其他cout一起使用，在输出的num宽度的字符中将cout函数没有填充完的字符用chr填充</td>\n</tr>\n<tr>\n<td>cout.setf(标记)</td>\n<td>格式化cout输出，标记种类很多，具体的可以查阅资料，配合cout函数一起使用</td>\n</tr>\n</tbody></table>\n<h2 id=\"4-文件IO流\"><a href=\"#4-文件IO流\" class=\"headerlink\" title=\"4.文件IO流\"></a>4.文件IO流</h2><p>​    文件操作相对来说比较简单，总的来说就是5个步骤，即</p>\n<h3 id=\"操作步骤\"><a href=\"#操作步骤\" class=\"headerlink\" title=\"操作步骤\"></a>操作步骤</h3><ul>\n<li><p>​    包含头文件<font color=\"red\">#include<ftream></ftream></font></p>\n</li>\n<li><p>​    创建流对象</p>\n</li>\n<li><p>​    打开文件</p>\n</li>\n<li><p>​    读写文件</p>\n<p>​    <font color=\"red\">需要注意的是C++中文件写的方式是使用符号“&lt;&lt;”，如：fout &lt;&lt; “文件内容”&lt;&lt;endl;</font></p>\n<p>​    <font color=\"red\">同理文件读也可以使用“&gt;&gt;”来读。</font></p>\n</li>\n<li><p>​    关闭文件</p>\n<p><strong>文件写</strong></p>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;string&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;fstream&gt;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tofstream fout;<br>\tfout.open(<span class=\"hljs-string\">&quot;文件测试.txt&quot;</span>, ios::out);<br>\tfout &lt;&lt; <span class=\"hljs-string\">&quot;姓名：张三&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\tfout &lt;&lt; <span class=\"hljs-string\">&quot;性别：男&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\tfout.close();<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\ttest();<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>​    <strong>输出结果：</strong>    </p>\n<p><img src=\"/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/Snipaste_2019-09-14_16-29-43.png\"></p>\n<h3 id=\"4种文件读的方式\"><a href=\"#4种文件读的方式\" class=\"headerlink\" title=\"4种文件读的方式\"></a>4种文件读的方式</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;string&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;fstream&gt;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tifstream fin;<br>\tfin.open(<span class=\"hljs-string\">&quot;文件测试.txt&quot;</span>, ios::in);<br>\t<span class=\"hljs-keyword\">if</span> (!fin.is_open())<span class=\"hljs-comment\">//文件读需要多添加一步判断文件是否打开成功的步骤</span><br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;文件打开失败&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">char</span> str[<span class=\"hljs-number\">1024</span>];<br>\t<span class=\"hljs-built_in\">string</span> strs;<br>\t<span class=\"hljs-keyword\">char</span> chr;<br>\t<span class=\"hljs-comment\">//第一中方式</span><br>\t<span class=\"hljs-comment\">//while (fin &gt;&gt; str)//操作符&quot;&gt;&gt;&quot;每次只能读取一行数据，读到文件尾“EOF”时结束</span><br>\t<span class=\"hljs-comment\">//&#123;</span><br>\t<span class=\"hljs-comment\">//\tcout &lt;&lt; str &lt;&lt; endl;</span><br>\t<span class=\"hljs-comment\">//&#125;</span><br><br>\t<span class=\"hljs-comment\">//第二种方式</span><br>\t<span class=\"hljs-comment\">//while (fin.getline(str, 50))//ifstream::getline(char *str,int num);这个函数只支持字符数组，参数num指的是需要读取的字节数</span><br>\t<span class=\"hljs-comment\">//&#123;</span><br>\t<span class=\"hljs-comment\">//\tcout &lt;&lt; str &lt;&lt; endl;</span><br>\t<span class=\"hljs-comment\">//&#125;</span><br><br>\t<span class=\"hljs-comment\">//第三种方式</span><br>\t<span class=\"hljs-comment\">//while (getline(fin, strs))//与第二种方式不同的是，这个getline函数是全局的，且只支持输出到string类型的对象中</span><br>\t<span class=\"hljs-comment\">//&#123;</span><br>\t<span class=\"hljs-comment\">//\tcout &lt;&lt; strs &lt;&lt; endl;</span><br>\t<span class=\"hljs-comment\">//&#125;</span><br><br>\t<span class=\"hljs-comment\">//第四中方式</span><br>\t<span class=\"hljs-keyword\">while</span> ((chr = fin.get()) != EOF)<span class=\"hljs-comment\">//get()函数每次只能读取一个字符</span><br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; chr ;<br>\t&#125;<br>\tfin.close();<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\ttest();<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"文件的打开模式\"><a href=\"#文件的打开模式\" class=\"headerlink\" title=\"文件的打开模式\"></a>文件的打开模式</h3><p>​    C++提供6中文件的打开方式</p>\n<table>\n<thead>\n<tr>\n<th>打开方式</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ios::in</td>\n<td>以读的形式打开</td>\n</tr>\n<tr>\n<td>ios::out</td>\n<td>以写的形式打开，会覆盖源文件</td>\n</tr>\n<tr>\n<td>ios::ate</td>\n<td>以写的形式打开并初始文件位置：文件尾，会覆盖源文件</td>\n</tr>\n<tr>\n<td>ios::app</td>\n<td>以追加的方式打开文件</td>\n</tr>\n<tr>\n<td>ios::trunc</td>\n<td>如果文件存在先删除再创建</td>\n</tr>\n<tr>\n<td>ios::binary</td>\n<td>以二进制的形式打开</td>\n</tr>\n</tbody></table>\n<h3 id=\"读写二进制文件\"><a href=\"#读写二进制文件\" class=\"headerlink\" title=\"读写二进制文件\"></a>读写二进制文件</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;string&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;fstream&gt;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;<br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">string</span> name = <span class=\"hljs-string\">&quot;张三&quot;</span>;<br>\t<span class=\"hljs-built_in\">string</span> sex = <span class=\"hljs-string\">&quot;男&quot;</span>;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tofstream fout;<br>\tfout.open(<span class=\"hljs-string\">&quot;二进制文件测试.txt&quot;</span>, ios::out | ios::binary);<br>\tPerson p;<br>\tfout.write((<span class=\"hljs-keyword\">char</span> *)&amp;p, <span class=\"hljs-keyword\">sizeof</span>(Person));<span class=\"hljs-comment\">//注意这里使用ofstream::write()来写</span><br>\tfout.close;<br><br>\tifstream fin;<br>\tfin.open(<span class=\"hljs-string\">&quot;二进制文件测试.txt&quot;</span>, ios::in | ios::binary);<br>\t<span class=\"hljs-keyword\">if</span> (!fin.is_open())<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;文件打开错误&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t&#125;<br>\tPerson pin;<br>\tfin.read((<span class=\"hljs-keyword\">char</span> *)&amp;pin, <span class=\"hljs-keyword\">sizeof</span>(Person));<span class=\"hljs-comment\">//注意这里使用ofstream::read()来读</span><br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;姓名：&quot;</span> &lt;&lt; pin.name &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;性别：&quot;</span> &lt;&lt; pin.sex &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\tfin.close();<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\ttest();<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h1 id=\"一、类\"><a href=\"#一、类\" class=\"headerlink\" title=\"一、类\"></a>一、类</h1><h2 id=\"1-浅拷贝与深拷贝\"><a href=\"#1-浅拷贝与深拷贝\" class=\"headerlink\" title=\"1.浅拷贝与深拷贝\"></a>1.浅拷贝与深拷贝</h2><h3 id=\"浅拷贝\"><a href=\"#浅拷贝\" class=\"headerlink\" title=\"浅拷贝\"></a>浅拷贝</h3><p><font color=\"red\"> C++在进行浅拷贝时，只拷贝栈区的内存空间，不拷贝堆区的内存空间，即浅拷贝只拷贝非指针的成员变量和指针本身，而不拷贝指针所指向的堆区的内容。</font></p>\n<p>我们代码1.1为例</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//代码1.1</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Obj</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\tObj(<span class=\"hljs-keyword\">char</span> *tp)<br>\t&#123;<br>\t\tlen = <span class=\"hljs-built_in\">strlen</span>(tp);<br>\t\tp = (<span class=\"hljs-keyword\">char</span>*)<span class=\"hljs-built_in\">malloc</span>(len + <span class=\"hljs-number\">1</span>);<br>\t\tstrcpy_s(p, len+<span class=\"hljs-number\">1</span>, tp);<br>\t&#125;<br>\t~Obj()<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (p != <span class=\"hljs-literal\">NULL</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">free</span>(p);<br>\t\t\tp = <span class=\"hljs-literal\">NULL</span>;<br>\t\t\tlen = <span class=\"hljs-number\">0</span>;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Show</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; *p &lt;&lt; *(p + <span class=\"hljs-number\">1</span>) &lt;&lt; *(p + <span class=\"hljs-number\">2</span>) &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-keyword\">char</span> *p;<br>\t<span class=\"hljs-keyword\">int</span> len;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">text</span><span class=\"hljs-params\">(Obj &amp;obj)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tObj obj2 = obj;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\">Obj <span class=\"hljs-title\">obj1</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;asd&quot;</span>)</span></span>;<br>\ttext(obj1);<br>\tobj1.Show();<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>我们作一个图示：</p>\n<p><img src=\"/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/Git\\Blog\\source_posts\\【C++】C++高级\\Snipaste_2019-10-01_16-21-15.png\"></p>\n<p>​    我们没有自定义Obj类的拷贝构造函数，所以当代码执行到<code>Obj obj2 = obj1;</code>时，编译器将调用默认的拷贝构造函数，然而，<font color=\"red\"> 编译器默认的拷贝构造函数是一个浅拷贝</font>，所以新创建的对象obj2没有自己的堆区空间，obj2.p指向的是obj1.p所指向的内存地址。</p>\n<p>​    上面的代码编译是通不过的，<font color=\"red\"> 原因在于，对象析构时，同一个内存地址<code>0x0001</code>被对象obj1和obj2一起析构了两次</font>。当代码执行完<code>test(obj1)</code>时，对象obj2被析构，指针obj2.p所指向的内存地址<code>0x0001</code>被释放，所以当代码执行到<code>obj1.Show()</code>时，使用了已经被释放掉的内存<code>0x0001</code>地址，从而导致运行错误。</p>\n<p>​    <font color=\"green\"> <strong>这里我有一个疑问，既然浅拷贝在拷贝有指针的对象时，会出现两次析构而出错，所以浅拷贝只能拷贝没有指针成员的对象，那么浅拷贝和深拷贝似乎没有什么区别了，那么浅拷贝存在的意义是什么呢？</strong></font></p>\n<h3 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h3><p>C++没有提供给开发者预定义的深拷贝方法，所以要想使用深拷贝，我们需要字写一个拷贝构造函数。</p>\n<p>深拷贝可以解决上面遇到的浅拷贝的问题，因为，<font color=\"red\"> 深拷贝会申请一新的内存空间用于存放拷贝过来的内容，即深拷贝拷贝对象的所有成员，包括指针所指向的内存空间也会一起被拷贝，被拷贝过来的指针会指向一个新的内存地址</font>。</p>\n<p><img src=\"/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/Snipaste_2019-10-01_16-52-53.png\"></p>\n<h3 id=\"定义深拷贝构造函数\"><a href=\"#定义深拷贝构造函数\" class=\"headerlink\" title=\"定义深拷贝构造函数\"></a>定义深拷贝构造函数</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//代码1.2</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Obj</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\tObj(<span class=\"hljs-keyword\">char</span> *tp)<br>\t&#123;<br>\t\tlen = <span class=\"hljs-built_in\">strlen</span>(tp);<br>\t\tp = (<span class=\"hljs-keyword\">char</span>*)<span class=\"hljs-built_in\">malloc</span>(len + <span class=\"hljs-number\">1</span>);<br>\t\tstrcpy_s(p, len+<span class=\"hljs-number\">1</span>, tp);<br>\t&#125;<br>    <span class=\"hljs-comment\">//------------------------------</span><br>    <span class=\"hljs-comment\">//拷贝构造函数--深拷贝</span><br>\tObj(<span class=\"hljs-keyword\">const</span> Obj &amp;obj)<br>\t&#123;<br>\t\tlen = obj.len;<br>\t\tp = (<span class=\"hljs-keyword\">char</span>*)<span class=\"hljs-built_in\">malloc</span>(len + <span class=\"hljs-number\">1</span>);<br>\t\tstrcpy_s(p, len + <span class=\"hljs-number\">1</span>, obj.p);<br>\t&#125;<br>    <span class=\"hljs-comment\">//------------------------------</span><br>\t~Obj()<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (p != <span class=\"hljs-literal\">NULL</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">free</span>(p);<br>\t\t\tp = <span class=\"hljs-literal\">NULL</span>;<br>\t\t\tlen = <span class=\"hljs-number\">0</span>;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Show</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; *p &lt;&lt; *(p + <span class=\"hljs-number\">1</span>) &lt;&lt; *(p + <span class=\"hljs-number\">2</span>) &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-keyword\">char</span> *p;<br>\t<span class=\"hljs-keyword\">int</span> len;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>当一个类中定义了拷贝构造函数，则在对象拷贝时，编译器就不会在调用默认的拷贝构造函数转而调用自定义的拷贝构造函数，当我们把代码1.1中类的定义改为代码1.2中类的定义后，程序就可以正常执行了。</p>\n<p><font color=\"red\">使用深拷贝时，我们还需要注意下面的情况：</font></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">Obj <span class=\"hljs-title\">obj1</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;asd&quot;</span>)</span></span>;<br><span class=\"hljs-function\">Obj <span class=\"hljs-title\">obj3</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;fgh&quot;</span>)</span></span>;<br>obj3 = obj1;<br></code></pre></td></tr></table></figure>\n<p>此时，在<code>obj3=obj1;</code>处依旧调用默认的拷贝构造函数，这里我们要弄清楚<code>obj3=obj1</code>和<code>Obj obj3 = obj1</code>之间的区别，<code>obj3=obj1</code>是将<font color=\"red\">obj1赋值给obj3</font>，<code>=</code>赋值与拷贝构造函数没有什么关联，<code>=</code>在赋值时是C++编译器自己调用默认的拷贝构造函数—浅拷贝，和类中有无定义深拷贝无关；而<code>Obj obj3=obj1</code>则是<font color=\"red\">使用obj1来构造obj3</font>，此时如果类中定义了深拷贝构造函数，就会使用深拷贝。要解决这个问题，就需要显示重载<code>=</code>运算符了。</p>\n<h3 id=\"小知识\"><a href=\"#小知识\" class=\"headerlink\" title=\"小知识\"></a><font color=\"blue\"><strong>小知识</strong></font></h3><ul>\n<li><font color=\"blue\">在定义拷贝构造函数时，必须使用引用传递，否则会出现无限拷贝的情况，因为，如果我们使用传值传递的话，在传递对象到拷贝构造函数时，又会调用拷贝构造函数将实参拷贝给形参，而这个过程又会将对象传递给拷贝构造函数，从而在此调用拷贝构造函数将实参拷贝给形参，如此无限循环</font></li>\n<li><font color=\"blue\">拷贝构造函数只能有一个参数，且必须是自身类的引用，否则编译器将识别被普通构造函数</font></li>\n</ul>\n<h2 id=\"2-初始化参数列表\"><a href=\"#2-初始化参数列表\" class=\"headerlink\" title=\"2.初始化参数列表\"></a>2.初始化参数列表</h2><h3 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h3><p>我们以下面的代码1.3来说明初始化参数列表</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\tA(<span class=\"hljs-keyword\">int</span> a)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;a = a;<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-keyword\">int</span> a;<br>&#125;;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">B</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span> :<br>\tB(<span class=\"hljs-keyword\">int</span> i)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;i = i;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">int</span> i;<br>\tA a;<br><br>&#125;;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\">B <span class=\"hljs-title\">b</span><span class=\"hljs-params\">(<span class=\"hljs-number\">1</span>)</span></span>;<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>运行结果：</strong></p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dns\">错误\tC2512\t“<span class=\"hljs-keyword\">A</span>”: 没有合适的默认构造函数可用<br></code></pre></td></tr></table></figure>\n<p>​    这个问题就在于，在类B中组合了一个A类的成员，编译器在构造B类对象时，同时会构造一个A类对象作为B类的成员，然而，因为A类自定义了一个有参的构造函数，所以在构造A类时，编译器不会使用默认构造函数，而是使用自定义的有参构造函数，问题就出在这里，编译器在构造A类时，没有参数传递到A类的有参构造函数中。初始化参数列表就是用于解决这种问题的。</p>\n<p>​    需要说明的是，如果A类中没有自定义有参的构造函数，则在B类构造对象时编译器自动调用A类的默认构造函数构造A类对象成员，就不会报错。</p>\n<p>​    初始化参数列表可以让我们在构造B类对象时，根据参数列表来构造不同的A类成员。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>初始化参数列表的使用如下面的<code>B(int i):a1(1),a2(2,&quot;asd&quot;)</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\tA(<span class=\"hljs-keyword\">int</span> a)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;a = a;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;构造小A&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>\tA(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-built_in\">string</span> str)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;a = a;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;str = str;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;构造大A&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>\t~A()<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;析构A&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">int</span> a;<br>\t<span class=\"hljs-built_in\">string</span> str;<br>&#125;;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">B</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span> :<br>\tB(<span class=\"hljs-keyword\">int</span> i):a1(<span class=\"hljs-number\">1</span>),a2(<span class=\"hljs-number\">2</span>,<span class=\"hljs-string\">&quot;asd&quot;</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;i = i;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;构造B&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>\t~B()<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;析构B&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">int</span> i;<br>\tA a1;<br>\tA a2;<br>&#125;;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\">B <span class=\"hljs-title\">b</span><span class=\"hljs-params\">(<span class=\"hljs-number\">1</span>)</span></span>;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; b.a1.str &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; b.a2.str &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\ttest();<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dns\">构造小<span class=\"hljs-keyword\">A</span><br>构造大<span class=\"hljs-keyword\">A</span><br>构造B<br><br>asd<br>析构B<br>析构<span class=\"hljs-keyword\">A</span><br>析构<span class=\"hljs-keyword\">A</span><br></code></pre></td></tr></table></figure>\n<p>​    值得注意的是<font color=\"red\"> A类对象的构造顺序不是由初始化参数列表的顺序决定的，而是由对象的申明的前后顺序决定的</font>，如：<code>B(int i):a1(1),a2(2,&quot;asd&quot;)</code>和<code>B(int i):a2(2,&quot;asd&quot;),a1(1)</code>的构造顺序是一样的，但是当我们将类B中组合的A类对象的申明顺序改为如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">B</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span> :<br>\tB(<span class=\"hljs-keyword\">int</span> i):a1(<span class=\"hljs-number\">1</span>),a2(<span class=\"hljs-number\">2</span>,<span class=\"hljs-string\">&quot;asd&quot;</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;i = i;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;构造B&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>\t~B()<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;析构B&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">int</span> i;<br>\tA a2;<br>\tA a1;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>则构造顺序就变为“先构造a2再构造a1”了。</p>\n<p><font color=\"red\"> 析构的顺序和构造的顺序相反。</font></p>\n<h3 id=\"小知识-1\"><a href=\"#小知识-1\" class=\"headerlink\" title=\" 小知识\"></a><font color=\"blue\"> 小知识</font></h3><ul>\n<li><font color=\"blue\"> 当一个类中组合了其他的类对象作为成员时，拷贝构造函数也必须使用初始化参数列表，来构造对象成员然后拷贝</font></li>\n</ul>\n<h2 id=\"3-匿名对象的生命周期\"><a href=\"#3-匿名对象的生命周期\" class=\"headerlink\" title=\"3.匿名对象的生命周期\"></a>3.匿名对象的生命周期</h2><h3 id=\"什么是匿名对象\"><a href=\"#什么是匿名对象\" class=\"headerlink\" title=\"什么是匿名对象\"></a>什么是匿名对象</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">calss A<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-keyword\">int</span> a;<br>\tA(<span class=\"hljs-keyword\">int</span> a)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;a = a;<br>\t&#125;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    A(<span class=\"hljs-number\">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>上面的语句<code>A(1)</code>创建的就是一个匿名临时的对象，<font color=\"red\"> 需要注意，如果一个类只有无参的构造函数，那么这个类将无法构建匿名对象</font>，匿名对象的生命周期就只在创建匿名对象的这条语句内，如果我们不使用一个对象来接收这个匿名对象，那么匿名对象会在语句结束时被销毁，当我们使用<code>A a = A(1);</code>不会出现匿名对象拷贝到类B对象b的情况，这种语句已经被C++优化成了类B的构造语句。说这么多其实匿名对象没什么卵用。</p>\n<h2 id=\"4-new和delete\"><a href=\"#4-new和delete\" class=\"headerlink\" title=\"4.new和delete\"></a>4.new和delete</h2><p>1.new和delete的用法</p>\n<p><code>new</code>可以为<strong>基础类型</strong>、<strong>数组</strong>、<strong>类</strong>分配内存空间，<code>new</code>分配的内存空间都分配在<strong>堆</strong>上。随意<code>new</code>出来的内存空间必须使用一个指针来指向，不能使用同类型的变量来接收，也禁止不接受。</p>\n<p><strong>new 基础类型</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">int</span> *p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>;<br><span class=\"hljs-keyword\">delete</span> p;<br></code></pre></td></tr></table></figure>\n<p><strong>new 数组</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">int</span> *p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[<span class=\"hljs-number\">10</span>];<br><span class=\"hljs-keyword\">delete</span>[] p;<br></code></pre></td></tr></table></figure>\n<p><strong>new 类</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//C++</span><br>A *p = <span class=\"hljs-keyword\">new</span> A();<br><span class=\"hljs-keyword\">delete</span> p;<br><span class=\"hljs-comment\">//C</span><br>A *pc = (A*)<span class=\"hljs-built_in\">malloc</span>(A);<br><span class=\"hljs-built_in\">free</span>(pc);<br></code></pre></td></tr></table></figure>\n<h3 id=\"new-delete和malloc-free的区别\"><a href=\"#new-delete和malloc-free的区别\" class=\"headerlink\" title=\"new delete和malloc free的区别\"></a><code>new delete</code>和<code>malloc free</code>的区别</h3><ul>\n<li><p>在基础类型和基础类型数组方面<code>new delete</code>和<code>malloc free</code>几乎没有什么区别</p>\n</li>\n<li><p><code>new</code>不仅会分配内存还会调用构造函数，而<code>malloc</code>只会分配内存</p>\n</li>\n<li><p><code>delete</code>会调用析构函数来销毁对象，而<code>free</code>只是单纯的释放内存</p>\n</li>\n</ul>\n<h3 id=\"小知识-2\"><a href=\"#小知识-2\" class=\"headerlink\" title=\" 小知识\"></a><font color=\"blue\"> <strong>小知识</strong></font></h3><p><font color=\"blue\"> <code>new delete</code>和<code>malloc free</code>是可以穿插使用的，即<code>new</code>可以和<code>free</code>搭配使用，<code>malloc</code>可以和<code>delete</code>搭配使用。</font></p>\n<h1 id=\"二、继承\"><a href=\"#二、继承\" class=\"headerlink\" title=\"二、继承\"></a>二、继承</h1><p>继承这边主要分析一下<code>虚继承</code></p>\n<h2 id=\"1-虚继承\"><a href=\"#1-虚继承\" class=\"headerlink\" title=\"1.虚继承\"></a>1.虚继承</h2><p>虚继承的出现主要是为解决如下的继承关系中的二义性问题</p>\n<p><img src=\"/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/Snipaste_2019-10-02_15-50-39.png\" alt=\"图1\"></p>\n<p>当我们的类的继承过程中出现这种继承关系时，我们需要使类B和类C分别虚继承类A来解决二义性，具体操作如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span></span><br><span class=\"hljs-class\">&#123;</span><br>   <span class=\"hljs-keyword\">public</span>:<br>    \t<span class=\"hljs-keyword\">int</span> a;<br>&#125;;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">B</span> :</span> <span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">public</span> A<br>&#123;<br>\t<span class=\"hljs-keyword\">public</span>:<br>\t\t<span class=\"hljs-keyword\">int</span> b;<br>&#125;;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">C</span> :</span> <span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">public</span> A<br>&#123;<br>\t<span class=\"hljs-keyword\">public</span>:<br>\t\t<span class=\"hljs-keyword\">int</span> c;<br>&#125;;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">D</span> :</span> <span class=\"hljs-keyword\">public</span> B,C<br>&#123;<br>\t<span class=\"hljs-keyword\">public</span>:<br>\t\t<span class=\"hljs-keyword\">int</span> d;<br>&#125;;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    D d;<br>    d.a = <span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这里有一点要注意，虚继承的应用场景有限，虚继承只能解决这种情况：</p>\n<p><img src=\"/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/Snipaste_2019-10-02_15-50-39.png\"></p>\n<p>而不能解决这种情况：</p>\n<p><img src=\"/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/Snipaste_2019-10-02_16-10-55.png\"></p>\n<h2 id=\"2-继承中的static关键字\"><a href=\"#2-继承中的static关键字\" class=\"headerlink\" title=\"2.继承中的static关键字\"></a>2.继承中的static关键字</h2><p><font color=\"red\"> 类中的静态成员变量被类的所有对象共享，同时也被类的派生类的所有对象共享。</font></p>\n<h1 id=\"三、多态\"><a href=\"#三、多态\" class=\"headerlink\" title=\"三、多态\"></a>三、多态</h1><p>​    在C++的几个特性中，封装、继承和抽象都相对好理解，而多态则不太好理解，这里就说说C++的多态。</p>\n<h2 id=\"1-多态分两种：\"><a href=\"#1-多态分两种：\" class=\"headerlink\" title=\"1.多态分两种：\"></a>1.多态分两种：</h2><p>​    静态多态：静态多态指的就是函数重载和运算符重载。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Animal</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">string</span> name = <span class=\"hljs-string\">&quot;动物&quot;</span>;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">speak</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; name &lt;&lt; <span class=\"hljs-string\">&quot;在叫&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Dog</span> :</span> <span class=\"hljs-keyword\">public</span> Animal<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">string</span> name = <span class=\"hljs-string\">&quot;狗&quot;</span>;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">speak</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; name &lt;&lt; <span class=\"hljs-string\">&quot;在叫&quot;</span> &lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-built_in\">string</span> <span class=\"hljs-keyword\">operator</span>+(Animal animal,Dog dog)<br>&#123;<br>\t<span class=\"hljs-keyword\">return</span> animal.name + <span class=\"hljs-string\">&quot;是&quot;</span> + dog.name + <span class=\"hljs-string\">&quot;的父类&quot;</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Run</span><span class=\"hljs-params\">(Animal animal)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; animal.name &lt;&lt;<span class=\"hljs-string\">&quot;在跑&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Run</span><span class=\"hljs-params\">(Dog dog)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; dog.name &lt;&lt; <span class=\"hljs-string\">&quot;在跑&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tAnimal animal;<br>\tDog dog;<br>\tRun(animal);<br>\tRun(dog);<br>\t<span class=\"hljs-built_in\">cout</span>&lt;&lt;animal+dog&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>​    动态多态：动态多态则是通过继承和虚函数实现标签相同的函数因为传入不同的对象来实现不同的功能。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Animal</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">string</span> name = <span class=\"hljs-string\">&quot;动物&quot;</span>;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">speak</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; name &lt;&lt; <span class=\"hljs-string\">&quot;在叫&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Dog</span> :</span> <span class=\"hljs-keyword\">public</span> Animal<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">string</span> name = <span class=\"hljs-string\">&quot;狗&quot;</span>;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">speak</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; name &lt;&lt; <span class=\"hljs-string\">&quot;在叫&quot;</span> &lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Speak</span><span class=\"hljs-params\">(Animal *animal)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tanimal-&gt;speak();<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tAnimal animal;<br>\tDog dog;<br>\tSpeak(&amp;animal);<br>\tSpeak(&amp;dog);<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>​    动态多态中只能用父类对象的指针或引用来指向子类或自身对象。</p>\n<h2 id=\"2-多态的实现原理\"><a href=\"#2-多态的实现原理\" class=\"headerlink\" title=\"2.多态的实现原理\"></a>2.多态的实现原理</h2><p>​    C++多态的实现依赖于类的虚函数表，当一个类中定义了虚函数，那么这个类就拥有的了一个记录这个虚函数入口地址的虚函数表，子类继承父类时也会继承父类的虚函数表，当子类重写父类的虚函数时，则子类的虚函数入口地址将覆盖父类的地址，如此当子类对象调用此函数时则从子类的虚函数表中寻找入口地址，当父类的对象调用此函数时则从父类的虚函数表中寻找入口地址。</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gcode\">当类创建虚函数时，编译器会在类中生成一个虚函数表<br>虚函数表是一个存储类成员函数指针的数据结构<br>虚函数表有编译器自动生成和维护<br>虚成员函数会被编译器放入虚函数表中<br>存在虚函数时，每一个对象中都会拥有一个指向虚函数表的虚函数表指针<span class=\"hljs-comment\">(vptr)</span><br></code></pre></td></tr></table></figure>\n<p>简单来说，多态实现的条件有三：</p>\n<ul>\n<li><p>要有继承</p>\n</li>\n<li><p>要有虚函数重写</p>\n</li>\n<li><p>要有父类指针(或引用)指向子类对象</p>\n</li>\n</ul>\n<h2 id=\"3-纯虚函数和抽象类\"><a href=\"#3-纯虚函数和抽象类\" class=\"headerlink\" title=\"3.纯虚函数和抽象类\"></a>3.纯虚函数和抽象类</h2><p>​    纯虚函数的定义：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">speak</span><span class=\"hljs-params\">()</span> </span>= <span class=\"hljs-number\">0</span><br></code></pre></td></tr></table></figure>\n<p>​    定义了纯虚函数的类就被成为抽象类，C++引入纯虚函数和抽象类的概念就是为了更好的使用多态，抽象类不能实例化对象，这个特性就规范了继承这个抽象类的子类必须重写父类的虚函数，因为如果继承了抽象类的子类不重写父类的虚函数，那么子类也是一个抽象类，子类便也不能实例化对象，如此便规范了多态实现，防止当子类很多时，出现某个子类在编写时忘记重写父类的虚函数，而导致这个子类没有实现多态。</p>\n<h2 id=\"4-虚析构函数和纯虚析构函数\"><a href=\"#4-虚析构函数和纯虚析构函数\" class=\"headerlink\" title=\"4.虚析构函数和纯虚析构函数\"></a>4.虚析构函数和纯虚析构函数</h2><ul>\n<li>虚析构函数的定义：</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">virtual</span> ~Animal();<br></code></pre></td></tr></table></figure>\n<ul>\n<li>纯虚析构函数的定义：</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">virtual</span> ~Animal() = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-comment\">//纯虚析构函数必须要有申明也要有实现</span><br>Animal：：~Animal()<br>&#123;<br>    <span class=\"hljs-comment\">//代码实现</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>如果子类在堆区中定义了数据，那么我们使用父类指针或引用来使用多态时，父类指针或引用是无法寻找到子类在堆区中的数据并释放的。C++引入虚析构函数和纯虚析构函数就是为了解决此类问题。</p>\n<p>​    我们来看一个例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Animal</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\tAnimal()<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;这是Animal的构造函数&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>\t~Animal()<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;这是Animal的析构函数&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Dog</span> :</span> <span class=\"hljs-keyword\">public</span> Animal<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-keyword\">int</span> *p;<br>\tDog()<br>\t&#123;<br>\t\tp = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;这是Dog的构造函数&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>\t~Dog()<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;这是Dog的析构函数&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t\t<span class=\"hljs-keyword\">if</span> (p != <span class=\"hljs-literal\">NULL</span>)<br>\t\t&#123;\t\t<br>\t\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;释放堆区的p&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t\t\t<span class=\"hljs-keyword\">delete</span> p;<br>\t\t\tp = <span class=\"hljs-literal\">NULL</span>;<br>\t\t&#125;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tAnimal *animal = <span class=\"hljs-keyword\">new</span> Dog();<br>\t<span class=\"hljs-keyword\">delete</span> animal;<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs inform7\">这是<span class=\"hljs-keyword\">Animal</span>的构造函数<br>这是Dog的构造函数<br>这是<span class=\"hljs-keyword\">Animal</span>的析构函数<br></code></pre></td></tr></table></figure>\n<p>可以看到，delete animal后并没有调用Dog的析构函数，释放子类Dog在堆区申请的空间。这样便出现了内存泄漏。</p>\n<p>此时虚析构函数和纯虚析构函数便可以起作用了，我们再看一个例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Animal</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\tAnimal()<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;这是Animal的构造函数&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">virtual</span> ~Animal()<span class=\"hljs-comment\">//把父类的析构函数改为虚析构函数</span><br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;这是Animal的析构函数&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Dog</span> :</span> <span class=\"hljs-keyword\">public</span> Animal<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-keyword\">int</span> *p;<br>\tDog()<br>\t&#123;<br>\t\tp = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;这是Dog的构造函数&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>\t~Dog()<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;这是Dog的析构函数&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t\t<span class=\"hljs-keyword\">if</span> (p != <span class=\"hljs-literal\">NULL</span>)<br>\t\t&#123;\t\t<br>\t\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;释放堆区的p&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t\t\t<span class=\"hljs-keyword\">delete</span> p;<br>\t\t\tp = <span class=\"hljs-literal\">NULL</span>;<br>\t\t&#125;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tAnimal *animal = <span class=\"hljs-keyword\">new</span> Dog();<br>\t<span class=\"hljs-keyword\">delete</span> animal;<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n<p>​    输出结果：</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs inform7\">这是<span class=\"hljs-keyword\">Animal</span>的构造函数<br>这是Dog的构造函数<br>这是Dog的析构函数<br>释放堆区的p<br>这是<span class=\"hljs-keyword\">Animal</span>的析构函数<br></code></pre></td></tr></table></figure>\n<p>​    如此便可以释放子类Dog在堆区申请的空间了，纯虚析构函数和虚析构函数的作用是一样，只是纯虚析构函数有一个和纯虚函数一样的特性，即定义了纯虚析构函数的类也属于抽象类，纯虚析构函数必须实现，如果不实现所有继承了拥有纯虚析构函数的抽象类的派生类都属于抽象类。需要注意的是，因为纯虚析构函数的特性，纯虚析构函数的实现就必须在类外实现了。</p>\n<h2 id=\"5-重载、重写、重定义\"><a href=\"#5-重载、重写、重定义\" class=\"headerlink\" title=\"5.重载、重写、重定义\"></a>5.重载、重写、重定义</h2><p><strong>重载</strong></p>\n<p>重载发生在一个类的内部，拥有相同函数名，相同返回值而参数列表不同的函数之间互为重载关系。如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span></span><br><span class=\"hljs-class\">&#123;</span><br>\t<span class=\"hljs-keyword\">public</span>:<br>\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">fun</span><span class=\"hljs-params\">()</span></span>&#123;&#125;<br>\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">fun</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a)</span></span>&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p><font color=\"red\"> 只有相同函数名而参数列表不同的函数才是重载，函数名相同参数列表也相同而返回值不同的函数在C++中是不允许的。</font></p>\n<p><strong>重写</strong></p>\n<p>重写发生在基类和派生类之间，基类中定义虚函数(纯虚函数)，派生类中定义和虚函数拥有<strong>相同函数名，相同参数列表和相同返回值</strong>的函数，这种情况下发生函数重写。如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span></span><br><span class=\"hljs-class\">&#123;</span><br>    <span class=\"hljs-keyword\">public</span>:<br>    \t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">fun</span><span class=\"hljs-params\">()</span></span>&#123;&#125;<br>&#125;;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">B</span> :</span> <span class=\"hljs-keyword\">public</span> A<br>&#123;<br>\t<span class=\"hljs-keyword\">public</span>:<br>\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">fun</span><span class=\"hljs-params\">()</span></span>&#123;&#125;<span class=\"hljs-comment\">//重写A类的fun函数</span><br>\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">fun</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a)</span></span>&#123;&#125;<span class=\"hljs-comment\">//重定义一个新函数</span><br>\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">fun</span><span class=\"hljs-params\">()</span></span>&#123;<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;&#125;<span class=\"hljs-comment\">//这种情况C++不允许</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<p><strong>重定义</strong></p>\n<p>重定义也是发生在基类和派生类之间，派生类拥有与基类函数名相同，返回值相同，而参数列表不同的函数，此时发生重定义。如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span></span><br><span class=\"hljs-class\">&#123;</span><br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">fun</span><span class=\"hljs-params\">()</span></span>&#123;&#125;<br>&#125;;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">B</span> :</span> <span class=\"hljs-keyword\">public</span> A<br>&#123;<br>\t<span class=\"hljs-keyword\">public</span>:<br>\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">fun</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a)</span></span>&#123;&#125;<span class=\"hljs-comment\">//发生重定义</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<p><font color=\"red\"> 派生类中可以重定义基类的任何函数，包括虚函数和纯虚函数。</font></p>\n<h2 id=\"6-父类指针和子类指针步长不一致问题\"><a href=\"#6-父类指针和子类指针步长不一致问题\" class=\"headerlink\" title=\"6.父类指针和子类指针步长不一致问题\"></a>6.父类指针和子类指针步长不一致问题</h2><p>问题出现的场景是这样的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-keyword\">int</span> a;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">()</span> </span>&#123;&#125;<br>&#125;;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">B</span> :</span> <span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">public</span> A<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-keyword\">int</span> b;<br>\tB(<span class=\"hljs-keyword\">int</span> b)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;b = b;<br>\t&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; b &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>&#125;;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tA *a = <span class=\"hljs-literal\">NULL</span>;<br>\tB *b = <span class=\"hljs-literal\">NULL</span>;<br>\tB <span class=\"hljs-built_in\">array</span>[<span class=\"hljs-number\">2</span>]&#123; B(<span class=\"hljs-number\">1</span>),B(<span class=\"hljs-number\">2</span>) &#125;;<br>\ta = <span class=\"hljs-built_in\">array</span>;<br>\tb = <span class=\"hljs-built_in\">array</span>;<br>\ta-&gt;print();<br>\tb-&gt;print();<br>\ta++; b++;<br>\ta-&gt;print();<span class=\"hljs-comment\">//这一步会出现异常</span><br>\tb-&gt;print();<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>即父类指针a和子类指针b都指向一个子类对象数组，于是我们可以通过指针++的自增运算来逐步访问数组元素，问题就出在这，使用<code>sizeof()</code>计算两个类的大小分别得出，sizeof(A)=8;sizeof(B)=20;这就导致A类指针a每一次移步时只移动了8个字节，这个距离还远远没有达到下一个元素的首地址，所以访问会出错，这是因为指针每次移步移动的距离是指针类型的空间大小，如：A类大小为8，所以A类指针每移步一次走8个字节。</p>\n<p>可能会有疑问，为什么类B的大小是20？</p>\n<p>我们可以算一算，类B继承至类A所以类A中拥有的成员变量，类B也拥有，占8字节，这8字节分别是int变量4字节和虚函数表指针4字节；类B自身定义了一个int变量占4字节，由于类B重写了类A的虚函数，所以类B也拥有一个自己的虚函数表指针，占4字节；类B虚继承了类A，在这个过程中，C++编译器会给类B增加一个属性，占4字节，于是，<strong>8+4+4+4+4=20</strong>。</p>\n<hr>\n<h1 id=\"四、泛型编程\"><a href=\"#四、泛型编程\" class=\"headerlink\" title=\"四、泛型编程\"></a>四、泛型编程</h1><h2 id=\"1-函数模板\"><a href=\"#1-函数模板\" class=\"headerlink\" title=\"1.函数模板\"></a>1.函数模板</h2><h3 id=\"函数模板的基本语法\"><a href=\"#函数模板的基本语法\" class=\"headerlink\" title=\"函数模板的基本语法\"></a>函数模板的基本语法</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//---------------函数模板</span><br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;<span class=\"hljs-comment\">//告诉编译器我要开始泛型编程了，遇到T不要报错</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Fun</span><span class=\"hljs-params\">(T &amp;a,T &amp;b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tT t = a;<br>\ta = b;<br>\tb = t;<br>&#125;<br><span class=\"hljs-comment\">//----------------</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">char</span> a = <span class=\"hljs-number\">97</span>,b = <span class=\"hljs-number\">102</span>;<br>\tFun(a, b);<span class=\"hljs-comment\">//自动推导类型调用</span><br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; a &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span> &lt;&lt; b &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t<span class=\"hljs-built_in\">string</span> x = <span class=\"hljs-string\">&quot;xxx&quot;</span>, y = <span class=\"hljs-string\">&quot;yyy&quot;</span>;<br>\tFun&lt;<span class=\"hljs-built_in\">string</span>&gt;(x, y);<span class=\"hljs-comment\">//显示类型调用</span><br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; x &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"当函数模板遇到函数重载\"><a href=\"#当函数模板遇到函数重载\" class=\"headerlink\" title=\"当函数模板遇到函数重载\"></a>当函数模板遇到函数重载</h3><p>当函数模板遇到函数重载准许下面4条原则</p>\n<ul>\n<li>函数模板可以像普通函数一样被重载</li>\n<li>C++编译器优先考虑普通函数</li>\n<li>如果函数模板可以产生一个更好的匹配，那么选择函数模板</li>\n<li>可以通过模板的空实参列表的语法限定编译器只通过函数模板匹配</li>\n</ul>\n<p>我们来看一个例子，逐一分析</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Fun</span><span class=\"hljs-params\">(T a,T b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\ta = a + b;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;我是函数模板&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>&#125;<br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T1,<span class=\"hljs-keyword\">typename</span> T2&gt;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Fun</span><span class=\"hljs-params\">(T1 a,T2 b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tT1 x = a;<br>\tT2 y = b;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;我是函数模板重载&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Fun</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;我是普通函数&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Fun2</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; a &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span> &lt;&lt; b &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tFun(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);<br>\tFun(<span class=\"hljs-number\">0.1</span>, <span class=\"hljs-number\">0.2</span>);<br>\tFun(<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-number\">1</span>);<br>\tFun&lt;&gt;(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);<br>\tFun2(<span class=\"hljs-number\">0.1</span>, <span class=\"hljs-number\">0.2</span>);<br>\tFun2(<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">3</span>);<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">我是普通函数<br>我是函数模板<br>我是函数模板重载<br>我是函数模板<br>0,0<br>97,3<br></code></pre></td></tr></table></figure>\n<p><strong>分析：</strong></p>\n<ul>\n<li><code>Fun(1,2)</code>:有完全匹配的普通函数，所以调用<code>void Fun(int a, int b)</code></li>\n<li><code>Fun(0.1,0.2)</code>:虽然普通函数<code>void Fun(int a, int b)</code>可以像<code>void Fun2(int a, int b)</code>一样进行隐式类型转换调用，倒是<code>Fun()</code>函数有更好的重载函数<code>void Fun(T1 a,T2 b)</code>模板匹配所以编译器优先调用<code>void Fun(T1 a,T2 b)</code></li>\n<li><code>Fun(&#39;c&#39;,1)</code>:编译器能找到匹配的函数模板重载<code>void Fun(T1 a,T2 b)</code>所以优先调用函数模板</li>\n<li><code>Fun&lt;&gt;(1,2)</code>:使用了空参数列表，告诉编译器只匹配函数模板，即使代码段中有能完美匹配的普通函数，也只调用函数模板</li>\n</ul>\n<h2 id=\"2-类模板\"><a href=\"#2-类模板\" class=\"headerlink\" title=\"2.类模板\"></a>2.类模板</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;<span class=\"hljs-comment\">//定义</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TemplateA</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\tTemplateA(T a)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;a = a;<br>\t&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">PrintA</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\tT a;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Test</span><span class=\"hljs-params\">(TemplateA&lt;<span class=\"hljs-keyword\">int</span>&gt; &amp;a)</span><span class=\"hljs-comment\">//类模板作形参</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\ta.PrintA();<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\">TemplateA&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">a</span><span class=\"hljs-params\">(<span class=\"hljs-number\">1</span>)</span></span>;<span class=\"hljs-comment\">//使用</span><br>\t<span class=\"hljs-function\">TemplateA&lt;<span class=\"hljs-built_in\">string</span>&gt; <span class=\"hljs-title\">b</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;str&quot;</span>)</span></span>;<br>\t<span class=\"hljs-function\">TemplateA&lt;<span class=\"hljs-keyword\">bool</span>&gt; <span class=\"hljs-title\">c</span><span class=\"hljs-params\">(<span class=\"hljs-literal\">true</span>)</span></span>;<br>\tTest(a);<br>\tb.PrintA();<br>\tc.PrintA();<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight avrasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs avrasm\"><span class=\"hljs-symbol\">a:</span><span class=\"hljs-number\">1</span><br><span class=\"hljs-symbol\">a:</span>str<br><span class=\"hljs-symbol\">a:</span><span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n<p>类模板的定义和函数模板的定义类似</p>\n<h3 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>类模板的使用必须显示的确定模板的类型参数，如：<code>TemplateA&lt;string&gt; b(&quot;str&quot;)</code></p>\n<h3 id=\"类模板作参数\"><a href=\"#类模板作参数\" class=\"headerlink\" title=\"类模板作参数\"></a>类模板作参数</h3><p>类模板作参数也必须显示的确定模板那的类型参数，如：</p>\n<p><code>void Test(TemplateA&lt;int&gt; &amp;a)</code>以便编译器为形参确定内存空间。</p>\n<h3 id=\"类模板派生普通类\"><a href=\"#类模板派生普通类\" class=\"headerlink\" title=\"类模板派生普通类\"></a>类模板派生普通类</h3><p>类模板也可以被继承，但是在继承时需要显示确定模板的类型参数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TemplateA</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\tTemplateA(T a)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;a = a;<br>\t&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">PrintA</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\tT a;<br>&#125;;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">B</span> :</span> <span class=\"hljs-keyword\">public</span> TemplateA&lt;<span class=\"hljs-keyword\">int</span>&gt;<span class=\"hljs-comment\">//类模板派生普通类</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\tB(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> b) :TemplateA(a)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;b = b;<br>\t&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">PrintB</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;b:&quot;</span> &lt;&lt; b &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-keyword\">int</span> b;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\">B <span class=\"hljs-title\">b</span><span class=\"hljs-params\">(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>)</span></span>;<br>\tb.PrintA();<br>\tb.PrintB();<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"模板类派生模板类\"><a href=\"#模板类派生模板类\" class=\"headerlink\" title=\"模板类派生模板类\"></a>模板类派生模板类</h3><p>模板类不仅可以派生普通类，还可以派生模板类</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TemplateA</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\tTemplateA(T a)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;a = a;<br>\t&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">PrintA</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\tT a;<br>&#125;;<br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T1,<span class=\"hljs-keyword\">typename</span> T2&gt;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TemplateB</span> :</span> <span class=\"hljs-keyword\">public</span> TemplateA&lt;T2&gt;<span class=\"hljs-comment\">//类模板派生类模板</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\tTemplateB(T2 a, T1 b) :TemplateA(a)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;b = b;<br>\t&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">PrintB</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;b:&quot;</span> &lt;&lt; b &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\tT1 b;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tTemplateB&lt;string,char&gt; b(&#x27;A&#x27;, &quot;TemplateB&quot;);<br>\tb.PrintA();<br>\tb.PrintB();<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight avrasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs avrasm\"><span class=\"hljs-symbol\">a:</span>A<br><span class=\"hljs-symbol\">b:</span>TemplateB<br></code></pre></td></tr></table></figure>\n<h3 id=\"类模板的主要作用\"><a href=\"#类模板的主要作用\" class=\"headerlink\" title=\"类模板的主要作用\"></a>类模板的主要作用</h3><p>类模板的主要作用就是将数据结构的表示和算法不受包含的元素类型的影响，即类模板将元素类型和数据结构算法分离开来了，使数据结构和算法成为真正意义上的数据结构和算法，如：链表不再因为<code>int</code>类型而定义一个<code>int</code>类型的链表，因<code>string</code>类型而定义一个<code>string</code>类型的链表，而是定义一个链表可以通用于所有类型。</p>\n<h1 id=\"五、异常处理\"><a href=\"#五、异常处理\" class=\"headerlink\" title=\"五、异常处理\"></a>五、异常处理</h1><h2 id=\"1-异常的基本语法\"><a href=\"#1-异常的基本语法\" class=\"headerlink\" title=\"1.异常的基本语法\"></a>1.异常的基本语法</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Try</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x, <span class=\"hljs-keyword\">int</span> y)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">if</span> (y == <span class=\"hljs-number\">0</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;除数不能等于0，抛出异常&quot;</span>&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br>\t\t<span class=\"hljs-keyword\">throw</span> y;<span class=\"hljs-comment\">//这里必须指明抛出异常的数据类型，否则程序无法处理异常，只能使用这个类型的变量，x和y的效果是一样的，不能直接抛出int，即这样是不行的throw int</span><br>\t&#125;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;x/y=&quot;</span> &lt;&lt; x / y &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Test1</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tTry(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);<br>\tTry(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">0</span>);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Test2</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">try</span><br>\t&#123;<br>\t\tTest1();<br>\t&#125;<br>\t<span class=\"hljs-keyword\">catch</span> (<span class=\"hljs-keyword\">char</span> e)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;处理char异常&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">catch</span>(...)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;无法处理的异常继续往上抛&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t\t<span class=\"hljs-keyword\">throw</span>;<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">try</span><br>\t&#123;<br>\t\tTest2();<br>\t&#125;<br>\t<span class=\"hljs-keyword\">catch</span>(<span class=\"hljs-keyword\">int</span> e)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;处理int异常&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">catch</span> (...)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;处理其他异常&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight gml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gml\"><span class=\"hljs-symbol\">x</span>/<span class=\"hljs-symbol\">y</span>=<span class=\"hljs-number\">0</span><br>除数不能等于<span class=\"hljs-number\">0</span>，抛出异常<br>无法处理的异常继续往上抛<br>处理int异常<br></code></pre></td></tr></table></figure>\n<ul>\n<li>异常的抛出是可以跨函数的，如上面的代码，在<code>Try</code>函数里抛出的异常可以在<code>mian</code>函数中处理，中间跨过了<code>Test1</code>，<code>Test2</code>两个函数</li>\n<li>如果在一个函数内捕捉到异常但是却无法处理可以通过<code>throw</code>继续向上抛，直至main函数，如上面代码，<code>Test2</code>捕捉到异常但是没有处理继续向上抛给了main函数，如果main函数还是没有处理，则会直接中断程序</li>\n<li>C++使用<code>cacth(...)</code>来捕捉其他没有捕捉到的异常，如上面代码，main函数中只捕捉了int类型的异常，如果出现其他类型的异常则有<code>cacth(...)</code>来捕捉</li>\n<li>异常处理是按照类型匹配来处理的，即<code>throw</code>的int类型的异常只有<code>cacth(int e)</code>能够接收得到，否则就只能使用<code>cacth(...)</code>来接收未知异常</li>\n</ul>\n<h2 id=\"2-C-异常处理的特性\"><a href=\"#2-C-异常处理的特性\" class=\"headerlink\" title=\"2.C++异常处理的特性\"></a>2.C++异常处理的特性</h2><p>​    C++的异常处理具有跨函数性，这使得<font color=\"red\"> 异常引发</font>和<font color=\"red\"> 异常处理</font>分离开来，这样下层函数可以不用过多的在一异常处理，而把重点放在问题的逻辑处理上，异常处理可以由上层调用者专门来处理。</p>\n<h2 id=\"3-异常接口申明\"><a href=\"#3-异常接口申明\" class=\"headerlink\" title=\"3.异常接口申明\"></a>3.异常接口申明</h2><p><strong>不抛出任何异常：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Try</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x, <span class=\"hljs-keyword\">int</span> y)</span> <span class=\"hljs-title\">throw</span><span class=\"hljs-params\">()</span><span class=\"hljs-comment\">//异常接口申明</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">if</span> (y == <span class=\"hljs-number\">0</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;除数不能等于0，抛出异常&quot;</span>&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br>\t\t<span class=\"hljs-keyword\">throw</span> x;<br>\t&#125;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;x/y=&quot;</span> &lt;&lt; x / y &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>只能抛出列表中类型的异常：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Try</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x, <span class=\"hljs-keyword\">int</span> y)</span> <span class=\"hljs-title\">throw</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">char</span>,<span class=\"hljs-keyword\">int</span>*)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">if</span> (y == <span class=\"hljs-number\">0</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;除数不能等于0，抛出异常&quot;</span>&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br>\t\t<span class=\"hljs-keyword\">throw</span> x;<br>\t&#125;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;x/y=&quot;</span> &lt;&lt; x / y &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>可以抛出任何异常：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Try</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x, <span class=\"hljs-keyword\">int</span> y)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">if</span> (y == <span class=\"hljs-number\">0</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;除数不能等于0，抛出异常&quot;</span>&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br>\t\t<span class=\"hljs-keyword\">throw</span> x;<br>\t&#125;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;x/y=&quot;</span> &lt;&lt; x / y &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>不过经过测试，三份代码无论是否写throw都是可以抛出并处理异常的，似乎这个语法没什么卵用，可能C++11摒弃了这种用法，但是考虑到兼容保留这个语法。</p>\n<h2 id=\"4-异常接收的3种方式\"><a href=\"#4-异常接收的3种方式\" class=\"headerlink\" title=\"4.异常接收的3种方式\"></a>4.异常接收的3种方式</h2><h3 id=\"普通形参\"><a href=\"#普通形参\" class=\"headerlink\" title=\"普通形参\"></a>普通形参</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\tA() &#123; <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;构造A&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>; &#125;<br>\tA(<span class=\"hljs-keyword\">const</span> A &amp;a) &#123; <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;拷贝A&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>; &#125;<br>\t~A() &#123; <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;析构A&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>; &#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Try</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tA a;<br>\t<span class=\"hljs-keyword\">throw</span> a;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">try</span><br>\t&#123;<br>\t\tTry();<br>\t&#125;<br>\t<span class=\"hljs-keyword\">catch</span>(A e)<span class=\"hljs-comment\">//使用普通形参</span><br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;处理int异常&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dns\">构造<span class=\"hljs-keyword\">A</span><br>拷贝<span class=\"hljs-keyword\">A</span><br>拷贝<span class=\"hljs-keyword\">A</span><br>析构<span class=\"hljs-keyword\">A</span><br>处理int异常<br>析构<span class=\"hljs-keyword\">A</span><br>析构<span class=\"hljs-keyword\">A</span><br></code></pre></td></tr></table></figure>\n<p>可以看到a被拷贝两次，第一次从<code>A a</code>拷贝到<code>throw a</code>，第二次从<code>throw a</code>拷贝到<code>catch(A e)</code>，可以看出如果使用普通形参来接收异常，异常变量会由异常抛出处拷贝到异常接收处。</p>\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><p>将上面代码的<code>catch(A e)</code>改为<code>catch(A &amp;e)</code></p>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dns\">构造<span class=\"hljs-keyword\">A</span><br>拷贝<span class=\"hljs-keyword\">A</span><br>析构<span class=\"hljs-keyword\">A</span><br>处理int异常<br>析构<span class=\"hljs-keyword\">A</span><br></code></pre></td></tr></table></figure>\n<p>可以看到只拷贝了一次，即从<code>A a</code>拷贝到<code>throw a</code>。</p>\n<h3 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h3><p>上面代码应该修改为如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\tA() &#123; <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;构造A&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>; &#125;<br>\tA(<span class=\"hljs-keyword\">const</span> A &amp;a) &#123; <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;拷贝A&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>; &#125;<br>\t~A() &#123; <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;析构A&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>; &#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Try</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tA *a = <span class=\"hljs-keyword\">new</span> A();<span class=\"hljs-comment\">//对象必须创建在堆区，函数结束对象就会被销毁，而无法通过指针传递到catch中</span><br>\t<span class=\"hljs-keyword\">throw</span> a;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">try</span><br>\t&#123;<br>\t\tTry();<br>\t&#125;<br>\t<span class=\"hljs-keyword\">catch</span>(A *e)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;处理int异常&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t\t<span class=\"hljs-keyword\">delete</span> e;<span class=\"hljs-comment\">//需要手动释放堆区的内存</span><br>\t&#125;<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dns\">构造<span class=\"hljs-keyword\">A</span><br>处理int异常<br>析构<span class=\"hljs-keyword\">A</span><br></code></pre></td></tr></table></figure>\n<p>可以看到使用指针完全不需要拷贝，但是却需要消耗堆区的内存且容易造成内存泄露。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>总的来说，最优的方式还是使用引用。</p>\n<h2 id=\"5-继承在异常处理中的应用\"><a href=\"#5-继承在异常处理中的应用\" class=\"headerlink\" title=\"5.继承在异常处理中的应用\"></a>5.继承在异常处理中的应用</h2><p>在实际的项目中我们处理的异常并不是一些基础的数据类型，大多都是开发者的自定义类，这种情况在捕捉异常的时候就相当麻烦，尽管有些异常处理起来程序基本一致，但是却要将每一种异常一一捕捉并一一处理，下面的代码我们来模拟一下这种情况。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span>//<span class=\"hljs-title\">A</span>类实现输入一个范围在0-10的奇数</span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\tA(<span class=\"hljs-keyword\">int</span> a) <br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (a % <span class=\"hljs-number\">2</span> != <span class=\"hljs-number\">0</span>) &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (a &lt; <span class=\"hljs-number\">0</span>)<span class=\"hljs-keyword\">throw</span> LtZero();<br>\t\t\t<span class=\"hljs-keyword\">if</span> (a &gt; <span class=\"hljs-number\">10</span>)<span class=\"hljs-keyword\">throw</span> GtTen();<br>\t\t\t<span class=\"hljs-keyword\">else</span> num = a;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">throw</span> Even();<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-keyword\">int</span> num;<br>&#125;;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LtZero</span>//专门处理异常的异常类</span><br><span class=\"hljs-class\">&#123;</span>&#125;;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GtTen</span></span><br><span class=\"hljs-class\">&#123;</span>&#125;;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Even</span></span><br><span class=\"hljs-class\">&#123;</span>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">try</span> &#123; <span class=\"hljs-function\">A <span class=\"hljs-title\">a</span><span class=\"hljs-params\">(<span class=\"hljs-number\">4</span>)</span></span>; &#125;<br>\t<span class=\"hljs-keyword\">catch</span> (LtZero &amp;lz) &#123; <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;输入的数小于0&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>; &#125;<br>\t<span class=\"hljs-keyword\">catch</span> (GtTen &amp;gt) &#123; <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;输入的数大于10&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>; &#125;<br>\t<span class=\"hljs-keyword\">catch</span> (Even &amp;ev) &#123; <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;输入的数是偶数&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>; &#125;<br>\t<span class=\"hljs-keyword\">catch</span> (...) &#123; <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;其他异常&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>; &#125;<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>可以看到我们的异常处理模块相当繁杂，在实际开发项目中异常的数量远远不止上面模拟的三种，可能多达上百种或则更多，这是异常的处理将变得十分繁杂，那么如何处理呢？</p>\n<p>可能心细的读者会发现，我们在处理异常时使用了专门的异常处理类，而类是可以继承的，于是乎，继承在异常处理中的作用就体现出来了。</p>\n<p>我们再来看一份优化后的代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span>//<span class=\"hljs-title\">A</span>类实现输入一个范围在0-10的奇数</span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\tA(<span class=\"hljs-keyword\">int</span> a) <br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (a % <span class=\"hljs-number\">2</span> != <span class=\"hljs-number\">0</span>) &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (a &lt; <span class=\"hljs-number\">0</span>)<span class=\"hljs-keyword\">throw</span> LtZero();<br>\t\t\t<span class=\"hljs-keyword\">if</span> (a &gt; <span class=\"hljs-number\">10</span>)<span class=\"hljs-keyword\">throw</span> GtTen();<br>\t\t\t<span class=\"hljs-keyword\">else</span> num = a;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">throw</span> Even();<br>\t&#125;<br><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Even</span></span><br><span class=\"hljs-class\">\t&#123;</span><br>\t<span class=\"hljs-keyword\">public</span>:<br>\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">PrintErro</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t\t</span>&#123;<br>\t\t\t<span class=\"hljs-built_in\">cout</span>&lt;&lt; <span class=\"hljs-string\">&quot;输入的数是偶数&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t\t&#125;<br>\t&#125;;<br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LtZero</span>:</span><span class=\"hljs-keyword\">public</span> Even<br>\t&#123;<br>\t<span class=\"hljs-keyword\">public</span>:<br>\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">PrintErro</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t\t</span>&#123;<br>\t\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;输入的数小于0&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t\t&#125;<br>\t&#125;;<br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GtTen</span>:</span><span class=\"hljs-keyword\">public</span> Even<br>\t&#123;<br>\t<span class=\"hljs-keyword\">public</span>:<br>\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">PrintErro</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t\t</span>&#123;<br>\t\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;输入的数大于10&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t\t&#125;<br>\t&#125;;<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-keyword\">int</span> num;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">try</span> &#123; <span class=\"hljs-function\">A <span class=\"hljs-title\">a</span><span class=\"hljs-params\">(<span class=\"hljs-number\">4</span>)</span></span>; &#125;<br>\t<span class=\"hljs-keyword\">catch</span> (A::Even e) &#123; e.PrintErro(); &#125;<br>\t<span class=\"hljs-keyword\">catch</span> (...) &#123; <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;其他异常&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>; &#125;<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>可以看到我们的异常处理模块使用多态，繁杂程度被大幅缩水了，而我们的异常处理被集中在了异常处理类中，有时，如果我们的异常处理只对某一个类有效也是可以直接将异常处理类定义在抛出类里面的。</p>\n<h2 id=\"6-标准异常库\"><a href=\"#6-标准异常库\" class=\"headerlink\" title=\"6.标准异常库\"></a>6.标准异常库</h2><p>C++提供一些标准的异常库，头文件为：#include<stdexcep></stdexcep></p>\n<h1 id=\"六、标准IO流\"><a href=\"#六、标准IO流\" class=\"headerlink\" title=\"六、标准IO流\"></a>六、标准IO流</h1><h2 id=\"1-标准IO流流程\"><a href=\"#1-标准IO流流程\" class=\"headerlink\" title=\"1.标准IO流流程\"></a>1.标准IO流流程</h2><p><img src=\"/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/Snipaste_2019-10-06_10-03-47.png\"></p>\n<h2 id=\"2-标准输入流\"><a href=\"#2-标准输入流\" class=\"headerlink\" title=\"2.标准输入流\"></a>2.标准输入流</h2><table>\n<thead>\n<tr>\n<th>标准函数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>cin</td>\n<td>cin&gt;&gt;操作支持任何基本类型的输入，但是遇到空格则结束读取</td>\n</tr>\n<tr>\n<td>cin.get(char chr)</td>\n<td>从缓冲区中读取一个字符到chr中，因为C++定义的cin.get(char)中会返回一个函数自身的引用，所以此函数支持链式编程，即cin.get(a).get(b).get(c);b表示依次从缓冲区中读取三个字符到a，b，c中</td>\n</tr>\n<tr>\n<td>cin.get(char* buf,int cout)</td>\n<td>从缓冲区中读取cout个字符到buf数组中，因为函数似乎会在数组末尾添加点什么，所以实际读取的字符数量是cout-1个，此函数也支持链式编程</td>\n</tr>\n<tr>\n<td>cin.get(char* buf,int cout,char chr)</td>\n<td>从缓冲区中读取cout个字符到buf数组中，如果碰到字符chr则结束读取</td>\n</tr>\n<tr>\n<td>cin.getline(char buf,int cout)</td>\n<td>从缓冲区中读取cout个字符到buf数组中</td>\n</tr>\n<tr>\n<td>cin.ignore(int num)</td>\n<td>忽略缓冲区当前读取指针开始的num个字符再读取</td>\n</tr>\n<tr>\n<td>cin.peek()</td>\n<td>判断缓冲区中是否有数据，如果有则返回第一个字符，如果没有则阻塞程序</td>\n</tr>\n<tr>\n<td>cin.putback(char chr)</td>\n<td>将读取出来的字符再返存回缓冲区，只能读取一个字符</td>\n</tr>\n</tbody></table>\n<h2 id=\"3-标准输出流\"><a href=\"#3-标准输出流\" class=\"headerlink\" title=\"3.标准输出流\"></a>3.标准输出流</h2><table>\n<thead>\n<tr>\n<th>标准函数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>cout</td>\n<td>输出缓冲区内容，支持任何基本类型数据的输出</td>\n</tr>\n<tr>\n<td>cout.flush(void)</td>\n<td>刷新缓冲区，无视系统繁忙，强制输出缓冲区的字符，语法和cout一样“cout.flush()&lt;&lt;buf&lt;&lt;endl;”</td>\n</tr>\n<tr>\n<td>cout.put(char chr)</td>\n<td>在标准输出设备输出指针的当前位置插入字符chr，语法和cout一致</td>\n</tr>\n<tr>\n<td>cout.write(char *chr,int cout)</td>\n<td>输出*chr所指向空间中cout个数量的字符，即使越界也会继续输出，语法和cout一致</td>\n</tr>\n<tr>\n<td>cout.width(int num)</td>\n<td>输出num个字节宽度的字符，一般配合cout.fill(char chr)和其他cout函数一起使用</td>\n</tr>\n<tr>\n<td>cout.fill(char chr)</td>\n<td>配合cout.width(int num)和其他cout一起使用，在输出的num宽度的字符中将cout函数没有填充完的字符用chr填充</td>\n</tr>\n<tr>\n<td>cout.setf(标记)</td>\n<td>格式化cout输出，标记种类很多，具体的可以查阅资料，配合cout函数一起使用</td>\n</tr>\n</tbody></table>\n<h2 id=\"4-文件IO流\"><a href=\"#4-文件IO流\" class=\"headerlink\" title=\"4.文件IO流\"></a>4.文件IO流</h2><p>​    文件操作相对来说比较简单，总的来说就是5个步骤，即</p>\n<h3 id=\"操作步骤\"><a href=\"#操作步骤\" class=\"headerlink\" title=\"操作步骤\"></a>操作步骤</h3><ul>\n<li><p>​    包含头文件<font color=\"red\">#include<ftream></ftream></font></p>\n</li>\n<li><p>​    创建流对象</p>\n</li>\n<li><p>​    打开文件</p>\n</li>\n<li><p>​    读写文件</p>\n<p>​    <font color=\"red\">需要注意的是C++中文件写的方式是使用符号“&lt;&lt;”，如：fout &lt;&lt; “文件内容”&lt;&lt;endl;</font></p>\n<p>​    <font color=\"red\">同理文件读也可以使用“&gt;&gt;”来读。</font></p>\n</li>\n<li><p>​    关闭文件</p>\n<p><strong>文件写</strong></p>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;string&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;fstream&gt;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tofstream fout;<br>\tfout.open(<span class=\"hljs-string\">&quot;文件测试.txt&quot;</span>, ios::out);<br>\tfout &lt;&lt; <span class=\"hljs-string\">&quot;姓名：张三&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\tfout &lt;&lt; <span class=\"hljs-string\">&quot;性别：男&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\tfout.close();<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\ttest();<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>​    <strong>输出结果：</strong>    </p>\n<p><img src=\"/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/Snipaste_2019-09-14_16-29-43.png\"></p>\n<h3 id=\"4种文件读的方式\"><a href=\"#4种文件读的方式\" class=\"headerlink\" title=\"4种文件读的方式\"></a>4种文件读的方式</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;string&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;fstream&gt;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tifstream fin;<br>\tfin.open(<span class=\"hljs-string\">&quot;文件测试.txt&quot;</span>, ios::in);<br>\t<span class=\"hljs-keyword\">if</span> (!fin.is_open())<span class=\"hljs-comment\">//文件读需要多添加一步判断文件是否打开成功的步骤</span><br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;文件打开失败&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">char</span> str[<span class=\"hljs-number\">1024</span>];<br>\t<span class=\"hljs-built_in\">string</span> strs;<br>\t<span class=\"hljs-keyword\">char</span> chr;<br>\t<span class=\"hljs-comment\">//第一中方式</span><br>\t<span class=\"hljs-comment\">//while (fin &gt;&gt; str)//操作符&quot;&gt;&gt;&quot;每次只能读取一行数据，读到文件尾“EOF”时结束</span><br>\t<span class=\"hljs-comment\">//&#123;</span><br>\t<span class=\"hljs-comment\">//\tcout &lt;&lt; str &lt;&lt; endl;</span><br>\t<span class=\"hljs-comment\">//&#125;</span><br><br>\t<span class=\"hljs-comment\">//第二种方式</span><br>\t<span class=\"hljs-comment\">//while (fin.getline(str, 50))//ifstream::getline(char *str,int num);这个函数只支持字符数组，参数num指的是需要读取的字节数</span><br>\t<span class=\"hljs-comment\">//&#123;</span><br>\t<span class=\"hljs-comment\">//\tcout &lt;&lt; str &lt;&lt; endl;</span><br>\t<span class=\"hljs-comment\">//&#125;</span><br><br>\t<span class=\"hljs-comment\">//第三种方式</span><br>\t<span class=\"hljs-comment\">//while (getline(fin, strs))//与第二种方式不同的是，这个getline函数是全局的，且只支持输出到string类型的对象中</span><br>\t<span class=\"hljs-comment\">//&#123;</span><br>\t<span class=\"hljs-comment\">//\tcout &lt;&lt; strs &lt;&lt; endl;</span><br>\t<span class=\"hljs-comment\">//&#125;</span><br><br>\t<span class=\"hljs-comment\">//第四中方式</span><br>\t<span class=\"hljs-keyword\">while</span> ((chr = fin.get()) != EOF)<span class=\"hljs-comment\">//get()函数每次只能读取一个字符</span><br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; chr ;<br>\t&#125;<br>\tfin.close();<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\ttest();<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"文件的打开模式\"><a href=\"#文件的打开模式\" class=\"headerlink\" title=\"文件的打开模式\"></a>文件的打开模式</h3><p>​    C++提供6中文件的打开方式</p>\n<table>\n<thead>\n<tr>\n<th>打开方式</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ios::in</td>\n<td>以读的形式打开</td>\n</tr>\n<tr>\n<td>ios::out</td>\n<td>以写的形式打开，会覆盖源文件</td>\n</tr>\n<tr>\n<td>ios::ate</td>\n<td>以写的形式打开并初始文件位置：文件尾，会覆盖源文件</td>\n</tr>\n<tr>\n<td>ios::app</td>\n<td>以追加的方式打开文件</td>\n</tr>\n<tr>\n<td>ios::trunc</td>\n<td>如果文件存在先删除再创建</td>\n</tr>\n<tr>\n<td>ios::binary</td>\n<td>以二进制的形式打开</td>\n</tr>\n</tbody></table>\n<h3 id=\"读写二进制文件\"><a href=\"#读写二进制文件\" class=\"headerlink\" title=\"读写二进制文件\"></a>读写二进制文件</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;string&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;fstream&gt;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;<br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">string</span> name = <span class=\"hljs-string\">&quot;张三&quot;</span>;<br>\t<span class=\"hljs-built_in\">string</span> sex = <span class=\"hljs-string\">&quot;男&quot;</span>;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tofstream fout;<br>\tfout.open(<span class=\"hljs-string\">&quot;二进制文件测试.txt&quot;</span>, ios::out | ios::binary);<br>\tPerson p;<br>\tfout.write((<span class=\"hljs-keyword\">char</span> *)&amp;p, <span class=\"hljs-keyword\">sizeof</span>(Person));<span class=\"hljs-comment\">//注意这里使用ofstream::write()来写</span><br>\tfout.close;<br><br>\tifstream fin;<br>\tfin.open(<span class=\"hljs-string\">&quot;二进制文件测试.txt&quot;</span>, ios::in | ios::binary);<br>\t<span class=\"hljs-keyword\">if</span> (!fin.is_open())<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;文件打开错误&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t&#125;<br>\tPerson pin;<br>\tfin.read((<span class=\"hljs-keyword\">char</span> *)&amp;pin, <span class=\"hljs-keyword\">sizeof</span>(Person));<span class=\"hljs-comment\">//注意这里使用ofstream::read()来读</span><br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;姓名：&quot;</span> &lt;&lt; pin.name &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;性别：&quot;</span> &lt;&lt; pin.sex &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\tfin.close();<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\ttest();<br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n"},{"title":"【日记】在衡变的日子","password":"snoopy","abstract":"绕路吧！","message":"这里不可以看哦！","date":"2021-02-02T12:32:12.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n​\t从离开三大来到衡变工作到现在已经七个月了，由想上一篇日记还是在2019年10月12日写的啊，这一眨眼一个2020就过去了，在蜘网的余热还没蜕净，又到了春招的时节，该动动身了。\n\n<!--more-->\n\n​\t今年年初的时候的，各种魔幻2020的视频刷爆了B站，回想2020发生的事情可真不少啊。\n\n​\t2019年1月22日早10：30我在武昌站登上了返家的列车，当我22：00到家打开手机，各种武汉封城的消息刷爆了朋友圈，从12月9号开始的新冠病毒借着春运突然爆发，我真是庆幸上天佑我，不然我要是被关在武汉，都不知道怎么死。当天晚上蜘网的同事大都连夜跑出了武汉，不过还是被留下来了两个，标哥和静静。不过失策的是我以为过年只有7天假，于是就没有带电脑回家了，结果一波疫情直接来了个史上最长寒假，直到4月8号武汉解封这个寒假才结束。虽说假期很长，但是我却无比的忧愁，因为我不仅没有带电脑回家，我的毕设还给放公司电脑上了，看着武汉解封从3月10号又推到3月20号，眼看离五月预答辩只剩一个月多月了，实在等不了了，于是我只好忍痛买了一台新电脑。毕设….唉！又从头开始，于是整个从3月24号电脑到手到4月7号前往武汉，我就过上了997的生活，没日没夜肝毕设，回到蜘网后也是白天上班晚上肝毕设，总算是在预答辩之前把毕设给肝出来了。\n\n​\t这里放上黄兴灿录的我们的毕设的视频链接（自己懒得录视频了）：https://www.bilibili.com/video/BV1gf4y11715?p=1\n\n​\t当然有时间我还是要自己保存一份的，顺便把毕设也传到github上。\n\n​\t我拿出我的毕设时同学们的一片惊呼依旧在脑后回响，成就感不言而喻，终答辩也一番风顺，导师们挨个问我问题，我就挨个解答，导师见问不倒我，居然让我现场写外挂，我真是向骂特么了，还好我刷了点小手段，给忽悠过去了🤣。想想我的论文被我两天肝出来，可真是不可思议，而且查重也在15%以内，那时的我真的充满了能量啊。\n\n​\t答辩结束了，6月22号我从蜘网离职回到了母校，和室友定了9天的酒店，开始了疯玩模式，我是提前去的，还在超哥的租房住了两天，害的超哥小姐姐出去住了两天，还蹭吃蹭喝的，现在想想都还怪不好意思的😊。四年的书总共才买了120块左右，最可恨的是电动车只卖了20块，唉！现在废品可不是一般的廉价。每天和浩，狗儒，超哥窝在一块玩，很快6月29号到了，我也该启程回家了。\n\n​\t<font color=red>再见，三大！</font>\n\n<img src=\"【日记】在衡变的日子\\QQ图片20210202211910.jpg\" style=\"zoom: 25%;\" />\n\n​                                                                      \t<img src=\"【日记】在衡变的日子\\QQ图片20210202211325.jpg\" style=\"zoom:25%;\" />\n\n<img src=\"【日记】在衡变的日子\\QQ图片20210202211328.jpg\" style=\"zoom:25%;\" />\n\n<img src=\"【日记】在衡变的日子\\QQ图片20210202211323.jpg\" style=\"zoom:25%;\" />\n\n<font color=red>再见了，宜昌！</font>\n\n<img src=\"【日记】在衡变的日子\\QQ图片20210202211257.jpg\" style=\"zoom:25%;\" />\n\n<font color=red>再见了，2班！</font>\n\n<img src=\"【日记】在衡变的日子\\QQ图片20210202211250.jpg\" style=\"zoom:25%;\" />\n\n<font color=red>再见了，蜘网！</font>\n\n<img src=\"【日记】在衡变的日子\\QQ图片20210202211319.jpg\" style=\"zoom:25%;\" />\n\n<font color=red>再见了，武汉！</font>\n\n<img src=\"【日记】在衡变的日子\\QQ图片20210202211306.jpg\" style=\"zoom:25%;\" />\n\n​\t这本来是写在上一篇日记里的，可惜换电脑时那片日记丢失了，只好写在这里了。\n\n​\t在家待了一个月后，2020年7月27号，我来到了衡阳了，开始了在衡变的生活，来到衡阳的第一感觉呢，热，脏，路况极差！这不是一个好城市。最开始是一个为期20天的集训，集训的日子还是很快的，认识了很多人，陈龙、郭阳、彭紫薇、陈淼、温毅、蒋琨、陈奕君、李萌萌、张艳艳、伍坤杰。然后我们下车间了，车间实习可真是够了，我进的是线圈一车间，每天和铜线打交道，听说实习还要一年，顿时我就萌生了退意，其实在当初看到劳动合同上的5500的工资，加上不保吃住和大小周的暴击已经让我动摇了车间实习是压死骆驼的最后一根稻草，还好鹏哥出手早，两个月后把我和陈龙从车间捞了上去，不然他可能等不到我了。我最早一批进入部门的人，进入部门后第一个星期写了一个星期的编程规范，可以看的出设计部对参数化的野心很大，想要做无纸化，信息化，可惜实力不够，又舍不得下资本砸，开不了高工资怎么可能揽得住人才，就算不小心进来也是留不住的，比如我😁。然后我就开始了无休止的写界面的活，说实话写前端真的很无聊。\n\n​\t期间跟着陈龙开始学习投资，买了一些基金，但是不太敢碰股票。陈龙炒股确实有一手，他去年炒股挣了2w+，我就买卖基金就可以，至少基金比银行还是要好些的。\n\n​\t在衡变的日子也不能说不快乐，设计部活动很多，三天一小吃五天一大吃，各种饭局吃得停不下来，于是我稳定在110斤了，和朋友们玩得也很开心，但是呀，没有涨薪途径，这里我可真就待不了了。\n\n​\t今天是2021年2月2号，我得春招开始了。\n\n![](【日记】在衡变的日子\\QQ图片20210202211300.jpg)\n\n","source":"_posts/【日记】在衡变的日子.md","raw":"---\ntitle: 【日记】在衡变的日子\npassword: snoopy\nabstract: 绕路吧！\nmessage: 这里不可以看哦！\ndate: 2021-02-02 20:32:12\ntags: 大事件\ncategories: 日记\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n​\t从离开三大来到衡变工作到现在已经七个月了，由想上一篇日记还是在2019年10月12日写的啊，这一眨眼一个2020就过去了，在蜘网的余热还没蜕净，又到了春招的时节，该动动身了。\n\n<!--more-->\n\n​\t今年年初的时候的，各种魔幻2020的视频刷爆了B站，回想2020发生的事情可真不少啊。\n\n​\t2019年1月22日早10：30我在武昌站登上了返家的列车，当我22：00到家打开手机，各种武汉封城的消息刷爆了朋友圈，从12月9号开始的新冠病毒借着春运突然爆发，我真是庆幸上天佑我，不然我要是被关在武汉，都不知道怎么死。当天晚上蜘网的同事大都连夜跑出了武汉，不过还是被留下来了两个，标哥和静静。不过失策的是我以为过年只有7天假，于是就没有带电脑回家了，结果一波疫情直接来了个史上最长寒假，直到4月8号武汉解封这个寒假才结束。虽说假期很长，但是我却无比的忧愁，因为我不仅没有带电脑回家，我的毕设还给放公司电脑上了，看着武汉解封从3月10号又推到3月20号，眼看离五月预答辩只剩一个月多月了，实在等不了了，于是我只好忍痛买了一台新电脑。毕设….唉！又从头开始，于是整个从3月24号电脑到手到4月7号前往武汉，我就过上了997的生活，没日没夜肝毕设，回到蜘网后也是白天上班晚上肝毕设，总算是在预答辩之前把毕设给肝出来了。\n\n​\t这里放上黄兴灿录的我们的毕设的视频链接（自己懒得录视频了）：https://www.bilibili.com/video/BV1gf4y11715?p=1\n\n​\t当然有时间我还是要自己保存一份的，顺便把毕设也传到github上。\n\n​\t我拿出我的毕设时同学们的一片惊呼依旧在脑后回响，成就感不言而喻，终答辩也一番风顺，导师们挨个问我问题，我就挨个解答，导师见问不倒我，居然让我现场写外挂，我真是向骂特么了，还好我刷了点小手段，给忽悠过去了🤣。想想我的论文被我两天肝出来，可真是不可思议，而且查重也在15%以内，那时的我真的充满了能量啊。\n\n​\t答辩结束了，6月22号我从蜘网离职回到了母校，和室友定了9天的酒店，开始了疯玩模式，我是提前去的，还在超哥的租房住了两天，害的超哥小姐姐出去住了两天，还蹭吃蹭喝的，现在想想都还怪不好意思的😊。四年的书总共才买了120块左右，最可恨的是电动车只卖了20块，唉！现在废品可不是一般的廉价。每天和浩，狗儒，超哥窝在一块玩，很快6月29号到了，我也该启程回家了。\n\n​\t<font color=red>再见，三大！</font>\n\n<img src=\"【日记】在衡变的日子\\QQ图片20210202211910.jpg\" style=\"zoom: 25%;\" />\n\n​                                                                      \t<img src=\"【日记】在衡变的日子\\QQ图片20210202211325.jpg\" style=\"zoom:25%;\" />\n\n<img src=\"【日记】在衡变的日子\\QQ图片20210202211328.jpg\" style=\"zoom:25%;\" />\n\n<img src=\"【日记】在衡变的日子\\QQ图片20210202211323.jpg\" style=\"zoom:25%;\" />\n\n<font color=red>再见了，宜昌！</font>\n\n<img src=\"【日记】在衡变的日子\\QQ图片20210202211257.jpg\" style=\"zoom:25%;\" />\n\n<font color=red>再见了，2班！</font>\n\n<img src=\"【日记】在衡变的日子\\QQ图片20210202211250.jpg\" style=\"zoom:25%;\" />\n\n<font color=red>再见了，蜘网！</font>\n\n<img src=\"【日记】在衡变的日子\\QQ图片20210202211319.jpg\" style=\"zoom:25%;\" />\n\n<font color=red>再见了，武汉！</font>\n\n<img src=\"【日记】在衡变的日子\\QQ图片20210202211306.jpg\" style=\"zoom:25%;\" />\n\n​\t这本来是写在上一篇日记里的，可惜换电脑时那片日记丢失了，只好写在这里了。\n\n​\t在家待了一个月后，2020年7月27号，我来到了衡阳了，开始了在衡变的生活，来到衡阳的第一感觉呢，热，脏，路况极差！这不是一个好城市。最开始是一个为期20天的集训，集训的日子还是很快的，认识了很多人，陈龙、郭阳、彭紫薇、陈淼、温毅、蒋琨、陈奕君、李萌萌、张艳艳、伍坤杰。然后我们下车间了，车间实习可真是够了，我进的是线圈一车间，每天和铜线打交道，听说实习还要一年，顿时我就萌生了退意，其实在当初看到劳动合同上的5500的工资，加上不保吃住和大小周的暴击已经让我动摇了车间实习是压死骆驼的最后一根稻草，还好鹏哥出手早，两个月后把我和陈龙从车间捞了上去，不然他可能等不到我了。我最早一批进入部门的人，进入部门后第一个星期写了一个星期的编程规范，可以看的出设计部对参数化的野心很大，想要做无纸化，信息化，可惜实力不够，又舍不得下资本砸，开不了高工资怎么可能揽得住人才，就算不小心进来也是留不住的，比如我😁。然后我就开始了无休止的写界面的活，说实话写前端真的很无聊。\n\n​\t期间跟着陈龙开始学习投资，买了一些基金，但是不太敢碰股票。陈龙炒股确实有一手，他去年炒股挣了2w+，我就买卖基金就可以，至少基金比银行还是要好些的。\n\n​\t在衡变的日子也不能说不快乐，设计部活动很多，三天一小吃五天一大吃，各种饭局吃得停不下来，于是我稳定在110斤了，和朋友们玩得也很开心，但是呀，没有涨薪途径，这里我可真就待不了了。\n\n​\t今天是2021年2月2号，我得春招开始了。\n\n![](【日记】在衡变的日子\\QQ图片20210202211300.jpg)\n\n","slug":"【日记】在衡变的日子","published":1,"updated":"2021-02-02T13:51:19.028Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckko29br50000pwr7hthl4tkw","content":"<script src=\"/crypto-js.js\"></script><script src=\"/mcommon.js\"></script><h3 id=\"encrypt-message\">这里不可以看哦！</h3><link rel=\"stylesheet\" href=\"//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css\"> <link rel=\"stylesheet\" href=\"//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css\"> <script src=\"//cdn.bootcss.com/jquery/1.11.3/jquery.min.js\"></script> <script src=\"//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js\"></script> <div id=\"security\"> <div> <div class=\"input-group\"> <input type=\"text\" class=\"form-control\" aria-label=\"Enter the password.\" id=\"pass\"/> <div class=\"input-group-btn\"> <button type=\"button\" class=\"btn btn-default\" onclick=\"decryptAES()\">Decrypt</button> </div> </div> </div> </div> <div id=\"encrypt-blog\" style=\"display:none\"> U2FsdGVkX18rQfjFO1C/rINoxUf1ORs4hbrQZDK3hA8LUE0gcrb4aPXvy/Q+i1KUhhCMHojB+nMXskPgeHJxyDfFzQ+7gs9NmRXHNKTteUlYCo4UMCpula7KQ1LNjA7LrSD2YwBF+0Js3V6wpoWuqEhebH8NS2PVnrHBkLwwODgUoPuSa4xGxDwuxup4U5KU8d+f35uy0S3Q4Ks4ySH3miU8rdTXDkAJN8eJjSFhbmQjdxO9FIBlbvswjrJ10hK6jr9UzkY+aEcIUCfNADvME9udoyOShF/Nw8WrwbKglTcu1cUTau+Ng1xnUGHyeCNds/cERKu5yxP7FQUeda8uADD98HwgwiG7jedXDMjw+Dk6RY44yl9FfZBXBnj8/r2Ipnnun72rEdmBdBKGLfUwL1EWz51WdE47WL9Fn9VZsO9KGJZvKhD1B0Xpk5f08LuyNrJTpjV0YTdYrPMYCOfSv5wmHu0D7trSkIqycJHU4xn0KrxZDwAjwR02jSo3Ihm9uUggANhebURwzXPColC/EBTRwKtGmst4mZdi8xBAcYyVHkycQA6oWveIz9ldCr3wi9vwhQ4LgRsKpNwk2gIM3RidbHJf/R1dPeYHHe0flc2AoZp1gvE+Yw0/JxAtnClkoL13LzFIf/HTIX/Ow8+GzMmd4Yw7oj4qy1BUDv/YluAq04sIMFzkmveio0YfDoTgrz9ioygtrOe/Qof2AD+0U1/Y4IWZgxJabLMOSJQ766ANbgC7EFUhY2MYsfPp6h3piOsX3nZfOf5IvAMaq5sDVgQhPlaXLOm0EXvJG/Jfd1jpLkf17gQkWNNAVKECFaabJRY4Y2vP2iyhRnWjbHBfhCuen5rIeVj5Bcs+LIIHl+Icw84d8fpDLetc/dY/bJu3a/jTBq7wTHB5WwRlXzcVrkEGxYHUaKuAyn45AIJQyt4Gv8EU/bDNrM/iQpIEuQkCTV2zU5xX63UiLO7OSoOUs1cD9eZ+HOsNN/8JCilGxNmT95SW59Ain8ywZwahdlr63ytRIPhrv0UF+wFsjSBgHIvcfXrxqAj8E6HAvjZmGLH83Ujc7oT3ytpcg2UOJ8bknAqiho/OHK/mvm6IFbxI0MuO3mt5U6IhGgkbjLtd3IA9mhV8ahqNyRvvb/g7nbxfo3SnDIpQxJFYCPWAlPyegjzOAdacqt9BDDVnrdZSkV9a62BQqXsvgidUwH6zcpg0voQhDXzqbThe5im+KVv3QKKtN4OaAwGo8Lp0Y9ZXxIAoY4N5lsLT4B3ednFwEPhOgYSCxLlEA6Q5MJklnntdDbqAhuQUmqTyNqesUA4Co6xIGhU7Tu5xRNuoX1XUDL0VAprJLnitiKbm1QMjUSs6RS0Bhp99X9W/f+kYEEBtL53i8LZxxSQ5oJmIWPh/+UZgB99PTjvSv1WBV9hey4ty1L3XyCXAu2ZpJypaVjc1PthNmld9cbxA0lydW87YhN7I0fTcrHceQRgLpWFFfWFoCO7RDrruuLi5kU+AL3gB8nHskQUHPKLwGNXCsO1mOzeYzWx804yIOzUURz4HCiAU4W8IHpp0HpPGYFfE35irzOUZIWdqzWntg9wqdBTTQQLKQYqO1uspk62bcRFvRsqby+/OsK0+D5T0ckJo/M2H4eft8qhae4cv8dNr/pLLU+qgBrLB45WFx/uUasS96rFoTVVLuDTIAlQGl6nlM+FSzFhulQSvzT1dVDHfHcs3iloRQ4/m6NvC4KZO308PBm6UsWQeQfRPW3c3RIa8y0rAD0QfJnxkQQgHncAJY4s8yRxuyO3Cs8e5tX6mCKq6SVvQsLDOXo6FuvqiFXdqwWyUDtlGbN+3j+msi1YH+iKXXSCm5oLVtb25cNUv5XdH343V2iIDmwk/N5ExWFyh3euEtv9lW6ISFzME8RmDAylutEP8GA4LW9wrX2bZ8J42LMGVj3zA2VV5eqldxxcTVyNcff4ftoHYQynHI2hErk4owNy/xazCPCXK/e711whVEu2vjtDmLxryLDzwHYj1Id0LK6/lUYS0JttxQpGqfFwKQlfR2URx4LrZwq57+J/m5B+Op/xlCP8XfZbw1M69o/bhhuWj4zWgAPGKG4W1X9iG75vzTTM4p10I5YvKyPLS4yO6NBOnDVotTxM2wrSz/3H3QJ1jfIPtVyU8GAN6v3fk4t5dUH+80QM8F0WREQjoNBUVFdkSlXsMW5cw1/rWQ8r0EJnWsxFUajuoNoZZVbKTcRnAPRI63aIpW99rLsAY+Osk1ilSuA0cBULk+lMCFhIHLlohWdcnveY3CDXqBT9Ef2xU6x8jg6TqnDT6eVO9IU+9az238nVBb4PYIzsswPN6r7zvO8ZS43zpwTAU1SHDdMD1/UvxKOqJh+wN98KBcZwfEkj+QZghstzq350ctyUPov4YfgltCbgtVkL8/nLNO4b4fukU8LtSNh3kY3y6dyYGoD/vDAcjGAXa9VOCBuHoxiRRSkBk0PDglAEXW6Fd2zgmTZtANDCl0YWAaLtEdn/nFs8IY5TRocsXrb5CPCf2fLh5ozljlPNvjHqyEVWMn+jD4Jy+DLR3bYeF7XIBM/WFZXTaTSGblQDRCYhQyHioxtb4doRe2leUOFLxsRMTlXA9ntJ0iXLuaGqrtPARzPNh6xDOg9CFum80BFWqCoPgtiI6a5iI6MBZqPhshH+AbvONAz9qznt385Ax2x7t4yVD3cNltysKZpHpDriGCRGmfJTnVWYYICCazZxBbwN/2oWhxXKYMudqMNc7WeaSU64smISVCam6Z543Vf6Q4KzDpsKUJMDd+Sp7LRYuQ+Gdl6tN0OULGVhbVo3XUXeUGw7NVm97+Yv6c6VoG0np0XFSjPbVZA1dlwL1ifDRNIFN850TCBjsRogtZPmILHmmQgLAgKBMhEZcnj2WC88zRPxh79VfpiJVZjmBqUd1Ignp/ZTzPbiSU9RPL1X4+tyOnQ3wkU0noWruKAStKQG25qQx5Q87Oi4BDGhT3I+ejSpN1fH/yYG4XSvojrMhcUYiPKjR8GSrbN8mNygdPkPSx5Jo8dhgvZZ4Rzm8EgM2+CTFtGAjKi3b+yXi/ZIYdjjCt3c9rw1UV3PRb7ap/DGJj9S3Vbw6xHnLMiH9QoUrZ6Vi4gjaI3+R3hPyAU7v8BJsS8waeXlIkihQaVrEfPJPIfIAQDCYTEdo9l/0HeSnzoZRzeuMMjsgFrDdXx0+m0tOiWoAOHXjG3jvSep2Hm2kw+Fkpq6JPD40JAxjkXYzz93vqjGg3JcLsFSNXNZh2g7C2kNQ3SGedjmF3wSAKp5Ll3kAmP083vQywwsRGQK+BOFCgO1yki78Rk3JgNxGX7E3mJUZJUFbEDmNguAM4osbxIwecAsg2C3HMRVmZ9+zfGxuj/LtBhmIkYYOXug+h+CIJH6uDotZYDv8iHqb8GdpfM2Rp+CH5VKD6myb8Nzo8BGovbJLF3wpM7yqvJt2cjo8OBVKHRNgzqxLincxdmvVangXP/nWN1rwf76C5gRBldrATGD2aCeywJIM1QfOoah5LFl3TVrv9uvCcBB2d4tvGF5AbD/2lCPEWptA2qqilLK+NlNcDMStemt/bFHndeRlHgmAfG2FthLM6F8d9SBUtM40pAwFJJmtxWFraz75wDW1lQbO8+G9kf342BM849MX6MehtKDVWDoMY5yPjpbzNWCIGPEa4IJz5JBTIFG/yZI4V9mXz2Y441yBqAd6a/7aSZpvM1PI31ZpxDwIZzHBHo+c68pRXvf3nOOS2BMwZ1f9jC/6TbOPR6ymnuPyjT5PG+O256cQdUaGUEE+PUlcaXBPQl92iQxu8gq+sn3zZmKRYPdM+10rUd8lLb35a/73ckjdeACFLrOf5WCryR6P2lrgl0ejGE4llMwSXfNb14HY3Hj9RGuL6DwgGQ5leiWkxqeUspfn0VPB45ORNcD8BQLby0yryq+a6AqHA7EBtpgXBYnFUFDG1ow87MNuPqxMOdl6TUA5RKzPIOvDX9O7flOYrQWl3iNTpVGSa4z5zOu2vNxFO1nP4SEt4PrZJLk9PmYxm7UPjluqb57btFvt3fHsh1YzXj4NOo9Ao8UgBA+VMhKKjrTdjgwhmBPqzlsNbWtbd8BbY34R116GFZ6W2gRiyZx3tNr4BkqsxNf1vF4wJwuDSXSea3JFiUMgYdiAYV5zkmbvWG4ZZu1GGWfQbB8yic2AzTXcGL+P2ZC2J3Uicp1hjorr+8h4/TMJMi48f2CAkGHF42RMvALj+BMs+wvOuzADRwfdPxjdPPKa5Nk9w1yEPYcjHWeRK0RKCjJfZpgmWL2Ti68H0LrYftTnlS1KKL/xRiP5SfOLYXsTAZZ5Zw+Urg+EE6mj5mjY8NeUcgp0e9+YSKeYNt/LlFJXYIzqVXg5S1VcNfSwUs5J0/wYiNyo2l8RAbfZ2OP778I8FcdNZfrf9ziO6laYWH2mfDf1FPsksA+p7EHMAb4aTePJatscCxjc+MWN9Z4+MECfl5jaodG0U7jWrlQwGFl2JJRc61dXJm48b5hkkQ6WxTOCj+sVXZfxebC1Gd3aGgwQk1AS+Y738BKcDjoPuOKzL6/bYBC0gWt6E4Uf/sEFLl3boqOssssK1y3grW6of98oOO3HrCga+9YCicS4Aq29ytLmL2WttKtW1X6Jg7ohCFM7Mk1c9Racb66gayg5f5ihQDsIMBbujvZxuPloM4UqEvSCBmxeEjARBgIH3gxfzxlkO1nzZ7BlGUduEzzgzKq5PqRyHtX7lR2dvmnC+7Et2gQ9/pTy1Oe4Ky1DW0n9IW/+88scbY4uJ/ma1wNq79GIlf/0zuOietjeTkdEbkPEInULpd/A20bDfbZiwwbS6/21GMKU0dVuz3S87wVWJvvsZSXbNjQi2OfES8XBWrO/TlcQ8mllT0so8LOk+NuRee4oYGEjKpl+qYpH6c7nuAxW81VzmACQqEuoXBVH4akZ63EuTjNktUIKy0yTaZbdjmx4flOkt4czL2E0459YYTdympel258r2IQZowcPM3aDr8qwZpWkfG9oxwSDOCgMN/8Z0x1G2WfKASGC8N8wixvY5ULOr7SEa27KKFNHHKcVc+qPqDaPpfcssi8ZB+P5HtLBvtXX9iM1FnsvDpkwJHGtuCTWDZYn4iQrqKTSaYJR0XVCCbvNtBOJBtkEORYRTlv+rjbpDc25FpY5tcSGaraSOswtNAK+swZW4Vs76IjyJd7ECoQdsCLii/Xvyw73omFdZZkksaM/PWE5PMNq+mLt17TvFSGzrsa+5GXKifjv0I7xln6Wsu5LA9m1OYaJaVEl73AqJ8X9UPN/TOM4hm0oMkI0UA7ps7tREv4PJUCElcXR6qehWqky2nrWN/9QA9Mo2HMYgeBUQ+WNQIu5+6xSMq1iq9zHD/s9bA9bishEGGzZXl9rbrDTxqYtEz3P0f2tnn+fhcoglbqNcBX8/EnlOdUNgBVVuWQEsrKzKofUMkWPnB+tequMvWG4LagNFuRnhy/A7T65pqTufqABseIDBU/TJ0EQOgacNDaEB6pt4t1e7HDr6xmH4V14VlZ4CIHhRL9lAdKHfW4YfQ41jVtv9yt+ArdPc9JUxidmb9g68AA1ewrCbPy0Uu1+SYYqV/pDXcvBnojU32mnCUjmFMOPYYeRD4mSSJ2Y28fqqQlS1WOYTqryVKHgLmUKfhtOWCl4tQFqZXHaP75dI4BFoNzPliG0TprTpCflWoaB6GC2eefCLk4aLH/QmazHSaLNOCPLJtFrNh7quUljzQKxzTBoh5okdhCDiVKMD90ZmgcKDUJQttE0WSPsT88xfdRTu8eGH238xdmwj3go3mMTmzUUEFs0ox6LavFxtMC54sf4bW2pGVu4TLEA0LNC4XXNoo9O+xsSrMyZR4++3UDCvlA2YiH5qs7Wy7G5DoBKn3c09zzhPwIUDO32ipMSX/b5xuG6foaMa/LydN1SKbIMPri7oWUo8OLeeuxzN+Lk/NbWyoJgtCMKLjeRZxacFu06C/CmeyzPetvDJUZUYcNQShQwc29INxqtADPMDZlGlIfmksWfP3DlcvWn6G1oQtGKDekt+Ifl06VkRXWjFumHPyzJ9ko+q7Ugw86n54Z/uK1x1IwrOST3oy1bvNg3/cy4yj4UBYPMCdFvLoB5a5CLupcwyKAi7yfxNjdc4f28O61Jp1/5Ixr0KvYYUr+mZZfPGQ1xeY3n/aM71kMNyOQTPeUKrM1Noayx9RIq9/i8pdOOl7pmS9hUAfPpaN8FGI6ps/1DoQ1FfW/omKsn/7hbocLMvEyjxRLH4HBWm3DbvsmQz9k/QhMvNu+wPN9OhXd2t8XtjZmoUdUw0rXWokbofTgqPc7em6Rbd0nupE9CHzprXLuVYkYj/atXu8w0XgwP0gUDQJfNtiRKbZB2a/ByMoKtYW2JbEhm94FKnxMM4TLlEOnhRMuUdL8tq7XaADtlH7sairl7K4YUj5YdgRXkXsFhNAX8x4gcip5w1sILcXvGS8vtl3EI/cqGCc/ZQCz29FctiMzV9gqHR28kq9ASEVtJRB4PUZWu/mgh3jIevNBD7De2LGuFaGzsndGn4CY2xoarWM4KdnPfVr2M1UjF20fa6SVIRCZq1pt9nHUhfp13ncBF/Vz2x85QkH5A58/RHD4b+60jH+02fqLtQh7fsaMHYI6a5FwdT03ABjsEvXxh8I9LYl6UVYBWx0Am5P9b/Nttvw/HW8ibu94AOeyaqiazOMFu/7XJvHIa313FTmpaH0rKKcFzdWdypridLNdeB6ABgD8u8A47Rhu1HQgbAn71HS+VXf8ZpXRFVjJLwCvBqpA9WNh46aWwRjwwz+AaiUh+lfHhaWBMuRFNlbWhIo1U1GTEVtTQqTrfl8P4erT8hFuG7yfrqGCeCdkIJmDWADm8fNwveC+e4bgXZzYOLcOasRMJcYKNA8sfnMTHLAra/KydEA7r2tSyeFmGthgRXer4nhHOdW/x4iaze5vNR9XJU1fmLFH1RB5rgPXoqZE5/l3RxKatzkWJNYePEF0cKRQ5lFGOADjAISoD/XO8RX+vpqq/coxkrOXytr7urxSrCfE1MlkL8o28wm5mk2Y03QJZTVWVa4aCQDAY1L1m43lBo9OWjR4rVTWv5w2nmST3scC8J7mhAgkOUGqz07S+iDle3w+/3hid0VWCF0sQSdEIQcZPdHeCsBIXs9IxdPwb0sm17Mch8220TojgjarVp0cYlzNrX2PIjmdbUrLyky1mphdoI4CN1wyS9q98MFXqGVQDqWtDUKSCcv+45QyOrtVlTOSU3b0EtKS2jO2vfDnoSu+8gGL9uvyCM7CJ5OzhV82obAQA3t/Tak2rP28ARkDR0v8fA70EWvgLAnRx9fJvSu0a7YnQRQR4qzmpdb3o4KQnCAekC+xlpiDw9GhWq2TcXALr1UibUsFCMzQu4zCVb88bNbawpavsG27IhJgXbnsWBDTrzOa/be9RuxcTx1WIBgRehl0tVkrSH6HI+1c3taxmPKJI5DVtEZiOLW92yy8dzwjLa4LPNpVDxs49lyo2z9ss2P/YsdQqlyN79JtAWYJPd1KCMp6+XmOqrYmx89yBpcpB0hcUmOnIbI23JWtMuMjKjdZo+I5IhWZzfeGf+O4QlBL18RKunvCU7n+ak5706fp9RTBujip4ZFE5w7GLkY4NGIEsMn3ORDRwlMmTpCid3b/zuurkfk5bpcd0DFmdKzMwLU8Ut4rZ+We56rwEz53K4xWaBnea3kEHIvlgVtIWvyx00C2opbwX9sJ11o2y96Vo44iB1qF7d26n7m2976Z1PbsrJoP9eUQiowRY0ctNIxW+8ob0R40H9A2BJndDKP8hQyvxjIGcVCYkqHBcrRtKXsT6PwS2CprG+isr/2vijVg6Iy4NUT+0YVV4Oc2+deW1it4TODuaH55qkRX2jWuuXhsvAhbT25/hPjqwpItP9ZsHN7YNI3uHamB+srHwjOf+H1AIWxjHQ9JucEdOKTVHkn94HyPRixYwxOTyOa4VjN4y6aUjTOKaZZNn95U3JWhtI/tkM5jlx43K59hq3o4zGuy2X5kgKC8z2mwf/GLDBjHq8NuJwEJtiq95kvp7ir2ploOI2BO1aeZnLbmrD++1N5gFbVB7NwA1yXdi8NUzRFkSvGHGYOzB2PrjpSnMxKQM3sdcvXi41DS/ebET4ZcHqvsmkJVfqjiKVjaTaFyuYOhus/j0kh9et8LKYg2PSia1y4j6MFxBD696lbXnijhV+HsV6yiTopvHuv+wjFkZtwtNHOkkJTVzablhjaBpn4qPHvFfjv2SCMrd1gA8yOhOeb4mpR1JAJVgplCJjAvXcYwSEoN03ne8a3x8gen4+unMlkVasloGZ0Y3DS/Bz+QO+kQAgISyjd/PaLfIlRbdpyP8nNcBIy0oNw3Cmi+zQQI6Y0gNxvyCcEtMSc4ZeJ11U8PaJv6Qkzg52xhYmAGJ1JDLk6JB9C1pdopU4Kdvjyyqz8rg8tWizb8bvm9+4iNAWGVqGPOY/0k6W7LBwEmkIupVLTOwkBk42sKYrCnzSZ2RfRD2/csf1qFAXhJcAkHatA6l+ni4yguB/QWjomOnjxcvm3KNgsE7RzaWEwn113j4/Z0/EIkKGBp2+XKvldT869sNYrEfAl4yXphkkWVovE1fF4lkqsOQx8VdN1RWwI2yjQAJidxTOztIQEMN3gIMVSXKQ7UzC40te48nDSRRANblgJ1hGoKKkZxi7Ua8yQ+hOOpdZeIranZ/W5AjlJd0x6+mkls1CExqejpHPVZxpz06F2ssnYg0u7QQjZwL6ek2nuDckFo9S1Uo+DguFv6VZC7BOyXcXghtb0v+KdZ2GZYke7k8647o6VCDoDYoLJLnp8PSdq8yMVsDBcT9fT7astj2GYPwL9UBrLKnc8bNMF51gZ6BpHUdfq06in+Y5Cvd+q6r8BolwHgXaTUt5XcmthDwpanQz44pzea/OojOpHmoA0Hnx0dBCu41X8aPBx5wXNksvu3GoUSGLXBq9c4DtDVr12pKP6RTQoW+A/PJbe9CVG9c05oLdBjK6KZdM4Q19INXtupYA/l/0B2C63kXt/NnrAaJmUGEJoAQILKNLReLDpgDq54CBEYeVGig+R60VQB4hw0bA6bpjMJPCH1FbKVs2pq7gttBAhJYCcxD1ylajL4LTYPCc0FN7DALhZh+MXRYF4TfEnxOcxPWj4AcbZNq5D+o662VilzeyU6QUd3x7xCZ4sTqwsA5+aWp3J9xQfyl3Qv32u2z7XXxupP0ogh2qoLXvD0CMSx3LnWpBeWFM200j3WAMbt2sykdVOizxkeoGVZekwJZVuJA70t9aNFDfS7iM1f+KYAEyyCu+1fctqzNZauNgcAp22cqjO7o/wZYgh1BhkjGGGlppE44IfkPgZv5Je7avKRKUBpKkwdyfagde/2nLpUL3ezXZubfjcaYsks2qfemFwMu6pxjz3sQuUHIrZkmd4v9SPW6NuQxRDaumz99VONaLV2C/0IjmgwG1HhNNRxdfu9lSYmsxaY3yVObJWPcCFXGzQq/uErgTapHyfpVcecgkfEnXOlq/rfZbTVKc6IAI1f+gQZm7tY+B7rnvTcW+H+GJ1V7bYGbzYY6e+LxgIFjYlHTLHXKwah2+nj710OnF/Tna4ihKbGPLH2HwMffG8mNKWyj3AnYqxZjtxRDHH4eNu/G5XHNPMtfObjOWIhOhvudV9YNZs9CaD7P42meQtOXipAsvXb5dy5yb5v+5Gwrjq75vtAYkaCWFIAFpKPeQ2qeH9nW5FCR+E6RXejPnD6xgYvjyQwC6QVpAVvq2icomVCo15f3hKmeQClJEpTIZsyMLZYKtxoSASr6fXSC6DPkRScSc1Y0tCEQ3jbOYm2rfUrBflvtwLH1yiOqwsRK/m7BPBp0tWhk1hQhqwh/uNlPzg1cULYdnYLZG9EurLPG8/LgeyNks+qQ8saP00Ixe2RpzHYx1t4sW2Zdd6lJQonHbGKGNa9z6o7f1x5ge3OUfUkxioPawV+wakeHz8iqw3xE5km05XThXF3CHQA5SIA4soQU4GY1OoHsuH9j6W+VwhgJ8iow49o8zZCcjU+0fLlRGOEw59LIeYNR36CVF88kB65beREbteBXDLfBqDbnjWm8AEtBTZiFEaZwK7cS4U4Q+mb9+IxU9VuMhhZR6GvYoNNZim0NcOnE00XoqJ4Ta72/G1IBiDk6S+rsqWtT9nImwA31huKXQj/VRy7NvAOVc1E+oq3ZBgw1hpnhNAZ45xZsE72EXDY521NRJSi62zzCAe+SKY/rtxMUM+Y4t4zQIK7fSaG/fLoTeWrkLEuQlSkD8WP9hwX6RRU9l0HMFiT+bNssMfm+zmfDlBxlDOaylSF9HaksQtrlmXwc0Zj5OoFjtGsain1qMjJgZ59J58CHeN/uGQaQ/rjK9mG8+wPIqg50Bh5EzQeaASy1/lLv307/tyvLuGiCvZcA555UPMHn1dA1a/7rk5SOj9llRdOwRd9uzbX4SjS9W2EGQ2msEj7/luRG7cd5qDKrm0x5ei1R9VZD+I8ANyiZtvQCRFI/OE36ns4AGKWODOzIXD0pHXfaBRAkvTpjSYRbFXCCnUsAEKqigsQ9C5yL0syWrKseFhIaBVk4wrZbGKiLaqYL8HRzMaTMVWBbjcRgs0CPYzA0NX2pakJZZOZTob9J1z677rNT/vLq+v52H3zdyLEFbUpgg9/LB5B7zmWe9DTLrBPKviK1hpXze/iqR1xnXTgUwnoxhePnVSmACoStPqfxL7wy2bkgxKTM9jp/vsLx4D7dUg/Yr0coFsssx0CFY3b4nhjyizGEMrpCHk2AcwymL8v2+IuexU84DNOc5Avw2CbYa82WEnLHeD2wd5KsWThTBtltJG5P2OEB5nhBC/NUqyQkDOaHni44GWhU8zhB1f5S1g0eG17VSiP5CO7mMhVNn4b3lfdMsdBMRjOl2d6gFfCAaXxTqnZfoqY/LseJBsQYILXXNuFoKZbP5q2A7LTY2IuEBOiZ097rVuY0UUhgAVOBdGt+ucrkRQaxU3nQaPS8EbrM+upGjfg881hBxc+BkuwuesO+73u4rka/W7demwVbxhP5pbMTwoknGk0OAdjnZaMWq8OkKVGZoRvrwPkfeZZFwwBlrOruV8JnIZDedBCuO6o6S69FE/bAVtaOg5AWNIXSpIRkU8guorSzOqJkTt9AlNkxVA8VwI9zSYoSVfhA+acwU9IgpQI2t31weWmyyvTNtnW3lIHZzVrPFsLE3A7vxbq5MFyXRORz0o7Z5Y7t/7M4peXEeYKhcDv/0PLH3Yt3UKoBpeDQDMPxa1rMSY9+9M1VkhMkee6T0u6l4eiLf83fZoJ+O2Ai5uIKE09UFFwqAJ5OAlUIbdRYv8WOj98xZRpY4vIB84C3yCLtCh8gcgsEkNKM3jW3LsTuRXGEQXf/3Kxh0gX2EWAkJ+rXX3pzGs4kz7GLOqCQ0o2/XAFTEzsgIKE2m7ciseGdCjSDdK1aLkstjZIrlkauoYCbTfrILIYhXQ/A7Gw+Oi5kcx+hAj34X7cagc3UMGJjCt/Z26KYHcoAXi2KVrqbEle9lHAdr/CJuuuQ3mPvpF4a+X1LoVCH4pVfBr9gq+Lp0BhwpHcUYIjApvMqkwOtnmGxC0EM52by0+9eU89kWCujqZP2VChEg4GC61hJnZ06vJMhQahaLpRkgeCK8ed8LA10MwZ/3p36iZRH8/UXnwbL4ORM92spWynA9ihvOm0YdZHTnamQFMIyj4X5izsdzYUJvGbBsAflT27RQNoMWuV6xhOM8FJYpQOXE1xExgX2Ra+X1+JtHejZugz9t+xE2E4IE6x0brZLtBljeuOQNyv0nu5Ef0pGYhnI/oiLngKc9XGyT/XRbMA52HMNiuAxFfMJd0T3qxR1WSdFgryiocifXpOQv3D+dkr1+4WYpicwm+1Loo1ZMaVGaNu2RPP2xRHNrn4WogI6oHvHunXP86gvwx+mMa+al+NgXh9ZIjT5YQtaR1GrfbDEuPFlUcUVG/6HcxOQFW6ePuZo4vmtiubrxHYO+pEfQkYU6w5ueZ3xS33fAwvKNHtiqZcA22yAve6phLEUq3/mB5TAJbTP7fEUpRkbWTX6MOKz4hVw/nH6ciD3FUBhHU4LIK+nndPp2bsR1UW23v6DkltIpQ3J3mqrZHZXwnAlgjDrzY5xEh/doct8qr+7i4v1yjUoFL5cSc6le3JN1ACrbX5/BcgvDsQmshZ17C4Mk8PaUPycudJNARF5onAM5kTIKkfpVqXpKDcnWd7nShTvJ3Xxi/sp6fYgoEO0v+9vpbSBxnXaPmmp7LEHtXdBHFKtEYCHqHoO1/eIbvtNf12OVi8gHzULmDOwOW8JfKc4iQshcDwXujLS9AtB79t4jrHduky3JrmOhkYoUydWinO0UQro4kOJR4YTeRgWGFlZA4j3JQSiCZ6WO0eSaXAWhvVjUqe8TDBeEzdflOKMrDDS8+mV5DCLoosPRP9LcQD2pO0ns5bqROIp2v0cLoGj57eWtpcMAA/LG0HEsVHorcRjp9SDnOSX8387Ap0CbPoU9ifzG2lGBUJyyJCZLLDNcSwpoGRD+AHp2IRYqa+1BPVnmF40fu5rnA26PVP/Mm/q0OWMrgSMXHOZgyRtU3BbykMX/r4AzXfmw8yzEIBnN5abx34/0fcru1UZnnyS8lqmKWVIFMsUz1cb/B9xFWsskDlkzsaRtF9qFM2QHBWTVGjfPZbgeIwN5TDQOBMVO4TimUyGs1L48Qw4jxm8tIOzOKHi6GmiFoLSaYLB73nOdyTquFbKv+r/19eu6hjHhTKCEX3HHSC53liikZrxTIp/yNKrzfgm0idD8YD+MEQXF/J9A1XeYSiyRkbjg/1yK6cBU5TGxF6K8kCSMkbte01rJfJrzmQuMJCESXd0etWn4GHo2j/6UBI9yst1fJ9WD41GJ2tyKH9yIyqM1VYJABULPfw+p9FhV7DETlbUd/YqSeelBzm/5APVB3lfmDQMwd2WCGdZ2czyrLhfwOenYt9/AsARkGIpXVd9DQ2DE/WnK8v6PYs9Tp66QV+4kwjt/jpJa8iptQUyaaGYimJWXeiSZWK0h0xAI35cgXO0bkUYMs7GKgkmgCcVFcaTSYjvaOjDnHz0TE4r9a0fxmSjrCCRl9NBxzRzLnmCTRHj3ABpoK8fkzjrsi7iX5mRBBxNTb1aQONPGv3aRkyFWhXfzDrVZo5qOZ4+3er1OUYX2CIoPCJlOrd/vA6/B5VB2gESjGMxGgXwzU5SWMygnnBGLlkGsA74ioZYB1U4fo94ZoZKV0KS2k1RIHEen1J+sfut82xPMANDaK3VohajUqefGIszMov08onzHvuGXkIttUjICZRzDO6ZmYQA/an7S+mYsYJt2jhXTbElft7sV4y9IVj0wT+WXIHuK20n7A+WJLUBLQlGGV/+82wficaIjX2wI3dmx2TyeKysrdeywJwNB01l3rdCL9mM6TiWlZ6jNmqheG/JMyem338LwSG9TzRp0FO9e21VXGU2rDQAFZg3LRnnlWI++nkxmG14h1LFgBI2CfWq1sgRSOkl4R/fmJHHiuCpGLtr+JYEGVRcZ/EHPzZEyOBDKnp1L+w0RhdHQFLixQwZZOzrRVkLf9RIFTj1f/VvmcHLc9W1RMxC5X0wY39mODGPuDi7oSkVDiacgKN46MaqEl8zMObrYvgGLezN50OiUbtHm+iANYhDxCBE8AybCf/j43aLTRKMpS5othJxIMDlijAEVmWLr6uboYhzqlm3ClhMiPNpUK/ArGnXskwi5jGFCtGFbQna8/Y3l1TPytGDEnMNaDPOJkLu14fzKko6AsGekky6BJsSTIA4erusJ+sPoursF00vGGEiOoPNX5i7aPzpiNPbFjH8p259ji5vLoHKctJz+LZUrenYDqQETeMLdQKAON1d+x7Ta9TeSSHmA/bC633hAING/vViYfRgeP9uHIvqrS2cuPjMxRXOJGqdysrZZ7B4GG3+/PCDPbSx8zBWQBGGi249cN3wzz2xnUPjY9PSJSsIwS7Pad2lWfEP2ktnVuPB58lTZOljmYCyNjZLhkEHQEYxE2He7HPk26xDp3c+FxtlRVdqvxQtX89FgSnZtRpB5feSty19NzhNoM3xX8rBQkNZURF+8Cxm0/F+nvJKtKf7Jh2a70EM1LG+MJg6Jh17yAk8GFlUpoxw18Jp2YjMmBDyDH7pTyL5YlbJot0D1xk6ENgPVJc322KeysLKLsEJeUpNkVxNcYHJ4tzV9UosoomHd52owvuxtD69oAm9iiR+J8UnPuXmCwmdr6KaaDOAdb24HGbTzkGJgFJY2wo9DkQv7eysj5pPuIgZ5tR1NDbliCJGVCZBwGcBWPMpQoKm2dbv3Sd8hpfvuUuqKFg24IzTX7JX/PN6dY7z+IkWvMCGO+RlCKWI73YnlrGPWgMUWcUqJNmxSnDxqt41sM9mKg4ejquycOvzafG+0dxNkiRW/3bzcM8i5DBTV3QsrNvGz2jErLcGVaZ/83zoj2D36wtdMZU6uEq5a52vBojdblZPChQDpKkZR+eOljWOYK7sdHwwoNGBuGT9wkOYyF6kXXlXdxERa4w7fGS2L9/DbLObYZuTLE0lY+mWWK6W7AHQAfVD/ie/a7NSWrVW8zxYQkOuCbNCmEmUEnHzFJkHXRmxCb3OpWPkzm9z2QxcCNc2tc5VQTNF+J9JeFqkFIKvpR9ealALFKZJ2Vuhj1ZLJa53lAY9Lp+zvqmEsuEjVye/+v/Ehy8VdsH7ZbYcorGSAgeEo1JdN2NYTdBdDr2n8ULzwFtrFWTfxZySQtrPzTAkzQuHGvffVmnD3eQUoY5XapKBYZheSAHSaje8PFZvDfVMZlpf8jVIWe2oZyXF90X2friU8SlPbcZdvFkZQO3XRXFG9n3haiKjDvh8Zp2Vi8tW2KE7JbD+8dAjHPUgNPB4mE3oWV9v75kKYnaCrXh/sOL3ALQy7HHRRr4auk+2srNSMiIAV9u/SZGdefPED2QOmXC4qPZuALe5V8TCm+phxYzAx47XaU1GE8BPP5PxcZm9U77NsYxTSP0gcdZxlchHRwSrojoKxezqTVw6pOIfaWcZ2J0MOKTFS5FLuYmJBF/Ip09TgaYZP2ALLcSayT9ybaU7NcWSLPfwg1k4wpTtQ42N6nRx4Yp9i4WDQxtR+pEmMux+QdZzjqaaPd81U+VhSi/cu4/7NSLPWCWg/SPcvLjznYX0vnGdEsOFTZTrT9msWk54sTUpKnJNXhfPRn0o9367ZQ6A/3F4komBV2ojrdTFOjs8J3m9E8KwHrB/W9e/GBVQhT6OXdL365C6n2ID6H1l7LVbsgq1SzJ9OzzISyXNy81Rx2kud4ky3OozXGxuDkDKjnx7EttwFyuo8x/uoPo9u4bkV4H7A9wjC00ksvJODbnmAoSZlUg7EekYDfBvs4PfLVVKOKQk3+HMLU+PHxBRwArHXNqw3Tgz4LJ+HdpiAed9uMZQZce3XWnJDs633mUE/4zNQfAVk5PC8kNvvNJTEWmi17cyhMtsAUduCelRvM9DtPLp30jPTmEFLt2LCwOHl2ux1uXJpbUgw32tKK+0wy0BX+8QWmmKReztSrn36bD2zSkZ9HimM3cqBr9CEh3UHwCaeSJQVetvhOriRZLkk+lbHGLzIpHQIjOHP8eRUh7otqDhUcfJFt1pjkc/FnF1rRrs0c3LQR9sx3k+xoqvQTove9htvpduuOlS+rp7ifu+O4nK+ngfgWIJ3qOjLt8p8+vvm1kO9MdgZbirpPCz8OVt+sHr2PNiRAwEbLLgufTGvflRmIed+gVMEQJBSAcFUoiF8wK4qGdvpGrkx59C4mOH/RSOyzXkFuY5tziR9NH5ONYVGE7owxq/0VkRTz6VflzsDOphEaOqXLt8TGegBCOgje9ZN/e76BJttoWPK4BVO+PDc+gmtwgTd6St/VRMX5YmmYmLK2VPZBshqZNxCk7w36n1vTWOUsftwA8xyONZHej0bcphbn9khAjYo82WusNBoYU8NjpjpH4I2iXkNgCYr8y3QdUaAlBthKIakp3wu9dRnfLVv7QmuOEHx483Y01mrJSGdyhOz3wTOTrBxyI15ZQo/bwfEdQqPHQIrMvNKZcTD0VquuqVXZOQw7D98UgvT4GVmI3CAfr2F4wv5rIJSGvHskHhmhcIHSR7vM7p8+p533kftOkY0t8Us/BIyOQY36TbT+6q7CeioeFlIbDaEjLzsvfhpBau2z0HBLvVbpN0fKK7QZnfw8z040uvREwrjjSRVA+zwB5HZLH0yTb2808KTmhZfs8qMQwkyI0SRgUmhGvCsDhfT+l0y8UQD7Uz7JJykPhDRswAhdOEDIpAlkW+V/Wsqy1MBvbmVXUcLZW/ba4GbI/FKABkhlXITZFqr/z/mNObprqdOFEKw3MtHlbp27j/eaArJA3KYDTAtFzSVvcMLuloLvmVebiHpQZDQy+mtcFRocVCSC7zdJWwXI7rnpiN2mTOEu4boJPmL1MAFGTuFavVwZZ27tXZYcTl3MOEgAij7KBLLk78WuxGUK3xLv7QahxwL+5e5LPYP/duzyF6lMqk/47qL+/AC6w1GKDCSYIKiPqKi+jnuakfPppbZFlMqMkEyC0yYaHZzVftI/JldLS4yHHZzFHG4Fj0qdAWurofj1+1nPvQ9U5gSzepIbCibbV/QIFwzod3GWXWM9pHWupQDnYRUODsSdkdseuF/bqk0G3TmnY+xIMgwMio/077ow0NR1rtHvk6VCGKT1ycP0vibyhJfdCjL74f82YZnswpsI0gjUH8BVsAzGUOn7LU/athvzNPJ0+7+QSrnA5Z7OSp61stjcg4jKMtWcvqmDvvx1Cjvjko0hjm4Pe4w+93620as5X1GjFybth+eq4QSWtvKhxoePBxKTVu0L2vEPmh7EbfNM5xAkI6JVdeHfNQpM+SNehAh3zLlSuHLXmg2sYC4MdspVyZ//BWiuU03A/vo3Qg4tbAFxDntoGNQliPLoQeQO2LIittgISlwO4mFZEOsPPrdW122hTsQt5khWehjDpahUm2YI9S6qQoi+lMV3cXccZisVDOme0Id0myqUm4KRVBhunuOaMRdkbypOL6++qljSJnK6pbaaBznaR+tusP2b1gOFLLGiV7ct9gC2GwmhsAOM7DmtzTpoIQFYUwptVjFwfhA3iv7xSqCueWXEEwJRQDNVeY/tPbwgKopdOIVcCQyXZcAG43rwzqrFghVRDOlQej3wktb2CcbLZ5UG4TkKPNhCO241addNMSCDcorkZoCfFp9gfkfovHs+AjorKVg7JfbqATyXywZldyUzwZeQOHFecgM8qFsUj+TROA/1Ps+1cr3me/NQz6JufWtfKH65TOYiC3A7rgoP9O/+5kWBum51Agb+3wLgmhyj4rTfm3UEYvqUvchANigdxBqbBSYTwHcLN8gmmxic9I295/+XT8IRdbxkEYTprT1amgaAB2Ud+c0stTI+bOZgURCiH9tkjvWLISZJ6PSyu09so4CgYEWCxvFpRWShrjDRxSTHGMQ9wv9NIGAGlGPL608d31T3YXZRyaGseHeDOpIJVszogu0+C+Yq8Fy1+vtefHEwxlvhE/IilZ/9NFIfMdnw+fzYJ4Tgrb4ina8Id3/w21GX1OZsYp5F+ejE4363ip1+8U0DsabLPA8zOa1NRFkfRyQEdO1pn/UtMQEcRjsKYJ/wLbWZyVKh3fzFA5HeSeTPXkpfzgeR4BI/NmSkUAUpkfyYZ1+LBCRFbIoUmHUxOYFBQzqaxoxbLYDzP80h+JLvXYFqFcF7XRufl7KkbAFnifr3BxeY5EQd2+bLXh2chGPX5D6CwwnsbzjXkAqmFVykvDSk76TAMd3R3A8LG9xf4Hy74fjr1PGj8Ww1J0qDyPlSf1F1mo+hNCGJJx5zpJlYz5f5kdxPI2KZ2N3UCgKFxtmbuH4ZuogJlFbdT4rBIgRLX0rHslHh50v6L1GNXirmThOwqnMUjPiQQOe+dLD3soGffcW5XAKXQOKcLiliq8xAp8sxkcemIxo8cGSS+0ct0o+Oob7V/EppcdM29wqvagDjfL7WENXPhx6i7MY93krmy4c5ylVgZBeQdiMrT5CV36zW0TZgSshg4C7hwm1Lc3DS1OCVlt3S27sh6WQ3biW2+Ny6e/EB9HrWwfF8Lh1/Usj66DnpBQaW/SmG25e0tAHxPwyRteiU3s2eDSA3K4hdt0+38ROrjduhd57Yp9vMJLL4PgSeDniZbTIBKPFjinc11oTWBsaHlXOyO/3QvskcCbeZCA1AIHzibrFmmj+h7/n5A0PrB3+bgx8Uf3iYpnRbLAuhr7B/DZHBHya/9sOb4OIGlLNbDRiRLNPD3BADqe4K7TPfBYluhi0bpV7wnylDzQwMsdWDlm6f6rPkAKHDb/WlpIx45T9EfVxHq05aXP2U8WgeLkARK83kK+GndBvwthVkfwsIQmg1j4S/dVwhevoTlba2uorb/riCBt9u+1p0N5MSglEmux4RK1jre8xAJcR7sL/lnVpnQvIrG1KOsSTWvIP+8a3mUu0OTnb1IX/WXqzUos86fz6/ADK62w4mU6oU6ve0owllL54uiFOYjXbYLKrxE6uFRg6Xj9uaLo95y3L6jdQs6cSGm7GNxeuSznB0GEPS+RVN7kH6G671nfN0D/q5nNlwuPSV2Zzj83eIIt27VSikfjoh2MdNx5ZXjESRAi/n0YoXZ2Syp/zgiKg6BBXV0yKq3vU5oxdwNkcwM1kKzpObYvqVFgEXhRUfM8QWddtJJBNHnwbHC1R56qzaFiCug/GkKGsA+n4owoYEIIXuSYUZBFO6xGsBqKBvr9+TVs/ds9S+xjaIINRVlmQW6UNezqnX+39GMeu0feCFzob+ZvyEhmjRnuLmAea1TqjxuFyAHpvHfzW3S3bw+KcXreME2DoaZbcW42N7rwWi6ZboaQF7n3oVrf36+67ZBUghvIElqShTaeP5fEXFHqdt/qzp0T5DZgf2Yr0fPA1c553NyYQDg0ZdXL27RWn2JSFOz4VSDsPFlUmhE0sCIAeqoQ+CU3HMtnMwDFUPCDt6RfqT4p+Ka+WsegUxs/eHQSFgIxX+XhnoE6NCKeBTXxbFEpyB7S11Bs7GY/S7sfT1yMj37HjOyA47FsZDk6hL3roHXFPcAttSQmlmbPBRnQMRzsyAmQFEkiQNA/EvSAjRa1zfRMiVdbA7FXWFuc/EsBNMjKbGlMW1tb8mH/Akw7Z4Sgyn70SJ3UH9sm8DUBQDmByLi9lOINK26Za0U4VDmcyYAhZA+bO+s4c4+KfhOa5Te6pLtYYvxZ0z3fiysXRVmLyf9VNnG/Fe8ow1OXma4mqVOmyAk3mDymHql0q/Ap9240mZcx2B51oAecWHrKp/+B8xqfzTNlmZlTXQSyvCnRlXjPRVXxa7djGVIPBn1VEvnyYKrrTFY6Pvdsk1rQWwRqDlpeGSKdQkRawdutg+t01oGH9dj7vqIAA6qHyt+aaaVHy+6l5jJnoVIOgBcANhlMkLrpTwBdwvm+3O5IHVNDdsAC/M1SAyZTpHjV0AgeGF/jaPgBgDmEE0rie0EIkkhiluhX4ZKvM7gFpCqKxST4vYqhFz6ZFkBjAObAI4A8OWg+zUm8ibBZr09FJVRr7jwcMWuhiXkYAIlWM6ARY1qgPTVAZLWdUeuNRZCKHekbWwyZ5nFyPkkbiP0RxYuk2senCiR7eOLYpbWemkHZJCioOMXX25T7O+X/GCF2sS7ZYT/dhNqRK/Wlhum1izb6sXIlDcvDw8yVjVbrpQ/ZhKEtJ4qI5BiR9afsqCzZ+wmEl2r8/nCMRGdILy2PJzYisI2s1ZMzrlPZ3kbfIViCNC5rsx2fS4wN2HCt6IRBtp3SBf+ZxuysK/xrHuXYDdlLmFbryiJaOeM2M8+EYjbtdRJ1iFG+stn2xY32dJR/1mLxBGon8gZDqZtwn/m1NdE8UTRoNStwelUgxObf6Y4H08Ta1qJRd4pcyIfHWML32KhAqfIiGtE/eknWVUd0HXFXCNDqkUcFrVcF01iMcKezR6quQL47E2OIUGPMZcrhcsO007eMNEGpmEagyaJK4pI2HP2PNvgvJ82ZxJOuXBcUp6BRYTGakfVcqxu9UvmhQYdTf5fSYKLbOph6EYn1JpmWskd1vwo8Ubd+UIqInPDvijwmLVxdwoxoFvkYJl9xlIwRkzZRCHduJ3exM4hzcKeG/QzgVY9lBkGES4BrRxLCa2lbQcfTWijJY7T/WvY6QMLOGt3ASLzZembgat/JeqSya1+duG+WAh8qfa4JFCuEIA7n8dniV7UiHCku2A6ulLCR5zeMY5DAqtuSRAQBBhJ/Crl43z39GgQyU50B6LWuABXoIZ9YTzrb346aKNs0u0xyn3IHnh5tVzy0XYzugjqGFbNnbobKXZ/9wdUT6TwCrb/6+Bd0cFuf89imNHkJLPyzEafNUXo9lJXwSX+EvZvW1Ob2DfRe2JHmSfZ8lqc5RRJAdk8bard30R+4lDagNHL2ZDynpzf7BgohUOyfwkBJl0nMSyF1QQqbrIsup14VdL4ZpRL5jIE/+7F3KsKkinEs31pZtFwT5POl2x4pWh9958Ndsot8mshTEhtZz2ffA6/yLbb+jQOyqMi/X7IZSJZ0pah+7RUPrMmMoTrQDY1tbH24bZbMLLYiXPwqqRXFHypl1fSniYc+ZjWpc8yyAoXMhfU83ReY/dpx8E3jOiaHHx31ULegEwd8GxkgwU4oYLTw9rDDSn5UjvAtCNi1wmqUREGCqys2j1H2H7XXv47f1SSDQK8wTCGgtG8Z+QQ+zRJR0U8WA4fYgrtfUUPLskFpNoXJa2TjyezS6Mqg3T26i6uBE75luNt1TUU9B+UowGH7zgcy5KyjvyFWEI8XMhrOoVxdur4o94I9ACdvQSW0rjdg7Az2frfB59HTvjibHKr/u+e9OWwPTZPxrIaOCBM8AauSEhQvT6Mh8e4RdHKGLiHgYBds9RLBLeGnaY05+fGQsa9WF3+zTll1VUH07EHNDNK1eh+GxFFf4h5mKJQWnAVFPkobMOml7NNkX+yEAIRdLp/Hsci6pE9c1HupN53/tG0rFvbjb5T53ZQ3Gyg0yS8ZHe1ECf1NvC97j9PyLyvVMQ2jjhKDuzagPVbXvH3oICEw5/N5uhvgWzw7ndt/wNxXTvSfqAPR0jZg3javhgnISIEH/0Mi9KpxtdJvL+iv7xYy6op7VpwX9XGfU+G0HJ7XzzTHFXZzDnAAdZXUmx1I1zmdptGyXHiM20dMQQXmK+ausDgvmh2lcFmVllLEYalTvzVrkd7ml8dSfOnpnnFLw2iM6HzXw7zYpjW21y6/16cz9vuEVBGRqMBDalEEKlKR1p8NyvgV2w4U080lr0ogbc+lwNz/ehba5oCp9LxWMmu8Iryp1OVzu2GdRir+0GmN59z7Xe34Y/gIuGiJK+tTQBrjW1PKKh3RsQnCOQonJdCx30jGvdKyoZaNDf2z6wRoeUzWlX7JkBEi25ZieP+nEhzziWCbY3y/VLqrt5HkJPROB2/KCO1oUQncWiHugwr/uWuFqAOSKC4lrppGlkGluX+rFdgyPzo+PXKA/cLOyzgl/75oZMnSiloS/BmIsoiMa2vAiZbGpsK41/191J1qRw3qt5DatrWyUTNSJIvCpkSnAdlz4qAqcNKZ8LKTzUyJ/Wu45CH8BipdzDC+A9Dvpsi5+f6pkAzC3bvNe8LqSAz8fYzl5glotAnjGlwoIGq8vg4NRkdNCe5Tvd7lacdtroZPd+bjhjFBo7wrsg0287q1RYpGuva+AC9movB5/6WDDw4o5GzYo0In3jTpfC+V1GUF6c+vBJLrAepfRw+4/hI75Fb+EUL1DcB6Jfqj0mEAEsydiTiekaunaN3QrBR3GW714Gj4SRe4kqNou3JLfyIQu8NDCi3ff7yNopRcfgicKjhEcK0XY5SJ5skJ7ryWwnWrjH1bqYaQU9o9Tmhd7UYp9c1apC/BQ4mVPR19W2/lUMGNKUGnme6bOgrPNB18xuleY7ueJc5d6ZPQYcCT7tonFE5vjznyxU2H5jpeu0y9Fjcv5vhUjPPZTCKEQqk1HwQpygkALpza0x3Xjp67gewpyyI+KJJreKMSi42mO38PjxljA4fPUTqVYR6BsZ80BccSvBrtKYz8bbiTtilm7qyf1V+0l1kBXXQ5mSj5jQKZ7qSFhifn1+dwnz6MSQZ2qB37Drr/esH/FlTMvLYg9GBGJs42FkRIhaTQ78F+w/7dNuDA5wB+3iMQ6zWQ9vDaKUvaaC2gePLNZzSfWOzi380MqjY33NVAB0xKpShRkx9V/SDXsgbfwR1NtesbUlCcv0gXDsCFuk3R5USsqZgZINdmYq+y/Gw2uJ+WCdt96cKB4pVDwR0/JV7BmlfAMQZlGjr00f3c0dHZdhK5jzygetJrjQaAbyYwSbqG+HdTVNCMgiYFbCwzZs+0lclqC59zy1XaDDoCmevTft11VEZhbgmrskLVBr0vJtc9qavcD0Gf8azUH8NlEaGGbm/0BvQw3NOJc1ITlP7TS5gYPz7yS+3t7oQxkx9MNi5kNvMJx15A/KocTBieyw6ExbXBJqYZsS72pIMH80Ya5SBtl4N8HXswqecAtKGhwnGHesfXutm/ua0L685HYKlv02hfiRYshyGECGmXwDMNno2KA6G2zMAtFFRfinxkoZdBIM1Ae2rDGGTiJwfpm27dXM4VvI18Jo9WgqTO+EHgE58vI2QgE7x6mLks21hOT9kCnauplaKFN1s54t565NOUlFp93Sm8uxJR/nvINvEERZDey1Bz3c8NXQubkjv51Vrn9ARB5U2Enk8y </div>","site":{"data":{}},"excerpt":"绕路吧！","more":"绕路吧！","origin":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p>​    从离开三大来到衡变工作到现在已经七个月了，由想上一篇日记还是在2019年10月12日写的啊，这一眨眼一个2020就过去了，在蜘网的余热还没蜕净，又到了春招的时节，该动动身了。</p>\n<a id=\"more\"></a>\n\n<p>​    今年年初的时候的，各种魔幻2020的视频刷爆了B站，回想2020发生的事情可真不少啊。</p>\n<p>​    2019年1月22日早10：30我在武昌站登上了返家的列车，当我22：00到家打开手机，各种武汉封城的消息刷爆了朋友圈，从12月9号开始的新冠病毒借着春运突然爆发，我真是庆幸上天佑我，不然我要是被关在武汉，都不知道怎么死。当天晚上蜘网的同事大都连夜跑出了武汉，不过还是被留下来了两个，标哥和静静。不过失策的是我以为过年只有7天假，于是就没有带电脑回家了，结果一波疫情直接来了个史上最长寒假，直到4月8号武汉解封这个寒假才结束。虽说假期很长，但是我却无比的忧愁，因为我不仅没有带电脑回家，我的毕设还给放公司电脑上了，看着武汉解封从3月10号又推到3月20号，眼看离五月预答辩只剩一个月多月了，实在等不了了，于是我只好忍痛买了一台新电脑。毕设….唉！又从头开始，于是整个从3月24号电脑到手到4月7号前往武汉，我就过上了997的生活，没日没夜肝毕设，回到蜘网后也是白天上班晚上肝毕设，总算是在预答辩之前把毕设给肝出来了。</p>\n<p>​    这里放上黄兴灿录的我们的毕设的视频链接（自己懒得录视频了）：<a href=\"https://www.bilibili.com/video/BV1gf4y11715?p=1\">https://www.bilibili.com/video/BV1gf4y11715?p=1</a></p>\n<p>​    当然有时间我还是要自己保存一份的，顺便把毕设也传到github上。</p>\n<p>​    我拿出我的毕设时同学们的一片惊呼依旧在脑后回响，成就感不言而喻，终答辩也一番风顺，导师们挨个问我问题，我就挨个解答，导师见问不倒我，居然让我现场写外挂，我真是向骂特么了，还好我刷了点小手段，给忽悠过去了🤣。想想我的论文被我两天肝出来，可真是不可思议，而且查重也在15%以内，那时的我真的充满了能量啊。</p>\n<p>​    答辩结束了，6月22号我从蜘网离职回到了母校，和室友定了9天的酒店，开始了疯玩模式，我是提前去的，还在超哥的租房住了两天，害的超哥小姐姐出去住了两天，还蹭吃蹭喝的，现在想想都还怪不好意思的😊。四年的书总共才买了120块左右，最可恨的是电动车只卖了20块，唉！现在废品可不是一般的廉价。每天和浩，狗儒，超哥窝在一块玩，很快6月29号到了，我也该启程回家了。</p>\n<p>​    <font color=\"red\">再见，三大！</font></p>\n<img src=\"/2021/02/02/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E8%A1%A1%E5%8F%98%E7%9A%84%E6%97%A5%E5%AD%90/QQ图片20210202211910.jpg\" style=\"zoom: 25%;\">\n\n<p>​                                                                          <img src=\"/2021/02/02/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E8%A1%A1%E5%8F%98%E7%9A%84%E6%97%A5%E5%AD%90/QQ图片20210202211325.jpg\" style=\"zoom:25%;\"></p>\n<img src=\"/2021/02/02/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E8%A1%A1%E5%8F%98%E7%9A%84%E6%97%A5%E5%AD%90/QQ图片20210202211328.jpg\" style=\"zoom:25%;\">\n\n<img src=\"/2021/02/02/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E8%A1%A1%E5%8F%98%E7%9A%84%E6%97%A5%E5%AD%90/QQ图片20210202211323.jpg\" style=\"zoom:25%;\">\n\n<p><font color=\"red\">再见了，宜昌！</font></p>\n<img src=\"/2021/02/02/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E8%A1%A1%E5%8F%98%E7%9A%84%E6%97%A5%E5%AD%90/QQ图片20210202211257.jpg\" style=\"zoom:25%;\">\n\n<p><font color=\"red\">再见了，2班！</font></p>\n<img src=\"/2021/02/02/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E8%A1%A1%E5%8F%98%E7%9A%84%E6%97%A5%E5%AD%90/QQ图片20210202211250.jpg\" style=\"zoom:25%;\">\n\n<p><font color=\"red\">再见了，蜘网！</font></p>\n<img src=\"/2021/02/02/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E8%A1%A1%E5%8F%98%E7%9A%84%E6%97%A5%E5%AD%90/QQ图片20210202211319.jpg\" style=\"zoom:25%;\">\n\n<p><font color=\"red\">再见了，武汉！</font></p>\n<img src=\"/2021/02/02/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E8%A1%A1%E5%8F%98%E7%9A%84%E6%97%A5%E5%AD%90/QQ图片20210202211306.jpg\" style=\"zoom:25%;\">\n\n<p>​    这本来是写在上一篇日记里的，可惜换电脑时那片日记丢失了，只好写在这里了。</p>\n<p>​    在家待了一个月后，2020年7月27号，我来到了衡阳了，开始了在衡变的生活，来到衡阳的第一感觉呢，热，脏，路况极差！这不是一个好城市。最开始是一个为期20天的集训，集训的日子还是很快的，认识了很多人，陈龙、郭阳、彭紫薇、陈淼、温毅、蒋琨、陈奕君、李萌萌、张艳艳、伍坤杰。然后我们下车间了，车间实习可真是够了，我进的是线圈一车间，每天和铜线打交道，听说实习还要一年，顿时我就萌生了退意，其实在当初看到劳动合同上的5500的工资，加上不保吃住和大小周的暴击已经让我动摇了车间实习是压死骆驼的最后一根稻草，还好鹏哥出手早，两个月后把我和陈龙从车间捞了上去，不然他可能等不到我了。我最早一批进入部门的人，进入部门后第一个星期写了一个星期的编程规范，可以看的出设计部对参数化的野心很大，想要做无纸化，信息化，可惜实力不够，又舍不得下资本砸，开不了高工资怎么可能揽得住人才，就算不小心进来也是留不住的，比如我😁。然后我就开始了无休止的写界面的活，说实话写前端真的很无聊。</p>\n<p>​    期间跟着陈龙开始学习投资，买了一些基金，但是不太敢碰股票。陈龙炒股确实有一手，他去年炒股挣了2w+，我就买卖基金就可以，至少基金比银行还是要好些的。</p>\n<p>​    在衡变的日子也不能说不快乐，设计部活动很多，三天一小吃五天一大吃，各种饭局吃得停不下来，于是我稳定在110斤了，和朋友们玩得也很开心，但是呀，没有涨薪途径，这里我可真就待不了了。</p>\n<p>​    今天是2021年2月2号，我得春招开始了。</p>\n<p><img src=\"/2021/02/02/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E8%A1%A1%E5%8F%98%E7%9A%84%E6%97%A5%E5%AD%90/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E8%A1%A1%E5%8F%98%E7%9A%84%E6%97%A5%E5%AD%90%5CQQ%E5%9B%BE%E7%89%8720210202211300.jpg\"></p>\n","encrypt":true,"template":"<link rel=\"stylesheet\" href=\"//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css\"> <link rel=\"stylesheet\" href=\"//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css\"> <script src=\"//cdn.bootcss.com/jquery/1.11.3/jquery.min.js\"></script> <script src=\"//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js\"></script> <div id=\"security\"> <div> <div class=\"input-group\"> <input type=\"text\" class=\"form-control\" aria-label=\"Enter the password.\" id=\"pass\"/> <div class=\"input-group-btn\"> <button type=\"button\" class=\"btn btn-default\" onclick=\"decryptAES()\">Decrypt</button> </div> </div> </div> </div> <div id=\"encrypt-blog\" style=\"display:none\"> {{content}} </div>"},{"title":"【C++】C++ PremierReadNote","password":null,"abstract":null,"message":null,"date":"2021-02-03T02:52:44.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# C++ Primer 阅读笔记\n\n---\n\n<!--more-->\n\n# 一、开始\n\n---\n\n## 1.输入输出流的数据传输过程\n\n**输入:**\n[窗]->[输入流对象(cin)]\n\n**输出:**\n[输出流对象(cout，cerr，clog)->[窗口]\n\nc++从窗口中读取输入时不是直接存储在变量中而是先存储在istream类型对象cin中，输出是也非直接从变量输出到窗口而是先写入ostream对象cout/cerr/clog中，在从对象传输到窗口。\n\n## 2.输出运算符“<<”\n\n“<<”运算符输出的是一个ostream类型对象，“<<”接受两个运算对象，其中左侧的运算对象必须是一个ostream对象，右侧可以是需要输出的值，“<<”将需要输出的值写入到ostream对象中。\nstd::cout<<\"num:\"<<a<<std::endl；\n“<<”连续表达式可以理解为:\n((std::cout<<\"num:\")<<a)<<std::endl；\n每一个括号最终返回的都是一个ostream对象。其中endl是“操纵符”，运行效果是换行，并将与设备关联的缓冲区的内容刷新到设备中去，如果不写endl则在程序运行结束或缓冲区满后系统自动将缓冲区内容刷新到设备中去。\n输入运算符“>>”和输出运算符运行逻辑一样。\n\n## 3.char与unsigned char\n\n在计算机中char也是分无符号和有符号两类的，char与int等类型不同的是，int等类型不显示标注unsigned默认为有符号数，而char在不同硬件环境中表示的类型可能是不一样的，所以为保证移植性最好在使用时指定signed和unsigned，c++标准不建议使用char来存储数值，这种区别主要出现在char类型向值类型的转换的过程中。\n\n## 4.有符号数与无符号数的运算\n\n在c++运算优先级中，无符号数的优先级大于有符号数，所以当一个表达式中即存在有符号数又不存在无符号数时，运算将被转换为无符号数的运算，由于无符号数表示的最小值是0所以当表达式的运算结果为负数时就会出现运算错误。\n\n## 5.c++11的四种变量初始化方式\n\nint a=0;\nint a={0};\nint a{0};\n\nint a(0);\n --- \n\n# 二、变量和基本类型\n\n---\n\n1.const引用的隐式类型转换\n举例使用const限定的int类型的引用来引用double类型的变量的过程：double b=3.14;const int a=b;\n在将double类型变量赋值给const int类型的引用时系统先创建一个临时变量，并将double隐式成int类型的结果存放到临时变量中，然后再将临时变量赋给引用，此时引用本质上是int类型的临时变量的别名，之后如果更改了double类型变量的值，引用值随之改变。\n\n## 2.constexpr变量\n\nconstexpr是一个常量表达式，与const不同的是，const限定的变量只能被常量、常量的引用、常量表达式和常量与常量引用的表达式赋值，而constexpr可以被常量、常量的引用、表达式、以及可以在编译阶段就确定返回值的函数赋值。const在程序运行时的本质是在程序用的const的地方直接替换成期对应\n的常量，而constexpr则是替换其在编译器期计算出来的结果值。\nconstexpr的意义在于constexpr强制要求赋值给变量的表达式必须在编译阶段可计算出结果值，这对很多重复运算的简单表达式直接限定了在编译期只进行一次运算起到了优化效果。\n\n## 3.constexpr指针\n\n被constexpr限定的指针的初始值只能是nullptr或者0或者指向一个地址固定不变的对象，这里需要注意在函数里的任何对象都不是存储在固定地址中的，所以constexpr限定的指针不能指向函数中的对象，全局对象则是存在在固定地址中的所以constexpr限定的指针可以指向这样的对象。\n\n## 4.c++ 11的两种别名声明方法\n\ntypedef bm int;\nusing bm=int;\n\n\n##  5.decltype类型指示符\n\ndecltype的作用是通过表达式或函数的返回值动态的推断其指示变量的类型，如：\n\n```\ndecltype(fun()) sum = x;//sum的类型为fun函数返回值的类型，sum的值由x赋予\n```\n\n\n## 顶层Const与底层Const\n\n由于指针本身也是一个对象，所以在Const修饰指针时，就立存在修饰指针或修饰指针所指的对象。如果Const修饰指针则是底层Const，如果修饰指针所指的对象则是顶层Const。\n\n```\nconst int* pa;//const修饰指针，所以为底层const\nint* const pb;//const修饰pb，所以为顶层const\n```\n\n---\n\n# 三、字符串、向量和数组\n\n---\n\n## 1.c++11的string对象的初始化方式\n\nstring s;\nstring str=s;\nstring str(s);\nstring str(\"str\");\nstring str=\"str\";\nstring str(2,'s');//这种形式得到的是字符串\"ss\",其中括号里只能使用字符。\n\n## 2.cin、getline()和cin.getline()\n\ncin在对象在从缓存中读取数据时遇到空格符，制表符，换行符时或读至文件尾时会结束读取。\ngetline()可以读取空格符，遇到换行符时或读至文件尾时结束读取。\ncin.getline()作用和getline一样，只是cin.getline和cin都是标准输出流iosteeam中的对象方法，而getline这是属于string.h中的方法。\n\n## 3.string::size_type类型\n\n`size_type`类型是c++定义的几种标准库类型的几种配套类型，其目的在于解决在不同机器中因为机器字长不同而导致string.size()的返回值无法存储的问题，比如在一个16位的机器中int整型存储的最大字符数为32767，但这对于储存一个文件大小的string来说这个大小是明显不够的，所以c++引入`size_type`，以解决不同机器上string.size()的返回值一定能被存储。\n`size_type`的本质是无符号类型所以在使用string.size()和有符号数做运算时要十分注意，因为这会导致计算结果出现异常。\n需要注意的一点是`size_type`类型实际上不是一个确定的类型，在使用`size_type`时应注明`size_type`的类型，如:`string::size_type,vector<int>::size_type`。\n\n## 4.cctype头文件提供的一些字符判断函数\n\n* isalnum(c) 当c是字母过数字时为真\n\n* isalpha(c) 当c是字母时为真\n\n* iscntrl(c) 当c是控制字符时为真\n\n* isdigit(c) 当c是数字时为真\n\n* isgraph(c) 当c不是空格但可以打印时为真\n\n* islower(c) 当c是小写字母时为真\n\n* isprint(c) 当c是可打印字符时为真(即c是空格或c具有可视化形式)\n\n* ispunct(c) 当c是标点符号时为真(即c不是控制字符、数字、字母、可打印空白中的一种)\n\n* isspace(c) 当c是空格时为真\n\n* isupper(c) 当c是大写字母时为真\n\n* isxdigit(c) 当c是16进制数字时为真\n\n* tolower(c) 如果c是大写字母则输出其小写\n\n* toupper(c) 如果c是小写字母则输出其大写\n\n\n## 5.c++11的“foreach”\n\nc++本没有foreach循环，但是c++11为for语句添加了新的语法:\nfor(param:array){}这个for语法每次循环从array中读取一个数据并存放在param中用于操作\n需要注意的是param如果不使用引用的话，param实际是array中元素的拷贝，此时对param进行修改不会改变array的元素，如需要更改array中的元素的值时需要对param取引用。\n还有一点十分重要的是不可以在范围for语句中更改array的容量大小，这是因为能被范围for遍历的序列都需要包含begin,end两个返回迭代器的成员，我们可以先看一下范围for的源码:\nfor(auto beg=v.begin(),end=v.end();beg!=end;++beg)\n{\n}\n可以看到在范围for中实际上在循环前就已经存储了可遍历序列的begin,end迭代器，所以如果在循环中改变了序列的大小循环就会出错。\n\n## 6.vector容器的初始化方式\n\n* vector<T> v v是一个空的vector\n* vector<T> v2(v) v2是一个包含v所有副本的的vector\n* vector<T> v2=v 等价物v2(v)\n* vector<T> v(n,val) v是一个包含了n个重复元素，每个元素都是val的vector\n* vector<T> v(n) v是一个包含了n个重复执行了初始化的对象\n* vector<T> v{a,b,c……} v是一个包含了初始值个数元素的vector，每个元素被赋予对应的初始值\n* vector<T> v={a,b,c……} 等于v{a,b,c……}\n* <font color=red> 使用数组初始化vector容器，vector<T>(begin(array),end(array))，其中begin(array)是数组array的首地址，end(array)是数组array的尾地址 </font>\n\n\n## 7.vector对象能高效增长\n\nc++标准要求vector容器在运行时能高效快速地添加元素，在c++11标准中vector的动态添加元素的性能要优于预先规定容器大小的性能，只有一种情况例外，就是vector中的元素全部都是相同的时候这种情况会反过来。\n\n## 8.迭代器的end\n\n迭代器的end()并不实际指向某个元素，所以不能对其进行递增或解引用操作。 \n\n## 9.iterator和const_iterator\n\niterator和`const_iterator`是标准库定义的迭代器的类型，一般迭代器没有固定的类型，一般使用`类型::iterator`或`const_iterator`来确定迭代器的类型，如：`vector<int>::iterator  it`\n`iterator`为可读可写迭代器，`iterator`迭代器只能用于非常量容器；\n`const_iterator`为只读迭代器，`const_iterator`既可以用于非常量容器又可以用于常量容器，但是常量容器只能使用`const_iterator`迭代器。\n\n## 10.cbegin与cend\n\ncbegin和cend与begin和end相对，cbegin和cend返回const_iterator迭代器。\n\n\n## 11.迭代器的->运算符\n\n在使用迭代器的过程中经常需要通过解引用后再进行.运算，如：`(*it).empty()`，操作较为繁琐，c++11对这个操作进行了简化，即通过->运算来替换`(*it).`，前面的操作就可以替换为`it->empty()`\n\n\n## 12.容器的删添操作会是迭代器、引用和指针失效\n\n<font color=red>这是因为容器的删添操作可能会出现存储空间的重新分配，用string作为例子是最贴切的，当我们想一个string字符串中添加一个字符时，如：</font>\n\n\n```\nsting v = \"str\";\nv = v + ‘s’;\n\n```\n\n<font color=red>程序的实际操作是先创建一个临时变量来存储添加之后的字符串strs，然后再将v指向新分配的存储空间，于是指向之前空间位置的迭代器、引用和指针自然就失效了。</font>\n\n\n## 13.迭代器的运算\n\n![Alt](https://i.loli.net/2020/08/27/EG2yOZL4H8YvhsT.jpg)\n\n迭代器之后同时也可以进行加减运算其结果为dfference_type的带符号整型数表示两个迭代器之间的距离。\n\n\n## 14.数组的特殊性\n\n<font color=red>不能使数组来初始化数组，也不能使用数组来赋值数组，有的编译器支持数组初始化和赋值这是编译器的自身扩展，但仍然不应该这样做，因为当换了编译环境后程序可能就会出错人。</font>\n\n\n## 15.存放存放指针的数组和指向数组的指针\n\n```\nint *ptr[2];//拥有两个指针成员的数组\nint &ptr2[2];//错误，不存在引用数组\nint (*ptr3)[2];//指向有两个长度的整型数组的指针\nint (&ptr4)[2];//指向两个长度的整型数组的引用\n\n```\n\n## 16.数组和指针\n\n数组的名字实际上就是指向数组收地址的指针，所以下面操作得到是指针：\n\n```\nint arr[2] = {};\nauto ptr(arr);//per是一个指向arr首地址的int*类型指针\n\n```\n\n<font color =red >使用decltype进行上面的操作不会得到指针，而是得到数组，如：</font>\n\n```\ndecltype(arr) arr2 = {1};//arr2是一个包含一个元素的int型数组\n```\n\n<font color =red >对数组执行下标运算实质上是对指向数组首地址的指针执行下标运算，如：</font>\n\n```\nint i = ia[2]; //实际得到是(ia+2)所指向的元素\n```\n\n\n<font color =red >数组的下标运算只要不超过数组长度就可以执行下标运算，如：含有10个元素数组下标从0-9，但是 下标运算可以取到10，即a[10]，a[10]是数组的尾元素的下一个位置，但是对a[10]只能进行去地址运算(&a[10])，不能对a[10]解引用或读取。</font>\n\n## 17.ptrdiff_t类型\n\n和`size_type`一样，`ptrdiff_t`是c++11专门定制给begin()与end()的运算结果的类型，用于适应不同机器的字长。\n<font color=red>需要注意的是，内置数组下标值不是`ptrdiff_t`类型，如：a[1]，1就不是`ptrdiff_t`类型。</font>\n\n\n## 18.void *指针\n\n任何非常量值都可以存入`void *`指针中。\n\n# 四、表达式\n\n---\n\n## 1.为定义行为\n\nc++中存在一些为定义行为，如<<运算符在c++中并没有定义其后表达式的运算顺序，此时运行下面代码就会出现为定义行为。\n\n```\nint i=0;\ncout<<i<<\",\"<<++i<<endl;\n```\n\n此时会出现0，1或1，1两种结果，这是因为<<没有明确指定何时及如何对运算对象求值，但是在实际使用过程中并没有出现上述情况，这可能是编译器为<<规定了运算顺序。\n\n## 2.溢出与其他算术异常\n\n![6](https://i.loli.net/2020/09/04/QRnNjiTqEeOGaLV.jpg)\n\n## 3.运算符的优先级\n\n![Alt](https://i.loli.net/2020/10/09/6aVu9jBoswIgUEY.jpg)\n\n\n## 4.前置递增运算符与后置递增运算符的运行过程\n\n前置递增运算符先将对象递增之后再返回递增后的结果，而后置递增运算符则先创建一个临时变量先将旧的值存储起来，然后再将变量递增，再将旧的值返回。\n相对于前置递增运算符，后置递增运算符需要创建一个临时变量，这就产生了一个消耗，在一些普通的后置递增运算中可能不大可看得出来，但在较为复杂的迭代器中这种额外的消耗就会产生巨大的性能浪费，所以平时使用时尽量使用前置递增运算符。\n\n\n## 5.表达式在运算过程中值发生变化\n\n<font color=red>在一个运算表达式中，参与运算的值不应该在运算的过程中发生变化，否则极易造成未定义行为，如：</font>\n<font color=red>`v[i++]<v[i]`，在大于号运算的过程中v[i++]的值向后移动了一位，造成了值的变化，由于C++没有定义二元运算符两端未定义自增运算符的运算顺序，所级就造成了未定义行为。</font>\n\n\n## 6.有符号数的位运算\n\n有符号数尽量不要做位运算，因为位运算容易改变有符号数的符号位导致未定义行为。\n\n\n## 7.位运算中的类型提升\n\n在程序编写时需要注意，任何占字节小于int类型的类型变量进行位运算时都会产生类型提升而被转换成int类型，如下代码所示：\n\n```\nint main(){\nchar s='s';\nshort a=1;\nbool b=true;\nlong c=2;\ncout<<sizeof(s)<<endl;\ncout << sizeof(~s)<<endl;\ncout<<sizeof(s<<1)<<endl;\ncout<<\"----------\"<<endl;\ncout<<sizeof(a)<<endl;\ncout<<sizeof(~a)<<endl;\ncout<<\"----------\"<<endl;\ncout<<sizeof(b)<<endl;\ncout<<sizeof(~b)<<endl;\ncout<<\"----------\"<<endl;\ncout<<sizeof(c)<<endl;\ncout<<sizeof(~c)<<endl;\ncout<<\"----------\"<<endl;\ncout<<~s<<endl;\ncout<<~b<<endl;\nreturn 0;\n}\n```\n\n输出结果：\n![Alt](https://i.loli.net/2020/10/23/GUI54xhOrQs7oyK.jpg)\n\n\n## 8.sizeof计算指针大小\n\nsizeof在计算指针时有个很有趣的现象，因为sizeof满足右结合律且优先级与`*`相同，所以在`sizeof *p`中，先对p解引用，然后在对解引用后的内容计算所占内存大小，由于sizeof并没有使用解引用的内容，所以`*p`是否为空是否有效对sizeof的计算没有影响。\n`sizeof *p` == `sizeof(*p)`\n\n\n## 9.隐式转换的过程\n\n以`int a=3.14+3；`为例\n在这个例子中3.14是山比double类型，3是int类型，运算时为了保证精度C++会将int类型转换成double类型，而不是因为结果是int类型而将double类型转换成int类型，所以在表达示右侧的运算过程得到的结果是一个double类型的值，当这个值被赋值给a的时候才进行double到int的类型转换。\n\n---\n\n# 五、语句\n\n---\n\n## 1.switch语句跨case标签引用变量\n\n若需要在一个 case 语句下定义变量同时在多个 case 语下使用这个变量，则定义变量时不能同时初始化变量，应另起等于初始变量，否则编译器会报跨标签访问错误，如：\n\n```\nswitch (a)\n{\n    case 0:\n        int b;  //如果直接int b=1;则会报跨标签访问错误\n        b=1;\n        break;\n    case 1:\n        cout<<b<<endl;\n        break;\n    default:\n        ;\n}\n```\n\n\n## 2.C++无法捕获计算溢出异常和除0异常\n\nC++认为计算溢出和除0异常属于底层事件，应被同样底层的事件去处理，所以C++没有提供计算溢出和除0异常，如果需要捕获这两类异常在Windows系统中应使用Windows提供的SEH模型`__try`、`__except`、`__finally`异常语句，使用方法和try-catch基本类似，与try-catch不同的是，SEH中使用的是`__try-__except`搭配和`__try-__finally`搭配。\n\n---\n\n# 六、函数\n\n---\n\n## 1.静态局布变量\n\n在函数体内使用static关键字可以效静态局布量，静态局布变量的生命周期从变量定义到程序结束，但是静态局布变量只对函数可见，在函数外不可访问。\n\n\n## 2.C++程序的编译过程\n\n![Alt](https://i.loli.net/2020/11/09/bJ5xRFg6TGHnLCO.jpg)\n\n\n## 3.函数调用过程中的形参创建\n\n函数的每一次调用都会重新创建形参并传入实参对其进行初始化，形餐盘类型决定了形参与实参的交互类型，如果形参是引用类型，则形参与相对应的实参相绑定，作为实参的别名使用；如果形参是值类型，则实参的值拷贝给形参，形参与实参相互独立。\n\n\n## 4.函数的指针参数传递\n\n<font color=red>当指针作为实参传递给函数形参时，传递的是指针的值拷贝而不是指针所指的对象，且形参指针与实参指针是两个不同的指针，此时形参指针与实参指针指向同一对象，修改形参的指针指向不会影实参指针。</font>\n\n\n## 5.引用形参的限制\n\n* 如果将函数的参数定义普通引用参数，那么这个形参就无法接受const对象、字面值和需要类型转换的对象作为实参。\n\n* 如果将函数的参数定义为const引用参数，这个参数可以接受第一条中的参数，但是却无法修改参数的值。\n\n\n## 6.数组的两个特殊性质\n\n* 数组不可被拷贝\n* 数组再使用时被转换为指针\n\n\n## 7.数组引用形参\n\n当我们使用数组作普通形参时，\n\n```\nvoid fun(int* arr);\nvoid fun(int arr[]);\nvoid fun(int arr[10]);\n```\n\n表示的都是同一个函数，且形参可接受任意长度的实参数组，但是当将普通形参改为引用形参时，\n\n```\nvoid fun(int (&arr)[10]);\n```\n\n`(&arr)`中()不可缺少，否则形参变成引用的数组而非数组的引用，且形参只能接收长度为10的数组。\n\n\n## 8.main函数传参\n\n有的时候我们会遇到这样的main函数：\n\n```\nint main(int argc,char** argv)\n{\n}\n```\n\n通常情况下，直接使用argv，argv中的内容是空的，那么main函数在什么情况下会接收参数呢？\n事实上main函数本身就是当前程序的入口，在当前程序中没有其他程序为main函数传入参数了，当我们把写好的程序打包后在外部调用时就可以给main函数传入参数了，如在CMD中调程序\n\n```\nprog -o -d ofile data0//prog为程序名\n```\n\n<font color=red>需要注意的是argv数组的0号索引存储程序的名字，参数从1号索引开始存储，且最后一个索引位置固定内容为0</font>\n\n","source":"_posts/【C++】C++ PremierReadNote.md","raw":"---\ntitle: 【C++】C++ PremierReadNote\npassword: \nabstract: \nmessage: \ndate: 2021-02-03 10:52:44\ntags: CPlus\ncategories: 学习笔记\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# C++ Primer 阅读笔记\n\n---\n\n<!--more-->\n\n# 一、开始\n\n---\n\n## 1.输入输出流的数据传输过程\n\n**输入:**\n[窗]->[输入流对象(cin)]\n\n**输出:**\n[输出流对象(cout，cerr，clog)->[窗口]\n\nc++从窗口中读取输入时不是直接存储在变量中而是先存储在istream类型对象cin中，输出是也非直接从变量输出到窗口而是先写入ostream对象cout/cerr/clog中，在从对象传输到窗口。\n\n## 2.输出运算符“<<”\n\n“<<”运算符输出的是一个ostream类型对象，“<<”接受两个运算对象，其中左侧的运算对象必须是一个ostream对象，右侧可以是需要输出的值，“<<”将需要输出的值写入到ostream对象中。\nstd::cout<<\"num:\"<<a<<std::endl；\n“<<”连续表达式可以理解为:\n((std::cout<<\"num:\")<<a)<<std::endl；\n每一个括号最终返回的都是一个ostream对象。其中endl是“操纵符”，运行效果是换行，并将与设备关联的缓冲区的内容刷新到设备中去，如果不写endl则在程序运行结束或缓冲区满后系统自动将缓冲区内容刷新到设备中去。\n输入运算符“>>”和输出运算符运行逻辑一样。\n\n## 3.char与unsigned char\n\n在计算机中char也是分无符号和有符号两类的，char与int等类型不同的是，int等类型不显示标注unsigned默认为有符号数，而char在不同硬件环境中表示的类型可能是不一样的，所以为保证移植性最好在使用时指定signed和unsigned，c++标准不建议使用char来存储数值，这种区别主要出现在char类型向值类型的转换的过程中。\n\n## 4.有符号数与无符号数的运算\n\n在c++运算优先级中，无符号数的优先级大于有符号数，所以当一个表达式中即存在有符号数又不存在无符号数时，运算将被转换为无符号数的运算，由于无符号数表示的最小值是0所以当表达式的运算结果为负数时就会出现运算错误。\n\n## 5.c++11的四种变量初始化方式\n\nint a=0;\nint a={0};\nint a{0};\n\nint a(0);\n --- \n\n# 二、变量和基本类型\n\n---\n\n1.const引用的隐式类型转换\n举例使用const限定的int类型的引用来引用double类型的变量的过程：double b=3.14;const int a=b;\n在将double类型变量赋值给const int类型的引用时系统先创建一个临时变量，并将double隐式成int类型的结果存放到临时变量中，然后再将临时变量赋给引用，此时引用本质上是int类型的临时变量的别名，之后如果更改了double类型变量的值，引用值随之改变。\n\n## 2.constexpr变量\n\nconstexpr是一个常量表达式，与const不同的是，const限定的变量只能被常量、常量的引用、常量表达式和常量与常量引用的表达式赋值，而constexpr可以被常量、常量的引用、表达式、以及可以在编译阶段就确定返回值的函数赋值。const在程序运行时的本质是在程序用的const的地方直接替换成期对应\n的常量，而constexpr则是替换其在编译器期计算出来的结果值。\nconstexpr的意义在于constexpr强制要求赋值给变量的表达式必须在编译阶段可计算出结果值，这对很多重复运算的简单表达式直接限定了在编译期只进行一次运算起到了优化效果。\n\n## 3.constexpr指针\n\n被constexpr限定的指针的初始值只能是nullptr或者0或者指向一个地址固定不变的对象，这里需要注意在函数里的任何对象都不是存储在固定地址中的，所以constexpr限定的指针不能指向函数中的对象，全局对象则是存在在固定地址中的所以constexpr限定的指针可以指向这样的对象。\n\n## 4.c++ 11的两种别名声明方法\n\ntypedef bm int;\nusing bm=int;\n\n\n##  5.decltype类型指示符\n\ndecltype的作用是通过表达式或函数的返回值动态的推断其指示变量的类型，如：\n\n```\ndecltype(fun()) sum = x;//sum的类型为fun函数返回值的类型，sum的值由x赋予\n```\n\n\n## 顶层Const与底层Const\n\n由于指针本身也是一个对象，所以在Const修饰指针时，就立存在修饰指针或修饰指针所指的对象。如果Const修饰指针则是底层Const，如果修饰指针所指的对象则是顶层Const。\n\n```\nconst int* pa;//const修饰指针，所以为底层const\nint* const pb;//const修饰pb，所以为顶层const\n```\n\n---\n\n# 三、字符串、向量和数组\n\n---\n\n## 1.c++11的string对象的初始化方式\n\nstring s;\nstring str=s;\nstring str(s);\nstring str(\"str\");\nstring str=\"str\";\nstring str(2,'s');//这种形式得到的是字符串\"ss\",其中括号里只能使用字符。\n\n## 2.cin、getline()和cin.getline()\n\ncin在对象在从缓存中读取数据时遇到空格符，制表符，换行符时或读至文件尾时会结束读取。\ngetline()可以读取空格符，遇到换行符时或读至文件尾时结束读取。\ncin.getline()作用和getline一样，只是cin.getline和cin都是标准输出流iosteeam中的对象方法，而getline这是属于string.h中的方法。\n\n## 3.string::size_type类型\n\n`size_type`类型是c++定义的几种标准库类型的几种配套类型，其目的在于解决在不同机器中因为机器字长不同而导致string.size()的返回值无法存储的问题，比如在一个16位的机器中int整型存储的最大字符数为32767，但这对于储存一个文件大小的string来说这个大小是明显不够的，所以c++引入`size_type`，以解决不同机器上string.size()的返回值一定能被存储。\n`size_type`的本质是无符号类型所以在使用string.size()和有符号数做运算时要十分注意，因为这会导致计算结果出现异常。\n需要注意的一点是`size_type`类型实际上不是一个确定的类型，在使用`size_type`时应注明`size_type`的类型，如:`string::size_type,vector<int>::size_type`。\n\n## 4.cctype头文件提供的一些字符判断函数\n\n* isalnum(c) 当c是字母过数字时为真\n\n* isalpha(c) 当c是字母时为真\n\n* iscntrl(c) 当c是控制字符时为真\n\n* isdigit(c) 当c是数字时为真\n\n* isgraph(c) 当c不是空格但可以打印时为真\n\n* islower(c) 当c是小写字母时为真\n\n* isprint(c) 当c是可打印字符时为真(即c是空格或c具有可视化形式)\n\n* ispunct(c) 当c是标点符号时为真(即c不是控制字符、数字、字母、可打印空白中的一种)\n\n* isspace(c) 当c是空格时为真\n\n* isupper(c) 当c是大写字母时为真\n\n* isxdigit(c) 当c是16进制数字时为真\n\n* tolower(c) 如果c是大写字母则输出其小写\n\n* toupper(c) 如果c是小写字母则输出其大写\n\n\n## 5.c++11的“foreach”\n\nc++本没有foreach循环，但是c++11为for语句添加了新的语法:\nfor(param:array){}这个for语法每次循环从array中读取一个数据并存放在param中用于操作\n需要注意的是param如果不使用引用的话，param实际是array中元素的拷贝，此时对param进行修改不会改变array的元素，如需要更改array中的元素的值时需要对param取引用。\n还有一点十分重要的是不可以在范围for语句中更改array的容量大小，这是因为能被范围for遍历的序列都需要包含begin,end两个返回迭代器的成员，我们可以先看一下范围for的源码:\nfor(auto beg=v.begin(),end=v.end();beg!=end;++beg)\n{\n}\n可以看到在范围for中实际上在循环前就已经存储了可遍历序列的begin,end迭代器，所以如果在循环中改变了序列的大小循环就会出错。\n\n## 6.vector容器的初始化方式\n\n* vector<T> v v是一个空的vector\n* vector<T> v2(v) v2是一个包含v所有副本的的vector\n* vector<T> v2=v 等价物v2(v)\n* vector<T> v(n,val) v是一个包含了n个重复元素，每个元素都是val的vector\n* vector<T> v(n) v是一个包含了n个重复执行了初始化的对象\n* vector<T> v{a,b,c……} v是一个包含了初始值个数元素的vector，每个元素被赋予对应的初始值\n* vector<T> v={a,b,c……} 等于v{a,b,c……}\n* <font color=red> 使用数组初始化vector容器，vector<T>(begin(array),end(array))，其中begin(array)是数组array的首地址，end(array)是数组array的尾地址 </font>\n\n\n## 7.vector对象能高效增长\n\nc++标准要求vector容器在运行时能高效快速地添加元素，在c++11标准中vector的动态添加元素的性能要优于预先规定容器大小的性能，只有一种情况例外，就是vector中的元素全部都是相同的时候这种情况会反过来。\n\n## 8.迭代器的end\n\n迭代器的end()并不实际指向某个元素，所以不能对其进行递增或解引用操作。 \n\n## 9.iterator和const_iterator\n\niterator和`const_iterator`是标准库定义的迭代器的类型，一般迭代器没有固定的类型，一般使用`类型::iterator`或`const_iterator`来确定迭代器的类型，如：`vector<int>::iterator  it`\n`iterator`为可读可写迭代器，`iterator`迭代器只能用于非常量容器；\n`const_iterator`为只读迭代器，`const_iterator`既可以用于非常量容器又可以用于常量容器，但是常量容器只能使用`const_iterator`迭代器。\n\n## 10.cbegin与cend\n\ncbegin和cend与begin和end相对，cbegin和cend返回const_iterator迭代器。\n\n\n## 11.迭代器的->运算符\n\n在使用迭代器的过程中经常需要通过解引用后再进行.运算，如：`(*it).empty()`，操作较为繁琐，c++11对这个操作进行了简化，即通过->运算来替换`(*it).`，前面的操作就可以替换为`it->empty()`\n\n\n## 12.容器的删添操作会是迭代器、引用和指针失效\n\n<font color=red>这是因为容器的删添操作可能会出现存储空间的重新分配，用string作为例子是最贴切的，当我们想一个string字符串中添加一个字符时，如：</font>\n\n\n```\nsting v = \"str\";\nv = v + ‘s’;\n\n```\n\n<font color=red>程序的实际操作是先创建一个临时变量来存储添加之后的字符串strs，然后再将v指向新分配的存储空间，于是指向之前空间位置的迭代器、引用和指针自然就失效了。</font>\n\n\n## 13.迭代器的运算\n\n![Alt](https://i.loli.net/2020/08/27/EG2yOZL4H8YvhsT.jpg)\n\n迭代器之后同时也可以进行加减运算其结果为dfference_type的带符号整型数表示两个迭代器之间的距离。\n\n\n## 14.数组的特殊性\n\n<font color=red>不能使数组来初始化数组，也不能使用数组来赋值数组，有的编译器支持数组初始化和赋值这是编译器的自身扩展，但仍然不应该这样做，因为当换了编译环境后程序可能就会出错人。</font>\n\n\n## 15.存放存放指针的数组和指向数组的指针\n\n```\nint *ptr[2];//拥有两个指针成员的数组\nint &ptr2[2];//错误，不存在引用数组\nint (*ptr3)[2];//指向有两个长度的整型数组的指针\nint (&ptr4)[2];//指向两个长度的整型数组的引用\n\n```\n\n## 16.数组和指针\n\n数组的名字实际上就是指向数组收地址的指针，所以下面操作得到是指针：\n\n```\nint arr[2] = {};\nauto ptr(arr);//per是一个指向arr首地址的int*类型指针\n\n```\n\n<font color =red >使用decltype进行上面的操作不会得到指针，而是得到数组，如：</font>\n\n```\ndecltype(arr) arr2 = {1};//arr2是一个包含一个元素的int型数组\n```\n\n<font color =red >对数组执行下标运算实质上是对指向数组首地址的指针执行下标运算，如：</font>\n\n```\nint i = ia[2]; //实际得到是(ia+2)所指向的元素\n```\n\n\n<font color =red >数组的下标运算只要不超过数组长度就可以执行下标运算，如：含有10个元素数组下标从0-9，但是 下标运算可以取到10，即a[10]，a[10]是数组的尾元素的下一个位置，但是对a[10]只能进行去地址运算(&a[10])，不能对a[10]解引用或读取。</font>\n\n## 17.ptrdiff_t类型\n\n和`size_type`一样，`ptrdiff_t`是c++11专门定制给begin()与end()的运算结果的类型，用于适应不同机器的字长。\n<font color=red>需要注意的是，内置数组下标值不是`ptrdiff_t`类型，如：a[1]，1就不是`ptrdiff_t`类型。</font>\n\n\n## 18.void *指针\n\n任何非常量值都可以存入`void *`指针中。\n\n# 四、表达式\n\n---\n\n## 1.为定义行为\n\nc++中存在一些为定义行为，如<<运算符在c++中并没有定义其后表达式的运算顺序，此时运行下面代码就会出现为定义行为。\n\n```\nint i=0;\ncout<<i<<\",\"<<++i<<endl;\n```\n\n此时会出现0，1或1，1两种结果，这是因为<<没有明确指定何时及如何对运算对象求值，但是在实际使用过程中并没有出现上述情况，这可能是编译器为<<规定了运算顺序。\n\n## 2.溢出与其他算术异常\n\n![6](https://i.loli.net/2020/09/04/QRnNjiTqEeOGaLV.jpg)\n\n## 3.运算符的优先级\n\n![Alt](https://i.loli.net/2020/10/09/6aVu9jBoswIgUEY.jpg)\n\n\n## 4.前置递增运算符与后置递增运算符的运行过程\n\n前置递增运算符先将对象递增之后再返回递增后的结果，而后置递增运算符则先创建一个临时变量先将旧的值存储起来，然后再将变量递增，再将旧的值返回。\n相对于前置递增运算符，后置递增运算符需要创建一个临时变量，这就产生了一个消耗，在一些普通的后置递增运算中可能不大可看得出来，但在较为复杂的迭代器中这种额外的消耗就会产生巨大的性能浪费，所以平时使用时尽量使用前置递增运算符。\n\n\n## 5.表达式在运算过程中值发生变化\n\n<font color=red>在一个运算表达式中，参与运算的值不应该在运算的过程中发生变化，否则极易造成未定义行为，如：</font>\n<font color=red>`v[i++]<v[i]`，在大于号运算的过程中v[i++]的值向后移动了一位，造成了值的变化，由于C++没有定义二元运算符两端未定义自增运算符的运算顺序，所级就造成了未定义行为。</font>\n\n\n## 6.有符号数的位运算\n\n有符号数尽量不要做位运算，因为位运算容易改变有符号数的符号位导致未定义行为。\n\n\n## 7.位运算中的类型提升\n\n在程序编写时需要注意，任何占字节小于int类型的类型变量进行位运算时都会产生类型提升而被转换成int类型，如下代码所示：\n\n```\nint main(){\nchar s='s';\nshort a=1;\nbool b=true;\nlong c=2;\ncout<<sizeof(s)<<endl;\ncout << sizeof(~s)<<endl;\ncout<<sizeof(s<<1)<<endl;\ncout<<\"----------\"<<endl;\ncout<<sizeof(a)<<endl;\ncout<<sizeof(~a)<<endl;\ncout<<\"----------\"<<endl;\ncout<<sizeof(b)<<endl;\ncout<<sizeof(~b)<<endl;\ncout<<\"----------\"<<endl;\ncout<<sizeof(c)<<endl;\ncout<<sizeof(~c)<<endl;\ncout<<\"----------\"<<endl;\ncout<<~s<<endl;\ncout<<~b<<endl;\nreturn 0;\n}\n```\n\n输出结果：\n![Alt](https://i.loli.net/2020/10/23/GUI54xhOrQs7oyK.jpg)\n\n\n## 8.sizeof计算指针大小\n\nsizeof在计算指针时有个很有趣的现象，因为sizeof满足右结合律且优先级与`*`相同，所以在`sizeof *p`中，先对p解引用，然后在对解引用后的内容计算所占内存大小，由于sizeof并没有使用解引用的内容，所以`*p`是否为空是否有效对sizeof的计算没有影响。\n`sizeof *p` == `sizeof(*p)`\n\n\n## 9.隐式转换的过程\n\n以`int a=3.14+3；`为例\n在这个例子中3.14是山比double类型，3是int类型，运算时为了保证精度C++会将int类型转换成double类型，而不是因为结果是int类型而将double类型转换成int类型，所以在表达示右侧的运算过程得到的结果是一个double类型的值，当这个值被赋值给a的时候才进行double到int的类型转换。\n\n---\n\n# 五、语句\n\n---\n\n## 1.switch语句跨case标签引用变量\n\n若需要在一个 case 语句下定义变量同时在多个 case 语下使用这个变量，则定义变量时不能同时初始化变量，应另起等于初始变量，否则编译器会报跨标签访问错误，如：\n\n```\nswitch (a)\n{\n    case 0:\n        int b;  //如果直接int b=1;则会报跨标签访问错误\n        b=1;\n        break;\n    case 1:\n        cout<<b<<endl;\n        break;\n    default:\n        ;\n}\n```\n\n\n## 2.C++无法捕获计算溢出异常和除0异常\n\nC++认为计算溢出和除0异常属于底层事件，应被同样底层的事件去处理，所以C++没有提供计算溢出和除0异常，如果需要捕获这两类异常在Windows系统中应使用Windows提供的SEH模型`__try`、`__except`、`__finally`异常语句，使用方法和try-catch基本类似，与try-catch不同的是，SEH中使用的是`__try-__except`搭配和`__try-__finally`搭配。\n\n---\n\n# 六、函数\n\n---\n\n## 1.静态局布变量\n\n在函数体内使用static关键字可以效静态局布量，静态局布变量的生命周期从变量定义到程序结束，但是静态局布变量只对函数可见，在函数外不可访问。\n\n\n## 2.C++程序的编译过程\n\n![Alt](https://i.loli.net/2020/11/09/bJ5xRFg6TGHnLCO.jpg)\n\n\n## 3.函数调用过程中的形参创建\n\n函数的每一次调用都会重新创建形参并传入实参对其进行初始化，形餐盘类型决定了形参与实参的交互类型，如果形参是引用类型，则形参与相对应的实参相绑定，作为实参的别名使用；如果形参是值类型，则实参的值拷贝给形参，形参与实参相互独立。\n\n\n## 4.函数的指针参数传递\n\n<font color=red>当指针作为实参传递给函数形参时，传递的是指针的值拷贝而不是指针所指的对象，且形参指针与实参指针是两个不同的指针，此时形参指针与实参指针指向同一对象，修改形参的指针指向不会影实参指针。</font>\n\n\n## 5.引用形参的限制\n\n* 如果将函数的参数定义普通引用参数，那么这个形参就无法接受const对象、字面值和需要类型转换的对象作为实参。\n\n* 如果将函数的参数定义为const引用参数，这个参数可以接受第一条中的参数，但是却无法修改参数的值。\n\n\n## 6.数组的两个特殊性质\n\n* 数组不可被拷贝\n* 数组再使用时被转换为指针\n\n\n## 7.数组引用形参\n\n当我们使用数组作普通形参时，\n\n```\nvoid fun(int* arr);\nvoid fun(int arr[]);\nvoid fun(int arr[10]);\n```\n\n表示的都是同一个函数，且形参可接受任意长度的实参数组，但是当将普通形参改为引用形参时，\n\n```\nvoid fun(int (&arr)[10]);\n```\n\n`(&arr)`中()不可缺少，否则形参变成引用的数组而非数组的引用，且形参只能接收长度为10的数组。\n\n\n## 8.main函数传参\n\n有的时候我们会遇到这样的main函数：\n\n```\nint main(int argc,char** argv)\n{\n}\n```\n\n通常情况下，直接使用argv，argv中的内容是空的，那么main函数在什么情况下会接收参数呢？\n事实上main函数本身就是当前程序的入口，在当前程序中没有其他程序为main函数传入参数了，当我们把写好的程序打包后在外部调用时就可以给main函数传入参数了，如在CMD中调程序\n\n```\nprog -o -d ofile data0//prog为程序名\n```\n\n<font color=red>需要注意的是argv数组的0号索引存储程序的名字，参数从1号索引开始存储，且最后一个索引位置固定内容为0</font>\n\n","slug":"【C++】C++ PremierReadNote","published":1,"updated":"2021-03-30T06:41:55.056Z","_id":"ckkou93gg0000ekr70u00eitq","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h1 id=\"C-Primer-阅读笔记\"><a href=\"#C-Primer-阅读笔记\" class=\"headerlink\" title=\"C++ Primer 阅读笔记\"></a>C++ Primer 阅读笔记</h1><hr>\n<a id=\"more\"></a>\n\n<h1 id=\"一、开始\"><a href=\"#一、开始\" class=\"headerlink\" title=\"一、开始\"></a>一、开始</h1><hr>\n<h2 id=\"1-输入输出流的数据传输过程\"><a href=\"#1-输入输出流的数据传输过程\" class=\"headerlink\" title=\"1.输入输出流的数据传输过程\"></a>1.输入输出流的数据传输过程</h2><p><strong>输入:</strong><br>[窗]-&gt;[输入流对象(cin)]</p>\n<p><strong>输出:</strong><br>[输出流对象(cout，cerr，clog)-&gt;[窗口]</p>\n<p>c++从窗口中读取输入时不是直接存储在变量中而是先存储在istream类型对象cin中，输出是也非直接从变量输出到窗口而是先写入ostream对象cout/cerr/clog中，在从对象传输到窗口。</p>\n<h2 id=\"2-输出运算符“-lt-lt-”\"><a href=\"#2-输出运算符“-lt-lt-”\" class=\"headerlink\" title=\"2.输出运算符“&lt;&lt;”\"></a>2.输出运算符“&lt;&lt;”</h2><p>“&lt;&lt;”运算符输出的是一个ostream类型对象，“&lt;&lt;”接受两个运算对象，其中左侧的运算对象必须是一个ostream对象，右侧可以是需要输出的值，“&lt;&lt;”将需要输出的值写入到ostream对象中。<br>std::cout&lt;&lt;”num:”&lt;&lt;a&lt;&lt;std::endl；<br>“&lt;&lt;”连续表达式可以理解为:<br>((std::cout&lt;&lt;”num:”)&lt;&lt;a)&lt;&lt;std::endl；<br>每一个括号最终返回的都是一个ostream对象。其中endl是“操纵符”，运行效果是换行，并将与设备关联的缓冲区的内容刷新到设备中去，如果不写endl则在程序运行结束或缓冲区满后系统自动将缓冲区内容刷新到设备中去。<br>输入运算符“&gt;&gt;”和输出运算符运行逻辑一样。</p>\n<h2 id=\"3-char与unsigned-char\"><a href=\"#3-char与unsigned-char\" class=\"headerlink\" title=\"3.char与unsigned char\"></a>3.char与unsigned char</h2><p>在计算机中char也是分无符号和有符号两类的，char与int等类型不同的是，int等类型不显示标注unsigned默认为有符号数，而char在不同硬件环境中表示的类型可能是不一样的，所以为保证移植性最好在使用时指定signed和unsigned，c++标准不建议使用char来存储数值，这种区别主要出现在char类型向值类型的转换的过程中。</p>\n<h2 id=\"4-有符号数与无符号数的运算\"><a href=\"#4-有符号数与无符号数的运算\" class=\"headerlink\" title=\"4.有符号数与无符号数的运算\"></a>4.有符号数与无符号数的运算</h2><p>在c++运算优先级中，无符号数的优先级大于有符号数，所以当一个表达式中即存在有符号数又不存在无符号数时，运算将被转换为无符号数的运算，由于无符号数表示的最小值是0所以当表达式的运算结果为负数时就会出现运算错误。</p>\n<h2 id=\"5-c-11的四种变量初始化方式\"><a href=\"#5-c-11的四种变量初始化方式\" class=\"headerlink\" title=\"5.c++11的四种变量初始化方式\"></a>5.c++11的四种变量初始化方式</h2><p>int a=0;<br>int a={0};<br>int a{0};</p>\n<h2 id=\"int-a-0\"><a href=\"#int-a-0\" class=\"headerlink\" title=\"int a(0);\"></a>int a(0);</h2><h1 id=\"二、变量和基本类型\"><a href=\"#二、变量和基本类型\" class=\"headerlink\" title=\"二、变量和基本类型\"></a>二、变量和基本类型</h1><hr>\n<p>1.const引用的隐式类型转换<br>举例使用const限定的int类型的引用来引用double类型的变量的过程：double b=3.14;const int a=b;<br>在将double类型变量赋值给const int类型的引用时系统先创建一个临时变量，并将double隐式成int类型的结果存放到临时变量中，然后再将临时变量赋给引用，此时引用本质上是int类型的临时变量的别名，之后如果更改了double类型变量的值，引用值随之改变。</p>\n<h2 id=\"2-constexpr变量\"><a href=\"#2-constexpr变量\" class=\"headerlink\" title=\"2.constexpr变量\"></a>2.constexpr变量</h2><p>constexpr是一个常量表达式，与const不同的是，const限定的变量只能被常量、常量的引用、常量表达式和常量与常量引用的表达式赋值，而constexpr可以被常量、常量的引用、表达式、以及可以在编译阶段就确定返回值的函数赋值。const在程序运行时的本质是在程序用的const的地方直接替换成期对应<br>的常量，而constexpr则是替换其在编译器期计算出来的结果值。<br>constexpr的意义在于constexpr强制要求赋值给变量的表达式必须在编译阶段可计算出结果值，这对很多重复运算的简单表达式直接限定了在编译期只进行一次运算起到了优化效果。</p>\n<h2 id=\"3-constexpr指针\"><a href=\"#3-constexpr指针\" class=\"headerlink\" title=\"3.constexpr指针\"></a>3.constexpr指针</h2><p>被constexpr限定的指针的初始值只能是nullptr或者0或者指向一个地址固定不变的对象，这里需要注意在函数里的任何对象都不是存储在固定地址中的，所以constexpr限定的指针不能指向函数中的对象，全局对象则是存在在固定地址中的所以constexpr限定的指针可以指向这样的对象。</p>\n<h2 id=\"4-c-11的两种别名声明方法\"><a href=\"#4-c-11的两种别名声明方法\" class=\"headerlink\" title=\"4.c++ 11的两种别名声明方法\"></a>4.c++ 11的两种别名声明方法</h2><p>typedef bm int;<br>using bm=int;</p>\n<h2 id=\"5-decltype类型指示符\"><a href=\"#5-decltype类型指示符\" class=\"headerlink\" title=\"5.decltype类型指示符\"></a>5.decltype类型指示符</h2><p>decltype的作用是通过表达式或函数的返回值动态的推断其指示变量的类型，如：</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\">decltype(<span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span>()) <span class=\"hljs-title\">sum</span></span> = x;<span class=\"hljs-regexp\">//sum</span>的类型为<span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span>函数返回值的类型，<span class=\"hljs-title\">sum</span></span>的值由x赋予<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"顶层Const与底层Const\"><a href=\"#顶层Const与底层Const\" class=\"headerlink\" title=\"顶层Const与底层Const\"></a>顶层Const与底层Const</h2><p>由于指针本身也是一个对象，所以在Const修饰指针时，就立存在修饰指针或修饰指针所指的对象。如果Const修饰指针则是底层Const，如果修饰指针所指的对象则是顶层Const。</p>\n<figure class=\"highlight nim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nim\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">int</span>* pa;//<span class=\"hljs-keyword\">const</span>修饰指针，所以为底层<span class=\"hljs-keyword\">const</span><br><span class=\"hljs-built_in\">int</span>* <span class=\"hljs-keyword\">const</span> pb;//<span class=\"hljs-keyword\">const</span>修饰pb，所以为顶层<span class=\"hljs-keyword\">const</span><br></code></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"三、字符串、向量和数组\"><a href=\"#三、字符串、向量和数组\" class=\"headerlink\" title=\"三、字符串、向量和数组\"></a>三、字符串、向量和数组</h1><hr>\n<h2 id=\"1-c-11的string对象的初始化方式\"><a href=\"#1-c-11的string对象的初始化方式\" class=\"headerlink\" title=\"1.c++11的string对象的初始化方式\"></a>1.c++11的string对象的初始化方式</h2><p>string s;<br>string str=s;<br>string str(s);<br>string str(“str”);<br>string str=”str”;<br>string str(2,’s’);//这种形式得到的是字符串”ss”,其中括号里只能使用字符。</p>\n<h2 id=\"2-cin、getline-和cin-getline\"><a href=\"#2-cin、getline-和cin-getline\" class=\"headerlink\" title=\"2.cin、getline()和cin.getline()\"></a>2.cin、getline()和cin.getline()</h2><p>cin在对象在从缓存中读取数据时遇到空格符，制表符，换行符时或读至文件尾时会结束读取。<br>getline()可以读取空格符，遇到换行符时或读至文件尾时结束读取。<br>cin.getline()作用和getline一样，只是cin.getline和cin都是标准输出流iosteeam中的对象方法，而getline这是属于string.h中的方法。</p>\n<h2 id=\"3-string-size-type类型\"><a href=\"#3-string-size-type类型\" class=\"headerlink\" title=\"3.string::size_type类型\"></a>3.string::size_type类型</h2><p><code>size_type</code>类型是c++定义的几种标准库类型的几种配套类型，其目的在于解决在不同机器中因为机器字长不同而导致string.size()的返回值无法存储的问题，比如在一个16位的机器中int整型存储的最大字符数为32767，但这对于储存一个文件大小的string来说这个大小是明显不够的，所以c++引入<code>size_type</code>，以解决不同机器上string.size()的返回值一定能被存储。<br><code>size_type</code>的本质是无符号类型所以在使用string.size()和有符号数做运算时要十分注意，因为这会导致计算结果出现异常。<br>需要注意的一点是<code>size_type</code>类型实际上不是一个确定的类型，在使用<code>size_type</code>时应注明<code>size_type</code>的类型，如:<code>string::size_type,vector&lt;int&gt;::size_type</code>。</p>\n<h2 id=\"4-cctype头文件提供的一些字符判断函数\"><a href=\"#4-cctype头文件提供的一些字符判断函数\" class=\"headerlink\" title=\"4.cctype头文件提供的一些字符判断函数\"></a>4.cctype头文件提供的一些字符判断函数</h2><ul>\n<li><p>isalnum(c) 当c是字母过数字时为真</p>\n</li>\n<li><p>isalpha(c) 当c是字母时为真</p>\n</li>\n<li><p>iscntrl(c) 当c是控制字符时为真</p>\n</li>\n<li><p>isdigit(c) 当c是数字时为真</p>\n</li>\n<li><p>isgraph(c) 当c不是空格但可以打印时为真</p>\n</li>\n<li><p>islower(c) 当c是小写字母时为真</p>\n</li>\n<li><p>isprint(c) 当c是可打印字符时为真(即c是空格或c具有可视化形式)</p>\n</li>\n<li><p>ispunct(c) 当c是标点符号时为真(即c不是控制字符、数字、字母、可打印空白中的一种)</p>\n</li>\n<li><p>isspace(c) 当c是空格时为真</p>\n</li>\n<li><p>isupper(c) 当c是大写字母时为真</p>\n</li>\n<li><p>isxdigit(c) 当c是16进制数字时为真</p>\n</li>\n<li><p>tolower(c) 如果c是大写字母则输出其小写</p>\n</li>\n<li><p>toupper(c) 如果c是小写字母则输出其大写</p>\n</li>\n</ul>\n<h2 id=\"5-c-11的“foreach”\"><a href=\"#5-c-11的“foreach”\" class=\"headerlink\" title=\"5.c++11的“foreach”\"></a>5.c++11的“foreach”</h2><p>c++本没有foreach循环，但是c++11为for语句添加了新的语法:<br>for(param:array){}这个for语法每次循环从array中读取一个数据并存放在param中用于操作<br>需要注意的是param如果不使用引用的话，param实际是array中元素的拷贝，此时对param进行修改不会改变array的元素，如需要更改array中的元素的值时需要对param取引用。<br>还有一点十分重要的是不可以在范围for语句中更改array的容量大小，这是因为能被范围for遍历的序列都需要包含begin,end两个返回迭代器的成员，我们可以先看一下范围for的源码:<br>for(auto beg=v.begin(),end=v.end();beg!=end;++beg)<br>{<br>}<br>可以看到在范围for中实际上在循环前就已经存储了可遍历序列的begin,end迭代器，所以如果在循环中改变了序列的大小循环就会出错。</p>\n<h2 id=\"6-vector容器的初始化方式\"><a href=\"#6-vector容器的初始化方式\" class=\"headerlink\" title=\"6.vector容器的初始化方式\"></a>6.vector容器的初始化方式</h2><ul>\n<li>vector<T> v v是一个空的vector</T></li>\n<li>vector<T> v2(v) v2是一个包含v所有副本的的vector</T></li>\n<li>vector<T> v2=v 等价物v2(v)</T></li>\n<li>vector<T> v(n,val) v是一个包含了n个重复元素，每个元素都是val的vector</T></li>\n<li>vector<T> v(n) v是一个包含了n个重复执行了初始化的对象</T></li>\n<li>vector<T> v{a,b,c……} v是一个包含了初始值个数元素的vector，每个元素被赋予对应的初始值</T></li>\n<li>vector<T> v={a,b,c……} 等于v{a,b,c……}</T></li>\n<li><font color=\"red\"> 使用数组初始化vector容器，vector<T>(begin(array),end(array))，其中begin(array)是数组array的首地址，end(array)是数组array的尾地址 </T></font></li>\n</ul>\n<h2 id=\"7-vector对象能高效增长\"><a href=\"#7-vector对象能高效增长\" class=\"headerlink\" title=\"7.vector对象能高效增长\"></a>7.vector对象能高效增长</h2><p>c++标准要求vector容器在运行时能高效快速地添加元素，在c++11标准中vector的动态添加元素的性能要优于预先规定容器大小的性能，只有一种情况例外，就是vector中的元素全部都是相同的时候这种情况会反过来。</p>\n<h2 id=\"8-迭代器的end\"><a href=\"#8-迭代器的end\" class=\"headerlink\" title=\"8.迭代器的end\"></a>8.迭代器的end</h2><p>迭代器的end()并不实际指向某个元素，所以不能对其进行递增或解引用操作。 </p>\n<h2 id=\"9-iterator和const-iterator\"><a href=\"#9-iterator和const-iterator\" class=\"headerlink\" title=\"9.iterator和const_iterator\"></a>9.iterator和const_iterator</h2><p>iterator和<code>const_iterator</code>是标准库定义的迭代器的类型，一般迭代器没有固定的类型，一般使用<code>类型::iterator</code>或<code>const_iterator</code>来确定迭代器的类型，如：<code>vector&lt;int&gt;::iterator  it</code><br><code>iterator</code>为可读可写迭代器，<code>iterator</code>迭代器只能用于非常量容器；<br><code>const_iterator</code>为只读迭代器，<code>const_iterator</code>既可以用于非常量容器又可以用于常量容器，但是常量容器只能使用<code>const_iterator</code>迭代器。</p>\n<h2 id=\"10-cbegin与cend\"><a href=\"#10-cbegin与cend\" class=\"headerlink\" title=\"10.cbegin与cend\"></a>10.cbegin与cend</h2><p>cbegin和cend与begin和end相对，cbegin和cend返回const_iterator迭代器。</p>\n<h2 id=\"11-迭代器的-gt-运算符\"><a href=\"#11-迭代器的-gt-运算符\" class=\"headerlink\" title=\"11.迭代器的-&gt;运算符\"></a>11.迭代器的-&gt;运算符</h2><p>在使用迭代器的过程中经常需要通过解引用后再进行.运算，如：<code>(*it).empty()</code>，操作较为繁琐，c++11对这个操作进行了简化，即通过-&gt;运算来替换<code>(*it).</code>，前面的操作就可以替换为<code>it-&gt;empty()</code></p>\n<h2 id=\"12-容器的删添操作会是迭代器、引用和指针失效\"><a href=\"#12-容器的删添操作会是迭代器、引用和指针失效\" class=\"headerlink\" title=\"12.容器的删添操作会是迭代器、引用和指针失效\"></a>12.容器的删添操作会是迭代器、引用和指针失效</h2><p><font color=\"red\">这是因为容器的删添操作可能会出现存储空间的重新分配，用string作为例子是最贴切的，当我们想一个string字符串中添加一个字符时，如：</font></p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">sting v</span> = <span class=\"hljs-string\">&quot;str&quot;</span>;<br><span class=\"hljs-attribute\">v</span> = v + ‘s’;<br><br></code></pre></td></tr></table></figure>\n<p><font color=\"red\">程序的实际操作是先创建一个临时变量来存储添加之后的字符串strs，然后再将v指向新分配的存储空间，于是指向之前空间位置的迭代器、引用和指针自然就失效了。</font></p>\n<h2 id=\"13-迭代器的运算\"><a href=\"#13-迭代器的运算\" class=\"headerlink\" title=\"13.迭代器的运算\"></a>13.迭代器的运算</h2><p><img src=\"https://i.loli.net/2020/08/27/EG2yOZL4H8YvhsT.jpg\" alt=\"Alt\"></p>\n<p>迭代器之后同时也可以进行加减运算其结果为dfference_type的带符号整型数表示两个迭代器之间的距离。</p>\n<h2 id=\"14-数组的特殊性\"><a href=\"#14-数组的特殊性\" class=\"headerlink\" title=\"14.数组的特殊性\"></a>14.数组的特殊性</h2><p><font color=\"red\">不能使数组来初始化数组，也不能使用数组来赋值数组，有的编译器支持数组初始化和赋值这是编译器的自身扩展，但仍然不应该这样做，因为当换了编译环境后程序可能就会出错人。</font></p>\n<h2 id=\"15-存放存放指针的数组和指向数组的指针\"><a href=\"#15-存放存放指针的数组和指向数组的指针\" class=\"headerlink\" title=\"15.存放存放指针的数组和指向数组的指针\"></a>15.存放存放指针的数组和指向数组的指针</h2><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs less\"><span class=\"hljs-selector-tag\">int</span> *<span class=\"hljs-selector-tag\">ptr</span><span class=\"hljs-selector-attr\">[2]</span>;<span class=\"hljs-comment\">//拥有两个指针成员的数组</span><br><span class=\"hljs-selector-tag\">int</span> <span class=\"hljs-selector-tag\">&amp;</span><span class=\"hljs-selector-tag\">ptr2</span><span class=\"hljs-selector-attr\">[2]</span>;<span class=\"hljs-comment\">//错误，不存在引用数组</span><br><span class=\"hljs-selector-tag\">int</span> (*ptr3)<span class=\"hljs-selector-attr\">[2]</span>;<span class=\"hljs-comment\">//指向有两个长度的整型数组的指针</span><br><span class=\"hljs-selector-tag\">int</span> (&amp;ptr4)<span class=\"hljs-selector-attr\">[2]</span>;<span class=\"hljs-comment\">//指向两个长度的整型数组的引用</span><br><br></code></pre></td></tr></table></figure>\n<h2 id=\"16-数组和指针\"><a href=\"#16-数组和指针\" class=\"headerlink\" title=\"16.数组和指针\"></a>16.数组和指针</h2><p>数组的名字实际上就是指向数组收地址的指针，所以下面操作得到是指针：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">int</span> arr[<span class=\"hljs-number\">2</span>] = &#123;&#125;;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">auto</span> <span class=\"hljs-title\">ptr</span><span class=\"hljs-params\">(arr)</span></span>;<span class=\"hljs-comment\">//per是一个指向arr首地址的int*类型指针</span><br><br></code></pre></td></tr></table></figure>\n<p><font color=\"red\">使用decltype进行上面的操作不会得到指针，而是得到数组，如：</font></p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">decltype</span>(arr) arr<span class=\"hljs-number\">2</span> = &#123;<span class=\"hljs-number\">1</span>&#125;;//arr<span class=\"hljs-number\">2</span>是一个包含一个元素的int型数组<br></code></pre></td></tr></table></figure>\n<p><font color=\"red\">对数组执行下标运算实质上是对指向数组首地址的指针执行下标运算，如：</font></p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs angelscript\"><span class=\"hljs-built_in\">int</span> i = ia[<span class=\"hljs-number\">2</span>]; <span class=\"hljs-comment\">//实际得到是(ia+2)所指向的元素</span><br></code></pre></td></tr></table></figure>\n\n<p><font color=\"red\">数组的下标运算只要不超过数组长度就可以执行下标运算，如：含有10个元素数组下标从0-9，但是 下标运算可以取到10，即a[10]，a[10]是数组的尾元素的下一个位置，但是对a[10]只能进行去地址运算(&amp;a[10])，不能对a[10]解引用或读取。</font></p>\n<h2 id=\"17-ptrdiff-t类型\"><a href=\"#17-ptrdiff-t类型\" class=\"headerlink\" title=\"17.ptrdiff_t类型\"></a>17.ptrdiff_t类型</h2><p>和<code>size_type</code>一样，<code>ptrdiff_t</code>是c++11专门定制给begin()与end()的运算结果的类型，用于适应不同机器的字长。<br><font color=\"red\">需要注意的是，内置数组下标值不是<code>ptrdiff_t</code>类型，如：a[1]，1就不是<code>ptrdiff_t</code>类型。</font></p>\n<h2 id=\"18-void-指针\"><a href=\"#18-void-指针\" class=\"headerlink\" title=\"18.void *指针\"></a>18.void *指针</h2><p>任何非常量值都可以存入<code>void *</code>指针中。</p>\n<h1 id=\"四、表达式\"><a href=\"#四、表达式\" class=\"headerlink\" title=\"四、表达式\"></a>四、表达式</h1><hr>\n<h2 id=\"1-为定义行为\"><a href=\"#1-为定义行为\" class=\"headerlink\" title=\"1.为定义行为\"></a>1.为定义行为</h2><p>c++中存在一些为定义行为，如&lt;&lt;运算符在c++中并没有定义其后表达式的运算顺序，此时运行下面代码就会出现为定义行为。</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-built_in\">cout</span>&lt;&lt;i&lt;&lt;<span class=\"hljs-string\">&quot;,&quot;</span>&lt;&lt;++i&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br></code></pre></td></tr></table></figure>\n<p>此时会出现0，1或1，1两种结果，这是因为&lt;&lt;没有明确指定何时及如何对运算对象求值，但是在实际使用过程中并没有出现上述情况，这可能是编译器为&lt;&lt;规定了运算顺序。</p>\n<h2 id=\"2-溢出与其他算术异常\"><a href=\"#2-溢出与其他算术异常\" class=\"headerlink\" title=\"2.溢出与其他算术异常\"></a>2.溢出与其他算术异常</h2><p><img src=\"https://i.loli.net/2020/09/04/QRnNjiTqEeOGaLV.jpg\" alt=\"6\"></p>\n<h2 id=\"3-运算符的优先级\"><a href=\"#3-运算符的优先级\" class=\"headerlink\" title=\"3.运算符的优先级\"></a>3.运算符的优先级</h2><p><img src=\"https://i.loli.net/2020/10/09/6aVu9jBoswIgUEY.jpg\" alt=\"Alt\"></p>\n<h2 id=\"4-前置递增运算符与后置递增运算符的运行过程\"><a href=\"#4-前置递增运算符与后置递增运算符的运行过程\" class=\"headerlink\" title=\"4.前置递增运算符与后置递增运算符的运行过程\"></a>4.前置递增运算符与后置递增运算符的运行过程</h2><p>前置递增运算符先将对象递增之后再返回递增后的结果，而后置递增运算符则先创建一个临时变量先将旧的值存储起来，然后再将变量递增，再将旧的值返回。<br>相对于前置递增运算符，后置递增运算符需要创建一个临时变量，这就产生了一个消耗，在一些普通的后置递增运算中可能不大可看得出来，但在较为复杂的迭代器中这种额外的消耗就会产生巨大的性能浪费，所以平时使用时尽量使用前置递增运算符。</p>\n<h2 id=\"5-表达式在运算过程中值发生变化\"><a href=\"#5-表达式在运算过程中值发生变化\" class=\"headerlink\" title=\"5.表达式在运算过程中值发生变化\"></a>5.表达式在运算过程中值发生变化</h2><p><font color=\"red\">在一个运算表达式中，参与运算的值不应该在运算的过程中发生变化，否则极易造成未定义行为，如：</font><br><font color=\"red\"><code>v[i++]&lt;v[i]</code>，在大于号运算的过程中v[i++]的值向后移动了一位，造成了值的变化，由于C++没有定义二元运算符两端未定义自增运算符的运算顺序，所级就造成了未定义行为。</font></p>\n<h2 id=\"6-有符号数的位运算\"><a href=\"#6-有符号数的位运算\" class=\"headerlink\" title=\"6.有符号数的位运算\"></a>6.有符号数的位运算</h2><p>有符号数尽量不要做位运算，因为位运算容易改变有符号数的符号位导致未定义行为。</p>\n<h2 id=\"7-位运算中的类型提升\"><a href=\"#7-位运算中的类型提升\" class=\"headerlink\" title=\"7.位运算中的类型提升\"></a>7.位运算中的类型提升</h2><p>在程序编写时需要注意，任何占字节小于int类型的类型变量进行位运算时都会产生类型提升而被转换成int类型，如下代码所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br><span class=\"hljs-keyword\">char</span> s=<span class=\"hljs-string\">&#x27;s&#x27;</span>;<br><span class=\"hljs-keyword\">short</span> a=<span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">bool</span> b=<span class=\"hljs-literal\">true</span>;<br><span class=\"hljs-keyword\">long</span> c=<span class=\"hljs-number\">2</span>;<br><span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-keyword\">sizeof</span>(s)&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-keyword\">sizeof</span>(~s)&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-keyword\">sizeof</span>(s&lt;&lt;<span class=\"hljs-number\">1</span>)&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">&quot;----------&quot;</span>&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-keyword\">sizeof</span>(a)&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-keyword\">sizeof</span>(~a)&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">&quot;----------&quot;</span>&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-keyword\">sizeof</span>(b)&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-keyword\">sizeof</span>(~b)&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">&quot;----------&quot;</span>&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-keyword\">sizeof</span>(c)&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-keyword\">sizeof</span>(~c)&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">&quot;----------&quot;</span>&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span>&lt;&lt;~s&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span>&lt;&lt;~b&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>输出结果：<br><img src=\"https://i.loli.net/2020/10/23/GUI54xhOrQs7oyK.jpg\" alt=\"Alt\"></p>\n<h2 id=\"8-sizeof计算指针大小\"><a href=\"#8-sizeof计算指针大小\" class=\"headerlink\" title=\"8.sizeof计算指针大小\"></a>8.sizeof计算指针大小</h2><p>sizeof在计算指针时有个很有趣的现象，因为sizeof满足右结合律且优先级与<code>*</code>相同，所以在<code>sizeof *p</code>中，先对p解引用，然后在对解引用后的内容计算所占内存大小，由于sizeof并没有使用解引用的内容，所以<code>*p</code>是否为空是否有效对sizeof的计算没有影响。<br><code>sizeof *p</code> == <code>sizeof(*p)</code></p>\n<h2 id=\"9-隐式转换的过程\"><a href=\"#9-隐式转换的过程\" class=\"headerlink\" title=\"9.隐式转换的过程\"></a>9.隐式转换的过程</h2><p>以<code>int a=3.14+3；</code>为例<br>在这个例子中3.14是山比double类型，3是int类型，运算时为了保证精度C++会将int类型转换成double类型，而不是因为结果是int类型而将double类型转换成int类型，所以在表达示右侧的运算过程得到的结果是一个double类型的值，当这个值被赋值给a的时候才进行double到int的类型转换。</p>\n<hr>\n<h1 id=\"五、语句\"><a href=\"#五、语句\" class=\"headerlink\" title=\"五、语句\"></a>五、语句</h1><hr>\n<h2 id=\"1-switch语句跨case标签引用变量\"><a href=\"#1-switch语句跨case标签引用变量\" class=\"headerlink\" title=\"1.switch语句跨case标签引用变量\"></a>1.switch语句跨case标签引用变量</h2><p>若需要在一个 case 语句下定义变量同时在多个 case 语下使用这个变量，则定义变量时不能同时初始化变量，应另起等于初始变量，否则编译器会报跨标签访问错误，如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">switch</span> (a)<br>&#123;<br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">0</span>:<br>        <span class=\"hljs-keyword\">int</span> b;  <span class=\"hljs-comment\">//如果直接int b=1;则会报跨标签访问错误</span><br>        b=<span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-keyword\">break</span>;<br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">1</span>:<br>        <span class=\"hljs-built_in\">cout</span>&lt;&lt;b&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br>        <span class=\"hljs-keyword\">break</span>;<br>    <span class=\"hljs-keyword\">default</span>:<br>        ;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"2-C-无法捕获计算溢出异常和除0异常\"><a href=\"#2-C-无法捕获计算溢出异常和除0异常\" class=\"headerlink\" title=\"2.C++无法捕获计算溢出异常和除0异常\"></a>2.C++无法捕获计算溢出异常和除0异常</h2><p>C++认为计算溢出和除0异常属于底层事件，应被同样底层的事件去处理，所以C++没有提供计算溢出和除0异常，如果需要捕获这两类异常在Windows系统中应使用Windows提供的SEH模型<code>__try</code>、<code>__except</code>、<code>__finally</code>异常语句，使用方法和try-catch基本类似，与try-catch不同的是，SEH中使用的是<code>__try-__except</code>搭配和<code>__try-__finally</code>搭配。</p>\n<hr>\n<h1 id=\"六、函数\"><a href=\"#六、函数\" class=\"headerlink\" title=\"六、函数\"></a>六、函数</h1><hr>\n<h2 id=\"1-静态局布变量\"><a href=\"#1-静态局布变量\" class=\"headerlink\" title=\"1.静态局布变量\"></a>1.静态局布变量</h2><p>在函数体内使用static关键字可以效静态局布量，静态局布变量的生命周期从变量定义到程序结束，但是静态局布变量只对函数可见，在函数外不可访问。</p>\n<h2 id=\"2-C-程序的编译过程\"><a href=\"#2-C-程序的编译过程\" class=\"headerlink\" title=\"2.C++程序的编译过程\"></a>2.C++程序的编译过程</h2><p><img src=\"https://i.loli.net/2020/11/09/bJ5xRFg6TGHnLCO.jpg\" alt=\"Alt\"></p>\n<h2 id=\"3-函数调用过程中的形参创建\"><a href=\"#3-函数调用过程中的形参创建\" class=\"headerlink\" title=\"3.函数调用过程中的形参创建\"></a>3.函数调用过程中的形参创建</h2><p>函数的每一次调用都会重新创建形参并传入实参对其进行初始化，形餐盘类型决定了形参与实参的交互类型，如果形参是引用类型，则形参与相对应的实参相绑定，作为实参的别名使用；如果形参是值类型，则实参的值拷贝给形参，形参与实参相互独立。</p>\n<h2 id=\"4-函数的指针参数传递\"><a href=\"#4-函数的指针参数传递\" class=\"headerlink\" title=\"4.函数的指针参数传递\"></a>4.函数的指针参数传递</h2><p><font color=\"red\">当指针作为实参传递给函数形参时，传递的是指针的值拷贝而不是指针所指的对象，且形参指针与实参指针是两个不同的指针，此时形参指针与实参指针指向同一对象，修改形参的指针指向不会影实参指针。</font></p>\n<h2 id=\"5-引用形参的限制\"><a href=\"#5-引用形参的限制\" class=\"headerlink\" title=\"5.引用形参的限制\"></a>5.引用形参的限制</h2><ul>\n<li><p>如果将函数的参数定义普通引用参数，那么这个形参就无法接受const对象、字面值和需要类型转换的对象作为实参。</p>\n</li>\n<li><p>如果将函数的参数定义为const引用参数，这个参数可以接受第一条中的参数，但是却无法修改参数的值。</p>\n</li>\n</ul>\n<h2 id=\"6-数组的两个特殊性质\"><a href=\"#6-数组的两个特殊性质\" class=\"headerlink\" title=\"6.数组的两个特殊性质\"></a>6.数组的两个特殊性质</h2><ul>\n<li>数组不可被拷贝</li>\n<li>数组再使用时被转换为指针</li>\n</ul>\n<h2 id=\"7-数组引用形参\"><a href=\"#7-数组引用形参\" class=\"headerlink\" title=\"7.数组引用形参\"></a>7.数组引用形参</h2><p>当我们使用数组作普通形参时，</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs kotlin\">void <span class=\"hljs-function\"><span class=\"hljs-title\">fun</span><span class=\"hljs-params\">(int* arr)</span></span>;<br>void <span class=\"hljs-function\"><span class=\"hljs-title\">fun</span><span class=\"hljs-params\">(int arr[])</span></span>;<br>void <span class=\"hljs-function\"><span class=\"hljs-title\">fun</span><span class=\"hljs-params\">(int arr[<span class=\"hljs-number\">10</span>])</span></span>;<br></code></pre></td></tr></table></figure>\n<p>表示的都是同一个函数，且形参可接受任意长度的实参数组，但是当将普通形参改为引用形参时，</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs kotlin\">void <span class=\"hljs-function\"><span class=\"hljs-title\">fun</span><span class=\"hljs-params\">(int (&amp;arr)</span></span>[<span class=\"hljs-number\">10</span>]);<br></code></pre></td></tr></table></figure>\n<p><code>(&amp;arr)</code>中()不可缺少，否则形参变成引用的数组而非数组的引用，且形参只能接收长度为10的数组。</p>\n<h2 id=\"8-main函数传参\"><a href=\"#8-main函数传参\" class=\"headerlink\" title=\"8.main函数传参\"></a>8.main函数传参</h2><p>有的时候我们会遇到这样的main函数：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> argc,<span class=\"hljs-keyword\">char</span>** argv)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>通常情况下，直接使用argv，argv中的内容是空的，那么main函数在什么情况下会接收参数呢？<br>事实上main函数本身就是当前程序的入口，在当前程序中没有其他程序为main函数传入参数了，当我们把写好的程序打包后在外部调用时就可以给main函数传入参数了，如在CMD中调程序</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">prog -o -d ofile data0<span class=\"hljs-regexp\">//</span>prog为程序名<br></code></pre></td></tr></table></figure>\n<p><font color=\"red\">需要注意的是argv数组的0号索引存储程序的名字，参数从1号索引开始存储，且最后一个索引位置固定内容为0</font></p>\n","site":{"data":{}},"excerpt":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h1 id=\"C-Primer-阅读笔记\"><a href=\"#C-Primer-阅读笔记\" class=\"headerlink\" title=\"C++ Primer 阅读笔记\"></a>C++ Primer 阅读笔记</h1><hr>","more":"<h1 id=\"一、开始\"><a href=\"#一、开始\" class=\"headerlink\" title=\"一、开始\"></a>一、开始</h1><hr>\n<h2 id=\"1-输入输出流的数据传输过程\"><a href=\"#1-输入输出流的数据传输过程\" class=\"headerlink\" title=\"1.输入输出流的数据传输过程\"></a>1.输入输出流的数据传输过程</h2><p><strong>输入:</strong><br>[窗]-&gt;[输入流对象(cin)]</p>\n<p><strong>输出:</strong><br>[输出流对象(cout，cerr，clog)-&gt;[窗口]</p>\n<p>c++从窗口中读取输入时不是直接存储在变量中而是先存储在istream类型对象cin中，输出是也非直接从变量输出到窗口而是先写入ostream对象cout/cerr/clog中，在从对象传输到窗口。</p>\n<h2 id=\"2-输出运算符“-lt-lt-”\"><a href=\"#2-输出运算符“-lt-lt-”\" class=\"headerlink\" title=\"2.输出运算符“&lt;&lt;”\"></a>2.输出运算符“&lt;&lt;”</h2><p>“&lt;&lt;”运算符输出的是一个ostream类型对象，“&lt;&lt;”接受两个运算对象，其中左侧的运算对象必须是一个ostream对象，右侧可以是需要输出的值，“&lt;&lt;”将需要输出的值写入到ostream对象中。<br>std::cout&lt;&lt;”num:”&lt;&lt;a&lt;&lt;std::endl；<br>“&lt;&lt;”连续表达式可以理解为:<br>((std::cout&lt;&lt;”num:”)&lt;&lt;a)&lt;&lt;std::endl；<br>每一个括号最终返回的都是一个ostream对象。其中endl是“操纵符”，运行效果是换行，并将与设备关联的缓冲区的内容刷新到设备中去，如果不写endl则在程序运行结束或缓冲区满后系统自动将缓冲区内容刷新到设备中去。<br>输入运算符“&gt;&gt;”和输出运算符运行逻辑一样。</p>\n<h2 id=\"3-char与unsigned-char\"><a href=\"#3-char与unsigned-char\" class=\"headerlink\" title=\"3.char与unsigned char\"></a>3.char与unsigned char</h2><p>在计算机中char也是分无符号和有符号两类的，char与int等类型不同的是，int等类型不显示标注unsigned默认为有符号数，而char在不同硬件环境中表示的类型可能是不一样的，所以为保证移植性最好在使用时指定signed和unsigned，c++标准不建议使用char来存储数值，这种区别主要出现在char类型向值类型的转换的过程中。</p>\n<h2 id=\"4-有符号数与无符号数的运算\"><a href=\"#4-有符号数与无符号数的运算\" class=\"headerlink\" title=\"4.有符号数与无符号数的运算\"></a>4.有符号数与无符号数的运算</h2><p>在c++运算优先级中，无符号数的优先级大于有符号数，所以当一个表达式中即存在有符号数又不存在无符号数时，运算将被转换为无符号数的运算，由于无符号数表示的最小值是0所以当表达式的运算结果为负数时就会出现运算错误。</p>\n<h2 id=\"5-c-11的四种变量初始化方式\"><a href=\"#5-c-11的四种变量初始化方式\" class=\"headerlink\" title=\"5.c++11的四种变量初始化方式\"></a>5.c++11的四种变量初始化方式</h2><p>int a=0;<br>int a={0};<br>int a{0};</p>\n<h2 id=\"int-a-0\"><a href=\"#int-a-0\" class=\"headerlink\" title=\"int a(0);\"></a>int a(0);</h2><h1 id=\"二、变量和基本类型\"><a href=\"#二、变量和基本类型\" class=\"headerlink\" title=\"二、变量和基本类型\"></a>二、变量和基本类型</h1><hr>\n<p>1.const引用的隐式类型转换<br>举例使用const限定的int类型的引用来引用double类型的变量的过程：double b=3.14;const int a=b;<br>在将double类型变量赋值给const int类型的引用时系统先创建一个临时变量，并将double隐式成int类型的结果存放到临时变量中，然后再将临时变量赋给引用，此时引用本质上是int类型的临时变量的别名，之后如果更改了double类型变量的值，引用值随之改变。</p>\n<h2 id=\"2-constexpr变量\"><a href=\"#2-constexpr变量\" class=\"headerlink\" title=\"2.constexpr变量\"></a>2.constexpr变量</h2><p>constexpr是一个常量表达式，与const不同的是，const限定的变量只能被常量、常量的引用、常量表达式和常量与常量引用的表达式赋值，而constexpr可以被常量、常量的引用、表达式、以及可以在编译阶段就确定返回值的函数赋值。const在程序运行时的本质是在程序用的const的地方直接替换成期对应<br>的常量，而constexpr则是替换其在编译器期计算出来的结果值。<br>constexpr的意义在于constexpr强制要求赋值给变量的表达式必须在编译阶段可计算出结果值，这对很多重复运算的简单表达式直接限定了在编译期只进行一次运算起到了优化效果。</p>\n<h2 id=\"3-constexpr指针\"><a href=\"#3-constexpr指针\" class=\"headerlink\" title=\"3.constexpr指针\"></a>3.constexpr指针</h2><p>被constexpr限定的指针的初始值只能是nullptr或者0或者指向一个地址固定不变的对象，这里需要注意在函数里的任何对象都不是存储在固定地址中的，所以constexpr限定的指针不能指向函数中的对象，全局对象则是存在在固定地址中的所以constexpr限定的指针可以指向这样的对象。</p>\n<h2 id=\"4-c-11的两种别名声明方法\"><a href=\"#4-c-11的两种别名声明方法\" class=\"headerlink\" title=\"4.c++ 11的两种别名声明方法\"></a>4.c++ 11的两种别名声明方法</h2><p>typedef bm int;<br>using bm=int;</p>\n<h2 id=\"5-decltype类型指示符\"><a href=\"#5-decltype类型指示符\" class=\"headerlink\" title=\"5.decltype类型指示符\"></a>5.decltype类型指示符</h2><p>decltype的作用是通过表达式或函数的返回值动态的推断其指示变量的类型，如：</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\">decltype(<span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span>()) <span class=\"hljs-title\">sum</span></span> = x;<span class=\"hljs-regexp\">//sum</span>的类型为<span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span>函数返回值的类型，<span class=\"hljs-title\">sum</span></span>的值由x赋予<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"顶层Const与底层Const\"><a href=\"#顶层Const与底层Const\" class=\"headerlink\" title=\"顶层Const与底层Const\"></a>顶层Const与底层Const</h2><p>由于指针本身也是一个对象，所以在Const修饰指针时，就立存在修饰指针或修饰指针所指的对象。如果Const修饰指针则是底层Const，如果修饰指针所指的对象则是顶层Const。</p>\n<figure class=\"highlight nim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nim\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">int</span>* pa;//<span class=\"hljs-keyword\">const</span>修饰指针，所以为底层<span class=\"hljs-keyword\">const</span><br><span class=\"hljs-built_in\">int</span>* <span class=\"hljs-keyword\">const</span> pb;//<span class=\"hljs-keyword\">const</span>修饰pb，所以为顶层<span class=\"hljs-keyword\">const</span><br></code></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"三、字符串、向量和数组\"><a href=\"#三、字符串、向量和数组\" class=\"headerlink\" title=\"三、字符串、向量和数组\"></a>三、字符串、向量和数组</h1><hr>\n<h2 id=\"1-c-11的string对象的初始化方式\"><a href=\"#1-c-11的string对象的初始化方式\" class=\"headerlink\" title=\"1.c++11的string对象的初始化方式\"></a>1.c++11的string对象的初始化方式</h2><p>string s;<br>string str=s;<br>string str(s);<br>string str(“str”);<br>string str=”str”;<br>string str(2,’s’);//这种形式得到的是字符串”ss”,其中括号里只能使用字符。</p>\n<h2 id=\"2-cin、getline-和cin-getline\"><a href=\"#2-cin、getline-和cin-getline\" class=\"headerlink\" title=\"2.cin、getline()和cin.getline()\"></a>2.cin、getline()和cin.getline()</h2><p>cin在对象在从缓存中读取数据时遇到空格符，制表符，换行符时或读至文件尾时会结束读取。<br>getline()可以读取空格符，遇到换行符时或读至文件尾时结束读取。<br>cin.getline()作用和getline一样，只是cin.getline和cin都是标准输出流iosteeam中的对象方法，而getline这是属于string.h中的方法。</p>\n<h2 id=\"3-string-size-type类型\"><a href=\"#3-string-size-type类型\" class=\"headerlink\" title=\"3.string::size_type类型\"></a>3.string::size_type类型</h2><p><code>size_type</code>类型是c++定义的几种标准库类型的几种配套类型，其目的在于解决在不同机器中因为机器字长不同而导致string.size()的返回值无法存储的问题，比如在一个16位的机器中int整型存储的最大字符数为32767，但这对于储存一个文件大小的string来说这个大小是明显不够的，所以c++引入<code>size_type</code>，以解决不同机器上string.size()的返回值一定能被存储。<br><code>size_type</code>的本质是无符号类型所以在使用string.size()和有符号数做运算时要十分注意，因为这会导致计算结果出现异常。<br>需要注意的一点是<code>size_type</code>类型实际上不是一个确定的类型，在使用<code>size_type</code>时应注明<code>size_type</code>的类型，如:<code>string::size_type,vector&lt;int&gt;::size_type</code>。</p>\n<h2 id=\"4-cctype头文件提供的一些字符判断函数\"><a href=\"#4-cctype头文件提供的一些字符判断函数\" class=\"headerlink\" title=\"4.cctype头文件提供的一些字符判断函数\"></a>4.cctype头文件提供的一些字符判断函数</h2><ul>\n<li><p>isalnum(c) 当c是字母过数字时为真</p>\n</li>\n<li><p>isalpha(c) 当c是字母时为真</p>\n</li>\n<li><p>iscntrl(c) 当c是控制字符时为真</p>\n</li>\n<li><p>isdigit(c) 当c是数字时为真</p>\n</li>\n<li><p>isgraph(c) 当c不是空格但可以打印时为真</p>\n</li>\n<li><p>islower(c) 当c是小写字母时为真</p>\n</li>\n<li><p>isprint(c) 当c是可打印字符时为真(即c是空格或c具有可视化形式)</p>\n</li>\n<li><p>ispunct(c) 当c是标点符号时为真(即c不是控制字符、数字、字母、可打印空白中的一种)</p>\n</li>\n<li><p>isspace(c) 当c是空格时为真</p>\n</li>\n<li><p>isupper(c) 当c是大写字母时为真</p>\n</li>\n<li><p>isxdigit(c) 当c是16进制数字时为真</p>\n</li>\n<li><p>tolower(c) 如果c是大写字母则输出其小写</p>\n</li>\n<li><p>toupper(c) 如果c是小写字母则输出其大写</p>\n</li>\n</ul>\n<h2 id=\"5-c-11的“foreach”\"><a href=\"#5-c-11的“foreach”\" class=\"headerlink\" title=\"5.c++11的“foreach”\"></a>5.c++11的“foreach”</h2><p>c++本没有foreach循环，但是c++11为for语句添加了新的语法:<br>for(param:array){}这个for语法每次循环从array中读取一个数据并存放在param中用于操作<br>需要注意的是param如果不使用引用的话，param实际是array中元素的拷贝，此时对param进行修改不会改变array的元素，如需要更改array中的元素的值时需要对param取引用。<br>还有一点十分重要的是不可以在范围for语句中更改array的容量大小，这是因为能被范围for遍历的序列都需要包含begin,end两个返回迭代器的成员，我们可以先看一下范围for的源码:<br>for(auto beg=v.begin(),end=v.end();beg!=end;++beg)<br>{<br>}<br>可以看到在范围for中实际上在循环前就已经存储了可遍历序列的begin,end迭代器，所以如果在循环中改变了序列的大小循环就会出错。</p>\n<h2 id=\"6-vector容器的初始化方式\"><a href=\"#6-vector容器的初始化方式\" class=\"headerlink\" title=\"6.vector容器的初始化方式\"></a>6.vector容器的初始化方式</h2><ul>\n<li>vector<T> v v是一个空的vector</T></li>\n<li>vector<T> v2(v) v2是一个包含v所有副本的的vector</T></li>\n<li>vector<T> v2=v 等价物v2(v)</T></li>\n<li>vector<T> v(n,val) v是一个包含了n个重复元素，每个元素都是val的vector</T></li>\n<li>vector<T> v(n) v是一个包含了n个重复执行了初始化的对象</T></li>\n<li>vector<T> v{a,b,c……} v是一个包含了初始值个数元素的vector，每个元素被赋予对应的初始值</T></li>\n<li>vector<T> v={a,b,c……} 等于v{a,b,c……}</T></li>\n<li><font color=\"red\"> 使用数组初始化vector容器，vector<T>(begin(array),end(array))，其中begin(array)是数组array的首地址，end(array)是数组array的尾地址 </T></font></li>\n</ul>\n<h2 id=\"7-vector对象能高效增长\"><a href=\"#7-vector对象能高效增长\" class=\"headerlink\" title=\"7.vector对象能高效增长\"></a>7.vector对象能高效增长</h2><p>c++标准要求vector容器在运行时能高效快速地添加元素，在c++11标准中vector的动态添加元素的性能要优于预先规定容器大小的性能，只有一种情况例外，就是vector中的元素全部都是相同的时候这种情况会反过来。</p>\n<h2 id=\"8-迭代器的end\"><a href=\"#8-迭代器的end\" class=\"headerlink\" title=\"8.迭代器的end\"></a>8.迭代器的end</h2><p>迭代器的end()并不实际指向某个元素，所以不能对其进行递增或解引用操作。 </p>\n<h2 id=\"9-iterator和const-iterator\"><a href=\"#9-iterator和const-iterator\" class=\"headerlink\" title=\"9.iterator和const_iterator\"></a>9.iterator和const_iterator</h2><p>iterator和<code>const_iterator</code>是标准库定义的迭代器的类型，一般迭代器没有固定的类型，一般使用<code>类型::iterator</code>或<code>const_iterator</code>来确定迭代器的类型，如：<code>vector&lt;int&gt;::iterator  it</code><br><code>iterator</code>为可读可写迭代器，<code>iterator</code>迭代器只能用于非常量容器；<br><code>const_iterator</code>为只读迭代器，<code>const_iterator</code>既可以用于非常量容器又可以用于常量容器，但是常量容器只能使用<code>const_iterator</code>迭代器。</p>\n<h2 id=\"10-cbegin与cend\"><a href=\"#10-cbegin与cend\" class=\"headerlink\" title=\"10.cbegin与cend\"></a>10.cbegin与cend</h2><p>cbegin和cend与begin和end相对，cbegin和cend返回const_iterator迭代器。</p>\n<h2 id=\"11-迭代器的-gt-运算符\"><a href=\"#11-迭代器的-gt-运算符\" class=\"headerlink\" title=\"11.迭代器的-&gt;运算符\"></a>11.迭代器的-&gt;运算符</h2><p>在使用迭代器的过程中经常需要通过解引用后再进行.运算，如：<code>(*it).empty()</code>，操作较为繁琐，c++11对这个操作进行了简化，即通过-&gt;运算来替换<code>(*it).</code>，前面的操作就可以替换为<code>it-&gt;empty()</code></p>\n<h2 id=\"12-容器的删添操作会是迭代器、引用和指针失效\"><a href=\"#12-容器的删添操作会是迭代器、引用和指针失效\" class=\"headerlink\" title=\"12.容器的删添操作会是迭代器、引用和指针失效\"></a>12.容器的删添操作会是迭代器、引用和指针失效</h2><p><font color=\"red\">这是因为容器的删添操作可能会出现存储空间的重新分配，用string作为例子是最贴切的，当我们想一个string字符串中添加一个字符时，如：</font></p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">sting v</span> = <span class=\"hljs-string\">&quot;str&quot;</span>;<br><span class=\"hljs-attribute\">v</span> = v + ‘s’;<br><br></code></pre></td></tr></table></figure>\n<p><font color=\"red\">程序的实际操作是先创建一个临时变量来存储添加之后的字符串strs，然后再将v指向新分配的存储空间，于是指向之前空间位置的迭代器、引用和指针自然就失效了。</font></p>\n<h2 id=\"13-迭代器的运算\"><a href=\"#13-迭代器的运算\" class=\"headerlink\" title=\"13.迭代器的运算\"></a>13.迭代器的运算</h2><p><img src=\"https://i.loli.net/2020/08/27/EG2yOZL4H8YvhsT.jpg\" alt=\"Alt\"></p>\n<p>迭代器之后同时也可以进行加减运算其结果为dfference_type的带符号整型数表示两个迭代器之间的距离。</p>\n<h2 id=\"14-数组的特殊性\"><a href=\"#14-数组的特殊性\" class=\"headerlink\" title=\"14.数组的特殊性\"></a>14.数组的特殊性</h2><p><font color=\"red\">不能使数组来初始化数组，也不能使用数组来赋值数组，有的编译器支持数组初始化和赋值这是编译器的自身扩展，但仍然不应该这样做，因为当换了编译环境后程序可能就会出错人。</font></p>\n<h2 id=\"15-存放存放指针的数组和指向数组的指针\"><a href=\"#15-存放存放指针的数组和指向数组的指针\" class=\"headerlink\" title=\"15.存放存放指针的数组和指向数组的指针\"></a>15.存放存放指针的数组和指向数组的指针</h2><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs less\"><span class=\"hljs-selector-tag\">int</span> *<span class=\"hljs-selector-tag\">ptr</span><span class=\"hljs-selector-attr\">[2]</span>;<span class=\"hljs-comment\">//拥有两个指针成员的数组</span><br><span class=\"hljs-selector-tag\">int</span> <span class=\"hljs-selector-tag\">&amp;</span><span class=\"hljs-selector-tag\">ptr2</span><span class=\"hljs-selector-attr\">[2]</span>;<span class=\"hljs-comment\">//错误，不存在引用数组</span><br><span class=\"hljs-selector-tag\">int</span> (*ptr3)<span class=\"hljs-selector-attr\">[2]</span>;<span class=\"hljs-comment\">//指向有两个长度的整型数组的指针</span><br><span class=\"hljs-selector-tag\">int</span> (&amp;ptr4)<span class=\"hljs-selector-attr\">[2]</span>;<span class=\"hljs-comment\">//指向两个长度的整型数组的引用</span><br><br></code></pre></td></tr></table></figure>\n<h2 id=\"16-数组和指针\"><a href=\"#16-数组和指针\" class=\"headerlink\" title=\"16.数组和指针\"></a>16.数组和指针</h2><p>数组的名字实际上就是指向数组收地址的指针，所以下面操作得到是指针：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">int</span> arr[<span class=\"hljs-number\">2</span>] = &#123;&#125;;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">auto</span> <span class=\"hljs-title\">ptr</span><span class=\"hljs-params\">(arr)</span></span>;<span class=\"hljs-comment\">//per是一个指向arr首地址的int*类型指针</span><br><br></code></pre></td></tr></table></figure>\n<p><font color=\"red\">使用decltype进行上面的操作不会得到指针，而是得到数组，如：</font></p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">decltype</span>(arr) arr<span class=\"hljs-number\">2</span> = &#123;<span class=\"hljs-number\">1</span>&#125;;//arr<span class=\"hljs-number\">2</span>是一个包含一个元素的int型数组<br></code></pre></td></tr></table></figure>\n<p><font color=\"red\">对数组执行下标运算实质上是对指向数组首地址的指针执行下标运算，如：</font></p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs angelscript\"><span class=\"hljs-built_in\">int</span> i = ia[<span class=\"hljs-number\">2</span>]; <span class=\"hljs-comment\">//实际得到是(ia+2)所指向的元素</span><br></code></pre></td></tr></table></figure>\n\n<p><font color=\"red\">数组的下标运算只要不超过数组长度就可以执行下标运算，如：含有10个元素数组下标从0-9，但是 下标运算可以取到10，即a[10]，a[10]是数组的尾元素的下一个位置，但是对a[10]只能进行去地址运算(&amp;a[10])，不能对a[10]解引用或读取。</font></p>\n<h2 id=\"17-ptrdiff-t类型\"><a href=\"#17-ptrdiff-t类型\" class=\"headerlink\" title=\"17.ptrdiff_t类型\"></a>17.ptrdiff_t类型</h2><p>和<code>size_type</code>一样，<code>ptrdiff_t</code>是c++11专门定制给begin()与end()的运算结果的类型，用于适应不同机器的字长。<br><font color=\"red\">需要注意的是，内置数组下标值不是<code>ptrdiff_t</code>类型，如：a[1]，1就不是<code>ptrdiff_t</code>类型。</font></p>\n<h2 id=\"18-void-指针\"><a href=\"#18-void-指针\" class=\"headerlink\" title=\"18.void *指针\"></a>18.void *指针</h2><p>任何非常量值都可以存入<code>void *</code>指针中。</p>\n<h1 id=\"四、表达式\"><a href=\"#四、表达式\" class=\"headerlink\" title=\"四、表达式\"></a>四、表达式</h1><hr>\n<h2 id=\"1-为定义行为\"><a href=\"#1-为定义行为\" class=\"headerlink\" title=\"1.为定义行为\"></a>1.为定义行为</h2><p>c++中存在一些为定义行为，如&lt;&lt;运算符在c++中并没有定义其后表达式的运算顺序，此时运行下面代码就会出现为定义行为。</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-built_in\">cout</span>&lt;&lt;i&lt;&lt;<span class=\"hljs-string\">&quot;,&quot;</span>&lt;&lt;++i&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br></code></pre></td></tr></table></figure>\n<p>此时会出现0，1或1，1两种结果，这是因为&lt;&lt;没有明确指定何时及如何对运算对象求值，但是在实际使用过程中并没有出现上述情况，这可能是编译器为&lt;&lt;规定了运算顺序。</p>\n<h2 id=\"2-溢出与其他算术异常\"><a href=\"#2-溢出与其他算术异常\" class=\"headerlink\" title=\"2.溢出与其他算术异常\"></a>2.溢出与其他算术异常</h2><p><img src=\"https://i.loli.net/2020/09/04/QRnNjiTqEeOGaLV.jpg\" alt=\"6\"></p>\n<h2 id=\"3-运算符的优先级\"><a href=\"#3-运算符的优先级\" class=\"headerlink\" title=\"3.运算符的优先级\"></a>3.运算符的优先级</h2><p><img src=\"https://i.loli.net/2020/10/09/6aVu9jBoswIgUEY.jpg\" alt=\"Alt\"></p>\n<h2 id=\"4-前置递增运算符与后置递增运算符的运行过程\"><a href=\"#4-前置递增运算符与后置递增运算符的运行过程\" class=\"headerlink\" title=\"4.前置递增运算符与后置递增运算符的运行过程\"></a>4.前置递增运算符与后置递增运算符的运行过程</h2><p>前置递增运算符先将对象递增之后再返回递增后的结果，而后置递增运算符则先创建一个临时变量先将旧的值存储起来，然后再将变量递增，再将旧的值返回。<br>相对于前置递增运算符，后置递增运算符需要创建一个临时变量，这就产生了一个消耗，在一些普通的后置递增运算中可能不大可看得出来，但在较为复杂的迭代器中这种额外的消耗就会产生巨大的性能浪费，所以平时使用时尽量使用前置递增运算符。</p>\n<h2 id=\"5-表达式在运算过程中值发生变化\"><a href=\"#5-表达式在运算过程中值发生变化\" class=\"headerlink\" title=\"5.表达式在运算过程中值发生变化\"></a>5.表达式在运算过程中值发生变化</h2><p><font color=\"red\">在一个运算表达式中，参与运算的值不应该在运算的过程中发生变化，否则极易造成未定义行为，如：</font><br><font color=\"red\"><code>v[i++]&lt;v[i]</code>，在大于号运算的过程中v[i++]的值向后移动了一位，造成了值的变化，由于C++没有定义二元运算符两端未定义自增运算符的运算顺序，所级就造成了未定义行为。</font></p>\n<h2 id=\"6-有符号数的位运算\"><a href=\"#6-有符号数的位运算\" class=\"headerlink\" title=\"6.有符号数的位运算\"></a>6.有符号数的位运算</h2><p>有符号数尽量不要做位运算，因为位运算容易改变有符号数的符号位导致未定义行为。</p>\n<h2 id=\"7-位运算中的类型提升\"><a href=\"#7-位运算中的类型提升\" class=\"headerlink\" title=\"7.位运算中的类型提升\"></a>7.位运算中的类型提升</h2><p>在程序编写时需要注意，任何占字节小于int类型的类型变量进行位运算时都会产生类型提升而被转换成int类型，如下代码所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br><span class=\"hljs-keyword\">char</span> s=<span class=\"hljs-string\">&#x27;s&#x27;</span>;<br><span class=\"hljs-keyword\">short</span> a=<span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">bool</span> b=<span class=\"hljs-literal\">true</span>;<br><span class=\"hljs-keyword\">long</span> c=<span class=\"hljs-number\">2</span>;<br><span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-keyword\">sizeof</span>(s)&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-keyword\">sizeof</span>(~s)&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-keyword\">sizeof</span>(s&lt;&lt;<span class=\"hljs-number\">1</span>)&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">&quot;----------&quot;</span>&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-keyword\">sizeof</span>(a)&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-keyword\">sizeof</span>(~a)&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">&quot;----------&quot;</span>&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-keyword\">sizeof</span>(b)&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-keyword\">sizeof</span>(~b)&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">&quot;----------&quot;</span>&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-keyword\">sizeof</span>(c)&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-keyword\">sizeof</span>(~c)&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">&quot;----------&quot;</span>&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span>&lt;&lt;~s&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span>&lt;&lt;~b&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>输出结果：<br><img src=\"https://i.loli.net/2020/10/23/GUI54xhOrQs7oyK.jpg\" alt=\"Alt\"></p>\n<h2 id=\"8-sizeof计算指针大小\"><a href=\"#8-sizeof计算指针大小\" class=\"headerlink\" title=\"8.sizeof计算指针大小\"></a>8.sizeof计算指针大小</h2><p>sizeof在计算指针时有个很有趣的现象，因为sizeof满足右结合律且优先级与<code>*</code>相同，所以在<code>sizeof *p</code>中，先对p解引用，然后在对解引用后的内容计算所占内存大小，由于sizeof并没有使用解引用的内容，所以<code>*p</code>是否为空是否有效对sizeof的计算没有影响。<br><code>sizeof *p</code> == <code>sizeof(*p)</code></p>\n<h2 id=\"9-隐式转换的过程\"><a href=\"#9-隐式转换的过程\" class=\"headerlink\" title=\"9.隐式转换的过程\"></a>9.隐式转换的过程</h2><p>以<code>int a=3.14+3；</code>为例<br>在这个例子中3.14是山比double类型，3是int类型，运算时为了保证精度C++会将int类型转换成double类型，而不是因为结果是int类型而将double类型转换成int类型，所以在表达示右侧的运算过程得到的结果是一个double类型的值，当这个值被赋值给a的时候才进行double到int的类型转换。</p>\n<hr>\n<h1 id=\"五、语句\"><a href=\"#五、语句\" class=\"headerlink\" title=\"五、语句\"></a>五、语句</h1><hr>\n<h2 id=\"1-switch语句跨case标签引用变量\"><a href=\"#1-switch语句跨case标签引用变量\" class=\"headerlink\" title=\"1.switch语句跨case标签引用变量\"></a>1.switch语句跨case标签引用变量</h2><p>若需要在一个 case 语句下定义变量同时在多个 case 语下使用这个变量，则定义变量时不能同时初始化变量，应另起等于初始变量，否则编译器会报跨标签访问错误，如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">switch</span> (a)<br>&#123;<br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">0</span>:<br>        <span class=\"hljs-keyword\">int</span> b;  <span class=\"hljs-comment\">//如果直接int b=1;则会报跨标签访问错误</span><br>        b=<span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-keyword\">break</span>;<br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">1</span>:<br>        <span class=\"hljs-built_in\">cout</span>&lt;&lt;b&lt;&lt;<span class=\"hljs-built_in\">endl</span>;<br>        <span class=\"hljs-keyword\">break</span>;<br>    <span class=\"hljs-keyword\">default</span>:<br>        ;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"2-C-无法捕获计算溢出异常和除0异常\"><a href=\"#2-C-无法捕获计算溢出异常和除0异常\" class=\"headerlink\" title=\"2.C++无法捕获计算溢出异常和除0异常\"></a>2.C++无法捕获计算溢出异常和除0异常</h2><p>C++认为计算溢出和除0异常属于底层事件，应被同样底层的事件去处理，所以C++没有提供计算溢出和除0异常，如果需要捕获这两类异常在Windows系统中应使用Windows提供的SEH模型<code>__try</code>、<code>__except</code>、<code>__finally</code>异常语句，使用方法和try-catch基本类似，与try-catch不同的是，SEH中使用的是<code>__try-__except</code>搭配和<code>__try-__finally</code>搭配。</p>\n<hr>\n<h1 id=\"六、函数\"><a href=\"#六、函数\" class=\"headerlink\" title=\"六、函数\"></a>六、函数</h1><hr>\n<h2 id=\"1-静态局布变量\"><a href=\"#1-静态局布变量\" class=\"headerlink\" title=\"1.静态局布变量\"></a>1.静态局布变量</h2><p>在函数体内使用static关键字可以效静态局布量，静态局布变量的生命周期从变量定义到程序结束，但是静态局布变量只对函数可见，在函数外不可访问。</p>\n<h2 id=\"2-C-程序的编译过程\"><a href=\"#2-C-程序的编译过程\" class=\"headerlink\" title=\"2.C++程序的编译过程\"></a>2.C++程序的编译过程</h2><p><img src=\"https://i.loli.net/2020/11/09/bJ5xRFg6TGHnLCO.jpg\" alt=\"Alt\"></p>\n<h2 id=\"3-函数调用过程中的形参创建\"><a href=\"#3-函数调用过程中的形参创建\" class=\"headerlink\" title=\"3.函数调用过程中的形参创建\"></a>3.函数调用过程中的形参创建</h2><p>函数的每一次调用都会重新创建形参并传入实参对其进行初始化，形餐盘类型决定了形参与实参的交互类型，如果形参是引用类型，则形参与相对应的实参相绑定，作为实参的别名使用；如果形参是值类型，则实参的值拷贝给形参，形参与实参相互独立。</p>\n<h2 id=\"4-函数的指针参数传递\"><a href=\"#4-函数的指针参数传递\" class=\"headerlink\" title=\"4.函数的指针参数传递\"></a>4.函数的指针参数传递</h2><p><font color=\"red\">当指针作为实参传递给函数形参时，传递的是指针的值拷贝而不是指针所指的对象，且形参指针与实参指针是两个不同的指针，此时形参指针与实参指针指向同一对象，修改形参的指针指向不会影实参指针。</font></p>\n<h2 id=\"5-引用形参的限制\"><a href=\"#5-引用形参的限制\" class=\"headerlink\" title=\"5.引用形参的限制\"></a>5.引用形参的限制</h2><ul>\n<li><p>如果将函数的参数定义普通引用参数，那么这个形参就无法接受const对象、字面值和需要类型转换的对象作为实参。</p>\n</li>\n<li><p>如果将函数的参数定义为const引用参数，这个参数可以接受第一条中的参数，但是却无法修改参数的值。</p>\n</li>\n</ul>\n<h2 id=\"6-数组的两个特殊性质\"><a href=\"#6-数组的两个特殊性质\" class=\"headerlink\" title=\"6.数组的两个特殊性质\"></a>6.数组的两个特殊性质</h2><ul>\n<li>数组不可被拷贝</li>\n<li>数组再使用时被转换为指针</li>\n</ul>\n<h2 id=\"7-数组引用形参\"><a href=\"#7-数组引用形参\" class=\"headerlink\" title=\"7.数组引用形参\"></a>7.数组引用形参</h2><p>当我们使用数组作普通形参时，</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs kotlin\">void <span class=\"hljs-function\"><span class=\"hljs-title\">fun</span><span class=\"hljs-params\">(int* arr)</span></span>;<br>void <span class=\"hljs-function\"><span class=\"hljs-title\">fun</span><span class=\"hljs-params\">(int arr[])</span></span>;<br>void <span class=\"hljs-function\"><span class=\"hljs-title\">fun</span><span class=\"hljs-params\">(int arr[<span class=\"hljs-number\">10</span>])</span></span>;<br></code></pre></td></tr></table></figure>\n<p>表示的都是同一个函数，且形参可接受任意长度的实参数组，但是当将普通形参改为引用形参时，</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs kotlin\">void <span class=\"hljs-function\"><span class=\"hljs-title\">fun</span><span class=\"hljs-params\">(int (&amp;arr)</span></span>[<span class=\"hljs-number\">10</span>]);<br></code></pre></td></tr></table></figure>\n<p><code>(&amp;arr)</code>中()不可缺少，否则形参变成引用的数组而非数组的引用，且形参只能接收长度为10的数组。</p>\n<h2 id=\"8-main函数传参\"><a href=\"#8-main函数传参\" class=\"headerlink\" title=\"8.main函数传参\"></a>8.main函数传参</h2><p>有的时候我们会遇到这样的main函数：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> argc,<span class=\"hljs-keyword\">char</span>** argv)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>通常情况下，直接使用argv，argv中的内容是空的，那么main函数在什么情况下会接收参数呢？<br>事实上main函数本身就是当前程序的入口，在当前程序中没有其他程序为main函数传入参数了，当我们把写好的程序打包后在外部调用时就可以给main函数传入参数了，如在CMD中调程序</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">prog -o -d ofile data0<span class=\"hljs-regexp\">//</span>prog为程序名<br></code></pre></td></tr></table></figure>\n<p><font color=\"red\">需要注意的是argv数组的0号索引存储程序的名字，参数从1号索引开始存储，且最后一个索引位置固定内容为0</font></p>"},{"title":"【Dev】DevExpress应用","password":null,"abstract":null,"message":null,"date":"2021-02-03T02:33:53.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n## 一、大纲\n\n最近使用DevExpress做C/S开发碰到了一些问题，在解决问题的同时在这里做一下记录，下面列出涉及到技术点\n\n- **Dev框架下GridControl与GridView**\n- **使用模板列动态替换GridView的指定列**\n- **GridView分组并去掉列名的前缀**\n- **FPT服务器文件预览与下载**\n- **单元格添加按钮并添加自定义点击事件**\n- **GridView数据导出到Excel**\n- **向Word模板中写数据**\n\n<!--more-->\n\n## 二、Dev框架下的GridControl和GridView\n\n### 1.GridControl和GridView的关系\n\nDev框架下GridControl负责操作数据，GridView负责展示数据，GridControl是GridView的容器，一个GridControl可以容纳多个GridView，在GridView中的任何数据操作都不会影响到GridControl中的源数据，即当我们将GridControl中数据重新刷入GridView时，GridView中数据操作会被清除，所以如果我们有要在本地展示的数据则需要在GridControl刷数据进入GridView的时候重新再刷入一次本地数据。\n\n### 2.GridControl输入数据到GridView的原理\n\nGridControl的数据刷入GridView的操作由Dev框架执行，我们需要做的只是把数据绑定到GridControl.DataSource中即可。\n\n只有当GridView中存在与GridControl数据源对应列时，GridControl才能将对应列的数据刷入GridView的对应列中，这里的对应列指的是GridView中列的`FiledName`的值与GridControl数据源的列名相同，且大小写敏感。\n\n在GridView的列属性中有三个极为重要的属性：\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090745.png)\n\n- Name：列在程序中操作的标识符，类似变量名，对列的操作都由它来引用，如：修改colfilename列的列宽\n\n  ```c#\n  colfilename.Width = 300;\n  ```\n\n- ColumnEdit：用于挂载模板列的属性，可以将列动态的替换为其他类型的控件，例子中是将列挂载了一个多行编辑框，这样就可以在单元格中显示多行内容\n\n  ![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090756.png)\n\n- FieldName：FieldName属性是列与GridControl数据源对应的标志，如果想要将GridControl数据源中某一列的数据刷入当前列，那么当前列的FieldName的取值必须和数据源中对应列的列名一致，并且FielName也是用来获取表格数据的标识，如：\n\n  ```C#\n  gridView_FileViewer.GetFocusedDataRow()[\"path\"]//取所选行的path列单元格的数据\n  ```\n\n  \n\n### 3.向GridView存在而GridControl中不存在的列刷入数据\n\n有的时候为了展示需要，我们需要在GridView中增加新列刷入自己的数据，而新增列在GridControl的数据源中没有与之对应的列，即在数据源中没有对应的字段（这里的数据源通常情况下指的就是数据库中的表），此时我们就需要在GridControl.Datasource中动态地添加一列来与新增列对应。\n\n为什么要要在GridControl.Datasource中动态地添加一列呢？\n\n这可能是由GridControl和GridView的内部机制影响的，当一列在GridView中存在而GridControl中不存在时，我们是无法向此列写入数据的，即使数据是来自本地而不是数据库，并且编译器会报错：\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090901.png)\n\n如果我们要向GridView存在而GridControl中不存在的列刷入数据，那么我们必须在GridControl的DataSource中动态的加列，下面是示例代码：\n\n```c#\nprivate void LoadFileNameColumn(object sender, EventArgs args)\n{\n\tGridColumn col = gridView_JobPlacement.Columns[\"xgwj\"];//取表格xgwj列的索引\n\n\t/*代码块说明：\n\t*   作用：向gridview的datasource动态添加filename列，使GridView中的filename列与DataSource中的filename字段对应\n\t*   说明：因为在GridView中添加了filename列如果在GridView的DataSource中没有与之对应的字段，\n\t*       则无法对filename列做任何操作\n\t*/\n\tDataTable gridViewTable = gridControl_JobPlacement.DataSource as DataTable;//取DataSource的引用并转换成DataTable\n\tif (!gridViewTable.Columns.Contains(\"filename\"))//判断DataSource中是否已存在filename列\n\t{\n\t\tDataColumn dsFileNameCol = new DataColumn();//创建新列\n\t\tdsFileNameCol.ColumnName = \"filename\";//将新列命名为filename\n         gridViewTable.Columns.Add(dsFileNameCol);//将新列添加到DataSource中\n\t}//至此，DataSource中就存在与GridView中的filename列对应的filename列了\n\n\t//遍历GridView所有行，对有文件组编码的行在filename列载入文件列表信息\n\t for (int rowIndex = 0; rowIndex < gridView_JobPlacement.RowCount; rowIndex++)\n\t{     \n\t\t DataRow row = gridView_JobPlacement.GetDataRow(rowIndex);//根据索引数据行\n\t\tif (row[\"xgwj\"].ToString() != \"\")//如果数据行中的xgwj列单元格不为空，则向单元格刷入指定数据\n\t\t{\n\t\t\tstring fileGroupTmp = gridView_JobPlacement.GetRowCellDisplayText(rowIndex, col);//取指定单元格显示的内容\n\t\t\tstring fileGroup = CodingTool.GetFileGroup(fileGroupTmp);//将单元格存储的文件组编码转换成数据库可用的编码\n\t\t\tDataTable table = bll.SelectFromFileTableByFileGroup(fileGroup);//根据编码到数据库查询文件列表\n\t\t\tforeach(DataRow tableRow in table.Rows)//遍历文件列表将文件名刷入新增列\n\t\t\t{\n\t\t\t\trow[\"filename\"] += tableRow[\"filename\"]+\"\\n\";//将数据刷入filename列单元格\n\t\t\t}\n         }\n     }\n}\n```\n\n## 三、使用模板列动态替换GridView中的指定列\n\n有的时候为了保密需要，在数据库中部分字段会用编码标识，如：人名使用编码标识，张三对应编码001，但是在表格中展示的时候应该显示人名而不是编码，此时我们就需要用到模板列的动态替换。\n\n直接上代码：\n\n```c#\nSecurity.BLL.userinfo ubll = new Security.BLL.userinfo();\n\nRepositoryItemGridLookUpEdit replaceRegistrant = new RepositoryItemGridLookUpEdit();\nreplaceRegistrant.DataSource = ubll.GetAllList().Tables[0];//绑定数据源到RepositoryItemGridLookUpEdit\nreplaceRegistrant.DisplayMember = \"fullname\";  //选择要替换显示的字段\nreplaceRegistrant.ValueMember = \"ID\";  //\nreplaceRegistrant.NullText = \"\";//字段为空时要显示的内容\ngridView_JobPlacement.Columns[\"djr\"].ColumnEdit = replaceRegistrant;//将RepositoryItemGridLookUpEdit绑定到GridView的“djr”列\n\nRepositoryItemGridLookUpEdit replacePricipal = new RepositoryItemGridLookUpEdit();\nreplacePricipal.DataSource = ubll.GetAllList().Tables[0];//绑定数据源到RepositoryItemGridLookUpEdit\nreplacePricipal.DisplayMember = \"fullname\";  //选择要替换显示的字段\nreplacePricipal.ValueMember = \"ID\";  //\nreplacePricipal.NullText = \"\";//字段为空时要显示的内容\ngridView_JobPlacement.Columns[\"fzr\"].ColumnEdit = replacePricipal;//将RepositoryItemGridLookUpEdit绑定到GridView的“djr”列\n```\n\n这是通过代码添加动态的添加模板列，同时我们也可以在列属性中的ColumnEdit属性中静态的添加模板列。\n\n## 四、GridView分组并去掉列名的前缀\n\n### 1.分组\n\nGridView分组只需要在需要分组的列的属性中将GroupIndex属性值由“-1”改为0即可，如果需要二级分组则在需要分组的列的属性中将GroupIndex属性值由“-1”改为1，以此类推需要三级分组则改为2。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090912.png)\n\n### 2.去掉列名前缀\n\n分完组后如果不做修改我们加载数据之后表格是这样的：\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090919.png)\n\n有时我们不需要显示列名前缀，这时我们需要修改GridView的GroupFormat属性修改为{1}，GroupFormat属性的默认值是`{0}: [#image]{1} {2}`，其中\n\n- {0}显示列标题\n- [#image]显示图片\n- {1}显示列的内容值\n- {2}显示列的摘要\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090923.png)\n\n设置好之后，效果是这样的:\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090936.png)\n\n## 四、FTP文件预览与下载\n\n直接上代码，解释都放注释上了：\n\n```c#\nprivate void PreviewFile(object sender,EventArgs e)\n{\n    if (fileDic == null)\n    {\n        return;\n    }\n    //自定义函数，获取文件在服务器中的路径\n    string serverPath = ServerFTP.CreateFilePathInServerBySQLPath(gridView_FileViewer.GetFocusedDataRow()[\"path\"].ToString());\n    //获取文件名\n    string fileName = gridView_FileViewer.GetFocusedDataRow()[\"file\"].ToString();\n    //根据路径将文件下载到本地，并返回文件路径\n    string savePath = ServerFTP.currentMode.RequestFile(serverPath,fileName,GeneralLib.FTPDownloadStyle.CACHE);\n    if (savePath != \"\")\n    {\n        //调用系统软件打开文件\n        FileIO.OpenFileInWindows(savePath);\n    }  \n}\n```\n\n这里挑几个比较重要的函数讲解\n\n**RequestFile**\n\n```c#\npublic string RequestFile(string serverPath,string fileName, FTPDownloadStyle style)\n{\n    string savePath = \"\";\n    switch (style)\n    {\n        //下载文件到缓存临时文件夹，用于预览\n        case FTPDownloadStyle.CACHE:\n            savePath = Path.Combine(ServerFTP.cachePath, fileName);\n            break;\n        //下载文件到所选的文件夹，用于下载\n        case FTPDownloadStyle.CHOOSEDIC:\n            savePath = FileIO.ChooseSaveFile(fileName, \"\", ServerFTP.chooseTempDic);       \n            //保存所选的文件夹，以便下次打开直接进入相应目录\n            ServerFTP.chooseTempDic = Path.GetDirectoryName(savePath);\n            break;\n    }\n    if (savePath == null)\n    {\n        return \"\";\n    }\n\n    //判断目录是否存在\n    if (!Directory.Exists(Path.GetDirectoryName(savePath)))\n    {\n        //如果不存在则创建目录\n        Directory.CreateDirectory(Path.GetDirectoryName(savePath));\n    }\n\n\t//根据文件路径创建FPT连接实例\n    FtpWebRequest ftp = (FtpWebRequest)WebRequest.Create(serverPath);\n    //从配置文件中读取登录项\n    ICredentials credentials = new NetworkCredential(Config.Get[\"ftp_username\"], Config.Get[\"ftp_password\"]);\n    //配置FPT服务器登录项\n    ftp.Credentials = credentials；\n    //配置FPT操作为下载文件\n    ftp.Method = WebRequestMethods.Ftp.DownloadFile;\n\t//向FPT服务器发出操作请求\n    FtpWebResponse response = (FtpWebResponse)ftp.GetResponse();\n    //创建流缓冲区接收FPT服务器反馈的字节流\n    Stream responseStream = response.GetResponseStream();\n    //根据存储路径在本地创建文件\n    FileStream fs = File.Create(savePath);\n    //创建用于批量取缓冲区字节数据的数据\n    byte[] buffer = new byte[ConstLib.BUFFER_SIZE];\n    int read = 0;\n    do\n    {\n        //将缓冲区的字节数据读入字节数组\n        read = responseStream.Read(buffer, 0, buffer.Length);\n        //将字节数组的数据写入到文件中\n        fs.Write(buffer, 0, read);\n        //清楚fs的流缓冲区，这里fs的流缓冲区与responseStream流缓冲区不是同一个缓冲区，需要注意\n        fs.Flush();\n    }\n    while (read != 0)；\n        \n    fs.Flush();\n    //关闭文件\n    fs.Close();\n    \n    return savePath;\n}\n```\n\n**OpenFileInWindows**\n\n```C#\npublic static Process OpenFileInWindows(string filePath)\n{\n    //创建一个新的进程\n    ProcessStartInfo info = new ProcessStartInfo();\n    //设置进程要打开的文档，Windows会根据文件类型的默认开打应用来启动对应应用程序来打开文件\n    info.FileName = Path.GetFileName(filePath);\n    //设置启动进程的初始目录\n    info.WorkingDirectory = Path.GetDirectoryName(filePath);\n    //设置进程启动后，窗口的状态，可以设置为最大化，最小化和正常\n    info.WindowStyle = ProcessWindowStyle.Normal;\n    //启动进程\n    Process proc = Process.Start(info);\n\n    return proc;\n}\n```\n\n当关闭文件时清楚临时文件夹的内容\n\n```c#\npublic static void CleanCacheDirectory()\n{\n    //判断临时文件夹是否存在\n    if (!Directory.Exists(ServerFTP.cachePath))\n    {\n        return;\n    }\n    try\n    {\n        //等待系统将占用文件的进程杀死再清空临时文件夹\n        System.Threading.Thread.Sleep(500);\n        //获取临时文件夹目录信息\n        DirectoryInfo dicInfo = new DirectoryInfo(ServerFTP.cachePath);\n        //直接删除临时文件夹\n        dicInfo.Delete(true);\n    }\n    catch\n    {\n        //如果目录被其他进程占用，则暂时不清空临时文件夹\n        return;\n    }\n}\n```\n\n这里我使用的是最简单的直接删除临时文件夹的暴力删除法，这样做会有一个问题就是，在程序删除文件夹的时候，可能预览文件的进程还没有被系统杀死或有其他的进程占用了目录中文件，这都会导致目录删除失败而抛出异常，我的解决方案是在删除目录之前等待500ms，等待系统将预览文件的进程杀死后在删除文件夹，但是如果是其他的进程占用了目录，则需要手动结束进程才能继续删除临时文件夹，我的解决方案是，如果有其他进程占用了目录，则本次本次临时缓冲区先不删除，等下次有机会再删除。所以这里的try-catch不是用来抛出异常的，而是用来推出函数的。\n\n当然比较理想的删除方法是遍历整个目录中文件和子文件夹，依次删除目录下文件和子文件夹，有被其他进程占用的文件暂时不删除。这样就可以只留下被占用的文件，而不是整个目录。\n\n## 五、单元格添加按钮并添加自定义点击事件\n\n有时我们需要向某一列的单元格添加点击事件，甚至向某一个单元格添加点击事件，这时我们就需要向单元格添加按钮了。\n\n### 1.向单元格添加简单的点击事件\n\n如果我们只想在某一单元格添加简单的点击事件\n\n```C#\nprivate void gridView_JobPlacement_RowCellClick(object sender, RowCellClickEventArgs e)\n{\n    if (e.RowHandle == 1 && e.Column.FieldName == \"filename\")\n    {\n        if (e.Button == MouseButtons.Left)\n        {\n            //todo\n        }\n        if (e.Button == MouseButtons.Right)\n        {\n\t\t\t//todo\n        }\n        if(e.Button == MouseButtons.Moddle)\n        {\n            //todo\n        }\n    }\n}\n```\n\n这时我们需要用到RowCellClick事件，RowCellClick事件在鼠标点击单元格时触发，然后我们只需要判定鼠标点击是哪一行哪一列，就可以实现某一个单元格的点击事件了。当然我们也可以通过添加按钮来实现。\n\n### 2.向单元格添加复杂点击事件\n\n如果我们想向单元格添加一系列复杂的点击事件，如在某一单元格内做文件的上传，预览，下载，删除等操作，这时我们就需要借助模板列了，使用模板列是无法只向某一个单元添加点击事件的，因为模板列挂载的是一整列。\n\n我需要用到模板列`RepositoryItemButtonEdit`，我可以在列属性里静态挂载，也可以在代码中动态挂载，重要的是我们需要用到`RepositoryItemButtonEdit`属性里的`Buttons`属性，向Buttons属性里添加元素。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090945.png)\n\n光是添加按钮单元中还是看不到按钮的，我们还需要将每个按钮的Kind属性设置为Glyph，这样我们才能在单元格中看到按钮\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090950.png)\n\n添加完按钮就可以向对应按钮添加点击事件了，我们可以发现在列属性里找不到事件，所以我们需要在代码中为按钮添加点击事件，这时我们需要用到`repositoryItemButtonEdit.Buttons[0].Click`，其中repositoryItemButtonEdit是模板列的名字，Buttons[0]是第一个按钮的引用，我们只需要向Click事件添加我们想要执行的函数即可。\n\n## 六、GridView数据导出到Excel\n\n GridView的数据要导出到Excel有很多种方法，可以最直接的就是遍历GridView，然后将数据写入Excel，这算是比较麻烦的做法了，事实上Dev已经提供了一些便捷的方法。\n\n### 1.GetAllFilteredAndSortedRows()方法\n\nDev提供了一个`GridView.DataController.GetAllFilteredAndSortedRows()`方法，可以用于提取GridView当前数据，在筛选排序等操作之后更改了的数据也可以提取。\n\n<font color=red> 但是，GridView类中的DataController对象在VS中被隐藏了，即通过提示器是找不到GDataController对象的的，只能通过手写调用。</font>\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090957.png)\n\nGetAllFilteredAndSortedRows()方法返回的是一个IList泛型列表，数据写入Excel一就要自己手动写入，写入方法：\n\n```C#\n//需要包含的引用\nusing DevExpress.XtraSpreadsheet;\nusing DevExpress.Spreadsheet;\n\nSpreadsheetControl ss = new SpreadsheetControl();\nvar book = ss.Document;\nWorksheet sheet = book.Worksheets[0];\nsheet.Import(table, true, 0, 0);//table是DataTable类型，也是要导出到Excel的数据\n```\n\n<font color=red> 其中有一点需要格外注意，在使用Import函数时需要引用`DevExpress.Docs`程序集，因为Import函数在这个程序集里，Dev在DevExpress.Docs程序集里给Worksheet的父类ExternalWorksheet写了扩展，也就是扩展了Import函数等，其中DevExpress.Docs程序集和DevExpress.Spreadsheet程序集的命名空间是一样的，如果没有搞清楚这一点很容易产生玄学问题🥴</font>\n\n### 2.GridView.Export()方法\n\n最简单的方法就是使用Dev官方提供的导出方法GridView.Export().\n\nDev已经在GridView中添加了官方的Export方法，支持多种导出格式：\n\n- Xls\n- Xlsx\n- Html\n- Mht\n- Pdf\n- Text\n- Rtf\n- Csv\n- Image\n- Docx\n\n同时提供三种重载：\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326091003.png)\n\n使用方法也很简单：\n\n```C#\n/// <summary>\n/// 将GridView中的数据导出到Excel\n/// </summary>\n/// <param name=\"fileName\"></param>\n/// <param name=\"view\"></param>\npublic static void ExportExcel(string fileName, GridView view)\n{\n    SaveFileDialog sfd = new SaveFileDialog();\n    sfd.Title = \"另存为\";\n    sfd.InitialDirectory = \"C:\\\\\";\n    sfd.Filter = \"Excel文件(*.xlsx) | *.xlsx\";\n    sfd.FileName = fileName;//fileName文件名不需要包含后缀\n    if (sfd.ShowDialog() == DialogResult.OK)\n    {\n        view.Export(DevExpress.XtraPrinting.ExportTarget.Xlsx, sfd.FileName);\n    }\n}\n```\n\n- view.Export是dev自带的导出方法，在导出文件后dev会自动调用系统对此文件的默认打开应用来打开文件，当然dev也提供内置的预览方法，这在下一节导出word模板中使用。\n\n## 七、向Word模板中写入数据\n\n### 1.载入word模板文件\n\n向word模板中写入数据我这里主要使用的是<font color=red>RichEditControl</font>类，RichEditControl类提供海量的富文本API接口，这里主要讲解使用到的API。\n\n首先打开word文档，RichEditControl类提供RichEditControl.LoadDocument(string path)方法加载文档，RichEditControl类也提供多个LoadDocument函数的重载给予各种文件的加载形式，我这里使用的是直接通过文件路径加载文档。LoadDocument函数支持DOC、DOCX、RTP、HTM、HTML、MHT、XML和EPUB类型的文档，可以自动检测文档类型。\n\n```C#\nRichEditControl.LoadDocument(string path)\n```\n\n将文档载入内存之后就可以通过<font color=red>RichEditControl.Document.Text</font>属性查看文档内容了，也可以通过RichEditControl.Document.Text属性判断文档是否加载成功。\n\n```C#\nif(richEditControl.Document.Text == null)\n{\n\treturn;\n}\n```\n\n### 2.向word模板的指定位置写入数据\n\n向word模板的指定位置写入数据主要使用Word的书签和域，我这里使用的是书签，在word中想要插入数据的地方添加一个书签即可，如：\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326091009.png)\n\n我想要在生产号、型号和图号后面的单元格写入数据，那么我只需要在这些单元中添加书签即可，添加书签的步骤：\n\n```mermaid\ngraph LR;\n将光标定位到要添加的书签的位置-->插入-->书签-->添加一个书签名-->添加\n```\n\n添加完书签时候在word上是看不到的，但是把光标定位到书签所在的位置处，插入书签时会自定定位到所插入的书签名。\n\n然后即可通过<font color=red> Document.Replace(DocumentRange range,string text)</font>函数来向书签所在位置插入数据了，其中DocumentRange类型的参数需要通过<font color=red>Document.Bookmarks[string bookmarks].Range</font>来将字符串类型的书签标志转换为DocumentRange类型的可用书签标志。\n\n如：我要在生产号、型号和图号后面的单元格写入数据，那么我需要分别在这些单元格中插入书签`sch`、`xh`、`th`，然后通过下面代码即可向word模板中写入数据\n\n```C#\nRichEditControl richEdit = new RichEditControl();\nrichEdit.LoadDocument(\"C:/a.doc\");\nDocument doc = rich.Document;\ndoc.Replace(doc.Bookmarks[\"sch\"].Range,\"01\");\ndoc.Replace(doc.Bookmarks[\"xh\"].Range,\"02\");\ndoc.Replace(doc.Bookmarks[\"th\"].Range,\"03\");\n```\n\n原理就是书签提供了一个占位符，而dev则通过搜索匹配的占位符，将指定数据替换掉占位符。\n\n### 3.向word模板中的表格插入新行并写入内容\n\n向word模板中的表格插入新行则稍微复杂一些。主要步骤如下：\n\n- 首先word文档中要有一个模板表格\n\n- 需要在要插入表的位置添加书签table\n\n- 遍历word文档中所有的表再遍历每一个表中所有的单元格，查找到书签所在的单元格\n\n  ```c#\n  public TableCell GetTableCell(Document document) \n  {\n      //遍历文档中所有的表\n      foreach (Table table in document.Tables)\n      {\n          int row = 0, col = 0;\n          bool ok = false;\n          TableCell retCell = null;\n  \t\t//遍历表格中所有的单元格\n          table.ForEachCell((cell, rowIndex, columnIndex) =>\n                            {\n                                if (cell.Range.Contains(document.Bookmarks[\"table\"].Range.Start))\n                                {\n                                    row = rowIndex;\n                                    col = columnIndex;\n                                    retCell = cell;\n                                    ok = true;\n                                }\n                            });\n          if (ok)\n          {\n              return retCell;\n          }\n      }\n  ```\n\n  <font color=red>Table.ForEachCell(TableCellProcessorDelegate cellProcessor)</font>函数传入的是一个委托。这里使用的是匿名方法\n\n- 在指定单元格后新增行\n\n  可以使用<font color=red>Document.Tables[int index].Rows.Append()</font>函数在表的最后追加行，或使用<font color=red> Document.Tables[int index].Rows.InsertAfter(int rowIndex)</font>函数在指定行之后插入行。其中Document.Tables[int index].Rows.Append()中index（表的索引）可以通过<font color=red> Document.Tables.IndexOf(Table table)</font>函数获取，而table又可以同通过上一步查找到的TableCell对象retCell.Table属性获取。\n\n  ```c#\n  RichEditControl richEdit = new RichEditControl();\n  richEdit.LoadDocument(\"C:/a.doc\");\n  Document doc = rich.Document;\n  TableCell cell = GetTableCell(doc);\n  doc.BeginUpdate();\n  int index = doc.Tables.IndexOf(cell.Table);\n  doc.Tables[index].Rows.Append();//或者\n  //doc.Table[index].Rows.InsertAfter(cell.Row.Index - 1);\n  //获取指定单元格的占位符范围\n  DocumentRange range = doc.Tables[index].Rows[cell.Row.Index].Cells[cell.Index].ContentRange;\n  doc.Replace()\n  doc.EndUpdate();\n  ```\n\n  ","source":"_posts/【Dev】DevExpress应用.md","raw":"---\ntitle: 【Dev】DevExpress应用\npassword: \nabstract: \nmessage: \ndate: 2021-02-03 10:33:53\ntags: Dev\ncategories: 知识记录\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n## 一、大纲\n\n最近使用DevExpress做C/S开发碰到了一些问题，在解决问题的同时在这里做一下记录，下面列出涉及到技术点\n\n- **Dev框架下GridControl与GridView**\n- **使用模板列动态替换GridView的指定列**\n- **GridView分组并去掉列名的前缀**\n- **FPT服务器文件预览与下载**\n- **单元格添加按钮并添加自定义点击事件**\n- **GridView数据导出到Excel**\n- **向Word模板中写数据**\n\n<!--more-->\n\n## 二、Dev框架下的GridControl和GridView\n\n### 1.GridControl和GridView的关系\n\nDev框架下GridControl负责操作数据，GridView负责展示数据，GridControl是GridView的容器，一个GridControl可以容纳多个GridView，在GridView中的任何数据操作都不会影响到GridControl中的源数据，即当我们将GridControl中数据重新刷入GridView时，GridView中数据操作会被清除，所以如果我们有要在本地展示的数据则需要在GridControl刷数据进入GridView的时候重新再刷入一次本地数据。\n\n### 2.GridControl输入数据到GridView的原理\n\nGridControl的数据刷入GridView的操作由Dev框架执行，我们需要做的只是把数据绑定到GridControl.DataSource中即可。\n\n只有当GridView中存在与GridControl数据源对应列时，GridControl才能将对应列的数据刷入GridView的对应列中，这里的对应列指的是GridView中列的`FiledName`的值与GridControl数据源的列名相同，且大小写敏感。\n\n在GridView的列属性中有三个极为重要的属性：\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090745.png)\n\n- Name：列在程序中操作的标识符，类似变量名，对列的操作都由它来引用，如：修改colfilename列的列宽\n\n  ```c#\n  colfilename.Width = 300;\n  ```\n\n- ColumnEdit：用于挂载模板列的属性，可以将列动态的替换为其他类型的控件，例子中是将列挂载了一个多行编辑框，这样就可以在单元格中显示多行内容\n\n  ![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090756.png)\n\n- FieldName：FieldName属性是列与GridControl数据源对应的标志，如果想要将GridControl数据源中某一列的数据刷入当前列，那么当前列的FieldName的取值必须和数据源中对应列的列名一致，并且FielName也是用来获取表格数据的标识，如：\n\n  ```C#\n  gridView_FileViewer.GetFocusedDataRow()[\"path\"]//取所选行的path列单元格的数据\n  ```\n\n  \n\n### 3.向GridView存在而GridControl中不存在的列刷入数据\n\n有的时候为了展示需要，我们需要在GridView中增加新列刷入自己的数据，而新增列在GridControl的数据源中没有与之对应的列，即在数据源中没有对应的字段（这里的数据源通常情况下指的就是数据库中的表），此时我们就需要在GridControl.Datasource中动态地添加一列来与新增列对应。\n\n为什么要要在GridControl.Datasource中动态地添加一列呢？\n\n这可能是由GridControl和GridView的内部机制影响的，当一列在GridView中存在而GridControl中不存在时，我们是无法向此列写入数据的，即使数据是来自本地而不是数据库，并且编译器会报错：\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090901.png)\n\n如果我们要向GridView存在而GridControl中不存在的列刷入数据，那么我们必须在GridControl的DataSource中动态的加列，下面是示例代码：\n\n```c#\nprivate void LoadFileNameColumn(object sender, EventArgs args)\n{\n\tGridColumn col = gridView_JobPlacement.Columns[\"xgwj\"];//取表格xgwj列的索引\n\n\t/*代码块说明：\n\t*   作用：向gridview的datasource动态添加filename列，使GridView中的filename列与DataSource中的filename字段对应\n\t*   说明：因为在GridView中添加了filename列如果在GridView的DataSource中没有与之对应的字段，\n\t*       则无法对filename列做任何操作\n\t*/\n\tDataTable gridViewTable = gridControl_JobPlacement.DataSource as DataTable;//取DataSource的引用并转换成DataTable\n\tif (!gridViewTable.Columns.Contains(\"filename\"))//判断DataSource中是否已存在filename列\n\t{\n\t\tDataColumn dsFileNameCol = new DataColumn();//创建新列\n\t\tdsFileNameCol.ColumnName = \"filename\";//将新列命名为filename\n         gridViewTable.Columns.Add(dsFileNameCol);//将新列添加到DataSource中\n\t}//至此，DataSource中就存在与GridView中的filename列对应的filename列了\n\n\t//遍历GridView所有行，对有文件组编码的行在filename列载入文件列表信息\n\t for (int rowIndex = 0; rowIndex < gridView_JobPlacement.RowCount; rowIndex++)\n\t{     \n\t\t DataRow row = gridView_JobPlacement.GetDataRow(rowIndex);//根据索引数据行\n\t\tif (row[\"xgwj\"].ToString() != \"\")//如果数据行中的xgwj列单元格不为空，则向单元格刷入指定数据\n\t\t{\n\t\t\tstring fileGroupTmp = gridView_JobPlacement.GetRowCellDisplayText(rowIndex, col);//取指定单元格显示的内容\n\t\t\tstring fileGroup = CodingTool.GetFileGroup(fileGroupTmp);//将单元格存储的文件组编码转换成数据库可用的编码\n\t\t\tDataTable table = bll.SelectFromFileTableByFileGroup(fileGroup);//根据编码到数据库查询文件列表\n\t\t\tforeach(DataRow tableRow in table.Rows)//遍历文件列表将文件名刷入新增列\n\t\t\t{\n\t\t\t\trow[\"filename\"] += tableRow[\"filename\"]+\"\\n\";//将数据刷入filename列单元格\n\t\t\t}\n         }\n     }\n}\n```\n\n## 三、使用模板列动态替换GridView中的指定列\n\n有的时候为了保密需要，在数据库中部分字段会用编码标识，如：人名使用编码标识，张三对应编码001，但是在表格中展示的时候应该显示人名而不是编码，此时我们就需要用到模板列的动态替换。\n\n直接上代码：\n\n```c#\nSecurity.BLL.userinfo ubll = new Security.BLL.userinfo();\n\nRepositoryItemGridLookUpEdit replaceRegistrant = new RepositoryItemGridLookUpEdit();\nreplaceRegistrant.DataSource = ubll.GetAllList().Tables[0];//绑定数据源到RepositoryItemGridLookUpEdit\nreplaceRegistrant.DisplayMember = \"fullname\";  //选择要替换显示的字段\nreplaceRegistrant.ValueMember = \"ID\";  //\nreplaceRegistrant.NullText = \"\";//字段为空时要显示的内容\ngridView_JobPlacement.Columns[\"djr\"].ColumnEdit = replaceRegistrant;//将RepositoryItemGridLookUpEdit绑定到GridView的“djr”列\n\nRepositoryItemGridLookUpEdit replacePricipal = new RepositoryItemGridLookUpEdit();\nreplacePricipal.DataSource = ubll.GetAllList().Tables[0];//绑定数据源到RepositoryItemGridLookUpEdit\nreplacePricipal.DisplayMember = \"fullname\";  //选择要替换显示的字段\nreplacePricipal.ValueMember = \"ID\";  //\nreplacePricipal.NullText = \"\";//字段为空时要显示的内容\ngridView_JobPlacement.Columns[\"fzr\"].ColumnEdit = replacePricipal;//将RepositoryItemGridLookUpEdit绑定到GridView的“djr”列\n```\n\n这是通过代码添加动态的添加模板列，同时我们也可以在列属性中的ColumnEdit属性中静态的添加模板列。\n\n## 四、GridView分组并去掉列名的前缀\n\n### 1.分组\n\nGridView分组只需要在需要分组的列的属性中将GroupIndex属性值由“-1”改为0即可，如果需要二级分组则在需要分组的列的属性中将GroupIndex属性值由“-1”改为1，以此类推需要三级分组则改为2。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090912.png)\n\n### 2.去掉列名前缀\n\n分完组后如果不做修改我们加载数据之后表格是这样的：\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090919.png)\n\n有时我们不需要显示列名前缀，这时我们需要修改GridView的GroupFormat属性修改为{1}，GroupFormat属性的默认值是`{0}: [#image]{1} {2}`，其中\n\n- {0}显示列标题\n- [#image]显示图片\n- {1}显示列的内容值\n- {2}显示列的摘要\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090923.png)\n\n设置好之后，效果是这样的:\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090936.png)\n\n## 四、FTP文件预览与下载\n\n直接上代码，解释都放注释上了：\n\n```c#\nprivate void PreviewFile(object sender,EventArgs e)\n{\n    if (fileDic == null)\n    {\n        return;\n    }\n    //自定义函数，获取文件在服务器中的路径\n    string serverPath = ServerFTP.CreateFilePathInServerBySQLPath(gridView_FileViewer.GetFocusedDataRow()[\"path\"].ToString());\n    //获取文件名\n    string fileName = gridView_FileViewer.GetFocusedDataRow()[\"file\"].ToString();\n    //根据路径将文件下载到本地，并返回文件路径\n    string savePath = ServerFTP.currentMode.RequestFile(serverPath,fileName,GeneralLib.FTPDownloadStyle.CACHE);\n    if (savePath != \"\")\n    {\n        //调用系统软件打开文件\n        FileIO.OpenFileInWindows(savePath);\n    }  \n}\n```\n\n这里挑几个比较重要的函数讲解\n\n**RequestFile**\n\n```c#\npublic string RequestFile(string serverPath,string fileName, FTPDownloadStyle style)\n{\n    string savePath = \"\";\n    switch (style)\n    {\n        //下载文件到缓存临时文件夹，用于预览\n        case FTPDownloadStyle.CACHE:\n            savePath = Path.Combine(ServerFTP.cachePath, fileName);\n            break;\n        //下载文件到所选的文件夹，用于下载\n        case FTPDownloadStyle.CHOOSEDIC:\n            savePath = FileIO.ChooseSaveFile(fileName, \"\", ServerFTP.chooseTempDic);       \n            //保存所选的文件夹，以便下次打开直接进入相应目录\n            ServerFTP.chooseTempDic = Path.GetDirectoryName(savePath);\n            break;\n    }\n    if (savePath == null)\n    {\n        return \"\";\n    }\n\n    //判断目录是否存在\n    if (!Directory.Exists(Path.GetDirectoryName(savePath)))\n    {\n        //如果不存在则创建目录\n        Directory.CreateDirectory(Path.GetDirectoryName(savePath));\n    }\n\n\t//根据文件路径创建FPT连接实例\n    FtpWebRequest ftp = (FtpWebRequest)WebRequest.Create(serverPath);\n    //从配置文件中读取登录项\n    ICredentials credentials = new NetworkCredential(Config.Get[\"ftp_username\"], Config.Get[\"ftp_password\"]);\n    //配置FPT服务器登录项\n    ftp.Credentials = credentials；\n    //配置FPT操作为下载文件\n    ftp.Method = WebRequestMethods.Ftp.DownloadFile;\n\t//向FPT服务器发出操作请求\n    FtpWebResponse response = (FtpWebResponse)ftp.GetResponse();\n    //创建流缓冲区接收FPT服务器反馈的字节流\n    Stream responseStream = response.GetResponseStream();\n    //根据存储路径在本地创建文件\n    FileStream fs = File.Create(savePath);\n    //创建用于批量取缓冲区字节数据的数据\n    byte[] buffer = new byte[ConstLib.BUFFER_SIZE];\n    int read = 0;\n    do\n    {\n        //将缓冲区的字节数据读入字节数组\n        read = responseStream.Read(buffer, 0, buffer.Length);\n        //将字节数组的数据写入到文件中\n        fs.Write(buffer, 0, read);\n        //清楚fs的流缓冲区，这里fs的流缓冲区与responseStream流缓冲区不是同一个缓冲区，需要注意\n        fs.Flush();\n    }\n    while (read != 0)；\n        \n    fs.Flush();\n    //关闭文件\n    fs.Close();\n    \n    return savePath;\n}\n```\n\n**OpenFileInWindows**\n\n```C#\npublic static Process OpenFileInWindows(string filePath)\n{\n    //创建一个新的进程\n    ProcessStartInfo info = new ProcessStartInfo();\n    //设置进程要打开的文档，Windows会根据文件类型的默认开打应用来启动对应应用程序来打开文件\n    info.FileName = Path.GetFileName(filePath);\n    //设置启动进程的初始目录\n    info.WorkingDirectory = Path.GetDirectoryName(filePath);\n    //设置进程启动后，窗口的状态，可以设置为最大化，最小化和正常\n    info.WindowStyle = ProcessWindowStyle.Normal;\n    //启动进程\n    Process proc = Process.Start(info);\n\n    return proc;\n}\n```\n\n当关闭文件时清楚临时文件夹的内容\n\n```c#\npublic static void CleanCacheDirectory()\n{\n    //判断临时文件夹是否存在\n    if (!Directory.Exists(ServerFTP.cachePath))\n    {\n        return;\n    }\n    try\n    {\n        //等待系统将占用文件的进程杀死再清空临时文件夹\n        System.Threading.Thread.Sleep(500);\n        //获取临时文件夹目录信息\n        DirectoryInfo dicInfo = new DirectoryInfo(ServerFTP.cachePath);\n        //直接删除临时文件夹\n        dicInfo.Delete(true);\n    }\n    catch\n    {\n        //如果目录被其他进程占用，则暂时不清空临时文件夹\n        return;\n    }\n}\n```\n\n这里我使用的是最简单的直接删除临时文件夹的暴力删除法，这样做会有一个问题就是，在程序删除文件夹的时候，可能预览文件的进程还没有被系统杀死或有其他的进程占用了目录中文件，这都会导致目录删除失败而抛出异常，我的解决方案是在删除目录之前等待500ms，等待系统将预览文件的进程杀死后在删除文件夹，但是如果是其他的进程占用了目录，则需要手动结束进程才能继续删除临时文件夹，我的解决方案是，如果有其他进程占用了目录，则本次本次临时缓冲区先不删除，等下次有机会再删除。所以这里的try-catch不是用来抛出异常的，而是用来推出函数的。\n\n当然比较理想的删除方法是遍历整个目录中文件和子文件夹，依次删除目录下文件和子文件夹，有被其他进程占用的文件暂时不删除。这样就可以只留下被占用的文件，而不是整个目录。\n\n## 五、单元格添加按钮并添加自定义点击事件\n\n有时我们需要向某一列的单元格添加点击事件，甚至向某一个单元格添加点击事件，这时我们就需要向单元格添加按钮了。\n\n### 1.向单元格添加简单的点击事件\n\n如果我们只想在某一单元格添加简单的点击事件\n\n```C#\nprivate void gridView_JobPlacement_RowCellClick(object sender, RowCellClickEventArgs e)\n{\n    if (e.RowHandle == 1 && e.Column.FieldName == \"filename\")\n    {\n        if (e.Button == MouseButtons.Left)\n        {\n            //todo\n        }\n        if (e.Button == MouseButtons.Right)\n        {\n\t\t\t//todo\n        }\n        if(e.Button == MouseButtons.Moddle)\n        {\n            //todo\n        }\n    }\n}\n```\n\n这时我们需要用到RowCellClick事件，RowCellClick事件在鼠标点击单元格时触发，然后我们只需要判定鼠标点击是哪一行哪一列，就可以实现某一个单元格的点击事件了。当然我们也可以通过添加按钮来实现。\n\n### 2.向单元格添加复杂点击事件\n\n如果我们想向单元格添加一系列复杂的点击事件，如在某一单元格内做文件的上传，预览，下载，删除等操作，这时我们就需要借助模板列了，使用模板列是无法只向某一个单元添加点击事件的，因为模板列挂载的是一整列。\n\n我需要用到模板列`RepositoryItemButtonEdit`，我可以在列属性里静态挂载，也可以在代码中动态挂载，重要的是我们需要用到`RepositoryItemButtonEdit`属性里的`Buttons`属性，向Buttons属性里添加元素。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090945.png)\n\n光是添加按钮单元中还是看不到按钮的，我们还需要将每个按钮的Kind属性设置为Glyph，这样我们才能在单元格中看到按钮\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090950.png)\n\n添加完按钮就可以向对应按钮添加点击事件了，我们可以发现在列属性里找不到事件，所以我们需要在代码中为按钮添加点击事件，这时我们需要用到`repositoryItemButtonEdit.Buttons[0].Click`，其中repositoryItemButtonEdit是模板列的名字，Buttons[0]是第一个按钮的引用，我们只需要向Click事件添加我们想要执行的函数即可。\n\n## 六、GridView数据导出到Excel\n\n GridView的数据要导出到Excel有很多种方法，可以最直接的就是遍历GridView，然后将数据写入Excel，这算是比较麻烦的做法了，事实上Dev已经提供了一些便捷的方法。\n\n### 1.GetAllFilteredAndSortedRows()方法\n\nDev提供了一个`GridView.DataController.GetAllFilteredAndSortedRows()`方法，可以用于提取GridView当前数据，在筛选排序等操作之后更改了的数据也可以提取。\n\n<font color=red> 但是，GridView类中的DataController对象在VS中被隐藏了，即通过提示器是找不到GDataController对象的的，只能通过手写调用。</font>\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090957.png)\n\nGetAllFilteredAndSortedRows()方法返回的是一个IList泛型列表，数据写入Excel一就要自己手动写入，写入方法：\n\n```C#\n//需要包含的引用\nusing DevExpress.XtraSpreadsheet;\nusing DevExpress.Spreadsheet;\n\nSpreadsheetControl ss = new SpreadsheetControl();\nvar book = ss.Document;\nWorksheet sheet = book.Worksheets[0];\nsheet.Import(table, true, 0, 0);//table是DataTable类型，也是要导出到Excel的数据\n```\n\n<font color=red> 其中有一点需要格外注意，在使用Import函数时需要引用`DevExpress.Docs`程序集，因为Import函数在这个程序集里，Dev在DevExpress.Docs程序集里给Worksheet的父类ExternalWorksheet写了扩展，也就是扩展了Import函数等，其中DevExpress.Docs程序集和DevExpress.Spreadsheet程序集的命名空间是一样的，如果没有搞清楚这一点很容易产生玄学问题🥴</font>\n\n### 2.GridView.Export()方法\n\n最简单的方法就是使用Dev官方提供的导出方法GridView.Export().\n\nDev已经在GridView中添加了官方的Export方法，支持多种导出格式：\n\n- Xls\n- Xlsx\n- Html\n- Mht\n- Pdf\n- Text\n- Rtf\n- Csv\n- Image\n- Docx\n\n同时提供三种重载：\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326091003.png)\n\n使用方法也很简单：\n\n```C#\n/// <summary>\n/// 将GridView中的数据导出到Excel\n/// </summary>\n/// <param name=\"fileName\"></param>\n/// <param name=\"view\"></param>\npublic static void ExportExcel(string fileName, GridView view)\n{\n    SaveFileDialog sfd = new SaveFileDialog();\n    sfd.Title = \"另存为\";\n    sfd.InitialDirectory = \"C:\\\\\";\n    sfd.Filter = \"Excel文件(*.xlsx) | *.xlsx\";\n    sfd.FileName = fileName;//fileName文件名不需要包含后缀\n    if (sfd.ShowDialog() == DialogResult.OK)\n    {\n        view.Export(DevExpress.XtraPrinting.ExportTarget.Xlsx, sfd.FileName);\n    }\n}\n```\n\n- view.Export是dev自带的导出方法，在导出文件后dev会自动调用系统对此文件的默认打开应用来打开文件，当然dev也提供内置的预览方法，这在下一节导出word模板中使用。\n\n## 七、向Word模板中写入数据\n\n### 1.载入word模板文件\n\n向word模板中写入数据我这里主要使用的是<font color=red>RichEditControl</font>类，RichEditControl类提供海量的富文本API接口，这里主要讲解使用到的API。\n\n首先打开word文档，RichEditControl类提供RichEditControl.LoadDocument(string path)方法加载文档，RichEditControl类也提供多个LoadDocument函数的重载给予各种文件的加载形式，我这里使用的是直接通过文件路径加载文档。LoadDocument函数支持DOC、DOCX、RTP、HTM、HTML、MHT、XML和EPUB类型的文档，可以自动检测文档类型。\n\n```C#\nRichEditControl.LoadDocument(string path)\n```\n\n将文档载入内存之后就可以通过<font color=red>RichEditControl.Document.Text</font>属性查看文档内容了，也可以通过RichEditControl.Document.Text属性判断文档是否加载成功。\n\n```C#\nif(richEditControl.Document.Text == null)\n{\n\treturn;\n}\n```\n\n### 2.向word模板的指定位置写入数据\n\n向word模板的指定位置写入数据主要使用Word的书签和域，我这里使用的是书签，在word中想要插入数据的地方添加一个书签即可，如：\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326091009.png)\n\n我想要在生产号、型号和图号后面的单元格写入数据，那么我只需要在这些单元中添加书签即可，添加书签的步骤：\n\n```mermaid\ngraph LR;\n将光标定位到要添加的书签的位置-->插入-->书签-->添加一个书签名-->添加\n```\n\n添加完书签时候在word上是看不到的，但是把光标定位到书签所在的位置处，插入书签时会自定定位到所插入的书签名。\n\n然后即可通过<font color=red> Document.Replace(DocumentRange range,string text)</font>函数来向书签所在位置插入数据了，其中DocumentRange类型的参数需要通过<font color=red>Document.Bookmarks[string bookmarks].Range</font>来将字符串类型的书签标志转换为DocumentRange类型的可用书签标志。\n\n如：我要在生产号、型号和图号后面的单元格写入数据，那么我需要分别在这些单元格中插入书签`sch`、`xh`、`th`，然后通过下面代码即可向word模板中写入数据\n\n```C#\nRichEditControl richEdit = new RichEditControl();\nrichEdit.LoadDocument(\"C:/a.doc\");\nDocument doc = rich.Document;\ndoc.Replace(doc.Bookmarks[\"sch\"].Range,\"01\");\ndoc.Replace(doc.Bookmarks[\"xh\"].Range,\"02\");\ndoc.Replace(doc.Bookmarks[\"th\"].Range,\"03\");\n```\n\n原理就是书签提供了一个占位符，而dev则通过搜索匹配的占位符，将指定数据替换掉占位符。\n\n### 3.向word模板中的表格插入新行并写入内容\n\n向word模板中的表格插入新行则稍微复杂一些。主要步骤如下：\n\n- 首先word文档中要有一个模板表格\n\n- 需要在要插入表的位置添加书签table\n\n- 遍历word文档中所有的表再遍历每一个表中所有的单元格，查找到书签所在的单元格\n\n  ```c#\n  public TableCell GetTableCell(Document document) \n  {\n      //遍历文档中所有的表\n      foreach (Table table in document.Tables)\n      {\n          int row = 0, col = 0;\n          bool ok = false;\n          TableCell retCell = null;\n  \t\t//遍历表格中所有的单元格\n          table.ForEachCell((cell, rowIndex, columnIndex) =>\n                            {\n                                if (cell.Range.Contains(document.Bookmarks[\"table\"].Range.Start))\n                                {\n                                    row = rowIndex;\n                                    col = columnIndex;\n                                    retCell = cell;\n                                    ok = true;\n                                }\n                            });\n          if (ok)\n          {\n              return retCell;\n          }\n      }\n  ```\n\n  <font color=red>Table.ForEachCell(TableCellProcessorDelegate cellProcessor)</font>函数传入的是一个委托。这里使用的是匿名方法\n\n- 在指定单元格后新增行\n\n  可以使用<font color=red>Document.Tables[int index].Rows.Append()</font>函数在表的最后追加行，或使用<font color=red> Document.Tables[int index].Rows.InsertAfter(int rowIndex)</font>函数在指定行之后插入行。其中Document.Tables[int index].Rows.Append()中index（表的索引）可以通过<font color=red> Document.Tables.IndexOf(Table table)</font>函数获取，而table又可以同通过上一步查找到的TableCell对象retCell.Table属性获取。\n\n  ```c#\n  RichEditControl richEdit = new RichEditControl();\n  richEdit.LoadDocument(\"C:/a.doc\");\n  Document doc = rich.Document;\n  TableCell cell = GetTableCell(doc);\n  doc.BeginUpdate();\n  int index = doc.Tables.IndexOf(cell.Table);\n  doc.Tables[index].Rows.Append();//或者\n  //doc.Table[index].Rows.InsertAfter(cell.Row.Index - 1);\n  //获取指定单元格的占位符范围\n  DocumentRange range = doc.Tables[index].Rows[cell.Row.Index].Cells[cell.Index].ContentRange;\n  doc.Replace()\n  doc.EndUpdate();\n  ```\n\n  ","slug":"【Dev】DevExpress应用","published":1,"updated":"2021-03-26T01:10:16.852Z","_id":"ckkou93hl0001ekr799tm2wkb","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h2 id=\"一、大纲\"><a href=\"#一、大纲\" class=\"headerlink\" title=\"一、大纲\"></a>一、大纲</h2><p>最近使用DevExpress做C/S开发碰到了一些问题，在解决问题的同时在这里做一下记录，下面列出涉及到技术点</p>\n<ul>\n<li><strong>Dev框架下GridControl与GridView</strong></li>\n<li><strong>使用模板列动态替换GridView的指定列</strong></li>\n<li><strong>GridView分组并去掉列名的前缀</strong></li>\n<li><strong>FPT服务器文件预览与下载</strong></li>\n<li><strong>单元格添加按钮并添加自定义点击事件</strong></li>\n<li><strong>GridView数据导出到Excel</strong></li>\n<li><strong>向Word模板中写数据</strong></li>\n</ul>\n<a id=\"more\"></a>\n\n<h2 id=\"二、Dev框架下的GridControl和GridView\"><a href=\"#二、Dev框架下的GridControl和GridView\" class=\"headerlink\" title=\"二、Dev框架下的GridControl和GridView\"></a>二、Dev框架下的GridControl和GridView</h2><h3 id=\"1-GridControl和GridView的关系\"><a href=\"#1-GridControl和GridView的关系\" class=\"headerlink\" title=\"1.GridControl和GridView的关系\"></a>1.GridControl和GridView的关系</h3><p>Dev框架下GridControl负责操作数据，GridView负责展示数据，GridControl是GridView的容器，一个GridControl可以容纳多个GridView，在GridView中的任何数据操作都不会影响到GridControl中的源数据，即当我们将GridControl中数据重新刷入GridView时，GridView中数据操作会被清除，所以如果我们有要在本地展示的数据则需要在GridControl刷数据进入GridView的时候重新再刷入一次本地数据。</p>\n<h3 id=\"2-GridControl输入数据到GridView的原理\"><a href=\"#2-GridControl输入数据到GridView的原理\" class=\"headerlink\" title=\"2.GridControl输入数据到GridView的原理\"></a>2.GridControl输入数据到GridView的原理</h3><p>GridControl的数据刷入GridView的操作由Dev框架执行，我们需要做的只是把数据绑定到GridControl.DataSource中即可。</p>\n<p>只有当GridView中存在与GridControl数据源对应列时，GridControl才能将对应列的数据刷入GridView的对应列中，这里的对应列指的是GridView中列的<code>FiledName</code>的值与GridControl数据源的列名相同，且大小写敏感。</p>\n<p>在GridView的列属性中有三个极为重要的属性：</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090745.png\"></p>\n<ul>\n<li><p>Name：列在程序中操作的标识符，类似变量名，对列的操作都由它来引用，如：修改colfilename列的列宽</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c#\">colfilename.Width = <span class=\"hljs-number\">300</span>;<br></code></pre></td></tr></table></figure></li>\n<li><p>ColumnEdit：用于挂载模板列的属性，可以将列动态的替换为其他类型的控件，例子中是将列挂载了一个多行编辑框，这样就可以在单元格中显示多行内容</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090756.png\"></p>\n</li>\n<li><p>FieldName：FieldName属性是列与GridControl数据源对应的标志，如果想要将GridControl数据源中某一列的数据刷入当前列，那么当前列的FieldName的取值必须和数据源中对应列的列名一致，并且FielName也是用来获取表格数据的标识，如：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C#\">gridView_FileViewer.GetFocusedDataRow()[<span class=\"hljs-string\">&quot;path&quot;</span>]<span class=\"hljs-comment\">//取所选行的path列单元格的数据</span><br></code></pre></td></tr></table></figure>\n\n\n</li>\n</ul>\n<h3 id=\"3-向GridView存在而GridControl中不存在的列刷入数据\"><a href=\"#3-向GridView存在而GridControl中不存在的列刷入数据\" class=\"headerlink\" title=\"3.向GridView存在而GridControl中不存在的列刷入数据\"></a>3.向GridView存在而GridControl中不存在的列刷入数据</h3><p>有的时候为了展示需要，我们需要在GridView中增加新列刷入自己的数据，而新增列在GridControl的数据源中没有与之对应的列，即在数据源中没有对应的字段（这里的数据源通常情况下指的就是数据库中的表），此时我们就需要在GridControl.Datasource中动态地添加一列来与新增列对应。</p>\n<p>为什么要要在GridControl.Datasource中动态地添加一列呢？</p>\n<p>这可能是由GridControl和GridView的内部机制影响的，当一列在GridView中存在而GridControl中不存在时，我们是无法向此列写入数据的，即使数据是来自本地而不是数据库，并且编译器会报错：</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090901.png\"></p>\n<p>如果我们要向GridView存在而GridControl中不存在的列刷入数据，那么我们必须在GridControl的DataSource中动态的加列，下面是示例代码：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c#\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">LoadFileNameColumn</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">object</span> sender, EventArgs args</span>)</span><br><span class=\"hljs-function\"></span>&#123;<br>\tGridColumn col = gridView_JobPlacement.Columns[<span class=\"hljs-string\">&quot;xgwj&quot;</span>];<span class=\"hljs-comment\">//取表格xgwj列的索引</span><br><br>\t<span class=\"hljs-comment\">/*代码块说明：</span><br><span class=\"hljs-comment\">\t*   作用：向gridview的datasource动态添加filename列，使GridView中的filename列与DataSource中的filename字段对应</span><br><span class=\"hljs-comment\">\t*   说明：因为在GridView中添加了filename列如果在GridView的DataSource中没有与之对应的字段，</span><br><span class=\"hljs-comment\">\t*       则无法对filename列做任何操作</span><br><span class=\"hljs-comment\">\t*/</span><br>\tDataTable gridViewTable = gridControl_JobPlacement.DataSource <span class=\"hljs-keyword\">as</span> DataTable;<span class=\"hljs-comment\">//取DataSource的引用并转换成DataTable</span><br>\t<span class=\"hljs-keyword\">if</span> (!gridViewTable.Columns.Contains(<span class=\"hljs-string\">&quot;filename&quot;</span>))<span class=\"hljs-comment\">//判断DataSource中是否已存在filename列</span><br>\t&#123;<br>\t\tDataColumn dsFileNameCol = <span class=\"hljs-keyword\">new</span> DataColumn();<span class=\"hljs-comment\">//创建新列</span><br>\t\tdsFileNameCol.ColumnName = <span class=\"hljs-string\">&quot;filename&quot;</span>;<span class=\"hljs-comment\">//将新列命名为filename</span><br>         gridViewTable.Columns.Add(dsFileNameCol);<span class=\"hljs-comment\">//将新列添加到DataSource中</span><br>\t&#125;<span class=\"hljs-comment\">//至此，DataSource中就存在与GridView中的filename列对应的filename列了</span><br><br>\t<span class=\"hljs-comment\">//遍历GridView所有行，对有文件组编码的行在filename列载入文件列表信息</span><br>\t <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> rowIndex = <span class=\"hljs-number\">0</span>; rowIndex &lt; gridView_JobPlacement.RowCount; rowIndex++)<br>\t&#123;     <br>\t\t DataRow row = gridView_JobPlacement.GetDataRow(rowIndex);<span class=\"hljs-comment\">//根据索引数据行</span><br>\t\t<span class=\"hljs-keyword\">if</span> (row[<span class=\"hljs-string\">&quot;xgwj&quot;</span>].ToString() != <span class=\"hljs-string\">&quot;&quot;</span>)<span class=\"hljs-comment\">//如果数据行中的xgwj列单元格不为空，则向单元格刷入指定数据</span><br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">string</span> fileGroupTmp = gridView_JobPlacement.GetRowCellDisplayText(rowIndex, col);<span class=\"hljs-comment\">//取指定单元格显示的内容</span><br>\t\t\t<span class=\"hljs-built_in\">string</span> fileGroup = CodingTool.GetFileGroup(fileGroupTmp);<span class=\"hljs-comment\">//将单元格存储的文件组编码转换成数据库可用的编码</span><br>\t\t\tDataTable table = bll.SelectFromFileTableByFileGroup(fileGroup);<span class=\"hljs-comment\">//根据编码到数据库查询文件列表</span><br>\t\t\t<span class=\"hljs-keyword\">foreach</span>(DataRow tableRow <span class=\"hljs-keyword\">in</span> table.Rows)<span class=\"hljs-comment\">//遍历文件列表将文件名刷入新增列</span><br>\t\t\t&#123;<br>\t\t\t\trow[<span class=\"hljs-string\">&quot;filename&quot;</span>] += tableRow[<span class=\"hljs-string\">&quot;filename&quot;</span>]+<span class=\"hljs-string\">&quot;\\n&quot;</span>;<span class=\"hljs-comment\">//将数据刷入filename列单元格</span><br>\t\t\t&#125;<br>         &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"三、使用模板列动态替换GridView中的指定列\"><a href=\"#三、使用模板列动态替换GridView中的指定列\" class=\"headerlink\" title=\"三、使用模板列动态替换GridView中的指定列\"></a>三、使用模板列动态替换GridView中的指定列</h2><p>有的时候为了保密需要，在数据库中部分字段会用编码标识，如：人名使用编码标识，张三对应编码001，但是在表格中展示的时候应该显示人名而不是编码，此时我们就需要用到模板列的动态替换。</p>\n<p>直接上代码：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c#\">Security.BLL.userinfo ubll = <span class=\"hljs-keyword\">new</span> Security.BLL.userinfo();<br><br>RepositoryItemGridLookUpEdit replaceRegistrant = <span class=\"hljs-keyword\">new</span> RepositoryItemGridLookUpEdit();<br>replaceRegistrant.DataSource = ubll.GetAllList().Tables[<span class=\"hljs-number\">0</span>];<span class=\"hljs-comment\">//绑定数据源到RepositoryItemGridLookUpEdit</span><br>replaceRegistrant.DisplayMember = <span class=\"hljs-string\">&quot;fullname&quot;</span>;  <span class=\"hljs-comment\">//选择要替换显示的字段</span><br>replaceRegistrant.ValueMember = <span class=\"hljs-string\">&quot;ID&quot;</span>;  <span class=\"hljs-comment\">//</span><br>replaceRegistrant.NullText = <span class=\"hljs-string\">&quot;&quot;</span>;<span class=\"hljs-comment\">//字段为空时要显示的内容</span><br>gridView_JobPlacement.Columns[<span class=\"hljs-string\">&quot;djr&quot;</span>].ColumnEdit = replaceRegistrant;<span class=\"hljs-comment\">//将RepositoryItemGridLookUpEdit绑定到GridView的“djr”列</span><br><br>RepositoryItemGridLookUpEdit replacePricipal = <span class=\"hljs-keyword\">new</span> RepositoryItemGridLookUpEdit();<br>replacePricipal.DataSource = ubll.GetAllList().Tables[<span class=\"hljs-number\">0</span>];<span class=\"hljs-comment\">//绑定数据源到RepositoryItemGridLookUpEdit</span><br>replacePricipal.DisplayMember = <span class=\"hljs-string\">&quot;fullname&quot;</span>;  <span class=\"hljs-comment\">//选择要替换显示的字段</span><br>replacePricipal.ValueMember = <span class=\"hljs-string\">&quot;ID&quot;</span>;  <span class=\"hljs-comment\">//</span><br>replacePricipal.NullText = <span class=\"hljs-string\">&quot;&quot;</span>;<span class=\"hljs-comment\">//字段为空时要显示的内容</span><br>gridView_JobPlacement.Columns[<span class=\"hljs-string\">&quot;fzr&quot;</span>].ColumnEdit = replacePricipal;<span class=\"hljs-comment\">//将RepositoryItemGridLookUpEdit绑定到GridView的“djr”列</span><br></code></pre></td></tr></table></figure>\n<p>这是通过代码添加动态的添加模板列，同时我们也可以在列属性中的ColumnEdit属性中静态的添加模板列。</p>\n<h2 id=\"四、GridView分组并去掉列名的前缀\"><a href=\"#四、GridView分组并去掉列名的前缀\" class=\"headerlink\" title=\"四、GridView分组并去掉列名的前缀\"></a>四、GridView分组并去掉列名的前缀</h2><h3 id=\"1-分组\"><a href=\"#1-分组\" class=\"headerlink\" title=\"1.分组\"></a>1.分组</h3><p>GridView分组只需要在需要分组的列的属性中将GroupIndex属性值由“-1”改为0即可，如果需要二级分组则在需要分组的列的属性中将GroupIndex属性值由“-1”改为1，以此类推需要三级分组则改为2。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090912.png\"></p>\n<h3 id=\"2-去掉列名前缀\"><a href=\"#2-去掉列名前缀\" class=\"headerlink\" title=\"2.去掉列名前缀\"></a>2.去掉列名前缀</h3><p>分完组后如果不做修改我们加载数据之后表格是这样的：</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090919.png\"></p>\n<p>有时我们不需要显示列名前缀，这时我们需要修改GridView的GroupFormat属性修改为{1}，GroupFormat属性的默认值是<code>&#123;0&#125;: [#image]&#123;1&#125; &#123;2&#125;</code>，其中</p>\n<ul>\n<li>{0}显示列标题</li>\n<li>[#image]显示图片</li>\n<li>{1}显示列的内容值</li>\n<li>{2}显示列的摘要</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090923.png\"></p>\n<p>设置好之后，效果是这样的:</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090936.png\"></p>\n<h2 id=\"四、FTP文件预览与下载\"><a href=\"#四、FTP文件预览与下载\" class=\"headerlink\" title=\"四、FTP文件预览与下载\"></a>四、FTP文件预览与下载</h2><p>直接上代码，解释都放注释上了：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c#\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">PreviewFile</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">object</span> sender,EventArgs e</span>)</span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (fileDic == <span class=\"hljs-literal\">null</span>)<br>    &#123;<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">//自定义函数，获取文件在服务器中的路径</span><br>    <span class=\"hljs-built_in\">string</span> serverPath = ServerFTP.CreateFilePathInServerBySQLPath(gridView_FileViewer.GetFocusedDataRow()[<span class=\"hljs-string\">&quot;path&quot;</span>].ToString());<br>    <span class=\"hljs-comment\">//获取文件名</span><br>    <span class=\"hljs-built_in\">string</span> fileName = gridView_FileViewer.GetFocusedDataRow()[<span class=\"hljs-string\">&quot;file&quot;</span>].ToString();<br>    <span class=\"hljs-comment\">//根据路径将文件下载到本地，并返回文件路径</span><br>    <span class=\"hljs-built_in\">string</span> savePath = ServerFTP.currentMode.RequestFile(serverPath,fileName,GeneralLib.FTPDownloadStyle.CACHE);<br>    <span class=\"hljs-keyword\">if</span> (savePath != <span class=\"hljs-string\">&quot;&quot;</span>)<br>    &#123;<br>        <span class=\"hljs-comment\">//调用系统软件打开文件</span><br>        FileIO.OpenFileInWindows(savePath);<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这里挑几个比较重要的函数讲解</p>\n<p><strong>RequestFile</strong></p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c#\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">string</span> <span class=\"hljs-title\">RequestFile</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">string</span> serverPath,<span class=\"hljs-built_in\">string</span> fileName, FTPDownloadStyle style</span>)</span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-built_in\">string</span> savePath = <span class=\"hljs-string\">&quot;&quot;</span>;<br>    <span class=\"hljs-keyword\">switch</span> (style)<br>    &#123;<br>        <span class=\"hljs-comment\">//下载文件到缓存临时文件夹，用于预览</span><br>        <span class=\"hljs-keyword\">case</span> FTPDownloadStyle.CACHE:<br>            savePath = Path.Combine(ServerFTP.cachePath, fileName);<br>            <span class=\"hljs-keyword\">break</span>;<br>        <span class=\"hljs-comment\">//下载文件到所选的文件夹，用于下载</span><br>        <span class=\"hljs-keyword\">case</span> FTPDownloadStyle.CHOOSEDIC:<br>            savePath = FileIO.ChooseSaveFile(fileName, <span class=\"hljs-string\">&quot;&quot;</span>, ServerFTP.chooseTempDic);       <br>            <span class=\"hljs-comment\">//保存所选的文件夹，以便下次打开直接进入相应目录</span><br>            ServerFTP.chooseTempDic = Path.GetDirectoryName(savePath);<br>            <span class=\"hljs-keyword\">break</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (savePath == <span class=\"hljs-literal\">null</span>)<br>    &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&quot;</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">//判断目录是否存在</span><br>    <span class=\"hljs-keyword\">if</span> (!Directory.Exists(Path.GetDirectoryName(savePath)))<br>    &#123;<br>        <span class=\"hljs-comment\">//如果不存在则创建目录</span><br>        Directory.CreateDirectory(Path.GetDirectoryName(savePath));<br>    &#125;<br><br>\t<span class=\"hljs-comment\">//根据文件路径创建FPT连接实例</span><br>    FtpWebRequest ftp = (FtpWebRequest)WebRequest.Create(serverPath);<br>    <span class=\"hljs-comment\">//从配置文件中读取登录项</span><br>    ICredentials credentials = <span class=\"hljs-keyword\">new</span> NetworkCredential(Config.Get[<span class=\"hljs-string\">&quot;ftp_username&quot;</span>], Config.Get[<span class=\"hljs-string\">&quot;ftp_password&quot;</span>]);<br>    <span class=\"hljs-comment\">//配置FPT服务器登录项</span><br>    ftp.Credentials = credentials；<br>    <span class=\"hljs-comment\">//配置FPT操作为下载文件</span><br>    ftp.Method = WebRequestMethods.Ftp.DownloadFile;<br>\t<span class=\"hljs-comment\">//向FPT服务器发出操作请求</span><br>    FtpWebResponse response = (FtpWebResponse)ftp.GetResponse();<br>    <span class=\"hljs-comment\">//创建流缓冲区接收FPT服务器反馈的字节流</span><br>    Stream responseStream = response.GetResponseStream();<br>    <span class=\"hljs-comment\">//根据存储路径在本地创建文件</span><br>    FileStream fs = File.Create(savePath);<br>    <span class=\"hljs-comment\">//创建用于批量取缓冲区字节数据的数据</span><br>    <span class=\"hljs-built_in\">byte</span>[] buffer = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">byte</span>[ConstLib.BUFFER_SIZE];<br>    <span class=\"hljs-built_in\">int</span> read = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">do</span><br>    &#123;<br>        <span class=\"hljs-comment\">//将缓冲区的字节数据读入字节数组</span><br>        read = responseStream.Read(buffer, <span class=\"hljs-number\">0</span>, buffer.Length);<br>        <span class=\"hljs-comment\">//将字节数组的数据写入到文件中</span><br>        fs.Write(buffer, <span class=\"hljs-number\">0</span>, read);<br>        <span class=\"hljs-comment\">//清楚fs的流缓冲区，这里fs的流缓冲区与responseStream流缓冲区不是同一个缓冲区，需要注意</span><br>        fs.Flush();<br>    &#125;<br>    <span class=\"hljs-keyword\">while</span> (read != <span class=\"hljs-number\">0</span>)；<br>        <br>    fs.Flush();<br>    <span class=\"hljs-comment\">//关闭文件</span><br>    fs.Close();<br>    <br>    <span class=\"hljs-keyword\">return</span> savePath;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>OpenFileInWindows</strong></p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C#\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Process <span class=\"hljs-title\">OpenFileInWindows</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">string</span> filePath</span>)</span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//创建一个新的进程</span><br>    ProcessStartInfo info = <span class=\"hljs-keyword\">new</span> ProcessStartInfo();<br>    <span class=\"hljs-comment\">//设置进程要打开的文档，Windows会根据文件类型的默认开打应用来启动对应应用程序来打开文件</span><br>    info.FileName = Path.GetFileName(filePath);<br>    <span class=\"hljs-comment\">//设置启动进程的初始目录</span><br>    info.WorkingDirectory = Path.GetDirectoryName(filePath);<br>    <span class=\"hljs-comment\">//设置进程启动后，窗口的状态，可以设置为最大化，最小化和正常</span><br>    info.WindowStyle = ProcessWindowStyle.Normal;<br>    <span class=\"hljs-comment\">//启动进程</span><br>    Process proc = Process.Start(info);<br><br>    <span class=\"hljs-keyword\">return</span> proc;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>当关闭文件时清楚临时文件夹的内容</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c#\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">CleanCacheDirectory</span>(<span class=\"hljs-params\"></span>)</span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//判断临时文件夹是否存在</span><br>    <span class=\"hljs-keyword\">if</span> (!Directory.Exists(ServerFTP.cachePath))<br>    &#123;<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">try</span><br>    &#123;<br>        <span class=\"hljs-comment\">//等待系统将占用文件的进程杀死再清空临时文件夹</span><br>        System.Threading.Thread.Sleep(<span class=\"hljs-number\">500</span>);<br>        <span class=\"hljs-comment\">//获取临时文件夹目录信息</span><br>        DirectoryInfo dicInfo = <span class=\"hljs-keyword\">new</span> DirectoryInfo(ServerFTP.cachePath);<br>        <span class=\"hljs-comment\">//直接删除临时文件夹</span><br>        dicInfo.Delete(<span class=\"hljs-literal\">true</span>);<br>    &#125;<br>    catch<br>    &#123;<br>        <span class=\"hljs-comment\">//如果目录被其他进程占用，则暂时不清空临时文件夹</span><br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这里我使用的是最简单的直接删除临时文件夹的暴力删除法，这样做会有一个问题就是，在程序删除文件夹的时候，可能预览文件的进程还没有被系统杀死或有其他的进程占用了目录中文件，这都会导致目录删除失败而抛出异常，我的解决方案是在删除目录之前等待500ms，等待系统将预览文件的进程杀死后在删除文件夹，但是如果是其他的进程占用了目录，则需要手动结束进程才能继续删除临时文件夹，我的解决方案是，如果有其他进程占用了目录，则本次本次临时缓冲区先不删除，等下次有机会再删除。所以这里的try-catch不是用来抛出异常的，而是用来推出函数的。</p>\n<p>当然比较理想的删除方法是遍历整个目录中文件和子文件夹，依次删除目录下文件和子文件夹，有被其他进程占用的文件暂时不删除。这样就可以只留下被占用的文件，而不是整个目录。</p>\n<h2 id=\"五、单元格添加按钮并添加自定义点击事件\"><a href=\"#五、单元格添加按钮并添加自定义点击事件\" class=\"headerlink\" title=\"五、单元格添加按钮并添加自定义点击事件\"></a>五、单元格添加按钮并添加自定义点击事件</h2><p>有时我们需要向某一列的单元格添加点击事件，甚至向某一个单元格添加点击事件，这时我们就需要向单元格添加按钮了。</p>\n<h3 id=\"1-向单元格添加简单的点击事件\"><a href=\"#1-向单元格添加简单的点击事件\" class=\"headerlink\" title=\"1.向单元格添加简单的点击事件\"></a>1.向单元格添加简单的点击事件</h3><p>如果我们只想在某一单元格添加简单的点击事件</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C#\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">gridView_JobPlacement_RowCellClick</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">object</span> sender, RowCellClickEventArgs e</span>)</span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (e.RowHandle == <span class=\"hljs-number\">1</span> &amp;&amp; e.Column.FieldName == <span class=\"hljs-string\">&quot;filename&quot;</span>)<br>    &#123;<br>        <span class=\"hljs-keyword\">if</span> (e.Button == MouseButtons.Left)<br>        &#123;<br>            <span class=\"hljs-comment\">//todo</span><br>        &#125;<br>        <span class=\"hljs-keyword\">if</span> (e.Button == MouseButtons.Right)<br>        &#123;<br>\t\t\t<span class=\"hljs-comment\">//todo</span><br>        &#125;<br>        <span class=\"hljs-keyword\">if</span>(e.Button == MouseButtons.Moddle)<br>        &#123;<br>            <span class=\"hljs-comment\">//todo</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这时我们需要用到RowCellClick事件，RowCellClick事件在鼠标点击单元格时触发，然后我们只需要判定鼠标点击是哪一行哪一列，就可以实现某一个单元格的点击事件了。当然我们也可以通过添加按钮来实现。</p>\n<h3 id=\"2-向单元格添加复杂点击事件\"><a href=\"#2-向单元格添加复杂点击事件\" class=\"headerlink\" title=\"2.向单元格添加复杂点击事件\"></a>2.向单元格添加复杂点击事件</h3><p>如果我们想向单元格添加一系列复杂的点击事件，如在某一单元格内做文件的上传，预览，下载，删除等操作，这时我们就需要借助模板列了，使用模板列是无法只向某一个单元添加点击事件的，因为模板列挂载的是一整列。</p>\n<p>我需要用到模板列<code>RepositoryItemButtonEdit</code>，我可以在列属性里静态挂载，也可以在代码中动态挂载，重要的是我们需要用到<code>RepositoryItemButtonEdit</code>属性里的<code>Buttons</code>属性，向Buttons属性里添加元素。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090945.png\"></p>\n<p>光是添加按钮单元中还是看不到按钮的，我们还需要将每个按钮的Kind属性设置为Glyph，这样我们才能在单元格中看到按钮</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090950.png\"></p>\n<p>添加完按钮就可以向对应按钮添加点击事件了，我们可以发现在列属性里找不到事件，所以我们需要在代码中为按钮添加点击事件，这时我们需要用到<code>repositoryItemButtonEdit.Buttons[0].Click</code>，其中repositoryItemButtonEdit是模板列的名字，Buttons[0]是第一个按钮的引用，我们只需要向Click事件添加我们想要执行的函数即可。</p>\n<h2 id=\"六、GridView数据导出到Excel\"><a href=\"#六、GridView数据导出到Excel\" class=\"headerlink\" title=\"六、GridView数据导出到Excel\"></a>六、GridView数据导出到Excel</h2><p> GridView的数据要导出到Excel有很多种方法，可以最直接的就是遍历GridView，然后将数据写入Excel，这算是比较麻烦的做法了，事实上Dev已经提供了一些便捷的方法。</p>\n<h3 id=\"1-GetAllFilteredAndSortedRows-方法\"><a href=\"#1-GetAllFilteredAndSortedRows-方法\" class=\"headerlink\" title=\"1.GetAllFilteredAndSortedRows()方法\"></a>1.GetAllFilteredAndSortedRows()方法</h3><p>Dev提供了一个<code>GridView.DataController.GetAllFilteredAndSortedRows()</code>方法，可以用于提取GridView当前数据，在筛选排序等操作之后更改了的数据也可以提取。</p>\n<p><font color=\"red\"> 但是，GridView类中的DataController对象在VS中被隐藏了，即通过提示器是找不到GDataController对象的的，只能通过手写调用。</font></p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090957.png\"></p>\n<p>GetAllFilteredAndSortedRows()方法返回的是一个IList泛型列表，数据写入Excel一就要自己手动写入，写入方法：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C#\"><span class=\"hljs-comment\">//需要包含的引用</span><br><span class=\"hljs-keyword\">using</span> DevExpress.XtraSpreadsheet;<br><span class=\"hljs-keyword\">using</span> DevExpress.Spreadsheet;<br><br>SpreadsheetControl ss = <span class=\"hljs-keyword\">new</span> SpreadsheetControl();<br><span class=\"hljs-keyword\">var</span> book = ss.Document;<br>Worksheet sheet = book.Worksheets[<span class=\"hljs-number\">0</span>];<br>sheet.Import(table, <span class=\"hljs-literal\">true</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>);<span class=\"hljs-comment\">//table是DataTable类型，也是要导出到Excel的数据</span><br></code></pre></td></tr></table></figure>\n<p><font color=\"red\"> 其中有一点需要格外注意，在使用Import函数时需要引用<code>DevExpress.Docs</code>程序集，因为Import函数在这个程序集里，Dev在DevExpress.Docs程序集里给Worksheet的父类ExternalWorksheet写了扩展，也就是扩展了Import函数等，其中DevExpress.Docs程序集和DevExpress.Spreadsheet程序集的命名空间是一样的，如果没有搞清楚这一点很容易产生玄学问题🥴</font></p>\n<h3 id=\"2-GridView-Export-方法\"><a href=\"#2-GridView-Export-方法\" class=\"headerlink\" title=\"2.GridView.Export()方法\"></a>2.GridView.Export()方法</h3><p>最简单的方法就是使用Dev官方提供的导出方法GridView.Export().</p>\n<p>Dev已经在GridView中添加了官方的Export方法，支持多种导出格式：</p>\n<ul>\n<li>Xls</li>\n<li>Xlsx</li>\n<li>Html</li>\n<li>Mht</li>\n<li>Pdf</li>\n<li>Text</li>\n<li>Rtf</li>\n<li>Csv</li>\n<li>Image</li>\n<li>Docx</li>\n</ul>\n<p>同时提供三种重载：</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326091003.png\"></p>\n<p>使用方法也很简单：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C#\"><span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span><br><span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> 将GridView中的数据导出到Excel</span><br><span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span><br><span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;fileName&quot;&gt;</span><span class=\"hljs-doctag\">&lt;/param&gt;</span></span><br><span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;view&quot;&gt;</span><span class=\"hljs-doctag\">&lt;/param&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ExportExcel</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">string</span> fileName, GridView view</span>)</span><br><span class=\"hljs-function\"></span>&#123;<br>    SaveFileDialog sfd = <span class=\"hljs-keyword\">new</span> SaveFileDialog();<br>    sfd.Title = <span class=\"hljs-string\">&quot;另存为&quot;</span>;<br>    sfd.InitialDirectory = <span class=\"hljs-string\">&quot;C:\\\\&quot;</span>;<br>    sfd.Filter = <span class=\"hljs-string\">&quot;Excel文件(*.xlsx) | *.xlsx&quot;</span>;<br>    sfd.FileName = fileName;<span class=\"hljs-comment\">//fileName文件名不需要包含后缀</span><br>    <span class=\"hljs-keyword\">if</span> (sfd.ShowDialog() == DialogResult.OK)<br>    &#123;<br>        view.Export(DevExpress.XtraPrinting.ExportTarget.Xlsx, sfd.FileName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>view.Export是dev自带的导出方法，在导出文件后dev会自动调用系统对此文件的默认打开应用来打开文件，当然dev也提供内置的预览方法，这在下一节导出word模板中使用。</li>\n</ul>\n<h2 id=\"七、向Word模板中写入数据\"><a href=\"#七、向Word模板中写入数据\" class=\"headerlink\" title=\"七、向Word模板中写入数据\"></a>七、向Word模板中写入数据</h2><h3 id=\"1-载入word模板文件\"><a href=\"#1-载入word模板文件\" class=\"headerlink\" title=\"1.载入word模板文件\"></a>1.载入word模板文件</h3><p>向word模板中写入数据我这里主要使用的是<font color=\"red\">RichEditControl</font>类，RichEditControl类提供海量的富文本API接口，这里主要讲解使用到的API。</p>\n<p>首先打开word文档，RichEditControl类提供RichEditControl.LoadDocument(string path)方法加载文档，RichEditControl类也提供多个LoadDocument函数的重载给予各种文件的加载形式，我这里使用的是直接通过文件路径加载文档。LoadDocument函数支持DOC、DOCX、RTP、HTM、HTML、MHT、XML和EPUB类型的文档，可以自动检测文档类型。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C#\">RichEditControl.LoadDocument(<span class=\"hljs-built_in\">string</span> path)<br></code></pre></td></tr></table></figure>\n<p>将文档载入内存之后就可以通过<font color=\"red\">RichEditControl.Document.Text</font>属性查看文档内容了，也可以通过RichEditControl.Document.Text属性判断文档是否加载成功。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C#\"><span class=\"hljs-keyword\">if</span>(richEditControl.Document.Text == <span class=\"hljs-literal\">null</span>)<br>&#123;<br>\t<span class=\"hljs-keyword\">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"2-向word模板的指定位置写入数据\"><a href=\"#2-向word模板的指定位置写入数据\" class=\"headerlink\" title=\"2.向word模板的指定位置写入数据\"></a>2.向word模板的指定位置写入数据</h3><p>向word模板的指定位置写入数据主要使用Word的书签和域，我这里使用的是书签，在word中想要插入数据的地方添加一个书签即可，如：</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326091009.png\"></p>\n<p>我想要在生产号、型号和图号后面的单元格写入数据，那么我只需要在这些单元中添加书签即可，添加书签的步骤：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mermaid\">graph LR;<br>将光标定位到要添加的书签的位置--&gt;插入--&gt;书签--&gt;添加一个书签名--&gt;添加<br></code></pre></td></tr></table></figure>\n<p>添加完书签时候在word上是看不到的，但是把光标定位到书签所在的位置处，插入书签时会自定定位到所插入的书签名。</p>\n<p>然后即可通过<font color=\"red\"> Document.Replace(DocumentRange range,string text)</font>函数来向书签所在位置插入数据了，其中DocumentRange类型的参数需要通过<font color=\"red\">Document.Bookmarks[string bookmarks].Range</font>来将字符串类型的书签标志转换为DocumentRange类型的可用书签标志。</p>\n<p>如：我要在生产号、型号和图号后面的单元格写入数据，那么我需要分别在这些单元格中插入书签<code>sch</code>、<code>xh</code>、<code>th</code>，然后通过下面代码即可向word模板中写入数据</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C#\">RichEditControl richEdit = <span class=\"hljs-keyword\">new</span> RichEditControl();<br>richEdit.LoadDocument(<span class=\"hljs-string\">&quot;C:/a.doc&quot;</span>);<br>Document doc = rich.Document;<br>doc.Replace(doc.Bookmarks[<span class=\"hljs-string\">&quot;sch&quot;</span>].Range,<span class=\"hljs-string\">&quot;01&quot;</span>);<br>doc.Replace(doc.Bookmarks[<span class=\"hljs-string\">&quot;xh&quot;</span>].Range,<span class=\"hljs-string\">&quot;02&quot;</span>);<br>doc.Replace(doc.Bookmarks[<span class=\"hljs-string\">&quot;th&quot;</span>].Range,<span class=\"hljs-string\">&quot;03&quot;</span>);<br></code></pre></td></tr></table></figure>\n<p>原理就是书签提供了一个占位符，而dev则通过搜索匹配的占位符，将指定数据替换掉占位符。</p>\n<h3 id=\"3-向word模板中的表格插入新行并写入内容\"><a href=\"#3-向word模板中的表格插入新行并写入内容\" class=\"headerlink\" title=\"3.向word模板中的表格插入新行并写入内容\"></a>3.向word模板中的表格插入新行并写入内容</h3><p>向word模板中的表格插入新行则稍微复杂一些。主要步骤如下：</p>\n<ul>\n<li><p>首先word文档中要有一个模板表格</p>\n</li>\n<li><p>需要在要插入表的位置添加书签table</p>\n</li>\n<li><p>遍历word文档中所有的表再遍历每一个表中所有的单元格，查找到书签所在的单元格</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c#\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> TableCell <span class=\"hljs-title\">GetTableCell</span>(<span class=\"hljs-params\">Document document</span>) </span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//遍历文档中所有的表</span><br>    <span class=\"hljs-keyword\">foreach</span> (Table table <span class=\"hljs-keyword\">in</span> document.Tables)<br>    &#123;<br>        <span class=\"hljs-built_in\">int</span> row = <span class=\"hljs-number\">0</span>, col = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-built_in\">bool</span> ok = <span class=\"hljs-literal\">false</span>;<br>        TableCell retCell = <span class=\"hljs-literal\">null</span>;<br>\t\t<span class=\"hljs-comment\">//遍历表格中所有的单元格</span><br>        table.ForEachCell((cell, rowIndex, columnIndex) =&gt;<br>                          &#123;<br>                              <span class=\"hljs-keyword\">if</span> (cell.Range.Contains(document.Bookmarks[<span class=\"hljs-string\">&quot;table&quot;</span>].Range.Start))<br>                              &#123;<br>                                  row = rowIndex;<br>                                  col = columnIndex;<br>                                  retCell = cell;<br>                                  ok = <span class=\"hljs-literal\">true</span>;<br>                              &#125;<br>                          &#125;);<br>        <span class=\"hljs-keyword\">if</span> (ok)<br>        &#123;<br>            <span class=\"hljs-keyword\">return</span> retCell;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>\n<p><font color=\"red\">Table.ForEachCell(TableCellProcessorDelegate cellProcessor)</font>函数传入的是一个委托。这里使用的是匿名方法</p>\n</li>\n<li><p>在指定单元格后新增行</p>\n<p>可以使用<font color=\"red\">Document.Tables[int index].Rows.Append()</font>函数在表的最后追加行，或使用<font color=\"red\"> Document.Tables[int index].Rows.InsertAfter(int rowIndex)</font>函数在指定行之后插入行。其中Document.Tables[int index].Rows.Append()中index（表的索引）可以通过<font color=\"red\"> Document.Tables.IndexOf(Table table)</font>函数获取，而table又可以同通过上一步查找到的TableCell对象retCell.Table属性获取。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c#\">RichEditControl richEdit = <span class=\"hljs-keyword\">new</span> RichEditControl();<br>richEdit.LoadDocument(<span class=\"hljs-string\">&quot;C:/a.doc&quot;</span>);<br>Document doc = rich.Document;<br>TableCell cell = GetTableCell(doc);<br>doc.BeginUpdate();<br><span class=\"hljs-built_in\">int</span> index = doc.Tables.IndexOf(cell.Table);<br>doc.Tables[index].Rows.Append();<span class=\"hljs-comment\">//或者</span><br><span class=\"hljs-comment\">//doc.Table[index].Rows.InsertAfter(cell.Row.Index - 1);</span><br><span class=\"hljs-comment\">//获取指定单元格的占位符范围</span><br>DocumentRange range = doc.Tables[index].Rows[cell.Row.Index].Cells[cell.Index].ContentRange;<br>doc.Replace()<br>doc.EndUpdate();<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h2 id=\"一、大纲\"><a href=\"#一、大纲\" class=\"headerlink\" title=\"一、大纲\"></a>一、大纲</h2><p>最近使用DevExpress做C/S开发碰到了一些问题，在解决问题的同时在这里做一下记录，下面列出涉及到技术点</p>\n<ul>\n<li><strong>Dev框架下GridControl与GridView</strong></li>\n<li><strong>使用模板列动态替换GridView的指定列</strong></li>\n<li><strong>GridView分组并去掉列名的前缀</strong></li>\n<li><strong>FPT服务器文件预览与下载</strong></li>\n<li><strong>单元格添加按钮并添加自定义点击事件</strong></li>\n<li><strong>GridView数据导出到Excel</strong></li>\n<li><strong>向Word模板中写数据</strong></li>\n</ul>","more":"<h2 id=\"二、Dev框架下的GridControl和GridView\"><a href=\"#二、Dev框架下的GridControl和GridView\" class=\"headerlink\" title=\"二、Dev框架下的GridControl和GridView\"></a>二、Dev框架下的GridControl和GridView</h2><h3 id=\"1-GridControl和GridView的关系\"><a href=\"#1-GridControl和GridView的关系\" class=\"headerlink\" title=\"1.GridControl和GridView的关系\"></a>1.GridControl和GridView的关系</h3><p>Dev框架下GridControl负责操作数据，GridView负责展示数据，GridControl是GridView的容器，一个GridControl可以容纳多个GridView，在GridView中的任何数据操作都不会影响到GridControl中的源数据，即当我们将GridControl中数据重新刷入GridView时，GridView中数据操作会被清除，所以如果我们有要在本地展示的数据则需要在GridControl刷数据进入GridView的时候重新再刷入一次本地数据。</p>\n<h3 id=\"2-GridControl输入数据到GridView的原理\"><a href=\"#2-GridControl输入数据到GridView的原理\" class=\"headerlink\" title=\"2.GridControl输入数据到GridView的原理\"></a>2.GridControl输入数据到GridView的原理</h3><p>GridControl的数据刷入GridView的操作由Dev框架执行，我们需要做的只是把数据绑定到GridControl.DataSource中即可。</p>\n<p>只有当GridView中存在与GridControl数据源对应列时，GridControl才能将对应列的数据刷入GridView的对应列中，这里的对应列指的是GridView中列的<code>FiledName</code>的值与GridControl数据源的列名相同，且大小写敏感。</p>\n<p>在GridView的列属性中有三个极为重要的属性：</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090745.png\"></p>\n<ul>\n<li><p>Name：列在程序中操作的标识符，类似变量名，对列的操作都由它来引用，如：修改colfilename列的列宽</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c#\">colfilename.Width = <span class=\"hljs-number\">300</span>;<br></code></pre></td></tr></table></figure></li>\n<li><p>ColumnEdit：用于挂载模板列的属性，可以将列动态的替换为其他类型的控件，例子中是将列挂载了一个多行编辑框，这样就可以在单元格中显示多行内容</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090756.png\"></p>\n</li>\n<li><p>FieldName：FieldName属性是列与GridControl数据源对应的标志，如果想要将GridControl数据源中某一列的数据刷入当前列，那么当前列的FieldName的取值必须和数据源中对应列的列名一致，并且FielName也是用来获取表格数据的标识，如：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C#\">gridView_FileViewer.GetFocusedDataRow()[<span class=\"hljs-string\">&quot;path&quot;</span>]<span class=\"hljs-comment\">//取所选行的path列单元格的数据</span><br></code></pre></td></tr></table></figure>\n\n\n</li>\n</ul>\n<h3 id=\"3-向GridView存在而GridControl中不存在的列刷入数据\"><a href=\"#3-向GridView存在而GridControl中不存在的列刷入数据\" class=\"headerlink\" title=\"3.向GridView存在而GridControl中不存在的列刷入数据\"></a>3.向GridView存在而GridControl中不存在的列刷入数据</h3><p>有的时候为了展示需要，我们需要在GridView中增加新列刷入自己的数据，而新增列在GridControl的数据源中没有与之对应的列，即在数据源中没有对应的字段（这里的数据源通常情况下指的就是数据库中的表），此时我们就需要在GridControl.Datasource中动态地添加一列来与新增列对应。</p>\n<p>为什么要要在GridControl.Datasource中动态地添加一列呢？</p>\n<p>这可能是由GridControl和GridView的内部机制影响的，当一列在GridView中存在而GridControl中不存在时，我们是无法向此列写入数据的，即使数据是来自本地而不是数据库，并且编译器会报错：</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090901.png\"></p>\n<p>如果我们要向GridView存在而GridControl中不存在的列刷入数据，那么我们必须在GridControl的DataSource中动态的加列，下面是示例代码：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c#\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">LoadFileNameColumn</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">object</span> sender, EventArgs args</span>)</span><br><span class=\"hljs-function\"></span>&#123;<br>\tGridColumn col = gridView_JobPlacement.Columns[<span class=\"hljs-string\">&quot;xgwj&quot;</span>];<span class=\"hljs-comment\">//取表格xgwj列的索引</span><br><br>\t<span class=\"hljs-comment\">/*代码块说明：</span><br><span class=\"hljs-comment\">\t*   作用：向gridview的datasource动态添加filename列，使GridView中的filename列与DataSource中的filename字段对应</span><br><span class=\"hljs-comment\">\t*   说明：因为在GridView中添加了filename列如果在GridView的DataSource中没有与之对应的字段，</span><br><span class=\"hljs-comment\">\t*       则无法对filename列做任何操作</span><br><span class=\"hljs-comment\">\t*/</span><br>\tDataTable gridViewTable = gridControl_JobPlacement.DataSource <span class=\"hljs-keyword\">as</span> DataTable;<span class=\"hljs-comment\">//取DataSource的引用并转换成DataTable</span><br>\t<span class=\"hljs-keyword\">if</span> (!gridViewTable.Columns.Contains(<span class=\"hljs-string\">&quot;filename&quot;</span>))<span class=\"hljs-comment\">//判断DataSource中是否已存在filename列</span><br>\t&#123;<br>\t\tDataColumn dsFileNameCol = <span class=\"hljs-keyword\">new</span> DataColumn();<span class=\"hljs-comment\">//创建新列</span><br>\t\tdsFileNameCol.ColumnName = <span class=\"hljs-string\">&quot;filename&quot;</span>;<span class=\"hljs-comment\">//将新列命名为filename</span><br>         gridViewTable.Columns.Add(dsFileNameCol);<span class=\"hljs-comment\">//将新列添加到DataSource中</span><br>\t&#125;<span class=\"hljs-comment\">//至此，DataSource中就存在与GridView中的filename列对应的filename列了</span><br><br>\t<span class=\"hljs-comment\">//遍历GridView所有行，对有文件组编码的行在filename列载入文件列表信息</span><br>\t <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> rowIndex = <span class=\"hljs-number\">0</span>; rowIndex &lt; gridView_JobPlacement.RowCount; rowIndex++)<br>\t&#123;     <br>\t\t DataRow row = gridView_JobPlacement.GetDataRow(rowIndex);<span class=\"hljs-comment\">//根据索引数据行</span><br>\t\t<span class=\"hljs-keyword\">if</span> (row[<span class=\"hljs-string\">&quot;xgwj&quot;</span>].ToString() != <span class=\"hljs-string\">&quot;&quot;</span>)<span class=\"hljs-comment\">//如果数据行中的xgwj列单元格不为空，则向单元格刷入指定数据</span><br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">string</span> fileGroupTmp = gridView_JobPlacement.GetRowCellDisplayText(rowIndex, col);<span class=\"hljs-comment\">//取指定单元格显示的内容</span><br>\t\t\t<span class=\"hljs-built_in\">string</span> fileGroup = CodingTool.GetFileGroup(fileGroupTmp);<span class=\"hljs-comment\">//将单元格存储的文件组编码转换成数据库可用的编码</span><br>\t\t\tDataTable table = bll.SelectFromFileTableByFileGroup(fileGroup);<span class=\"hljs-comment\">//根据编码到数据库查询文件列表</span><br>\t\t\t<span class=\"hljs-keyword\">foreach</span>(DataRow tableRow <span class=\"hljs-keyword\">in</span> table.Rows)<span class=\"hljs-comment\">//遍历文件列表将文件名刷入新增列</span><br>\t\t\t&#123;<br>\t\t\t\trow[<span class=\"hljs-string\">&quot;filename&quot;</span>] += tableRow[<span class=\"hljs-string\">&quot;filename&quot;</span>]+<span class=\"hljs-string\">&quot;\\n&quot;</span>;<span class=\"hljs-comment\">//将数据刷入filename列单元格</span><br>\t\t\t&#125;<br>         &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"三、使用模板列动态替换GridView中的指定列\"><a href=\"#三、使用模板列动态替换GridView中的指定列\" class=\"headerlink\" title=\"三、使用模板列动态替换GridView中的指定列\"></a>三、使用模板列动态替换GridView中的指定列</h2><p>有的时候为了保密需要，在数据库中部分字段会用编码标识，如：人名使用编码标识，张三对应编码001，但是在表格中展示的时候应该显示人名而不是编码，此时我们就需要用到模板列的动态替换。</p>\n<p>直接上代码：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c#\">Security.BLL.userinfo ubll = <span class=\"hljs-keyword\">new</span> Security.BLL.userinfo();<br><br>RepositoryItemGridLookUpEdit replaceRegistrant = <span class=\"hljs-keyword\">new</span> RepositoryItemGridLookUpEdit();<br>replaceRegistrant.DataSource = ubll.GetAllList().Tables[<span class=\"hljs-number\">0</span>];<span class=\"hljs-comment\">//绑定数据源到RepositoryItemGridLookUpEdit</span><br>replaceRegistrant.DisplayMember = <span class=\"hljs-string\">&quot;fullname&quot;</span>;  <span class=\"hljs-comment\">//选择要替换显示的字段</span><br>replaceRegistrant.ValueMember = <span class=\"hljs-string\">&quot;ID&quot;</span>;  <span class=\"hljs-comment\">//</span><br>replaceRegistrant.NullText = <span class=\"hljs-string\">&quot;&quot;</span>;<span class=\"hljs-comment\">//字段为空时要显示的内容</span><br>gridView_JobPlacement.Columns[<span class=\"hljs-string\">&quot;djr&quot;</span>].ColumnEdit = replaceRegistrant;<span class=\"hljs-comment\">//将RepositoryItemGridLookUpEdit绑定到GridView的“djr”列</span><br><br>RepositoryItemGridLookUpEdit replacePricipal = <span class=\"hljs-keyword\">new</span> RepositoryItemGridLookUpEdit();<br>replacePricipal.DataSource = ubll.GetAllList().Tables[<span class=\"hljs-number\">0</span>];<span class=\"hljs-comment\">//绑定数据源到RepositoryItemGridLookUpEdit</span><br>replacePricipal.DisplayMember = <span class=\"hljs-string\">&quot;fullname&quot;</span>;  <span class=\"hljs-comment\">//选择要替换显示的字段</span><br>replacePricipal.ValueMember = <span class=\"hljs-string\">&quot;ID&quot;</span>;  <span class=\"hljs-comment\">//</span><br>replacePricipal.NullText = <span class=\"hljs-string\">&quot;&quot;</span>;<span class=\"hljs-comment\">//字段为空时要显示的内容</span><br>gridView_JobPlacement.Columns[<span class=\"hljs-string\">&quot;fzr&quot;</span>].ColumnEdit = replacePricipal;<span class=\"hljs-comment\">//将RepositoryItemGridLookUpEdit绑定到GridView的“djr”列</span><br></code></pre></td></tr></table></figure>\n<p>这是通过代码添加动态的添加模板列，同时我们也可以在列属性中的ColumnEdit属性中静态的添加模板列。</p>\n<h2 id=\"四、GridView分组并去掉列名的前缀\"><a href=\"#四、GridView分组并去掉列名的前缀\" class=\"headerlink\" title=\"四、GridView分组并去掉列名的前缀\"></a>四、GridView分组并去掉列名的前缀</h2><h3 id=\"1-分组\"><a href=\"#1-分组\" class=\"headerlink\" title=\"1.分组\"></a>1.分组</h3><p>GridView分组只需要在需要分组的列的属性中将GroupIndex属性值由“-1”改为0即可，如果需要二级分组则在需要分组的列的属性中将GroupIndex属性值由“-1”改为1，以此类推需要三级分组则改为2。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090912.png\"></p>\n<h3 id=\"2-去掉列名前缀\"><a href=\"#2-去掉列名前缀\" class=\"headerlink\" title=\"2.去掉列名前缀\"></a>2.去掉列名前缀</h3><p>分完组后如果不做修改我们加载数据之后表格是这样的：</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090919.png\"></p>\n<p>有时我们不需要显示列名前缀，这时我们需要修改GridView的GroupFormat属性修改为{1}，GroupFormat属性的默认值是<code>&#123;0&#125;: [#image]&#123;1&#125; &#123;2&#125;</code>，其中</p>\n<ul>\n<li>{0}显示列标题</li>\n<li>[#image]显示图片</li>\n<li>{1}显示列的内容值</li>\n<li>{2}显示列的摘要</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090923.png\"></p>\n<p>设置好之后，效果是这样的:</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090936.png\"></p>\n<h2 id=\"四、FTP文件预览与下载\"><a href=\"#四、FTP文件预览与下载\" class=\"headerlink\" title=\"四、FTP文件预览与下载\"></a>四、FTP文件预览与下载</h2><p>直接上代码，解释都放注释上了：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c#\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">PreviewFile</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">object</span> sender,EventArgs e</span>)</span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (fileDic == <span class=\"hljs-literal\">null</span>)<br>    &#123;<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">//自定义函数，获取文件在服务器中的路径</span><br>    <span class=\"hljs-built_in\">string</span> serverPath = ServerFTP.CreateFilePathInServerBySQLPath(gridView_FileViewer.GetFocusedDataRow()[<span class=\"hljs-string\">&quot;path&quot;</span>].ToString());<br>    <span class=\"hljs-comment\">//获取文件名</span><br>    <span class=\"hljs-built_in\">string</span> fileName = gridView_FileViewer.GetFocusedDataRow()[<span class=\"hljs-string\">&quot;file&quot;</span>].ToString();<br>    <span class=\"hljs-comment\">//根据路径将文件下载到本地，并返回文件路径</span><br>    <span class=\"hljs-built_in\">string</span> savePath = ServerFTP.currentMode.RequestFile(serverPath,fileName,GeneralLib.FTPDownloadStyle.CACHE);<br>    <span class=\"hljs-keyword\">if</span> (savePath != <span class=\"hljs-string\">&quot;&quot;</span>)<br>    &#123;<br>        <span class=\"hljs-comment\">//调用系统软件打开文件</span><br>        FileIO.OpenFileInWindows(savePath);<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这里挑几个比较重要的函数讲解</p>\n<p><strong>RequestFile</strong></p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c#\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">string</span> <span class=\"hljs-title\">RequestFile</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">string</span> serverPath,<span class=\"hljs-built_in\">string</span> fileName, FTPDownloadStyle style</span>)</span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-built_in\">string</span> savePath = <span class=\"hljs-string\">&quot;&quot;</span>;<br>    <span class=\"hljs-keyword\">switch</span> (style)<br>    &#123;<br>        <span class=\"hljs-comment\">//下载文件到缓存临时文件夹，用于预览</span><br>        <span class=\"hljs-keyword\">case</span> FTPDownloadStyle.CACHE:<br>            savePath = Path.Combine(ServerFTP.cachePath, fileName);<br>            <span class=\"hljs-keyword\">break</span>;<br>        <span class=\"hljs-comment\">//下载文件到所选的文件夹，用于下载</span><br>        <span class=\"hljs-keyword\">case</span> FTPDownloadStyle.CHOOSEDIC:<br>            savePath = FileIO.ChooseSaveFile(fileName, <span class=\"hljs-string\">&quot;&quot;</span>, ServerFTP.chooseTempDic);       <br>            <span class=\"hljs-comment\">//保存所选的文件夹，以便下次打开直接进入相应目录</span><br>            ServerFTP.chooseTempDic = Path.GetDirectoryName(savePath);<br>            <span class=\"hljs-keyword\">break</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (savePath == <span class=\"hljs-literal\">null</span>)<br>    &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&quot;</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">//判断目录是否存在</span><br>    <span class=\"hljs-keyword\">if</span> (!Directory.Exists(Path.GetDirectoryName(savePath)))<br>    &#123;<br>        <span class=\"hljs-comment\">//如果不存在则创建目录</span><br>        Directory.CreateDirectory(Path.GetDirectoryName(savePath));<br>    &#125;<br><br>\t<span class=\"hljs-comment\">//根据文件路径创建FPT连接实例</span><br>    FtpWebRequest ftp = (FtpWebRequest)WebRequest.Create(serverPath);<br>    <span class=\"hljs-comment\">//从配置文件中读取登录项</span><br>    ICredentials credentials = <span class=\"hljs-keyword\">new</span> NetworkCredential(Config.Get[<span class=\"hljs-string\">&quot;ftp_username&quot;</span>], Config.Get[<span class=\"hljs-string\">&quot;ftp_password&quot;</span>]);<br>    <span class=\"hljs-comment\">//配置FPT服务器登录项</span><br>    ftp.Credentials = credentials；<br>    <span class=\"hljs-comment\">//配置FPT操作为下载文件</span><br>    ftp.Method = WebRequestMethods.Ftp.DownloadFile;<br>\t<span class=\"hljs-comment\">//向FPT服务器发出操作请求</span><br>    FtpWebResponse response = (FtpWebResponse)ftp.GetResponse();<br>    <span class=\"hljs-comment\">//创建流缓冲区接收FPT服务器反馈的字节流</span><br>    Stream responseStream = response.GetResponseStream();<br>    <span class=\"hljs-comment\">//根据存储路径在本地创建文件</span><br>    FileStream fs = File.Create(savePath);<br>    <span class=\"hljs-comment\">//创建用于批量取缓冲区字节数据的数据</span><br>    <span class=\"hljs-built_in\">byte</span>[] buffer = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">byte</span>[ConstLib.BUFFER_SIZE];<br>    <span class=\"hljs-built_in\">int</span> read = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">do</span><br>    &#123;<br>        <span class=\"hljs-comment\">//将缓冲区的字节数据读入字节数组</span><br>        read = responseStream.Read(buffer, <span class=\"hljs-number\">0</span>, buffer.Length);<br>        <span class=\"hljs-comment\">//将字节数组的数据写入到文件中</span><br>        fs.Write(buffer, <span class=\"hljs-number\">0</span>, read);<br>        <span class=\"hljs-comment\">//清楚fs的流缓冲区，这里fs的流缓冲区与responseStream流缓冲区不是同一个缓冲区，需要注意</span><br>        fs.Flush();<br>    &#125;<br>    <span class=\"hljs-keyword\">while</span> (read != <span class=\"hljs-number\">0</span>)；<br>        <br>    fs.Flush();<br>    <span class=\"hljs-comment\">//关闭文件</span><br>    fs.Close();<br>    <br>    <span class=\"hljs-keyword\">return</span> savePath;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>OpenFileInWindows</strong></p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C#\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Process <span class=\"hljs-title\">OpenFileInWindows</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">string</span> filePath</span>)</span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//创建一个新的进程</span><br>    ProcessStartInfo info = <span class=\"hljs-keyword\">new</span> ProcessStartInfo();<br>    <span class=\"hljs-comment\">//设置进程要打开的文档，Windows会根据文件类型的默认开打应用来启动对应应用程序来打开文件</span><br>    info.FileName = Path.GetFileName(filePath);<br>    <span class=\"hljs-comment\">//设置启动进程的初始目录</span><br>    info.WorkingDirectory = Path.GetDirectoryName(filePath);<br>    <span class=\"hljs-comment\">//设置进程启动后，窗口的状态，可以设置为最大化，最小化和正常</span><br>    info.WindowStyle = ProcessWindowStyle.Normal;<br>    <span class=\"hljs-comment\">//启动进程</span><br>    Process proc = Process.Start(info);<br><br>    <span class=\"hljs-keyword\">return</span> proc;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>当关闭文件时清楚临时文件夹的内容</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c#\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">CleanCacheDirectory</span>(<span class=\"hljs-params\"></span>)</span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//判断临时文件夹是否存在</span><br>    <span class=\"hljs-keyword\">if</span> (!Directory.Exists(ServerFTP.cachePath))<br>    &#123;<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">try</span><br>    &#123;<br>        <span class=\"hljs-comment\">//等待系统将占用文件的进程杀死再清空临时文件夹</span><br>        System.Threading.Thread.Sleep(<span class=\"hljs-number\">500</span>);<br>        <span class=\"hljs-comment\">//获取临时文件夹目录信息</span><br>        DirectoryInfo dicInfo = <span class=\"hljs-keyword\">new</span> DirectoryInfo(ServerFTP.cachePath);<br>        <span class=\"hljs-comment\">//直接删除临时文件夹</span><br>        dicInfo.Delete(<span class=\"hljs-literal\">true</span>);<br>    &#125;<br>    catch<br>    &#123;<br>        <span class=\"hljs-comment\">//如果目录被其他进程占用，则暂时不清空临时文件夹</span><br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这里我使用的是最简单的直接删除临时文件夹的暴力删除法，这样做会有一个问题就是，在程序删除文件夹的时候，可能预览文件的进程还没有被系统杀死或有其他的进程占用了目录中文件，这都会导致目录删除失败而抛出异常，我的解决方案是在删除目录之前等待500ms，等待系统将预览文件的进程杀死后在删除文件夹，但是如果是其他的进程占用了目录，则需要手动结束进程才能继续删除临时文件夹，我的解决方案是，如果有其他进程占用了目录，则本次本次临时缓冲区先不删除，等下次有机会再删除。所以这里的try-catch不是用来抛出异常的，而是用来推出函数的。</p>\n<p>当然比较理想的删除方法是遍历整个目录中文件和子文件夹，依次删除目录下文件和子文件夹，有被其他进程占用的文件暂时不删除。这样就可以只留下被占用的文件，而不是整个目录。</p>\n<h2 id=\"五、单元格添加按钮并添加自定义点击事件\"><a href=\"#五、单元格添加按钮并添加自定义点击事件\" class=\"headerlink\" title=\"五、单元格添加按钮并添加自定义点击事件\"></a>五、单元格添加按钮并添加自定义点击事件</h2><p>有时我们需要向某一列的单元格添加点击事件，甚至向某一个单元格添加点击事件，这时我们就需要向单元格添加按钮了。</p>\n<h3 id=\"1-向单元格添加简单的点击事件\"><a href=\"#1-向单元格添加简单的点击事件\" class=\"headerlink\" title=\"1.向单元格添加简单的点击事件\"></a>1.向单元格添加简单的点击事件</h3><p>如果我们只想在某一单元格添加简单的点击事件</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C#\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">gridView_JobPlacement_RowCellClick</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">object</span> sender, RowCellClickEventArgs e</span>)</span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (e.RowHandle == <span class=\"hljs-number\">1</span> &amp;&amp; e.Column.FieldName == <span class=\"hljs-string\">&quot;filename&quot;</span>)<br>    &#123;<br>        <span class=\"hljs-keyword\">if</span> (e.Button == MouseButtons.Left)<br>        &#123;<br>            <span class=\"hljs-comment\">//todo</span><br>        &#125;<br>        <span class=\"hljs-keyword\">if</span> (e.Button == MouseButtons.Right)<br>        &#123;<br>\t\t\t<span class=\"hljs-comment\">//todo</span><br>        &#125;<br>        <span class=\"hljs-keyword\">if</span>(e.Button == MouseButtons.Moddle)<br>        &#123;<br>            <span class=\"hljs-comment\">//todo</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这时我们需要用到RowCellClick事件，RowCellClick事件在鼠标点击单元格时触发，然后我们只需要判定鼠标点击是哪一行哪一列，就可以实现某一个单元格的点击事件了。当然我们也可以通过添加按钮来实现。</p>\n<h3 id=\"2-向单元格添加复杂点击事件\"><a href=\"#2-向单元格添加复杂点击事件\" class=\"headerlink\" title=\"2.向单元格添加复杂点击事件\"></a>2.向单元格添加复杂点击事件</h3><p>如果我们想向单元格添加一系列复杂的点击事件，如在某一单元格内做文件的上传，预览，下载，删除等操作，这时我们就需要借助模板列了，使用模板列是无法只向某一个单元添加点击事件的，因为模板列挂载的是一整列。</p>\n<p>我需要用到模板列<code>RepositoryItemButtonEdit</code>，我可以在列属性里静态挂载，也可以在代码中动态挂载，重要的是我们需要用到<code>RepositoryItemButtonEdit</code>属性里的<code>Buttons</code>属性，向Buttons属性里添加元素。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090945.png\"></p>\n<p>光是添加按钮单元中还是看不到按钮的，我们还需要将每个按钮的Kind属性设置为Glyph，这样我们才能在单元格中看到按钮</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090950.png\"></p>\n<p>添加完按钮就可以向对应按钮添加点击事件了，我们可以发现在列属性里找不到事件，所以我们需要在代码中为按钮添加点击事件，这时我们需要用到<code>repositoryItemButtonEdit.Buttons[0].Click</code>，其中repositoryItemButtonEdit是模板列的名字，Buttons[0]是第一个按钮的引用，我们只需要向Click事件添加我们想要执行的函数即可。</p>\n<h2 id=\"六、GridView数据导出到Excel\"><a href=\"#六、GridView数据导出到Excel\" class=\"headerlink\" title=\"六、GridView数据导出到Excel\"></a>六、GridView数据导出到Excel</h2><p> GridView的数据要导出到Excel有很多种方法，可以最直接的就是遍历GridView，然后将数据写入Excel，这算是比较麻烦的做法了，事实上Dev已经提供了一些便捷的方法。</p>\n<h3 id=\"1-GetAllFilteredAndSortedRows-方法\"><a href=\"#1-GetAllFilteredAndSortedRows-方法\" class=\"headerlink\" title=\"1.GetAllFilteredAndSortedRows()方法\"></a>1.GetAllFilteredAndSortedRows()方法</h3><p>Dev提供了一个<code>GridView.DataController.GetAllFilteredAndSortedRows()</code>方法，可以用于提取GridView当前数据，在筛选排序等操作之后更改了的数据也可以提取。</p>\n<p><font color=\"red\"> 但是，GridView类中的DataController对象在VS中被隐藏了，即通过提示器是找不到GDataController对象的的，只能通过手写调用。</font></p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090957.png\"></p>\n<p>GetAllFilteredAndSortedRows()方法返回的是一个IList泛型列表，数据写入Excel一就要自己手动写入，写入方法：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C#\"><span class=\"hljs-comment\">//需要包含的引用</span><br><span class=\"hljs-keyword\">using</span> DevExpress.XtraSpreadsheet;<br><span class=\"hljs-keyword\">using</span> DevExpress.Spreadsheet;<br><br>SpreadsheetControl ss = <span class=\"hljs-keyword\">new</span> SpreadsheetControl();<br><span class=\"hljs-keyword\">var</span> book = ss.Document;<br>Worksheet sheet = book.Worksheets[<span class=\"hljs-number\">0</span>];<br>sheet.Import(table, <span class=\"hljs-literal\">true</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>);<span class=\"hljs-comment\">//table是DataTable类型，也是要导出到Excel的数据</span><br></code></pre></td></tr></table></figure>\n<p><font color=\"red\"> 其中有一点需要格外注意，在使用Import函数时需要引用<code>DevExpress.Docs</code>程序集，因为Import函数在这个程序集里，Dev在DevExpress.Docs程序集里给Worksheet的父类ExternalWorksheet写了扩展，也就是扩展了Import函数等，其中DevExpress.Docs程序集和DevExpress.Spreadsheet程序集的命名空间是一样的，如果没有搞清楚这一点很容易产生玄学问题🥴</font></p>\n<h3 id=\"2-GridView-Export-方法\"><a href=\"#2-GridView-Export-方法\" class=\"headerlink\" title=\"2.GridView.Export()方法\"></a>2.GridView.Export()方法</h3><p>最简单的方法就是使用Dev官方提供的导出方法GridView.Export().</p>\n<p>Dev已经在GridView中添加了官方的Export方法，支持多种导出格式：</p>\n<ul>\n<li>Xls</li>\n<li>Xlsx</li>\n<li>Html</li>\n<li>Mht</li>\n<li>Pdf</li>\n<li>Text</li>\n<li>Rtf</li>\n<li>Csv</li>\n<li>Image</li>\n<li>Docx</li>\n</ul>\n<p>同时提供三种重载：</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326091003.png\"></p>\n<p>使用方法也很简单：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C#\"><span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span><br><span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> 将GridView中的数据导出到Excel</span><br><span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span><br><span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;fileName&quot;&gt;</span><span class=\"hljs-doctag\">&lt;/param&gt;</span></span><br><span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;view&quot;&gt;</span><span class=\"hljs-doctag\">&lt;/param&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ExportExcel</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">string</span> fileName, GridView view</span>)</span><br><span class=\"hljs-function\"></span>&#123;<br>    SaveFileDialog sfd = <span class=\"hljs-keyword\">new</span> SaveFileDialog();<br>    sfd.Title = <span class=\"hljs-string\">&quot;另存为&quot;</span>;<br>    sfd.InitialDirectory = <span class=\"hljs-string\">&quot;C:\\\\&quot;</span>;<br>    sfd.Filter = <span class=\"hljs-string\">&quot;Excel文件(*.xlsx) | *.xlsx&quot;</span>;<br>    sfd.FileName = fileName;<span class=\"hljs-comment\">//fileName文件名不需要包含后缀</span><br>    <span class=\"hljs-keyword\">if</span> (sfd.ShowDialog() == DialogResult.OK)<br>    &#123;<br>        view.Export(DevExpress.XtraPrinting.ExportTarget.Xlsx, sfd.FileName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>view.Export是dev自带的导出方法，在导出文件后dev会自动调用系统对此文件的默认打开应用来打开文件，当然dev也提供内置的预览方法，这在下一节导出word模板中使用。</li>\n</ul>\n<h2 id=\"七、向Word模板中写入数据\"><a href=\"#七、向Word模板中写入数据\" class=\"headerlink\" title=\"七、向Word模板中写入数据\"></a>七、向Word模板中写入数据</h2><h3 id=\"1-载入word模板文件\"><a href=\"#1-载入word模板文件\" class=\"headerlink\" title=\"1.载入word模板文件\"></a>1.载入word模板文件</h3><p>向word模板中写入数据我这里主要使用的是<font color=\"red\">RichEditControl</font>类，RichEditControl类提供海量的富文本API接口，这里主要讲解使用到的API。</p>\n<p>首先打开word文档，RichEditControl类提供RichEditControl.LoadDocument(string path)方法加载文档，RichEditControl类也提供多个LoadDocument函数的重载给予各种文件的加载形式，我这里使用的是直接通过文件路径加载文档。LoadDocument函数支持DOC、DOCX、RTP、HTM、HTML、MHT、XML和EPUB类型的文档，可以自动检测文档类型。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C#\">RichEditControl.LoadDocument(<span class=\"hljs-built_in\">string</span> path)<br></code></pre></td></tr></table></figure>\n<p>将文档载入内存之后就可以通过<font color=\"red\">RichEditControl.Document.Text</font>属性查看文档内容了，也可以通过RichEditControl.Document.Text属性判断文档是否加载成功。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C#\"><span class=\"hljs-keyword\">if</span>(richEditControl.Document.Text == <span class=\"hljs-literal\">null</span>)<br>&#123;<br>\t<span class=\"hljs-keyword\">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"2-向word模板的指定位置写入数据\"><a href=\"#2-向word模板的指定位置写入数据\" class=\"headerlink\" title=\"2.向word模板的指定位置写入数据\"></a>2.向word模板的指定位置写入数据</h3><p>向word模板的指定位置写入数据主要使用Word的书签和域，我这里使用的是书签，在word中想要插入数据的地方添加一个书签即可，如：</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326091009.png\"></p>\n<p>我想要在生产号、型号和图号后面的单元格写入数据，那么我只需要在这些单元中添加书签即可，添加书签的步骤：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mermaid\">graph LR;<br>将光标定位到要添加的书签的位置--&gt;插入--&gt;书签--&gt;添加一个书签名--&gt;添加<br></code></pre></td></tr></table></figure>\n<p>添加完书签时候在word上是看不到的，但是把光标定位到书签所在的位置处，插入书签时会自定定位到所插入的书签名。</p>\n<p>然后即可通过<font color=\"red\"> Document.Replace(DocumentRange range,string text)</font>函数来向书签所在位置插入数据了，其中DocumentRange类型的参数需要通过<font color=\"red\">Document.Bookmarks[string bookmarks].Range</font>来将字符串类型的书签标志转换为DocumentRange类型的可用书签标志。</p>\n<p>如：我要在生产号、型号和图号后面的单元格写入数据，那么我需要分别在这些单元格中插入书签<code>sch</code>、<code>xh</code>、<code>th</code>，然后通过下面代码即可向word模板中写入数据</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C#\">RichEditControl richEdit = <span class=\"hljs-keyword\">new</span> RichEditControl();<br>richEdit.LoadDocument(<span class=\"hljs-string\">&quot;C:/a.doc&quot;</span>);<br>Document doc = rich.Document;<br>doc.Replace(doc.Bookmarks[<span class=\"hljs-string\">&quot;sch&quot;</span>].Range,<span class=\"hljs-string\">&quot;01&quot;</span>);<br>doc.Replace(doc.Bookmarks[<span class=\"hljs-string\">&quot;xh&quot;</span>].Range,<span class=\"hljs-string\">&quot;02&quot;</span>);<br>doc.Replace(doc.Bookmarks[<span class=\"hljs-string\">&quot;th&quot;</span>].Range,<span class=\"hljs-string\">&quot;03&quot;</span>);<br></code></pre></td></tr></table></figure>\n<p>原理就是书签提供了一个占位符，而dev则通过搜索匹配的占位符，将指定数据替换掉占位符。</p>\n<h3 id=\"3-向word模板中的表格插入新行并写入内容\"><a href=\"#3-向word模板中的表格插入新行并写入内容\" class=\"headerlink\" title=\"3.向word模板中的表格插入新行并写入内容\"></a>3.向word模板中的表格插入新行并写入内容</h3><p>向word模板中的表格插入新行则稍微复杂一些。主要步骤如下：</p>\n<ul>\n<li><p>首先word文档中要有一个模板表格</p>\n</li>\n<li><p>需要在要插入表的位置添加书签table</p>\n</li>\n<li><p>遍历word文档中所有的表再遍历每一个表中所有的单元格，查找到书签所在的单元格</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c#\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> TableCell <span class=\"hljs-title\">GetTableCell</span>(<span class=\"hljs-params\">Document document</span>) </span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//遍历文档中所有的表</span><br>    <span class=\"hljs-keyword\">foreach</span> (Table table <span class=\"hljs-keyword\">in</span> document.Tables)<br>    &#123;<br>        <span class=\"hljs-built_in\">int</span> row = <span class=\"hljs-number\">0</span>, col = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-built_in\">bool</span> ok = <span class=\"hljs-literal\">false</span>;<br>        TableCell retCell = <span class=\"hljs-literal\">null</span>;<br>\t\t<span class=\"hljs-comment\">//遍历表格中所有的单元格</span><br>        table.ForEachCell((cell, rowIndex, columnIndex) =&gt;<br>                          &#123;<br>                              <span class=\"hljs-keyword\">if</span> (cell.Range.Contains(document.Bookmarks[<span class=\"hljs-string\">&quot;table&quot;</span>].Range.Start))<br>                              &#123;<br>                                  row = rowIndex;<br>                                  col = columnIndex;<br>                                  retCell = cell;<br>                                  ok = <span class=\"hljs-literal\">true</span>;<br>                              &#125;<br>                          &#125;);<br>        <span class=\"hljs-keyword\">if</span> (ok)<br>        &#123;<br>            <span class=\"hljs-keyword\">return</span> retCell;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>\n<p><font color=\"red\">Table.ForEachCell(TableCellProcessorDelegate cellProcessor)</font>函数传入的是一个委托。这里使用的是匿名方法</p>\n</li>\n<li><p>在指定单元格后新增行</p>\n<p>可以使用<font color=\"red\">Document.Tables[int index].Rows.Append()</font>函数在表的最后追加行，或使用<font color=\"red\"> Document.Tables[int index].Rows.InsertAfter(int rowIndex)</font>函数在指定行之后插入行。其中Document.Tables[int index].Rows.Append()中index（表的索引）可以通过<font color=\"red\"> Document.Tables.IndexOf(Table table)</font>函数获取，而table又可以同通过上一步查找到的TableCell对象retCell.Table属性获取。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c#\">RichEditControl richEdit = <span class=\"hljs-keyword\">new</span> RichEditControl();<br>richEdit.LoadDocument(<span class=\"hljs-string\">&quot;C:/a.doc&quot;</span>);<br>Document doc = rich.Document;<br>TableCell cell = GetTableCell(doc);<br>doc.BeginUpdate();<br><span class=\"hljs-built_in\">int</span> index = doc.Tables.IndexOf(cell.Table);<br>doc.Tables[index].Rows.Append();<span class=\"hljs-comment\">//或者</span><br><span class=\"hljs-comment\">//doc.Table[index].Rows.InsertAfter(cell.Row.Index - 1);</span><br><span class=\"hljs-comment\">//获取指定单元格的占位符范围</span><br>DocumentRange range = doc.Tables[index].Rows[cell.Row.Index].Cells[cell.Index].ContentRange;<br>doc.Replace()<br>doc.EndUpdate();<br></code></pre></td></tr></table></figure>\n</li>\n</ul>"},{"title":"【Python】Python学习笔记","date":"2021-02-04T06:10:35.000Z","password":null,"abstract":null,"message":null,"_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n<center><font size=6><strong>Python基础</strong></font></center>\n\n<!--more-->\n\n# 一、中文编码、注释与标准文档\n\n## 1.中文编码\n\n若只需要在单个文件中指定中文编码，只需在文件开始处添加\n\n```python\n# _*_ coding: UTF-8 _*_\n```\n\n即可。\n\n如果要在整个工程里设置中文编码，则需要在编辑器中设置工程的编码为UTF-8。\n\n## 2.单行注释\n\npython使用`#`来接单行注释\n\n## 3.多行注释\n\npython使用`'''`或`\"\"\"`（三个单引号或三个双引号）来包含多行注释\n\n如：\n\n```python\n# 这是单行注释\n'''\n这是使用三个单引号的\n多行注释\n'''\n\"\"\"\n这是使用三个双引号的\n多行注释\n\"\"\"\n```\n\n## 4.标准文档\n\n[官方文档](https://docs.python.org/zh-cn/3.7/library/index.html)\n\n# 二、标识符与代码块\n\n## 1.标识符规则\n\n- python标识符大小写敏感。\n- python中以下划线开头的标识符有特殊的含义，以单下划线开头的标识符代表不能直接访问的类属性，需要通过类提供的接口进行访问，不能用from xxx import *导入，如：_value。\n- 以双下划线开头的标识符代表类的私有成员，如：`__value`。\n- 以双下划线开头和结尾的标识符代表python里特殊方法的专用标识符，如：`__init__()`代表类的构造函数。\n\n## 2.保留字符\n\n|          |         |        |\n| :------: | :-----: | :----: |\n|   and    |  exec   |  not   |\n|  assert  | finally |   or   |\n|  break   |   for   |  pass  |\n|  class   |  from   | print  |\n| continue | global  | raise  |\n|   def    |   if    | return |\n|   del    | import  |  try   |\n|   elif   |   in    | while  |\n|   else   |   is    |  with  |\n|  except  | lambda  | yield  |\n\n## 3.代码块\n\npython与C系列语言最大的不同就是python没有了`{}`囊括的代码块，而采用了<font color=red>缩进</font>来表示代码块，即在一个代码块中的代码采用同等数量的数量的缩进，缩进的数量按空格的数量计算，采用同一缩进量的代码属于同一格代码块。\n\n如：\n\n```python\nif ture:\n    a = 1\n    b = 2\n```\n\n`a=1;`与`b=2`同属于if语句的代码块中。\n\n### python空行规范\n\n- 类与其他代码块之间需要空两行\n\n- 方法体与其他代码块之间需要空一行\n\n- 全局函数与其他代码块之间需要空两行\n\n  如：\n\n  ```python\n  class Person:\n      names = 'aa'\n  \n      def __init__(self, age, name):\n          self.age = age\n          self.name = name\n          addr = 'beijing'\n          names = \"bb\"\n  \n      def GetName(self):\n          self.sex = 'female'\n          print('my name is ' + self.names)\n  \n      @staticmethod\n      def PP():\n          print(names)\n      \n      @classmethod\n      def OO(cls):       \n          print(cls.names)\n  \n  \n  p = Person(18, 'lusa')\n  ```\n\n  \n\n## 4.多行语句\n\n由于python即使用了`;`来分割同行的不同语句，同时通过新行来结束上一句语句，所以如果代码需要换行的话需要使用<font color=red> `\\`</font>来分割多行。\n\n如：\n\n```python\na = b \\\n\t+ c \\\n    + d\n```\n\n<font color=green> **例外**：包括在`[]`、`()`、`{}`中的语句换行不需要使用`\\`。</font>\n\n# 三、变量及数据结构\n\npython支持\n\n- Numbers-数字\n- String-字符串\n- List-列表\n- Tuple-原表\n- Dictionary-字典\n\n几种数据类型。\n\n## 1.Numbers\n\n其中Numbers又分为\n\n```mermaid\ngraph LR;\nNumbers---int---有符号整型;\nNumbers---long---长整型-使用小写l或大写L表示;\nNumbers---float---浮点型;\nNumbers---complex---复数-使用a+bj表示或complex函数生成;\n```\n\n需要注意的是python不支持double。\n\n<font color=red> long在python3.x以后被移除。</font>\n\n## 2.String\n<font color=red>使用Python字符串时首先需要明确一点，就是Python不支持单字符，在Python中单字符也被当作字符串使用。</font>\n\nPython的字符串可以使用`'`,`\"`,`'''`,`\"\"\"`来标识字符串，有单引号和双引号来表示字符串就够了，那么为什么Python要使用三单引号`'''`和三双引号`\"\"\"`来标识字符串呢？\n\n### `'''`和`\"\"\"`的优点\n\n要想直观的了解三单引号和三双引号的优点，我们首先使用C#字符串来写一个SQL语句\n\n```C#\nstring sql=\"select xm as 姓名,xb as 性别 from db_table where xm = @xm and xb = @xb and (bm like '%666' or bm like '666%') order by grade > 90 desc\";\nOleDbCommand cmd = new OleDbCommand();\ncmd.CommandText = sql;\ncmd.Parameters.AddWithValue(\"@xm\", txtName.Text);\ncmd.Parameters.AddWithValue(\"@xb\", txtSex.Text);\ncmd.Connection = conn;\nconn.Open();\ncmd.ExecuteNonQuery();\n```\n\n我们再使用Python写一句同样的SQL语句\n\n```Python\nsql = '''\nselect xm as 姓名,xb as 性别 from db_table \nwhere xm = '{0}' and xb = {1} and (bm like '%666' or bm like '666%') \norder by grade > 90 desc\n'''.format(txtName.Text,txtSex.Text)\ncuesor = conn.cursor()\ncursor.execute(sql)\ncursor.close()\n```\n\n有没有发现Python在写sql字符串时十分优雅呢？尤其是在写很长的sql语句时这个效果尤为突出，得益于Python三引号字符串的可换行支持，Python的sql可以在传参的同时保留sql的优雅格式，极大的提高了sql的可阅读性。\n\npython的字符串是不可变的，当我们对字符串进行操作时，python都会生成新的字符串，而不会在旧的字符串的基础上进行修改。\n\n- 与C系列语言对字符串的操作有些差异的是python使用`*`来重复字符串，如：\n\n\n```python\nstr = 'a'\nstr2 = str*2 #str2存储的是'aa'\n```\n\n- String支持从前索引和从后索引，从前索引的首地址索引为0，从后索引的末地址为-1\n\n\n|  a   |  b   |  c   |  d   |\n| :--: | :--: | :--: | :--: |\n|  0   |  1   |  2   |  3   |\n|  -4  |  -3  |  -2  |  -1  |\n\n- python支持直接通过索引截取子字符串，如：\n\n\n```python\nstr = 'abcd'\nstr2 = str[1:3] #str2存储的是'bc'\n```\n\n### 转移字符\n\n| 字符 | 说明 |\n| --- | --- |\n| `\\`(在行尾时)|续行符|\n|\\\\|\t反斜杠符号|\n|\\'|\t单引号|\n|\\\"|\t双引号|\n|\\a|\t响铃|\n|\\b|\t退格(Backspace)|\n|\\e|\t转义|\n|\\000|\t空|\n|\\n|\t换行|\n|\\v|\t纵向制表符|\n|\\t|\t横向制表符|\n|\\r|\t回车|\n|\\f|\t换页|\n|\\oyy|\t八进制数，y 代表 0~7 的字符，例如：\\012 代表换行|\n|\\xyy|十六进制数，以 \\x 开头，yy代表的字符，例如：\\x0a代表换行|\n|\\other|其它的字符以普通格式输出|\n\n### 两个特殊的字符串运算符\n\n| 字符 | 说明 | 实例 |\n| --- | --- | --- |\n|r/R| <font color=red>原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母`r`（可以大小写）以外，与普通字符串有着几乎完全相同的语法。</font> | print(r’/n’)<br />输出结果：<br />/n        |\n|%|\t格式字符串|  |\n|u| 在字符串的前面加上一个字母u即表示创建Unicode字符串，可以通过`\\u`+Unicode编码向字符串中插入任何Unicode支持的字符 | print(u’a\\u2201a’)<br />输出结果：<br />a⤀a |\n\n### 字符串格式化\n\nPython中的字符串格式化和C基本保持一致，插入整型也是用的`%d`\n\n| 符号 | 说明 |\n| --- | --- |\n| %c\t |格式化字符及其ASCII码|\n| %s\t |格式化字符串|\n| %d\t |格式化整数|\n| %u\t |格式化无符号整型|\n| %o\t |格式化无符号八进制数|\n| %x\t |格式化无符号十六进制数|\n| %X| 格式化无符号十六进制数（大写）|\n| %f\t |格式化浮点数字，可指定小数点后的精度|\n| %e\t |用科学计数法格式化浮点数|\n| %E\t |作用同%e，用科学计数法格式化浮点数|\n| %g\t |%f和%e的简写|\n| %G|\t %F 和 %E 的简写|\n| %p\t| 用十六进制数格式化变量的地址|\n\n### 格式化操作辅助指令\n\n| 符号 | 说明 |\n| --- | --- |\n|*|\t定义宽度或者小数点精度|\n|-|\t用做左对齐|\n|+|\t在正数前面显示加号( + )|\n|`<sp>`|\t在正数前面显示空格|\n|#|\t在八进制数前面显示零('0')，在十六进制前面显示'0x'或者'0X'(取决于用的是'x'还是'X')|\n|0|\t显示的数字前面填充'0'而不是默认的空格|\n|%|\t'%%'输出一个单一的'%'|\n|(var)|\t映射变量(字典参数)|\n|m.n.|\tm 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)|\n\n### String内置函数\n\n| **方法**                                                     | **描述**                                                     |\n| :----------------------------------------------------------- | :----------------------------------------------------------- |\n| [string.capitalize()](https://www.runoob.com/python/att-string-capitalize.html) | 把字符串的第一个字符大写                                     |\n| [string.center(width)](https://www.runoob.com/python/att-string-center.html) | 返回一个原字符串居中,并使用空格填充至长度 width 的新字符串   |\n| **[string.count(str, beg=0, end=len(string))](https://www.runoob.com/python/att-string-count.html)** | 返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数 |\n| [string.decode(encoding='UTF-8', errors='strict')](https://www.runoob.com/python/att-string-decode.html) | 以 encoding 指定的编码格式解码 string，如果出错默认报一个 ValueError 的 异 常 ， 除非 errors 指 定 的 是 'ignore' 或 者'replace' |\n| [string.encode(encoding='UTF-8', errors='strict')](https://www.runoob.com/python/att-string-encode.html) | 以 encoding 指定的编码格式编码 string，如果出错默认报一个ValueError 的异常，除非 errors 指定的是'ignore'或者'replace' |\n| **[string.endswith(obj, beg=0, end=len(string))](https://www.runoob.com/python/att-string-endswith.html)** | 检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False. |\n| [string.expandtabs(tabsize=8)](https://www.runoob.com/python/att-string-expandtabs.html) | 把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8。 |\n| **[string.find(str, beg=0, end=len(string))](https://www.runoob.com/python/att-string-find.html)** | 检测 str 是否包含在 string 中，如果 beg 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回-1 |\n| **[string.format()](https://www.runoob.com/python/att-string-format.html)** | 格式化字符串                                                 |\n| **[string.index(str, beg=0, end=len(string))](https://www.runoob.com/python/att-string-index.html)** | 跟find()方法一样，只不过如果str不在 string中会报一个异常.    |\n| [string.isalnum()](https://www.runoob.com/python/att-string-isalnum.html) | 如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True,否则返回 False |\n| [string.isalpha()](https://www.runoob.com/python/att-string-isalpha.html) | 如果 string 至少有一个字符并且所有字符都是字母则返回 True,否则返回 False |\n| [string.isdecimal()](https://www.runoob.com/python/att-string-isdecimal.html) | 如果 string 只包含十进制数字则返回 True 否则返回 False.      |\n| [string.isdigit()](https://www.runoob.com/python/att-string-isdigit.html) | 如果 string 只包含数字则返回 True 否则返回 False.            |\n| [string.islower()](https://www.runoob.com/python/att-string-islower.html) | 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False |\n| [string.isnumeric()](https://www.runoob.com/python/att-string-isnumeric.html) | 如果 string 中只包含数字字符，则返回 True，否则返回 False    |\n| [string.isspace()](https://www.runoob.com/python/att-string-isspace.html) | 如果 string 中只包含空格，则返回 True，否则返回 False.       |\n| [string.istitle()](https://www.runoob.com/python/att-string-istitle.html) | 如果 string 是标题化的(见 title())则返回 True，否则返回 False |\n| [string.isupper()](https://www.runoob.com/python/att-string-isupper.html) | 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False |\n| **[string.join(seq)](https://www.runoob.com/python/att-string-join.html)** | 以 string 作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串 |\n| [string.ljust(width)](https://www.runoob.com/python/att-string-ljust.html) | 返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串 |\n| [string.lower()](https://www.runoob.com/python/att-string-lower.html) | 转换 string 中所有大写字符为小写.                            |\n| [string.lstrip()](https://www.runoob.com/python/att-string-lstrip.html) | 截掉 string 左边的空格                                       |\n| [string.maketrans(intab, outtab\\])](https://www.runoob.com/python/att-string-maketrans.html) | maketrans() 方法用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。 |\n| [max(str)](https://www.runoob.com/python/att-string-max.html) | 返回字符串 *str* 中最大的字母。                              |\n| [min(str)](https://www.runoob.com/python/att-string-min.html) | 返回字符串 *str* 中最小的字母。                              |\n| **[string.partition(str)](https://www.runoob.com/python/att-string-partition.html)** | 有点像 find()和 split()的结合体,从 str 出现的第一个位置起,把 字 符 串 string 分 成 一 个 3 元 素 的 元 组 (string_pre_str,str,string_post_str),如果 string 中不包含str 则 string_pre_str == string. |\n| **[string.replace(str1, str2, num=string.count(str1))](https://www.runoob.com/python/att-string-replace.html)** | 把 string 中的 str1 替换成 str2,如果 num 指定，则替换不超过 num 次. |\n| [string.rfind(str, beg=0,end=len(string) )](https://www.runoob.com/python/att-string-rfind.html) | 类似于 find() 函数，返回字符串最后一次出现的位置，如果没有匹配项则返回 -1。 |\n| [string.rindex( str, beg=0,end=len(string))](https://www.runoob.com/python/att-string-rindex.html) | 类似于 index()，不过是从右边开始.                            |\n| [string.rjust(width)](https://www.runoob.com/python/att-string-rjust.html) | 返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串 |\n| [string.rpartition(str)](https://www.runoob.com/python/att-string-rpartition.html) | 类似于 partition()函数,不过是从右边开始查找                  |\n| [string.rstrip()](https://www.runoob.com/python/att-string-rstrip.html) | 删除 string 字符串末尾的空格.                                |\n| **[string.split(str=\"\", num=string.count(str))](https://www.runoob.com/python/att-string-split.html)** | 以 str 为分隔符切片 string，如果 num 有指定值，则仅分隔 num+ 个子字符串 |\n| [string.splitlines([keepends\\])](https://www.runoob.com/python/att-string-splitlines.html) | 按照行('\\r', '\\r\\n', \\n')分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。 |\n| [string.startswith(obj, beg=0,end=len(string))](https://www.runoob.com/python/att-string-startswith.html) | 检查字符串是否是以 obj 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查. |\n| **[string.strip([obj\\])](https://www.runoob.com/python/att-string-strip.html)** | 在 string 上执行 lstrip()和 rstrip()                         |\n| [string.swapcase()](https://www.runoob.com/python/att-string-swapcase.html) | 翻转 string 中的大小写                                       |\n| [string.title()](https://www.runoob.com/python/att-string-title.html) | 返回\"标题化\"的 string,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle()) |\n| **[string.translate(str, del=\"\")](https://www.runoob.com/python/att-string-translate.html)** | 根据 str 给出的表(包含 256 个字符)转换 string 的字符,要过滤掉的字符放到 del 参数中 |\n| [string.upper()](https://www.runoob.com/python/att-string-upper.html) | 转换 string 中的小写字母为大写                               |\n| [string.zfill(width)](https://www.runoob.com/python/att-string-zfill.html) | 返回长度为 width 的字符串，原字符串 string 右对齐，前面填充0 |\n\n## 3.Tuple\n\n==元组类似与C#中`readonly List`，是一个只读列表，但是python的元组的元素可以是不同的类型，python用`()`来表示元组。==元组支持存储不同类型元素，如：\n\n```python\nt = ('a',1,3.14)\n```\n\n这里的元组只读及元素不可修改\n\n### 创建空元组\n\n```python\nt = ()\n```\n\n### <font color=red> 创建一个值的元组</font>\n\n```python\nt = (12,)//逗号不可省略\n```\n\n<font color=red> 需要特别注意的是`,`不可省略，如果省略了，`t=(12)`就等于`t=12`</font>\n\n### 元组的分片操作\n\n```python\nt = (1,2,3,4,5,6)\nprint(t[1:3])\n#输出结果为2，3\n```\n\n分片操作可以批量的取元组中的数据，值不能取到3号索引，只能取到3号索引的前一位。\n\n### Tuple的+和*操作\n\n和字符串一样，列表的+运算用于组合列表，列表的*运算用于重复列表，如：\n\n```python\ntu1 = (1, 2)\ntu2 = tu1 + tu1\nprint(tu2)\ntu3 = tu1*3\nprint(tu3)\n```\n\n输出结果：\n\n```\n[1, 2, 1, 2]\n[1, 2, 1, 2, 1, 2]  \n```\n\n### Tuple的无关分隔符\n\n任意无符号对象，只要以`,`分隔，Python都将其是为元组，如\n\n```python\nprint 1, 2, 'a', 3.14\ntu = x, y = 1, 'b'\n```\n\n`1, 2, 'a', 3.14`，会被视为一个元组，及print打印的事实上是一个元组，tu也会被Python默认转换成一个元组，当然x，y还是可以才开使用的。\n\n### Python内置元组操作函数\n\n| 方法                                                         | 描述                   |\n| :----------------------------------------------------------- | ---------------------- |\n| [cmp(tuple1, tuple2)](https://www.runoob.com/python/att-tuple-cmp.html) | 比较两个元组元素。     |\n| [len(tuple)](https://www.runoob.com/python/att-tuple-len.html) | 计算元组元素个数。     |\n| [max(tuple)](https://www.runoob.com/python/att-tuple-max.html) | 返回元组中元素最大值。 |\n| [min(tuple)](https://www.runoob.com/python/att-tuple-min.html) | 返回元组中元素最小值。 |\n| [tuple(seq)](https://www.runoob.com/python/att-tuple-tuple.html) | 将列表转换为元组。     |\n\n## 4.List\n\nList就和C#中的List基本一致，但是python的List更灵活\n\n### List初始化\n\nList的初始化使用`[]`，我们可以使用‘数字’、‘字符串’、‘元组’或‘列表’来初始化一个列表，列表也支持分片操作。\n\npython的列表可以在一个列表中存储不同类型的元素。\n\n并且提供一些基础函数\n\n- index：从列表中找出某个元素的位置，如果有多个相同的元素，则返回第一个元素的位置，如果没有找到则抛出异常。\n\n- count：统计某个元素在列表中出现的次数。\n\n- append：列表末尾增加新的元素。\n\n- extend：将一个新列表的元素添加到原列表中。\n\n  注意到，虽然 append 和 extend 可接收一个列表作为参数，但是 append 方法是将其作为一个元素添加到列表中，而 extend 则是将新列表的元素逐个添加到原列表中。\n\n- insert：将某个元素添加到某个位置。\n\n- pop：移除列表中的一个元素（默认是最后一个），并且返回该元素的值。\n\n- remove：移除列表中的某个匹配元素，如果有多个匹配，则移除第一个。\n\n- reverse：将列表中的元素进行反转。\n\n- sort：对列表进行排序，注意该方法会改变原来的列表，而不是返回新的排序列表，另外，sort 方法的返回值是空。\n\n  如果要使用sort对列表进行排序，那么列表中元素应该保持同一类型。\n\n- clear：清空列表。\n\n### 列表的集合运算\n\nPython提供内置的`set()`函数来对元素集进行集合运算，set函数支持所有可迭代的对象，包括list和tuple。只要是set函数支持的对象，尽管进行运算的两个对象不是相同类型也依旧可以进行集合运算，如：\n\n**取交集**\n\n```python\nl1 = [1, 'a', True, 2, 3]\nl2 = (1, 'a', True, 4, 5)\nprint(set(l1) & set(l2))\n```\n\n输出结果：\n\n```python\n{1， 1, 'a'}\n```\n\n<font color=red> 注意：当bool值进行集合运算时会被转换成0和1，但是这个0和1不会和数字的0和1重复。</font>\n\nPython集合运算符\n\n| 运算符 | 说明       |\n| --- | --- |\n| \\|     | 取并集     |\n| &      | 取交集     |\n| -      | 取差集     |\n| ^      | 取对称差集 |\n\n<font color=red> 集合运算符支持`set()`函数返回的`set`集合作为运算对象。</font>\n\n### List的+和*操作\n\n和字符串一样，列表的+运算用于组合列表，列表的*运算用于重复列表，如：\n\n```python\nli = [1, 2]\nli2 = li + li\nprint(li2)\nli3 = li*3\nprint(li3)\n```\n\n输出结果：\n\n```\n[1, 2, 1, 2]\n[1, 2, 1, 2, 1, 2]  \n```\n\n### Python内置列表操作函数\n\n| 函数                                                         | 描述               |\n| :----------------------------------------------------------- | ------------------ |\n| [cmp(list1, list2)](https://www.runoob.com/python/att-list-cmp.html) | 比较两个列表的元素 |\n| [len(list)](https://www.runoob.com/python/att-list-len.html) | 列表元素个数       |\n| [max(list)](https://www.runoob.com/python/att-list-max.html) | 返回列表元素最大值 |\n| [min(list)](https://www.runoob.com/python/att-list-min.html) | 返回列表元素最小值 |\n| [list(seq)](https://www.runoob.com/python/att-list-list.html) | 将元组转换为列表   |\n\n### List内置函数\n\n| 方法                                                         | 描述                                                         |\n| :----------------------------------------------------------- | ------------------------------------------------------------ |\n| [list.append(obj)](https://www.runoob.com/python/att-list-append.html) | 在列表末尾添加新的对象                                       |\n| [list.count(obj)](https://www.runoob.com/python/att-list-count.html) | 统计某个元素在列表中出现的次数                               |\n| [list.extend(seq)](https://www.runoob.com/python/att-list-extend.html) | 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） |\n| [list.index(obj)](https://www.runoob.com/python/att-list-index.html) | 从列表中找出某个值第一个匹配项的索引位置                     |\n| [list.insert(index, obj)](https://www.runoob.com/python/att-list-insert.html) | 将对象插入列表                                               |\n| [list.pop([index=-1\\])](https://www.runoob.com/python/att-list-pop.html) | 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 |\n| [list.remove(obj)](https://www.runoob.com/python/att-list-remove.html) | 移除列表中某个值的第一个匹配项                               |\n| [list.reverse()](https://www.runoob.com/python/att-list-reverse.html) | 反向列表中元素                                               |\n| [list.sort(cmp=None, key=None, reverse=False)](https://www.runoob.com/python/att-list-sort.html) | 对原列表进行排序                                             |\n\n\n\n## 5.Dictionary\n\nPython的字典和C#中的字典的用法基本一致，不同的时Python使用`{}`来创建字典，使用`:`来连接键值对，使用`,`来分割元素。如：\n\n```python\ndic = {'a': True, 2: \"Py\", \"bb\": 3}\n```\n\nPython自定更强大的地方在于，Python字典在一个字典里支持不同类型的键和值。\n\n<font color=red> 字典的键只能是数字、字符串或元组类型，而值没有任何要求。</font>\n\n### Python内置字典操作函数\n\n| 函数                                                         | 描述                                               |\n| ------------------------------------------------------------ | -------------------------------------------------- |\n| [cmp(dict1, dict2)](https://www.runoob.com/python/att-dictionary-cmp.html) | 比较两个字典元素。                                 |\n| [len(dict)](https://www.runoob.com/python/att-dictionary-len.html) | 计算字典元素个数，即键的总数。                     |\n| [str(dict)](https://www.runoob.com/python/att-dictionary-str.html) | 输出字典可打印的字符串表示。                       |\n| [type(variable)](https://www.runoob.com/python/att-dictionary-type.html) | 返回输入的变量类型，如果变量是字典就返回字典类型。 |\n\n### Dictionary内置函数\n\n| 函数                                                         | 描述                                                         |\n| :----------------------------------------------------------- | ------------------------------------------------------------ |\n| [dict.clear()](https://www.runoob.com/python/att-dictionary-clear.html) | 删除字典内所有元素                                           |\n| [dict.copy()](https://www.runoob.com/python/att-dictionary-copy.html) | 返回一个字典的浅复制                                         |\n| [dict.fromkeys(seq[, val\\])](https://www.runoob.com/python/att-dictionary-fromkeys.html) | 创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值 |\n| [dict.get(key, default=None)](https://www.runoob.com/python/att-dictionary-get.html) | 返回指定键的值，如果值不在字典中返回default值                |\n| [dict.has_key(key)](https://www.runoob.com/python/att-dictionary-has_key.html) | 如果键在字典dict里返回true，否则返回false                    |\n| [dict.items()](https://www.runoob.com/python/att-dictionary-items.html) | 以列表返回可遍历的(键, 值) 元组数组                          |\n| [dict.keys()](https://www.runoob.com/python/att-dictionary-keys.html) | 以列表返回一个字典所有的键                                   |\n| [dict.setdefault(key, default=None)](https://www.runoob.com/python/att-dictionary-setdefault.html) | 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default |\n| [dict.update(dict2)](https://www.runoob.com/python/att-dictionary-update.html) | 把字典dict2的键/值对更新到dict里                             |\n| [dict.values()](https://www.runoob.com/python/att-dictionary-values.html) | 以列表返回字典中的所有值                                     |\n| [pop(key[,default\\])](https://www.runoob.com/python/python-att-dictionary-pop.html) | 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。 |\n| [popitem()](https://www.runoob.com/python/python-att-dictionary-popitem.html) | 返回并删除字典中的最后一对键和值。                           |\n\n## 6.日期和时间\n\nPython的日期时间函数被放在了`time`、`datetime`和`calender`模块下，这里有几个点是需要注意的\n\n### time.time()\n\ntime.time()函数返回的是从1970年1月1日午夜到当前时间所经过的总时长。\n\n```python\nimport time\nprint(time.time())\n#当前时间为：2021.2.6 09：51\n```\n\n输出结果：\n\n```python\n1612576137.817901\n```\n\n### time.localtime()\n\n那么如何输出当前时间呢？答案就是使用`time.localtime(time.time())`来计算当前时间。\n\n```python\nimport time\nprint(time.localtime(time.time()))\n```\n\n输出结果：\n\n```python\ntime.struct_time(tm_year=2021, tm_mon=2, tm_mday=6, tm_hour=9, tm_min=51, tm_sec=39, tm_wday=5, tm_yday=37, tm_isdst=0)\n```\n\n可以看到，函数返回的不是格式化的`2021.2.6 9:51`而是一个`struct_time`时间元组，什么是时间元组？\n\n### 时间元组\n\n很多Python函数用一个元组装起来的9组数字处理时间:\n\n| 序号 | 字段         | 值                                   |\n| :--- | :----------- | :----------------------------------- |\n| 0    | 4位数年      | 2008                                 |\n| 1    | 月           | 1 到 12                              |\n| 2    | 日           | 1到31                                |\n| 3    | 小时         | 0到23                                |\n| 4    | 分钟         | 0到59                                |\n| 5    | 秒           | 0到61 (60或61 是闰秒)                |\n| 6    | 一周的第几日 | 0到6 (0是周一)                       |\n| 7    | 一年的第几日 | 1到366 (儒略历)                      |\n| 8    | 夏令时       | -1, 0, 1, -1是决定是否为夏令时的旗帜 |\n\n而struct_time就是其中之一，struct_time的结构：\n\n| 序号 | 属性     | 值                                   |\n| :--- | :------- | :----------------------------------- |\n| 0    | tm_year  | 2021                                 |\n| 1    | tm_mon   | 1 到 12                              |\n| 2    | tm_mday  | 1 到 31                              |\n| 3    | tm_hour  | 0 到 23                              |\n| 4    | tm_min   | 0 到 59                              |\n| 5    | tm_sec   | 0 到 61 (60或61 是闰秒)              |\n| 6    | tm_wday  | 0到6 (0是周一)                       |\n| 7    | tm_yday  | 1 到 366(儒略历)                     |\n| 8    | tm_isdst | -1, 0, 1, -1是决定是否为夏令时的旗帜 |\n\n### 获取格式化时间\n\n那么如何获取格式化时间呢？\n\n```python\nprint(time.asctime(time.localtime(time.time())))\n```\n\n输出结果：\n\n```python\nSat Feb  6 10:28:09 2021\n```\n\ntime.localtime()返回的是一个字符串，除此之外我们看还可以使用<font color=red>`time.strftime()`</font>函数来自定义时间格式化格式，如：\n\n```python\nprint(time.strftime(\"%H:%M:%S %Y-%m-%d\", time.localtime()))\n```\n\n输出结果：\n\n```python\n10:51:12 2021-02-06\n```\n\n### 时间日期格式化符号\n\n| 符号 | 描述                                      |\n| ---- | ----------------------------------------- |\n| %y   | 两位数的年份表示（00-99）                 |\n| %Y   | 四位数的年份表示（000-9999）              |\n| %m   | 月份（01-12）                             |\n| %d   | 月内中的一天（0-31）                      |\n| %H   | 24小时制小时数（0-23）                    |\n| %I   | 12小时制小时数（01-12）                   |\n| %M   | 分钟数（00-59）                           |\n| %S   | 秒（00-59）                               |\n| %a   | 本地简化星期名称                          |\n| %A   | 本地完整星期名称                          |\n| %b   | 本地简化的月份名称                        |\n| %B   | 本地完整的月份名称                        |\n| %c   | 本地相应的日期表示和时间表示              |\n| %j   | 年内的一天（001-366）                     |\n| %p   | 本地A.M.或P.M.的等价符                    |\n| %U   | 一年中的星期数（00-53）星期天为星期的开始 |\n| %w   | 星期（0-6），星期天为星期的开始           |\n| %W   | 一年中的星期数（00-53）星期一为星期的开始 |\n| %x   | 本地相应的日期表示                        |\n| %X   | 本地相应的时间表示                        |\n| %Z   | 当前时区的名称                            |\n| %%   | %号本身                                   |\n\n### time与datetime库\n\npython处理时间处理time模块还可以使用datetime模块，那么time和datetime之间有什么区别呢？\n\n在 Python 文档里，`time`是归类在`Generic Operating System Services`中，换句话说， 它提供的功能是更加接近于操作系统层面的。通读[文档](https://docs.python.org/2.7/library/time.html)可知，time 模块是围绕着 Unix Timestamp 进行的。\n\n该模块主要包括一个类 `struct_time`，另外其他几个函数及相关常量。 需要注意的是在该模块中的大多数函数是调用了所在平台`C library`的同名函数， 所以要特别注意有些函数是平台相关的，可能会在不同的平台有不同的效果。另外一点是，由于是基于Unix Timestamp，所以其所能表述的日期范围被限定在 1970 - 2038 之间，如果你写的代码需要处理在前面所述范围之外的日期，那可能需要考虑使用`datetime`模块更好。\n\ndatetime 比 time 高级了不少，可以理解为 datetime 基于 time 进行了封装，提供了更多实用的函数。\n\n| 类        | 描述                 |\n| --------- | -------------------- |\n| timedelta | 主要用于计算时间跨度 |\n| tzinfo    | 时区相关             |\n| time      | 只关注时间           |\n| date      | 只关注日期           |\n| datetime  | 同时有时间和日期     |\n\n### calendar库\n\ncalendar库主要用于处理日历，如：打印2021年2月的日历\n\n```python\nprint(calendar.month(2021, 1))\n```\n\n输出结果：\n\n```python\n    January 2021\nMo Tu We Th Fr Sa Su\n             1  2  3\n 4  5  6  7  8  9 10\n11 12 13 14 15 16 17\n18 19 20 21 22 23 24\n25 26 27 28 29 30 31\n```\n\n### time库内置函数\n\n| 函数                                                         | 描述                                                         |\n| :----------------------------------------------------------- | :----------------------------------------------------------- |\n| [time.altzone](https://www.runoob.com/python/att-time-altzone.html) | 返回格林威治西部的夏令时地区的偏移秒数。如果该地区在格林威治东部会返回负值（如西欧，包括英国）。对夏令时启用地区才能使用。 |\n| [time.asctime([tupletime])](https://www.runoob.com/python/att-time-asctime.html) | 接受时间元组并返回一个可读的形式为\"Tue Dec 11 18:07:14 2008\"（2008年12月11日 周二18时07分14秒）的24个字符的字符串。 |\n| [time.clock( )](https://www.runoob.com/python/att-time-clock.html) | 用以浮点数计算的秒数返回当前的CPU时间。用来衡量不同程序的耗时，比time.time()更有用。 |\n| [time.ctime([secs])](https://www.runoob.com/python/att-time-ctime.html) | 作用相当于asctime(localtime(secs))，未给参数相当于asctime()  |\n| [time.gmtime([secs])](https://www.runoob.com/python/att-time-gmtime.html) | 接收时间戳（1970纪元后经过的浮点秒数）并返回格林威治天文时间下的时间元组t。注：t.tm_isdst始终为0 |\n| [time.localtime([secs])](https://www.runoob.com/python/att-time-localtime.html) | 接收时间戳（1970纪元后经过的浮点秒数）并返回当地时间下的时间元组t（t.tm_isdst可取0或1，取决于当地当时是不是夏令时）。 |\n| [time.mktime(tupletime)](https://www.runoob.com/python/att-time-mktime.html) | 接受时间元组并返回时间戳（1970纪元后经过的浮点秒数）。       |\n| [time.sleep(secs)](https://www.runoob.com/python/att-time-sleep.html) | 推迟调用线程的运行，secs指秒数。                             |\n| [time.strftime(fmt[,tupletime])](https://www.runoob.com/python/att-time-strftime.html) | 接收以时间元组，并返回以可读字符串表示的当地时间，格式由fmt决定。 |\n| [time.strptime(str,fmt='%a %b %d %H:%M:%S %Y')](https://www.runoob.com/python/att-time-strptime.html) | 根据fmt的格式把一个时间字符串解析为时间元组。                |\n| [time.time( )](https://www.runoob.com/python/att-time-time.html) | 返回当前时间的时间戳（1970纪元后经过的浮点秒数）。           |\n| [time.tzset()](https://www.runoob.com/python/att-time-tzset.html) | 根据环境变量TZ重新初始化时间相关设置。                       |\n\n### 两个time库重要属性\n\n| 属性              | 描述                                                         |\n| :---------------- | :----------------------------------------------------------- |\n| **time.timezone** | 属性 time.timezone 是当地时区（未启动夏令时）距离格林威治的偏移秒数（>0，美洲<=0大部分欧洲，亚洲，非洲）。 |\n| **time.tzname**   | 属性time.tzname包含一对根据情况的不同而不同的字符串，分别是带夏令时的本地时区名称，和不带的。 |\n\n### calendar内置函数\n\n| 函数                                     | 描述                                                         |\n| :--------------------------------------- | :----------------------------------------------------------- |\n| **calendar.calendar(year,w=2,l=1,c=6)**  | 返回一个多行字符串格式的year年年历，3个月一行，间隔距离为c。 每日宽度间隔为w字符。每行长度为21* W+18+2* C。l是每星期行数。 |\n| **calendar.firstweekday( )**             | 返回当前每周起始日期的设置。默认情况下，首次载入 calendar 模块时返回 0，即星期一。 |\n| **calendar.isleap(year)**                | 是闰年返回 True，否则为 False。`>>> import calendar >>> print(calendar.isleap(2000)) True >>> print(calendar.isleap(1900)) False` |\n| **calendar.leapdays(y1,y2)**             | 返回在Y1，Y2两年之间的闰年总数。                             |\n| **calendar.month(year,month,w=2,l=1)**   | 返回一个多行字符串格式的year年month月日历，两行标题，一周一行。每日宽度间隔为w字符。每行的长度为7* w+6。l是每星期的行数。 |\n| **calendar.monthcalendar(year,month)**   | 返回一个整数的单层嵌套列表。每个子列表装载代表一个星期的整数。Year年month月外的日期都设为0;范围内的日子都由该月第几日表示，从1开始。 |\n| **calendar.monthrange(year,month)**      | 返回两个整数。第一个是该月的星期几的日期码，第二个是该月的日期码。日从0（星期一）到6（星期日）;月从1到12。 |\n| **calendar.prcal(year,w=2,l=1,c=6)**     | 相当于 **print calendar.calendar(year,w=2,l=1,c=6)**。       |\n| **calendar.prmonth(year,month,w=2,l=1)** | 相当于 **print calendar.month(year,month,w=2,l=1)** 。       |\n| **calendar.setfirstweekday(weekday)**    | 设置每周的起始日期码。0（星期一）到6（星期日）。             |\n| **calendar.timegm(tupletime)**           | 和time.gmtime相反：接受一个时间元组形式，返回该时刻的时间戳（1970纪元后经过的浮点秒数）。 |\n| **calendar.weekday(year,month,day)**     | 返回给定日期的日期码。0（星期一）到6（星期日）。月份为 1（一月） 到 12（12月）。 |\n\n## 7.set集合\n\npython的set集合和C++的set集合的用法基本是一样的，set集合是一个无序不重复序列，python使用`{}`或`set()`函数来创建set集合，区别字典的地方是{}包括的元素不是键值对，需要注意的是，创建空集合只能通过set()函数。\n\n## 8.类型转换\n\nPython提供了大量内置类型转换函数：\n\n| 函数                                                         | 描述                                                |\n| ------------------------------------------------------------ | --------------------------------------------------- |\n| int(x [,[base])](https://www.runoob.com/python/python-func-int.html) | 将x转换为一个整数                                   |\n| long(x [,[base] )](https://www.runoob.com/python/python-func-long.html) | 将x转换为一个长整数                                 |\n| [float(x)](https://www.runoob.com/python/python-func-float.html) | 将x转换到一个浮点数                                 |\n| complex(real [[,imag])](https://www.runoob.com/python/python-func-complex.html) | 创建一个复数                                        |\n| [str(x)](https://www.runoob.com/python/python-func-str.html) | 将对象 x 转换为字符串                               |\n| [repr(x)](https://www.runoob.com/python/python-func-repr.html) | 将对象 x 转换为表达式字符串                         |\n| [eval(str)](https://www.runoob.com/python/python-func-eval.html) | 用来计算在字符串中的有效Python表达式,并返回一个对象 |\n| [tuple(s)](https://www.runoob.com/python/att-tuple-tuple.html) | 将序列 s 转换为一个元组                             |\n| [list(s)](https://www.runoob.com/python/att-list-list.html)  | 将序列 s 转换为一个列表                             |\n| [set(s)](https://www.runoob.com/python/python-func-set.html) | 转换为可变集合                                      |\n| [dict(d)](https://www.runoob.com/python/python-func-dict.html) | 创建一个字典。d 必须是一个序列 (key,value)元组。    |\n| [frozenset(s)](https://www.runoob.com/python/python-func-frozenset.html) | 转换为不可变集合                                    |\n| [chr(x)](https://www.runoob.com/python/python-func-chr.html) | 将一个整数转换为一个字符                            |\n| [unichr(x)](https://www.runoob.com/python/python-func-unichr.html) | 将一个整数转换为Unicode字符                         |\n| [ord(x)](https://www.runoob.com/python/python-func-ord.html) | 将一个字符转换为它的整数值                          |\n| [hex(x)](https://www.runoob.com/python/python-func-hex.html) | 将一个整数转换为一个十六进制字符串                  |\n| [oct(x)](https://www.runoob.com/python/python-func-oct.html) | 将一个整数转换为一个八进制字符串                    |\n\n# 四、运算符\n\n## 1.算术运算符\n\nPython的算术运算基本和C系列语言没什么区别，唯一的区别在于Python将C系列语言的求幂函数和取整函数直接内置到了Python的运算符里了，如：\n\n| 运算符 | 描述 |\n| ------- | ----- |\n| ** | 求幂运算符，二元运算符，a**b表示求a的b次幂 |\n| // |取整运算符，二元运算符，a//b表示a对b取整，如9//4 = 2 |\n\n## 2.赋值运算符\n\n和算数运算符一样，Python也将求幂运算和取整运算的赋值运算内置到运算符里。\n\n| 运算符 | 描述 |\n| --- | --- |\n| **= | 幂赋值运算符 |\n| //= | 取整赋值运算符 |\n\n## 3.逻辑运算符\n\n由于Python的底层是用C写的所有C的逻辑运算符（`&`,`|`,`!`）在Python中就不能再使用了，所以Python使用（`and`,`or`,`not`）来做逻辑运算符，用法和`&`,`|`,`!`一样。\n\n## 4.成员运算符\n\n和前面一样，Python也将判断函数直接内置到运算符中了，Python成员运算符作用就是判断指定序列中是否包含某个指定元素，序列支持字符串，列表和元组。\n\n|  |  |\n| --- | --- |\n| in | 如果指定元素在指定序列中则返回True |\n| not in | 如果指定元素不在指定序列中则返回True |\n\n\n```\nli = [1,2,3,4,5]\ntu = (1,2,3,4,5)\nst = “12345”\na = 1\nb = ‘1’\nprint(a in li)\nprint(a not in tu)\nprint(b in st)\n```\n返回结果：\n\n```\nTrue\nFalse\nTrue\n```\n\n## 5.身份运算符\n\n| | |\n| --- | --- |\n| is | 判断两个对象是否来自同一引用|\n| is not | 判断两个对象是否不同的引用|\n\nPyhton的身份运算符和C#的is是不一样的，Python的is用于判断两个对象是否来引用同一引用，而C#的is则是判断某一对象是否是指定类型。\n\n使用案例：\n\n```\na  = 1\nb = a\nprint(a is b)\nb = 2\nprint(a is not b)\nc = 2\nprint(b is c)\n```\n输出结果：\n\n```\nTrue\nTrue\nTrue\n```\n\n这里出现了一个疑问，为什么b和c来自同一引用呢？\n我们查看一下b和c的内存地址\n\n```\nprint(id(b))\nprint(id(c))\n```\n输出结果：\n\n```\n2324527120200\n2324527120200\n```\n可以看到b和c指向了同一内存地址，原来Python在对程序优化的时候会将程序中的内容相同的常量存储到一个存储地址中。\n\n# 五、控制语句\n\nPython的条件语句与C系列语言最大的不同是，Python的条件语句可以不使用`()`来包含条件表达式，当然也可以是使用，大多数情况下还是建议使用（），以使代码的阅读性更高。\n\n## 1.if语句\n\n当条if-else语句的用法和C系列基本一致。\n\n```\nif True:\n\ta=1\n\tb=1\nelse:\n\ta=2\n\tb=2\n```\n\n<font color=red> 其中`:`是必须的</font>\nPython中比较特殊的是else if语句，在Python中使用<font color=red> elif</font>表示。\n\n## 2.while循环语句\n\nPython的while循环可以搭配esle使用，当循环跳出时执行else语句，个人感觉没什么实际用处。\n\n```\na = 0\nwhile a<3:\n\tprint(a)\n\ta += 1\nelse:\n\tprint(“循环结束”)\n```\n输出结果：\n\n```\n0\n1\n2\n循环结束\n```\n\n## 3.for循环\n\n<font color=red> 在写循环语句之前有一点是需要明确的，及根据Python的设计理念Python已经不使用自增`++`自减`--`运算符了，所以需要自增时应使用`a += 1`</font>\n\n### for in\n\nfor in的用法和C#的foreach一致，可以遍历任何序列，如：\n\n```\nli = [1,2,3,4,5]\nfor item in li:\n\tprint(item)\nelse：\n\tprint(“for end”)\n```\n\n和while一样for也可以配合else使用\n\n### for in range()\n\nfor in range()就是不同的for循环，通过下标来遍历序列，如：\n\n```\nli = [1,2,3,4,5]\nfor i in range(len(li)):\n\tprint(li[i])\nelse:\n\tprint(“for end”)\n```\n<font color=red> 需要注意实际上for in中是不包含range()的，range只是一个辅助函数，用于确定下标的范围。如果我们直接像下面那样写是会报语法错误的，如：</font>\n\n```\nfor i in 4:\n\t#code\n```\n如果我们想让循环只跑4轮，应该用range(4)来确定下标范围，如：\n\n```\nfor i in range(4):\n```\n\n### continue、break和pass\n\nPython的continue和break的用法和C系列语言基本一致，Python中新增了pass语句，pass语句就是C系列语言中`;`及空语句，一般用于空循环中维护代码的结构性。\n\n# 六、函数\n\n## 1.函数定义\n\n- 函数代码块以 **def** 关键词开头，后接函数标识符名称和圆括号**()**。\n- 任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。\n- <font color=red>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</font>\n- 函数内容以冒号起始，并且缩进。\n- **return [表达式]** 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。\n\n如：\n\n```python\ndef fun(a):\n    \"打印a的平方并返回\"\n    b = a*a\n    print(b)\n    return b\n```\n\n## 2.函数调用\n\n<font color=red> 在调用Python函数时有一点是需要特别注意的，由于Python是解释型语言，Python脚本在运行时是一行一行地放入解释器中进行解释的，因此Pyhton不支持函数的声明定义的分离，所有Python的函数调用必须在定义之后，否则将会报函数未定义。</font>\n\n## 3.参数传递\n\n在讨论函数参数之前，我们需要了解两个概念：\n\n- 不可变对象：不可变对象都是不可变类型，<font color=red>Python的不可变类型有数字、字符串、元组</font>，不可变对象指向的内存地址上的内容是不可更改的，如需操作其内容Python会开辟一个新的内存地址来存储编辑后的内容。\n\n- 可变对象：可变对象都是可变类型，不是不可变类型的类型都是可变类型，包括列表、字典、自定义类型等，可变类型对象指向的内存地址的内容是可更改，操作可变对象的内容时Python不会开辟新的内存，而是直接修改原地址内容。\n\n<font color=red>函数传入不可变对象的原理和C++的传值原理是一样的，函数传入可变对象的原理和C++传址原理是一样的。</font>\n\n### 传参原理\n\n由于Python的变量都是若类型的，参数也不例外，函数在定义参数时只有名字没有类型，所以Python在调用函数时，参数的传递是根据实参的顺序来给形参赋值的。\n\n### 关键字参数\n\nPython的函数支持关键字传参，关键字传参的原理是指定实参来赋值指定形参，所以可以无视参数的传入顺序。如：\n\n```python\ndef fun(a,b,c):\n    print(a+b+c)\nfun(b = 1,c = 2,a = 3)\n```\n\n### 默认参数\n\nPython的函数也支持默认参数，原理和C++一样。\n\n### 单*号不定长参数\n\nPython的不定长参数和C++则有些不同，Python使用`*`来标识不定长参数，所有形参匹配之外的参数都将存储到不定长参数中，如：\n\n```python\ndef fun(a,b,*c):\n    d = a + b\n    for item in c:\n        d += item\n    print(d)\nfun(1,2,3,4)\n```\n\n在这个过程中，1被赋予a，2被赋予b，3和4被赋予c\n\nPython支持不定长参数的单独使用，如：\n\n```python\ndef fun(*param):\n    pass\n```\n\n如果函数的参数只有一个不定长参数，那么函数传入的任何参数都会存储到不定长参数里。\n\n<font color = red> 单`*`号不定长参数会将传入的所有参数封装在一个元组里，且单`*`号不定长参数只支持参数的顺序传入，不支持关键字传入。</font>\n\n当函数只有单`*`号不定长参数时，单`*`号不定长参数因该放在最后一个参数，如果不放在最后将会报错：\n\n```python\ndef fun(*c, t):\n    c[0][0] = 5\n    print(c[0])\n    print(t)\n```\n\n报错：\n\n```python\nTraceback (most recent call last):\n  File \"d:\\Codes\\Python\\MyFirstPython.py\", line 9, in <module>\n    fun(li, 2)\nTypeError: fun() missing 1 required keyword-only argument: 't'\n```\n\n### 双*号不定长参数\n\n除了单`*`号不定长参数外，Python还支持双`*`号不定长参数，<font color=red> 双`*`号不定长参数支持关键字传入，不支持顺序传入，双`*`号不定长参数会将传入的参数封装在一个字典里，其中关键字的名字存入字典的键中，关键字的值存入字典的值中。</font>如：\n\n```python\ndef fun(t,**d):\n    print(t)\n    print(d['x'])\n    print(d['y'])\nfun(1,x=2,y=3)\n```\n\n输出结果：\n\n```python\n1\n2\n3\n```\n\n当函数中同时存在单`*`号不定长参数和双`*`号不定长参数时，双`*`号不定长参数应放在最后一个参数位置，单`*`号参数应放在倒数第二个参数位置。\n\n## 4.匿名函数\n\nPython的匿名函数的使用场景是，当函数体只由比较简单的Lambda表达式组成时才使用。匿名函数除了没有函数名，其他的和有名函数没有什么区别。如：\n\n```python\nf = lambda a,b=1: a+b\nprint(f(1))\n```\n\n输出结果：\n\n```python\n2\n```\n\n在lambda表达式的结构中，`:`之前的为参数，`:`号之后有且只有一条语句，这是由Python语句分割的方式决定的。从上面的例子我们还可以发现，lambda表达式支持默认参数，且自带返回值，lambda表达式将表达式的结果作为返回值，需要注意的是，lambda表达式中不能进行复制操作，否则将报语法错误。\n\n# 七、模块\n\n一个Python文件就是一个Python模块，一个Python包也是一个Python模块。\n\n## 1.导入模块（包）\n\n### 整模块导入\n\nPython使用`import`+`模块名`来导入模块，如：\n\n```python\nimport MyFirstPython\n```\n\n当我们将一个Python作为模块导入到另一个文件时，Python会在工程文件夹下的`__pycache`文件夹下生成一个模块名对应的`pyc`文件，如上面的例子则会生成一个`PyFirstPython.cpython-39.pyc`其中cpython-39为python版本号，这个文件是做什么用的呢？pyc文件是一个二进制文件，且已经经过Python加密，直接打开会显示乱码，pyc的主要作用就是加快模块的导入速度，注意这里是导入速度而非运行速度，pyc文件可以通过反编译器重新反编译成可执行的Python文件。\n\npython支持使用`,`来分割模块，达到同时导入多个包的目的，如：\n\n```python\nimport MyfirstPython,MySecondPython\n```\n\n### 单函数导入\n\npython除了支持整个文件的模块导入，同时也支持只导入模块中的一个函数，python使用`from 模块名 import 函数名`来从指定模块导入单个函数，如：\n\n```python\nfrom MySecondPython import fun as f\n```\n\n同时，python在导入模块或模块中的函数时可以使用`as`关键字为模块或函数起别名。\n\nform import还可以使用`*`来达到import的效果，如：\n\n```python\nfrom MyFirstPython import * #相当于import MyFirstPython\n```\n\n### python导入模块时的路径搜索顺序\n\n- 1、当前目录\n- 2、如果不在当前目录，Python 则搜索在 shell 变量 PYTHONPATH 下的每个目录。\n- 3、如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/。\n\n### python使用导入模块的全局变量\n\n有一点十分不方便的就是在当前文件下无法直接使用导入模块的全局变量，只能通过为指定变量编写读写函数才能操作全局变量，这是由python的变量规则决定的。\n\n### Pyhton模块打包\n\nPython提供了多个打包工具，我使用的是python3.9内置的`setuptools`库，setuptools库中提供了一个setup函数用于打包模块，具体操作如下：\n\n- 1.在工程目录下新建一个setup.py文件，这个文件用于配置一些包的必要信息，配置信息都由关键字参数的形式传入setup函数中，具体参数信息如下;\n\n  ```python\n  setup(\n      name=about[\"__title__\"],  # 包名称\n      version=about[\"__version__\"],  # 包版本\n      description=about[\"__description__\"],  # 包详细描述\n      long_description=readme,   # 长描述，通常是readme，打包到PiPy需要\n      author=about[\"__author__\"],  # 作者名称\n      author_email=about[\"__author_email__\"],  # 作者邮箱\n      url=about[\"__url__\"],   # 项目官网\n      packages=packages,    # 项目需要的包\n      data_files=file_data,   # 打包时需要打包的数据文件，如图片，配置文件等\n      include_package_data=True,  # 是否需要导入静态数据文件\n      python_requires=\">=3.0, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3*\",  # Python版本依赖\n      install_requires=requires,  # 第三方库依赖\n      zip_safe=False,  # 此项需要，否则卸载时报windows error\n      classifiers=[    # 程序的所属分类列表\n          'Development Status :: 5 - Production/Stable',\n          'Intended Audience :: Developers',\n          'Natural Language :: English',\n          'Programming Language :: Python',\n          'Programming Language :: Python :: 3',\n          'Programming Language :: Python :: 3.4',\n          'Programming Language :: Python :: 3.5',\n          'Programming Language :: Python :: 3.6',\n          'Programming Language :: Python :: 3.7',\n          'Programming Language :: Python :: Implementation :: CPython',\n          'Programming Language :: Python :: Implementation :: PyPy'\n      ],\n  )\n  ```\n\n  当然这里面所有的参数都不是非必须，如果我们一个参数都不传入，则pyhton会生成一个名为`UNKNOW-0.0.0.tar.gz`的包。\n\n- 2.使用cmd进入setup.py所在目录，使用`python setup.py sdist`命令之后，python会在此目录下生成一个`dist`目录和一个`包名.egg-info`目录，包名及setup函数中name指定的名称，为命名则为UNKNOWN.egg-info，这个文件夹下是一些包的详细信息文件。\n\n如此包便打包完成了，这中间踩了一写坑，记录一下：\n\n使用python setup.py sdist命令无反应，然后使用python -v发现也不输出python版信息，此时打开此电脑/属性/高级系统设置/高级/环境变量，发现path中都以存在python目录，可是使用python -v就是无反应。\n\n解决方案：在cmd下使用`set PATH=Python完成目录;%PATH%`，不知道为什么需要使用命令行配置一下系统环境才行。\n\n当然不同的打包工具，打包过程略有不同，这里就详细展开了。\n\n# 八、Python的内置函数\n\n## 1.数学函数\n\n| 函数| 描述 |\n| --- | --- |\n| [abs()](https://www.runoob.com/python/func-number-abs.html) | 返回数字的绝对值，如abs(-10) 返回 10 |\n| [cmp()](https://www.runoob.com/python/func-number-cmp.html) | 如果 x < y 返回 -1, 如果 x == y 返回 0, 如果 x > y 返回 1 |\n| [max()](https://www.runoob.com/python/func-number-max.html) | 返回给定参数的最大值，参数可以为序列 |\n| [min()](https://www.runoob.com/python/func-number-min.html) | 返回给定参数的最小值，参数可以为序列 |\n| [pow()](https://www.runoob.com/python/func-number-pow.html) | x^y 运算后的值，及求x的y次幂 |\n| [round(x [,n])](https://www.runoob.com/python/func-number-round.html) | 返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数 |\n| [sum()](https://www.runoob.com/python/python-func-sum.html) | 对序列求和 |\n| [round()](https://www.runoob.com/python/func-number-round.html) | 返回浮点数x的四舍五入值 |\n## 5.反射函数\n\n| 函数                                                         | 描述                                                         |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| [dir()](https://www.runoob.com/python/python-func-dir.html)  | dir函数返回一个包含了一个模块里所定义的所有模块、变量和函数，dir函数只是列出名称，无其他实际意义，其中以`__`开头的是模块相关的默认属性，如：`__name__`指向模块的名字，`__file__`指向模块文件的名字，dir函数可以传入模块名称，则输出的是模块相关的信息，如果不传入参数则输出当前作用域的相关信息 |\n| [globals()](https://www.runoob.com/python/python-func-globals.html) | 在函数内使用则返回一个包含该函数能访问的所有全局名字的字典，在函数外使用效果和在函数内使用一样 |\n| [locals()](https://www.runoob.com/python/python-func-locals.html) | 在函数内使用则返回一个包含该函数内的全部局部名字的字典，在函数外使用效果和globals()函数一样 |\n| [callable()](https://www.runoob.com/python/python-func-callable.html) | 检查一个对象是否是可调用的。如果返回 True，object 仍然可能调用失败；但如果返回 False，调用对象 object 绝对不会成功。 |\n\n## 6.类型转换函数\n\n| 函数                                                         | 描述                                                         |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| [bool()](https://www.runoob.com/python/python-func-bool.html) | 将对象转换为bool类型，对于空元组和空列表将转换为false        |\n| [float()](https://www.runoob.com/python/python-func-float.html) | 在python中没有double类型，python的float精度就已经达到了double的精度 |\n| [int()](https://www.runoob.com/python/python-func-int.html)  | 转整型                                                       |\n| [long()](https://www.runoob.com/python/python-func-long.html) | 转长整型                                                     |\n| [str()](https://www.runoob.com/python/python-func-str.html)  | 将对象转换成字符串，支持任何对象                             |\n| [eval()](https://www.runoob.com/python/python-func-eval.html) | eval函数可以用来做字符串转列表、元组和字典等，如：`a = eval('[1,2]')`、`b = eval('(1,2)')`，a是一个列表，b是一个元组，其中字典需要注意的是要使用纯字符串，如：`c = eavl(r\"{'a':1,'b':2}\")`，c就是一个字典了，除此之外，eval函数还可以用来运行字符串命令，如：`eval('bool(1)')`，输出为`True` |\n| [list()](https://www.runoob.com/python/att-list-list.html)   | 将可迭代序列(包括元组，字符串，字典等)转换成列表，如：字符串转列表`a = list('abc')`则a列表内容为`['a','b','c']`、字典转列表则会返回一个key值列表 |\n| [tuple()](https://www.runoob.com/python/att-tuple-tuple.html) | 将可迭代序列(包括元组，字符串，字典等)转换成元组，如：字符串转元组`a = tuple('abc')`则a列表内容为`('a','b','c')`、字典转元组则会返回一个key值元组 |\n| [dict()](https://www.runoob.com/python/python-func-dict.html) | dict函数支持三种转换形式，其一使用关键字的形式，关键字名称为键，关键字的值为值，如：`a=dict(a=1,b=1)`则a就是字典`{'a':1,'b':2}`，其二使用zip函数的形式，zip函数将两个可迭代序列按位置打包成二元元组，dict函数则将二元元组的第一个元素作为键，第二个元素作为值创建字典，如：`a=dict(zip(['a','b'],[1,2]))`，其中zip函数返回值为`[('a',1),('b',2)]`，dict函数返回值为`{'a':1,'b':2}`，其三使用可迭代对象的形式，如：`a=dict([('a',1),('b':2)])`其中可迭代对象可以是任何子成员为二元序列的对象 |\n| [chr()](https://www.runoob.com/python/python-func-chr.html)  | 将数字转换成对应的字符                                       |\n\n\n\n## 6.其他内置函数\n\n详情见[菜鸟教程](https://www.runoob.com/python/python-built-in-functions.html)\n\n# 九、文件IO\n\n## 1.标准输出\n\nprint()在终端打印，这里需要注意的是python3已经不支持`print 'aa'`这种打印方式了。\n\n## 2.标准输入\n\ninput()从终端输入，有时我们会看到row_input函数或input函数接收python表达式的标准输入，这些都是ptrhon2的标准输入函数和输入特性，在python3中python只保留了一个input函数作为标准输入，且input函数不在支持python表达式的输入，而是把所有的输入当作是字符串。\n\n## 3.文件读写\n\npython的文件读写通过内置类型`file`类型来进行操作，而file类型对象的创建需要通过内置函数`open`来创建。\n\n### open函数\n\n```python\nopen(file_name ,access_mode, buffering)\n```\n\n- file_name：文件路径\n\n- access_mode：打开模式，默认为只读，具体模式如下：\n\n  | 字符  | 含义                             |\n  | :---- | :------------------------------- |\n  | `'r'` | 读取（默认）                     |\n  | `'w'` | 写入，并先截断文件               |\n  | `'x'` | 排它性创建，如果文件已存在则失败 |\n  | `'a'` | 写入，如果文件存在则在末尾追加   |\n  | `'b'` | 二进制模式                       |\n  | `'t'` | 文本模式（默认）                 |\n  | `'+'` | 更新磁盘文件（读取并写入）       |\n\n  python3以后删除了很多打开模式，只保留了上面几种，所以如果在python3环境中使用`+`打开模式就会报错。\n\n- buffering：是否寄存行，可选参数，具体取值如下：\n\n  | 取值 | 描述                                                    |\n  | ---- | ------------------------------------------------------- |\n  | 0    | 取0，不寄存行                                           |\n  | 1    | 取1，寄存行                                             |\n  | >1   | 取大于1的值，寄存行，且设置寄存区的缓冲大小为当前值     |\n  | <0   | 取小于0的值，寄存行，且设置寄存区的缓冲大小为系统默认值 |\n\n- 返回值：open函数打开文件，读取文件内容到内存并一个可操作文件的file类型对象。\n\n### file类型对象内置函数\n\n| 序号                                                         | 方法及描述                                                   |\n| :----------------------------------------------------------- | :----------------------------------------------------------- |\n| [file.close()](https://www.runoob.com/python3/python3-file-close.html) | 关闭文件。关闭后文件不能再进行读写操作。                     |\n| [file.flush()](https://www.runoob.com/python3/python3-file-flush.html) | 刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。 |\n| [file.fileno()](https://www.runoob.com/python3/python3-file-fileno.html) | 返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。 |\n| [file.isatty()](https://www.runoob.com/python3/python3-file-isatty.html) | 如果文件连接到一个终端设备返回 True，否则返回 False。        |\n| [file.read([size])](https://www.runoob.com/python3/python3-file-read.html) | 从文件读取指定的字节数，如果未给定或为负则读取所有。         |\n| [file.readline([size])](https://www.runoob.com/python3/python3-file-readline.html) | 读取整行，包括 \"\\n\" 字符。                                   |\n| [file.readlines([sizeint])](https://www.runoob.com/python3/python3-file-readlines.html) | 读取所有行并返回列表，若给定sizeint>0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。 |\n| [file.seek(offset[, whence])](https://www.runoob.com/python3/python3-file-seek.html) | 移动文件读取指针到指定位置                                   |\n| [file.tell()](https://www.runoob.com/python3/python3-file-tell.html) | 返回文件当前位置。                                           |\n| [file.truncate([size])](https://www.runoob.com/python3/python3-file-truncate.html) | 从文件的首行首字符开始截断，截断文件为 size 个字符，无 size 表示从当前位置截断；截断之后后面的所有字符被删除，其中 windows 系统下的换行代表2个字符大小。 |\n| [file.write(str)](https://www.runoob.com/python3/python3-file-write.html) | 将字符串写入文件，返回的是写入的字符长度。                   |\n| [file.writelines(sequence)](https://www.runoob.com/python3/python3-file-writelines.html) | 向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。 |\n\n### file类型对象内置属性\n\n| 属性           | 描述                                                         |\n| :------------- | :----------------------------------------------------------- |\n| file.closed    | 返回true如果文件已被关闭，否则返回false。                    |\n| file.mode      | 返回被打开文件的访问模式。                                   |\n| file.name      | 返回文件的名称。                                             |\n| file.softspace | 如果用print输出后，必须跟一个空格符，则返回false。否则返回true。 |\n\n## 4.文件及目录操作\n\n这里的文件操作不是对文件的内容进行增删改操作而是在文件级别进行重命名删除设置权限等操作，对文件做这些操作需要用到`os`模块，os模块提供大量的函数对文件进行操作，文件数量过多这里就不贴出来了，具体见菜鸟教程：\n\n[os文件操作函数](https://www.runoob.com/python/os-file-methods.html)\n\n# 十、异常\n\n## 1.异常处理语句\n\nPython的异常处理语句是`try/except`，需要监测异常的代码放在`try:`块下，在异常发生后需要执行的代码放在`except:`块下，except后可以接异常类型也可以不接，如：\n\n```python\ntry:\n    a = 1/0\nexcept ZeroDivisionError:\n    print('0不可以做除数')\nelse:\n    print('没有异常')\nfinally:\n    print('有没有异常都会执行')\n```\n\n可以看到，和条件语句一样try/except语句也可以接else分支，else分支在没有异常发生时执行。、\n\n## 2.抛出异常\n\npython使用`raise`语句来抛出异常，需要注意的是，raise必须抛出一个异常类，如：\n\n```python\ntry:\n    a = 1/0\nexcept ZeroDivisionError:\n    raise ZeroDivisionError('0不可以做除数')\n```\n\n\n\n## 3.标准异常\n\n| 异常名称                  | 描述                                               |\n| :------------------------ | :------------------------------------------------- |\n| BaseException             | 所有异常的基类                                     |\n| SystemExit                | 解释器请求退出                                     |\n| KeyboardInterrupt         | 用户中断执行(通常是输入^C)                         |\n| Exception                 | 常规错误的基类                                     |\n| StopIteration             | 迭代器没有更多的值                                 |\n| GeneratorExit             | 生成器(generator)发生异常来通知退出                |\n| StandardError             | 所有的内建标准异常的基类                           |\n| ArithmeticError           | 所有数值计算错误的基类                             |\n| FloatingPointError        | 浮点计算错误                                       |\n| OverflowError             | 数值运算超出最大限制                               |\n| ZeroDivisionError         | 除(或取模)零 (所有数据类型)                        |\n| AssertionError            | 断言语句失败                                       |\n| AttributeError            | 对象没有这个属性                                   |\n| EOFError                  | 没有内建输入,到达EOF 标记                          |\n| EnvironmentError          | 操作系统错误的基类                                 |\n| IOError                   | 输入/输出操作失败                                  |\n| OSError                   | 操作系统错误                                       |\n| WindowsError              | 系统调用失败                                       |\n| ImportError               | 导入模块/对象失败                                  |\n| LookupError               | 无效数据查询的基类                                 |\n| IndexError                | 序列中没有此索引(index)                            |\n| KeyError                  | 映射中没有这个键                                   |\n| MemoryError               | 内存溢出错误(对于Python 解释器不是致命的)          |\n| NameError                 | 未声明/初始化对象 (没有属性)                       |\n| UnboundLocalError         | 访问未初始化的本地变量                             |\n| ReferenceError            | 弱引用(Weak reference)试图访问已经垃圾回收了的对象 |\n| RuntimeError              | 一般的运行时错误                                   |\n| NotImplementedError       | 尚未实现的方法                                     |\n| SyntaxError               | Python 语法错误                                    |\n| IndentationError          | 缩进错误                                           |\n| TabError                  | Tab 和空格混用                                     |\n| SystemError               | 一般的解释器系统错误                               |\n| TypeError                 | 对类型无效的操作                                   |\n| ValueError                | 传入无效的参数                                     |\n| UnicodeError              | Unicode 相关的错误                                 |\n| UnicodeDecodeError        | Unicode 解码时的错误                               |\n| UnicodeEncodeError        | Unicode 编码时错误                                 |\n| UnicodeTranslateError     | Unicode 转换时错误                                 |\n| Warning                   | 警告的基类                                         |\n| DeprecationWarning        | 关于被弃用的特征的警告                             |\n| FutureWarning             | 关于构造将来语义会有改变的警告                     |\n| OverflowWarning           | 旧的关于自动提升为长整型(long)的警告               |\n| PendingDeprecationWarning | 关于特性将会被废弃的警告                           |\n| RuntimeWarning            | 可疑的运行时行为(runtime behavior)的警告           |\n| SyntaxWarning             | 可疑的语法的警告                                   |\n| UserWarning               | 用户代码生成的警告                                 |\n\n## 4.自定义异常\n\npython的自定义异常只需要将自定义异常类继承自python标准异常类即可。\n\n# 十一、面向对象\n\npython在设计之初就已经是一门面向对象的语言了，在python中一切皆对象，包括所有的基础类型也是对象，这使得python在创建类和对象时十分容易，但是这也导致python十分消耗内存空间，因为哪怕只创建一个整型也会消耗对于C语言的内存空间。\n\n## 1.定义类\n\n和大多数语言一样，python也使用`class`关键字来标识类，使用同等量的缩进来标识类的范围，如：\n\n```python\nclass Person:\n    age = 0\n    name = ''\n    __id = 1\n    _sex = 'female'\n\n    def __init__(self, age, name):\n        self.age = age\n        self.name = name\n\n    def GetName(this):\n        print('my name is ' + this.name)\n    \n    def __SetId():\n        id = 001\n\n\np = Person(18, 'lusa')\np.GetName()\n```\n\n## 2.成员变量\n\n### 私有成员变量\n\n由于python无法使用public，private等关键字，所以python使用双下划线开头来标识私有成员变量。如上面代码中的`__id`。\n\n### 保护成员变量\n\npython使用单下划线开头来标识保护成员变量，如上面代码中的`_sex`。\n\n### 公有成员变量\n\n不带有任何前缀的变量的就是公有成员变量。\n\n\n\n## 3.成员函数\n\n### 私有函数、保护函数和公有函数\n\n和变量一样，python使用双下划线来前缀来标识私有函数，用单下划线前缀来标识保护函数，无前缀函数表示公有函数。\n\n### self参数\n\n<font color =red>与其他语言不同的是，python的函数都必须带有一个self参数，self参数的在效果上与C++的this指针很像，但是python的self参数不是类自带的，在定义函数时需要手动显示表示，且必须放在函数的第一个参数位置，self参数的名字不一定非得叫self也可以叫其他的名字，如上面代码中的GetName函数的this，但是按照python的规范建议将都是用self命名，self参数指向当前类实例，类的实例变量都必须使用self参数才能访问，直接使用是无法访问的，如：</font>\n\n```python\nclass Person:\n    age = 0\n\n    def __init__(self, param):\n        age = param\n```\n\n不通过self参数访问类的成员变量将直接报语法错误。\n\n## 4.类变量、实例变量和局部变量\n\n### 类变量\n\n定义在类的内部且定义在方法体外的变量，如上面代码中age，<font color=red>类变量可以被类直接访问，也可以被实例直接访问，同时可以被实例方法和类方法方法访问，但是不可以被静态方法访问</font>。如：\n\n```python\nclass Person:\n    names = 'aa'\n\n    def __init__(self, age, name):\n        self.age = age\n        self.name = name\n        addr = 'beijing'\n        names = \"bb\"\n\n    def GetName(self):\n        self.sex = 'female'\n        print('my name is ' + self.names)\n\n    @staticmethod\n    def PP():\n        print(names)\n    \n    @classmethod\n    def OO(cls):       \n        print(cls.names)\n\n\np = Person(18, \"lusa\")\nprint(p.names)\np.names = \"cc\"\np.GetName()\nprint(Person.names)\nPerson.names = \"dd\"\nPerson.OO()\nprint(p.names)\nPerson.PP()\n```\n\n输出结果：\n\n```python\naa\nmy name is cc\naa\ndd\ncc\nTraceback (most recent call last):\n  File \"d:\\Codes\\Python\\MyFirstPython.py\", line 31, in <module>\n    Person.PP()\n  File \"d:\\Codes\\Python\\MyFirstPython.py\", line 16, in PP\n    print(names)\nNameError: name 'names' is not definedd\n```\n\n可以看到，类变量names初始值为aa，我们的本意是在构造函数中再赋值bb但是再实际输出中names的值依旧是aa，当我们使用实例给类变量names赋值为cc时，输出GetName函数输出就变为了cc，然而直接通过类名访问的结果依旧是aa，当我们通过类名赋值names为dd时，类方法输出的结果就变为了dd，然而用实例访问的结果依旧时cc，最终运行到类的静态方法PP处则报错了，由上结果可得出结论：\n\n- 类在创建实例时会拷贝一份类变量到实例中，实例中类变量和类中的类变量互相独立\n- 构造函数不可以初始化类变量，当我们在构造函数初始化一个类变量的同名变量时，实际上python初始化的是一个和类变量同名的局部变量\n- 同一个类变量既可以被类实例访问也可以被类名直接访问，但二者内存地址时两个内存地址\n- 静态方法不可以访问类变量\n\n### 实例变量\n\n实例变量是定义在构造函数内部且通过self引出的变量，这两点十分重要，如果一个变量不是在构造函数里创建即使通过self引出也依旧不是实例变量，或一个变量在构造函数中创建但不是由self引出，那它也不是实例变量，而是函数的局部变量，如：上面代码中self.sex，和构造函数里的addr和names，我们是不可以使用实例访问的。\n\n### 局部变量\n\n在构造函数中创建的不由self引出的变量或在其他方法中创建的变量，如上面代码中GetName啊哈桑农户里的self.sex和构造函数里的addr和names\n\n## 5.类方法、实例方法和静态方法\n\n被`@classmethod`修饰的方法就是类方法，被`@staticmethod`修饰的方法就是静态方法，除此之外其余的方法都是实例方法。类方法和静态方法也有保护级。\n\n### 类方法\n\n类方法属于类，可以直接通过类型访问，也可以同通过实例访问，访问效果是一样的。在创建类方法时必须至少需要一个参数，一般命名为`cls`，用于python传递默认参数–类。如：\n\n```python\n@classmethod\ndef OO(cls):\n    print(cls.names)\n```\n\ncls不可省略，在类方法中只能通过cls来访问类变量，且只能访问类变量。\n\n### 静态方法\n\n静态方法同类方法很相似，也可以被类名和实例直接访问。不同的是，静态方法不需要cls参数，python不会传递默认参数到静态方法，静态方法不可以直接访问类的任何成员。\n\n### 嵌套函数\n\npython支持方法中嵌套创建方法，如：\n\n```python\ndef funa():\n    a = 1\n    print(a)\n\n    def funb():\n        nonlocal a\n        a += 1\n        print(a)\n   \n    funb()\n\n\nfuna()\n```\n\n# 十二、作用域\n\npython的作用域大部分与C系列语言的作用域差不多，只是有三点比较特殊：\n\n- python中只有类、函数、模块才会引入新的作用域，控制语句不会引入新的作用域，也就是说，在控制语句中创建的变量可以在控制语句外部被访问\n\n  如：\n\n  ```python\n  for i in range(3):\n      print(i)\n  \n  print(i)\n  ```\n\n  输出结果：\n\n  ```python\n  0\n  1\n  2\n  2\n  ```\n\n- 如果要在函数内部访问全局变量需要在在函数内部使用`global`申明，否则python将创建一个同名的局部变量而不是引用全局变量\n\n  如：\n\n  ```python\n  a = 1\n  \n  \n  def fun():\n      a += 1\n  ```\n\n  python会直接报语法错误，因为我们使用了一个未定义的局部变量，但是当我们使用global申明之后，我们访问的就是全局变量了，如：\n\n  ```python\n  a = 1\n  \n  \n  def fun():\n      global a\n      a += 1\n  ```\n\n- 如果要在嵌套函数中访问外层函数的变量需要使用`nonlocal`申明，否则python也会创建一个同名的局部函数，如：\n\n  ```python\n  a = 1\n  \n  \n  def fun():\n      global a\n      a += 1\n      b = 2\n  \n      def funb():\n          global a\n          nonlocal b\n          b += 1\n          print(a)\n          print(b)\n  \n      funb()\n  \n  \n  fun()\n  ```\n\n  输出结果：\n\n  ```python\n  2\n  3\n  ```\n\n  \n\n","source":"_posts/【Python】Python学习笔记.md","raw":"---\ntitle: 【Python】Python学习笔记\ndate: 2021-02-04 14:10:35\ntags: Python\ncategories: 学习笔记\npassword:\nabstract:\nmessage:\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n<center><font size=6><strong>Python基础</strong></font></center>\n\n<!--more-->\n\n# 一、中文编码、注释与标准文档\n\n## 1.中文编码\n\n若只需要在单个文件中指定中文编码，只需在文件开始处添加\n\n```python\n# _*_ coding: UTF-8 _*_\n```\n\n即可。\n\n如果要在整个工程里设置中文编码，则需要在编辑器中设置工程的编码为UTF-8。\n\n## 2.单行注释\n\npython使用`#`来接单行注释\n\n## 3.多行注释\n\npython使用`'''`或`\"\"\"`（三个单引号或三个双引号）来包含多行注释\n\n如：\n\n```python\n# 这是单行注释\n'''\n这是使用三个单引号的\n多行注释\n'''\n\"\"\"\n这是使用三个双引号的\n多行注释\n\"\"\"\n```\n\n## 4.标准文档\n\n[官方文档](https://docs.python.org/zh-cn/3.7/library/index.html)\n\n# 二、标识符与代码块\n\n## 1.标识符规则\n\n- python标识符大小写敏感。\n- python中以下划线开头的标识符有特殊的含义，以单下划线开头的标识符代表不能直接访问的类属性，需要通过类提供的接口进行访问，不能用from xxx import *导入，如：_value。\n- 以双下划线开头的标识符代表类的私有成员，如：`__value`。\n- 以双下划线开头和结尾的标识符代表python里特殊方法的专用标识符，如：`__init__()`代表类的构造函数。\n\n## 2.保留字符\n\n|          |         |        |\n| :------: | :-----: | :----: |\n|   and    |  exec   |  not   |\n|  assert  | finally |   or   |\n|  break   |   for   |  pass  |\n|  class   |  from   | print  |\n| continue | global  | raise  |\n|   def    |   if    | return |\n|   del    | import  |  try   |\n|   elif   |   in    | while  |\n|   else   |   is    |  with  |\n|  except  | lambda  | yield  |\n\n## 3.代码块\n\npython与C系列语言最大的不同就是python没有了`{}`囊括的代码块，而采用了<font color=red>缩进</font>来表示代码块，即在一个代码块中的代码采用同等数量的数量的缩进，缩进的数量按空格的数量计算，采用同一缩进量的代码属于同一格代码块。\n\n如：\n\n```python\nif ture:\n    a = 1\n    b = 2\n```\n\n`a=1;`与`b=2`同属于if语句的代码块中。\n\n### python空行规范\n\n- 类与其他代码块之间需要空两行\n\n- 方法体与其他代码块之间需要空一行\n\n- 全局函数与其他代码块之间需要空两行\n\n  如：\n\n  ```python\n  class Person:\n      names = 'aa'\n  \n      def __init__(self, age, name):\n          self.age = age\n          self.name = name\n          addr = 'beijing'\n          names = \"bb\"\n  \n      def GetName(self):\n          self.sex = 'female'\n          print('my name is ' + self.names)\n  \n      @staticmethod\n      def PP():\n          print(names)\n      \n      @classmethod\n      def OO(cls):       \n          print(cls.names)\n  \n  \n  p = Person(18, 'lusa')\n  ```\n\n  \n\n## 4.多行语句\n\n由于python即使用了`;`来分割同行的不同语句，同时通过新行来结束上一句语句，所以如果代码需要换行的话需要使用<font color=red> `\\`</font>来分割多行。\n\n如：\n\n```python\na = b \\\n\t+ c \\\n    + d\n```\n\n<font color=green> **例外**：包括在`[]`、`()`、`{}`中的语句换行不需要使用`\\`。</font>\n\n# 三、变量及数据结构\n\npython支持\n\n- Numbers-数字\n- String-字符串\n- List-列表\n- Tuple-原表\n- Dictionary-字典\n\n几种数据类型。\n\n## 1.Numbers\n\n其中Numbers又分为\n\n```mermaid\ngraph LR;\nNumbers---int---有符号整型;\nNumbers---long---长整型-使用小写l或大写L表示;\nNumbers---float---浮点型;\nNumbers---complex---复数-使用a+bj表示或complex函数生成;\n```\n\n需要注意的是python不支持double。\n\n<font color=red> long在python3.x以后被移除。</font>\n\n## 2.String\n<font color=red>使用Python字符串时首先需要明确一点，就是Python不支持单字符，在Python中单字符也被当作字符串使用。</font>\n\nPython的字符串可以使用`'`,`\"`,`'''`,`\"\"\"`来标识字符串，有单引号和双引号来表示字符串就够了，那么为什么Python要使用三单引号`'''`和三双引号`\"\"\"`来标识字符串呢？\n\n### `'''`和`\"\"\"`的优点\n\n要想直观的了解三单引号和三双引号的优点，我们首先使用C#字符串来写一个SQL语句\n\n```C#\nstring sql=\"select xm as 姓名,xb as 性别 from db_table where xm = @xm and xb = @xb and (bm like '%666' or bm like '666%') order by grade > 90 desc\";\nOleDbCommand cmd = new OleDbCommand();\ncmd.CommandText = sql;\ncmd.Parameters.AddWithValue(\"@xm\", txtName.Text);\ncmd.Parameters.AddWithValue(\"@xb\", txtSex.Text);\ncmd.Connection = conn;\nconn.Open();\ncmd.ExecuteNonQuery();\n```\n\n我们再使用Python写一句同样的SQL语句\n\n```Python\nsql = '''\nselect xm as 姓名,xb as 性别 from db_table \nwhere xm = '{0}' and xb = {1} and (bm like '%666' or bm like '666%') \norder by grade > 90 desc\n'''.format(txtName.Text,txtSex.Text)\ncuesor = conn.cursor()\ncursor.execute(sql)\ncursor.close()\n```\n\n有没有发现Python在写sql字符串时十分优雅呢？尤其是在写很长的sql语句时这个效果尤为突出，得益于Python三引号字符串的可换行支持，Python的sql可以在传参的同时保留sql的优雅格式，极大的提高了sql的可阅读性。\n\npython的字符串是不可变的，当我们对字符串进行操作时，python都会生成新的字符串，而不会在旧的字符串的基础上进行修改。\n\n- 与C系列语言对字符串的操作有些差异的是python使用`*`来重复字符串，如：\n\n\n```python\nstr = 'a'\nstr2 = str*2 #str2存储的是'aa'\n```\n\n- String支持从前索引和从后索引，从前索引的首地址索引为0，从后索引的末地址为-1\n\n\n|  a   |  b   |  c   |  d   |\n| :--: | :--: | :--: | :--: |\n|  0   |  1   |  2   |  3   |\n|  -4  |  -3  |  -2  |  -1  |\n\n- python支持直接通过索引截取子字符串，如：\n\n\n```python\nstr = 'abcd'\nstr2 = str[1:3] #str2存储的是'bc'\n```\n\n### 转移字符\n\n| 字符 | 说明 |\n| --- | --- |\n| `\\`(在行尾时)|续行符|\n|\\\\|\t反斜杠符号|\n|\\'|\t单引号|\n|\\\"|\t双引号|\n|\\a|\t响铃|\n|\\b|\t退格(Backspace)|\n|\\e|\t转义|\n|\\000|\t空|\n|\\n|\t换行|\n|\\v|\t纵向制表符|\n|\\t|\t横向制表符|\n|\\r|\t回车|\n|\\f|\t换页|\n|\\oyy|\t八进制数，y 代表 0~7 的字符，例如：\\012 代表换行|\n|\\xyy|十六进制数，以 \\x 开头，yy代表的字符，例如：\\x0a代表换行|\n|\\other|其它的字符以普通格式输出|\n\n### 两个特殊的字符串运算符\n\n| 字符 | 说明 | 实例 |\n| --- | --- | --- |\n|r/R| <font color=red>原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母`r`（可以大小写）以外，与普通字符串有着几乎完全相同的语法。</font> | print(r’/n’)<br />输出结果：<br />/n        |\n|%|\t格式字符串|  |\n|u| 在字符串的前面加上一个字母u即表示创建Unicode字符串，可以通过`\\u`+Unicode编码向字符串中插入任何Unicode支持的字符 | print(u’a\\u2201a’)<br />输出结果：<br />a⤀a |\n\n### 字符串格式化\n\nPython中的字符串格式化和C基本保持一致，插入整型也是用的`%d`\n\n| 符号 | 说明 |\n| --- | --- |\n| %c\t |格式化字符及其ASCII码|\n| %s\t |格式化字符串|\n| %d\t |格式化整数|\n| %u\t |格式化无符号整型|\n| %o\t |格式化无符号八进制数|\n| %x\t |格式化无符号十六进制数|\n| %X| 格式化无符号十六进制数（大写）|\n| %f\t |格式化浮点数字，可指定小数点后的精度|\n| %e\t |用科学计数法格式化浮点数|\n| %E\t |作用同%e，用科学计数法格式化浮点数|\n| %g\t |%f和%e的简写|\n| %G|\t %F 和 %E 的简写|\n| %p\t| 用十六进制数格式化变量的地址|\n\n### 格式化操作辅助指令\n\n| 符号 | 说明 |\n| --- | --- |\n|*|\t定义宽度或者小数点精度|\n|-|\t用做左对齐|\n|+|\t在正数前面显示加号( + )|\n|`<sp>`|\t在正数前面显示空格|\n|#|\t在八进制数前面显示零('0')，在十六进制前面显示'0x'或者'0X'(取决于用的是'x'还是'X')|\n|0|\t显示的数字前面填充'0'而不是默认的空格|\n|%|\t'%%'输出一个单一的'%'|\n|(var)|\t映射变量(字典参数)|\n|m.n.|\tm 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)|\n\n### String内置函数\n\n| **方法**                                                     | **描述**                                                     |\n| :----------------------------------------------------------- | :----------------------------------------------------------- |\n| [string.capitalize()](https://www.runoob.com/python/att-string-capitalize.html) | 把字符串的第一个字符大写                                     |\n| [string.center(width)](https://www.runoob.com/python/att-string-center.html) | 返回一个原字符串居中,并使用空格填充至长度 width 的新字符串   |\n| **[string.count(str, beg=0, end=len(string))](https://www.runoob.com/python/att-string-count.html)** | 返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数 |\n| [string.decode(encoding='UTF-8', errors='strict')](https://www.runoob.com/python/att-string-decode.html) | 以 encoding 指定的编码格式解码 string，如果出错默认报一个 ValueError 的 异 常 ， 除非 errors 指 定 的 是 'ignore' 或 者'replace' |\n| [string.encode(encoding='UTF-8', errors='strict')](https://www.runoob.com/python/att-string-encode.html) | 以 encoding 指定的编码格式编码 string，如果出错默认报一个ValueError 的异常，除非 errors 指定的是'ignore'或者'replace' |\n| **[string.endswith(obj, beg=0, end=len(string))](https://www.runoob.com/python/att-string-endswith.html)** | 检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False. |\n| [string.expandtabs(tabsize=8)](https://www.runoob.com/python/att-string-expandtabs.html) | 把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8。 |\n| **[string.find(str, beg=0, end=len(string))](https://www.runoob.com/python/att-string-find.html)** | 检测 str 是否包含在 string 中，如果 beg 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回-1 |\n| **[string.format()](https://www.runoob.com/python/att-string-format.html)** | 格式化字符串                                                 |\n| **[string.index(str, beg=0, end=len(string))](https://www.runoob.com/python/att-string-index.html)** | 跟find()方法一样，只不过如果str不在 string中会报一个异常.    |\n| [string.isalnum()](https://www.runoob.com/python/att-string-isalnum.html) | 如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True,否则返回 False |\n| [string.isalpha()](https://www.runoob.com/python/att-string-isalpha.html) | 如果 string 至少有一个字符并且所有字符都是字母则返回 True,否则返回 False |\n| [string.isdecimal()](https://www.runoob.com/python/att-string-isdecimal.html) | 如果 string 只包含十进制数字则返回 True 否则返回 False.      |\n| [string.isdigit()](https://www.runoob.com/python/att-string-isdigit.html) | 如果 string 只包含数字则返回 True 否则返回 False.            |\n| [string.islower()](https://www.runoob.com/python/att-string-islower.html) | 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False |\n| [string.isnumeric()](https://www.runoob.com/python/att-string-isnumeric.html) | 如果 string 中只包含数字字符，则返回 True，否则返回 False    |\n| [string.isspace()](https://www.runoob.com/python/att-string-isspace.html) | 如果 string 中只包含空格，则返回 True，否则返回 False.       |\n| [string.istitle()](https://www.runoob.com/python/att-string-istitle.html) | 如果 string 是标题化的(见 title())则返回 True，否则返回 False |\n| [string.isupper()](https://www.runoob.com/python/att-string-isupper.html) | 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False |\n| **[string.join(seq)](https://www.runoob.com/python/att-string-join.html)** | 以 string 作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串 |\n| [string.ljust(width)](https://www.runoob.com/python/att-string-ljust.html) | 返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串 |\n| [string.lower()](https://www.runoob.com/python/att-string-lower.html) | 转换 string 中所有大写字符为小写.                            |\n| [string.lstrip()](https://www.runoob.com/python/att-string-lstrip.html) | 截掉 string 左边的空格                                       |\n| [string.maketrans(intab, outtab\\])](https://www.runoob.com/python/att-string-maketrans.html) | maketrans() 方法用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。 |\n| [max(str)](https://www.runoob.com/python/att-string-max.html) | 返回字符串 *str* 中最大的字母。                              |\n| [min(str)](https://www.runoob.com/python/att-string-min.html) | 返回字符串 *str* 中最小的字母。                              |\n| **[string.partition(str)](https://www.runoob.com/python/att-string-partition.html)** | 有点像 find()和 split()的结合体,从 str 出现的第一个位置起,把 字 符 串 string 分 成 一 个 3 元 素 的 元 组 (string_pre_str,str,string_post_str),如果 string 中不包含str 则 string_pre_str == string. |\n| **[string.replace(str1, str2, num=string.count(str1))](https://www.runoob.com/python/att-string-replace.html)** | 把 string 中的 str1 替换成 str2,如果 num 指定，则替换不超过 num 次. |\n| [string.rfind(str, beg=0,end=len(string) )](https://www.runoob.com/python/att-string-rfind.html) | 类似于 find() 函数，返回字符串最后一次出现的位置，如果没有匹配项则返回 -1。 |\n| [string.rindex( str, beg=0,end=len(string))](https://www.runoob.com/python/att-string-rindex.html) | 类似于 index()，不过是从右边开始.                            |\n| [string.rjust(width)](https://www.runoob.com/python/att-string-rjust.html) | 返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串 |\n| [string.rpartition(str)](https://www.runoob.com/python/att-string-rpartition.html) | 类似于 partition()函数,不过是从右边开始查找                  |\n| [string.rstrip()](https://www.runoob.com/python/att-string-rstrip.html) | 删除 string 字符串末尾的空格.                                |\n| **[string.split(str=\"\", num=string.count(str))](https://www.runoob.com/python/att-string-split.html)** | 以 str 为分隔符切片 string，如果 num 有指定值，则仅分隔 num+ 个子字符串 |\n| [string.splitlines([keepends\\])](https://www.runoob.com/python/att-string-splitlines.html) | 按照行('\\r', '\\r\\n', \\n')分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。 |\n| [string.startswith(obj, beg=0,end=len(string))](https://www.runoob.com/python/att-string-startswith.html) | 检查字符串是否是以 obj 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查. |\n| **[string.strip([obj\\])](https://www.runoob.com/python/att-string-strip.html)** | 在 string 上执行 lstrip()和 rstrip()                         |\n| [string.swapcase()](https://www.runoob.com/python/att-string-swapcase.html) | 翻转 string 中的大小写                                       |\n| [string.title()](https://www.runoob.com/python/att-string-title.html) | 返回\"标题化\"的 string,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle()) |\n| **[string.translate(str, del=\"\")](https://www.runoob.com/python/att-string-translate.html)** | 根据 str 给出的表(包含 256 个字符)转换 string 的字符,要过滤掉的字符放到 del 参数中 |\n| [string.upper()](https://www.runoob.com/python/att-string-upper.html) | 转换 string 中的小写字母为大写                               |\n| [string.zfill(width)](https://www.runoob.com/python/att-string-zfill.html) | 返回长度为 width 的字符串，原字符串 string 右对齐，前面填充0 |\n\n## 3.Tuple\n\n==元组类似与C#中`readonly List`，是一个只读列表，但是python的元组的元素可以是不同的类型，python用`()`来表示元组。==元组支持存储不同类型元素，如：\n\n```python\nt = ('a',1,3.14)\n```\n\n这里的元组只读及元素不可修改\n\n### 创建空元组\n\n```python\nt = ()\n```\n\n### <font color=red> 创建一个值的元组</font>\n\n```python\nt = (12,)//逗号不可省略\n```\n\n<font color=red> 需要特别注意的是`,`不可省略，如果省略了，`t=(12)`就等于`t=12`</font>\n\n### 元组的分片操作\n\n```python\nt = (1,2,3,4,5,6)\nprint(t[1:3])\n#输出结果为2，3\n```\n\n分片操作可以批量的取元组中的数据，值不能取到3号索引，只能取到3号索引的前一位。\n\n### Tuple的+和*操作\n\n和字符串一样，列表的+运算用于组合列表，列表的*运算用于重复列表，如：\n\n```python\ntu1 = (1, 2)\ntu2 = tu1 + tu1\nprint(tu2)\ntu3 = tu1*3\nprint(tu3)\n```\n\n输出结果：\n\n```\n[1, 2, 1, 2]\n[1, 2, 1, 2, 1, 2]  \n```\n\n### Tuple的无关分隔符\n\n任意无符号对象，只要以`,`分隔，Python都将其是为元组，如\n\n```python\nprint 1, 2, 'a', 3.14\ntu = x, y = 1, 'b'\n```\n\n`1, 2, 'a', 3.14`，会被视为一个元组，及print打印的事实上是一个元组，tu也会被Python默认转换成一个元组，当然x，y还是可以才开使用的。\n\n### Python内置元组操作函数\n\n| 方法                                                         | 描述                   |\n| :----------------------------------------------------------- | ---------------------- |\n| [cmp(tuple1, tuple2)](https://www.runoob.com/python/att-tuple-cmp.html) | 比较两个元组元素。     |\n| [len(tuple)](https://www.runoob.com/python/att-tuple-len.html) | 计算元组元素个数。     |\n| [max(tuple)](https://www.runoob.com/python/att-tuple-max.html) | 返回元组中元素最大值。 |\n| [min(tuple)](https://www.runoob.com/python/att-tuple-min.html) | 返回元组中元素最小值。 |\n| [tuple(seq)](https://www.runoob.com/python/att-tuple-tuple.html) | 将列表转换为元组。     |\n\n## 4.List\n\nList就和C#中的List基本一致，但是python的List更灵活\n\n### List初始化\n\nList的初始化使用`[]`，我们可以使用‘数字’、‘字符串’、‘元组’或‘列表’来初始化一个列表，列表也支持分片操作。\n\npython的列表可以在一个列表中存储不同类型的元素。\n\n并且提供一些基础函数\n\n- index：从列表中找出某个元素的位置，如果有多个相同的元素，则返回第一个元素的位置，如果没有找到则抛出异常。\n\n- count：统计某个元素在列表中出现的次数。\n\n- append：列表末尾增加新的元素。\n\n- extend：将一个新列表的元素添加到原列表中。\n\n  注意到，虽然 append 和 extend 可接收一个列表作为参数，但是 append 方法是将其作为一个元素添加到列表中，而 extend 则是将新列表的元素逐个添加到原列表中。\n\n- insert：将某个元素添加到某个位置。\n\n- pop：移除列表中的一个元素（默认是最后一个），并且返回该元素的值。\n\n- remove：移除列表中的某个匹配元素，如果有多个匹配，则移除第一个。\n\n- reverse：将列表中的元素进行反转。\n\n- sort：对列表进行排序，注意该方法会改变原来的列表，而不是返回新的排序列表，另外，sort 方法的返回值是空。\n\n  如果要使用sort对列表进行排序，那么列表中元素应该保持同一类型。\n\n- clear：清空列表。\n\n### 列表的集合运算\n\nPython提供内置的`set()`函数来对元素集进行集合运算，set函数支持所有可迭代的对象，包括list和tuple。只要是set函数支持的对象，尽管进行运算的两个对象不是相同类型也依旧可以进行集合运算，如：\n\n**取交集**\n\n```python\nl1 = [1, 'a', True, 2, 3]\nl2 = (1, 'a', True, 4, 5)\nprint(set(l1) & set(l2))\n```\n\n输出结果：\n\n```python\n{1， 1, 'a'}\n```\n\n<font color=red> 注意：当bool值进行集合运算时会被转换成0和1，但是这个0和1不会和数字的0和1重复。</font>\n\nPython集合运算符\n\n| 运算符 | 说明       |\n| --- | --- |\n| \\|     | 取并集     |\n| &      | 取交集     |\n| -      | 取差集     |\n| ^      | 取对称差集 |\n\n<font color=red> 集合运算符支持`set()`函数返回的`set`集合作为运算对象。</font>\n\n### List的+和*操作\n\n和字符串一样，列表的+运算用于组合列表，列表的*运算用于重复列表，如：\n\n```python\nli = [1, 2]\nli2 = li + li\nprint(li2)\nli3 = li*3\nprint(li3)\n```\n\n输出结果：\n\n```\n[1, 2, 1, 2]\n[1, 2, 1, 2, 1, 2]  \n```\n\n### Python内置列表操作函数\n\n| 函数                                                         | 描述               |\n| :----------------------------------------------------------- | ------------------ |\n| [cmp(list1, list2)](https://www.runoob.com/python/att-list-cmp.html) | 比较两个列表的元素 |\n| [len(list)](https://www.runoob.com/python/att-list-len.html) | 列表元素个数       |\n| [max(list)](https://www.runoob.com/python/att-list-max.html) | 返回列表元素最大值 |\n| [min(list)](https://www.runoob.com/python/att-list-min.html) | 返回列表元素最小值 |\n| [list(seq)](https://www.runoob.com/python/att-list-list.html) | 将元组转换为列表   |\n\n### List内置函数\n\n| 方法                                                         | 描述                                                         |\n| :----------------------------------------------------------- | ------------------------------------------------------------ |\n| [list.append(obj)](https://www.runoob.com/python/att-list-append.html) | 在列表末尾添加新的对象                                       |\n| [list.count(obj)](https://www.runoob.com/python/att-list-count.html) | 统计某个元素在列表中出现的次数                               |\n| [list.extend(seq)](https://www.runoob.com/python/att-list-extend.html) | 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） |\n| [list.index(obj)](https://www.runoob.com/python/att-list-index.html) | 从列表中找出某个值第一个匹配项的索引位置                     |\n| [list.insert(index, obj)](https://www.runoob.com/python/att-list-insert.html) | 将对象插入列表                                               |\n| [list.pop([index=-1\\])](https://www.runoob.com/python/att-list-pop.html) | 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 |\n| [list.remove(obj)](https://www.runoob.com/python/att-list-remove.html) | 移除列表中某个值的第一个匹配项                               |\n| [list.reverse()](https://www.runoob.com/python/att-list-reverse.html) | 反向列表中元素                                               |\n| [list.sort(cmp=None, key=None, reverse=False)](https://www.runoob.com/python/att-list-sort.html) | 对原列表进行排序                                             |\n\n\n\n## 5.Dictionary\n\nPython的字典和C#中的字典的用法基本一致，不同的时Python使用`{}`来创建字典，使用`:`来连接键值对，使用`,`来分割元素。如：\n\n```python\ndic = {'a': True, 2: \"Py\", \"bb\": 3}\n```\n\nPython自定更强大的地方在于，Python字典在一个字典里支持不同类型的键和值。\n\n<font color=red> 字典的键只能是数字、字符串或元组类型，而值没有任何要求。</font>\n\n### Python内置字典操作函数\n\n| 函数                                                         | 描述                                               |\n| ------------------------------------------------------------ | -------------------------------------------------- |\n| [cmp(dict1, dict2)](https://www.runoob.com/python/att-dictionary-cmp.html) | 比较两个字典元素。                                 |\n| [len(dict)](https://www.runoob.com/python/att-dictionary-len.html) | 计算字典元素个数，即键的总数。                     |\n| [str(dict)](https://www.runoob.com/python/att-dictionary-str.html) | 输出字典可打印的字符串表示。                       |\n| [type(variable)](https://www.runoob.com/python/att-dictionary-type.html) | 返回输入的变量类型，如果变量是字典就返回字典类型。 |\n\n### Dictionary内置函数\n\n| 函数                                                         | 描述                                                         |\n| :----------------------------------------------------------- | ------------------------------------------------------------ |\n| [dict.clear()](https://www.runoob.com/python/att-dictionary-clear.html) | 删除字典内所有元素                                           |\n| [dict.copy()](https://www.runoob.com/python/att-dictionary-copy.html) | 返回一个字典的浅复制                                         |\n| [dict.fromkeys(seq[, val\\])](https://www.runoob.com/python/att-dictionary-fromkeys.html) | 创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值 |\n| [dict.get(key, default=None)](https://www.runoob.com/python/att-dictionary-get.html) | 返回指定键的值，如果值不在字典中返回default值                |\n| [dict.has_key(key)](https://www.runoob.com/python/att-dictionary-has_key.html) | 如果键在字典dict里返回true，否则返回false                    |\n| [dict.items()](https://www.runoob.com/python/att-dictionary-items.html) | 以列表返回可遍历的(键, 值) 元组数组                          |\n| [dict.keys()](https://www.runoob.com/python/att-dictionary-keys.html) | 以列表返回一个字典所有的键                                   |\n| [dict.setdefault(key, default=None)](https://www.runoob.com/python/att-dictionary-setdefault.html) | 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default |\n| [dict.update(dict2)](https://www.runoob.com/python/att-dictionary-update.html) | 把字典dict2的键/值对更新到dict里                             |\n| [dict.values()](https://www.runoob.com/python/att-dictionary-values.html) | 以列表返回字典中的所有值                                     |\n| [pop(key[,default\\])](https://www.runoob.com/python/python-att-dictionary-pop.html) | 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。 |\n| [popitem()](https://www.runoob.com/python/python-att-dictionary-popitem.html) | 返回并删除字典中的最后一对键和值。                           |\n\n## 6.日期和时间\n\nPython的日期时间函数被放在了`time`、`datetime`和`calender`模块下，这里有几个点是需要注意的\n\n### time.time()\n\ntime.time()函数返回的是从1970年1月1日午夜到当前时间所经过的总时长。\n\n```python\nimport time\nprint(time.time())\n#当前时间为：2021.2.6 09：51\n```\n\n输出结果：\n\n```python\n1612576137.817901\n```\n\n### time.localtime()\n\n那么如何输出当前时间呢？答案就是使用`time.localtime(time.time())`来计算当前时间。\n\n```python\nimport time\nprint(time.localtime(time.time()))\n```\n\n输出结果：\n\n```python\ntime.struct_time(tm_year=2021, tm_mon=2, tm_mday=6, tm_hour=9, tm_min=51, tm_sec=39, tm_wday=5, tm_yday=37, tm_isdst=0)\n```\n\n可以看到，函数返回的不是格式化的`2021.2.6 9:51`而是一个`struct_time`时间元组，什么是时间元组？\n\n### 时间元组\n\n很多Python函数用一个元组装起来的9组数字处理时间:\n\n| 序号 | 字段         | 值                                   |\n| :--- | :----------- | :----------------------------------- |\n| 0    | 4位数年      | 2008                                 |\n| 1    | 月           | 1 到 12                              |\n| 2    | 日           | 1到31                                |\n| 3    | 小时         | 0到23                                |\n| 4    | 分钟         | 0到59                                |\n| 5    | 秒           | 0到61 (60或61 是闰秒)                |\n| 6    | 一周的第几日 | 0到6 (0是周一)                       |\n| 7    | 一年的第几日 | 1到366 (儒略历)                      |\n| 8    | 夏令时       | -1, 0, 1, -1是决定是否为夏令时的旗帜 |\n\n而struct_time就是其中之一，struct_time的结构：\n\n| 序号 | 属性     | 值                                   |\n| :--- | :------- | :----------------------------------- |\n| 0    | tm_year  | 2021                                 |\n| 1    | tm_mon   | 1 到 12                              |\n| 2    | tm_mday  | 1 到 31                              |\n| 3    | tm_hour  | 0 到 23                              |\n| 4    | tm_min   | 0 到 59                              |\n| 5    | tm_sec   | 0 到 61 (60或61 是闰秒)              |\n| 6    | tm_wday  | 0到6 (0是周一)                       |\n| 7    | tm_yday  | 1 到 366(儒略历)                     |\n| 8    | tm_isdst | -1, 0, 1, -1是决定是否为夏令时的旗帜 |\n\n### 获取格式化时间\n\n那么如何获取格式化时间呢？\n\n```python\nprint(time.asctime(time.localtime(time.time())))\n```\n\n输出结果：\n\n```python\nSat Feb  6 10:28:09 2021\n```\n\ntime.localtime()返回的是一个字符串，除此之外我们看还可以使用<font color=red>`time.strftime()`</font>函数来自定义时间格式化格式，如：\n\n```python\nprint(time.strftime(\"%H:%M:%S %Y-%m-%d\", time.localtime()))\n```\n\n输出结果：\n\n```python\n10:51:12 2021-02-06\n```\n\n### 时间日期格式化符号\n\n| 符号 | 描述                                      |\n| ---- | ----------------------------------------- |\n| %y   | 两位数的年份表示（00-99）                 |\n| %Y   | 四位数的年份表示（000-9999）              |\n| %m   | 月份（01-12）                             |\n| %d   | 月内中的一天（0-31）                      |\n| %H   | 24小时制小时数（0-23）                    |\n| %I   | 12小时制小时数（01-12）                   |\n| %M   | 分钟数（00-59）                           |\n| %S   | 秒（00-59）                               |\n| %a   | 本地简化星期名称                          |\n| %A   | 本地完整星期名称                          |\n| %b   | 本地简化的月份名称                        |\n| %B   | 本地完整的月份名称                        |\n| %c   | 本地相应的日期表示和时间表示              |\n| %j   | 年内的一天（001-366）                     |\n| %p   | 本地A.M.或P.M.的等价符                    |\n| %U   | 一年中的星期数（00-53）星期天为星期的开始 |\n| %w   | 星期（0-6），星期天为星期的开始           |\n| %W   | 一年中的星期数（00-53）星期一为星期的开始 |\n| %x   | 本地相应的日期表示                        |\n| %X   | 本地相应的时间表示                        |\n| %Z   | 当前时区的名称                            |\n| %%   | %号本身                                   |\n\n### time与datetime库\n\npython处理时间处理time模块还可以使用datetime模块，那么time和datetime之间有什么区别呢？\n\n在 Python 文档里，`time`是归类在`Generic Operating System Services`中，换句话说， 它提供的功能是更加接近于操作系统层面的。通读[文档](https://docs.python.org/2.7/library/time.html)可知，time 模块是围绕着 Unix Timestamp 进行的。\n\n该模块主要包括一个类 `struct_time`，另外其他几个函数及相关常量。 需要注意的是在该模块中的大多数函数是调用了所在平台`C library`的同名函数， 所以要特别注意有些函数是平台相关的，可能会在不同的平台有不同的效果。另外一点是，由于是基于Unix Timestamp，所以其所能表述的日期范围被限定在 1970 - 2038 之间，如果你写的代码需要处理在前面所述范围之外的日期，那可能需要考虑使用`datetime`模块更好。\n\ndatetime 比 time 高级了不少，可以理解为 datetime 基于 time 进行了封装，提供了更多实用的函数。\n\n| 类        | 描述                 |\n| --------- | -------------------- |\n| timedelta | 主要用于计算时间跨度 |\n| tzinfo    | 时区相关             |\n| time      | 只关注时间           |\n| date      | 只关注日期           |\n| datetime  | 同时有时间和日期     |\n\n### calendar库\n\ncalendar库主要用于处理日历，如：打印2021年2月的日历\n\n```python\nprint(calendar.month(2021, 1))\n```\n\n输出结果：\n\n```python\n    January 2021\nMo Tu We Th Fr Sa Su\n             1  2  3\n 4  5  6  7  8  9 10\n11 12 13 14 15 16 17\n18 19 20 21 22 23 24\n25 26 27 28 29 30 31\n```\n\n### time库内置函数\n\n| 函数                                                         | 描述                                                         |\n| :----------------------------------------------------------- | :----------------------------------------------------------- |\n| [time.altzone](https://www.runoob.com/python/att-time-altzone.html) | 返回格林威治西部的夏令时地区的偏移秒数。如果该地区在格林威治东部会返回负值（如西欧，包括英国）。对夏令时启用地区才能使用。 |\n| [time.asctime([tupletime])](https://www.runoob.com/python/att-time-asctime.html) | 接受时间元组并返回一个可读的形式为\"Tue Dec 11 18:07:14 2008\"（2008年12月11日 周二18时07分14秒）的24个字符的字符串。 |\n| [time.clock( )](https://www.runoob.com/python/att-time-clock.html) | 用以浮点数计算的秒数返回当前的CPU时间。用来衡量不同程序的耗时，比time.time()更有用。 |\n| [time.ctime([secs])](https://www.runoob.com/python/att-time-ctime.html) | 作用相当于asctime(localtime(secs))，未给参数相当于asctime()  |\n| [time.gmtime([secs])](https://www.runoob.com/python/att-time-gmtime.html) | 接收时间戳（1970纪元后经过的浮点秒数）并返回格林威治天文时间下的时间元组t。注：t.tm_isdst始终为0 |\n| [time.localtime([secs])](https://www.runoob.com/python/att-time-localtime.html) | 接收时间戳（1970纪元后经过的浮点秒数）并返回当地时间下的时间元组t（t.tm_isdst可取0或1，取决于当地当时是不是夏令时）。 |\n| [time.mktime(tupletime)](https://www.runoob.com/python/att-time-mktime.html) | 接受时间元组并返回时间戳（1970纪元后经过的浮点秒数）。       |\n| [time.sleep(secs)](https://www.runoob.com/python/att-time-sleep.html) | 推迟调用线程的运行，secs指秒数。                             |\n| [time.strftime(fmt[,tupletime])](https://www.runoob.com/python/att-time-strftime.html) | 接收以时间元组，并返回以可读字符串表示的当地时间，格式由fmt决定。 |\n| [time.strptime(str,fmt='%a %b %d %H:%M:%S %Y')](https://www.runoob.com/python/att-time-strptime.html) | 根据fmt的格式把一个时间字符串解析为时间元组。                |\n| [time.time( )](https://www.runoob.com/python/att-time-time.html) | 返回当前时间的时间戳（1970纪元后经过的浮点秒数）。           |\n| [time.tzset()](https://www.runoob.com/python/att-time-tzset.html) | 根据环境变量TZ重新初始化时间相关设置。                       |\n\n### 两个time库重要属性\n\n| 属性              | 描述                                                         |\n| :---------------- | :----------------------------------------------------------- |\n| **time.timezone** | 属性 time.timezone 是当地时区（未启动夏令时）距离格林威治的偏移秒数（>0，美洲<=0大部分欧洲，亚洲，非洲）。 |\n| **time.tzname**   | 属性time.tzname包含一对根据情况的不同而不同的字符串，分别是带夏令时的本地时区名称，和不带的。 |\n\n### calendar内置函数\n\n| 函数                                     | 描述                                                         |\n| :--------------------------------------- | :----------------------------------------------------------- |\n| **calendar.calendar(year,w=2,l=1,c=6)**  | 返回一个多行字符串格式的year年年历，3个月一行，间隔距离为c。 每日宽度间隔为w字符。每行长度为21* W+18+2* C。l是每星期行数。 |\n| **calendar.firstweekday( )**             | 返回当前每周起始日期的设置。默认情况下，首次载入 calendar 模块时返回 0，即星期一。 |\n| **calendar.isleap(year)**                | 是闰年返回 True，否则为 False。`>>> import calendar >>> print(calendar.isleap(2000)) True >>> print(calendar.isleap(1900)) False` |\n| **calendar.leapdays(y1,y2)**             | 返回在Y1，Y2两年之间的闰年总数。                             |\n| **calendar.month(year,month,w=2,l=1)**   | 返回一个多行字符串格式的year年month月日历，两行标题，一周一行。每日宽度间隔为w字符。每行的长度为7* w+6。l是每星期的行数。 |\n| **calendar.monthcalendar(year,month)**   | 返回一个整数的单层嵌套列表。每个子列表装载代表一个星期的整数。Year年month月外的日期都设为0;范围内的日子都由该月第几日表示，从1开始。 |\n| **calendar.monthrange(year,month)**      | 返回两个整数。第一个是该月的星期几的日期码，第二个是该月的日期码。日从0（星期一）到6（星期日）;月从1到12。 |\n| **calendar.prcal(year,w=2,l=1,c=6)**     | 相当于 **print calendar.calendar(year,w=2,l=1,c=6)**。       |\n| **calendar.prmonth(year,month,w=2,l=1)** | 相当于 **print calendar.month(year,month,w=2,l=1)** 。       |\n| **calendar.setfirstweekday(weekday)**    | 设置每周的起始日期码。0（星期一）到6（星期日）。             |\n| **calendar.timegm(tupletime)**           | 和time.gmtime相反：接受一个时间元组形式，返回该时刻的时间戳（1970纪元后经过的浮点秒数）。 |\n| **calendar.weekday(year,month,day)**     | 返回给定日期的日期码。0（星期一）到6（星期日）。月份为 1（一月） 到 12（12月）。 |\n\n## 7.set集合\n\npython的set集合和C++的set集合的用法基本是一样的，set集合是一个无序不重复序列，python使用`{}`或`set()`函数来创建set集合，区别字典的地方是{}包括的元素不是键值对，需要注意的是，创建空集合只能通过set()函数。\n\n## 8.类型转换\n\nPython提供了大量内置类型转换函数：\n\n| 函数                                                         | 描述                                                |\n| ------------------------------------------------------------ | --------------------------------------------------- |\n| int(x [,[base])](https://www.runoob.com/python/python-func-int.html) | 将x转换为一个整数                                   |\n| long(x [,[base] )](https://www.runoob.com/python/python-func-long.html) | 将x转换为一个长整数                                 |\n| [float(x)](https://www.runoob.com/python/python-func-float.html) | 将x转换到一个浮点数                                 |\n| complex(real [[,imag])](https://www.runoob.com/python/python-func-complex.html) | 创建一个复数                                        |\n| [str(x)](https://www.runoob.com/python/python-func-str.html) | 将对象 x 转换为字符串                               |\n| [repr(x)](https://www.runoob.com/python/python-func-repr.html) | 将对象 x 转换为表达式字符串                         |\n| [eval(str)](https://www.runoob.com/python/python-func-eval.html) | 用来计算在字符串中的有效Python表达式,并返回一个对象 |\n| [tuple(s)](https://www.runoob.com/python/att-tuple-tuple.html) | 将序列 s 转换为一个元组                             |\n| [list(s)](https://www.runoob.com/python/att-list-list.html)  | 将序列 s 转换为一个列表                             |\n| [set(s)](https://www.runoob.com/python/python-func-set.html) | 转换为可变集合                                      |\n| [dict(d)](https://www.runoob.com/python/python-func-dict.html) | 创建一个字典。d 必须是一个序列 (key,value)元组。    |\n| [frozenset(s)](https://www.runoob.com/python/python-func-frozenset.html) | 转换为不可变集合                                    |\n| [chr(x)](https://www.runoob.com/python/python-func-chr.html) | 将一个整数转换为一个字符                            |\n| [unichr(x)](https://www.runoob.com/python/python-func-unichr.html) | 将一个整数转换为Unicode字符                         |\n| [ord(x)](https://www.runoob.com/python/python-func-ord.html) | 将一个字符转换为它的整数值                          |\n| [hex(x)](https://www.runoob.com/python/python-func-hex.html) | 将一个整数转换为一个十六进制字符串                  |\n| [oct(x)](https://www.runoob.com/python/python-func-oct.html) | 将一个整数转换为一个八进制字符串                    |\n\n# 四、运算符\n\n## 1.算术运算符\n\nPython的算术运算基本和C系列语言没什么区别，唯一的区别在于Python将C系列语言的求幂函数和取整函数直接内置到了Python的运算符里了，如：\n\n| 运算符 | 描述 |\n| ------- | ----- |\n| ** | 求幂运算符，二元运算符，a**b表示求a的b次幂 |\n| // |取整运算符，二元运算符，a//b表示a对b取整，如9//4 = 2 |\n\n## 2.赋值运算符\n\n和算数运算符一样，Python也将求幂运算和取整运算的赋值运算内置到运算符里。\n\n| 运算符 | 描述 |\n| --- | --- |\n| **= | 幂赋值运算符 |\n| //= | 取整赋值运算符 |\n\n## 3.逻辑运算符\n\n由于Python的底层是用C写的所有C的逻辑运算符（`&`,`|`,`!`）在Python中就不能再使用了，所以Python使用（`and`,`or`,`not`）来做逻辑运算符，用法和`&`,`|`,`!`一样。\n\n## 4.成员运算符\n\n和前面一样，Python也将判断函数直接内置到运算符中了，Python成员运算符作用就是判断指定序列中是否包含某个指定元素，序列支持字符串，列表和元组。\n\n|  |  |\n| --- | --- |\n| in | 如果指定元素在指定序列中则返回True |\n| not in | 如果指定元素不在指定序列中则返回True |\n\n\n```\nli = [1,2,3,4,5]\ntu = (1,2,3,4,5)\nst = “12345”\na = 1\nb = ‘1’\nprint(a in li)\nprint(a not in tu)\nprint(b in st)\n```\n返回结果：\n\n```\nTrue\nFalse\nTrue\n```\n\n## 5.身份运算符\n\n| | |\n| --- | --- |\n| is | 判断两个对象是否来自同一引用|\n| is not | 判断两个对象是否不同的引用|\n\nPyhton的身份运算符和C#的is是不一样的，Python的is用于判断两个对象是否来引用同一引用，而C#的is则是判断某一对象是否是指定类型。\n\n使用案例：\n\n```\na  = 1\nb = a\nprint(a is b)\nb = 2\nprint(a is not b)\nc = 2\nprint(b is c)\n```\n输出结果：\n\n```\nTrue\nTrue\nTrue\n```\n\n这里出现了一个疑问，为什么b和c来自同一引用呢？\n我们查看一下b和c的内存地址\n\n```\nprint(id(b))\nprint(id(c))\n```\n输出结果：\n\n```\n2324527120200\n2324527120200\n```\n可以看到b和c指向了同一内存地址，原来Python在对程序优化的时候会将程序中的内容相同的常量存储到一个存储地址中。\n\n# 五、控制语句\n\nPython的条件语句与C系列语言最大的不同是，Python的条件语句可以不使用`()`来包含条件表达式，当然也可以是使用，大多数情况下还是建议使用（），以使代码的阅读性更高。\n\n## 1.if语句\n\n当条if-else语句的用法和C系列基本一致。\n\n```\nif True:\n\ta=1\n\tb=1\nelse:\n\ta=2\n\tb=2\n```\n\n<font color=red> 其中`:`是必须的</font>\nPython中比较特殊的是else if语句，在Python中使用<font color=red> elif</font>表示。\n\n## 2.while循环语句\n\nPython的while循环可以搭配esle使用，当循环跳出时执行else语句，个人感觉没什么实际用处。\n\n```\na = 0\nwhile a<3:\n\tprint(a)\n\ta += 1\nelse:\n\tprint(“循环结束”)\n```\n输出结果：\n\n```\n0\n1\n2\n循环结束\n```\n\n## 3.for循环\n\n<font color=red> 在写循环语句之前有一点是需要明确的，及根据Python的设计理念Python已经不使用自增`++`自减`--`运算符了，所以需要自增时应使用`a += 1`</font>\n\n### for in\n\nfor in的用法和C#的foreach一致，可以遍历任何序列，如：\n\n```\nli = [1,2,3,4,5]\nfor item in li:\n\tprint(item)\nelse：\n\tprint(“for end”)\n```\n\n和while一样for也可以配合else使用\n\n### for in range()\n\nfor in range()就是不同的for循环，通过下标来遍历序列，如：\n\n```\nli = [1,2,3,4,5]\nfor i in range(len(li)):\n\tprint(li[i])\nelse:\n\tprint(“for end”)\n```\n<font color=red> 需要注意实际上for in中是不包含range()的，range只是一个辅助函数，用于确定下标的范围。如果我们直接像下面那样写是会报语法错误的，如：</font>\n\n```\nfor i in 4:\n\t#code\n```\n如果我们想让循环只跑4轮，应该用range(4)来确定下标范围，如：\n\n```\nfor i in range(4):\n```\n\n### continue、break和pass\n\nPython的continue和break的用法和C系列语言基本一致，Python中新增了pass语句，pass语句就是C系列语言中`;`及空语句，一般用于空循环中维护代码的结构性。\n\n# 六、函数\n\n## 1.函数定义\n\n- 函数代码块以 **def** 关键词开头，后接函数标识符名称和圆括号**()**。\n- 任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。\n- <font color=red>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</font>\n- 函数内容以冒号起始，并且缩进。\n- **return [表达式]** 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。\n\n如：\n\n```python\ndef fun(a):\n    \"打印a的平方并返回\"\n    b = a*a\n    print(b)\n    return b\n```\n\n## 2.函数调用\n\n<font color=red> 在调用Python函数时有一点是需要特别注意的，由于Python是解释型语言，Python脚本在运行时是一行一行地放入解释器中进行解释的，因此Pyhton不支持函数的声明定义的分离，所有Python的函数调用必须在定义之后，否则将会报函数未定义。</font>\n\n## 3.参数传递\n\n在讨论函数参数之前，我们需要了解两个概念：\n\n- 不可变对象：不可变对象都是不可变类型，<font color=red>Python的不可变类型有数字、字符串、元组</font>，不可变对象指向的内存地址上的内容是不可更改的，如需操作其内容Python会开辟一个新的内存地址来存储编辑后的内容。\n\n- 可变对象：可变对象都是可变类型，不是不可变类型的类型都是可变类型，包括列表、字典、自定义类型等，可变类型对象指向的内存地址的内容是可更改，操作可变对象的内容时Python不会开辟新的内存，而是直接修改原地址内容。\n\n<font color=red>函数传入不可变对象的原理和C++的传值原理是一样的，函数传入可变对象的原理和C++传址原理是一样的。</font>\n\n### 传参原理\n\n由于Python的变量都是若类型的，参数也不例外，函数在定义参数时只有名字没有类型，所以Python在调用函数时，参数的传递是根据实参的顺序来给形参赋值的。\n\n### 关键字参数\n\nPython的函数支持关键字传参，关键字传参的原理是指定实参来赋值指定形参，所以可以无视参数的传入顺序。如：\n\n```python\ndef fun(a,b,c):\n    print(a+b+c)\nfun(b = 1,c = 2,a = 3)\n```\n\n### 默认参数\n\nPython的函数也支持默认参数，原理和C++一样。\n\n### 单*号不定长参数\n\nPython的不定长参数和C++则有些不同，Python使用`*`来标识不定长参数，所有形参匹配之外的参数都将存储到不定长参数中，如：\n\n```python\ndef fun(a,b,*c):\n    d = a + b\n    for item in c:\n        d += item\n    print(d)\nfun(1,2,3,4)\n```\n\n在这个过程中，1被赋予a，2被赋予b，3和4被赋予c\n\nPython支持不定长参数的单独使用，如：\n\n```python\ndef fun(*param):\n    pass\n```\n\n如果函数的参数只有一个不定长参数，那么函数传入的任何参数都会存储到不定长参数里。\n\n<font color = red> 单`*`号不定长参数会将传入的所有参数封装在一个元组里，且单`*`号不定长参数只支持参数的顺序传入，不支持关键字传入。</font>\n\n当函数只有单`*`号不定长参数时，单`*`号不定长参数因该放在最后一个参数，如果不放在最后将会报错：\n\n```python\ndef fun(*c, t):\n    c[0][0] = 5\n    print(c[0])\n    print(t)\n```\n\n报错：\n\n```python\nTraceback (most recent call last):\n  File \"d:\\Codes\\Python\\MyFirstPython.py\", line 9, in <module>\n    fun(li, 2)\nTypeError: fun() missing 1 required keyword-only argument: 't'\n```\n\n### 双*号不定长参数\n\n除了单`*`号不定长参数外，Python还支持双`*`号不定长参数，<font color=red> 双`*`号不定长参数支持关键字传入，不支持顺序传入，双`*`号不定长参数会将传入的参数封装在一个字典里，其中关键字的名字存入字典的键中，关键字的值存入字典的值中。</font>如：\n\n```python\ndef fun(t,**d):\n    print(t)\n    print(d['x'])\n    print(d['y'])\nfun(1,x=2,y=3)\n```\n\n输出结果：\n\n```python\n1\n2\n3\n```\n\n当函数中同时存在单`*`号不定长参数和双`*`号不定长参数时，双`*`号不定长参数应放在最后一个参数位置，单`*`号参数应放在倒数第二个参数位置。\n\n## 4.匿名函数\n\nPython的匿名函数的使用场景是，当函数体只由比较简单的Lambda表达式组成时才使用。匿名函数除了没有函数名，其他的和有名函数没有什么区别。如：\n\n```python\nf = lambda a,b=1: a+b\nprint(f(1))\n```\n\n输出结果：\n\n```python\n2\n```\n\n在lambda表达式的结构中，`:`之前的为参数，`:`号之后有且只有一条语句，这是由Python语句分割的方式决定的。从上面的例子我们还可以发现，lambda表达式支持默认参数，且自带返回值，lambda表达式将表达式的结果作为返回值，需要注意的是，lambda表达式中不能进行复制操作，否则将报语法错误。\n\n# 七、模块\n\n一个Python文件就是一个Python模块，一个Python包也是一个Python模块。\n\n## 1.导入模块（包）\n\n### 整模块导入\n\nPython使用`import`+`模块名`来导入模块，如：\n\n```python\nimport MyFirstPython\n```\n\n当我们将一个Python作为模块导入到另一个文件时，Python会在工程文件夹下的`__pycache`文件夹下生成一个模块名对应的`pyc`文件，如上面的例子则会生成一个`PyFirstPython.cpython-39.pyc`其中cpython-39为python版本号，这个文件是做什么用的呢？pyc文件是一个二进制文件，且已经经过Python加密，直接打开会显示乱码，pyc的主要作用就是加快模块的导入速度，注意这里是导入速度而非运行速度，pyc文件可以通过反编译器重新反编译成可执行的Python文件。\n\npython支持使用`,`来分割模块，达到同时导入多个包的目的，如：\n\n```python\nimport MyfirstPython,MySecondPython\n```\n\n### 单函数导入\n\npython除了支持整个文件的模块导入，同时也支持只导入模块中的一个函数，python使用`from 模块名 import 函数名`来从指定模块导入单个函数，如：\n\n```python\nfrom MySecondPython import fun as f\n```\n\n同时，python在导入模块或模块中的函数时可以使用`as`关键字为模块或函数起别名。\n\nform import还可以使用`*`来达到import的效果，如：\n\n```python\nfrom MyFirstPython import * #相当于import MyFirstPython\n```\n\n### python导入模块时的路径搜索顺序\n\n- 1、当前目录\n- 2、如果不在当前目录，Python 则搜索在 shell 变量 PYTHONPATH 下的每个目录。\n- 3、如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/。\n\n### python使用导入模块的全局变量\n\n有一点十分不方便的就是在当前文件下无法直接使用导入模块的全局变量，只能通过为指定变量编写读写函数才能操作全局变量，这是由python的变量规则决定的。\n\n### Pyhton模块打包\n\nPython提供了多个打包工具，我使用的是python3.9内置的`setuptools`库，setuptools库中提供了一个setup函数用于打包模块，具体操作如下：\n\n- 1.在工程目录下新建一个setup.py文件，这个文件用于配置一些包的必要信息，配置信息都由关键字参数的形式传入setup函数中，具体参数信息如下;\n\n  ```python\n  setup(\n      name=about[\"__title__\"],  # 包名称\n      version=about[\"__version__\"],  # 包版本\n      description=about[\"__description__\"],  # 包详细描述\n      long_description=readme,   # 长描述，通常是readme，打包到PiPy需要\n      author=about[\"__author__\"],  # 作者名称\n      author_email=about[\"__author_email__\"],  # 作者邮箱\n      url=about[\"__url__\"],   # 项目官网\n      packages=packages,    # 项目需要的包\n      data_files=file_data,   # 打包时需要打包的数据文件，如图片，配置文件等\n      include_package_data=True,  # 是否需要导入静态数据文件\n      python_requires=\">=3.0, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3*\",  # Python版本依赖\n      install_requires=requires,  # 第三方库依赖\n      zip_safe=False,  # 此项需要，否则卸载时报windows error\n      classifiers=[    # 程序的所属分类列表\n          'Development Status :: 5 - Production/Stable',\n          'Intended Audience :: Developers',\n          'Natural Language :: English',\n          'Programming Language :: Python',\n          'Programming Language :: Python :: 3',\n          'Programming Language :: Python :: 3.4',\n          'Programming Language :: Python :: 3.5',\n          'Programming Language :: Python :: 3.6',\n          'Programming Language :: Python :: 3.7',\n          'Programming Language :: Python :: Implementation :: CPython',\n          'Programming Language :: Python :: Implementation :: PyPy'\n      ],\n  )\n  ```\n\n  当然这里面所有的参数都不是非必须，如果我们一个参数都不传入，则pyhton会生成一个名为`UNKNOW-0.0.0.tar.gz`的包。\n\n- 2.使用cmd进入setup.py所在目录，使用`python setup.py sdist`命令之后，python会在此目录下生成一个`dist`目录和一个`包名.egg-info`目录，包名及setup函数中name指定的名称，为命名则为UNKNOWN.egg-info，这个文件夹下是一些包的详细信息文件。\n\n如此包便打包完成了，这中间踩了一写坑，记录一下：\n\n使用python setup.py sdist命令无反应，然后使用python -v发现也不输出python版信息，此时打开此电脑/属性/高级系统设置/高级/环境变量，发现path中都以存在python目录，可是使用python -v就是无反应。\n\n解决方案：在cmd下使用`set PATH=Python完成目录;%PATH%`，不知道为什么需要使用命令行配置一下系统环境才行。\n\n当然不同的打包工具，打包过程略有不同，这里就详细展开了。\n\n# 八、Python的内置函数\n\n## 1.数学函数\n\n| 函数| 描述 |\n| --- | --- |\n| [abs()](https://www.runoob.com/python/func-number-abs.html) | 返回数字的绝对值，如abs(-10) 返回 10 |\n| [cmp()](https://www.runoob.com/python/func-number-cmp.html) | 如果 x < y 返回 -1, 如果 x == y 返回 0, 如果 x > y 返回 1 |\n| [max()](https://www.runoob.com/python/func-number-max.html) | 返回给定参数的最大值，参数可以为序列 |\n| [min()](https://www.runoob.com/python/func-number-min.html) | 返回给定参数的最小值，参数可以为序列 |\n| [pow()](https://www.runoob.com/python/func-number-pow.html) | x^y 运算后的值，及求x的y次幂 |\n| [round(x [,n])](https://www.runoob.com/python/func-number-round.html) | 返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数 |\n| [sum()](https://www.runoob.com/python/python-func-sum.html) | 对序列求和 |\n| [round()](https://www.runoob.com/python/func-number-round.html) | 返回浮点数x的四舍五入值 |\n## 5.反射函数\n\n| 函数                                                         | 描述                                                         |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| [dir()](https://www.runoob.com/python/python-func-dir.html)  | dir函数返回一个包含了一个模块里所定义的所有模块、变量和函数，dir函数只是列出名称，无其他实际意义，其中以`__`开头的是模块相关的默认属性，如：`__name__`指向模块的名字，`__file__`指向模块文件的名字，dir函数可以传入模块名称，则输出的是模块相关的信息，如果不传入参数则输出当前作用域的相关信息 |\n| [globals()](https://www.runoob.com/python/python-func-globals.html) | 在函数内使用则返回一个包含该函数能访问的所有全局名字的字典，在函数外使用效果和在函数内使用一样 |\n| [locals()](https://www.runoob.com/python/python-func-locals.html) | 在函数内使用则返回一个包含该函数内的全部局部名字的字典，在函数外使用效果和globals()函数一样 |\n| [callable()](https://www.runoob.com/python/python-func-callable.html) | 检查一个对象是否是可调用的。如果返回 True，object 仍然可能调用失败；但如果返回 False，调用对象 object 绝对不会成功。 |\n\n## 6.类型转换函数\n\n| 函数                                                         | 描述                                                         |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| [bool()](https://www.runoob.com/python/python-func-bool.html) | 将对象转换为bool类型，对于空元组和空列表将转换为false        |\n| [float()](https://www.runoob.com/python/python-func-float.html) | 在python中没有double类型，python的float精度就已经达到了double的精度 |\n| [int()](https://www.runoob.com/python/python-func-int.html)  | 转整型                                                       |\n| [long()](https://www.runoob.com/python/python-func-long.html) | 转长整型                                                     |\n| [str()](https://www.runoob.com/python/python-func-str.html)  | 将对象转换成字符串，支持任何对象                             |\n| [eval()](https://www.runoob.com/python/python-func-eval.html) | eval函数可以用来做字符串转列表、元组和字典等，如：`a = eval('[1,2]')`、`b = eval('(1,2)')`，a是一个列表，b是一个元组，其中字典需要注意的是要使用纯字符串，如：`c = eavl(r\"{'a':1,'b':2}\")`，c就是一个字典了，除此之外，eval函数还可以用来运行字符串命令，如：`eval('bool(1)')`，输出为`True` |\n| [list()](https://www.runoob.com/python/att-list-list.html)   | 将可迭代序列(包括元组，字符串，字典等)转换成列表，如：字符串转列表`a = list('abc')`则a列表内容为`['a','b','c']`、字典转列表则会返回一个key值列表 |\n| [tuple()](https://www.runoob.com/python/att-tuple-tuple.html) | 将可迭代序列(包括元组，字符串，字典等)转换成元组，如：字符串转元组`a = tuple('abc')`则a列表内容为`('a','b','c')`、字典转元组则会返回一个key值元组 |\n| [dict()](https://www.runoob.com/python/python-func-dict.html) | dict函数支持三种转换形式，其一使用关键字的形式，关键字名称为键，关键字的值为值，如：`a=dict(a=1,b=1)`则a就是字典`{'a':1,'b':2}`，其二使用zip函数的形式，zip函数将两个可迭代序列按位置打包成二元元组，dict函数则将二元元组的第一个元素作为键，第二个元素作为值创建字典，如：`a=dict(zip(['a','b'],[1,2]))`，其中zip函数返回值为`[('a',1),('b',2)]`，dict函数返回值为`{'a':1,'b':2}`，其三使用可迭代对象的形式，如：`a=dict([('a',1),('b':2)])`其中可迭代对象可以是任何子成员为二元序列的对象 |\n| [chr()](https://www.runoob.com/python/python-func-chr.html)  | 将数字转换成对应的字符                                       |\n\n\n\n## 6.其他内置函数\n\n详情见[菜鸟教程](https://www.runoob.com/python/python-built-in-functions.html)\n\n# 九、文件IO\n\n## 1.标准输出\n\nprint()在终端打印，这里需要注意的是python3已经不支持`print 'aa'`这种打印方式了。\n\n## 2.标准输入\n\ninput()从终端输入，有时我们会看到row_input函数或input函数接收python表达式的标准输入，这些都是ptrhon2的标准输入函数和输入特性，在python3中python只保留了一个input函数作为标准输入，且input函数不在支持python表达式的输入，而是把所有的输入当作是字符串。\n\n## 3.文件读写\n\npython的文件读写通过内置类型`file`类型来进行操作，而file类型对象的创建需要通过内置函数`open`来创建。\n\n### open函数\n\n```python\nopen(file_name ,access_mode, buffering)\n```\n\n- file_name：文件路径\n\n- access_mode：打开模式，默认为只读，具体模式如下：\n\n  | 字符  | 含义                             |\n  | :---- | :------------------------------- |\n  | `'r'` | 读取（默认）                     |\n  | `'w'` | 写入，并先截断文件               |\n  | `'x'` | 排它性创建，如果文件已存在则失败 |\n  | `'a'` | 写入，如果文件存在则在末尾追加   |\n  | `'b'` | 二进制模式                       |\n  | `'t'` | 文本模式（默认）                 |\n  | `'+'` | 更新磁盘文件（读取并写入）       |\n\n  python3以后删除了很多打开模式，只保留了上面几种，所以如果在python3环境中使用`+`打开模式就会报错。\n\n- buffering：是否寄存行，可选参数，具体取值如下：\n\n  | 取值 | 描述                                                    |\n  | ---- | ------------------------------------------------------- |\n  | 0    | 取0，不寄存行                                           |\n  | 1    | 取1，寄存行                                             |\n  | >1   | 取大于1的值，寄存行，且设置寄存区的缓冲大小为当前值     |\n  | <0   | 取小于0的值，寄存行，且设置寄存区的缓冲大小为系统默认值 |\n\n- 返回值：open函数打开文件，读取文件内容到内存并一个可操作文件的file类型对象。\n\n### file类型对象内置函数\n\n| 序号                                                         | 方法及描述                                                   |\n| :----------------------------------------------------------- | :----------------------------------------------------------- |\n| [file.close()](https://www.runoob.com/python3/python3-file-close.html) | 关闭文件。关闭后文件不能再进行读写操作。                     |\n| [file.flush()](https://www.runoob.com/python3/python3-file-flush.html) | 刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。 |\n| [file.fileno()](https://www.runoob.com/python3/python3-file-fileno.html) | 返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。 |\n| [file.isatty()](https://www.runoob.com/python3/python3-file-isatty.html) | 如果文件连接到一个终端设备返回 True，否则返回 False。        |\n| [file.read([size])](https://www.runoob.com/python3/python3-file-read.html) | 从文件读取指定的字节数，如果未给定或为负则读取所有。         |\n| [file.readline([size])](https://www.runoob.com/python3/python3-file-readline.html) | 读取整行，包括 \"\\n\" 字符。                                   |\n| [file.readlines([sizeint])](https://www.runoob.com/python3/python3-file-readlines.html) | 读取所有行并返回列表，若给定sizeint>0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。 |\n| [file.seek(offset[, whence])](https://www.runoob.com/python3/python3-file-seek.html) | 移动文件读取指针到指定位置                                   |\n| [file.tell()](https://www.runoob.com/python3/python3-file-tell.html) | 返回文件当前位置。                                           |\n| [file.truncate([size])](https://www.runoob.com/python3/python3-file-truncate.html) | 从文件的首行首字符开始截断，截断文件为 size 个字符，无 size 表示从当前位置截断；截断之后后面的所有字符被删除，其中 windows 系统下的换行代表2个字符大小。 |\n| [file.write(str)](https://www.runoob.com/python3/python3-file-write.html) | 将字符串写入文件，返回的是写入的字符长度。                   |\n| [file.writelines(sequence)](https://www.runoob.com/python3/python3-file-writelines.html) | 向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。 |\n\n### file类型对象内置属性\n\n| 属性           | 描述                                                         |\n| :------------- | :----------------------------------------------------------- |\n| file.closed    | 返回true如果文件已被关闭，否则返回false。                    |\n| file.mode      | 返回被打开文件的访问模式。                                   |\n| file.name      | 返回文件的名称。                                             |\n| file.softspace | 如果用print输出后，必须跟一个空格符，则返回false。否则返回true。 |\n\n## 4.文件及目录操作\n\n这里的文件操作不是对文件的内容进行增删改操作而是在文件级别进行重命名删除设置权限等操作，对文件做这些操作需要用到`os`模块，os模块提供大量的函数对文件进行操作，文件数量过多这里就不贴出来了，具体见菜鸟教程：\n\n[os文件操作函数](https://www.runoob.com/python/os-file-methods.html)\n\n# 十、异常\n\n## 1.异常处理语句\n\nPython的异常处理语句是`try/except`，需要监测异常的代码放在`try:`块下，在异常发生后需要执行的代码放在`except:`块下，except后可以接异常类型也可以不接，如：\n\n```python\ntry:\n    a = 1/0\nexcept ZeroDivisionError:\n    print('0不可以做除数')\nelse:\n    print('没有异常')\nfinally:\n    print('有没有异常都会执行')\n```\n\n可以看到，和条件语句一样try/except语句也可以接else分支，else分支在没有异常发生时执行。、\n\n## 2.抛出异常\n\npython使用`raise`语句来抛出异常，需要注意的是，raise必须抛出一个异常类，如：\n\n```python\ntry:\n    a = 1/0\nexcept ZeroDivisionError:\n    raise ZeroDivisionError('0不可以做除数')\n```\n\n\n\n## 3.标准异常\n\n| 异常名称                  | 描述                                               |\n| :------------------------ | :------------------------------------------------- |\n| BaseException             | 所有异常的基类                                     |\n| SystemExit                | 解释器请求退出                                     |\n| KeyboardInterrupt         | 用户中断执行(通常是输入^C)                         |\n| Exception                 | 常规错误的基类                                     |\n| StopIteration             | 迭代器没有更多的值                                 |\n| GeneratorExit             | 生成器(generator)发生异常来通知退出                |\n| StandardError             | 所有的内建标准异常的基类                           |\n| ArithmeticError           | 所有数值计算错误的基类                             |\n| FloatingPointError        | 浮点计算错误                                       |\n| OverflowError             | 数值运算超出最大限制                               |\n| ZeroDivisionError         | 除(或取模)零 (所有数据类型)                        |\n| AssertionError            | 断言语句失败                                       |\n| AttributeError            | 对象没有这个属性                                   |\n| EOFError                  | 没有内建输入,到达EOF 标记                          |\n| EnvironmentError          | 操作系统错误的基类                                 |\n| IOError                   | 输入/输出操作失败                                  |\n| OSError                   | 操作系统错误                                       |\n| WindowsError              | 系统调用失败                                       |\n| ImportError               | 导入模块/对象失败                                  |\n| LookupError               | 无效数据查询的基类                                 |\n| IndexError                | 序列中没有此索引(index)                            |\n| KeyError                  | 映射中没有这个键                                   |\n| MemoryError               | 内存溢出错误(对于Python 解释器不是致命的)          |\n| NameError                 | 未声明/初始化对象 (没有属性)                       |\n| UnboundLocalError         | 访问未初始化的本地变量                             |\n| ReferenceError            | 弱引用(Weak reference)试图访问已经垃圾回收了的对象 |\n| RuntimeError              | 一般的运行时错误                                   |\n| NotImplementedError       | 尚未实现的方法                                     |\n| SyntaxError               | Python 语法错误                                    |\n| IndentationError          | 缩进错误                                           |\n| TabError                  | Tab 和空格混用                                     |\n| SystemError               | 一般的解释器系统错误                               |\n| TypeError                 | 对类型无效的操作                                   |\n| ValueError                | 传入无效的参数                                     |\n| UnicodeError              | Unicode 相关的错误                                 |\n| UnicodeDecodeError        | Unicode 解码时的错误                               |\n| UnicodeEncodeError        | Unicode 编码时错误                                 |\n| UnicodeTranslateError     | Unicode 转换时错误                                 |\n| Warning                   | 警告的基类                                         |\n| DeprecationWarning        | 关于被弃用的特征的警告                             |\n| FutureWarning             | 关于构造将来语义会有改变的警告                     |\n| OverflowWarning           | 旧的关于自动提升为长整型(long)的警告               |\n| PendingDeprecationWarning | 关于特性将会被废弃的警告                           |\n| RuntimeWarning            | 可疑的运行时行为(runtime behavior)的警告           |\n| SyntaxWarning             | 可疑的语法的警告                                   |\n| UserWarning               | 用户代码生成的警告                                 |\n\n## 4.自定义异常\n\npython的自定义异常只需要将自定义异常类继承自python标准异常类即可。\n\n# 十一、面向对象\n\npython在设计之初就已经是一门面向对象的语言了，在python中一切皆对象，包括所有的基础类型也是对象，这使得python在创建类和对象时十分容易，但是这也导致python十分消耗内存空间，因为哪怕只创建一个整型也会消耗对于C语言的内存空间。\n\n## 1.定义类\n\n和大多数语言一样，python也使用`class`关键字来标识类，使用同等量的缩进来标识类的范围，如：\n\n```python\nclass Person:\n    age = 0\n    name = ''\n    __id = 1\n    _sex = 'female'\n\n    def __init__(self, age, name):\n        self.age = age\n        self.name = name\n\n    def GetName(this):\n        print('my name is ' + this.name)\n    \n    def __SetId():\n        id = 001\n\n\np = Person(18, 'lusa')\np.GetName()\n```\n\n## 2.成员变量\n\n### 私有成员变量\n\n由于python无法使用public，private等关键字，所以python使用双下划线开头来标识私有成员变量。如上面代码中的`__id`。\n\n### 保护成员变量\n\npython使用单下划线开头来标识保护成员变量，如上面代码中的`_sex`。\n\n### 公有成员变量\n\n不带有任何前缀的变量的就是公有成员变量。\n\n\n\n## 3.成员函数\n\n### 私有函数、保护函数和公有函数\n\n和变量一样，python使用双下划线来前缀来标识私有函数，用单下划线前缀来标识保护函数，无前缀函数表示公有函数。\n\n### self参数\n\n<font color =red>与其他语言不同的是，python的函数都必须带有一个self参数，self参数的在效果上与C++的this指针很像，但是python的self参数不是类自带的，在定义函数时需要手动显示表示，且必须放在函数的第一个参数位置，self参数的名字不一定非得叫self也可以叫其他的名字，如上面代码中的GetName函数的this，但是按照python的规范建议将都是用self命名，self参数指向当前类实例，类的实例变量都必须使用self参数才能访问，直接使用是无法访问的，如：</font>\n\n```python\nclass Person:\n    age = 0\n\n    def __init__(self, param):\n        age = param\n```\n\n不通过self参数访问类的成员变量将直接报语法错误。\n\n## 4.类变量、实例变量和局部变量\n\n### 类变量\n\n定义在类的内部且定义在方法体外的变量，如上面代码中age，<font color=red>类变量可以被类直接访问，也可以被实例直接访问，同时可以被实例方法和类方法方法访问，但是不可以被静态方法访问</font>。如：\n\n```python\nclass Person:\n    names = 'aa'\n\n    def __init__(self, age, name):\n        self.age = age\n        self.name = name\n        addr = 'beijing'\n        names = \"bb\"\n\n    def GetName(self):\n        self.sex = 'female'\n        print('my name is ' + self.names)\n\n    @staticmethod\n    def PP():\n        print(names)\n    \n    @classmethod\n    def OO(cls):       \n        print(cls.names)\n\n\np = Person(18, \"lusa\")\nprint(p.names)\np.names = \"cc\"\np.GetName()\nprint(Person.names)\nPerson.names = \"dd\"\nPerson.OO()\nprint(p.names)\nPerson.PP()\n```\n\n输出结果：\n\n```python\naa\nmy name is cc\naa\ndd\ncc\nTraceback (most recent call last):\n  File \"d:\\Codes\\Python\\MyFirstPython.py\", line 31, in <module>\n    Person.PP()\n  File \"d:\\Codes\\Python\\MyFirstPython.py\", line 16, in PP\n    print(names)\nNameError: name 'names' is not definedd\n```\n\n可以看到，类变量names初始值为aa，我们的本意是在构造函数中再赋值bb但是再实际输出中names的值依旧是aa，当我们使用实例给类变量names赋值为cc时，输出GetName函数输出就变为了cc，然而直接通过类名访问的结果依旧是aa，当我们通过类名赋值names为dd时，类方法输出的结果就变为了dd，然而用实例访问的结果依旧时cc，最终运行到类的静态方法PP处则报错了，由上结果可得出结论：\n\n- 类在创建实例时会拷贝一份类变量到实例中，实例中类变量和类中的类变量互相独立\n- 构造函数不可以初始化类变量，当我们在构造函数初始化一个类变量的同名变量时，实际上python初始化的是一个和类变量同名的局部变量\n- 同一个类变量既可以被类实例访问也可以被类名直接访问，但二者内存地址时两个内存地址\n- 静态方法不可以访问类变量\n\n### 实例变量\n\n实例变量是定义在构造函数内部且通过self引出的变量，这两点十分重要，如果一个变量不是在构造函数里创建即使通过self引出也依旧不是实例变量，或一个变量在构造函数中创建但不是由self引出，那它也不是实例变量，而是函数的局部变量，如：上面代码中self.sex，和构造函数里的addr和names，我们是不可以使用实例访问的。\n\n### 局部变量\n\n在构造函数中创建的不由self引出的变量或在其他方法中创建的变量，如上面代码中GetName啊哈桑农户里的self.sex和构造函数里的addr和names\n\n## 5.类方法、实例方法和静态方法\n\n被`@classmethod`修饰的方法就是类方法，被`@staticmethod`修饰的方法就是静态方法，除此之外其余的方法都是实例方法。类方法和静态方法也有保护级。\n\n### 类方法\n\n类方法属于类，可以直接通过类型访问，也可以同通过实例访问，访问效果是一样的。在创建类方法时必须至少需要一个参数，一般命名为`cls`，用于python传递默认参数–类。如：\n\n```python\n@classmethod\ndef OO(cls):\n    print(cls.names)\n```\n\ncls不可省略，在类方法中只能通过cls来访问类变量，且只能访问类变量。\n\n### 静态方法\n\n静态方法同类方法很相似，也可以被类名和实例直接访问。不同的是，静态方法不需要cls参数，python不会传递默认参数到静态方法，静态方法不可以直接访问类的任何成员。\n\n### 嵌套函数\n\npython支持方法中嵌套创建方法，如：\n\n```python\ndef funa():\n    a = 1\n    print(a)\n\n    def funb():\n        nonlocal a\n        a += 1\n        print(a)\n   \n    funb()\n\n\nfuna()\n```\n\n# 十二、作用域\n\npython的作用域大部分与C系列语言的作用域差不多，只是有三点比较特殊：\n\n- python中只有类、函数、模块才会引入新的作用域，控制语句不会引入新的作用域，也就是说，在控制语句中创建的变量可以在控制语句外部被访问\n\n  如：\n\n  ```python\n  for i in range(3):\n      print(i)\n  \n  print(i)\n  ```\n\n  输出结果：\n\n  ```python\n  0\n  1\n  2\n  2\n  ```\n\n- 如果要在函数内部访问全局变量需要在在函数内部使用`global`申明，否则python将创建一个同名的局部变量而不是引用全局变量\n\n  如：\n\n  ```python\n  a = 1\n  \n  \n  def fun():\n      a += 1\n  ```\n\n  python会直接报语法错误，因为我们使用了一个未定义的局部变量，但是当我们使用global申明之后，我们访问的就是全局变量了，如：\n\n  ```python\n  a = 1\n  \n  \n  def fun():\n      global a\n      a += 1\n  ```\n\n- 如果要在嵌套函数中访问外层函数的变量需要使用`nonlocal`申明，否则python也会创建一个同名的局部函数，如：\n\n  ```python\n  a = 1\n  \n  \n  def fun():\n      global a\n      a += 1\n      b = 2\n  \n      def funb():\n          global a\n          nonlocal b\n          b += 1\n          print(a)\n          print(b)\n  \n      funb()\n  \n  \n  fun()\n  ```\n\n  输出结果：\n\n  ```python\n  2\n  3\n  ```\n\n  \n\n","slug":"【Python】Python学习笔记","published":1,"updated":"2021-02-23T08:00:52.640Z","_id":"cklakss1f00008gr776mod2zv","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<center><font size=\"6\"><strong>Python基础</strong></font></center>\n\n<a id=\"more\"></a>\n\n<h1 id=\"一、中文编码、注释与标准文档\"><a href=\"#一、中文编码、注释与标准文档\" class=\"headerlink\" title=\"一、中文编码、注释与标准文档\"></a>一、中文编码、注释与标准文档</h1><h2 id=\"1-中文编码\"><a href=\"#1-中文编码\" class=\"headerlink\" title=\"1.中文编码\"></a>1.中文编码</h2><p>若只需要在单个文件中指定中文编码，只需在文件开始处添加</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># _*_ coding: UTF-8 _*_</span><br></code></pre></td></tr></table></figure>\n<p>即可。</p>\n<p>如果要在整个工程里设置中文编码，则需要在编辑器中设置工程的编码为UTF-8。</p>\n<h2 id=\"2-单行注释\"><a href=\"#2-单行注释\" class=\"headerlink\" title=\"2.单行注释\"></a>2.单行注释</h2><p>python使用<code>#</code>来接单行注释</p>\n<h2 id=\"3-多行注释\"><a href=\"#3-多行注释\" class=\"headerlink\" title=\"3.多行注释\"></a>3.多行注释</h2><p>python使用<code>&#39;&#39;&#39;</code>或<code>&quot;&quot;&quot;</code>（三个单引号或三个双引号）来包含多行注释</p>\n<p>如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># 这是单行注释</span><br><span class=\"hljs-string\">&#x27;&#x27;&#x27;</span><br><span class=\"hljs-string\">这是使用三个单引号的</span><br><span class=\"hljs-string\">多行注释</span><br><span class=\"hljs-string\">&#x27;&#x27;&#x27;</span><br><span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">这是使用三个双引号的</span><br><span class=\"hljs-string\">多行注释</span><br><span class=\"hljs-string\">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"4-标准文档\"><a href=\"#4-标准文档\" class=\"headerlink\" title=\"4.标准文档\"></a>4.标准文档</h2><p><a href=\"https://docs.python.org/zh-cn/3.7/library/index.html\">官方文档</a></p>\n<h1 id=\"二、标识符与代码块\"><a href=\"#二、标识符与代码块\" class=\"headerlink\" title=\"二、标识符与代码块\"></a>二、标识符与代码块</h1><h2 id=\"1-标识符规则\"><a href=\"#1-标识符规则\" class=\"headerlink\" title=\"1.标识符规则\"></a>1.标识符规则</h2><ul>\n<li>python标识符大小写敏感。</li>\n<li>python中以下划线开头的标识符有特殊的含义，以单下划线开头的标识符代表不能直接访问的类属性，需要通过类提供的接口进行访问，不能用from xxx import *导入，如：_value。</li>\n<li>以双下划线开头的标识符代表类的私有成员，如：<code>__value</code>。</li>\n<li>以双下划线开头和结尾的标识符代表python里特殊方法的专用标识符，如：<code>__init__()</code>代表类的构造函数。</li>\n</ul>\n<h2 id=\"2-保留字符\"><a href=\"#2-保留字符\" class=\"headerlink\" title=\"2.保留字符\"></a>2.保留字符</h2><table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\"></th>\n<th align=\"center\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">and</td>\n<td align=\"center\">exec</td>\n<td align=\"center\">not</td>\n</tr>\n<tr>\n<td align=\"center\">assert</td>\n<td align=\"center\">finally</td>\n<td align=\"center\">or</td>\n</tr>\n<tr>\n<td align=\"center\">break</td>\n<td align=\"center\">for</td>\n<td align=\"center\">pass</td>\n</tr>\n<tr>\n<td align=\"center\">class</td>\n<td align=\"center\">from</td>\n<td align=\"center\">print</td>\n</tr>\n<tr>\n<td align=\"center\">continue</td>\n<td align=\"center\">global</td>\n<td align=\"center\">raise</td>\n</tr>\n<tr>\n<td align=\"center\">def</td>\n<td align=\"center\">if</td>\n<td align=\"center\">return</td>\n</tr>\n<tr>\n<td align=\"center\">del</td>\n<td align=\"center\">import</td>\n<td align=\"center\">try</td>\n</tr>\n<tr>\n<td align=\"center\">elif</td>\n<td align=\"center\">in</td>\n<td align=\"center\">while</td>\n</tr>\n<tr>\n<td align=\"center\">else</td>\n<td align=\"center\">is</td>\n<td align=\"center\">with</td>\n</tr>\n<tr>\n<td align=\"center\">except</td>\n<td align=\"center\">lambda</td>\n<td align=\"center\">yield</td>\n</tr>\n</tbody></table>\n<h2 id=\"3-代码块\"><a href=\"#3-代码块\" class=\"headerlink\" title=\"3.代码块\"></a>3.代码块</h2><p>python与C系列语言最大的不同就是python没有了<code>&#123;&#125;</code>囊括的代码块，而采用了<font color=\"red\">缩进</font>来表示代码块，即在一个代码块中的代码采用同等数量的数量的缩进，缩进的数量按空格的数量计算，采用同一缩进量的代码属于同一格代码块。</p>\n<p>如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">if</span> ture:<br>    a = <span class=\"hljs-number\">1</span><br>    b = <span class=\"hljs-number\">2</span><br></code></pre></td></tr></table></figure>\n<p><code>a=1;</code>与<code>b=2</code>同属于if语句的代码块中。</p>\n<h3 id=\"python空行规范\"><a href=\"#python空行规范\" class=\"headerlink\" title=\"python空行规范\"></a>python空行规范</h3><ul>\n<li><p>类与其他代码块之间需要空两行</p>\n</li>\n<li><p>方法体与其他代码块之间需要空一行</p>\n</li>\n<li><p>全局函数与其他代码块之间需要空两行</p>\n<p>如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span>:</span><br>    names = <span class=\"hljs-string\">&#x27;aa&#x27;</span><br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__init__</span>(<span class=\"hljs-params\">self, age, name</span>):</span><br>        self.age = age<br>        self.name = name<br>        addr = <span class=\"hljs-string\">&#x27;beijing&#x27;</span><br>        names = <span class=\"hljs-string\">&quot;bb&quot;</span><br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">GetName</span>(<span class=\"hljs-params\">self</span>):</span><br>        self.sex = <span class=\"hljs-string\">&#x27;female&#x27;</span><br>        print(<span class=\"hljs-string\">&#x27;my name is &#x27;</span> + self.names)<br><br><span class=\"hljs-meta\">    @staticmethod</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">PP</span>():</span><br>        print(names)<br>    <br><span class=\"hljs-meta\">    @classmethod</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">OO</span>(<span class=\"hljs-params\">cls</span>):</span>       <br>        print(cls.names)<br><br><br>p = Person(<span class=\"hljs-number\">18</span>, <span class=\"hljs-string\">&#x27;lusa&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n\n</li>\n</ul>\n<h2 id=\"4-多行语句\"><a href=\"#4-多行语句\" class=\"headerlink\" title=\"4.多行语句\"></a>4.多行语句</h2><p>由于python即使用了<code>;</code>来分割同行的不同语句，同时通过新行来结束上一句语句，所以如果代码需要换行的话需要使用<font color=\"red\"> <code>\\</code></font>来分割多行。</p>\n<p>如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">a = b \\<br>\t+ c \\<br>    + d<br></code></pre></td></tr></table></figure>\n<p><font color=\"green\"> <strong>例外</strong>：包括在<code>[]</code>、<code>()</code>、<code>&#123;&#125;</code>中的语句换行不需要使用<code>\\</code>。</font></p>\n<h1 id=\"三、变量及数据结构\"><a href=\"#三、变量及数据结构\" class=\"headerlink\" title=\"三、变量及数据结构\"></a>三、变量及数据结构</h1><p>python支持</p>\n<ul>\n<li>Numbers-数字</li>\n<li>String-字符串</li>\n<li>List-列表</li>\n<li>Tuple-原表</li>\n<li>Dictionary-字典</li>\n</ul>\n<p>几种数据类型。</p>\n<h2 id=\"1-Numbers\"><a href=\"#1-Numbers\" class=\"headerlink\" title=\"1.Numbers\"></a>1.Numbers</h2><p>其中Numbers又分为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mermaid\">graph LR;<br>Numbers---int---有符号整型;<br>Numbers---long---长整型-使用小写l或大写L表示;<br>Numbers---float---浮点型;<br>Numbers---complex---复数-使用a+bj表示或complex函数生成;<br></code></pre></td></tr></table></figure>\n<p>需要注意的是python不支持double。</p>\n<p><font color=\"red\"> long在python3.x以后被移除。</font></p>\n<h2 id=\"2-String\"><a href=\"#2-String\" class=\"headerlink\" title=\"2.String\"></a>2.String</h2><p><font color=\"red\">使用Python字符串时首先需要明确一点，就是Python不支持单字符，在Python中单字符也被当作字符串使用。</font></p>\n<p>Python的字符串可以使用<code>&#39;</code>,<code>&quot;</code>,<code>&#39;&#39;&#39;</code>,<code>&quot;&quot;&quot;</code>来标识字符串，有单引号和双引号来表示字符串就够了，那么为什么Python要使用三单引号<code>&#39;&#39;&#39;</code>和三双引号<code>&quot;&quot;&quot;</code>来标识字符串呢？</p>\n<h3 id=\"39-39-39-和-quot-quot-quot-的优点\"><a href=\"#39-39-39-和-quot-quot-quot-的优点\" class=\"headerlink\" title=\"&#39;&#39;&#39;和&quot;&quot;&quot;的优点\"></a><code>&#39;&#39;&#39;</code>和<code>&quot;&quot;&quot;</code>的优点</h3><p>要想直观的了解三单引号和三双引号的优点，我们首先使用C#字符串来写一个SQL语句</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C#\"><span class=\"hljs-built_in\">string</span> sql=<span class=\"hljs-string\">&quot;select xm as 姓名,xb as 性别 from db_table where xm = @xm and xb = @xb and (bm like &#x27;%666&#x27; or bm like &#x27;666%&#x27;) order by grade &gt; 90 desc&quot;</span>;<br>OleDbCommand cmd = <span class=\"hljs-keyword\">new</span> OleDbCommand();<br>cmd.CommandText = sql;<br>cmd.Parameters.AddWithValue(<span class=\"hljs-string\">&quot;@xm&quot;</span>, txtName.Text);<br>cmd.Parameters.AddWithValue(<span class=\"hljs-string\">&quot;@xb&quot;</span>, txtSex.Text);<br>cmd.Connection = conn;<br>conn.Open();<br>cmd.ExecuteNonQuery();<br></code></pre></td></tr></table></figure>\n<p>我们再使用Python写一句同样的SQL语句</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Python\">sql = <span class=\"hljs-string\">&#x27;&#x27;&#x27;</span><br><span class=\"hljs-string\">select xm as 姓名,xb as 性别 from db_table </span><br><span class=\"hljs-string\">where xm = &#x27;&#123;0&#125;&#x27; and xb = &#123;1&#125; and (bm like &#x27;%666&#x27; or bm like &#x27;666%&#x27;) </span><br><span class=\"hljs-string\">order by grade &gt; 90 desc</span><br><span class=\"hljs-string\">&#x27;&#x27;&#x27;</span>.<span class=\"hljs-built_in\">format</span>(txtName.Text,txtSex.Text)<br>cuesor = conn.cursor()<br>cursor.execute(sql)<br>cursor.close()<br></code></pre></td></tr></table></figure>\n<p>有没有发现Python在写sql字符串时十分优雅呢？尤其是在写很长的sql语句时这个效果尤为突出，得益于Python三引号字符串的可换行支持，Python的sql可以在传参的同时保留sql的优雅格式，极大的提高了sql的可阅读性。</p>\n<p>python的字符串是不可变的，当我们对字符串进行操作时，python都会生成新的字符串，而不会在旧的字符串的基础上进行修改。</p>\n<ul>\n<li>与C系列语言对字符串的操作有些差异的是python使用<code>*</code>来重复字符串，如：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-built_in\">str</span> = <span class=\"hljs-string\">&#x27;a&#x27;</span><br>str2 = <span class=\"hljs-built_in\">str</span>*<span class=\"hljs-number\">2</span> <span class=\"hljs-comment\">#str2存储的是&#x27;aa&#x27;</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li>String支持从前索引和从后索引，从前索引的首地址索引为0，从后索引的末地址为-1</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">a</th>\n<th align=\"center\">b</th>\n<th align=\"center\">c</th>\n<th align=\"center\">d</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">2</td>\n<td align=\"center\">3</td>\n</tr>\n<tr>\n<td align=\"center\">-4</td>\n<td align=\"center\">-3</td>\n<td align=\"center\">-2</td>\n<td align=\"center\">-1</td>\n</tr>\n</tbody></table>\n<ul>\n<li>python支持直接通过索引截取子字符串，如：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-built_in\">str</span> = <span class=\"hljs-string\">&#x27;abcd&#x27;</span><br>str2 = <span class=\"hljs-built_in\">str</span>[<span class=\"hljs-number\">1</span>:<span class=\"hljs-number\">3</span>] <span class=\"hljs-comment\">#str2存储的是&#x27;bc&#x27;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"转移字符\"><a href=\"#转移字符\" class=\"headerlink\" title=\"转移字符\"></a>转移字符</h3><table>\n<thead>\n<tr>\n<th>字符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>\\</code>(在行尾时)</td>\n<td>续行符</td>\n</tr>\n<tr>\n<td>\\</td>\n<td>反斜杠符号</td>\n</tr>\n<tr>\n<td>&#39;</td>\n<td>单引号</td>\n</tr>\n<tr>\n<td>&quot;</td>\n<td>双引号</td>\n</tr>\n<tr>\n<td>\\a</td>\n<td>响铃</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>退格(Backspace)</td>\n</tr>\n<tr>\n<td>\\e</td>\n<td>转义</td>\n</tr>\n<tr>\n<td>\\000</td>\n<td>空</td>\n</tr>\n<tr>\n<td>\\n</td>\n<td>换行</td>\n</tr>\n<tr>\n<td>\\v</td>\n<td>纵向制表符</td>\n</tr>\n<tr>\n<td>\\t</td>\n<td>横向制表符</td>\n</tr>\n<tr>\n<td>\\r</td>\n<td>回车</td>\n</tr>\n<tr>\n<td>\\f</td>\n<td>换页</td>\n</tr>\n<tr>\n<td>\\oyy</td>\n<td>八进制数，y 代表 0~7 的字符，例如：\\012 代表换行</td>\n</tr>\n<tr>\n<td>\\xyy</td>\n<td>十六进制数，以 \\x 开头，yy代表的字符，例如：\\x0a代表换行</td>\n</tr>\n<tr>\n<td>\\other</td>\n<td>其它的字符以普通格式输出</td>\n</tr>\n</tbody></table>\n<h3 id=\"两个特殊的字符串运算符\"><a href=\"#两个特殊的字符串运算符\" class=\"headerlink\" title=\"两个特殊的字符串运算符\"></a>两个特殊的字符串运算符</h3><table>\n<thead>\n<tr>\n<th>字符</th>\n<th>说明</th>\n<th>实例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>r/R</td>\n<td><font color=\"red\">原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母<code>r</code>（可以大小写）以外，与普通字符串有着几乎完全相同的语法。</font></td>\n<td>print(r’/n’)<br>输出结果：<br>/n</td>\n</tr>\n<tr>\n<td>%</td>\n<td>格式字符串</td>\n<td></td>\n</tr>\n<tr>\n<td>u</td>\n<td>在字符串的前面加上一个字母u即表示创建Unicode字符串，可以通过<code>\\u</code>+Unicode编码向字符串中插入任何Unicode支持的字符</td>\n<td>print(u’a\\u2201a’)<br>输出结果：<br>a⤀a</td>\n</tr>\n</tbody></table>\n<h3 id=\"字符串格式化\"><a href=\"#字符串格式化\" class=\"headerlink\" title=\"字符串格式化\"></a>字符串格式化</h3><p>Python中的字符串格式化和C基本保持一致，插入整型也是用的<code>%d</code></p>\n<table>\n<thead>\n<tr>\n<th>符号</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>%c</td>\n<td>格式化字符及其ASCII码</td>\n</tr>\n<tr>\n<td>%s</td>\n<td>格式化字符串</td>\n</tr>\n<tr>\n<td>%d</td>\n<td>格式化整数</td>\n</tr>\n<tr>\n<td>%u</td>\n<td>格式化无符号整型</td>\n</tr>\n<tr>\n<td>%o</td>\n<td>格式化无符号八进制数</td>\n</tr>\n<tr>\n<td>%x</td>\n<td>格式化无符号十六进制数</td>\n</tr>\n<tr>\n<td>%X</td>\n<td>格式化无符号十六进制数（大写）</td>\n</tr>\n<tr>\n<td>%f</td>\n<td>格式化浮点数字，可指定小数点后的精度</td>\n</tr>\n<tr>\n<td>%e</td>\n<td>用科学计数法格式化浮点数</td>\n</tr>\n<tr>\n<td>%E</td>\n<td>作用同%e，用科学计数法格式化浮点数</td>\n</tr>\n<tr>\n<td>%g</td>\n<td>%f和%e的简写</td>\n</tr>\n<tr>\n<td>%G</td>\n<td>%F 和 %E 的简写</td>\n</tr>\n<tr>\n<td>%p</td>\n<td>用十六进制数格式化变量的地址</td>\n</tr>\n</tbody></table>\n<h3 id=\"格式化操作辅助指令\"><a href=\"#格式化操作辅助指令\" class=\"headerlink\" title=\"格式化操作辅助指令\"></a>格式化操作辅助指令</h3><table>\n<thead>\n<tr>\n<th>符号</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>*</td>\n<td>定义宽度或者小数点精度</td>\n</tr>\n<tr>\n<td>-</td>\n<td>用做左对齐</td>\n</tr>\n<tr>\n<td>+</td>\n<td>在正数前面显示加号( + )</td>\n</tr>\n<tr>\n<td><code>&lt;sp&gt;</code></td>\n<td>在正数前面显示空格</td>\n</tr>\n<tr>\n<td>#</td>\n<td>在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’)</td>\n</tr>\n<tr>\n<td>0</td>\n<td>显示的数字前面填充’0’而不是默认的空格</td>\n</tr>\n<tr>\n<td>%</td>\n<td>‘%%’输出一个单一的’%’</td>\n</tr>\n<tr>\n<td>(var)</td>\n<td>映射变量(字典参数)</td>\n</tr>\n<tr>\n<td>m.n.</td>\n<td>m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)</td>\n</tr>\n</tbody></table>\n<h3 id=\"String内置函数\"><a href=\"#String内置函数\" class=\"headerlink\" title=\"String内置函数\"></a>String内置函数</h3><table>\n<thead>\n<tr>\n<th align=\"left\"><strong>方法</strong></th>\n<th align=\"left\"><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-capitalize.html\">string.capitalize()</a></td>\n<td align=\"left\">把字符串的第一个字符大写</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-center.html\">string.center(width)</a></td>\n<td align=\"left\">返回一个原字符串居中,并使用空格填充至长度 width 的新字符串</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><a href=\"https://www.runoob.com/python/att-string-count.html\">string.count(str, beg=0, end=len(string))</a></strong></td>\n<td align=\"left\">返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-decode.html\">string.decode(encoding=’UTF-8’, errors=’strict’)</a></td>\n<td align=\"left\">以 encoding 指定的编码格式解码 string，如果出错默认报一个 ValueError 的 异 常 ， 除非 errors 指 定 的 是 ‘ignore’ 或 者’replace’</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-encode.html\">string.encode(encoding=’UTF-8’, errors=’strict’)</a></td>\n<td align=\"left\">以 encoding 指定的编码格式编码 string，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><a href=\"https://www.runoob.com/python/att-string-endswith.html\">string.endswith(obj, beg=0, end=len(string))</a></strong></td>\n<td align=\"left\">检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-expandtabs.html\">string.expandtabs(tabsize=8)</a></td>\n<td align=\"left\">把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><a href=\"https://www.runoob.com/python/att-string-find.html\">string.find(str, beg=0, end=len(string))</a></strong></td>\n<td align=\"left\">检测 str 是否包含在 string 中，如果 beg 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回-1</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><a href=\"https://www.runoob.com/python/att-string-format.html\">string.format()</a></strong></td>\n<td align=\"left\">格式化字符串</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><a href=\"https://www.runoob.com/python/att-string-index.html\">string.index(str, beg=0, end=len(string))</a></strong></td>\n<td align=\"left\">跟find()方法一样，只不过如果str不在 string中会报一个异常.</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-isalnum.html\">string.isalnum()</a></td>\n<td align=\"left\">如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True,否则返回 False</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-isalpha.html\">string.isalpha()</a></td>\n<td align=\"left\">如果 string 至少有一个字符并且所有字符都是字母则返回 True,否则返回 False</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-isdecimal.html\">string.isdecimal()</a></td>\n<td align=\"left\">如果 string 只包含十进制数字则返回 True 否则返回 False.</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-isdigit.html\">string.isdigit()</a></td>\n<td align=\"left\">如果 string 只包含数字则返回 True 否则返回 False.</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-islower.html\">string.islower()</a></td>\n<td align=\"left\">如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-isnumeric.html\">string.isnumeric()</a></td>\n<td align=\"left\">如果 string 中只包含数字字符，则返回 True，否则返回 False</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-isspace.html\">string.isspace()</a></td>\n<td align=\"left\">如果 string 中只包含空格，则返回 True，否则返回 False.</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-istitle.html\">string.istitle()</a></td>\n<td align=\"left\">如果 string 是标题化的(见 title())则返回 True，否则返回 False</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-isupper.html\">string.isupper()</a></td>\n<td align=\"left\">如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><a href=\"https://www.runoob.com/python/att-string-join.html\">string.join(seq)</a></strong></td>\n<td align=\"left\">以 string 作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-ljust.html\">string.ljust(width)</a></td>\n<td align=\"left\">返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-lower.html\">string.lower()</a></td>\n<td align=\"left\">转换 string 中所有大写字符为小写.</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-lstrip.html\">string.lstrip()</a></td>\n<td align=\"left\">截掉 string 左边的空格</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-maketrans.html\">string.maketrans(intab, outtab])</a></td>\n<td align=\"left\">maketrans() 方法用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-max.html\">max(str)</a></td>\n<td align=\"left\">返回字符串 <em>str</em> 中最大的字母。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-min.html\">min(str)</a></td>\n<td align=\"left\">返回字符串 <em>str</em> 中最小的字母。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><a href=\"https://www.runoob.com/python/att-string-partition.html\">string.partition(str)</a></strong></td>\n<td align=\"left\">有点像 find()和 split()的结合体,从 str 出现的第一个位置起,把 字 符 串 string 分 成 一 个 3 元 素 的 元 组 (string_pre_str,str,string_post_str),如果 string 中不包含str 则 string_pre_str == string.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><a href=\"https://www.runoob.com/python/att-string-replace.html\">string.replace(str1, str2, num=string.count(str1))</a></strong></td>\n<td align=\"left\">把 string 中的 str1 替换成 str2,如果 num 指定，则替换不超过 num 次.</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-rfind.html\">string.rfind(str, beg=0,end=len(string) )</a></td>\n<td align=\"left\">类似于 find() 函数，返回字符串最后一次出现的位置，如果没有匹配项则返回 -1。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-rindex.html\">string.rindex( str, beg=0,end=len(string))</a></td>\n<td align=\"left\">类似于 index()，不过是从右边开始.</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-rjust.html\">string.rjust(width)</a></td>\n<td align=\"left\">返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-rpartition.html\">string.rpartition(str)</a></td>\n<td align=\"left\">类似于 partition()函数,不过是从右边开始查找</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-rstrip.html\">string.rstrip()</a></td>\n<td align=\"left\">删除 string 字符串末尾的空格.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><a href=\"https://www.runoob.com/python/att-string-split.html\">string.split(str=””, num=string.count(str))</a></strong></td>\n<td align=\"left\">以 str 为分隔符切片 string，如果 num 有指定值，则仅分隔 num+ 个子字符串</td>\n</tr>\n<tr>\n<td align=\"left\">[string.splitlines(<a href=\"https://www.runoob.com/python/att-string-splitlines.html\">keepends])</a></td>\n<td align=\"left\">按照行(‘\\r’, ‘\\r\\n’, \\n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-startswith.html\">string.startswith(obj, beg=0,end=len(string))</a></td>\n<td align=\"left\">检查字符串是否是以 obj 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>[string.strip(<a href=\"https://www.runoob.com/python/att-string-strip.html\">obj])</a></strong></td>\n<td align=\"left\">在 string 上执行 lstrip()和 rstrip()</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-swapcase.html\">string.swapcase()</a></td>\n<td align=\"left\">翻转 string 中的大小写</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-title.html\">string.title()</a></td>\n<td align=\"left\">返回”标题化”的 string,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><a href=\"https://www.runoob.com/python/att-string-translate.html\">string.translate(str, del=””)</a></strong></td>\n<td align=\"left\">根据 str 给出的表(包含 256 个字符)转换 string 的字符,要过滤掉的字符放到 del 参数中</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-upper.html\">string.upper()</a></td>\n<td align=\"left\">转换 string 中的小写字母为大写</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-zfill.html\">string.zfill(width)</a></td>\n<td align=\"left\">返回长度为 width 的字符串，原字符串 string 右对齐，前面填充0</td>\n</tr>\n</tbody></table>\n<h2 id=\"3-Tuple\"><a href=\"#3-Tuple\" class=\"headerlink\" title=\"3.Tuple\"></a>3.Tuple</h2><p>==元组类似与C#中<code>readonly List</code>，是一个只读列表，但是python的元组的元素可以是不同的类型，python用<code>()</code>来表示元组。==元组支持存储不同类型元素，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">t = (<span class=\"hljs-string\">&#x27;a&#x27;</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">3.14</span>)<br></code></pre></td></tr></table></figure>\n<p>这里的元组只读及元素不可修改</p>\n<h3 id=\"创建空元组\"><a href=\"#创建空元组\" class=\"headerlink\" title=\"创建空元组\"></a>创建空元组</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">t = ()<br></code></pre></td></tr></table></figure>\n<h3 id=\"创建一个值的元组\"><a href=\"#创建一个值的元组\" class=\"headerlink\" title=\" 创建一个值的元组\"></a><font color=\"red\"> 创建一个值的元组</font></h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">t = (<span class=\"hljs-number\">12</span>,)//逗号不可省略<br></code></pre></td></tr></table></figure>\n<p><font color=\"red\"> 需要特别注意的是<code>,</code>不可省略，如果省略了，<code>t=(12)</code>就等于<code>t=12</code></font></p>\n<h3 id=\"元组的分片操作\"><a href=\"#元组的分片操作\" class=\"headerlink\" title=\"元组的分片操作\"></a>元组的分片操作</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">t = (<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>)<br>print(t[<span class=\"hljs-number\">1</span>:<span class=\"hljs-number\">3</span>])<br><span class=\"hljs-comment\">#输出结果为2，3</span><br></code></pre></td></tr></table></figure>\n<p>分片操作可以批量的取元组中的数据，值不能取到3号索引，只能取到3号索引的前一位。</p>\n<h3 id=\"Tuple的-和-操作\"><a href=\"#Tuple的-和-操作\" class=\"headerlink\" title=\"Tuple的+和*操作\"></a>Tuple的+和*操作</h3><p>和字符串一样，列表的+运算用于组合列表，列表的*运算用于重复列表，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">tu1 = (<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>)<br>tu2 = tu1 + tu1<br>print(tu2)<br>tu3 = tu1*<span class=\"hljs-number\">3</span><br>print(tu3)<br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\">[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]<br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]  <br></code></pre></td></tr></table></figure>\n<h3 id=\"Tuple的无关分隔符\"><a href=\"#Tuple的无关分隔符\" class=\"headerlink\" title=\"Tuple的无关分隔符\"></a>Tuple的无关分隔符</h3><p>任意无符号对象，只要以<code>,</code>分隔，Python都将其是为元组，如</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-built_in\">print</span> <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">3.14</span><br>tu = x, y = <span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span><br></code></pre></td></tr></table></figure>\n<p><code>1, 2, &#39;a&#39;, 3.14</code>，会被视为一个元组，及print打印的事实上是一个元组，tu也会被Python默认转换成一个元组，当然x，y还是可以才开使用的。</p>\n<h3 id=\"Python内置元组操作函数\"><a href=\"#Python内置元组操作函数\" class=\"headerlink\" title=\"Python内置元组操作函数\"></a>Python内置元组操作函数</h3><table>\n<thead>\n<tr>\n<th align=\"left\">方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-tuple-cmp.html\">cmp(tuple1, tuple2)</a></td>\n<td>比较两个元组元素。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-tuple-len.html\">len(tuple)</a></td>\n<td>计算元组元素个数。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-tuple-max.html\">max(tuple)</a></td>\n<td>返回元组中元素最大值。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-tuple-min.html\">min(tuple)</a></td>\n<td>返回元组中元素最小值。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-tuple-tuple.html\">tuple(seq)</a></td>\n<td>将列表转换为元组。</td>\n</tr>\n</tbody></table>\n<h2 id=\"4-List\"><a href=\"#4-List\" class=\"headerlink\" title=\"4.List\"></a>4.List</h2><p>List就和C#中的List基本一致，但是python的List更灵活</p>\n<h3 id=\"List初始化\"><a href=\"#List初始化\" class=\"headerlink\" title=\"List初始化\"></a>List初始化</h3><p>List的初始化使用<code>[]</code>，我们可以使用‘数字’、‘字符串’、‘元组’或‘列表’来初始化一个列表，列表也支持分片操作。</p>\n<p>python的列表可以在一个列表中存储不同类型的元素。</p>\n<p>并且提供一些基础函数</p>\n<ul>\n<li><p>index：从列表中找出某个元素的位置，如果有多个相同的元素，则返回第一个元素的位置，如果没有找到则抛出异常。</p>\n</li>\n<li><p>count：统计某个元素在列表中出现的次数。</p>\n</li>\n<li><p>append：列表末尾增加新的元素。</p>\n</li>\n<li><p>extend：将一个新列表的元素添加到原列表中。</p>\n<p>注意到，虽然 append 和 extend 可接收一个列表作为参数，但是 append 方法是将其作为一个元素添加到列表中，而 extend 则是将新列表的元素逐个添加到原列表中。</p>\n</li>\n<li><p>insert：将某个元素添加到某个位置。</p>\n</li>\n<li><p>pop：移除列表中的一个元素（默认是最后一个），并且返回该元素的值。</p>\n</li>\n<li><p>remove：移除列表中的某个匹配元素，如果有多个匹配，则移除第一个。</p>\n</li>\n<li><p>reverse：将列表中的元素进行反转。</p>\n</li>\n<li><p>sort：对列表进行排序，注意该方法会改变原来的列表，而不是返回新的排序列表，另外，sort 方法的返回值是空。</p>\n<p>如果要使用sort对列表进行排序，那么列表中元素应该保持同一类型。</p>\n</li>\n<li><p>clear：清空列表。</p>\n</li>\n</ul>\n<h3 id=\"列表的集合运算\"><a href=\"#列表的集合运算\" class=\"headerlink\" title=\"列表的集合运算\"></a>列表的集合运算</h3><p>Python提供内置的<code>set()</code>函数来对元素集进行集合运算，set函数支持所有可迭代的对象，包括list和tuple。只要是set函数支持的对象，尽管进行运算的两个对象不是相同类型也依旧可以进行集合运算，如：</p>\n<p><strong>取交集</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">l1 = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-literal\">True</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]<br>l2 = (<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-literal\">True</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>)<br>print(<span class=\"hljs-built_in\">set</span>(l1) &amp; <span class=\"hljs-built_in\">set</span>(l2))<br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">&#123;<span class=\"hljs-number\">1</span>， <span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;a&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>\n<p><font color=\"red\"> 注意：当bool值进行集合运算时会被转换成0和1，但是这个0和1不会和数字的0和1重复。</font></p>\n<p>Python集合运算符</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>|</td>\n<td>取并集</td>\n</tr>\n<tr>\n<td>&amp;</td>\n<td>取交集</td>\n</tr>\n<tr>\n<td>-</td>\n<td>取差集</td>\n</tr>\n<tr>\n<td>^</td>\n<td>取对称差集</td>\n</tr>\n</tbody></table>\n<p><font color=\"red\"> 集合运算符支持<code>set()</code>函数返回的<code>set</code>集合作为运算对象。</font></p>\n<h3 id=\"List的-和-操作\"><a href=\"#List的-和-操作\" class=\"headerlink\" title=\"List的+和*操作\"></a>List的+和*操作</h3><p>和字符串一样，列表的+运算用于组合列表，列表的*运算用于重复列表，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">li = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]<br>li2 = li + li<br>print(li2)<br>li3 = li*<span class=\"hljs-number\">3</span><br>print(li3)<br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\">[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]<br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]  <br></code></pre></td></tr></table></figure>\n<h3 id=\"Python内置列表操作函数\"><a href=\"#Python内置列表操作函数\" class=\"headerlink\" title=\"Python内置列表操作函数\"></a>Python内置列表操作函数</h3><table>\n<thead>\n<tr>\n<th align=\"left\">函数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-list-cmp.html\">cmp(list1, list2)</a></td>\n<td>比较两个列表的元素</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-list-len.html\">len(list)</a></td>\n<td>列表元素个数</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-list-max.html\">max(list)</a></td>\n<td>返回列表元素最大值</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-list-min.html\">min(list)</a></td>\n<td>返回列表元素最小值</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-list-list.html\">list(seq)</a></td>\n<td>将元组转换为列表</td>\n</tr>\n</tbody></table>\n<h3 id=\"List内置函数\"><a href=\"#List内置函数\" class=\"headerlink\" title=\"List内置函数\"></a>List内置函数</h3><table>\n<thead>\n<tr>\n<th align=\"left\">方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-list-append.html\">list.append(obj)</a></td>\n<td>在列表末尾添加新的对象</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-list-count.html\">list.count(obj)</a></td>\n<td>统计某个元素在列表中出现的次数</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-list-extend.html\">list.extend(seq)</a></td>\n<td>在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-list-index.html\">list.index(obj)</a></td>\n<td>从列表中找出某个值第一个匹配项的索引位置</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-list-insert.html\">list.insert(index, obj)</a></td>\n<td>将对象插入列表</td>\n</tr>\n<tr>\n<td align=\"left\">[list.pop(<a href=\"https://www.runoob.com/python/att-list-pop.html\">index=-1])</a></td>\n<td>移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-list-remove.html\">list.remove(obj)</a></td>\n<td>移除列表中某个值的第一个匹配项</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-list-reverse.html\">list.reverse()</a></td>\n<td>反向列表中元素</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-list-sort.html\">list.sort(cmp=None, key=None, reverse=False)</a></td>\n<td>对原列表进行排序</td>\n</tr>\n</tbody></table>\n<h2 id=\"5-Dictionary\"><a href=\"#5-Dictionary\" class=\"headerlink\" title=\"5.Dictionary\"></a>5.Dictionary</h2><p>Python的字典和C#中的字典的用法基本一致，不同的时Python使用<code>&#123;&#125;</code>来创建字典，使用<code>:</code>来连接键值对，使用<code>,</code>来分割元素。如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">dic = &#123;<span class=\"hljs-string\">&#x27;a&#x27;</span>: <span class=\"hljs-literal\">True</span>, <span class=\"hljs-number\">2</span>: <span class=\"hljs-string\">&quot;Py&quot;</span>, <span class=\"hljs-string\">&quot;bb&quot;</span>: <span class=\"hljs-number\">3</span>&#125;<br></code></pre></td></tr></table></figure>\n<p>Python自定更强大的地方在于，Python字典在一个字典里支持不同类型的键和值。</p>\n<p><font color=\"red\"> 字典的键只能是数字、字符串或元组类型，而值没有任何要求。</font></p>\n<h3 id=\"Python内置字典操作函数\"><a href=\"#Python内置字典操作函数\" class=\"headerlink\" title=\"Python内置字典操作函数\"></a>Python内置字典操作函数</h3><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"https://www.runoob.com/python/att-dictionary-cmp.html\">cmp(dict1, dict2)</a></td>\n<td>比较两个字典元素。</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/att-dictionary-len.html\">len(dict)</a></td>\n<td>计算字典元素个数，即键的总数。</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/att-dictionary-str.html\">str(dict)</a></td>\n<td>输出字典可打印的字符串表示。</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/att-dictionary-type.html\">type(variable)</a></td>\n<td>返回输入的变量类型，如果变量是字典就返回字典类型。</td>\n</tr>\n</tbody></table>\n<h3 id=\"Dictionary内置函数\"><a href=\"#Dictionary内置函数\" class=\"headerlink\" title=\"Dictionary内置函数\"></a>Dictionary内置函数</h3><table>\n<thead>\n<tr>\n<th align=\"left\">函数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-dictionary-clear.html\">dict.clear()</a></td>\n<td>删除字典内所有元素</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-dictionary-copy.html\">dict.copy()</a></td>\n<td>返回一个字典的浅复制</td>\n</tr>\n<tr>\n<td align=\"left\">[dict.fromkeys(seq<a href=\"https://www.runoob.com/python/att-dictionary-fromkeys.html\">, val])</a></td>\n<td>创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-dictionary-get.html\">dict.get(key, default=None)</a></td>\n<td>返回指定键的值，如果值不在字典中返回default值</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-dictionary-has_key.html\">dict.has_key(key)</a></td>\n<td>如果键在字典dict里返回true，否则返回false</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-dictionary-items.html\">dict.items()</a></td>\n<td>以列表返回可遍历的(键, 值) 元组数组</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-dictionary-keys.html\">dict.keys()</a></td>\n<td>以列表返回一个字典所有的键</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-dictionary-setdefault.html\">dict.setdefault(key, default=None)</a></td>\n<td>和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-dictionary-update.html\">dict.update(dict2)</a></td>\n<td>把字典dict2的键/值对更新到dict里</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-dictionary-values.html\">dict.values()</a></td>\n<td>以列表返回字典中的所有值</td>\n</tr>\n<tr>\n<td align=\"left\">[pop(key<a href=\"https://www.runoob.com/python/python-att-dictionary-pop.html\">,default])</a></td>\n<td>删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/python-att-dictionary-popitem.html\">popitem()</a></td>\n<td>返回并删除字典中的最后一对键和值。</td>\n</tr>\n</tbody></table>\n<h2 id=\"6-日期和时间\"><a href=\"#6-日期和时间\" class=\"headerlink\" title=\"6.日期和时间\"></a>6.日期和时间</h2><p>Python的日期时间函数被放在了<code>time</code>、<code>datetime</code>和<code>calender</code>模块下，这里有几个点是需要注意的</p>\n<h3 id=\"time-time\"><a href=\"#time-time\" class=\"headerlink\" title=\"time.time()\"></a>time.time()</h3><p>time.time()函数返回的是从1970年1月1日午夜到当前时间所经过的总时长。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> time<br>print(time.time())<br><span class=\"hljs-comment\">#当前时间为：2021.2.6 09：51</span><br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-number\">1612576137.817901</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"time-localtime\"><a href=\"#time-localtime\" class=\"headerlink\" title=\"time.localtime()\"></a>time.localtime()</h3><p>那么如何输出当前时间呢？答案就是使用<code>time.localtime(time.time())</code>来计算当前时间。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> time<br>print(time.localtime(time.time()))<br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">time.struct_time(tm_year=<span class=\"hljs-number\">2021</span>, tm_mon=<span class=\"hljs-number\">2</span>, tm_mday=<span class=\"hljs-number\">6</span>, tm_hour=<span class=\"hljs-number\">9</span>, tm_min=<span class=\"hljs-number\">51</span>, tm_sec=<span class=\"hljs-number\">39</span>, tm_wday=<span class=\"hljs-number\">5</span>, tm_yday=<span class=\"hljs-number\">37</span>, tm_isdst=<span class=\"hljs-number\">0</span>)<br></code></pre></td></tr></table></figure>\n<p>可以看到，函数返回的不是格式化的<code>2021.2.6 9:51</code>而是一个<code>struct_time</code>时间元组，什么是时间元组？</p>\n<h3 id=\"时间元组\"><a href=\"#时间元组\" class=\"headerlink\" title=\"时间元组\"></a>时间元组</h3><p>很多Python函数用一个元组装起来的9组数字处理时间:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">字段</th>\n<th align=\"left\">值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">0</td>\n<td align=\"left\">4位数年</td>\n<td align=\"left\">2008</td>\n</tr>\n<tr>\n<td align=\"left\">1</td>\n<td align=\"left\">月</td>\n<td align=\"left\">1 到 12</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">日</td>\n<td align=\"left\">1到31</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">小时</td>\n<td align=\"left\">0到23</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">分钟</td>\n<td align=\"left\">0到59</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">秒</td>\n<td align=\"left\">0到61 (60或61 是闰秒)</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">一周的第几日</td>\n<td align=\"left\">0到6 (0是周一)</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">一年的第几日</td>\n<td align=\"left\">1到366 (儒略历)</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">夏令时</td>\n<td align=\"left\">-1, 0, 1, -1是决定是否为夏令时的旗帜</td>\n</tr>\n</tbody></table>\n<p>而struct_time就是其中之一，struct_time的结构：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">属性</th>\n<th align=\"left\">值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">0</td>\n<td align=\"left\">tm_year</td>\n<td align=\"left\">2021</td>\n</tr>\n<tr>\n<td align=\"left\">1</td>\n<td align=\"left\">tm_mon</td>\n<td align=\"left\">1 到 12</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">tm_mday</td>\n<td align=\"left\">1 到 31</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">tm_hour</td>\n<td align=\"left\">0 到 23</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">tm_min</td>\n<td align=\"left\">0 到 59</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">tm_sec</td>\n<td align=\"left\">0 到 61 (60或61 是闰秒)</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">tm_wday</td>\n<td align=\"left\">0到6 (0是周一)</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">tm_yday</td>\n<td align=\"left\">1 到 366(儒略历)</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">tm_isdst</td>\n<td align=\"left\">-1, 0, 1, -1是决定是否为夏令时的旗帜</td>\n</tr>\n</tbody></table>\n<h3 id=\"获取格式化时间\"><a href=\"#获取格式化时间\" class=\"headerlink\" title=\"获取格式化时间\"></a>获取格式化时间</h3><p>那么如何获取格式化时间呢？</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">print(time.asctime(time.localtime(time.time())))<br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">Sat Feb  <span class=\"hljs-number\">6</span> <span class=\"hljs-number\">10</span>:<span class=\"hljs-number\">28</span>:09 <span class=\"hljs-number\">2021</span><br></code></pre></td></tr></table></figure>\n<p>time.localtime()返回的是一个字符串，除此之外我们看还可以使用<font color=\"red\"><code>time.strftime()</code></font>函数来自定义时间格式化格式，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">print(time.strftime(<span class=\"hljs-string\">&quot;%H:%M:%S %Y-%m-%d&quot;</span>, time.localtime()))<br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-number\">10</span>:<span class=\"hljs-number\">51</span>:<span class=\"hljs-number\">12</span> <span class=\"hljs-number\">2021</span>-02-06<br></code></pre></td></tr></table></figure>\n<h3 id=\"时间日期格式化符号\"><a href=\"#时间日期格式化符号\" class=\"headerlink\" title=\"时间日期格式化符号\"></a>时间日期格式化符号</h3><table>\n<thead>\n<tr>\n<th>符号</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>%y</td>\n<td>两位数的年份表示（00-99）</td>\n</tr>\n<tr>\n<td>%Y</td>\n<td>四位数的年份表示（000-9999）</td>\n</tr>\n<tr>\n<td>%m</td>\n<td>月份（01-12）</td>\n</tr>\n<tr>\n<td>%d</td>\n<td>月内中的一天（0-31）</td>\n</tr>\n<tr>\n<td>%H</td>\n<td>24小时制小时数（0-23）</td>\n</tr>\n<tr>\n<td>%I</td>\n<td>12小时制小时数（01-12）</td>\n</tr>\n<tr>\n<td>%M</td>\n<td>分钟数（00-59）</td>\n</tr>\n<tr>\n<td>%S</td>\n<td>秒（00-59）</td>\n</tr>\n<tr>\n<td>%a</td>\n<td>本地简化星期名称</td>\n</tr>\n<tr>\n<td>%A</td>\n<td>本地完整星期名称</td>\n</tr>\n<tr>\n<td>%b</td>\n<td>本地简化的月份名称</td>\n</tr>\n<tr>\n<td>%B</td>\n<td>本地完整的月份名称</td>\n</tr>\n<tr>\n<td>%c</td>\n<td>本地相应的日期表示和时间表示</td>\n</tr>\n<tr>\n<td>%j</td>\n<td>年内的一天（001-366）</td>\n</tr>\n<tr>\n<td>%p</td>\n<td>本地A.M.或P.M.的等价符</td>\n</tr>\n<tr>\n<td>%U</td>\n<td>一年中的星期数（00-53）星期天为星期的开始</td>\n</tr>\n<tr>\n<td>%w</td>\n<td>星期（0-6），星期天为星期的开始</td>\n</tr>\n<tr>\n<td>%W</td>\n<td>一年中的星期数（00-53）星期一为星期的开始</td>\n</tr>\n<tr>\n<td>%x</td>\n<td>本地相应的日期表示</td>\n</tr>\n<tr>\n<td>%X</td>\n<td>本地相应的时间表示</td>\n</tr>\n<tr>\n<td>%Z</td>\n<td>当前时区的名称</td>\n</tr>\n<tr>\n<td>%%</td>\n<td>%号本身</td>\n</tr>\n</tbody></table>\n<h3 id=\"time与datetime库\"><a href=\"#time与datetime库\" class=\"headerlink\" title=\"time与datetime库\"></a>time与datetime库</h3><p>python处理时间处理time模块还可以使用datetime模块，那么time和datetime之间有什么区别呢？</p>\n<p>在 Python 文档里，<code>time</code>是归类在<code>Generic Operating System Services</code>中，换句话说， 它提供的功能是更加接近于操作系统层面的。通读<a href=\"https://docs.python.org/2.7/library/time.html\">文档</a>可知，time 模块是围绕着 Unix Timestamp 进行的。</p>\n<p>该模块主要包括一个类 <code>struct_time</code>，另外其他几个函数及相关常量。 需要注意的是在该模块中的大多数函数是调用了所在平台<code>C library</code>的同名函数， 所以要特别注意有些函数是平台相关的，可能会在不同的平台有不同的效果。另外一点是，由于是基于Unix Timestamp，所以其所能表述的日期范围被限定在 1970 - 2038 之间，如果你写的代码需要处理在前面所述范围之外的日期，那可能需要考虑使用<code>datetime</code>模块更好。</p>\n<p>datetime 比 time 高级了不少，可以理解为 datetime 基于 time 进行了封装，提供了更多实用的函数。</p>\n<table>\n<thead>\n<tr>\n<th>类</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>timedelta</td>\n<td>主要用于计算时间跨度</td>\n</tr>\n<tr>\n<td>tzinfo</td>\n<td>时区相关</td>\n</tr>\n<tr>\n<td>time</td>\n<td>只关注时间</td>\n</tr>\n<tr>\n<td>date</td>\n<td>只关注日期</td>\n</tr>\n<tr>\n<td>datetime</td>\n<td>同时有时间和日期</td>\n</tr>\n</tbody></table>\n<h3 id=\"calendar库\"><a href=\"#calendar库\" class=\"headerlink\" title=\"calendar库\"></a>calendar库</h3><p>calendar库主要用于处理日历，如：打印2021年2月的日历</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">print(calendar.month(<span class=\"hljs-number\">2021</span>, <span class=\"hljs-number\">1</span>))<br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">    January <span class=\"hljs-number\">2021</span><br>Mo Tu We Th Fr Sa Su<br>             <span class=\"hljs-number\">1</span>  <span class=\"hljs-number\">2</span>  <span class=\"hljs-number\">3</span><br> <span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">5</span>  <span class=\"hljs-number\">6</span>  <span class=\"hljs-number\">7</span>  <span class=\"hljs-number\">8</span>  <span class=\"hljs-number\">9</span> <span class=\"hljs-number\">10</span><br><span class=\"hljs-number\">11</span> <span class=\"hljs-number\">12</span> <span class=\"hljs-number\">13</span> <span class=\"hljs-number\">14</span> <span class=\"hljs-number\">15</span> <span class=\"hljs-number\">16</span> <span class=\"hljs-number\">17</span><br><span class=\"hljs-number\">18</span> <span class=\"hljs-number\">19</span> <span class=\"hljs-number\">20</span> <span class=\"hljs-number\">21</span> <span class=\"hljs-number\">22</span> <span class=\"hljs-number\">23</span> <span class=\"hljs-number\">24</span><br><span class=\"hljs-number\">25</span> <span class=\"hljs-number\">26</span> <span class=\"hljs-number\">27</span> <span class=\"hljs-number\">28</span> <span class=\"hljs-number\">29</span> <span class=\"hljs-number\">30</span> <span class=\"hljs-number\">31</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"time库内置函数\"><a href=\"#time库内置函数\" class=\"headerlink\" title=\"time库内置函数\"></a>time库内置函数</h3><table>\n<thead>\n<tr>\n<th align=\"left\">函数</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-time-altzone.html\">time.altzone</a></td>\n<td align=\"left\">返回格林威治西部的夏令时地区的偏移秒数。如果该地区在格林威治东部会返回负值（如西欧，包括英国）。对夏令时启用地区才能使用。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-time-asctime.html\">time.asctime([tupletime])</a></td>\n<td align=\"left\">接受时间元组并返回一个可读的形式为”Tue Dec 11 18:07:14 2008”（2008年12月11日 周二18时07分14秒）的24个字符的字符串。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-time-clock.html\">time.clock( )</a></td>\n<td align=\"left\">用以浮点数计算的秒数返回当前的CPU时间。用来衡量不同程序的耗时，比time.time()更有用。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-time-ctime.html\">time.ctime([secs])</a></td>\n<td align=\"left\">作用相当于asctime(localtime(secs))，未给参数相当于asctime()</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-time-gmtime.html\">time.gmtime([secs])</a></td>\n<td align=\"left\">接收时间戳（1970纪元后经过的浮点秒数）并返回格林威治天文时间下的时间元组t。注：t.tm_isdst始终为0</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-time-localtime.html\">time.localtime([secs])</a></td>\n<td align=\"left\">接收时间戳（1970纪元后经过的浮点秒数）并返回当地时间下的时间元组t（t.tm_isdst可取0或1，取决于当地当时是不是夏令时）。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-time-mktime.html\">time.mktime(tupletime)</a></td>\n<td align=\"left\">接受时间元组并返回时间戳（1970纪元后经过的浮点秒数）。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-time-sleep.html\">time.sleep(secs)</a></td>\n<td align=\"left\">推迟调用线程的运行，secs指秒数。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-time-strftime.html\">time.strftime(fmt[,tupletime])</a></td>\n<td align=\"left\">接收以时间元组，并返回以可读字符串表示的当地时间，格式由fmt决定。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-time-strptime.html\">time.strptime(str,fmt=’%a %b %d %H:%M:%S %Y’)</a></td>\n<td align=\"left\">根据fmt的格式把一个时间字符串解析为时间元组。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-time-time.html\">time.time( )</a></td>\n<td align=\"left\">返回当前时间的时间戳（1970纪元后经过的浮点秒数）。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-time-tzset.html\">time.tzset()</a></td>\n<td align=\"left\">根据环境变量TZ重新初始化时间相关设置。</td>\n</tr>\n</tbody></table>\n<h3 id=\"两个time库重要属性\"><a href=\"#两个time库重要属性\" class=\"headerlink\" title=\"两个time库重要属性\"></a>两个time库重要属性</h3><table>\n<thead>\n<tr>\n<th align=\"left\">属性</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>time.timezone</strong></td>\n<td align=\"left\">属性 time.timezone 是当地时区（未启动夏令时）距离格林威治的偏移秒数（&gt;0，美洲&lt;=0大部分欧洲，亚洲，非洲）。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>time.tzname</strong></td>\n<td align=\"left\">属性time.tzname包含一对根据情况的不同而不同的字符串，分别是带夏令时的本地时区名称，和不带的。</td>\n</tr>\n</tbody></table>\n<h3 id=\"calendar内置函数\"><a href=\"#calendar内置函数\" class=\"headerlink\" title=\"calendar内置函数\"></a>calendar内置函数</h3><table>\n<thead>\n<tr>\n<th align=\"left\">函数</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>calendar.calendar(year,w=2,l=1,c=6)</strong></td>\n<td align=\"left\">返回一个多行字符串格式的year年年历，3个月一行，间隔距离为c。 每日宽度间隔为w字符。每行长度为21* W+18+2* C。l是每星期行数。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>calendar.firstweekday( )</strong></td>\n<td align=\"left\">返回当前每周起始日期的设置。默认情况下，首次载入 calendar 模块时返回 0，即星期一。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>calendar.isleap(year)</strong></td>\n<td align=\"left\">是闰年返回 True，否则为 False。<code>&gt;&gt;&gt; import calendar &gt;&gt;&gt; print(calendar.isleap(2000)) True &gt;&gt;&gt; print(calendar.isleap(1900)) False</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>calendar.leapdays(y1,y2)</strong></td>\n<td align=\"left\">返回在Y1，Y2两年之间的闰年总数。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>calendar.month(year,month,w=2,l=1)</strong></td>\n<td align=\"left\">返回一个多行字符串格式的year年month月日历，两行标题，一周一行。每日宽度间隔为w字符。每行的长度为7* w+6。l是每星期的行数。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>calendar.monthcalendar(year,month)</strong></td>\n<td align=\"left\">返回一个整数的单层嵌套列表。每个子列表装载代表一个星期的整数。Year年month月外的日期都设为0;范围内的日子都由该月第几日表示，从1开始。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>calendar.monthrange(year,month)</strong></td>\n<td align=\"left\">返回两个整数。第一个是该月的星期几的日期码，第二个是该月的日期码。日从0（星期一）到6（星期日）;月从1到12。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>calendar.prcal(year,w=2,l=1,c=6)</strong></td>\n<td align=\"left\">相当于 **print calendar.calendar(year,w=2,l=1,c=6)**。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>calendar.prmonth(year,month,w=2,l=1)</strong></td>\n<td align=\"left\">相当于 <strong>print calendar.month(year,month,w=2,l=1)</strong> 。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>calendar.setfirstweekday(weekday)</strong></td>\n<td align=\"left\">设置每周的起始日期码。0（星期一）到6（星期日）。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>calendar.timegm(tupletime)</strong></td>\n<td align=\"left\">和time.gmtime相反：接受一个时间元组形式，返回该时刻的时间戳（1970纪元后经过的浮点秒数）。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>calendar.weekday(year,month,day)</strong></td>\n<td align=\"left\">返回给定日期的日期码。0（星期一）到6（星期日）。月份为 1（一月） 到 12（12月）。</td>\n</tr>\n</tbody></table>\n<h2 id=\"7-set集合\"><a href=\"#7-set集合\" class=\"headerlink\" title=\"7.set集合\"></a>7.set集合</h2><p>python的set集合和C++的set集合的用法基本是一样的，set集合是一个无序不重复序列，python使用<code>&#123;&#125;</code>或<code>set()</code>函数来创建set集合，区别字典的地方是{}包括的元素不是键值对，需要注意的是，创建空集合只能通过set()函数。</p>\n<h2 id=\"8-类型转换\"><a href=\"#8-类型转换\" class=\"headerlink\" title=\"8.类型转换\"></a>8.类型转换</h2><p>Python提供了大量内置类型转换函数：</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>int(x <a href=\"https://www.runoob.com/python/python-func-int.html\">,[base])</a></td>\n<td>将x转换为一个整数</td>\n</tr>\n<tr>\n<td>long(x <a href=\"https://www.runoob.com/python/python-func-long.html\">,[base] )</a></td>\n<td>将x转换为一个长整数</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-float.html\">float(x)</a></td>\n<td>将x转换到一个浮点数</td>\n</tr>\n<tr>\n<td>complex(real <a href=\"https://www.runoob.com/python/python-func-complex.html\">[,imag])</a></td>\n<td>创建一个复数</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-str.html\">str(x)</a></td>\n<td>将对象 x 转换为字符串</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-repr.html\">repr(x)</a></td>\n<td>将对象 x 转换为表达式字符串</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-eval.html\">eval(str)</a></td>\n<td>用来计算在字符串中的有效Python表达式,并返回一个对象</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/att-tuple-tuple.html\">tuple(s)</a></td>\n<td>将序列 s 转换为一个元组</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/att-list-list.html\">list(s)</a></td>\n<td>将序列 s 转换为一个列表</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-set.html\">set(s)</a></td>\n<td>转换为可变集合</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-dict.html\">dict(d)</a></td>\n<td>创建一个字典。d 必须是一个序列 (key,value)元组。</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-frozenset.html\">frozenset(s)</a></td>\n<td>转换为不可变集合</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-chr.html\">chr(x)</a></td>\n<td>将一个整数转换为一个字符</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-unichr.html\">unichr(x)</a></td>\n<td>将一个整数转换为Unicode字符</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-ord.html\">ord(x)</a></td>\n<td>将一个字符转换为它的整数值</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-hex.html\">hex(x)</a></td>\n<td>将一个整数转换为一个十六进制字符串</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-oct.html\">oct(x)</a></td>\n<td>将一个整数转换为一个八进制字符串</td>\n</tr>\n</tbody></table>\n<h1 id=\"四、运算符\"><a href=\"#四、运算符\" class=\"headerlink\" title=\"四、运算符\"></a>四、运算符</h1><h2 id=\"1-算术运算符\"><a href=\"#1-算术运算符\" class=\"headerlink\" title=\"1.算术运算符\"></a>1.算术运算符</h2><p>Python的算术运算基本和C系列语言没什么区别，唯一的区别在于Python将C系列语言的求幂函数和取整函数直接内置到了Python的运算符里了，如：</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>**</td>\n<td>求幂运算符，二元运算符，a**b表示求a的b次幂</td>\n</tr>\n<tr>\n<td>//</td>\n<td>取整运算符，二元运算符，a//b表示a对b取整，如9//4 = 2</td>\n</tr>\n</tbody></table>\n<h2 id=\"2-赋值运算符\"><a href=\"#2-赋值运算符\" class=\"headerlink\" title=\"2.赋值运算符\"></a>2.赋值运算符</h2><p>和算数运算符一样，Python也将求幂运算和取整运算的赋值运算内置到运算符里。</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>**=</td>\n<td>幂赋值运算符</td>\n</tr>\n<tr>\n<td>//=</td>\n<td>取整赋值运算符</td>\n</tr>\n</tbody></table>\n<h2 id=\"3-逻辑运算符\"><a href=\"#3-逻辑运算符\" class=\"headerlink\" title=\"3.逻辑运算符\"></a>3.逻辑运算符</h2><p>由于Python的底层是用C写的所有C的逻辑运算符（<code>&amp;</code>,<code>|</code>,<code>!</code>）在Python中就不能再使用了，所以Python使用（<code>and</code>,<code>or</code>,<code>not</code>）来做逻辑运算符，用法和<code>&amp;</code>,<code>|</code>,<code>!</code>一样。</p>\n<h2 id=\"4-成员运算符\"><a href=\"#4-成员运算符\" class=\"headerlink\" title=\"4.成员运算符\"></a>4.成员运算符</h2><p>和前面一样，Python也将判断函数直接内置到运算符中了，Python成员运算符作用就是判断指定序列中是否包含某个指定元素，序列支持字符串，列表和元组。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>in</td>\n<td>如果指定元素在指定序列中则返回True</td>\n</tr>\n<tr>\n<td>not in</td>\n<td>如果指定元素不在指定序列中则返回True</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-selector-tag\">li</span> = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>]<br>tu = (<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>)<br>st = “<span class=\"hljs-number\">12345</span>”<br><span class=\"hljs-selector-tag\">a</span> = <span class=\"hljs-number\">1</span><br><span class=\"hljs-selector-tag\">b</span> = ‘<span class=\"hljs-number\">1</span>’<br><span class=\"hljs-function\"><span class=\"hljs-title\">print</span><span class=\"hljs-params\">(a in li)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-title\">print</span><span class=\"hljs-params\">(a not in tu)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-title\">print</span><span class=\"hljs-params\">(b in st)</span></span><br></code></pre></td></tr></table></figure>\n<p>返回结果：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-literal\">True</span><br><span class=\"hljs-literal\">False</span><br><span class=\"hljs-literal\">True</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"5-身份运算符\"><a href=\"#5-身份运算符\" class=\"headerlink\" title=\"5.身份运算符\"></a>5.身份运算符</h2><table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>is</td>\n<td>判断两个对象是否来自同一引用</td>\n</tr>\n<tr>\n<td>is not</td>\n<td>判断两个对象是否不同的引用</td>\n</tr>\n</tbody></table>\n<p>Pyhton的身份运算符和C#的is是不一样的，Python的is用于判断两个对象是否来引用同一引用，而C#的is则是判断某一对象是否是指定类型。</p>\n<p>使用案例：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-selector-tag\">a</span>  = <span class=\"hljs-number\">1</span><br><span class=\"hljs-selector-tag\">b</span> = a<br><span class=\"hljs-function\"><span class=\"hljs-title\">print</span><span class=\"hljs-params\">(a is b)</span></span><br><span class=\"hljs-selector-tag\">b</span> = <span class=\"hljs-number\">2</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">print</span><span class=\"hljs-params\">(a is not b)</span></span><br>c = <span class=\"hljs-number\">2</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">print</span><span class=\"hljs-params\">(b is c)</span></span><br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-literal\">True</span><br><span class=\"hljs-literal\">True</span><br><span class=\"hljs-literal\">True</span><br></code></pre></td></tr></table></figure>\n<p>这里出现了一个疑问，为什么b和c来自同一引用呢？<br>我们查看一下b和c的内存地址</p>\n<figure class=\"highlight isbl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs isbl\"><span class=\"hljs-function\"><span class=\"hljs-title\">print</span>(<span class=\"hljs-title\">id</span>(<span class=\"hljs-variable\">b</span>))</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">print</span>(<span class=\"hljs-title\">id</span>(<span class=\"hljs-variable\">c</span>))</span><br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dns\"><span class=\"hljs-number\">2324527120200</span><br><span class=\"hljs-number\">2324527120200</span><br></code></pre></td></tr></table></figure>\n<p>可以看到b和c指向了同一内存地址，原来Python在对程序优化的时候会将程序中的内容相同的常量存储到一个存储地址中。</p>\n<h1 id=\"五、控制语句\"><a href=\"#五、控制语句\" class=\"headerlink\" title=\"五、控制语句\"></a>五、控制语句</h1><p>Python的条件语句与C系列语言最大的不同是，Python的条件语句可以不使用<code>()</code>来包含条件表达式，当然也可以是使用，大多数情况下还是建议使用（），以使代码的阅读性更高。</p>\n<h2 id=\"1-if语句\"><a href=\"#1-if语句\" class=\"headerlink\" title=\"1.if语句\"></a>1.if语句</h2><p>当条if-else语句的用法和C系列基本一致。</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\"><span class=\"hljs-keyword\">if</span> <span class=\"hljs-literal\">True</span>:<br>\t<span class=\"hljs-attribute\">a</span>=1<br>\t<span class=\"hljs-attribute\">b</span>=1<br><span class=\"hljs-keyword\">else</span>:<br>\t<span class=\"hljs-attribute\">a</span>=2<br>\t<span class=\"hljs-attribute\">b</span>=2<br></code></pre></td></tr></table></figure>\n<p><font color=\"red\"> 其中<code>:</code>是必须的</font><br>Python中比较特殊的是else if语句，在Python中使用<font color=\"red\"> elif</font>表示。</p>\n<h2 id=\"2-while循环语句\"><a href=\"#2-while循环语句\" class=\"headerlink\" title=\"2.while循环语句\"></a>2.while循环语句</h2><p>Python的while循环可以搭配esle使用，当循环跳出时执行else语句，个人感觉没什么实际用处。</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gauss\">a = <span class=\"hljs-number\">0</span><br><span class=\"hljs-keyword\">while</span> a&lt;<span class=\"hljs-number\">3</span>:<br>\t<span class=\"hljs-keyword\">print</span>(a)<br>\ta += <span class=\"hljs-number\">1</span><br><span class=\"hljs-keyword\">else</span>:<br>\t<span class=\"hljs-keyword\">print</span>(“循环结束”)<br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">0<br>1<br>2<br>循环结束<br></code></pre></td></tr></table></figure>\n<h2 id=\"3-for循环\"><a href=\"#3-for循环\" class=\"headerlink\" title=\"3.for循环\"></a>3.for循环</h2><p><font color=\"red\"> 在写循环语句之前有一点是需要明确的，及根据Python的设计理念Python已经不使用自增<code>++</code>自减<code>--</code>运算符了，所以需要自增时应使用<code>a += 1</code></font></p>\n<h3 id=\"for-in\"><a href=\"#for-in\" class=\"headerlink\" title=\"for in\"></a>for in</h3><p>for in的用法和C#的foreach一致，可以遍历任何序列，如：</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs maxima\"><span class=\"hljs-built_in\">li</span> = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>]<br><span class=\"hljs-keyword\">for</span> item <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">li</span>:<br>\t<span class=\"hljs-built_in\">print</span>(item)<br><span class=\"hljs-keyword\">else</span>：<br>\t<span class=\"hljs-built_in\">print</span>(“<span class=\"hljs-keyword\">for</span> end”)<br></code></pre></td></tr></table></figure>\n<p>和while一样for也可以配合else使用</p>\n<h3 id=\"for-in-range\"><a href=\"#for-in-range\" class=\"headerlink\" title=\"for in range()\"></a>for in range()</h3><p>for in range()就是不同的for循环，通过下标来遍历序列，如：</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs maxima\"><span class=\"hljs-built_in\">li</span> = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>]<br><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(len(<span class=\"hljs-built_in\">li</span>)):<br>\t<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-built_in\">li</span>[i])<br><span class=\"hljs-keyword\">else</span>:<br>\t<span class=\"hljs-built_in\">print</span>(“<span class=\"hljs-keyword\">for</span> end”)<br></code></pre></td></tr></table></figure>\n<p><font color=\"red\"> 需要注意实际上for in中是不包含range()的，range只是一个辅助函数，用于确定下标的范围。如果我们直接像下面那样写是会报语法错误的，如：</font></p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">for</span> i in <span class=\"hljs-number\">4</span>:<br>\t<span class=\"hljs-comment\">#code</span><br></code></pre></td></tr></table></figure>\n<p>如果我们想让循环只跑4轮，应该用range(4)来确定下标范围，如：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\"><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-keyword\">range</span>(<span class=\"hljs-number\">4</span>):<br></code></pre></td></tr></table></figure>\n<h3 id=\"continue、break和pass\"><a href=\"#continue、break和pass\" class=\"headerlink\" title=\"continue、break和pass\"></a>continue、break和pass</h3><p>Python的continue和break的用法和C系列语言基本一致，Python中新增了pass语句，pass语句就是C系列语言中<code>;</code>及空语句，一般用于空循环中维护代码的结构性。</p>\n<h1 id=\"六、函数\"><a href=\"#六、函数\" class=\"headerlink\" title=\"六、函数\"></a>六、函数</h1><h2 id=\"1-函数定义\"><a href=\"#1-函数定义\" class=\"headerlink\" title=\"1.函数定义\"></a>1.函数定义</h2><ul>\n<li>函数代码块以 <strong>def</strong> 关键词开头，后接函数标识符名称和圆括号**()**。</li>\n<li>任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。</li>\n<li><font color=\"red\">函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</font></li>\n<li>函数内容以冒号起始，并且缩进。</li>\n<li><strong>return [表达式]</strong> 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。</li>\n</ul>\n<p>如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">fun</span>(<span class=\"hljs-params\">a</span>):</span><br>    <span class=\"hljs-string\">&quot;打印a的平方并返回&quot;</span><br>    b = a*a<br>    print(b)<br>    <span class=\"hljs-keyword\">return</span> b<br></code></pre></td></tr></table></figure>\n<h2 id=\"2-函数调用\"><a href=\"#2-函数调用\" class=\"headerlink\" title=\"2.函数调用\"></a>2.函数调用</h2><p><font color=\"red\"> 在调用Python函数时有一点是需要特别注意的，由于Python是解释型语言，Python脚本在运行时是一行一行地放入解释器中进行解释的，因此Pyhton不支持函数的声明定义的分离，所有Python的函数调用必须在定义之后，否则将会报函数未定义。</font></p>\n<h2 id=\"3-参数传递\"><a href=\"#3-参数传递\" class=\"headerlink\" title=\"3.参数传递\"></a>3.参数传递</h2><p>在讨论函数参数之前，我们需要了解两个概念：</p>\n<ul>\n<li><p>不可变对象：不可变对象都是不可变类型，<font color=\"red\">Python的不可变类型有数字、字符串、元组</font>，不可变对象指向的内存地址上的内容是不可更改的，如需操作其内容Python会开辟一个新的内存地址来存储编辑后的内容。</p>\n</li>\n<li><p>可变对象：可变对象都是可变类型，不是不可变类型的类型都是可变类型，包括列表、字典、自定义类型等，可变类型对象指向的内存地址的内容是可更改，操作可变对象的内容时Python不会开辟新的内存，而是直接修改原地址内容。</p>\n</li>\n</ul>\n<p><font color=\"red\">函数传入不可变对象的原理和C++的传值原理是一样的，函数传入可变对象的原理和C++传址原理是一样的。</font></p>\n<h3 id=\"传参原理\"><a href=\"#传参原理\" class=\"headerlink\" title=\"传参原理\"></a>传参原理</h3><p>由于Python的变量都是若类型的，参数也不例外，函数在定义参数时只有名字没有类型，所以Python在调用函数时，参数的传递是根据实参的顺序来给形参赋值的。</p>\n<h3 id=\"关键字参数\"><a href=\"#关键字参数\" class=\"headerlink\" title=\"关键字参数\"></a>关键字参数</h3><p>Python的函数支持关键字传参，关键字传参的原理是指定实参来赋值指定形参，所以可以无视参数的传入顺序。如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">fun</span>(<span class=\"hljs-params\">a,b,c</span>):</span><br>    print(a+b+c)<br>fun(b = <span class=\"hljs-number\">1</span>,c = <span class=\"hljs-number\">2</span>,a = <span class=\"hljs-number\">3</span>)<br></code></pre></td></tr></table></figure>\n<h3 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h3><p>Python的函数也支持默认参数，原理和C++一样。</p>\n<h3 id=\"单-号不定长参数\"><a href=\"#单-号不定长参数\" class=\"headerlink\" title=\"单*号不定长参数\"></a>单*号不定长参数</h3><p>Python的不定长参数和C++则有些不同，Python使用<code>*</code>来标识不定长参数，所有形参匹配之外的参数都将存储到不定长参数中，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">fun</span>(<span class=\"hljs-params\">a,b,*c</span>):</span><br>    d = a + b<br>    <span class=\"hljs-keyword\">for</span> item <span class=\"hljs-keyword\">in</span> c:<br>        d += item<br>    print(d)<br>fun(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>)<br></code></pre></td></tr></table></figure>\n<p>在这个过程中，1被赋予a，2被赋予b，3和4被赋予c</p>\n<p>Python支持不定长参数的单独使用，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">fun</span>(<span class=\"hljs-params\">*param</span>):</span><br>    <span class=\"hljs-keyword\">pass</span><br></code></pre></td></tr></table></figure>\n<p>如果函数的参数只有一个不定长参数，那么函数传入的任何参数都会存储到不定长参数里。</p>\n<p><font color=\"red\"> 单<code>*</code>号不定长参数会将传入的所有参数封装在一个元组里，且单<code>*</code>号不定长参数只支持参数的顺序传入，不支持关键字传入。</font></p>\n<p>当函数只有单<code>*</code>号不定长参数时，单<code>*</code>号不定长参数因该放在最后一个参数，如果不放在最后将会报错：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">fun</span>(<span class=\"hljs-params\">*c, t</span>):</span><br>    c[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">5</span><br>    print(c[<span class=\"hljs-number\">0</span>])<br>    print(t)<br></code></pre></td></tr></table></figure>\n<p>报错：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">Traceback (most recent call last):<br>  File <span class=\"hljs-string\">&quot;d:\\Codes\\Python\\MyFirstPython.py&quot;</span>, line <span class=\"hljs-number\">9</span>, <span class=\"hljs-keyword\">in</span> &lt;module&gt;<br>    fun(li, <span class=\"hljs-number\">2</span>)<br>TypeError: fun() missing <span class=\"hljs-number\">1</span> required keyword-only argument: <span class=\"hljs-string\">&#x27;t&#x27;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"双-号不定长参数\"><a href=\"#双-号不定长参数\" class=\"headerlink\" title=\"双*号不定长参数\"></a>双*号不定长参数</h3><p>除了单<code>*</code>号不定长参数外，Python还支持双<code>*</code>号不定长参数，<font color=\"red\"> 双<code>*</code>号不定长参数支持关键字传入，不支持顺序传入，双<code>*</code>号不定长参数会将传入的参数封装在一个字典里，其中关键字的名字存入字典的键中，关键字的值存入字典的值中。</font>如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">fun</span>(<span class=\"hljs-params\">t,**d</span>):</span><br>    print(t)<br>    print(d[<span class=\"hljs-string\">&#x27;x&#x27;</span>])<br>    print(d[<span class=\"hljs-string\">&#x27;y&#x27;</span>])<br>fun(<span class=\"hljs-number\">1</span>,x=<span class=\"hljs-number\">2</span>,y=<span class=\"hljs-number\">3</span>)<br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-number\">1</span><br><span class=\"hljs-number\">2</span><br><span class=\"hljs-number\">3</span><br></code></pre></td></tr></table></figure>\n<p>当函数中同时存在单<code>*</code>号不定长参数和双<code>*</code>号不定长参数时，双<code>*</code>号不定长参数应放在最后一个参数位置，单<code>*</code>号参数应放在倒数第二个参数位置。</p>\n<h2 id=\"4-匿名函数\"><a href=\"#4-匿名函数\" class=\"headerlink\" title=\"4.匿名函数\"></a>4.匿名函数</h2><p>Python的匿名函数的使用场景是，当函数体只由比较简单的Lambda表达式组成时才使用。匿名函数除了没有函数名，其他的和有名函数没有什么区别。如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">f = <span class=\"hljs-keyword\">lambda</span> a,b=<span class=\"hljs-number\">1</span>: a+b<br>print(f(<span class=\"hljs-number\">1</span>))<br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-number\">2</span><br></code></pre></td></tr></table></figure>\n<p>在lambda表达式的结构中，<code>:</code>之前的为参数，<code>:</code>号之后有且只有一条语句，这是由Python语句分割的方式决定的。从上面的例子我们还可以发现，lambda表达式支持默认参数，且自带返回值，lambda表达式将表达式的结果作为返回值，需要注意的是，lambda表达式中不能进行复制操作，否则将报语法错误。</p>\n<h1 id=\"七、模块\"><a href=\"#七、模块\" class=\"headerlink\" title=\"七、模块\"></a>七、模块</h1><p>一个Python文件就是一个Python模块，一个Python包也是一个Python模块。</p>\n<h2 id=\"1-导入模块（包）\"><a href=\"#1-导入模块（包）\" class=\"headerlink\" title=\"1.导入模块（包）\"></a>1.导入模块（包）</h2><h3 id=\"整模块导入\"><a href=\"#整模块导入\" class=\"headerlink\" title=\"整模块导入\"></a>整模块导入</h3><p>Python使用<code>import</code>+<code>模块名</code>来导入模块，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> MyFirstPython<br></code></pre></td></tr></table></figure>\n<p>当我们将一个Python作为模块导入到另一个文件时，Python会在工程文件夹下的<code>__pycache</code>文件夹下生成一个模块名对应的<code>pyc</code>文件，如上面的例子则会生成一个<code>PyFirstPython.cpython-39.pyc</code>其中cpython-39为python版本号，这个文件是做什么用的呢？pyc文件是一个二进制文件，且已经经过Python加密，直接打开会显示乱码，pyc的主要作用就是加快模块的导入速度，注意这里是导入速度而非运行速度，pyc文件可以通过反编译器重新反编译成可执行的Python文件。</p>\n<p>python支持使用<code>,</code>来分割模块，达到同时导入多个包的目的，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> MyfirstPython,MySecondPython<br></code></pre></td></tr></table></figure>\n<h3 id=\"单函数导入\"><a href=\"#单函数导入\" class=\"headerlink\" title=\"单函数导入\"></a>单函数导入</h3><p>python除了支持整个文件的模块导入，同时也支持只导入模块中的一个函数，python使用<code>from 模块名 import 函数名</code>来从指定模块导入单个函数，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">from</span> MySecondPython <span class=\"hljs-keyword\">import</span> fun <span class=\"hljs-keyword\">as</span> f<br></code></pre></td></tr></table></figure>\n<p>同时，python在导入模块或模块中的函数时可以使用<code>as</code>关键字为模块或函数起别名。</p>\n<p>form import还可以使用<code>*</code>来达到import的效果，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">from</span> MyFirstPython <span class=\"hljs-keyword\">import</span> * <span class=\"hljs-comment\">#相当于import MyFirstPython</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"python导入模块时的路径搜索顺序\"><a href=\"#python导入模块时的路径搜索顺序\" class=\"headerlink\" title=\"python导入模块时的路径搜索顺序\"></a>python导入模块时的路径搜索顺序</h3><ul>\n<li>1、当前目录</li>\n<li>2、如果不在当前目录，Python 则搜索在 shell 变量 PYTHONPATH 下的每个目录。</li>\n<li>3、如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/。</li>\n</ul>\n<h3 id=\"python使用导入模块的全局变量\"><a href=\"#python使用导入模块的全局变量\" class=\"headerlink\" title=\"python使用导入模块的全局变量\"></a>python使用导入模块的全局变量</h3><p>有一点十分不方便的就是在当前文件下无法直接使用导入模块的全局变量，只能通过为指定变量编写读写函数才能操作全局变量，这是由python的变量规则决定的。</p>\n<h3 id=\"Pyhton模块打包\"><a href=\"#Pyhton模块打包\" class=\"headerlink\" title=\"Pyhton模块打包\"></a>Pyhton模块打包</h3><p>Python提供了多个打包工具，我使用的是python3.9内置的<code>setuptools</code>库，setuptools库中提供了一个setup函数用于打包模块，具体操作如下：</p>\n<ul>\n<li><p>1.在工程目录下新建一个setup.py文件，这个文件用于配置一些包的必要信息，配置信息都由关键字参数的形式传入setup函数中，具体参数信息如下;</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">setup(<br>    name=about[<span class=\"hljs-string\">&quot;__title__&quot;</span>],  <span class=\"hljs-comment\"># 包名称</span><br>    version=about[<span class=\"hljs-string\">&quot;__version__&quot;</span>],  <span class=\"hljs-comment\"># 包版本</span><br>    description=about[<span class=\"hljs-string\">&quot;__description__&quot;</span>],  <span class=\"hljs-comment\"># 包详细描述</span><br>    long_description=readme,   <span class=\"hljs-comment\"># 长描述，通常是readme，打包到PiPy需要</span><br>    author=about[<span class=\"hljs-string\">&quot;__author__&quot;</span>],  <span class=\"hljs-comment\"># 作者名称</span><br>    author_email=about[<span class=\"hljs-string\">&quot;__author_email__&quot;</span>],  <span class=\"hljs-comment\"># 作者邮箱</span><br>    url=about[<span class=\"hljs-string\">&quot;__url__&quot;</span>],   <span class=\"hljs-comment\"># 项目官网</span><br>    packages=packages,    <span class=\"hljs-comment\"># 项目需要的包</span><br>    data_files=file_data,   <span class=\"hljs-comment\"># 打包时需要打包的数据文件，如图片，配置文件等</span><br>    include_package_data=<span class=\"hljs-literal\">True</span>,  <span class=\"hljs-comment\"># 是否需要导入静态数据文件</span><br>    python_requires=<span class=\"hljs-string\">&quot;&gt;=3.0, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3*&quot;</span>,  <span class=\"hljs-comment\"># Python版本依赖</span><br>    install_requires=requires,  <span class=\"hljs-comment\"># 第三方库依赖</span><br>    zip_safe=<span class=\"hljs-literal\">False</span>,  <span class=\"hljs-comment\"># 此项需要，否则卸载时报windows error</span><br>    classifiers=[    <span class=\"hljs-comment\"># 程序的所属分类列表</span><br>        <span class=\"hljs-string\">&#x27;Development Status :: 5 - Production/Stable&#x27;</span>,<br>        <span class=\"hljs-string\">&#x27;Intended Audience :: Developers&#x27;</span>,<br>        <span class=\"hljs-string\">&#x27;Natural Language :: English&#x27;</span>,<br>        <span class=\"hljs-string\">&#x27;Programming Language :: Python&#x27;</span>,<br>        <span class=\"hljs-string\">&#x27;Programming Language :: Python :: 3&#x27;</span>,<br>        <span class=\"hljs-string\">&#x27;Programming Language :: Python :: 3.4&#x27;</span>,<br>        <span class=\"hljs-string\">&#x27;Programming Language :: Python :: 3.5&#x27;</span>,<br>        <span class=\"hljs-string\">&#x27;Programming Language :: Python :: 3.6&#x27;</span>,<br>        <span class=\"hljs-string\">&#x27;Programming Language :: Python :: 3.7&#x27;</span>,<br>        <span class=\"hljs-string\">&#x27;Programming Language :: Python :: Implementation :: CPython&#x27;</span>,<br>        <span class=\"hljs-string\">&#x27;Programming Language :: Python :: Implementation :: PyPy&#x27;</span><br>    ],<br>)<br></code></pre></td></tr></table></figure>\n<p>当然这里面所有的参数都不是非必须，如果我们一个参数都不传入，则pyhton会生成一个名为<code>UNKNOW-0.0.0.tar.gz</code>的包。</p>\n</li>\n<li><p>2.使用cmd进入setup.py所在目录，使用<code>python setup.py sdist</code>命令之后，python会在此目录下生成一个<code>dist</code>目录和一个<code>包名.egg-info</code>目录，包名及setup函数中name指定的名称，为命名则为UNKNOWN.egg-info，这个文件夹下是一些包的详细信息文件。</p>\n</li>\n</ul>\n<p>如此包便打包完成了，这中间踩了一写坑，记录一下：</p>\n<p>使用python setup.py sdist命令无反应，然后使用python -v发现也不输出python版信息，此时打开此电脑/属性/高级系统设置/高级/环境变量，发现path中都以存在python目录，可是使用python -v就是无反应。</p>\n<p>解决方案：在cmd下使用<code>set PATH=Python完成目录;%PATH%</code>，不知道为什么需要使用命令行配置一下系统环境才行。</p>\n<p>当然不同的打包工具，打包过程略有不同，这里就详细展开了。</p>\n<h1 id=\"八、Python的内置函数\"><a href=\"#八、Python的内置函数\" class=\"headerlink\" title=\"八、Python的内置函数\"></a>八、Python的内置函数</h1><h2 id=\"1-数学函数\"><a href=\"#1-数学函数\" class=\"headerlink\" title=\"1.数学函数\"></a>1.数学函数</h2><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"https://www.runoob.com/python/func-number-abs.html\">abs()</a></td>\n<td>返回数字的绝对值，如abs(-10) 返回 10</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/func-number-cmp.html\">cmp()</a></td>\n<td>如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/func-number-max.html\">max()</a></td>\n<td>返回给定参数的最大值，参数可以为序列</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/func-number-min.html\">min()</a></td>\n<td>返回给定参数的最小值，参数可以为序列</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/func-number-pow.html\">pow()</a></td>\n<td>x^y 运算后的值，及求x的y次幂</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/func-number-round.html\">round(x [,n])</a></td>\n<td>返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-sum.html\">sum()</a></td>\n<td>对序列求和</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/func-number-round.html\">round()</a></td>\n<td>返回浮点数x的四舍五入值</td>\n</tr>\n</tbody></table>\n<h2 id=\"5-反射函数\"><a href=\"#5-反射函数\" class=\"headerlink\" title=\"5.反射函数\"></a>5.反射函数</h2><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"https://www.runoob.com/python/python-func-dir.html\">dir()</a></td>\n<td>dir函数返回一个包含了一个模块里所定义的所有模块、变量和函数，dir函数只是列出名称，无其他实际意义，其中以<code>__</code>开头的是模块相关的默认属性，如：<code>__name__</code>指向模块的名字，<code>__file__</code>指向模块文件的名字，dir函数可以传入模块名称，则输出的是模块相关的信息，如果不传入参数则输出当前作用域的相关信息</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-globals.html\">globals()</a></td>\n<td>在函数内使用则返回一个包含该函数能访问的所有全局名字的字典，在函数外使用效果和在函数内使用一样</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-locals.html\">locals()</a></td>\n<td>在函数内使用则返回一个包含该函数内的全部局部名字的字典，在函数外使用效果和globals()函数一样</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-callable.html\">callable()</a></td>\n<td>检查一个对象是否是可调用的。如果返回 True，object 仍然可能调用失败；但如果返回 False，调用对象 object 绝对不会成功。</td>\n</tr>\n</tbody></table>\n<h2 id=\"6-类型转换函数\"><a href=\"#6-类型转换函数\" class=\"headerlink\" title=\"6.类型转换函数\"></a>6.类型转换函数</h2><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"https://www.runoob.com/python/python-func-bool.html\">bool()</a></td>\n<td>将对象转换为bool类型，对于空元组和空列表将转换为false</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-float.html\">float()</a></td>\n<td>在python中没有double类型，python的float精度就已经达到了double的精度</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-int.html\">int()</a></td>\n<td>转整型</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-long.html\">long()</a></td>\n<td>转长整型</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-str.html\">str()</a></td>\n<td>将对象转换成字符串，支持任何对象</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-eval.html\">eval()</a></td>\n<td>eval函数可以用来做字符串转列表、元组和字典等，如：<code>a = eval(&#39;[1,2]&#39;)</code>、<code>b = eval(&#39;(1,2)&#39;)</code>，a是一个列表，b是一个元组，其中字典需要注意的是要使用纯字符串，如：<code>c = eavl(r&quot;&#123;&#39;a&#39;:1,&#39;b&#39;:2&#125;&quot;)</code>，c就是一个字典了，除此之外，eval函数还可以用来运行字符串命令，如：<code>eval(&#39;bool(1)&#39;)</code>，输出为<code>True</code></td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/att-list-list.html\">list()</a></td>\n<td>将可迭代序列(包括元组，字符串，字典等)转换成列表，如：字符串转列表<code>a = list(&#39;abc&#39;)</code>则a列表内容为<code>[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]</code>、字典转列表则会返回一个key值列表</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/att-tuple-tuple.html\">tuple()</a></td>\n<td>将可迭代序列(包括元组，字符串，字典等)转换成元组，如：字符串转元组<code>a = tuple(&#39;abc&#39;)</code>则a列表内容为<code>(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;)</code>、字典转元组则会返回一个key值元组</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-dict.html\">dict()</a></td>\n<td>dict函数支持三种转换形式，其一使用关键字的形式，关键字名称为键，关键字的值为值，如：<code>a=dict(a=1,b=1)</code>则a就是字典<code>&#123;&#39;a&#39;:1,&#39;b&#39;:2&#125;</code>，其二使用zip函数的形式，zip函数将两个可迭代序列按位置打包成二元元组，dict函数则将二元元组的第一个元素作为键，第二个元素作为值创建字典，如：<code>a=dict(zip([&#39;a&#39;,&#39;b&#39;],[1,2]))</code>，其中zip函数返回值为<code>[(&#39;a&#39;,1),(&#39;b&#39;,2)]</code>，dict函数返回值为<code>&#123;&#39;a&#39;:1,&#39;b&#39;:2&#125;</code>，其三使用可迭代对象的形式，如：<code>a=dict([(&#39;a&#39;,1),(&#39;b&#39;:2)])</code>其中可迭代对象可以是任何子成员为二元序列的对象</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-chr.html\">chr()</a></td>\n<td>将数字转换成对应的字符</td>\n</tr>\n</tbody></table>\n<h2 id=\"6-其他内置函数\"><a href=\"#6-其他内置函数\" class=\"headerlink\" title=\"6.其他内置函数\"></a>6.其他内置函数</h2><p>详情见<a href=\"https://www.runoob.com/python/python-built-in-functions.html\">菜鸟教程</a></p>\n<h1 id=\"九、文件IO\"><a href=\"#九、文件IO\" class=\"headerlink\" title=\"九、文件IO\"></a>九、文件IO</h1><h2 id=\"1-标准输出\"><a href=\"#1-标准输出\" class=\"headerlink\" title=\"1.标准输出\"></a>1.标准输出</h2><p>print()在终端打印，这里需要注意的是python3已经不支持<code>print &#39;aa&#39;</code>这种打印方式了。</p>\n<h2 id=\"2-标准输入\"><a href=\"#2-标准输入\" class=\"headerlink\" title=\"2.标准输入\"></a>2.标准输入</h2><p>input()从终端输入，有时我们会看到row_input函数或input函数接收python表达式的标准输入，这些都是ptrhon2的标准输入函数和输入特性，在python3中python只保留了一个input函数作为标准输入，且input函数不在支持python表达式的输入，而是把所有的输入当作是字符串。</p>\n<h2 id=\"3-文件读写\"><a href=\"#3-文件读写\" class=\"headerlink\" title=\"3.文件读写\"></a>3.文件读写</h2><p>python的文件读写通过内置类型<code>file</code>类型来进行操作，而file类型对象的创建需要通过内置函数<code>open</code>来创建。</p>\n<h3 id=\"open函数\"><a href=\"#open函数\" class=\"headerlink\" title=\"open函数\"></a>open函数</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-built_in\">open</span>(file_name ,access_mode, buffering)<br></code></pre></td></tr></table></figure>\n<ul>\n<li><p>file_name：文件路径</p>\n</li>\n<li><p>access_mode：打开模式，默认为只读，具体模式如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">字符</th>\n<th align=\"left\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>&#39;r&#39;</code></td>\n<td align=\"left\">读取（默认）</td>\n</tr>\n<tr>\n<td align=\"left\"><code>&#39;w&#39;</code></td>\n<td align=\"left\">写入，并先截断文件</td>\n</tr>\n<tr>\n<td align=\"left\"><code>&#39;x&#39;</code></td>\n<td align=\"left\">排它性创建，如果文件已存在则失败</td>\n</tr>\n<tr>\n<td align=\"left\"><code>&#39;a&#39;</code></td>\n<td align=\"left\">写入，如果文件存在则在末尾追加</td>\n</tr>\n<tr>\n<td align=\"left\"><code>&#39;b&#39;</code></td>\n<td align=\"left\">二进制模式</td>\n</tr>\n<tr>\n<td align=\"left\"><code>&#39;t&#39;</code></td>\n<td align=\"left\">文本模式（默认）</td>\n</tr>\n<tr>\n<td align=\"left\"><code>&#39;+&#39;</code></td>\n<td align=\"left\">更新磁盘文件（读取并写入）</td>\n</tr>\n</tbody></table>\n<p>python3以后删除了很多打开模式，只保留了上面几种，所以如果在python3环境中使用<code>+</code>打开模式就会报错。</p>\n</li>\n<li><p>buffering：是否寄存行，可选参数，具体取值如下：</p>\n<table>\n<thead>\n<tr>\n<th>取值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>取0，不寄存行</td>\n</tr>\n<tr>\n<td>1</td>\n<td>取1，寄存行</td>\n</tr>\n<tr>\n<td>&gt;1</td>\n<td>取大于1的值，寄存行，且设置寄存区的缓冲大小为当前值</td>\n</tr>\n<tr>\n<td>&lt;0</td>\n<td>取小于0的值，寄存行，且设置寄存区的缓冲大小为系统默认值</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>返回值：open函数打开文件，读取文件内容到内存并一个可操作文件的file类型对象。</p>\n</li>\n</ul>\n<h3 id=\"file类型对象内置函数\"><a href=\"#file类型对象内置函数\" class=\"headerlink\" title=\"file类型对象内置函数\"></a>file类型对象内置函数</h3><table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">方法及描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python3/python3-file-close.html\">file.close()</a></td>\n<td align=\"left\">关闭文件。关闭后文件不能再进行读写操作。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python3/python3-file-flush.html\">file.flush()</a></td>\n<td align=\"left\">刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python3/python3-file-fileno.html\">file.fileno()</a></td>\n<td align=\"left\">返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python3/python3-file-isatty.html\">file.isatty()</a></td>\n<td align=\"left\">如果文件连接到一个终端设备返回 True，否则返回 False。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python3/python3-file-read.html\">file.read([size])</a></td>\n<td align=\"left\">从文件读取指定的字节数，如果未给定或为负则读取所有。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python3/python3-file-readline.html\">file.readline([size])</a></td>\n<td align=\"left\">读取整行，包括 “\\n” 字符。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python3/python3-file-readlines.html\">file.readlines([sizeint])</a></td>\n<td align=\"left\">读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python3/python3-file-seek.html\">file.seek(offset[, whence])</a></td>\n<td align=\"left\">移动文件读取指针到指定位置</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python3/python3-file-tell.html\">file.tell()</a></td>\n<td align=\"left\">返回文件当前位置。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python3/python3-file-truncate.html\">file.truncate([size])</a></td>\n<td align=\"left\">从文件的首行首字符开始截断，截断文件为 size 个字符，无 size 表示从当前位置截断；截断之后后面的所有字符被删除，其中 windows 系统下的换行代表2个字符大小。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python3/python3-file-write.html\">file.write(str)</a></td>\n<td align=\"left\">将字符串写入文件，返回的是写入的字符长度。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python3/python3-file-writelines.html\">file.writelines(sequence)</a></td>\n<td align=\"left\">向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。</td>\n</tr>\n</tbody></table>\n<h3 id=\"file类型对象内置属性\"><a href=\"#file类型对象内置属性\" class=\"headerlink\" title=\"file类型对象内置属性\"></a>file类型对象内置属性</h3><table>\n<thead>\n<tr>\n<th align=\"left\">属性</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">file.closed</td>\n<td align=\"left\">返回true如果文件已被关闭，否则返回false。</td>\n</tr>\n<tr>\n<td align=\"left\">file.mode</td>\n<td align=\"left\">返回被打开文件的访问模式。</td>\n</tr>\n<tr>\n<td align=\"left\">file.name</td>\n<td align=\"left\">返回文件的名称。</td>\n</tr>\n<tr>\n<td align=\"left\">file.softspace</td>\n<td align=\"left\">如果用print输出后，必须跟一个空格符，则返回false。否则返回true。</td>\n</tr>\n</tbody></table>\n<h2 id=\"4-文件及目录操作\"><a href=\"#4-文件及目录操作\" class=\"headerlink\" title=\"4.文件及目录操作\"></a>4.文件及目录操作</h2><p>这里的文件操作不是对文件的内容进行增删改操作而是在文件级别进行重命名删除设置权限等操作，对文件做这些操作需要用到<code>os</code>模块，os模块提供大量的函数对文件进行操作，文件数量过多这里就不贴出来了，具体见菜鸟教程：</p>\n<p><a href=\"https://www.runoob.com/python/os-file-methods.html\">os文件操作函数</a></p>\n<h1 id=\"十、异常\"><a href=\"#十、异常\" class=\"headerlink\" title=\"十、异常\"></a>十、异常</h1><h2 id=\"1-异常处理语句\"><a href=\"#1-异常处理语句\" class=\"headerlink\" title=\"1.异常处理语句\"></a>1.异常处理语句</h2><p>Python的异常处理语句是<code>try/except</code>，需要监测异常的代码放在<code>try:</code>块下，在异常发生后需要执行的代码放在<code>except:</code>块下，except后可以接异常类型也可以不接，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">try</span>:<br>    a = <span class=\"hljs-number\">1</span>/<span class=\"hljs-number\">0</span><br><span class=\"hljs-keyword\">except</span> ZeroDivisionError:<br>    print(<span class=\"hljs-string\">&#x27;0不可以做除数&#x27;</span>)<br><span class=\"hljs-keyword\">else</span>:<br>    print(<span class=\"hljs-string\">&#x27;没有异常&#x27;</span>)<br><span class=\"hljs-keyword\">finally</span>:<br>    print(<span class=\"hljs-string\">&#x27;有没有异常都会执行&#x27;</span>)<br></code></pre></td></tr></table></figure>\n<p>可以看到，和条件语句一样try/except语句也可以接else分支，else分支在没有异常发生时执行。、</p>\n<h2 id=\"2-抛出异常\"><a href=\"#2-抛出异常\" class=\"headerlink\" title=\"2.抛出异常\"></a>2.抛出异常</h2><p>python使用<code>raise</code>语句来抛出异常，需要注意的是，raise必须抛出一个异常类，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">try</span>:<br>    a = <span class=\"hljs-number\">1</span>/<span class=\"hljs-number\">0</span><br><span class=\"hljs-keyword\">except</span> ZeroDivisionError:<br>    <span class=\"hljs-keyword\">raise</span> ZeroDivisionError(<span class=\"hljs-string\">&#x27;0不可以做除数&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"3-标准异常\"><a href=\"#3-标准异常\" class=\"headerlink\" title=\"3.标准异常\"></a>3.标准异常</h2><table>\n<thead>\n<tr>\n<th align=\"left\">异常名称</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">BaseException</td>\n<td align=\"left\">所有异常的基类</td>\n</tr>\n<tr>\n<td align=\"left\">SystemExit</td>\n<td align=\"left\">解释器请求退出</td>\n</tr>\n<tr>\n<td align=\"left\">KeyboardInterrupt</td>\n<td align=\"left\">用户中断执行(通常是输入^C)</td>\n</tr>\n<tr>\n<td align=\"left\">Exception</td>\n<td align=\"left\">常规错误的基类</td>\n</tr>\n<tr>\n<td align=\"left\">StopIteration</td>\n<td align=\"left\">迭代器没有更多的值</td>\n</tr>\n<tr>\n<td align=\"left\">GeneratorExit</td>\n<td align=\"left\">生成器(generator)发生异常来通知退出</td>\n</tr>\n<tr>\n<td align=\"left\">StandardError</td>\n<td align=\"left\">所有的内建标准异常的基类</td>\n</tr>\n<tr>\n<td align=\"left\">ArithmeticError</td>\n<td align=\"left\">所有数值计算错误的基类</td>\n</tr>\n<tr>\n<td align=\"left\">FloatingPointError</td>\n<td align=\"left\">浮点计算错误</td>\n</tr>\n<tr>\n<td align=\"left\">OverflowError</td>\n<td align=\"left\">数值运算超出最大限制</td>\n</tr>\n<tr>\n<td align=\"left\">ZeroDivisionError</td>\n<td align=\"left\">除(或取模)零 (所有数据类型)</td>\n</tr>\n<tr>\n<td align=\"left\">AssertionError</td>\n<td align=\"left\">断言语句失败</td>\n</tr>\n<tr>\n<td align=\"left\">AttributeError</td>\n<td align=\"left\">对象没有这个属性</td>\n</tr>\n<tr>\n<td align=\"left\">EOFError</td>\n<td align=\"left\">没有内建输入,到达EOF 标记</td>\n</tr>\n<tr>\n<td align=\"left\">EnvironmentError</td>\n<td align=\"left\">操作系统错误的基类</td>\n</tr>\n<tr>\n<td align=\"left\">IOError</td>\n<td align=\"left\">输入/输出操作失败</td>\n</tr>\n<tr>\n<td align=\"left\">OSError</td>\n<td align=\"left\">操作系统错误</td>\n</tr>\n<tr>\n<td align=\"left\">WindowsError</td>\n<td align=\"left\">系统调用失败</td>\n</tr>\n<tr>\n<td align=\"left\">ImportError</td>\n<td align=\"left\">导入模块/对象失败</td>\n</tr>\n<tr>\n<td align=\"left\">LookupError</td>\n<td align=\"left\">无效数据查询的基类</td>\n</tr>\n<tr>\n<td align=\"left\">IndexError</td>\n<td align=\"left\">序列中没有此索引(index)</td>\n</tr>\n<tr>\n<td align=\"left\">KeyError</td>\n<td align=\"left\">映射中没有这个键</td>\n</tr>\n<tr>\n<td align=\"left\">MemoryError</td>\n<td align=\"left\">内存溢出错误(对于Python 解释器不是致命的)</td>\n</tr>\n<tr>\n<td align=\"left\">NameError</td>\n<td align=\"left\">未声明/初始化对象 (没有属性)</td>\n</tr>\n<tr>\n<td align=\"left\">UnboundLocalError</td>\n<td align=\"left\">访问未初始化的本地变量</td>\n</tr>\n<tr>\n<td align=\"left\">ReferenceError</td>\n<td align=\"left\">弱引用(Weak reference)试图访问已经垃圾回收了的对象</td>\n</tr>\n<tr>\n<td align=\"left\">RuntimeError</td>\n<td align=\"left\">一般的运行时错误</td>\n</tr>\n<tr>\n<td align=\"left\">NotImplementedError</td>\n<td align=\"left\">尚未实现的方法</td>\n</tr>\n<tr>\n<td align=\"left\">SyntaxError</td>\n<td align=\"left\">Python 语法错误</td>\n</tr>\n<tr>\n<td align=\"left\">IndentationError</td>\n<td align=\"left\">缩进错误</td>\n</tr>\n<tr>\n<td align=\"left\">TabError</td>\n<td align=\"left\">Tab 和空格混用</td>\n</tr>\n<tr>\n<td align=\"left\">SystemError</td>\n<td align=\"left\">一般的解释器系统错误</td>\n</tr>\n<tr>\n<td align=\"left\">TypeError</td>\n<td align=\"left\">对类型无效的操作</td>\n</tr>\n<tr>\n<td align=\"left\">ValueError</td>\n<td align=\"left\">传入无效的参数</td>\n</tr>\n<tr>\n<td align=\"left\">UnicodeError</td>\n<td align=\"left\">Unicode 相关的错误</td>\n</tr>\n<tr>\n<td align=\"left\">UnicodeDecodeError</td>\n<td align=\"left\">Unicode 解码时的错误</td>\n</tr>\n<tr>\n<td align=\"left\">UnicodeEncodeError</td>\n<td align=\"left\">Unicode 编码时错误</td>\n</tr>\n<tr>\n<td align=\"left\">UnicodeTranslateError</td>\n<td align=\"left\">Unicode 转换时错误</td>\n</tr>\n<tr>\n<td align=\"left\">Warning</td>\n<td align=\"left\">警告的基类</td>\n</tr>\n<tr>\n<td align=\"left\">DeprecationWarning</td>\n<td align=\"left\">关于被弃用的特征的警告</td>\n</tr>\n<tr>\n<td align=\"left\">FutureWarning</td>\n<td align=\"left\">关于构造将来语义会有改变的警告</td>\n</tr>\n<tr>\n<td align=\"left\">OverflowWarning</td>\n<td align=\"left\">旧的关于自动提升为长整型(long)的警告</td>\n</tr>\n<tr>\n<td align=\"left\">PendingDeprecationWarning</td>\n<td align=\"left\">关于特性将会被废弃的警告</td>\n</tr>\n<tr>\n<td align=\"left\">RuntimeWarning</td>\n<td align=\"left\">可疑的运行时行为(runtime behavior)的警告</td>\n</tr>\n<tr>\n<td align=\"left\">SyntaxWarning</td>\n<td align=\"left\">可疑的语法的警告</td>\n</tr>\n<tr>\n<td align=\"left\">UserWarning</td>\n<td align=\"left\">用户代码生成的警告</td>\n</tr>\n</tbody></table>\n<h2 id=\"4-自定义异常\"><a href=\"#4-自定义异常\" class=\"headerlink\" title=\"4.自定义异常\"></a>4.自定义异常</h2><p>python的自定义异常只需要将自定义异常类继承自python标准异常类即可。</p>\n<h1 id=\"十一、面向对象\"><a href=\"#十一、面向对象\" class=\"headerlink\" title=\"十一、面向对象\"></a>十一、面向对象</h1><p>python在设计之初就已经是一门面向对象的语言了，在python中一切皆对象，包括所有的基础类型也是对象，这使得python在创建类和对象时十分容易，但是这也导致python十分消耗内存空间，因为哪怕只创建一个整型也会消耗对于C语言的内存空间。</p>\n<h2 id=\"1-定义类\"><a href=\"#1-定义类\" class=\"headerlink\" title=\"1.定义类\"></a>1.定义类</h2><p>和大多数语言一样，python也使用<code>class</code>关键字来标识类，使用同等量的缩进来标识类的范围，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span>:</span><br>    age = <span class=\"hljs-number\">0</span><br>    name = <span class=\"hljs-string\">&#x27;&#x27;</span><br>    __id = <span class=\"hljs-number\">1</span><br>    _sex = <span class=\"hljs-string\">&#x27;female&#x27;</span><br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__init__</span>(<span class=\"hljs-params\">self, age, name</span>):</span><br>        self.age = age<br>        self.name = name<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">GetName</span>(<span class=\"hljs-params\">this</span>):</span><br>        print(<span class=\"hljs-string\">&#x27;my name is &#x27;</span> + this.name)<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__SetId</span>():</span><br>        <span class=\"hljs-built_in\">id</span> = 001<br><br><br>p = Person(<span class=\"hljs-number\">18</span>, <span class=\"hljs-string\">&#x27;lusa&#x27;</span>)<br>p.GetName()<br></code></pre></td></tr></table></figure>\n<h2 id=\"2-成员变量\"><a href=\"#2-成员变量\" class=\"headerlink\" title=\"2.成员变量\"></a>2.成员变量</h2><h3 id=\"私有成员变量\"><a href=\"#私有成员变量\" class=\"headerlink\" title=\"私有成员变量\"></a>私有成员变量</h3><p>由于python无法使用public，private等关键字，所以python使用双下划线开头来标识私有成员变量。如上面代码中的<code>__id</code>。</p>\n<h3 id=\"保护成员变量\"><a href=\"#保护成员变量\" class=\"headerlink\" title=\"保护成员变量\"></a>保护成员变量</h3><p>python使用单下划线开头来标识保护成员变量，如上面代码中的<code>_sex</code>。</p>\n<h3 id=\"公有成员变量\"><a href=\"#公有成员变量\" class=\"headerlink\" title=\"公有成员变量\"></a>公有成员变量</h3><p>不带有任何前缀的变量的就是公有成员变量。</p>\n<h2 id=\"3-成员函数\"><a href=\"#3-成员函数\" class=\"headerlink\" title=\"3.成员函数\"></a>3.成员函数</h2><h3 id=\"私有函数、保护函数和公有函数\"><a href=\"#私有函数、保护函数和公有函数\" class=\"headerlink\" title=\"私有函数、保护函数和公有函数\"></a>私有函数、保护函数和公有函数</h3><p>和变量一样，python使用双下划线来前缀来标识私有函数，用单下划线前缀来标识保护函数，无前缀函数表示公有函数。</p>\n<h3 id=\"self参数\"><a href=\"#self参数\" class=\"headerlink\" title=\"self参数\"></a>self参数</h3><p><font color=\"red\">与其他语言不同的是，python的函数都必须带有一个self参数，self参数的在效果上与C++的this指针很像，但是python的self参数不是类自带的，在定义函数时需要手动显示表示，且必须放在函数的第一个参数位置，self参数的名字不一定非得叫self也可以叫其他的名字，如上面代码中的GetName函数的this，但是按照python的规范建议将都是用self命名，self参数指向当前类实例，类的实例变量都必须使用self参数才能访问，直接使用是无法访问的，如：</font></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span>:</span><br>    age = <span class=\"hljs-number\">0</span><br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__init__</span>(<span class=\"hljs-params\">self, param</span>):</span><br>        age = param<br></code></pre></td></tr></table></figure>\n<p>不通过self参数访问类的成员变量将直接报语法错误。</p>\n<h2 id=\"4-类变量、实例变量和局部变量\"><a href=\"#4-类变量、实例变量和局部变量\" class=\"headerlink\" title=\"4.类变量、实例变量和局部变量\"></a>4.类变量、实例变量和局部变量</h2><h3 id=\"类变量\"><a href=\"#类变量\" class=\"headerlink\" title=\"类变量\"></a>类变量</h3><p>定义在类的内部且定义在方法体外的变量，如上面代码中age，<font color=\"red\">类变量可以被类直接访问，也可以被实例直接访问，同时可以被实例方法和类方法方法访问，但是不可以被静态方法访问</font>。如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span>:</span><br>    names = <span class=\"hljs-string\">&#x27;aa&#x27;</span><br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__init__</span>(<span class=\"hljs-params\">self, age, name</span>):</span><br>        self.age = age<br>        self.name = name<br>        addr = <span class=\"hljs-string\">&#x27;beijing&#x27;</span><br>        names = <span class=\"hljs-string\">&quot;bb&quot;</span><br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">GetName</span>(<span class=\"hljs-params\">self</span>):</span><br>        self.sex = <span class=\"hljs-string\">&#x27;female&#x27;</span><br>        print(<span class=\"hljs-string\">&#x27;my name is &#x27;</span> + self.names)<br><br><span class=\"hljs-meta\">    @staticmethod</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">PP</span>():</span><br>        print(names)<br>    <br><span class=\"hljs-meta\">    @classmethod</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">OO</span>(<span class=\"hljs-params\">cls</span>):</span>       <br>        print(cls.names)<br><br><br>p = Person(<span class=\"hljs-number\">18</span>, <span class=\"hljs-string\">&quot;lusa&quot;</span>)<br>print(p.names)<br>p.names = <span class=\"hljs-string\">&quot;cc&quot;</span><br>p.GetName()<br>print(Person.names)<br>Person.names = <span class=\"hljs-string\">&quot;dd&quot;</span><br>Person.OO()<br>print(p.names)<br>Person.PP()<br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">aa<br>my name <span class=\"hljs-keyword\">is</span> cc<br>aa<br>dd<br>cc<br>Traceback (most recent call last):<br>  File <span class=\"hljs-string\">&quot;d:\\Codes\\Python\\MyFirstPython.py&quot;</span>, line <span class=\"hljs-number\">31</span>, <span class=\"hljs-keyword\">in</span> &lt;module&gt;<br>    Person.PP()<br>  File <span class=\"hljs-string\">&quot;d:\\Codes\\Python\\MyFirstPython.py&quot;</span>, line <span class=\"hljs-number\">16</span>, <span class=\"hljs-keyword\">in</span> PP<br>    print(names)<br>NameError: name <span class=\"hljs-string\">&#x27;names&#x27;</span> <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> definedd<br></code></pre></td></tr></table></figure>\n<p>可以看到，类变量names初始值为aa，我们的本意是在构造函数中再赋值bb但是再实际输出中names的值依旧是aa，当我们使用实例给类变量names赋值为cc时，输出GetName函数输出就变为了cc，然而直接通过类名访问的结果依旧是aa，当我们通过类名赋值names为dd时，类方法输出的结果就变为了dd，然而用实例访问的结果依旧时cc，最终运行到类的静态方法PP处则报错了，由上结果可得出结论：</p>\n<ul>\n<li>类在创建实例时会拷贝一份类变量到实例中，实例中类变量和类中的类变量互相独立</li>\n<li>构造函数不可以初始化类变量，当我们在构造函数初始化一个类变量的同名变量时，实际上python初始化的是一个和类变量同名的局部变量</li>\n<li>同一个类变量既可以被类实例访问也可以被类名直接访问，但二者内存地址时两个内存地址</li>\n<li>静态方法不可以访问类变量</li>\n</ul>\n<h3 id=\"实例变量\"><a href=\"#实例变量\" class=\"headerlink\" title=\"实例变量\"></a>实例变量</h3><p>实例变量是定义在构造函数内部且通过self引出的变量，这两点十分重要，如果一个变量不是在构造函数里创建即使通过self引出也依旧不是实例变量，或一个变量在构造函数中创建但不是由self引出，那它也不是实例变量，而是函数的局部变量，如：上面代码中self.sex，和构造函数里的addr和names，我们是不可以使用实例访问的。</p>\n<h3 id=\"局部变量\"><a href=\"#局部变量\" class=\"headerlink\" title=\"局部变量\"></a>局部变量</h3><p>在构造函数中创建的不由self引出的变量或在其他方法中创建的变量，如上面代码中GetName啊哈桑农户里的self.sex和构造函数里的addr和names</p>\n<h2 id=\"5-类方法、实例方法和静态方法\"><a href=\"#5-类方法、实例方法和静态方法\" class=\"headerlink\" title=\"5.类方法、实例方法和静态方法\"></a>5.类方法、实例方法和静态方法</h2><p>被<code>@classmethod</code>修饰的方法就是类方法，被<code>@staticmethod</code>修饰的方法就是静态方法，除此之外其余的方法都是实例方法。类方法和静态方法也有保护级。</p>\n<h3 id=\"类方法\"><a href=\"#类方法\" class=\"headerlink\" title=\"类方法\"></a>类方法</h3><p>类方法属于类，可以直接通过类型访问，也可以同通过实例访问，访问效果是一样的。在创建类方法时必须至少需要一个参数，一般命名为<code>cls</code>，用于python传递默认参数–类。如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">@classmethod</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">OO</span>(<span class=\"hljs-params\">cls</span>):</span><br>    print(cls.names)<br></code></pre></td></tr></table></figure>\n<p>cls不可省略，在类方法中只能通过cls来访问类变量，且只能访问类变量。</p>\n<h3 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h3><p>静态方法同类方法很相似，也可以被类名和实例直接访问。不同的是，静态方法不需要cls参数，python不会传递默认参数到静态方法，静态方法不可以直接访问类的任何成员。</p>\n<h3 id=\"嵌套函数\"><a href=\"#嵌套函数\" class=\"headerlink\" title=\"嵌套函数\"></a>嵌套函数</h3><p>python支持方法中嵌套创建方法，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">funa</span>():</span><br>    a = <span class=\"hljs-number\">1</span><br>    print(a)<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">funb</span>():</span><br>        <span class=\"hljs-keyword\">nonlocal</span> a<br>        a += <span class=\"hljs-number\">1</span><br>        print(a)<br>   <br>    funb()<br><br><br>funa()<br></code></pre></td></tr></table></figure>\n<h1 id=\"十二、作用域\"><a href=\"#十二、作用域\" class=\"headerlink\" title=\"十二、作用域\"></a>十二、作用域</h1><p>python的作用域大部分与C系列语言的作用域差不多，只是有三点比较特殊：</p>\n<ul>\n<li><p>python中只有类、函数、模块才会引入新的作用域，控制语句不会引入新的作用域，也就是说，在控制语句中创建的变量可以在控制语句外部被访问</p>\n<p>如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">3</span>):<br>    print(i)<br><br>print(i)<br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-number\">0</span><br><span class=\"hljs-number\">1</span><br><span class=\"hljs-number\">2</span><br><span class=\"hljs-number\">2</span><br></code></pre></td></tr></table></figure></li>\n<li><p>如果要在函数内部访问全局变量需要在在函数内部使用<code>global</code>申明，否则python将创建一个同名的局部变量而不是引用全局变量</p>\n<p>如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">a = <span class=\"hljs-number\">1</span><br><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">fun</span>():</span><br>    a += <span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n<p>python会直接报语法错误，因为我们使用了一个未定义的局部变量，但是当我们使用global申明之后，我们访问的就是全局变量了，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">a = <span class=\"hljs-number\">1</span><br><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">fun</span>():</span><br>    <span class=\"hljs-keyword\">global</span> a<br>    a += <span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure></li>\n<li><p>如果要在嵌套函数中访问外层函数的变量需要使用<code>nonlocal</code>申明，否则python也会创建一个同名的局部函数，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">a = <span class=\"hljs-number\">1</span><br><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">fun</span>():</span><br>    <span class=\"hljs-keyword\">global</span> a<br>    a += <span class=\"hljs-number\">1</span><br>    b = <span class=\"hljs-number\">2</span><br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">funb</span>():</span><br>        <span class=\"hljs-keyword\">global</span> a<br>        <span class=\"hljs-keyword\">nonlocal</span> b<br>        b += <span class=\"hljs-number\">1</span><br>        print(a)<br>        print(b)<br><br>    funb()<br><br><br>fun()<br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-number\">2</span><br><span class=\"hljs-number\">3</span><br></code></pre></td></tr></table></figure>\n\n\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<center><font size=\"6\"><strong>Python基础</strong></font></center>","more":"<h1 id=\"一、中文编码、注释与标准文档\"><a href=\"#一、中文编码、注释与标准文档\" class=\"headerlink\" title=\"一、中文编码、注释与标准文档\"></a>一、中文编码、注释与标准文档</h1><h2 id=\"1-中文编码\"><a href=\"#1-中文编码\" class=\"headerlink\" title=\"1.中文编码\"></a>1.中文编码</h2><p>若只需要在单个文件中指定中文编码，只需在文件开始处添加</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># _*_ coding: UTF-8 _*_</span><br></code></pre></td></tr></table></figure>\n<p>即可。</p>\n<p>如果要在整个工程里设置中文编码，则需要在编辑器中设置工程的编码为UTF-8。</p>\n<h2 id=\"2-单行注释\"><a href=\"#2-单行注释\" class=\"headerlink\" title=\"2.单行注释\"></a>2.单行注释</h2><p>python使用<code>#</code>来接单行注释</p>\n<h2 id=\"3-多行注释\"><a href=\"#3-多行注释\" class=\"headerlink\" title=\"3.多行注释\"></a>3.多行注释</h2><p>python使用<code>&#39;&#39;&#39;</code>或<code>&quot;&quot;&quot;</code>（三个单引号或三个双引号）来包含多行注释</p>\n<p>如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># 这是单行注释</span><br><span class=\"hljs-string\">&#x27;&#x27;&#x27;</span><br><span class=\"hljs-string\">这是使用三个单引号的</span><br><span class=\"hljs-string\">多行注释</span><br><span class=\"hljs-string\">&#x27;&#x27;&#x27;</span><br><span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">这是使用三个双引号的</span><br><span class=\"hljs-string\">多行注释</span><br><span class=\"hljs-string\">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"4-标准文档\"><a href=\"#4-标准文档\" class=\"headerlink\" title=\"4.标准文档\"></a>4.标准文档</h2><p><a href=\"https://docs.python.org/zh-cn/3.7/library/index.html\">官方文档</a></p>\n<h1 id=\"二、标识符与代码块\"><a href=\"#二、标识符与代码块\" class=\"headerlink\" title=\"二、标识符与代码块\"></a>二、标识符与代码块</h1><h2 id=\"1-标识符规则\"><a href=\"#1-标识符规则\" class=\"headerlink\" title=\"1.标识符规则\"></a>1.标识符规则</h2><ul>\n<li>python标识符大小写敏感。</li>\n<li>python中以下划线开头的标识符有特殊的含义，以单下划线开头的标识符代表不能直接访问的类属性，需要通过类提供的接口进行访问，不能用from xxx import *导入，如：_value。</li>\n<li>以双下划线开头的标识符代表类的私有成员，如：<code>__value</code>。</li>\n<li>以双下划线开头和结尾的标识符代表python里特殊方法的专用标识符，如：<code>__init__()</code>代表类的构造函数。</li>\n</ul>\n<h2 id=\"2-保留字符\"><a href=\"#2-保留字符\" class=\"headerlink\" title=\"2.保留字符\"></a>2.保留字符</h2><table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\"></th>\n<th align=\"center\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">and</td>\n<td align=\"center\">exec</td>\n<td align=\"center\">not</td>\n</tr>\n<tr>\n<td align=\"center\">assert</td>\n<td align=\"center\">finally</td>\n<td align=\"center\">or</td>\n</tr>\n<tr>\n<td align=\"center\">break</td>\n<td align=\"center\">for</td>\n<td align=\"center\">pass</td>\n</tr>\n<tr>\n<td align=\"center\">class</td>\n<td align=\"center\">from</td>\n<td align=\"center\">print</td>\n</tr>\n<tr>\n<td align=\"center\">continue</td>\n<td align=\"center\">global</td>\n<td align=\"center\">raise</td>\n</tr>\n<tr>\n<td align=\"center\">def</td>\n<td align=\"center\">if</td>\n<td align=\"center\">return</td>\n</tr>\n<tr>\n<td align=\"center\">del</td>\n<td align=\"center\">import</td>\n<td align=\"center\">try</td>\n</tr>\n<tr>\n<td align=\"center\">elif</td>\n<td align=\"center\">in</td>\n<td align=\"center\">while</td>\n</tr>\n<tr>\n<td align=\"center\">else</td>\n<td align=\"center\">is</td>\n<td align=\"center\">with</td>\n</tr>\n<tr>\n<td align=\"center\">except</td>\n<td align=\"center\">lambda</td>\n<td align=\"center\">yield</td>\n</tr>\n</tbody></table>\n<h2 id=\"3-代码块\"><a href=\"#3-代码块\" class=\"headerlink\" title=\"3.代码块\"></a>3.代码块</h2><p>python与C系列语言最大的不同就是python没有了<code>&#123;&#125;</code>囊括的代码块，而采用了<font color=\"red\">缩进</font>来表示代码块，即在一个代码块中的代码采用同等数量的数量的缩进，缩进的数量按空格的数量计算，采用同一缩进量的代码属于同一格代码块。</p>\n<p>如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">if</span> ture:<br>    a = <span class=\"hljs-number\">1</span><br>    b = <span class=\"hljs-number\">2</span><br></code></pre></td></tr></table></figure>\n<p><code>a=1;</code>与<code>b=2</code>同属于if语句的代码块中。</p>\n<h3 id=\"python空行规范\"><a href=\"#python空行规范\" class=\"headerlink\" title=\"python空行规范\"></a>python空行规范</h3><ul>\n<li><p>类与其他代码块之间需要空两行</p>\n</li>\n<li><p>方法体与其他代码块之间需要空一行</p>\n</li>\n<li><p>全局函数与其他代码块之间需要空两行</p>\n<p>如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span>:</span><br>    names = <span class=\"hljs-string\">&#x27;aa&#x27;</span><br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__init__</span>(<span class=\"hljs-params\">self, age, name</span>):</span><br>        self.age = age<br>        self.name = name<br>        addr = <span class=\"hljs-string\">&#x27;beijing&#x27;</span><br>        names = <span class=\"hljs-string\">&quot;bb&quot;</span><br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">GetName</span>(<span class=\"hljs-params\">self</span>):</span><br>        self.sex = <span class=\"hljs-string\">&#x27;female&#x27;</span><br>        print(<span class=\"hljs-string\">&#x27;my name is &#x27;</span> + self.names)<br><br><span class=\"hljs-meta\">    @staticmethod</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">PP</span>():</span><br>        print(names)<br>    <br><span class=\"hljs-meta\">    @classmethod</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">OO</span>(<span class=\"hljs-params\">cls</span>):</span>       <br>        print(cls.names)<br><br><br>p = Person(<span class=\"hljs-number\">18</span>, <span class=\"hljs-string\">&#x27;lusa&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n\n</li>\n</ul>\n<h2 id=\"4-多行语句\"><a href=\"#4-多行语句\" class=\"headerlink\" title=\"4.多行语句\"></a>4.多行语句</h2><p>由于python即使用了<code>;</code>来分割同行的不同语句，同时通过新行来结束上一句语句，所以如果代码需要换行的话需要使用<font color=\"red\"> <code>\\</code></font>来分割多行。</p>\n<p>如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">a = b \\<br>\t+ c \\<br>    + d<br></code></pre></td></tr></table></figure>\n<p><font color=\"green\"> <strong>例外</strong>：包括在<code>[]</code>、<code>()</code>、<code>&#123;&#125;</code>中的语句换行不需要使用<code>\\</code>。</font></p>\n<h1 id=\"三、变量及数据结构\"><a href=\"#三、变量及数据结构\" class=\"headerlink\" title=\"三、变量及数据结构\"></a>三、变量及数据结构</h1><p>python支持</p>\n<ul>\n<li>Numbers-数字</li>\n<li>String-字符串</li>\n<li>List-列表</li>\n<li>Tuple-原表</li>\n<li>Dictionary-字典</li>\n</ul>\n<p>几种数据类型。</p>\n<h2 id=\"1-Numbers\"><a href=\"#1-Numbers\" class=\"headerlink\" title=\"1.Numbers\"></a>1.Numbers</h2><p>其中Numbers又分为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mermaid\">graph LR;<br>Numbers---int---有符号整型;<br>Numbers---long---长整型-使用小写l或大写L表示;<br>Numbers---float---浮点型;<br>Numbers---complex---复数-使用a+bj表示或complex函数生成;<br></code></pre></td></tr></table></figure>\n<p>需要注意的是python不支持double。</p>\n<p><font color=\"red\"> long在python3.x以后被移除。</font></p>\n<h2 id=\"2-String\"><a href=\"#2-String\" class=\"headerlink\" title=\"2.String\"></a>2.String</h2><p><font color=\"red\">使用Python字符串时首先需要明确一点，就是Python不支持单字符，在Python中单字符也被当作字符串使用。</font></p>\n<p>Python的字符串可以使用<code>&#39;</code>,<code>&quot;</code>,<code>&#39;&#39;&#39;</code>,<code>&quot;&quot;&quot;</code>来标识字符串，有单引号和双引号来表示字符串就够了，那么为什么Python要使用三单引号<code>&#39;&#39;&#39;</code>和三双引号<code>&quot;&quot;&quot;</code>来标识字符串呢？</p>\n<h3 id=\"39-39-39-和-quot-quot-quot-的优点\"><a href=\"#39-39-39-和-quot-quot-quot-的优点\" class=\"headerlink\" title=\"&#39;&#39;&#39;和&quot;&quot;&quot;的优点\"></a><code>&#39;&#39;&#39;</code>和<code>&quot;&quot;&quot;</code>的优点</h3><p>要想直观的了解三单引号和三双引号的优点，我们首先使用C#字符串来写一个SQL语句</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C#\"><span class=\"hljs-built_in\">string</span> sql=<span class=\"hljs-string\">&quot;select xm as 姓名,xb as 性别 from db_table where xm = @xm and xb = @xb and (bm like &#x27;%666&#x27; or bm like &#x27;666%&#x27;) order by grade &gt; 90 desc&quot;</span>;<br>OleDbCommand cmd = <span class=\"hljs-keyword\">new</span> OleDbCommand();<br>cmd.CommandText = sql;<br>cmd.Parameters.AddWithValue(<span class=\"hljs-string\">&quot;@xm&quot;</span>, txtName.Text);<br>cmd.Parameters.AddWithValue(<span class=\"hljs-string\">&quot;@xb&quot;</span>, txtSex.Text);<br>cmd.Connection = conn;<br>conn.Open();<br>cmd.ExecuteNonQuery();<br></code></pre></td></tr></table></figure>\n<p>我们再使用Python写一句同样的SQL语句</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Python\">sql = <span class=\"hljs-string\">&#x27;&#x27;&#x27;</span><br><span class=\"hljs-string\">select xm as 姓名,xb as 性别 from db_table </span><br><span class=\"hljs-string\">where xm = &#x27;&#123;0&#125;&#x27; and xb = &#123;1&#125; and (bm like &#x27;%666&#x27; or bm like &#x27;666%&#x27;) </span><br><span class=\"hljs-string\">order by grade &gt; 90 desc</span><br><span class=\"hljs-string\">&#x27;&#x27;&#x27;</span>.<span class=\"hljs-built_in\">format</span>(txtName.Text,txtSex.Text)<br>cuesor = conn.cursor()<br>cursor.execute(sql)<br>cursor.close()<br></code></pre></td></tr></table></figure>\n<p>有没有发现Python在写sql字符串时十分优雅呢？尤其是在写很长的sql语句时这个效果尤为突出，得益于Python三引号字符串的可换行支持，Python的sql可以在传参的同时保留sql的优雅格式，极大的提高了sql的可阅读性。</p>\n<p>python的字符串是不可变的，当我们对字符串进行操作时，python都会生成新的字符串，而不会在旧的字符串的基础上进行修改。</p>\n<ul>\n<li>与C系列语言对字符串的操作有些差异的是python使用<code>*</code>来重复字符串，如：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-built_in\">str</span> = <span class=\"hljs-string\">&#x27;a&#x27;</span><br>str2 = <span class=\"hljs-built_in\">str</span>*<span class=\"hljs-number\">2</span> <span class=\"hljs-comment\">#str2存储的是&#x27;aa&#x27;</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li>String支持从前索引和从后索引，从前索引的首地址索引为0，从后索引的末地址为-1</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">a</th>\n<th align=\"center\">b</th>\n<th align=\"center\">c</th>\n<th align=\"center\">d</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">2</td>\n<td align=\"center\">3</td>\n</tr>\n<tr>\n<td align=\"center\">-4</td>\n<td align=\"center\">-3</td>\n<td align=\"center\">-2</td>\n<td align=\"center\">-1</td>\n</tr>\n</tbody></table>\n<ul>\n<li>python支持直接通过索引截取子字符串，如：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-built_in\">str</span> = <span class=\"hljs-string\">&#x27;abcd&#x27;</span><br>str2 = <span class=\"hljs-built_in\">str</span>[<span class=\"hljs-number\">1</span>:<span class=\"hljs-number\">3</span>] <span class=\"hljs-comment\">#str2存储的是&#x27;bc&#x27;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"转移字符\"><a href=\"#转移字符\" class=\"headerlink\" title=\"转移字符\"></a>转移字符</h3><table>\n<thead>\n<tr>\n<th>字符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>\\</code>(在行尾时)</td>\n<td>续行符</td>\n</tr>\n<tr>\n<td>\\</td>\n<td>反斜杠符号</td>\n</tr>\n<tr>\n<td>&#39;</td>\n<td>单引号</td>\n</tr>\n<tr>\n<td>&quot;</td>\n<td>双引号</td>\n</tr>\n<tr>\n<td>\\a</td>\n<td>响铃</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>退格(Backspace)</td>\n</tr>\n<tr>\n<td>\\e</td>\n<td>转义</td>\n</tr>\n<tr>\n<td>\\000</td>\n<td>空</td>\n</tr>\n<tr>\n<td>\\n</td>\n<td>换行</td>\n</tr>\n<tr>\n<td>\\v</td>\n<td>纵向制表符</td>\n</tr>\n<tr>\n<td>\\t</td>\n<td>横向制表符</td>\n</tr>\n<tr>\n<td>\\r</td>\n<td>回车</td>\n</tr>\n<tr>\n<td>\\f</td>\n<td>换页</td>\n</tr>\n<tr>\n<td>\\oyy</td>\n<td>八进制数，y 代表 0~7 的字符，例如：\\012 代表换行</td>\n</tr>\n<tr>\n<td>\\xyy</td>\n<td>十六进制数，以 \\x 开头，yy代表的字符，例如：\\x0a代表换行</td>\n</tr>\n<tr>\n<td>\\other</td>\n<td>其它的字符以普通格式输出</td>\n</tr>\n</tbody></table>\n<h3 id=\"两个特殊的字符串运算符\"><a href=\"#两个特殊的字符串运算符\" class=\"headerlink\" title=\"两个特殊的字符串运算符\"></a>两个特殊的字符串运算符</h3><table>\n<thead>\n<tr>\n<th>字符</th>\n<th>说明</th>\n<th>实例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>r/R</td>\n<td><font color=\"red\">原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母<code>r</code>（可以大小写）以外，与普通字符串有着几乎完全相同的语法。</font></td>\n<td>print(r’/n’)<br>输出结果：<br>/n</td>\n</tr>\n<tr>\n<td>%</td>\n<td>格式字符串</td>\n<td></td>\n</tr>\n<tr>\n<td>u</td>\n<td>在字符串的前面加上一个字母u即表示创建Unicode字符串，可以通过<code>\\u</code>+Unicode编码向字符串中插入任何Unicode支持的字符</td>\n<td>print(u’a\\u2201a’)<br>输出结果：<br>a⤀a</td>\n</tr>\n</tbody></table>\n<h3 id=\"字符串格式化\"><a href=\"#字符串格式化\" class=\"headerlink\" title=\"字符串格式化\"></a>字符串格式化</h3><p>Python中的字符串格式化和C基本保持一致，插入整型也是用的<code>%d</code></p>\n<table>\n<thead>\n<tr>\n<th>符号</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>%c</td>\n<td>格式化字符及其ASCII码</td>\n</tr>\n<tr>\n<td>%s</td>\n<td>格式化字符串</td>\n</tr>\n<tr>\n<td>%d</td>\n<td>格式化整数</td>\n</tr>\n<tr>\n<td>%u</td>\n<td>格式化无符号整型</td>\n</tr>\n<tr>\n<td>%o</td>\n<td>格式化无符号八进制数</td>\n</tr>\n<tr>\n<td>%x</td>\n<td>格式化无符号十六进制数</td>\n</tr>\n<tr>\n<td>%X</td>\n<td>格式化无符号十六进制数（大写）</td>\n</tr>\n<tr>\n<td>%f</td>\n<td>格式化浮点数字，可指定小数点后的精度</td>\n</tr>\n<tr>\n<td>%e</td>\n<td>用科学计数法格式化浮点数</td>\n</tr>\n<tr>\n<td>%E</td>\n<td>作用同%e，用科学计数法格式化浮点数</td>\n</tr>\n<tr>\n<td>%g</td>\n<td>%f和%e的简写</td>\n</tr>\n<tr>\n<td>%G</td>\n<td>%F 和 %E 的简写</td>\n</tr>\n<tr>\n<td>%p</td>\n<td>用十六进制数格式化变量的地址</td>\n</tr>\n</tbody></table>\n<h3 id=\"格式化操作辅助指令\"><a href=\"#格式化操作辅助指令\" class=\"headerlink\" title=\"格式化操作辅助指令\"></a>格式化操作辅助指令</h3><table>\n<thead>\n<tr>\n<th>符号</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>*</td>\n<td>定义宽度或者小数点精度</td>\n</tr>\n<tr>\n<td>-</td>\n<td>用做左对齐</td>\n</tr>\n<tr>\n<td>+</td>\n<td>在正数前面显示加号( + )</td>\n</tr>\n<tr>\n<td><code>&lt;sp&gt;</code></td>\n<td>在正数前面显示空格</td>\n</tr>\n<tr>\n<td>#</td>\n<td>在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’)</td>\n</tr>\n<tr>\n<td>0</td>\n<td>显示的数字前面填充’0’而不是默认的空格</td>\n</tr>\n<tr>\n<td>%</td>\n<td>‘%%’输出一个单一的’%’</td>\n</tr>\n<tr>\n<td>(var)</td>\n<td>映射变量(字典参数)</td>\n</tr>\n<tr>\n<td>m.n.</td>\n<td>m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)</td>\n</tr>\n</tbody></table>\n<h3 id=\"String内置函数\"><a href=\"#String内置函数\" class=\"headerlink\" title=\"String内置函数\"></a>String内置函数</h3><table>\n<thead>\n<tr>\n<th align=\"left\"><strong>方法</strong></th>\n<th align=\"left\"><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-capitalize.html\">string.capitalize()</a></td>\n<td align=\"left\">把字符串的第一个字符大写</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-center.html\">string.center(width)</a></td>\n<td align=\"left\">返回一个原字符串居中,并使用空格填充至长度 width 的新字符串</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><a href=\"https://www.runoob.com/python/att-string-count.html\">string.count(str, beg=0, end=len(string))</a></strong></td>\n<td align=\"left\">返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-decode.html\">string.decode(encoding=’UTF-8’, errors=’strict’)</a></td>\n<td align=\"left\">以 encoding 指定的编码格式解码 string，如果出错默认报一个 ValueError 的 异 常 ， 除非 errors 指 定 的 是 ‘ignore’ 或 者’replace’</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-encode.html\">string.encode(encoding=’UTF-8’, errors=’strict’)</a></td>\n<td align=\"left\">以 encoding 指定的编码格式编码 string，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><a href=\"https://www.runoob.com/python/att-string-endswith.html\">string.endswith(obj, beg=0, end=len(string))</a></strong></td>\n<td align=\"left\">检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-expandtabs.html\">string.expandtabs(tabsize=8)</a></td>\n<td align=\"left\">把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><a href=\"https://www.runoob.com/python/att-string-find.html\">string.find(str, beg=0, end=len(string))</a></strong></td>\n<td align=\"left\">检测 str 是否包含在 string 中，如果 beg 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回-1</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><a href=\"https://www.runoob.com/python/att-string-format.html\">string.format()</a></strong></td>\n<td align=\"left\">格式化字符串</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><a href=\"https://www.runoob.com/python/att-string-index.html\">string.index(str, beg=0, end=len(string))</a></strong></td>\n<td align=\"left\">跟find()方法一样，只不过如果str不在 string中会报一个异常.</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-isalnum.html\">string.isalnum()</a></td>\n<td align=\"left\">如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True,否则返回 False</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-isalpha.html\">string.isalpha()</a></td>\n<td align=\"left\">如果 string 至少有一个字符并且所有字符都是字母则返回 True,否则返回 False</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-isdecimal.html\">string.isdecimal()</a></td>\n<td align=\"left\">如果 string 只包含十进制数字则返回 True 否则返回 False.</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-isdigit.html\">string.isdigit()</a></td>\n<td align=\"left\">如果 string 只包含数字则返回 True 否则返回 False.</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-islower.html\">string.islower()</a></td>\n<td align=\"left\">如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-isnumeric.html\">string.isnumeric()</a></td>\n<td align=\"left\">如果 string 中只包含数字字符，则返回 True，否则返回 False</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-isspace.html\">string.isspace()</a></td>\n<td align=\"left\">如果 string 中只包含空格，则返回 True，否则返回 False.</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-istitle.html\">string.istitle()</a></td>\n<td align=\"left\">如果 string 是标题化的(见 title())则返回 True，否则返回 False</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-isupper.html\">string.isupper()</a></td>\n<td align=\"left\">如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><a href=\"https://www.runoob.com/python/att-string-join.html\">string.join(seq)</a></strong></td>\n<td align=\"left\">以 string 作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-ljust.html\">string.ljust(width)</a></td>\n<td align=\"left\">返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-lower.html\">string.lower()</a></td>\n<td align=\"left\">转换 string 中所有大写字符为小写.</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-lstrip.html\">string.lstrip()</a></td>\n<td align=\"left\">截掉 string 左边的空格</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-maketrans.html\">string.maketrans(intab, outtab])</a></td>\n<td align=\"left\">maketrans() 方法用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-max.html\">max(str)</a></td>\n<td align=\"left\">返回字符串 <em>str</em> 中最大的字母。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-min.html\">min(str)</a></td>\n<td align=\"left\">返回字符串 <em>str</em> 中最小的字母。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><a href=\"https://www.runoob.com/python/att-string-partition.html\">string.partition(str)</a></strong></td>\n<td align=\"left\">有点像 find()和 split()的结合体,从 str 出现的第一个位置起,把 字 符 串 string 分 成 一 个 3 元 素 的 元 组 (string_pre_str,str,string_post_str),如果 string 中不包含str 则 string_pre_str == string.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><a href=\"https://www.runoob.com/python/att-string-replace.html\">string.replace(str1, str2, num=string.count(str1))</a></strong></td>\n<td align=\"left\">把 string 中的 str1 替换成 str2,如果 num 指定，则替换不超过 num 次.</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-rfind.html\">string.rfind(str, beg=0,end=len(string) )</a></td>\n<td align=\"left\">类似于 find() 函数，返回字符串最后一次出现的位置，如果没有匹配项则返回 -1。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-rindex.html\">string.rindex( str, beg=0,end=len(string))</a></td>\n<td align=\"left\">类似于 index()，不过是从右边开始.</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-rjust.html\">string.rjust(width)</a></td>\n<td align=\"left\">返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-rpartition.html\">string.rpartition(str)</a></td>\n<td align=\"left\">类似于 partition()函数,不过是从右边开始查找</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-rstrip.html\">string.rstrip()</a></td>\n<td align=\"left\">删除 string 字符串末尾的空格.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><a href=\"https://www.runoob.com/python/att-string-split.html\">string.split(str=””, num=string.count(str))</a></strong></td>\n<td align=\"left\">以 str 为分隔符切片 string，如果 num 有指定值，则仅分隔 num+ 个子字符串</td>\n</tr>\n<tr>\n<td align=\"left\">[string.splitlines(<a href=\"https://www.runoob.com/python/att-string-splitlines.html\">keepends])</a></td>\n<td align=\"left\">按照行(‘\\r’, ‘\\r\\n’, \\n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-startswith.html\">string.startswith(obj, beg=0,end=len(string))</a></td>\n<td align=\"left\">检查字符串是否是以 obj 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>[string.strip(<a href=\"https://www.runoob.com/python/att-string-strip.html\">obj])</a></strong></td>\n<td align=\"left\">在 string 上执行 lstrip()和 rstrip()</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-swapcase.html\">string.swapcase()</a></td>\n<td align=\"left\">翻转 string 中的大小写</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-title.html\">string.title()</a></td>\n<td align=\"left\">返回”标题化”的 string,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><a href=\"https://www.runoob.com/python/att-string-translate.html\">string.translate(str, del=””)</a></strong></td>\n<td align=\"left\">根据 str 给出的表(包含 256 个字符)转换 string 的字符,要过滤掉的字符放到 del 参数中</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-upper.html\">string.upper()</a></td>\n<td align=\"left\">转换 string 中的小写字母为大写</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-string-zfill.html\">string.zfill(width)</a></td>\n<td align=\"left\">返回长度为 width 的字符串，原字符串 string 右对齐，前面填充0</td>\n</tr>\n</tbody></table>\n<h2 id=\"3-Tuple\"><a href=\"#3-Tuple\" class=\"headerlink\" title=\"3.Tuple\"></a>3.Tuple</h2><p>==元组类似与C#中<code>readonly List</code>，是一个只读列表，但是python的元组的元素可以是不同的类型，python用<code>()</code>来表示元组。==元组支持存储不同类型元素，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">t = (<span class=\"hljs-string\">&#x27;a&#x27;</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">3.14</span>)<br></code></pre></td></tr></table></figure>\n<p>这里的元组只读及元素不可修改</p>\n<h3 id=\"创建空元组\"><a href=\"#创建空元组\" class=\"headerlink\" title=\"创建空元组\"></a>创建空元组</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">t = ()<br></code></pre></td></tr></table></figure>\n<h3 id=\"创建一个值的元组\"><a href=\"#创建一个值的元组\" class=\"headerlink\" title=\" 创建一个值的元组\"></a><font color=\"red\"> 创建一个值的元组</font></h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">t = (<span class=\"hljs-number\">12</span>,)//逗号不可省略<br></code></pre></td></tr></table></figure>\n<p><font color=\"red\"> 需要特别注意的是<code>,</code>不可省略，如果省略了，<code>t=(12)</code>就等于<code>t=12</code></font></p>\n<h3 id=\"元组的分片操作\"><a href=\"#元组的分片操作\" class=\"headerlink\" title=\"元组的分片操作\"></a>元组的分片操作</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">t = (<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>)<br>print(t[<span class=\"hljs-number\">1</span>:<span class=\"hljs-number\">3</span>])<br><span class=\"hljs-comment\">#输出结果为2，3</span><br></code></pre></td></tr></table></figure>\n<p>分片操作可以批量的取元组中的数据，值不能取到3号索引，只能取到3号索引的前一位。</p>\n<h3 id=\"Tuple的-和-操作\"><a href=\"#Tuple的-和-操作\" class=\"headerlink\" title=\"Tuple的+和*操作\"></a>Tuple的+和*操作</h3><p>和字符串一样，列表的+运算用于组合列表，列表的*运算用于重复列表，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">tu1 = (<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>)<br>tu2 = tu1 + tu1<br>print(tu2)<br>tu3 = tu1*<span class=\"hljs-number\">3</span><br>print(tu3)<br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\">[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]<br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]  <br></code></pre></td></tr></table></figure>\n<h3 id=\"Tuple的无关分隔符\"><a href=\"#Tuple的无关分隔符\" class=\"headerlink\" title=\"Tuple的无关分隔符\"></a>Tuple的无关分隔符</h3><p>任意无符号对象，只要以<code>,</code>分隔，Python都将其是为元组，如</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-built_in\">print</span> <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">3.14</span><br>tu = x, y = <span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span><br></code></pre></td></tr></table></figure>\n<p><code>1, 2, &#39;a&#39;, 3.14</code>，会被视为一个元组，及print打印的事实上是一个元组，tu也会被Python默认转换成一个元组，当然x，y还是可以才开使用的。</p>\n<h3 id=\"Python内置元组操作函数\"><a href=\"#Python内置元组操作函数\" class=\"headerlink\" title=\"Python内置元组操作函数\"></a>Python内置元组操作函数</h3><table>\n<thead>\n<tr>\n<th align=\"left\">方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-tuple-cmp.html\">cmp(tuple1, tuple2)</a></td>\n<td>比较两个元组元素。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-tuple-len.html\">len(tuple)</a></td>\n<td>计算元组元素个数。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-tuple-max.html\">max(tuple)</a></td>\n<td>返回元组中元素最大值。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-tuple-min.html\">min(tuple)</a></td>\n<td>返回元组中元素最小值。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-tuple-tuple.html\">tuple(seq)</a></td>\n<td>将列表转换为元组。</td>\n</tr>\n</tbody></table>\n<h2 id=\"4-List\"><a href=\"#4-List\" class=\"headerlink\" title=\"4.List\"></a>4.List</h2><p>List就和C#中的List基本一致，但是python的List更灵活</p>\n<h3 id=\"List初始化\"><a href=\"#List初始化\" class=\"headerlink\" title=\"List初始化\"></a>List初始化</h3><p>List的初始化使用<code>[]</code>，我们可以使用‘数字’、‘字符串’、‘元组’或‘列表’来初始化一个列表，列表也支持分片操作。</p>\n<p>python的列表可以在一个列表中存储不同类型的元素。</p>\n<p>并且提供一些基础函数</p>\n<ul>\n<li><p>index：从列表中找出某个元素的位置，如果有多个相同的元素，则返回第一个元素的位置，如果没有找到则抛出异常。</p>\n</li>\n<li><p>count：统计某个元素在列表中出现的次数。</p>\n</li>\n<li><p>append：列表末尾增加新的元素。</p>\n</li>\n<li><p>extend：将一个新列表的元素添加到原列表中。</p>\n<p>注意到，虽然 append 和 extend 可接收一个列表作为参数，但是 append 方法是将其作为一个元素添加到列表中，而 extend 则是将新列表的元素逐个添加到原列表中。</p>\n</li>\n<li><p>insert：将某个元素添加到某个位置。</p>\n</li>\n<li><p>pop：移除列表中的一个元素（默认是最后一个），并且返回该元素的值。</p>\n</li>\n<li><p>remove：移除列表中的某个匹配元素，如果有多个匹配，则移除第一个。</p>\n</li>\n<li><p>reverse：将列表中的元素进行反转。</p>\n</li>\n<li><p>sort：对列表进行排序，注意该方法会改变原来的列表，而不是返回新的排序列表，另外，sort 方法的返回值是空。</p>\n<p>如果要使用sort对列表进行排序，那么列表中元素应该保持同一类型。</p>\n</li>\n<li><p>clear：清空列表。</p>\n</li>\n</ul>\n<h3 id=\"列表的集合运算\"><a href=\"#列表的集合运算\" class=\"headerlink\" title=\"列表的集合运算\"></a>列表的集合运算</h3><p>Python提供内置的<code>set()</code>函数来对元素集进行集合运算，set函数支持所有可迭代的对象，包括list和tuple。只要是set函数支持的对象，尽管进行运算的两个对象不是相同类型也依旧可以进行集合运算，如：</p>\n<p><strong>取交集</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">l1 = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-literal\">True</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]<br>l2 = (<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-literal\">True</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>)<br>print(<span class=\"hljs-built_in\">set</span>(l1) &amp; <span class=\"hljs-built_in\">set</span>(l2))<br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">&#123;<span class=\"hljs-number\">1</span>， <span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;a&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>\n<p><font color=\"red\"> 注意：当bool值进行集合运算时会被转换成0和1，但是这个0和1不会和数字的0和1重复。</font></p>\n<p>Python集合运算符</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>|</td>\n<td>取并集</td>\n</tr>\n<tr>\n<td>&amp;</td>\n<td>取交集</td>\n</tr>\n<tr>\n<td>-</td>\n<td>取差集</td>\n</tr>\n<tr>\n<td>^</td>\n<td>取对称差集</td>\n</tr>\n</tbody></table>\n<p><font color=\"red\"> 集合运算符支持<code>set()</code>函数返回的<code>set</code>集合作为运算对象。</font></p>\n<h3 id=\"List的-和-操作\"><a href=\"#List的-和-操作\" class=\"headerlink\" title=\"List的+和*操作\"></a>List的+和*操作</h3><p>和字符串一样，列表的+运算用于组合列表，列表的*运算用于重复列表，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">li = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]<br>li2 = li + li<br>print(li2)<br>li3 = li*<span class=\"hljs-number\">3</span><br>print(li3)<br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\">[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]<br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]  <br></code></pre></td></tr></table></figure>\n<h3 id=\"Python内置列表操作函数\"><a href=\"#Python内置列表操作函数\" class=\"headerlink\" title=\"Python内置列表操作函数\"></a>Python内置列表操作函数</h3><table>\n<thead>\n<tr>\n<th align=\"left\">函数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-list-cmp.html\">cmp(list1, list2)</a></td>\n<td>比较两个列表的元素</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-list-len.html\">len(list)</a></td>\n<td>列表元素个数</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-list-max.html\">max(list)</a></td>\n<td>返回列表元素最大值</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-list-min.html\">min(list)</a></td>\n<td>返回列表元素最小值</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-list-list.html\">list(seq)</a></td>\n<td>将元组转换为列表</td>\n</tr>\n</tbody></table>\n<h3 id=\"List内置函数\"><a href=\"#List内置函数\" class=\"headerlink\" title=\"List内置函数\"></a>List内置函数</h3><table>\n<thead>\n<tr>\n<th align=\"left\">方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-list-append.html\">list.append(obj)</a></td>\n<td>在列表末尾添加新的对象</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-list-count.html\">list.count(obj)</a></td>\n<td>统计某个元素在列表中出现的次数</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-list-extend.html\">list.extend(seq)</a></td>\n<td>在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-list-index.html\">list.index(obj)</a></td>\n<td>从列表中找出某个值第一个匹配项的索引位置</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-list-insert.html\">list.insert(index, obj)</a></td>\n<td>将对象插入列表</td>\n</tr>\n<tr>\n<td align=\"left\">[list.pop(<a href=\"https://www.runoob.com/python/att-list-pop.html\">index=-1])</a></td>\n<td>移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-list-remove.html\">list.remove(obj)</a></td>\n<td>移除列表中某个值的第一个匹配项</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-list-reverse.html\">list.reverse()</a></td>\n<td>反向列表中元素</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-list-sort.html\">list.sort(cmp=None, key=None, reverse=False)</a></td>\n<td>对原列表进行排序</td>\n</tr>\n</tbody></table>\n<h2 id=\"5-Dictionary\"><a href=\"#5-Dictionary\" class=\"headerlink\" title=\"5.Dictionary\"></a>5.Dictionary</h2><p>Python的字典和C#中的字典的用法基本一致，不同的时Python使用<code>&#123;&#125;</code>来创建字典，使用<code>:</code>来连接键值对，使用<code>,</code>来分割元素。如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">dic = &#123;<span class=\"hljs-string\">&#x27;a&#x27;</span>: <span class=\"hljs-literal\">True</span>, <span class=\"hljs-number\">2</span>: <span class=\"hljs-string\">&quot;Py&quot;</span>, <span class=\"hljs-string\">&quot;bb&quot;</span>: <span class=\"hljs-number\">3</span>&#125;<br></code></pre></td></tr></table></figure>\n<p>Python自定更强大的地方在于，Python字典在一个字典里支持不同类型的键和值。</p>\n<p><font color=\"red\"> 字典的键只能是数字、字符串或元组类型，而值没有任何要求。</font></p>\n<h3 id=\"Python内置字典操作函数\"><a href=\"#Python内置字典操作函数\" class=\"headerlink\" title=\"Python内置字典操作函数\"></a>Python内置字典操作函数</h3><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"https://www.runoob.com/python/att-dictionary-cmp.html\">cmp(dict1, dict2)</a></td>\n<td>比较两个字典元素。</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/att-dictionary-len.html\">len(dict)</a></td>\n<td>计算字典元素个数，即键的总数。</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/att-dictionary-str.html\">str(dict)</a></td>\n<td>输出字典可打印的字符串表示。</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/att-dictionary-type.html\">type(variable)</a></td>\n<td>返回输入的变量类型，如果变量是字典就返回字典类型。</td>\n</tr>\n</tbody></table>\n<h3 id=\"Dictionary内置函数\"><a href=\"#Dictionary内置函数\" class=\"headerlink\" title=\"Dictionary内置函数\"></a>Dictionary内置函数</h3><table>\n<thead>\n<tr>\n<th align=\"left\">函数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-dictionary-clear.html\">dict.clear()</a></td>\n<td>删除字典内所有元素</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-dictionary-copy.html\">dict.copy()</a></td>\n<td>返回一个字典的浅复制</td>\n</tr>\n<tr>\n<td align=\"left\">[dict.fromkeys(seq<a href=\"https://www.runoob.com/python/att-dictionary-fromkeys.html\">, val])</a></td>\n<td>创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-dictionary-get.html\">dict.get(key, default=None)</a></td>\n<td>返回指定键的值，如果值不在字典中返回default值</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-dictionary-has_key.html\">dict.has_key(key)</a></td>\n<td>如果键在字典dict里返回true，否则返回false</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-dictionary-items.html\">dict.items()</a></td>\n<td>以列表返回可遍历的(键, 值) 元组数组</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-dictionary-keys.html\">dict.keys()</a></td>\n<td>以列表返回一个字典所有的键</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-dictionary-setdefault.html\">dict.setdefault(key, default=None)</a></td>\n<td>和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-dictionary-update.html\">dict.update(dict2)</a></td>\n<td>把字典dict2的键/值对更新到dict里</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-dictionary-values.html\">dict.values()</a></td>\n<td>以列表返回字典中的所有值</td>\n</tr>\n<tr>\n<td align=\"left\">[pop(key<a href=\"https://www.runoob.com/python/python-att-dictionary-pop.html\">,default])</a></td>\n<td>删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/python-att-dictionary-popitem.html\">popitem()</a></td>\n<td>返回并删除字典中的最后一对键和值。</td>\n</tr>\n</tbody></table>\n<h2 id=\"6-日期和时间\"><a href=\"#6-日期和时间\" class=\"headerlink\" title=\"6.日期和时间\"></a>6.日期和时间</h2><p>Python的日期时间函数被放在了<code>time</code>、<code>datetime</code>和<code>calender</code>模块下，这里有几个点是需要注意的</p>\n<h3 id=\"time-time\"><a href=\"#time-time\" class=\"headerlink\" title=\"time.time()\"></a>time.time()</h3><p>time.time()函数返回的是从1970年1月1日午夜到当前时间所经过的总时长。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> time<br>print(time.time())<br><span class=\"hljs-comment\">#当前时间为：2021.2.6 09：51</span><br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-number\">1612576137.817901</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"time-localtime\"><a href=\"#time-localtime\" class=\"headerlink\" title=\"time.localtime()\"></a>time.localtime()</h3><p>那么如何输出当前时间呢？答案就是使用<code>time.localtime(time.time())</code>来计算当前时间。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> time<br>print(time.localtime(time.time()))<br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">time.struct_time(tm_year=<span class=\"hljs-number\">2021</span>, tm_mon=<span class=\"hljs-number\">2</span>, tm_mday=<span class=\"hljs-number\">6</span>, tm_hour=<span class=\"hljs-number\">9</span>, tm_min=<span class=\"hljs-number\">51</span>, tm_sec=<span class=\"hljs-number\">39</span>, tm_wday=<span class=\"hljs-number\">5</span>, tm_yday=<span class=\"hljs-number\">37</span>, tm_isdst=<span class=\"hljs-number\">0</span>)<br></code></pre></td></tr></table></figure>\n<p>可以看到，函数返回的不是格式化的<code>2021.2.6 9:51</code>而是一个<code>struct_time</code>时间元组，什么是时间元组？</p>\n<h3 id=\"时间元组\"><a href=\"#时间元组\" class=\"headerlink\" title=\"时间元组\"></a>时间元组</h3><p>很多Python函数用一个元组装起来的9组数字处理时间:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">字段</th>\n<th align=\"left\">值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">0</td>\n<td align=\"left\">4位数年</td>\n<td align=\"left\">2008</td>\n</tr>\n<tr>\n<td align=\"left\">1</td>\n<td align=\"left\">月</td>\n<td align=\"left\">1 到 12</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">日</td>\n<td align=\"left\">1到31</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">小时</td>\n<td align=\"left\">0到23</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">分钟</td>\n<td align=\"left\">0到59</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">秒</td>\n<td align=\"left\">0到61 (60或61 是闰秒)</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">一周的第几日</td>\n<td align=\"left\">0到6 (0是周一)</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">一年的第几日</td>\n<td align=\"left\">1到366 (儒略历)</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">夏令时</td>\n<td align=\"left\">-1, 0, 1, -1是决定是否为夏令时的旗帜</td>\n</tr>\n</tbody></table>\n<p>而struct_time就是其中之一，struct_time的结构：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">属性</th>\n<th align=\"left\">值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">0</td>\n<td align=\"left\">tm_year</td>\n<td align=\"left\">2021</td>\n</tr>\n<tr>\n<td align=\"left\">1</td>\n<td align=\"left\">tm_mon</td>\n<td align=\"left\">1 到 12</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">tm_mday</td>\n<td align=\"left\">1 到 31</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">tm_hour</td>\n<td align=\"left\">0 到 23</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">tm_min</td>\n<td align=\"left\">0 到 59</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">tm_sec</td>\n<td align=\"left\">0 到 61 (60或61 是闰秒)</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">tm_wday</td>\n<td align=\"left\">0到6 (0是周一)</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">tm_yday</td>\n<td align=\"left\">1 到 366(儒略历)</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">tm_isdst</td>\n<td align=\"left\">-1, 0, 1, -1是决定是否为夏令时的旗帜</td>\n</tr>\n</tbody></table>\n<h3 id=\"获取格式化时间\"><a href=\"#获取格式化时间\" class=\"headerlink\" title=\"获取格式化时间\"></a>获取格式化时间</h3><p>那么如何获取格式化时间呢？</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">print(time.asctime(time.localtime(time.time())))<br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">Sat Feb  <span class=\"hljs-number\">6</span> <span class=\"hljs-number\">10</span>:<span class=\"hljs-number\">28</span>:09 <span class=\"hljs-number\">2021</span><br></code></pre></td></tr></table></figure>\n<p>time.localtime()返回的是一个字符串，除此之外我们看还可以使用<font color=\"red\"><code>time.strftime()</code></font>函数来自定义时间格式化格式，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">print(time.strftime(<span class=\"hljs-string\">&quot;%H:%M:%S %Y-%m-%d&quot;</span>, time.localtime()))<br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-number\">10</span>:<span class=\"hljs-number\">51</span>:<span class=\"hljs-number\">12</span> <span class=\"hljs-number\">2021</span>-02-06<br></code></pre></td></tr></table></figure>\n<h3 id=\"时间日期格式化符号\"><a href=\"#时间日期格式化符号\" class=\"headerlink\" title=\"时间日期格式化符号\"></a>时间日期格式化符号</h3><table>\n<thead>\n<tr>\n<th>符号</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>%y</td>\n<td>两位数的年份表示（00-99）</td>\n</tr>\n<tr>\n<td>%Y</td>\n<td>四位数的年份表示（000-9999）</td>\n</tr>\n<tr>\n<td>%m</td>\n<td>月份（01-12）</td>\n</tr>\n<tr>\n<td>%d</td>\n<td>月内中的一天（0-31）</td>\n</tr>\n<tr>\n<td>%H</td>\n<td>24小时制小时数（0-23）</td>\n</tr>\n<tr>\n<td>%I</td>\n<td>12小时制小时数（01-12）</td>\n</tr>\n<tr>\n<td>%M</td>\n<td>分钟数（00-59）</td>\n</tr>\n<tr>\n<td>%S</td>\n<td>秒（00-59）</td>\n</tr>\n<tr>\n<td>%a</td>\n<td>本地简化星期名称</td>\n</tr>\n<tr>\n<td>%A</td>\n<td>本地完整星期名称</td>\n</tr>\n<tr>\n<td>%b</td>\n<td>本地简化的月份名称</td>\n</tr>\n<tr>\n<td>%B</td>\n<td>本地完整的月份名称</td>\n</tr>\n<tr>\n<td>%c</td>\n<td>本地相应的日期表示和时间表示</td>\n</tr>\n<tr>\n<td>%j</td>\n<td>年内的一天（001-366）</td>\n</tr>\n<tr>\n<td>%p</td>\n<td>本地A.M.或P.M.的等价符</td>\n</tr>\n<tr>\n<td>%U</td>\n<td>一年中的星期数（00-53）星期天为星期的开始</td>\n</tr>\n<tr>\n<td>%w</td>\n<td>星期（0-6），星期天为星期的开始</td>\n</tr>\n<tr>\n<td>%W</td>\n<td>一年中的星期数（00-53）星期一为星期的开始</td>\n</tr>\n<tr>\n<td>%x</td>\n<td>本地相应的日期表示</td>\n</tr>\n<tr>\n<td>%X</td>\n<td>本地相应的时间表示</td>\n</tr>\n<tr>\n<td>%Z</td>\n<td>当前时区的名称</td>\n</tr>\n<tr>\n<td>%%</td>\n<td>%号本身</td>\n</tr>\n</tbody></table>\n<h3 id=\"time与datetime库\"><a href=\"#time与datetime库\" class=\"headerlink\" title=\"time与datetime库\"></a>time与datetime库</h3><p>python处理时间处理time模块还可以使用datetime模块，那么time和datetime之间有什么区别呢？</p>\n<p>在 Python 文档里，<code>time</code>是归类在<code>Generic Operating System Services</code>中，换句话说， 它提供的功能是更加接近于操作系统层面的。通读<a href=\"https://docs.python.org/2.7/library/time.html\">文档</a>可知，time 模块是围绕着 Unix Timestamp 进行的。</p>\n<p>该模块主要包括一个类 <code>struct_time</code>，另外其他几个函数及相关常量。 需要注意的是在该模块中的大多数函数是调用了所在平台<code>C library</code>的同名函数， 所以要特别注意有些函数是平台相关的，可能会在不同的平台有不同的效果。另外一点是，由于是基于Unix Timestamp，所以其所能表述的日期范围被限定在 1970 - 2038 之间，如果你写的代码需要处理在前面所述范围之外的日期，那可能需要考虑使用<code>datetime</code>模块更好。</p>\n<p>datetime 比 time 高级了不少，可以理解为 datetime 基于 time 进行了封装，提供了更多实用的函数。</p>\n<table>\n<thead>\n<tr>\n<th>类</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>timedelta</td>\n<td>主要用于计算时间跨度</td>\n</tr>\n<tr>\n<td>tzinfo</td>\n<td>时区相关</td>\n</tr>\n<tr>\n<td>time</td>\n<td>只关注时间</td>\n</tr>\n<tr>\n<td>date</td>\n<td>只关注日期</td>\n</tr>\n<tr>\n<td>datetime</td>\n<td>同时有时间和日期</td>\n</tr>\n</tbody></table>\n<h3 id=\"calendar库\"><a href=\"#calendar库\" class=\"headerlink\" title=\"calendar库\"></a>calendar库</h3><p>calendar库主要用于处理日历，如：打印2021年2月的日历</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">print(calendar.month(<span class=\"hljs-number\">2021</span>, <span class=\"hljs-number\">1</span>))<br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">    January <span class=\"hljs-number\">2021</span><br>Mo Tu We Th Fr Sa Su<br>             <span class=\"hljs-number\">1</span>  <span class=\"hljs-number\">2</span>  <span class=\"hljs-number\">3</span><br> <span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">5</span>  <span class=\"hljs-number\">6</span>  <span class=\"hljs-number\">7</span>  <span class=\"hljs-number\">8</span>  <span class=\"hljs-number\">9</span> <span class=\"hljs-number\">10</span><br><span class=\"hljs-number\">11</span> <span class=\"hljs-number\">12</span> <span class=\"hljs-number\">13</span> <span class=\"hljs-number\">14</span> <span class=\"hljs-number\">15</span> <span class=\"hljs-number\">16</span> <span class=\"hljs-number\">17</span><br><span class=\"hljs-number\">18</span> <span class=\"hljs-number\">19</span> <span class=\"hljs-number\">20</span> <span class=\"hljs-number\">21</span> <span class=\"hljs-number\">22</span> <span class=\"hljs-number\">23</span> <span class=\"hljs-number\">24</span><br><span class=\"hljs-number\">25</span> <span class=\"hljs-number\">26</span> <span class=\"hljs-number\">27</span> <span class=\"hljs-number\">28</span> <span class=\"hljs-number\">29</span> <span class=\"hljs-number\">30</span> <span class=\"hljs-number\">31</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"time库内置函数\"><a href=\"#time库内置函数\" class=\"headerlink\" title=\"time库内置函数\"></a>time库内置函数</h3><table>\n<thead>\n<tr>\n<th align=\"left\">函数</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-time-altzone.html\">time.altzone</a></td>\n<td align=\"left\">返回格林威治西部的夏令时地区的偏移秒数。如果该地区在格林威治东部会返回负值（如西欧，包括英国）。对夏令时启用地区才能使用。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-time-asctime.html\">time.asctime([tupletime])</a></td>\n<td align=\"left\">接受时间元组并返回一个可读的形式为”Tue Dec 11 18:07:14 2008”（2008年12月11日 周二18时07分14秒）的24个字符的字符串。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-time-clock.html\">time.clock( )</a></td>\n<td align=\"left\">用以浮点数计算的秒数返回当前的CPU时间。用来衡量不同程序的耗时，比time.time()更有用。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-time-ctime.html\">time.ctime([secs])</a></td>\n<td align=\"left\">作用相当于asctime(localtime(secs))，未给参数相当于asctime()</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-time-gmtime.html\">time.gmtime([secs])</a></td>\n<td align=\"left\">接收时间戳（1970纪元后经过的浮点秒数）并返回格林威治天文时间下的时间元组t。注：t.tm_isdst始终为0</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-time-localtime.html\">time.localtime([secs])</a></td>\n<td align=\"left\">接收时间戳（1970纪元后经过的浮点秒数）并返回当地时间下的时间元组t（t.tm_isdst可取0或1，取决于当地当时是不是夏令时）。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-time-mktime.html\">time.mktime(tupletime)</a></td>\n<td align=\"left\">接受时间元组并返回时间戳（1970纪元后经过的浮点秒数）。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-time-sleep.html\">time.sleep(secs)</a></td>\n<td align=\"left\">推迟调用线程的运行，secs指秒数。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-time-strftime.html\">time.strftime(fmt[,tupletime])</a></td>\n<td align=\"left\">接收以时间元组，并返回以可读字符串表示的当地时间，格式由fmt决定。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-time-strptime.html\">time.strptime(str,fmt=’%a %b %d %H:%M:%S %Y’)</a></td>\n<td align=\"left\">根据fmt的格式把一个时间字符串解析为时间元组。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-time-time.html\">time.time( )</a></td>\n<td align=\"left\">返回当前时间的时间戳（1970纪元后经过的浮点秒数）。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python/att-time-tzset.html\">time.tzset()</a></td>\n<td align=\"left\">根据环境变量TZ重新初始化时间相关设置。</td>\n</tr>\n</tbody></table>\n<h3 id=\"两个time库重要属性\"><a href=\"#两个time库重要属性\" class=\"headerlink\" title=\"两个time库重要属性\"></a>两个time库重要属性</h3><table>\n<thead>\n<tr>\n<th align=\"left\">属性</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>time.timezone</strong></td>\n<td align=\"left\">属性 time.timezone 是当地时区（未启动夏令时）距离格林威治的偏移秒数（&gt;0，美洲&lt;=0大部分欧洲，亚洲，非洲）。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>time.tzname</strong></td>\n<td align=\"left\">属性time.tzname包含一对根据情况的不同而不同的字符串，分别是带夏令时的本地时区名称，和不带的。</td>\n</tr>\n</tbody></table>\n<h3 id=\"calendar内置函数\"><a href=\"#calendar内置函数\" class=\"headerlink\" title=\"calendar内置函数\"></a>calendar内置函数</h3><table>\n<thead>\n<tr>\n<th align=\"left\">函数</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>calendar.calendar(year,w=2,l=1,c=6)</strong></td>\n<td align=\"left\">返回一个多行字符串格式的year年年历，3个月一行，间隔距离为c。 每日宽度间隔为w字符。每行长度为21* W+18+2* C。l是每星期行数。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>calendar.firstweekday( )</strong></td>\n<td align=\"left\">返回当前每周起始日期的设置。默认情况下，首次载入 calendar 模块时返回 0，即星期一。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>calendar.isleap(year)</strong></td>\n<td align=\"left\">是闰年返回 True，否则为 False。<code>&gt;&gt;&gt; import calendar &gt;&gt;&gt; print(calendar.isleap(2000)) True &gt;&gt;&gt; print(calendar.isleap(1900)) False</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>calendar.leapdays(y1,y2)</strong></td>\n<td align=\"left\">返回在Y1，Y2两年之间的闰年总数。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>calendar.month(year,month,w=2,l=1)</strong></td>\n<td align=\"left\">返回一个多行字符串格式的year年month月日历，两行标题，一周一行。每日宽度间隔为w字符。每行的长度为7* w+6。l是每星期的行数。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>calendar.monthcalendar(year,month)</strong></td>\n<td align=\"left\">返回一个整数的单层嵌套列表。每个子列表装载代表一个星期的整数。Year年month月外的日期都设为0;范围内的日子都由该月第几日表示，从1开始。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>calendar.monthrange(year,month)</strong></td>\n<td align=\"left\">返回两个整数。第一个是该月的星期几的日期码，第二个是该月的日期码。日从0（星期一）到6（星期日）;月从1到12。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>calendar.prcal(year,w=2,l=1,c=6)</strong></td>\n<td align=\"left\">相当于 **print calendar.calendar(year,w=2,l=1,c=6)**。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>calendar.prmonth(year,month,w=2,l=1)</strong></td>\n<td align=\"left\">相当于 <strong>print calendar.month(year,month,w=2,l=1)</strong> 。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>calendar.setfirstweekday(weekday)</strong></td>\n<td align=\"left\">设置每周的起始日期码。0（星期一）到6（星期日）。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>calendar.timegm(tupletime)</strong></td>\n<td align=\"left\">和time.gmtime相反：接受一个时间元组形式，返回该时刻的时间戳（1970纪元后经过的浮点秒数）。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>calendar.weekday(year,month,day)</strong></td>\n<td align=\"left\">返回给定日期的日期码。0（星期一）到6（星期日）。月份为 1（一月） 到 12（12月）。</td>\n</tr>\n</tbody></table>\n<h2 id=\"7-set集合\"><a href=\"#7-set集合\" class=\"headerlink\" title=\"7.set集合\"></a>7.set集合</h2><p>python的set集合和C++的set集合的用法基本是一样的，set集合是一个无序不重复序列，python使用<code>&#123;&#125;</code>或<code>set()</code>函数来创建set集合，区别字典的地方是{}包括的元素不是键值对，需要注意的是，创建空集合只能通过set()函数。</p>\n<h2 id=\"8-类型转换\"><a href=\"#8-类型转换\" class=\"headerlink\" title=\"8.类型转换\"></a>8.类型转换</h2><p>Python提供了大量内置类型转换函数：</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>int(x <a href=\"https://www.runoob.com/python/python-func-int.html\">,[base])</a></td>\n<td>将x转换为一个整数</td>\n</tr>\n<tr>\n<td>long(x <a href=\"https://www.runoob.com/python/python-func-long.html\">,[base] )</a></td>\n<td>将x转换为一个长整数</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-float.html\">float(x)</a></td>\n<td>将x转换到一个浮点数</td>\n</tr>\n<tr>\n<td>complex(real <a href=\"https://www.runoob.com/python/python-func-complex.html\">[,imag])</a></td>\n<td>创建一个复数</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-str.html\">str(x)</a></td>\n<td>将对象 x 转换为字符串</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-repr.html\">repr(x)</a></td>\n<td>将对象 x 转换为表达式字符串</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-eval.html\">eval(str)</a></td>\n<td>用来计算在字符串中的有效Python表达式,并返回一个对象</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/att-tuple-tuple.html\">tuple(s)</a></td>\n<td>将序列 s 转换为一个元组</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/att-list-list.html\">list(s)</a></td>\n<td>将序列 s 转换为一个列表</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-set.html\">set(s)</a></td>\n<td>转换为可变集合</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-dict.html\">dict(d)</a></td>\n<td>创建一个字典。d 必须是一个序列 (key,value)元组。</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-frozenset.html\">frozenset(s)</a></td>\n<td>转换为不可变集合</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-chr.html\">chr(x)</a></td>\n<td>将一个整数转换为一个字符</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-unichr.html\">unichr(x)</a></td>\n<td>将一个整数转换为Unicode字符</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-ord.html\">ord(x)</a></td>\n<td>将一个字符转换为它的整数值</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-hex.html\">hex(x)</a></td>\n<td>将一个整数转换为一个十六进制字符串</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-oct.html\">oct(x)</a></td>\n<td>将一个整数转换为一个八进制字符串</td>\n</tr>\n</tbody></table>\n<h1 id=\"四、运算符\"><a href=\"#四、运算符\" class=\"headerlink\" title=\"四、运算符\"></a>四、运算符</h1><h2 id=\"1-算术运算符\"><a href=\"#1-算术运算符\" class=\"headerlink\" title=\"1.算术运算符\"></a>1.算术运算符</h2><p>Python的算术运算基本和C系列语言没什么区别，唯一的区别在于Python将C系列语言的求幂函数和取整函数直接内置到了Python的运算符里了，如：</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>**</td>\n<td>求幂运算符，二元运算符，a**b表示求a的b次幂</td>\n</tr>\n<tr>\n<td>//</td>\n<td>取整运算符，二元运算符，a//b表示a对b取整，如9//4 = 2</td>\n</tr>\n</tbody></table>\n<h2 id=\"2-赋值运算符\"><a href=\"#2-赋值运算符\" class=\"headerlink\" title=\"2.赋值运算符\"></a>2.赋值运算符</h2><p>和算数运算符一样，Python也将求幂运算和取整运算的赋值运算内置到运算符里。</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>**=</td>\n<td>幂赋值运算符</td>\n</tr>\n<tr>\n<td>//=</td>\n<td>取整赋值运算符</td>\n</tr>\n</tbody></table>\n<h2 id=\"3-逻辑运算符\"><a href=\"#3-逻辑运算符\" class=\"headerlink\" title=\"3.逻辑运算符\"></a>3.逻辑运算符</h2><p>由于Python的底层是用C写的所有C的逻辑运算符（<code>&amp;</code>,<code>|</code>,<code>!</code>）在Python中就不能再使用了，所以Python使用（<code>and</code>,<code>or</code>,<code>not</code>）来做逻辑运算符，用法和<code>&amp;</code>,<code>|</code>,<code>!</code>一样。</p>\n<h2 id=\"4-成员运算符\"><a href=\"#4-成员运算符\" class=\"headerlink\" title=\"4.成员运算符\"></a>4.成员运算符</h2><p>和前面一样，Python也将判断函数直接内置到运算符中了，Python成员运算符作用就是判断指定序列中是否包含某个指定元素，序列支持字符串，列表和元组。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>in</td>\n<td>如果指定元素在指定序列中则返回True</td>\n</tr>\n<tr>\n<td>not in</td>\n<td>如果指定元素不在指定序列中则返回True</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-selector-tag\">li</span> = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>]<br>tu = (<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>)<br>st = “<span class=\"hljs-number\">12345</span>”<br><span class=\"hljs-selector-tag\">a</span> = <span class=\"hljs-number\">1</span><br><span class=\"hljs-selector-tag\">b</span> = ‘<span class=\"hljs-number\">1</span>’<br><span class=\"hljs-function\"><span class=\"hljs-title\">print</span><span class=\"hljs-params\">(a in li)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-title\">print</span><span class=\"hljs-params\">(a not in tu)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-title\">print</span><span class=\"hljs-params\">(b in st)</span></span><br></code></pre></td></tr></table></figure>\n<p>返回结果：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-literal\">True</span><br><span class=\"hljs-literal\">False</span><br><span class=\"hljs-literal\">True</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"5-身份运算符\"><a href=\"#5-身份运算符\" class=\"headerlink\" title=\"5.身份运算符\"></a>5.身份运算符</h2><table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>is</td>\n<td>判断两个对象是否来自同一引用</td>\n</tr>\n<tr>\n<td>is not</td>\n<td>判断两个对象是否不同的引用</td>\n</tr>\n</tbody></table>\n<p>Pyhton的身份运算符和C#的is是不一样的，Python的is用于判断两个对象是否来引用同一引用，而C#的is则是判断某一对象是否是指定类型。</p>\n<p>使用案例：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-selector-tag\">a</span>  = <span class=\"hljs-number\">1</span><br><span class=\"hljs-selector-tag\">b</span> = a<br><span class=\"hljs-function\"><span class=\"hljs-title\">print</span><span class=\"hljs-params\">(a is b)</span></span><br><span class=\"hljs-selector-tag\">b</span> = <span class=\"hljs-number\">2</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">print</span><span class=\"hljs-params\">(a is not b)</span></span><br>c = <span class=\"hljs-number\">2</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">print</span><span class=\"hljs-params\">(b is c)</span></span><br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-literal\">True</span><br><span class=\"hljs-literal\">True</span><br><span class=\"hljs-literal\">True</span><br></code></pre></td></tr></table></figure>\n<p>这里出现了一个疑问，为什么b和c来自同一引用呢？<br>我们查看一下b和c的内存地址</p>\n<figure class=\"highlight isbl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs isbl\"><span class=\"hljs-function\"><span class=\"hljs-title\">print</span>(<span class=\"hljs-title\">id</span>(<span class=\"hljs-variable\">b</span>))</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">print</span>(<span class=\"hljs-title\">id</span>(<span class=\"hljs-variable\">c</span>))</span><br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dns\"><span class=\"hljs-number\">2324527120200</span><br><span class=\"hljs-number\">2324527120200</span><br></code></pre></td></tr></table></figure>\n<p>可以看到b和c指向了同一内存地址，原来Python在对程序优化的时候会将程序中的内容相同的常量存储到一个存储地址中。</p>\n<h1 id=\"五、控制语句\"><a href=\"#五、控制语句\" class=\"headerlink\" title=\"五、控制语句\"></a>五、控制语句</h1><p>Python的条件语句与C系列语言最大的不同是，Python的条件语句可以不使用<code>()</code>来包含条件表达式，当然也可以是使用，大多数情况下还是建议使用（），以使代码的阅读性更高。</p>\n<h2 id=\"1-if语句\"><a href=\"#1-if语句\" class=\"headerlink\" title=\"1.if语句\"></a>1.if语句</h2><p>当条if-else语句的用法和C系列基本一致。</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\"><span class=\"hljs-keyword\">if</span> <span class=\"hljs-literal\">True</span>:<br>\t<span class=\"hljs-attribute\">a</span>=1<br>\t<span class=\"hljs-attribute\">b</span>=1<br><span class=\"hljs-keyword\">else</span>:<br>\t<span class=\"hljs-attribute\">a</span>=2<br>\t<span class=\"hljs-attribute\">b</span>=2<br></code></pre></td></tr></table></figure>\n<p><font color=\"red\"> 其中<code>:</code>是必须的</font><br>Python中比较特殊的是else if语句，在Python中使用<font color=\"red\"> elif</font>表示。</p>\n<h2 id=\"2-while循环语句\"><a href=\"#2-while循环语句\" class=\"headerlink\" title=\"2.while循环语句\"></a>2.while循环语句</h2><p>Python的while循环可以搭配esle使用，当循环跳出时执行else语句，个人感觉没什么实际用处。</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gauss\">a = <span class=\"hljs-number\">0</span><br><span class=\"hljs-keyword\">while</span> a&lt;<span class=\"hljs-number\">3</span>:<br>\t<span class=\"hljs-keyword\">print</span>(a)<br>\ta += <span class=\"hljs-number\">1</span><br><span class=\"hljs-keyword\">else</span>:<br>\t<span class=\"hljs-keyword\">print</span>(“循环结束”)<br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">0<br>1<br>2<br>循环结束<br></code></pre></td></tr></table></figure>\n<h2 id=\"3-for循环\"><a href=\"#3-for循环\" class=\"headerlink\" title=\"3.for循环\"></a>3.for循环</h2><p><font color=\"red\"> 在写循环语句之前有一点是需要明确的，及根据Python的设计理念Python已经不使用自增<code>++</code>自减<code>--</code>运算符了，所以需要自增时应使用<code>a += 1</code></font></p>\n<h3 id=\"for-in\"><a href=\"#for-in\" class=\"headerlink\" title=\"for in\"></a>for in</h3><p>for in的用法和C#的foreach一致，可以遍历任何序列，如：</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs maxima\"><span class=\"hljs-built_in\">li</span> = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>]<br><span class=\"hljs-keyword\">for</span> item <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">li</span>:<br>\t<span class=\"hljs-built_in\">print</span>(item)<br><span class=\"hljs-keyword\">else</span>：<br>\t<span class=\"hljs-built_in\">print</span>(“<span class=\"hljs-keyword\">for</span> end”)<br></code></pre></td></tr></table></figure>\n<p>和while一样for也可以配合else使用</p>\n<h3 id=\"for-in-range\"><a href=\"#for-in-range\" class=\"headerlink\" title=\"for in range()\"></a>for in range()</h3><p>for in range()就是不同的for循环，通过下标来遍历序列，如：</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs maxima\"><span class=\"hljs-built_in\">li</span> = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>]<br><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(len(<span class=\"hljs-built_in\">li</span>)):<br>\t<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-built_in\">li</span>[i])<br><span class=\"hljs-keyword\">else</span>:<br>\t<span class=\"hljs-built_in\">print</span>(“<span class=\"hljs-keyword\">for</span> end”)<br></code></pre></td></tr></table></figure>\n<p><font color=\"red\"> 需要注意实际上for in中是不包含range()的，range只是一个辅助函数，用于确定下标的范围。如果我们直接像下面那样写是会报语法错误的，如：</font></p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">for</span> i in <span class=\"hljs-number\">4</span>:<br>\t<span class=\"hljs-comment\">#code</span><br></code></pre></td></tr></table></figure>\n<p>如果我们想让循环只跑4轮，应该用range(4)来确定下标范围，如：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\"><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-keyword\">range</span>(<span class=\"hljs-number\">4</span>):<br></code></pre></td></tr></table></figure>\n<h3 id=\"continue、break和pass\"><a href=\"#continue、break和pass\" class=\"headerlink\" title=\"continue、break和pass\"></a>continue、break和pass</h3><p>Python的continue和break的用法和C系列语言基本一致，Python中新增了pass语句，pass语句就是C系列语言中<code>;</code>及空语句，一般用于空循环中维护代码的结构性。</p>\n<h1 id=\"六、函数\"><a href=\"#六、函数\" class=\"headerlink\" title=\"六、函数\"></a>六、函数</h1><h2 id=\"1-函数定义\"><a href=\"#1-函数定义\" class=\"headerlink\" title=\"1.函数定义\"></a>1.函数定义</h2><ul>\n<li>函数代码块以 <strong>def</strong> 关键词开头，后接函数标识符名称和圆括号**()**。</li>\n<li>任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。</li>\n<li><font color=\"red\">函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</font></li>\n<li>函数内容以冒号起始，并且缩进。</li>\n<li><strong>return [表达式]</strong> 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。</li>\n</ul>\n<p>如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">fun</span>(<span class=\"hljs-params\">a</span>):</span><br>    <span class=\"hljs-string\">&quot;打印a的平方并返回&quot;</span><br>    b = a*a<br>    print(b)<br>    <span class=\"hljs-keyword\">return</span> b<br></code></pre></td></tr></table></figure>\n<h2 id=\"2-函数调用\"><a href=\"#2-函数调用\" class=\"headerlink\" title=\"2.函数调用\"></a>2.函数调用</h2><p><font color=\"red\"> 在调用Python函数时有一点是需要特别注意的，由于Python是解释型语言，Python脚本在运行时是一行一行地放入解释器中进行解释的，因此Pyhton不支持函数的声明定义的分离，所有Python的函数调用必须在定义之后，否则将会报函数未定义。</font></p>\n<h2 id=\"3-参数传递\"><a href=\"#3-参数传递\" class=\"headerlink\" title=\"3.参数传递\"></a>3.参数传递</h2><p>在讨论函数参数之前，我们需要了解两个概念：</p>\n<ul>\n<li><p>不可变对象：不可变对象都是不可变类型，<font color=\"red\">Python的不可变类型有数字、字符串、元组</font>，不可变对象指向的内存地址上的内容是不可更改的，如需操作其内容Python会开辟一个新的内存地址来存储编辑后的内容。</p>\n</li>\n<li><p>可变对象：可变对象都是可变类型，不是不可变类型的类型都是可变类型，包括列表、字典、自定义类型等，可变类型对象指向的内存地址的内容是可更改，操作可变对象的内容时Python不会开辟新的内存，而是直接修改原地址内容。</p>\n</li>\n</ul>\n<p><font color=\"red\">函数传入不可变对象的原理和C++的传值原理是一样的，函数传入可变对象的原理和C++传址原理是一样的。</font></p>\n<h3 id=\"传参原理\"><a href=\"#传参原理\" class=\"headerlink\" title=\"传参原理\"></a>传参原理</h3><p>由于Python的变量都是若类型的，参数也不例外，函数在定义参数时只有名字没有类型，所以Python在调用函数时，参数的传递是根据实参的顺序来给形参赋值的。</p>\n<h3 id=\"关键字参数\"><a href=\"#关键字参数\" class=\"headerlink\" title=\"关键字参数\"></a>关键字参数</h3><p>Python的函数支持关键字传参，关键字传参的原理是指定实参来赋值指定形参，所以可以无视参数的传入顺序。如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">fun</span>(<span class=\"hljs-params\">a,b,c</span>):</span><br>    print(a+b+c)<br>fun(b = <span class=\"hljs-number\">1</span>,c = <span class=\"hljs-number\">2</span>,a = <span class=\"hljs-number\">3</span>)<br></code></pre></td></tr></table></figure>\n<h3 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h3><p>Python的函数也支持默认参数，原理和C++一样。</p>\n<h3 id=\"单-号不定长参数\"><a href=\"#单-号不定长参数\" class=\"headerlink\" title=\"单*号不定长参数\"></a>单*号不定长参数</h3><p>Python的不定长参数和C++则有些不同，Python使用<code>*</code>来标识不定长参数，所有形参匹配之外的参数都将存储到不定长参数中，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">fun</span>(<span class=\"hljs-params\">a,b,*c</span>):</span><br>    d = a + b<br>    <span class=\"hljs-keyword\">for</span> item <span class=\"hljs-keyword\">in</span> c:<br>        d += item<br>    print(d)<br>fun(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>)<br></code></pre></td></tr></table></figure>\n<p>在这个过程中，1被赋予a，2被赋予b，3和4被赋予c</p>\n<p>Python支持不定长参数的单独使用，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">fun</span>(<span class=\"hljs-params\">*param</span>):</span><br>    <span class=\"hljs-keyword\">pass</span><br></code></pre></td></tr></table></figure>\n<p>如果函数的参数只有一个不定长参数，那么函数传入的任何参数都会存储到不定长参数里。</p>\n<p><font color=\"red\"> 单<code>*</code>号不定长参数会将传入的所有参数封装在一个元组里，且单<code>*</code>号不定长参数只支持参数的顺序传入，不支持关键字传入。</font></p>\n<p>当函数只有单<code>*</code>号不定长参数时，单<code>*</code>号不定长参数因该放在最后一个参数，如果不放在最后将会报错：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">fun</span>(<span class=\"hljs-params\">*c, t</span>):</span><br>    c[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">5</span><br>    print(c[<span class=\"hljs-number\">0</span>])<br>    print(t)<br></code></pre></td></tr></table></figure>\n<p>报错：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">Traceback (most recent call last):<br>  File <span class=\"hljs-string\">&quot;d:\\Codes\\Python\\MyFirstPython.py&quot;</span>, line <span class=\"hljs-number\">9</span>, <span class=\"hljs-keyword\">in</span> &lt;module&gt;<br>    fun(li, <span class=\"hljs-number\">2</span>)<br>TypeError: fun() missing <span class=\"hljs-number\">1</span> required keyword-only argument: <span class=\"hljs-string\">&#x27;t&#x27;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"双-号不定长参数\"><a href=\"#双-号不定长参数\" class=\"headerlink\" title=\"双*号不定长参数\"></a>双*号不定长参数</h3><p>除了单<code>*</code>号不定长参数外，Python还支持双<code>*</code>号不定长参数，<font color=\"red\"> 双<code>*</code>号不定长参数支持关键字传入，不支持顺序传入，双<code>*</code>号不定长参数会将传入的参数封装在一个字典里，其中关键字的名字存入字典的键中，关键字的值存入字典的值中。</font>如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">fun</span>(<span class=\"hljs-params\">t,**d</span>):</span><br>    print(t)<br>    print(d[<span class=\"hljs-string\">&#x27;x&#x27;</span>])<br>    print(d[<span class=\"hljs-string\">&#x27;y&#x27;</span>])<br>fun(<span class=\"hljs-number\">1</span>,x=<span class=\"hljs-number\">2</span>,y=<span class=\"hljs-number\">3</span>)<br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-number\">1</span><br><span class=\"hljs-number\">2</span><br><span class=\"hljs-number\">3</span><br></code></pre></td></tr></table></figure>\n<p>当函数中同时存在单<code>*</code>号不定长参数和双<code>*</code>号不定长参数时，双<code>*</code>号不定长参数应放在最后一个参数位置，单<code>*</code>号参数应放在倒数第二个参数位置。</p>\n<h2 id=\"4-匿名函数\"><a href=\"#4-匿名函数\" class=\"headerlink\" title=\"4.匿名函数\"></a>4.匿名函数</h2><p>Python的匿名函数的使用场景是，当函数体只由比较简单的Lambda表达式组成时才使用。匿名函数除了没有函数名，其他的和有名函数没有什么区别。如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">f = <span class=\"hljs-keyword\">lambda</span> a,b=<span class=\"hljs-number\">1</span>: a+b<br>print(f(<span class=\"hljs-number\">1</span>))<br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-number\">2</span><br></code></pre></td></tr></table></figure>\n<p>在lambda表达式的结构中，<code>:</code>之前的为参数，<code>:</code>号之后有且只有一条语句，这是由Python语句分割的方式决定的。从上面的例子我们还可以发现，lambda表达式支持默认参数，且自带返回值，lambda表达式将表达式的结果作为返回值，需要注意的是，lambda表达式中不能进行复制操作，否则将报语法错误。</p>\n<h1 id=\"七、模块\"><a href=\"#七、模块\" class=\"headerlink\" title=\"七、模块\"></a>七、模块</h1><p>一个Python文件就是一个Python模块，一个Python包也是一个Python模块。</p>\n<h2 id=\"1-导入模块（包）\"><a href=\"#1-导入模块（包）\" class=\"headerlink\" title=\"1.导入模块（包）\"></a>1.导入模块（包）</h2><h3 id=\"整模块导入\"><a href=\"#整模块导入\" class=\"headerlink\" title=\"整模块导入\"></a>整模块导入</h3><p>Python使用<code>import</code>+<code>模块名</code>来导入模块，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> MyFirstPython<br></code></pre></td></tr></table></figure>\n<p>当我们将一个Python作为模块导入到另一个文件时，Python会在工程文件夹下的<code>__pycache</code>文件夹下生成一个模块名对应的<code>pyc</code>文件，如上面的例子则会生成一个<code>PyFirstPython.cpython-39.pyc</code>其中cpython-39为python版本号，这个文件是做什么用的呢？pyc文件是一个二进制文件，且已经经过Python加密，直接打开会显示乱码，pyc的主要作用就是加快模块的导入速度，注意这里是导入速度而非运行速度，pyc文件可以通过反编译器重新反编译成可执行的Python文件。</p>\n<p>python支持使用<code>,</code>来分割模块，达到同时导入多个包的目的，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> MyfirstPython,MySecondPython<br></code></pre></td></tr></table></figure>\n<h3 id=\"单函数导入\"><a href=\"#单函数导入\" class=\"headerlink\" title=\"单函数导入\"></a>单函数导入</h3><p>python除了支持整个文件的模块导入，同时也支持只导入模块中的一个函数，python使用<code>from 模块名 import 函数名</code>来从指定模块导入单个函数，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">from</span> MySecondPython <span class=\"hljs-keyword\">import</span> fun <span class=\"hljs-keyword\">as</span> f<br></code></pre></td></tr></table></figure>\n<p>同时，python在导入模块或模块中的函数时可以使用<code>as</code>关键字为模块或函数起别名。</p>\n<p>form import还可以使用<code>*</code>来达到import的效果，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">from</span> MyFirstPython <span class=\"hljs-keyword\">import</span> * <span class=\"hljs-comment\">#相当于import MyFirstPython</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"python导入模块时的路径搜索顺序\"><a href=\"#python导入模块时的路径搜索顺序\" class=\"headerlink\" title=\"python导入模块时的路径搜索顺序\"></a>python导入模块时的路径搜索顺序</h3><ul>\n<li>1、当前目录</li>\n<li>2、如果不在当前目录，Python 则搜索在 shell 变量 PYTHONPATH 下的每个目录。</li>\n<li>3、如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/。</li>\n</ul>\n<h3 id=\"python使用导入模块的全局变量\"><a href=\"#python使用导入模块的全局变量\" class=\"headerlink\" title=\"python使用导入模块的全局变量\"></a>python使用导入模块的全局变量</h3><p>有一点十分不方便的就是在当前文件下无法直接使用导入模块的全局变量，只能通过为指定变量编写读写函数才能操作全局变量，这是由python的变量规则决定的。</p>\n<h3 id=\"Pyhton模块打包\"><a href=\"#Pyhton模块打包\" class=\"headerlink\" title=\"Pyhton模块打包\"></a>Pyhton模块打包</h3><p>Python提供了多个打包工具，我使用的是python3.9内置的<code>setuptools</code>库，setuptools库中提供了一个setup函数用于打包模块，具体操作如下：</p>\n<ul>\n<li><p>1.在工程目录下新建一个setup.py文件，这个文件用于配置一些包的必要信息，配置信息都由关键字参数的形式传入setup函数中，具体参数信息如下;</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">setup(<br>    name=about[<span class=\"hljs-string\">&quot;__title__&quot;</span>],  <span class=\"hljs-comment\"># 包名称</span><br>    version=about[<span class=\"hljs-string\">&quot;__version__&quot;</span>],  <span class=\"hljs-comment\"># 包版本</span><br>    description=about[<span class=\"hljs-string\">&quot;__description__&quot;</span>],  <span class=\"hljs-comment\"># 包详细描述</span><br>    long_description=readme,   <span class=\"hljs-comment\"># 长描述，通常是readme，打包到PiPy需要</span><br>    author=about[<span class=\"hljs-string\">&quot;__author__&quot;</span>],  <span class=\"hljs-comment\"># 作者名称</span><br>    author_email=about[<span class=\"hljs-string\">&quot;__author_email__&quot;</span>],  <span class=\"hljs-comment\"># 作者邮箱</span><br>    url=about[<span class=\"hljs-string\">&quot;__url__&quot;</span>],   <span class=\"hljs-comment\"># 项目官网</span><br>    packages=packages,    <span class=\"hljs-comment\"># 项目需要的包</span><br>    data_files=file_data,   <span class=\"hljs-comment\"># 打包时需要打包的数据文件，如图片，配置文件等</span><br>    include_package_data=<span class=\"hljs-literal\">True</span>,  <span class=\"hljs-comment\"># 是否需要导入静态数据文件</span><br>    python_requires=<span class=\"hljs-string\">&quot;&gt;=3.0, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3*&quot;</span>,  <span class=\"hljs-comment\"># Python版本依赖</span><br>    install_requires=requires,  <span class=\"hljs-comment\"># 第三方库依赖</span><br>    zip_safe=<span class=\"hljs-literal\">False</span>,  <span class=\"hljs-comment\"># 此项需要，否则卸载时报windows error</span><br>    classifiers=[    <span class=\"hljs-comment\"># 程序的所属分类列表</span><br>        <span class=\"hljs-string\">&#x27;Development Status :: 5 - Production/Stable&#x27;</span>,<br>        <span class=\"hljs-string\">&#x27;Intended Audience :: Developers&#x27;</span>,<br>        <span class=\"hljs-string\">&#x27;Natural Language :: English&#x27;</span>,<br>        <span class=\"hljs-string\">&#x27;Programming Language :: Python&#x27;</span>,<br>        <span class=\"hljs-string\">&#x27;Programming Language :: Python :: 3&#x27;</span>,<br>        <span class=\"hljs-string\">&#x27;Programming Language :: Python :: 3.4&#x27;</span>,<br>        <span class=\"hljs-string\">&#x27;Programming Language :: Python :: 3.5&#x27;</span>,<br>        <span class=\"hljs-string\">&#x27;Programming Language :: Python :: 3.6&#x27;</span>,<br>        <span class=\"hljs-string\">&#x27;Programming Language :: Python :: 3.7&#x27;</span>,<br>        <span class=\"hljs-string\">&#x27;Programming Language :: Python :: Implementation :: CPython&#x27;</span>,<br>        <span class=\"hljs-string\">&#x27;Programming Language :: Python :: Implementation :: PyPy&#x27;</span><br>    ],<br>)<br></code></pre></td></tr></table></figure>\n<p>当然这里面所有的参数都不是非必须，如果我们一个参数都不传入，则pyhton会生成一个名为<code>UNKNOW-0.0.0.tar.gz</code>的包。</p>\n</li>\n<li><p>2.使用cmd进入setup.py所在目录，使用<code>python setup.py sdist</code>命令之后，python会在此目录下生成一个<code>dist</code>目录和一个<code>包名.egg-info</code>目录，包名及setup函数中name指定的名称，为命名则为UNKNOWN.egg-info，这个文件夹下是一些包的详细信息文件。</p>\n</li>\n</ul>\n<p>如此包便打包完成了，这中间踩了一写坑，记录一下：</p>\n<p>使用python setup.py sdist命令无反应，然后使用python -v发现也不输出python版信息，此时打开此电脑/属性/高级系统设置/高级/环境变量，发现path中都以存在python目录，可是使用python -v就是无反应。</p>\n<p>解决方案：在cmd下使用<code>set PATH=Python完成目录;%PATH%</code>，不知道为什么需要使用命令行配置一下系统环境才行。</p>\n<p>当然不同的打包工具，打包过程略有不同，这里就详细展开了。</p>\n<h1 id=\"八、Python的内置函数\"><a href=\"#八、Python的内置函数\" class=\"headerlink\" title=\"八、Python的内置函数\"></a>八、Python的内置函数</h1><h2 id=\"1-数学函数\"><a href=\"#1-数学函数\" class=\"headerlink\" title=\"1.数学函数\"></a>1.数学函数</h2><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"https://www.runoob.com/python/func-number-abs.html\">abs()</a></td>\n<td>返回数字的绝对值，如abs(-10) 返回 10</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/func-number-cmp.html\">cmp()</a></td>\n<td>如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/func-number-max.html\">max()</a></td>\n<td>返回给定参数的最大值，参数可以为序列</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/func-number-min.html\">min()</a></td>\n<td>返回给定参数的最小值，参数可以为序列</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/func-number-pow.html\">pow()</a></td>\n<td>x^y 运算后的值，及求x的y次幂</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/func-number-round.html\">round(x [,n])</a></td>\n<td>返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-sum.html\">sum()</a></td>\n<td>对序列求和</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/func-number-round.html\">round()</a></td>\n<td>返回浮点数x的四舍五入值</td>\n</tr>\n</tbody></table>\n<h2 id=\"5-反射函数\"><a href=\"#5-反射函数\" class=\"headerlink\" title=\"5.反射函数\"></a>5.反射函数</h2><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"https://www.runoob.com/python/python-func-dir.html\">dir()</a></td>\n<td>dir函数返回一个包含了一个模块里所定义的所有模块、变量和函数，dir函数只是列出名称，无其他实际意义，其中以<code>__</code>开头的是模块相关的默认属性，如：<code>__name__</code>指向模块的名字，<code>__file__</code>指向模块文件的名字，dir函数可以传入模块名称，则输出的是模块相关的信息，如果不传入参数则输出当前作用域的相关信息</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-globals.html\">globals()</a></td>\n<td>在函数内使用则返回一个包含该函数能访问的所有全局名字的字典，在函数外使用效果和在函数内使用一样</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-locals.html\">locals()</a></td>\n<td>在函数内使用则返回一个包含该函数内的全部局部名字的字典，在函数外使用效果和globals()函数一样</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-callable.html\">callable()</a></td>\n<td>检查一个对象是否是可调用的。如果返回 True，object 仍然可能调用失败；但如果返回 False，调用对象 object 绝对不会成功。</td>\n</tr>\n</tbody></table>\n<h2 id=\"6-类型转换函数\"><a href=\"#6-类型转换函数\" class=\"headerlink\" title=\"6.类型转换函数\"></a>6.类型转换函数</h2><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"https://www.runoob.com/python/python-func-bool.html\">bool()</a></td>\n<td>将对象转换为bool类型，对于空元组和空列表将转换为false</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-float.html\">float()</a></td>\n<td>在python中没有double类型，python的float精度就已经达到了double的精度</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-int.html\">int()</a></td>\n<td>转整型</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-long.html\">long()</a></td>\n<td>转长整型</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-str.html\">str()</a></td>\n<td>将对象转换成字符串，支持任何对象</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-eval.html\">eval()</a></td>\n<td>eval函数可以用来做字符串转列表、元组和字典等，如：<code>a = eval(&#39;[1,2]&#39;)</code>、<code>b = eval(&#39;(1,2)&#39;)</code>，a是一个列表，b是一个元组，其中字典需要注意的是要使用纯字符串，如：<code>c = eavl(r&quot;&#123;&#39;a&#39;:1,&#39;b&#39;:2&#125;&quot;)</code>，c就是一个字典了，除此之外，eval函数还可以用来运行字符串命令，如：<code>eval(&#39;bool(1)&#39;)</code>，输出为<code>True</code></td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/att-list-list.html\">list()</a></td>\n<td>将可迭代序列(包括元组，字符串，字典等)转换成列表，如：字符串转列表<code>a = list(&#39;abc&#39;)</code>则a列表内容为<code>[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]</code>、字典转列表则会返回一个key值列表</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/att-tuple-tuple.html\">tuple()</a></td>\n<td>将可迭代序列(包括元组，字符串，字典等)转换成元组，如：字符串转元组<code>a = tuple(&#39;abc&#39;)</code>则a列表内容为<code>(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;)</code>、字典转元组则会返回一个key值元组</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-dict.html\">dict()</a></td>\n<td>dict函数支持三种转换形式，其一使用关键字的形式，关键字名称为键，关键字的值为值，如：<code>a=dict(a=1,b=1)</code>则a就是字典<code>&#123;&#39;a&#39;:1,&#39;b&#39;:2&#125;</code>，其二使用zip函数的形式，zip函数将两个可迭代序列按位置打包成二元元组，dict函数则将二元元组的第一个元素作为键，第二个元素作为值创建字典，如：<code>a=dict(zip([&#39;a&#39;,&#39;b&#39;],[1,2]))</code>，其中zip函数返回值为<code>[(&#39;a&#39;,1),(&#39;b&#39;,2)]</code>，dict函数返回值为<code>&#123;&#39;a&#39;:1,&#39;b&#39;:2&#125;</code>，其三使用可迭代对象的形式，如：<code>a=dict([(&#39;a&#39;,1),(&#39;b&#39;:2)])</code>其中可迭代对象可以是任何子成员为二元序列的对象</td>\n</tr>\n<tr>\n<td><a href=\"https://www.runoob.com/python/python-func-chr.html\">chr()</a></td>\n<td>将数字转换成对应的字符</td>\n</tr>\n</tbody></table>\n<h2 id=\"6-其他内置函数\"><a href=\"#6-其他内置函数\" class=\"headerlink\" title=\"6.其他内置函数\"></a>6.其他内置函数</h2><p>详情见<a href=\"https://www.runoob.com/python/python-built-in-functions.html\">菜鸟教程</a></p>\n<h1 id=\"九、文件IO\"><a href=\"#九、文件IO\" class=\"headerlink\" title=\"九、文件IO\"></a>九、文件IO</h1><h2 id=\"1-标准输出\"><a href=\"#1-标准输出\" class=\"headerlink\" title=\"1.标准输出\"></a>1.标准输出</h2><p>print()在终端打印，这里需要注意的是python3已经不支持<code>print &#39;aa&#39;</code>这种打印方式了。</p>\n<h2 id=\"2-标准输入\"><a href=\"#2-标准输入\" class=\"headerlink\" title=\"2.标准输入\"></a>2.标准输入</h2><p>input()从终端输入，有时我们会看到row_input函数或input函数接收python表达式的标准输入，这些都是ptrhon2的标准输入函数和输入特性，在python3中python只保留了一个input函数作为标准输入，且input函数不在支持python表达式的输入，而是把所有的输入当作是字符串。</p>\n<h2 id=\"3-文件读写\"><a href=\"#3-文件读写\" class=\"headerlink\" title=\"3.文件读写\"></a>3.文件读写</h2><p>python的文件读写通过内置类型<code>file</code>类型来进行操作，而file类型对象的创建需要通过内置函数<code>open</code>来创建。</p>\n<h3 id=\"open函数\"><a href=\"#open函数\" class=\"headerlink\" title=\"open函数\"></a>open函数</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-built_in\">open</span>(file_name ,access_mode, buffering)<br></code></pre></td></tr></table></figure>\n<ul>\n<li><p>file_name：文件路径</p>\n</li>\n<li><p>access_mode：打开模式，默认为只读，具体模式如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">字符</th>\n<th align=\"left\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>&#39;r&#39;</code></td>\n<td align=\"left\">读取（默认）</td>\n</tr>\n<tr>\n<td align=\"left\"><code>&#39;w&#39;</code></td>\n<td align=\"left\">写入，并先截断文件</td>\n</tr>\n<tr>\n<td align=\"left\"><code>&#39;x&#39;</code></td>\n<td align=\"left\">排它性创建，如果文件已存在则失败</td>\n</tr>\n<tr>\n<td align=\"left\"><code>&#39;a&#39;</code></td>\n<td align=\"left\">写入，如果文件存在则在末尾追加</td>\n</tr>\n<tr>\n<td align=\"left\"><code>&#39;b&#39;</code></td>\n<td align=\"left\">二进制模式</td>\n</tr>\n<tr>\n<td align=\"left\"><code>&#39;t&#39;</code></td>\n<td align=\"left\">文本模式（默认）</td>\n</tr>\n<tr>\n<td align=\"left\"><code>&#39;+&#39;</code></td>\n<td align=\"left\">更新磁盘文件（读取并写入）</td>\n</tr>\n</tbody></table>\n<p>python3以后删除了很多打开模式，只保留了上面几种，所以如果在python3环境中使用<code>+</code>打开模式就会报错。</p>\n</li>\n<li><p>buffering：是否寄存行，可选参数，具体取值如下：</p>\n<table>\n<thead>\n<tr>\n<th>取值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>取0，不寄存行</td>\n</tr>\n<tr>\n<td>1</td>\n<td>取1，寄存行</td>\n</tr>\n<tr>\n<td>&gt;1</td>\n<td>取大于1的值，寄存行，且设置寄存区的缓冲大小为当前值</td>\n</tr>\n<tr>\n<td>&lt;0</td>\n<td>取小于0的值，寄存行，且设置寄存区的缓冲大小为系统默认值</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>返回值：open函数打开文件，读取文件内容到内存并一个可操作文件的file类型对象。</p>\n</li>\n</ul>\n<h3 id=\"file类型对象内置函数\"><a href=\"#file类型对象内置函数\" class=\"headerlink\" title=\"file类型对象内置函数\"></a>file类型对象内置函数</h3><table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">方法及描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python3/python3-file-close.html\">file.close()</a></td>\n<td align=\"left\">关闭文件。关闭后文件不能再进行读写操作。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python3/python3-file-flush.html\">file.flush()</a></td>\n<td align=\"left\">刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python3/python3-file-fileno.html\">file.fileno()</a></td>\n<td align=\"left\">返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python3/python3-file-isatty.html\">file.isatty()</a></td>\n<td align=\"left\">如果文件连接到一个终端设备返回 True，否则返回 False。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python3/python3-file-read.html\">file.read([size])</a></td>\n<td align=\"left\">从文件读取指定的字节数，如果未给定或为负则读取所有。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python3/python3-file-readline.html\">file.readline([size])</a></td>\n<td align=\"left\">读取整行，包括 “\\n” 字符。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python3/python3-file-readlines.html\">file.readlines([sizeint])</a></td>\n<td align=\"left\">读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python3/python3-file-seek.html\">file.seek(offset[, whence])</a></td>\n<td align=\"left\">移动文件读取指针到指定位置</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python3/python3-file-tell.html\">file.tell()</a></td>\n<td align=\"left\">返回文件当前位置。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python3/python3-file-truncate.html\">file.truncate([size])</a></td>\n<td align=\"left\">从文件的首行首字符开始截断，截断文件为 size 个字符，无 size 表示从当前位置截断；截断之后后面的所有字符被删除，其中 windows 系统下的换行代表2个字符大小。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python3/python3-file-write.html\">file.write(str)</a></td>\n<td align=\"left\">将字符串写入文件，返回的是写入的字符长度。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/python3/python3-file-writelines.html\">file.writelines(sequence)</a></td>\n<td align=\"left\">向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。</td>\n</tr>\n</tbody></table>\n<h3 id=\"file类型对象内置属性\"><a href=\"#file类型对象内置属性\" class=\"headerlink\" title=\"file类型对象内置属性\"></a>file类型对象内置属性</h3><table>\n<thead>\n<tr>\n<th align=\"left\">属性</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">file.closed</td>\n<td align=\"left\">返回true如果文件已被关闭，否则返回false。</td>\n</tr>\n<tr>\n<td align=\"left\">file.mode</td>\n<td align=\"left\">返回被打开文件的访问模式。</td>\n</tr>\n<tr>\n<td align=\"left\">file.name</td>\n<td align=\"left\">返回文件的名称。</td>\n</tr>\n<tr>\n<td align=\"left\">file.softspace</td>\n<td align=\"left\">如果用print输出后，必须跟一个空格符，则返回false。否则返回true。</td>\n</tr>\n</tbody></table>\n<h2 id=\"4-文件及目录操作\"><a href=\"#4-文件及目录操作\" class=\"headerlink\" title=\"4.文件及目录操作\"></a>4.文件及目录操作</h2><p>这里的文件操作不是对文件的内容进行增删改操作而是在文件级别进行重命名删除设置权限等操作，对文件做这些操作需要用到<code>os</code>模块，os模块提供大量的函数对文件进行操作，文件数量过多这里就不贴出来了，具体见菜鸟教程：</p>\n<p><a href=\"https://www.runoob.com/python/os-file-methods.html\">os文件操作函数</a></p>\n<h1 id=\"十、异常\"><a href=\"#十、异常\" class=\"headerlink\" title=\"十、异常\"></a>十、异常</h1><h2 id=\"1-异常处理语句\"><a href=\"#1-异常处理语句\" class=\"headerlink\" title=\"1.异常处理语句\"></a>1.异常处理语句</h2><p>Python的异常处理语句是<code>try/except</code>，需要监测异常的代码放在<code>try:</code>块下，在异常发生后需要执行的代码放在<code>except:</code>块下，except后可以接异常类型也可以不接，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">try</span>:<br>    a = <span class=\"hljs-number\">1</span>/<span class=\"hljs-number\">0</span><br><span class=\"hljs-keyword\">except</span> ZeroDivisionError:<br>    print(<span class=\"hljs-string\">&#x27;0不可以做除数&#x27;</span>)<br><span class=\"hljs-keyword\">else</span>:<br>    print(<span class=\"hljs-string\">&#x27;没有异常&#x27;</span>)<br><span class=\"hljs-keyword\">finally</span>:<br>    print(<span class=\"hljs-string\">&#x27;有没有异常都会执行&#x27;</span>)<br></code></pre></td></tr></table></figure>\n<p>可以看到，和条件语句一样try/except语句也可以接else分支，else分支在没有异常发生时执行。、</p>\n<h2 id=\"2-抛出异常\"><a href=\"#2-抛出异常\" class=\"headerlink\" title=\"2.抛出异常\"></a>2.抛出异常</h2><p>python使用<code>raise</code>语句来抛出异常，需要注意的是，raise必须抛出一个异常类，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">try</span>:<br>    a = <span class=\"hljs-number\">1</span>/<span class=\"hljs-number\">0</span><br><span class=\"hljs-keyword\">except</span> ZeroDivisionError:<br>    <span class=\"hljs-keyword\">raise</span> ZeroDivisionError(<span class=\"hljs-string\">&#x27;0不可以做除数&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"3-标准异常\"><a href=\"#3-标准异常\" class=\"headerlink\" title=\"3.标准异常\"></a>3.标准异常</h2><table>\n<thead>\n<tr>\n<th align=\"left\">异常名称</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">BaseException</td>\n<td align=\"left\">所有异常的基类</td>\n</tr>\n<tr>\n<td align=\"left\">SystemExit</td>\n<td align=\"left\">解释器请求退出</td>\n</tr>\n<tr>\n<td align=\"left\">KeyboardInterrupt</td>\n<td align=\"left\">用户中断执行(通常是输入^C)</td>\n</tr>\n<tr>\n<td align=\"left\">Exception</td>\n<td align=\"left\">常规错误的基类</td>\n</tr>\n<tr>\n<td align=\"left\">StopIteration</td>\n<td align=\"left\">迭代器没有更多的值</td>\n</tr>\n<tr>\n<td align=\"left\">GeneratorExit</td>\n<td align=\"left\">生成器(generator)发生异常来通知退出</td>\n</tr>\n<tr>\n<td align=\"left\">StandardError</td>\n<td align=\"left\">所有的内建标准异常的基类</td>\n</tr>\n<tr>\n<td align=\"left\">ArithmeticError</td>\n<td align=\"left\">所有数值计算错误的基类</td>\n</tr>\n<tr>\n<td align=\"left\">FloatingPointError</td>\n<td align=\"left\">浮点计算错误</td>\n</tr>\n<tr>\n<td align=\"left\">OverflowError</td>\n<td align=\"left\">数值运算超出最大限制</td>\n</tr>\n<tr>\n<td align=\"left\">ZeroDivisionError</td>\n<td align=\"left\">除(或取模)零 (所有数据类型)</td>\n</tr>\n<tr>\n<td align=\"left\">AssertionError</td>\n<td align=\"left\">断言语句失败</td>\n</tr>\n<tr>\n<td align=\"left\">AttributeError</td>\n<td align=\"left\">对象没有这个属性</td>\n</tr>\n<tr>\n<td align=\"left\">EOFError</td>\n<td align=\"left\">没有内建输入,到达EOF 标记</td>\n</tr>\n<tr>\n<td align=\"left\">EnvironmentError</td>\n<td align=\"left\">操作系统错误的基类</td>\n</tr>\n<tr>\n<td align=\"left\">IOError</td>\n<td align=\"left\">输入/输出操作失败</td>\n</tr>\n<tr>\n<td align=\"left\">OSError</td>\n<td align=\"left\">操作系统错误</td>\n</tr>\n<tr>\n<td align=\"left\">WindowsError</td>\n<td align=\"left\">系统调用失败</td>\n</tr>\n<tr>\n<td align=\"left\">ImportError</td>\n<td align=\"left\">导入模块/对象失败</td>\n</tr>\n<tr>\n<td align=\"left\">LookupError</td>\n<td align=\"left\">无效数据查询的基类</td>\n</tr>\n<tr>\n<td align=\"left\">IndexError</td>\n<td align=\"left\">序列中没有此索引(index)</td>\n</tr>\n<tr>\n<td align=\"left\">KeyError</td>\n<td align=\"left\">映射中没有这个键</td>\n</tr>\n<tr>\n<td align=\"left\">MemoryError</td>\n<td align=\"left\">内存溢出错误(对于Python 解释器不是致命的)</td>\n</tr>\n<tr>\n<td align=\"left\">NameError</td>\n<td align=\"left\">未声明/初始化对象 (没有属性)</td>\n</tr>\n<tr>\n<td align=\"left\">UnboundLocalError</td>\n<td align=\"left\">访问未初始化的本地变量</td>\n</tr>\n<tr>\n<td align=\"left\">ReferenceError</td>\n<td align=\"left\">弱引用(Weak reference)试图访问已经垃圾回收了的对象</td>\n</tr>\n<tr>\n<td align=\"left\">RuntimeError</td>\n<td align=\"left\">一般的运行时错误</td>\n</tr>\n<tr>\n<td align=\"left\">NotImplementedError</td>\n<td align=\"left\">尚未实现的方法</td>\n</tr>\n<tr>\n<td align=\"left\">SyntaxError</td>\n<td align=\"left\">Python 语法错误</td>\n</tr>\n<tr>\n<td align=\"left\">IndentationError</td>\n<td align=\"left\">缩进错误</td>\n</tr>\n<tr>\n<td align=\"left\">TabError</td>\n<td align=\"left\">Tab 和空格混用</td>\n</tr>\n<tr>\n<td align=\"left\">SystemError</td>\n<td align=\"left\">一般的解释器系统错误</td>\n</tr>\n<tr>\n<td align=\"left\">TypeError</td>\n<td align=\"left\">对类型无效的操作</td>\n</tr>\n<tr>\n<td align=\"left\">ValueError</td>\n<td align=\"left\">传入无效的参数</td>\n</tr>\n<tr>\n<td align=\"left\">UnicodeError</td>\n<td align=\"left\">Unicode 相关的错误</td>\n</tr>\n<tr>\n<td align=\"left\">UnicodeDecodeError</td>\n<td align=\"left\">Unicode 解码时的错误</td>\n</tr>\n<tr>\n<td align=\"left\">UnicodeEncodeError</td>\n<td align=\"left\">Unicode 编码时错误</td>\n</tr>\n<tr>\n<td align=\"left\">UnicodeTranslateError</td>\n<td align=\"left\">Unicode 转换时错误</td>\n</tr>\n<tr>\n<td align=\"left\">Warning</td>\n<td align=\"left\">警告的基类</td>\n</tr>\n<tr>\n<td align=\"left\">DeprecationWarning</td>\n<td align=\"left\">关于被弃用的特征的警告</td>\n</tr>\n<tr>\n<td align=\"left\">FutureWarning</td>\n<td align=\"left\">关于构造将来语义会有改变的警告</td>\n</tr>\n<tr>\n<td align=\"left\">OverflowWarning</td>\n<td align=\"left\">旧的关于自动提升为长整型(long)的警告</td>\n</tr>\n<tr>\n<td align=\"left\">PendingDeprecationWarning</td>\n<td align=\"left\">关于特性将会被废弃的警告</td>\n</tr>\n<tr>\n<td align=\"left\">RuntimeWarning</td>\n<td align=\"left\">可疑的运行时行为(runtime behavior)的警告</td>\n</tr>\n<tr>\n<td align=\"left\">SyntaxWarning</td>\n<td align=\"left\">可疑的语法的警告</td>\n</tr>\n<tr>\n<td align=\"left\">UserWarning</td>\n<td align=\"left\">用户代码生成的警告</td>\n</tr>\n</tbody></table>\n<h2 id=\"4-自定义异常\"><a href=\"#4-自定义异常\" class=\"headerlink\" title=\"4.自定义异常\"></a>4.自定义异常</h2><p>python的自定义异常只需要将自定义异常类继承自python标准异常类即可。</p>\n<h1 id=\"十一、面向对象\"><a href=\"#十一、面向对象\" class=\"headerlink\" title=\"十一、面向对象\"></a>十一、面向对象</h1><p>python在设计之初就已经是一门面向对象的语言了，在python中一切皆对象，包括所有的基础类型也是对象，这使得python在创建类和对象时十分容易，但是这也导致python十分消耗内存空间，因为哪怕只创建一个整型也会消耗对于C语言的内存空间。</p>\n<h2 id=\"1-定义类\"><a href=\"#1-定义类\" class=\"headerlink\" title=\"1.定义类\"></a>1.定义类</h2><p>和大多数语言一样，python也使用<code>class</code>关键字来标识类，使用同等量的缩进来标识类的范围，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span>:</span><br>    age = <span class=\"hljs-number\">0</span><br>    name = <span class=\"hljs-string\">&#x27;&#x27;</span><br>    __id = <span class=\"hljs-number\">1</span><br>    _sex = <span class=\"hljs-string\">&#x27;female&#x27;</span><br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__init__</span>(<span class=\"hljs-params\">self, age, name</span>):</span><br>        self.age = age<br>        self.name = name<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">GetName</span>(<span class=\"hljs-params\">this</span>):</span><br>        print(<span class=\"hljs-string\">&#x27;my name is &#x27;</span> + this.name)<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__SetId</span>():</span><br>        <span class=\"hljs-built_in\">id</span> = 001<br><br><br>p = Person(<span class=\"hljs-number\">18</span>, <span class=\"hljs-string\">&#x27;lusa&#x27;</span>)<br>p.GetName()<br></code></pre></td></tr></table></figure>\n<h2 id=\"2-成员变量\"><a href=\"#2-成员变量\" class=\"headerlink\" title=\"2.成员变量\"></a>2.成员变量</h2><h3 id=\"私有成员变量\"><a href=\"#私有成员变量\" class=\"headerlink\" title=\"私有成员变量\"></a>私有成员变量</h3><p>由于python无法使用public，private等关键字，所以python使用双下划线开头来标识私有成员变量。如上面代码中的<code>__id</code>。</p>\n<h3 id=\"保护成员变量\"><a href=\"#保护成员变量\" class=\"headerlink\" title=\"保护成员变量\"></a>保护成员变量</h3><p>python使用单下划线开头来标识保护成员变量，如上面代码中的<code>_sex</code>。</p>\n<h3 id=\"公有成员变量\"><a href=\"#公有成员变量\" class=\"headerlink\" title=\"公有成员变量\"></a>公有成员变量</h3><p>不带有任何前缀的变量的就是公有成员变量。</p>\n<h2 id=\"3-成员函数\"><a href=\"#3-成员函数\" class=\"headerlink\" title=\"3.成员函数\"></a>3.成员函数</h2><h3 id=\"私有函数、保护函数和公有函数\"><a href=\"#私有函数、保护函数和公有函数\" class=\"headerlink\" title=\"私有函数、保护函数和公有函数\"></a>私有函数、保护函数和公有函数</h3><p>和变量一样，python使用双下划线来前缀来标识私有函数，用单下划线前缀来标识保护函数，无前缀函数表示公有函数。</p>\n<h3 id=\"self参数\"><a href=\"#self参数\" class=\"headerlink\" title=\"self参数\"></a>self参数</h3><p><font color=\"red\">与其他语言不同的是，python的函数都必须带有一个self参数，self参数的在效果上与C++的this指针很像，但是python的self参数不是类自带的，在定义函数时需要手动显示表示，且必须放在函数的第一个参数位置，self参数的名字不一定非得叫self也可以叫其他的名字，如上面代码中的GetName函数的this，但是按照python的规范建议将都是用self命名，self参数指向当前类实例，类的实例变量都必须使用self参数才能访问，直接使用是无法访问的，如：</font></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span>:</span><br>    age = <span class=\"hljs-number\">0</span><br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__init__</span>(<span class=\"hljs-params\">self, param</span>):</span><br>        age = param<br></code></pre></td></tr></table></figure>\n<p>不通过self参数访问类的成员变量将直接报语法错误。</p>\n<h2 id=\"4-类变量、实例变量和局部变量\"><a href=\"#4-类变量、实例变量和局部变量\" class=\"headerlink\" title=\"4.类变量、实例变量和局部变量\"></a>4.类变量、实例变量和局部变量</h2><h3 id=\"类变量\"><a href=\"#类变量\" class=\"headerlink\" title=\"类变量\"></a>类变量</h3><p>定义在类的内部且定义在方法体外的变量，如上面代码中age，<font color=\"red\">类变量可以被类直接访问，也可以被实例直接访问，同时可以被实例方法和类方法方法访问，但是不可以被静态方法访问</font>。如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span>:</span><br>    names = <span class=\"hljs-string\">&#x27;aa&#x27;</span><br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__init__</span>(<span class=\"hljs-params\">self, age, name</span>):</span><br>        self.age = age<br>        self.name = name<br>        addr = <span class=\"hljs-string\">&#x27;beijing&#x27;</span><br>        names = <span class=\"hljs-string\">&quot;bb&quot;</span><br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">GetName</span>(<span class=\"hljs-params\">self</span>):</span><br>        self.sex = <span class=\"hljs-string\">&#x27;female&#x27;</span><br>        print(<span class=\"hljs-string\">&#x27;my name is &#x27;</span> + self.names)<br><br><span class=\"hljs-meta\">    @staticmethod</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">PP</span>():</span><br>        print(names)<br>    <br><span class=\"hljs-meta\">    @classmethod</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">OO</span>(<span class=\"hljs-params\">cls</span>):</span>       <br>        print(cls.names)<br><br><br>p = Person(<span class=\"hljs-number\">18</span>, <span class=\"hljs-string\">&quot;lusa&quot;</span>)<br>print(p.names)<br>p.names = <span class=\"hljs-string\">&quot;cc&quot;</span><br>p.GetName()<br>print(Person.names)<br>Person.names = <span class=\"hljs-string\">&quot;dd&quot;</span><br>Person.OO()<br>print(p.names)<br>Person.PP()<br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">aa<br>my name <span class=\"hljs-keyword\">is</span> cc<br>aa<br>dd<br>cc<br>Traceback (most recent call last):<br>  File <span class=\"hljs-string\">&quot;d:\\Codes\\Python\\MyFirstPython.py&quot;</span>, line <span class=\"hljs-number\">31</span>, <span class=\"hljs-keyword\">in</span> &lt;module&gt;<br>    Person.PP()<br>  File <span class=\"hljs-string\">&quot;d:\\Codes\\Python\\MyFirstPython.py&quot;</span>, line <span class=\"hljs-number\">16</span>, <span class=\"hljs-keyword\">in</span> PP<br>    print(names)<br>NameError: name <span class=\"hljs-string\">&#x27;names&#x27;</span> <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> definedd<br></code></pre></td></tr></table></figure>\n<p>可以看到，类变量names初始值为aa，我们的本意是在构造函数中再赋值bb但是再实际输出中names的值依旧是aa，当我们使用实例给类变量names赋值为cc时，输出GetName函数输出就变为了cc，然而直接通过类名访问的结果依旧是aa，当我们通过类名赋值names为dd时，类方法输出的结果就变为了dd，然而用实例访问的结果依旧时cc，最终运行到类的静态方法PP处则报错了，由上结果可得出结论：</p>\n<ul>\n<li>类在创建实例时会拷贝一份类变量到实例中，实例中类变量和类中的类变量互相独立</li>\n<li>构造函数不可以初始化类变量，当我们在构造函数初始化一个类变量的同名变量时，实际上python初始化的是一个和类变量同名的局部变量</li>\n<li>同一个类变量既可以被类实例访问也可以被类名直接访问，但二者内存地址时两个内存地址</li>\n<li>静态方法不可以访问类变量</li>\n</ul>\n<h3 id=\"实例变量\"><a href=\"#实例变量\" class=\"headerlink\" title=\"实例变量\"></a>实例变量</h3><p>实例变量是定义在构造函数内部且通过self引出的变量，这两点十分重要，如果一个变量不是在构造函数里创建即使通过self引出也依旧不是实例变量，或一个变量在构造函数中创建但不是由self引出，那它也不是实例变量，而是函数的局部变量，如：上面代码中self.sex，和构造函数里的addr和names，我们是不可以使用实例访问的。</p>\n<h3 id=\"局部变量\"><a href=\"#局部变量\" class=\"headerlink\" title=\"局部变量\"></a>局部变量</h3><p>在构造函数中创建的不由self引出的变量或在其他方法中创建的变量，如上面代码中GetName啊哈桑农户里的self.sex和构造函数里的addr和names</p>\n<h2 id=\"5-类方法、实例方法和静态方法\"><a href=\"#5-类方法、实例方法和静态方法\" class=\"headerlink\" title=\"5.类方法、实例方法和静态方法\"></a>5.类方法、实例方法和静态方法</h2><p>被<code>@classmethod</code>修饰的方法就是类方法，被<code>@staticmethod</code>修饰的方法就是静态方法，除此之外其余的方法都是实例方法。类方法和静态方法也有保护级。</p>\n<h3 id=\"类方法\"><a href=\"#类方法\" class=\"headerlink\" title=\"类方法\"></a>类方法</h3><p>类方法属于类，可以直接通过类型访问，也可以同通过实例访问，访问效果是一样的。在创建类方法时必须至少需要一个参数，一般命名为<code>cls</code>，用于python传递默认参数–类。如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">@classmethod</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">OO</span>(<span class=\"hljs-params\">cls</span>):</span><br>    print(cls.names)<br></code></pre></td></tr></table></figure>\n<p>cls不可省略，在类方法中只能通过cls来访问类变量，且只能访问类变量。</p>\n<h3 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h3><p>静态方法同类方法很相似，也可以被类名和实例直接访问。不同的是，静态方法不需要cls参数，python不会传递默认参数到静态方法，静态方法不可以直接访问类的任何成员。</p>\n<h3 id=\"嵌套函数\"><a href=\"#嵌套函数\" class=\"headerlink\" title=\"嵌套函数\"></a>嵌套函数</h3><p>python支持方法中嵌套创建方法，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">funa</span>():</span><br>    a = <span class=\"hljs-number\">1</span><br>    print(a)<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">funb</span>():</span><br>        <span class=\"hljs-keyword\">nonlocal</span> a<br>        a += <span class=\"hljs-number\">1</span><br>        print(a)<br>   <br>    funb()<br><br><br>funa()<br></code></pre></td></tr></table></figure>\n<h1 id=\"十二、作用域\"><a href=\"#十二、作用域\" class=\"headerlink\" title=\"十二、作用域\"></a>十二、作用域</h1><p>python的作用域大部分与C系列语言的作用域差不多，只是有三点比较特殊：</p>\n<ul>\n<li><p>python中只有类、函数、模块才会引入新的作用域，控制语句不会引入新的作用域，也就是说，在控制语句中创建的变量可以在控制语句外部被访问</p>\n<p>如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">3</span>):<br>    print(i)<br><br>print(i)<br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-number\">0</span><br><span class=\"hljs-number\">1</span><br><span class=\"hljs-number\">2</span><br><span class=\"hljs-number\">2</span><br></code></pre></td></tr></table></figure></li>\n<li><p>如果要在函数内部访问全局变量需要在在函数内部使用<code>global</code>申明，否则python将创建一个同名的局部变量而不是引用全局变量</p>\n<p>如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">a = <span class=\"hljs-number\">1</span><br><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">fun</span>():</span><br>    a += <span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n<p>python会直接报语法错误，因为我们使用了一个未定义的局部变量，但是当我们使用global申明之后，我们访问的就是全局变量了，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">a = <span class=\"hljs-number\">1</span><br><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">fun</span>():</span><br>    <span class=\"hljs-keyword\">global</span> a<br>    a += <span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure></li>\n<li><p>如果要在嵌套函数中访问外层函数的变量需要使用<code>nonlocal</code>申明，否则python也会创建一个同名的局部函数，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">a = <span class=\"hljs-number\">1</span><br><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">fun</span>():</span><br>    <span class=\"hljs-keyword\">global</span> a<br>    a += <span class=\"hljs-number\">1</span><br>    b = <span class=\"hljs-number\">2</span><br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">funb</span>():</span><br>        <span class=\"hljs-keyword\">global</span> a<br>        <span class=\"hljs-keyword\">nonlocal</span> b<br>        b += <span class=\"hljs-number\">1</span><br>        print(a)<br>        print(b)<br><br>    funb()<br><br><br>fun()<br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-number\">2</span><br><span class=\"hljs-number\">3</span><br></code></pre></td></tr></table></figure>\n\n\n</li>\n</ul>"},{"title":"【计算机网络】网络游戏基础","date":"2019-08-25T11:34:37.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n![](【网络游戏】网络游戏基础/网络游戏基础.jpg)","source":"_posts/【计算机网络】网络游戏基础.md","raw":"---\ntitle: 【计算机网络】网络游戏基础\ndate: 2019-08-25 19:34:37\ntags: 计算机网络\ncategories: 学习笔记\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n![](【网络游戏】网络游戏基础/网络游戏基础.jpg)","slug":"【计算机网络】网络游戏基础","published":1,"updated":"2021-02-24T06:08:59.629Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklj1h5vc0000y4r7f1oofoww","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p><img src=\"/2019/08/25/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%9F%BA%E7%A1%80.jpg\"></p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p><img src=\"/2019/08/25/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%9F%BA%E7%A1%80.jpg\"></p>\n"},{"title":"【计算机网络】物联网通信基础","date":"2019-08-25T11:22:09.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n![](【网络通信】物联网通信基础/物联网通信技术基础.png)","source":"_posts/【计算机网络】物联网通信基础.md","raw":"---\ntitle: 【计算机网络】物联网通信基础\ndate: 2019-08-25 19:22:09\ntags: 计算机网络\ncategories: 学习笔记\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n![](【网络通信】物联网通信基础/物联网通信技术基础.png)","slug":"【计算机网络】物联网通信基础","published":1,"updated":"2021-02-24T06:09:24.559Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklj1h5w50001y4r77gugb7rt","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p><img src=\"/2019/08/25/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E7%89%A9%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/%E7%89%A9%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p><img src=\"/2019/08/25/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E7%89%A9%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/%E7%89%A9%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.png\"></p>\n"},{"title":"【UE4】GamePlay架构","date":"2021-02-26T01:37:18.000Z","password":null,"abstract":null,"message":null,"_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n参考博客：[UE4官方文档](https://docs.unrealengine.com/en-US/index.html)、[大钊](https://zhuanlan.zhihu.com/p/22813908)、[南京周润发](https://zhuanlan.zhihu.com/p/67055774)、[带带大师兄](https://blog.csdn.net/qq_29523119/article/details/84981218)\n\n# 一、整体框架\n\n首先来看一下整体框架：\n<!--more-->\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210226143303.png)\n\n\n\n<font color=red> 红色部分为主体，从右往左为组合关系，至上而下为派生关系。</font>\n\n在整个UE宇宙的构成中，UEngine就类似化学元素，UObject就类似物质，物质通过演化便衍生出了物体—AActor和UActorComponent，AActor继续演化就出现了生物APawn，人—ACharacter，于是世界便有了信息—AInfo，规则—AGameMode，大量的物体、生物组合在一起便形成了大陆—ULevel，不同的大陆组合在一起便形成了世界—UWorld，世界有着自己的信息—FWorldContext和客观规律—UGameInstance。\n\n而在UE这个宇宙有很多个Word，如编辑时的World，编辑时运行的World，运行时的World等等，查看源码就可知道UE宇宙有五大世界。\n\n```c++\nnamespace EWorldType\n{\n\tenum Type\n\t{\n\t\tNone,\t\t// An untyped world, in most cases this will be the vestigial worlds of streamed in sub-levels\n\t\tGame,\t\t// The game world\n\t\tEditor,\t\t// A world being edited in the editor\n\t\tPIE,\t\t// A Play In Editor world\n\t\tPreview,\t// A preview world for an editor tool\n\t\tInactive\t// An editor world that was loaded but not currently being edited in the level editor\n\t};\n}\n```\n\n首先我们先了解一下这些类的具体作用，然后再细致的了解各个类。\n\n## 1.UEngine\n\nUEngine类是UE的基础，UEngine提供一些最底层的交互—与操作系统的交互，而根据不同的运行模式UE与操作系统的交互模式又有少许不同，所以UEngine又派生出了UGameEngine和UEditerEngine来负责不同运行模式下的交互模式。\n\n其中有一个很重要的全局指针GEngine，通过GEngine可以访问各种UE的全局资源，同时GEngine还提供多线程访问能力。\n\n关于UEngine的资料实在是太少了，官方文档中对UEngine的描述也就一句话，对UEngine的理解也就止步于此了。\n\n## 2.UObject\n\nUObject是构成UE世界最基础的物质，所以UObject提供供UE世界运行的最基本的功能：\n\n- Garbage collection：垃圾收集\n- Reference updating：引用自动更新\n- Reflection：反射\n- Serialization：序列化\n- Automatic updating of default property changes：自动检测默认变量的更改\n- Automatic property initialization：自动变量初始化\n- Automatic editor integration：和虚幻引擎编辑器的自动交互\n- Type information available at runtime：运行时类型识别\n- Network replication：网络复制\n\n在之后再深入浅出的讲解各个功能。\n\n## 3.AActor\n\nAActor是派生自UObject的一个及其重要的类，AActor在UObject的基础上再进一步提供了：\n\n- Replication：网络复制\n- Spawn：动态创建\n- Tick：每帧运行\n\nReplicatoin使AActor有了分裂复制的生育能力，Spawn使AActor在UE世界中出生，在UE4世界中死去，Tick使AActor有了心跳，AActor便组成了丰富多彩的UE世界。\n\nAActor拥有一个庞大的子孙族群，ALevelScriptActor、ANavigationObjectBase、APawn、AController、AInfo这些都是AActor的直系后代，而这些后代也都各自拥有自己的庞大分支族群，构成了UE世界中最强大的种族AActor。\n\n### ALevelScriptActor\n\nALevelScriptActor在官方文档中的表述就是ULevelScriptBlueprint生成的类的基类，通过名称我们就很容易联想到关卡蓝图，没错ULevelScriptBlueprint就是我们最常用的关卡蓝图，ULevelScriptBlueprint继承自UObject，所以ULevelScriptBlueprint的子类是一个多继承的虚继承类，而ALevelScriptActor就为其提供AActor的能力。\n\n在官方文档中有提及默认关卡蓝图是可以通过DefualtGame.ini配置文件替换成自定义关卡蓝图的，具体使用方法在后面在探讨。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210309211442.png)\n\n### ANavigationObjectBase\n\nANavigationObjectBase的资料实在是少的可怜，就连官方文档也是没有一个字的描述，源码也是相当简单，总共就70行，由ANavigationObjectBase是APlayerState的基类，和它继承的接口INavAgentInterface可以猜测ANavigationObjectBase应该和网络复制有关，具体细节留到以后更熟悉UE4了再深入探讨吧。\n\n### APlayerStart\n\nAPlayerStart的作用就是记录APawn在游戏开始时生成的Position与Rotation信息，UE设计APlayerStart的初忠就是想让游戏的关卡设十师和场景设计师的工作分离开来，也就解耦合。那么，如果Level中不存在APlayerStart ，APawn 会出生在哪是呢？答案是世界原点(0，0，0)\n\n\n### APawn\n\nAPawn在AActor的基础上再度添加了：\n\n- 被Controller控制\n- PhysicsCollision：物理碰撞\n- MovementInput：移动响应接口\n\n等能力，有了MovementInput接口APawn就拥有了可运动的能力，这里UE的逻辑划分十分精妙，UE将一个可运动的物体巧妙地划分成了APwan和AController，APawn重点表现在物体，而这个物体具备运动能力，但是自身不具备运动技巧；而AController这是控制APawn运动地大脑，用来控制APawn如何运动，如果把APawn比作是提线木偶，那么AController就是控制木偶运动地线。\n\n到了APawn这一代，AActor的衍化之旅开始衍化出现于玩家间交互的能力，而这之中的佼佼者便是ACharacter。\n\n### ACharacter\n\nACharacter是APwan的特化加强版，在UE世界中可以称之为“人”，ACharacter是一个专门为人形角色定制的APawn，自带CharacterMovement组件，可以使人形角色像人一样行走。\n\n### ADefaultPawn\n\n最初始的APawn使最基本的APawn类，只提供APawn的一些基本能力，而没有提供支持这些能力的组件，而在具体实际使用情况中我们使用的APawn应该还需要组合一些其他的能力，以适应不同的场景，如：我们知道APawn可以运动，但在实际场景中我们是要确定这个APawn是因该直立行走还是爬行，是用轮子行驶还是用翅膀飞行，APawn在玩家眼里应该长什么样子，是人还是蛇，是因该左球形碰撞还是应该做方形碰撞，这些都是APawn不具备的能力，这时ADefaultPawn便出现了，ADefaultPawn自带DefualtPawnMovement、CollisionComponent、StaticMeshCompnent三件套，为ADefaultPawn提供了默认的场景表现。\n\n### ASpectatorPawn\n\n在游戏中存在一种特殊的玩家—观战玩家，这类玩家不需要具体表现形式，只需要一些相机的漫游能力，于是ASpectatorPawn出现了，ASpectatorPawn继承自ADefaultPawn，ASpectatorPawn提供了一个基本的USpectatorPawnMovement（不带重力漫游），并关闭了StaticMesh的显示，碰撞也设置到了“Spectator”通道。\n\n### AController\n\nAController就是控制APawn运动的大脑了，ACtroller负责处理一些直接与玩家交互的控制逻辑，AController是从AActor派生的与APawn同级的子类，在UE的设计中，在同一时刻一个AController和一个APawn之间是1:1的关系，AController可以在多个APawn之间通过Possess/UnPossess切换。AController有两种控制APawn的方式，一种是AController直接附在APawn的身上控制APawn的移动，如驾驶汽车，一种是以上帝的视角控制APawn的移动，如控制第三人称的角色。\n\n### APlayerController\n\nAPlayerController是由AController派生出来专门用于负责玩家交互逻辑的AController，APlayerController提供了：\n\n- Camera管理\n- Input输入响应\n- UPlayer关联\n- HUD显示\n- Level切换\n- Voice音源监听\n\n这些能力。\n\n### AAIController\n\n在一个游戏中有玩家控制的角色也可以有NPC，那么NPC的行动逻辑有谁来控制呢？答案就是AAIController，AAIController与APlayerController完全不同，因为一个NPC不要管理Camera，不需要响应玩家的输入，不需要关联UPlayer，不需要显示HUD，不需要监听音源，只有Level切换可能会在少数情况下需要，那么AAIController因该做什么呢？UE为它设计的是这些事：\n\n- Navigation：自动寻路\n- AI Component：用于启动运行行为树，使用黑板数据\n- Task系统：让AI去完成一些任务\n\n当然一个游戏中是至少需要一个APlayerController的，但是可以没有AAIController。\n\n### AInfo\n\nAInfo是一些数据保存类的基类，AInfo不需要运动和碰撞，也不需要物理表现，仅仅只是保存数据，所以UE在AInfo中将这些功能都隐藏了，之所以不直接继承自UObject，而继承自AActor是因为游戏数据是需要具备网络复制的能力的，而UObject不具备这个能力\n\n### AWordSetting\n\nAWordSetting继承自AInfo用来配置和保存一些Level配置，主要用于配置Level的GameMode信息，光照信息，导航系统，声音系统，LOD系统，物理加速度等关卡信息。由此可以知道一个Level对应一个AWordSetting，但是一个AWordSetting可以应用在多个Level上。\n\n### AGameMode\n\nAGameMode就是用于配置AWorldSetting中的GameMode属性的。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210310162744.png)\n\n在UE的设计中AGameMode就是游戏世界的逻辑，及整个游戏的玩法规则，而在实际情况中一个游戏既可以只有一个玩法也可以有多种玩法规则，所以AWordSetting与AGameMode的对应关系也是一个AWorldSetting只能对应一个AGameMode，而一个AGameMode可以对应多个AWorldSetting。那么AGameMode应该负责哪些逻辑呢？UE是这么规定的：\n\n- Class登记：记录GameMode中各种类的信息\n- Spawn：创建Pawn和PlayerController等\n- 游戏进度：游戏暂停重启的逻辑\n- 过场动画逻辑\n- 多人游戏的步调同步\n\n\n### AGameState\n\nAGameState用于保存游戏数据，如任务进度，游戏活动等。\n\n### APlayerState\n\nAPlayerState是一个用于存储玩家状态的类，在一个游戏客户端，尤其是网络游戏客户端中是可以存在多个APlayerState对象的，不同的APlayerState保存不同玩家的状态，同时APlayerState也可以存在于服务器中。APlayerState的生命周期为一整个Level的生命周期。\n\n到这是AActor家族下的几个重要成员的基本功能我们便有了一个大概的了解了，这里我们来捋一下这些成员之间的关系和在UE世界中的地位。\n![Alt](https://i.loli.net/2021/03/10/3Ccrl7uNo4QRbUK.jpg)\n\n## 4.UActorComponent\n\nUActorComponent是UE向U3D看齐的一个产物，虽然UE世界有了Actor就有了形形色色的物体生物，但是不同的生物拥有不同的技能，而同一个Actor可以会某个技能也可以不会，这种概念使用组合的方式组合到Actor下是最理想的，于是Component便出现了，UActorComponent直接继承自UObject，与AActor同级，Component既可以嵌套在Actor下，也可以嵌套在其他的Component下，但是需要注意的是，UActorComponent这一级是不提供互相嵌套的能力的，只有到其子类USceneComponent一级才提供互相嵌套能力。\n\n### USceneComponent\n\nUSceneComponent主要提供两大能力，一是Transform，二是SceneComponent的互相嵌套。一般我们直接在Level里创建的Actor都会默认带有一个SceneComponent组件。\n\n### UPrimitiveComponent\n\nUPrimitiveComponent主要提供Actor用于物体渲染和碰撞相关的基础能力。\n\n### UMeshComponent\n\nUMeshComponent由UPrimitiveComponent派生而来，主要提供具体的渲染显示方面的能力。\n\n### UChildActorComponent\n\n从名字就可以窥探其功能一二了，UChildComponent在Actor中主要用于链接Actor与Component，提供Component和Actor的嵌套能力。\n\n## 5.ULevel\n\nULevel可以看作是UE世界的大陆，是AActor的容器，前面提到的ALevelScriptActor便是ULevel默认带有的关卡蓝图，在这个关卡蓝图中编写便是这块大陆的逻辑，同事ULevel也默认带有一个AWorldSetting。\n\n## 6.UWorld\n\n在UE中所有的ULevel互相联系就构成了一个UWorld，ULevel构建UWorld的方式有两种，一种是以SubLevel的形式，像关卡流一样，一个关卡链接下一个关卡，来组成UWorld，一种是每一个ULevel就是这个大地图的UWorld中的一块地图，ULevel之间以相对位置衔接在一起，构成一个大地图来组成这个UWorld。无论是那种构成形式，在一个UWorld中都有一个PersistentLevel，PersistenetLevel就是主Level，是玩家最初始的出生地，这里用的是最初始而不是游戏开始，是因为，现在很多在游戏开始时玩家的出点可能不是PersistentLevel而是上一次玩家离线时的位置。\n\n## 7.FWorldContext\n\nFWorldContext不对开发者公开，是UE内部用来处理引擎UWorld上下文的类，比如当我们从编辑状态的EditorWorld点击播放切换到PIEWorld即运行状态时，这个过程中EditorWorld到PIEWorld之间的信息交换就是通过FWorldContext实现的。可以说FWorldContext处理的是UWorld级的通信。\n\n## 8.UGameInstance\n\nUGameInstance可以说是凌驾于所有AActor、UActorComponent、ULevel、UWorld之上的类，通常情况下一个Game中应该只有一个，这里的Gam是UEngine中提到的所有World的总和，当然这不是绝对的，对于更高层次的开发者，UE也是提供了多个UGameInstance协同的扩展的。\n\n所以UGameInstance主要处理：\n\n- UWorld、ULevel之间的切换\n- UPlayer的创建，这里的UPlayer又和前面的APlayerController有所不同，这一点在后面再介绍。\n- 全局配置\n- GameMode的切换\n\n## 9.UNetDriver\n\n从名字就可以略知一二，UNetDriver是UE处理网络同步相关的类，UNetDriver中有两个主要的成员：\n\n```c++\nclass UNetConnection* ServerConnection;\nTArray<class UNetConnection*> ClientConnections;\n```\n\nServerConnection是客户端到服务器的连接，ClientConnections数组是服务器到客户端群的连接的数组。而在UNetConnnection中又有一个很重要的成员：\n\n```c++\nTMap<TWeakObjectPtr<AActor>,class UActorChannel*> ActorChannels\n```\n\nActorChannels是在服务器与客户端完成连接后用于实现Actor同步的对象。\n\n## 10.UPlayer\n\nUPlayer即玩家，ULevel可以切换，UWorld可以交替，但是尽管ULevel、UWorld如何变换，玩家还是那个玩家，所以UPlayer是和UGameInstance同一级别的存在，那么，UPlayer、AController、APawn之间到底是什么关系呢?\n\nUE源码对UPlayer是这么解释：\n\n```\nPlayer: Corresponds to a real player (a local camera or remote net player).\n```\n\n很显然，UE对UPlayer的定位就是与玩家交互的类，即UPlayer是直接与底层硬件输入相关的类，如处理鼠标键盘的输入或游戏手柄的输入，当然游戏与人之间的交互也不仅限于这两种，还有VR设备的交互，语音交互，重力感应等等，谁也不知道未来还会有什么样的游戏交互出现，所以UE并没有把UPlayer隐藏起来，开发者依然可以创建自己的UPlayer。而然在大多数情况下，我们是不需要直接操作UPlayer的，因为一些常规的底层交互UE已经封装好了。\n\n所以UPlayer是处理底层输入的，而AController则是直接对接UPlayer，通过接收UPlayer的输入来处理对APawn的控制逻辑，最后APawn更具AController的控制逻辑做出响应的行为，于是玩家到角色的交互过程便实现了。\n\n### ULocalPlayer\n\n在一个单机游戏中UPlayer是唯一的存在，但是在一个网络联级游戏中，表示同一实体的UPlayer即存在于玩家本地的客户端中，同时也存在于其他玩家的多个客户端中，那么玩家的输入就既要作用于本地的APawn上，同时在其他玩家的客户端中的表示这个实体的APawn也要做出响应的反应，于是UE便将UPlayer又派生出了两个子类，ULocalPlayer和UNetConnection。其中ULocalPlayer就是处理本地客户端的输入逻辑的类。\n\n### UNetConnection\n\nUNetConnection就是处理其他玩家在本地客户端中的APawn的类，所以UNetConnection也是一个玩家。\n\n## 11.USaveGame\n\n前面提到了AGameState是一个保存游戏数据的类，这个保存是一个临时保存，所以当游戏程序关闭之后AGameState中数据也就不存在了，而USaveGame就是用来保存存档的类，USaveGame提供游戏数据永久性保存，我们只需要往USaveGame中添加我们要保存的属性字段，就可以直接调用USaveGame的接口直接将游戏数据序列化保存到本地文件中，相当的方便。\n\n花了这么长的篇幅也就简要的介绍了一下GamePlay的整体框架，总共由这11个类组成，说起来不多，但是里面的门道却是相当深奥，这需要在以后的使用中慢慢学习消化。\n\n那么接下来就开始各个类的详细使用学习了。\n\n# 二、UObject\n\n首先我们来看UObject提供的功能：\n\n- Garbage collection：垃圾收集\n- Reference updating：引用自动更新\n- Reflection：反射\n- Serialization：序列化\n- Automatic updating of default property changes：自动检测默认变量的更改\n- Automatic property initialization：自动变量初始化\n- Automatic editor integration：和虚幻引擎编辑器的自动交互\n- Type information available at runtime：运行时类型识别\n- Network replication：网络复制\n\n## 1.垃圾回收\n\n首先我们来研究研究UE4是如何进行垃圾回收的。\n\n这里推荐两位大佬的博客：[带带大师兄](https://zhuanlan.zhihu.com/p/67055774)、[南京周润发](https://blog.csdn.net/qq_29523119/article/details/84981218)\n\n可以配合着看。\n\n由于C++不提供GC功能，所有UE自己实现了一套GC功能，使用的也是最经典的`标记-清理`垃圾回收方式。\n\n### GC的过程\n\nUEGC分为来两个阶段，第一个阶段UE从根集合开始遍历，遍历所有可达对象，于是UE就知道了哪些对象还在被引用，哪些对象已经不可被引用了。第二阶段UE会逐步的清理这些不可达对象，形式为分帧分批清理，为什么要这么做呢？想想我们卸载一次性Level时的感受就知道了，分批处理可以保证我们在使用UE时的顺滑而不卡顿。\n\nUEGC的主要函数是在UObjectGlobals.h头文件中CollectGarbage函数\n\n```c++\nvoid CollectGarbage(EObjectFlags KeepFlags, bool bPerformFullPurge)\n{\n\t// No other thread may be performing UObject operations while we're running\n\tAcquireGCLock();\n\n\t// Perform actual garbage collection\n\tCollectGarbageInternal(KeepFlags, bPerformFullPurge);\n\n\t// Other threads are free to use UObjects\n\tReleaseGCLock();\n}\n```\n\n可以看到GC的整体流程很自然的划分成了三个阶段，获取GC锁、执行CollectGarbageInternal和释放GC锁。使用锁的原因是UEGC是多线程的，为了防止在GC的过程中对象被其他线程访问，以保证异步加载的稳定。而CollectGarbageInternal函数则进行垃圾回收和对象标记与清理，两个参数KeepFlags表示这些被标记的对象无论是否被引用都将被保留，bPerformFullPurge表示GC时进行全清理还是分帧分批清理。\n\n那么GC又是如何进行对象标记的呢？还是看源码\n\n```c++\n/** \n * Deletes all unreferenced objects, keeping objects that have any of the passed in KeepFlags set\n *\n * @param\tKeepFlags\t\t\tobjects with those flags will be kept regardless of being referenced or not\n * @param\tbPerformFullPurge\tif true, perform a full purge after the mark pass\n */\nvoid CollectGarbageInternal(EObjectFlags KeepFlags, bool bPerformFullPurge)\n{\n\tSCOPE_TIME_GUARD(TEXT(\"Collect Garbage\"));\n\tSCOPED_NAMED_EVENT(CollectGarbageInternal, FColor::Red);\n\tCSV_EVENT_GLOBAL(TEXT(\"GC\"));\n\tCSV_SCOPED_TIMING_STAT_EXCLUSIVE(GarbageCollection);\n\n\tFGCCSyncObject::Get().ResetGCIsWaiting();\n\n#if defined(WITH_CODE_GUARD_HANDLER) && WITH_CODE_GUARD_HANDLER\n\tvoid CheckImageIntegrityAtRuntime();\n\tCheckImageIntegrityAtRuntime();\n#endif\n\n\tDECLARE_SCOPE_CYCLE_COUNTER( TEXT( \"CollectGarbageInternal\" ), STAT_CollectGarbageInternal, STATGROUP_GC );\n\tSTAT_ADD_CUSTOMMESSAGE_NAME( STAT_NamedMarker, TEXT( \"GarbageCollection - Begin\" ) );\n\n\t// We can't collect garbage while there's a load in progress. E.g. one potential issue is Import.XObject\n\tcheck(!IsLoading());\n\n\t// Reset GC skip counter\n\tGNumAttemptsSinceLastGC = 0;\n\n\t// Flush streaming before GC if requested\n\tif (GFlushStreamingOnGC)\n\t{\n\t\tif (IsAsyncLoading())\n\t\t{\n\t\t\tUE_LOG(LogGarbage, Log, TEXT(\"CollectGarbageInternal() is flushing async loading\"));\n\t\t}\n\t\tFGCCSyncObject::Get().GCUnlock();\n\t\tFlushAsyncLoading();\n\t\tFGCCSyncObject::Get().GCLock();\n\t}\n\n\t// Route callbacks so we can ensure that we are e.g. not in the middle of loading something by flushing\n\t// the async loading, etc...\n\tFCoreUObjectDelegates::GetPreGarbageCollectDelegate().Broadcast();\n\tGLastGCFrame = GFrameCounter;\n\n\t{\n\t\t// Set 'I'm garbage collecting' flag - might be checked inside various functions.\n\t\t// This has to be unlocked before we call post GC callbacks\n\t\tFGCScopeLock GCLock;\n\n\t\tUE_LOG(LogGarbage, Log, TEXT(\"Collecting garbage%s\"), IsAsyncLoading() ? TEXT(\" while async loading\") : TEXT(\"\"));\n\n\t\t// Make sure previous incremental purge has finished or we do a full purge pass in case we haven't kicked one\n\t\t// off yet since the last call to garbage collection.\n\t\tif (GObjIncrementalPurgeIsInProgress || GObjPurgeIsRequired)\n\t\t{\n\t\t\tIncrementalPurgeGarbage(false);\n\t\t\tFMemory::Trim();\n\t\t}\n\t\tcheck(!GObjIncrementalPurgeIsInProgress);\n\t\tcheck(!GObjPurgeIsRequired);\n\n#if VERIFY_DISREGARD_GC_ASSUMPTIONS\n\t\t// Only verify assumptions if option is enabled. This avoids false positives in the Editor or commandlets.\n\t\tif ((GUObjectArray.DisregardForGCEnabled() || GUObjectClusters.GetNumAllocatedClusters()) && GShouldVerifyGCAssumptions)\n\t\t{\n\t\t\tDECLARE_SCOPE_CYCLE_COUNTER(TEXT(\"CollectGarbageInternal.VerifyGCAssumptions\"), STAT_CollectGarbageInternal_VerifyGCAssumptions, STATGROUP_GC);\n\t\t\tconst double StartTime = FPlatformTime::Seconds();\n\t\t\tVerifyGCAssumptions();\n\t\t\tVerifyClustersAssumptions();\n\t\t\tUE_LOG(LogGarbage, Log, TEXT(\"%f ms for Verify GC Assumptions\"), (FPlatformTime::Seconds() - StartTime) * 1000);\n\t\t}\n#endif\n\n\t\t// Fall back to single threaded GC if processor count is 1 or parallel GC is disabled\n\t\t// or detailed per class gc stats are enabled (not thread safe)\n\t\t// Temporarily forcing single-threaded GC in the editor until Modify() can be safely removed from HandleObjectReference.\n\t\tconst bool bForceSingleThreadedGC = !FApp::ShouldUseThreadingForPerformance() || !FPlatformProcess::SupportsMultithreading() ||\n#if PLATFORM_SUPPORTS_MULTITHREADED_GC\n\t\t(FPlatformMisc::NumberOfCores() < 2 || GAllowParallelGC == 0 || PERF_DETAILED_PER_CLASS_GC_STATS);\n#else\t//PLATFORM_SUPPORTS_MULTITHREADED_GC\n\t\t\ttrue;\n#endif\t//PLATFORM_SUPPORTS_MULTITHREADED_GC\n\n\t\t// Perform reachability analysis.\n\t\t{\n\t\t\tconst double StartTime = FPlatformTime::Seconds();\n\t\t\tFRealtimeGC TagUsedRealtimeGC;\n            //-----------------------------------------------------------\n\t\t\tTagUsedRealtimeGC.PerformReachabilityAnalysis(KeepFlags, bForceSingleThreadedGC);\n            //-----------------------------------------------------------\n\t\t\tUE_LOG(LogGarbage, Log, TEXT(\"%f ms for GC\"), (FPlatformTime::Seconds() - StartTime) * 1000);\n\t\t}\n\n\t\t// Reconstruct clusters if needed\n\t\tif (GUObjectClusters.ClustersNeedDissolving())\n\t\t{\n\t\t\tconst double StartTime = FPlatformTime::Seconds();\n\t\t\tGUObjectClusters.DissolveClusters();\n\t\t\tUE_LOG(LogGarbage, Log, TEXT(\"%f ms for dissolving GC clusters\"), (FPlatformTime::Seconds() - StartTime) * 1000);\n\t\t}\n\n\t\t// Fire post-reachability analysis hooks\n\t\tFCoreUObjectDelegates::PostReachabilityAnalysis.Broadcast();\n\t\t\n\t\t{\n\t\t\tFGCArrayPool::Get().ClearWeakReferences(bPerformFullPurge);\n\n\t\t\tGatherUnreachableObjects(bForceSingleThreadedGC);\n\n\t\t\tif (bPerformFullPurge || !GIncrementalBeginDestroyEnabled)\n\t\t\t{\n\t\t\t\tUnhashUnreachableObjects(/**bUseTimeLimit = */ false);\n\t\t\t\tFScopedCBDProfile::DumpProfile();\n\t\t\t}\n\t\t}\n\n\t\t// Set flag to indicate that we are relying on a purge to be performed.\n\t\tGObjPurgeIsRequired = true;\n\t\t// Reset purged count.\n\t\tGPurgedObjectCountSinceLastMarkPhase = 0;\n\t\tGObjCurrentPurgeObjectIndexResetPastPermanent = true;\n\n\t\t// Perform a full purge by not using a time limit for the incremental purge. The Editor always does a full purge.\n\t\tif (bPerformFullPurge || GIsEditor)\n\t\t{\n\t\t\tIncrementalPurgeGarbage(false);\n\t\t}\n\n\t\tif (bPerformFullPurge)\n\t\t{\n\t\t\tShrinkUObjectHashTables();\n\t\t}\n\n\t\t// Destroy all pending delete linkers\n\t\tDeleteLoaders();\n\n\t\t// Trim allocator memory\n\t\tFMemory::Trim();\n\t}\n\n\t// Route callbacks to verify GC assumptions\n\tFCoreUObjectDelegates::GetPostGarbageCollect().Broadcast();\n\n\tSTAT_ADD_CUSTOMMESSAGE_NAME( STAT_NamedMarker, TEXT( \"GarbageCollection - End\" ) );\n}\n\n```\n\n我在PerformReachabilityAnalysis函数处做了标记，GC时UE就是通过这个函数进行对象标记的，PerformReachabilityAnalysis函数会做多线程实时的分析对象的引用关系，然后标记出可达与不可达对象。标记是如何进行的还得深入到PerformReachabilityAnalysis函数，再上源码\n\n```c++\n/**\n\t * Performs reachability analysis.\n\t *\n\t * @param KeepFlags\t\tObjects with these flags will be kept regardless of being referenced or not\n\t */\n\tvoid PerformReachabilityAnalysis(EObjectFlags KeepFlags, bool bForceSingleThreaded = false)\n\t{\n\t\tLLM_SCOPE(ELLMTag::GC);\n\n\t\tSCOPED_NAMED_EVENT(FRealtimeGC_PerformReachabilityAnalysis, FColor::Red);\n\t\tDECLARE_SCOPE_CYCLE_COUNTER(TEXT(\"FRealtimeGC::PerformReachabilityAnalysis\"), STAT_FArchiveRealtimeGC_PerformReachabilityAnalysis, STATGROUP_GC);\n\n\t\t/** Growing array of objects that require serialization */\n\t\tFGCArrayStruct* ArrayStruct = FGCArrayPool::Get().GetArrayStructFromPool();\n\t\tTArray<UObject*>& ObjectsToSerialize = ArrayStruct->ObjectsToSerialize;\n\n\t\t// Reset object count.\n\t\tGObjectCountDuringLastMarkPhase.Reset();\n\n\t\t// Make sure GC referencer object is checked for references to other objects even if it resides in permanent object pool\n\t\tif (FPlatformProperties::RequiresCookedData() && FGCObject::GGCObjectReferencer && GUObjectArray.IsDisregardForGC(FGCObject::GGCObjectReferencer))\n\t\t{\n\t\t\tObjectsToSerialize.Add(FGCObject::GGCObjectReferencer);\n\t\t}\n\n\t\t{\n\t\t\tconst double StartTime = FPlatformTime::Seconds();\n\t\t\tMarkObjectsAsUnreachable(ObjectsToSerialize, KeepFlags, bForceSingleThreaded);\n\t\t\tUE_LOG(LogGarbage, Verbose, TEXT(\"%f ms for Mark Phase (%d Objects To Serialize\"), (FPlatformTime::Seconds() - StartTime) * 1000, ObjectsToSerialize.Num());\n\t\t}\n\n\t\t{\n\t\t\tconst double StartTime = FPlatformTime::Seconds();\n\t\t\tPerformReachabilityAnalysisOnObjects(ArrayStruct, bForceSingleThreaded);\n\t\t\tUE_LOG(LogGarbage, Verbose, TEXT(\"%f ms for Reachability Analysis\"), (FPlatformTime::Seconds() - StartTime) * 1000);\n\t\t}\n        \n\t\t// Allowing external systems to add object roots. This can't be done through AddReferencedObjects\n\t\t// because it may require tracing objects (via FGarbageCollectionTracer) multiple times\n\t\tFCoreUObjectDelegates::TraceExternalRootsForReachabilityAnalysis.Broadcast(*this, KeepFlags, bForceSingleThreaded);\n\n\t\tFGCArrayPool::Get().ReturnToPool(ArrayStruct);\n\n#if UE_BUILD_DEBUG\n\t\tFGCArrayPool::Get().CheckLeaks();\n#endif\n\t}\n```\n\n首先前面的宏暂时可以忽略掉，\n\n第一步，`FGCArrayStruct* ArrayStruct = FGCArrayPool::Get().GetArrayStructFromPool();`UE将UObject的所有的强引用和弱引用都存储大ArrayStruct数据结构中，FGCArrayPool是UEGC的主要执行类\n\n第二步，`TArray<UObject*>& ObjectsToSerialize = ArrayStruct->ObjectsToSerialize;`分离UObject的强引用到ObjectsToSerialize 数组中。\n\n这是FGCArrayStruct结构体的源码：\n\n```c++\nstruct FGCArrayStruct\n{\n\tTArray<UObject*> ObjectsToSerialize;\n\tTArray<UObject**> WeakReferences;\n};\n```\n\nObjectsToSerialize存储强引用，WeakReferences存储弱引用。\n\n第三步，`GObjectCountDuringLastMarkPhase.Reset();`重置对象的引用计数。\n\n第四步，通过一个if判断标记可达对象，于是可达对象与不可达对象就被标记出来了，接下来便是GC清理。\n\n### GC的触发\n\nUE的GC发生在游戏线程上，支持多线程GC，和大多数主流语言的GC一样支持自动触发和手动触发。\n\n**手动触发**\n\n手动触发UE也提供了两种方式，其一是通过C++函数：\n\n```c++\nGEngine->ForceGarbageCollection();\n```\n\n这里需要注意的是`GEngine`在`Engine.h`头文件下。\n\n手动触发的使用场景一般是在卸载某些资源后，手动触发GC回收这些资源在使用过程中的无用对象。\n\n其二是蓝图节点：\n\n![](D:\\Git\\Hexo\\source\\_posts\\【UE4】UE4GamePlay架构\\Snipaste_2021-03-19_21-54-55.png)\n\n手动调用这两个函数，UE会跳过GC算法，在下一次Tick时直接进行GC。\n\n<font color=red> 这里有一点需要注意，在大多数情况下，手动GC一般只能回收NewObject函数创建的对象，而UWorld()->SpawnActor函数创建的对象无论如何调用都无法销毁，这是因为，当UE创建一个Actor之后在UWorld中就已经保存了这个Actor的引用，所以无论我们如何释放Actor的引用，这个Actor的引用计数都不会归零，所以要销毁一个Actor还是需要通过Actor->Destroy()函数。</font>\n\n我们可以个一个例子：\n\n```c++\n//AACtor.cpp\nAActor1::AActor1()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tUE_LOG(LogTemp, Warning, TEXT(\"Actor1 Created\"));\n}\n\nAActor1::~AActor1()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"Actor1 Destryed\"));\n}\n```\n\n```c++\n//AMyActor.h\nUCLASS()\nclass INSIDEUE4_API AMyActor2 : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAMyActor2();\n\tAActor1 *a;//注意这里没有加UPROPERTY()宏\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n};\n```\n\n```c++\n//AMyActor2\nAMyActor2::AMyActor2()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyActor2::BeginPlay()\n{\n\tSuper::BeginPlay();\n\ta = UWorld()->SpawnActor<AActor1>();\n\ta = NULL;\n\tGEngine->ForceGarbageCollection();\n}\n\nvoid AMyActor2::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```\n\nOutputLog:\n\n```\nLogTemp: Warning: Actor1 Created\n```\n\n可以看到使用UWorld()->SpawnActor创建的Actor即使手动强制GC也没有被回收，因为这个Actor是可达对象。\n\n**自动触发**\n\n要想UE自动触发的GC能能够回收我们创建的对象，那么我们创建的对象就必须继承自UObject，至于加不加UPROPERTY()宏似乎不影响GC的回收，如下面的测试结果，还是以上面的例子为例，把BeginPlay函数改为如下：\n\n```c++\n//AMyActor2\nAMyActor2::AMyActor2()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyActor2::BeginPlay()\n{\n\tSuper::BeginPlay();\n\ta = NewObject<AActor1>();\n\ta = NULL;\n\tGEngine->ForceGarbageCollection();\n}\n\nvoid AMyActor2::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```\n\n我们将MyActor2拖入场景中，运行，OutputLog输出，可以找到下面两句：\n\n```c++\nLogTemp: Warning: Actor1 Created\n\nLogTemp: Warning: Actor1 Destryed\n```\n\n可以看到，没有使用UPROPERTY()宏的变量a依旧在手动GC时被回收了，这里为了效果明显点使用了手动强制回收，其实使用自动GC也是一样的。\n\n<font color=green>这里有提个疑问：</font>\n\n当我们在一个继承自UObject的类组合一个继承自UObject的对象，如果在这个对象定义前没有使用UPROPERTY()宏，那么在Play后UE会调用一次这个对象的析构函数，但是这个对象依然可以被使用，而如果在定义这个对象前使用了UPROPERTY()宏，那么这对象将和组合类被析构时一起被析构。疑问为什么UE会调用一次被组合对象的析构且析构后依然可以使用这个对象。如：\n\n```c++\n//UMyObject.cpp\nUMyObject::UMyObject()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"UMyObject Created\"));\n}\n\nUMyObject::~UMyObject()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"UMyObject Destoryed\"));\n}\n\nvoid UMyObject::Fun()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"UMyObject\"));\n}\n```\n\n```c++\n//AMyActor2.h\nUCLASS()\nclass INSIDEUE4_API AMyActor2 : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAMyActor2();\n\tUPROPERTY()\n\tUMyObject* obj;\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n};\n```\n\n```c++\n//AMyActor2.cpp\nvoid AMyActor2::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tobj = NewObject<UMyObject>();\n}\n```\n\n使用UPROPERTY()宏的输出结果：\n\n```c++\n//在点击Play后输出结果\nLogTemp: Warning: AMyActor2 Created\nLogTemp: Warning: UMyObject Created\n//再点击Stop后输出结果\nLogTemp: Warning: UMyObject Destoryed\nLogTemp: Warning: AMyActor2 Destroyed\n```\n\n不使用UPROPERTY()宏的输出结果：\n\n```c++\n//在点击Play后输出结果\nLogTemp: Warning: AMyActor2 Created\nLogTemp: Warning: UMyObject Created\nLogTemp: Warning: UMyObject Destoryed\n//再点击Stop后输出结果\nLogTemp: Warning: AMyActor2 Destroyed\n```\n\n很明显在Play后UMyObject对象的析构函数被调用了，但是此时如果继续访问UMyObject里的成员依旧可以访问。\n\n### TWeakObjectPtr、TWeakPtr（既保存引用又可GC）\n\n有时我们可能需要在一个类里面临时保存一些对象，但是一旦保存了引用，就需要手动释放才能保证这些对象可以被GC自动回收，关于这个方面UE也贴心的为我们提供了<font color=red> TWeakObjectPtr</font>指针，当然，这也是C++弱指针的UE魔改办罢了，使用这个指针既可以引用对象，但是又不会造成引用计数+1。可以通过一个例子很好的看出来。\n\n```c++\n//AACtor1.cpp\nAActor1::AActor1()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tUE_LOG(LogTemp, Warning, TEXT(\"Actor1 Created\"));\n}\n\nAActor1::~AActor1()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"Actor1 Destryed\"));\n}\n```\n\n```c++\n//AMyActor2\nUCLASS()\nclass INSIDEUE4_API AMyActor2 : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAMyActor2();\n\tAActor1* a;\n\tTWeakObjectPtr<AActor1> p;\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n};\n```\n\n```c++\n//AMyActor2.cpp/BeginPlay()\nvoid AMyActor2::BeginPlay()\n{\n\tSuper::BeginPlay();\n\ta = NewObject<AActor1>();\n\tp = a;\n\ta = NULL;\n\tGEngine->ForceGarbageCollection();\n}\n```\n\nOutputLog:\n\n```\nLogTemp: Warning: Actor1 Created\n\nLogTemp: Warning: Actor1 Destryed\n```\n\n可以看到，AActor1对象依旧被强制回收了。\n\n而TWeakPtr则对于自定义类的弱指针。\n\n<font color=red>注意：弱指针不可以被用来作为TSet或TMap的Key，因为一个对象被GC时无法通知一个容器的Key，但是可以用来作为容器的Value。</font>\n\n### TSharedPtr、TSharedRef（自定义类的GC）\n\n自定义类的GC，UE也贴心的提供了<font color=red> TSharedPtr和TSharedRef</font>对象来为自定义类支持GC，TSharedPtr本质上是一个被封装过的指针，使用形式上依然保留指针的风格。\n\n<font color=red> 创建TSharedPtr指针指向一个自定义类时，需要使用`MakeShareable()`函数，如：</font>\n\n```c++\nTSharedPtr<UMyObject> p = MakeShareable(NewObject<UMyObject>());\nTSharedPtr<FActor> f = MakeShareable(new FActor());\n```\n\nTSharedPtr和TSharedRef都可以为自定义类提供GC功能，二者的区别只在于TSharedPtr可以为null，而SharedRef不可以。我在网上查询发现有三种方法构建TSharedRef，分别为：\n\n第一种：\n\n```c++\nTSharedRef<FActor> ref(new FActor());\n```\n\n第二种：\n\n```c++\nTSharedRef<FActor> ref = MakeShared<FActor>(new FActor());\n```\n\n第三种：\n\n```c++\nTSharedPtr<FActor> ptr = MakeShareable<FActor>(new FActor());\nTSharedRef<FActor> ref = ptr.ToSharedRef();\n```\n\n其中第二种方法在编写时没有任何问题但在编译时无法通过，并提示：\n\n```\nThe TSharedRef() constructor is for internal usage only for hot-reload purposes. Please do NOT use it.\n```\n\n使用的编译环境为：UE4.22 + VS2017\n\n### FGCObject（在自定义类中控制UObject对象的GC）\n\n当我们在一个自定义类中组合一个UObject对象时，如果不做特殊处理也会出现GC触发中发现的疑问，在自定义类没有被析构时，UObject的对象的析构函数就被调用了，但是对象依然可以被使用。目前没有发现这种情况会导致什么样的后果，但是作为一个合格的UE程序还是应该尽量避免这种情况的发生，那么在一个自定义类中组合一个UObject对象，应该如何控制UObject对象的GC呢？\n\nUE4提供了一个叫做<font color=red>FGCObject</font>的类，位于<font color=red>GCObject.h</font>头文件中，我们需要使自定义类继承自FGCObject类，然后再实现AddReferencedObjects函数，并在函数中通过Collector.AddReferencedObject()函数将所有的UObject对象UE4自动管理即可。\n\n如：\n\n```c++\nclass INSIDEUE4_API FActor : FGCObject\n{\npublic:\n\tFActor();\n\t~FActor();\n\tUMyObject* obj;\n\n\tvirtual void AddReferencedObjects(FReferenceCollector& Collector) override\n\t{\n\t\tCollector.AddReferencedObject(obj);\n\t}\n};\n```\n\n然后，UObject对象就会在FActor对象析构时才被析构。\n\n## 2.序列化\n\n### FObjectWriter和FObjectReader序列化对象到文件和从文件读取\n\nFObjectWriter可以将对象数据序列化为二进制流，然后配合FFileHelper将流写入文件即可实现对象状态存储到文件。\n\n```c++\nvoid AOperatActor::SaveObject()\n{\n\tUSerializationObj* obj= NewObject<USerializationObj>();\n\tUE_LOG(LogTemp, Warning, TEXT(\"OldStr:%s\"), *obj->str);\n\tobj->str = TEXT(\"OperatActor\");\n\tTArray<uint8> bytes;\n\tFObjectWriter(obj, bytes);\t\n\tFFileHelper::SaveArrayToFile(bytes, *FString(\"D:\\\\Goulandis\\\\UE4\\\\MyProject\\\\obj.txt\"));\t\n}\n```\n\n配合FFileHelper将文件中的对象状态读入字节数组，FObjectReader就可以将字节数组中的对象状态写入新的对象中。\n\n```c++\nUSerializationObj* AOperatActor::LoadObject()\n{\n\tUSerializationObj* newObj = NewObject<USerializationObj>();\n\tTArray<uint8> bytes;\n\tFFileHelper::LoadFileToArray(bytes, *FString(\"D:\\\\Goulandis\\\\UE4\\\\MyProject\\\\obj.txt\"));\n\tFObjectReader reader(newObj, bytes);\n\tUE_LOG(LogTemp, Warning, TEXT(\"NewStr:%s\"), *newObj->str);\n\treturn newObj;\n}\n```\n\n看一下运行结果：\n\n![](https://img-blog.csdnimg.cn/20210512145024267.png#pic_center)\n\n可以看到，新创建的USerializationObj对象的状态是被修改过后的状态。\n\nActor的使用方式和UObject是一样的：\n\n```c++\nvoid AOperatActor::SaveActor()\n{\n\tASerializationActor* actor = GetWorld()->SpawnActor<ASerializationActor>();\n\tUE_LOG(LogTemp, Warning, TEXT(\"OldStr:%s\"), *actor->str);\n\tactor->str = TEXT(\"NewActor\");\n\tTArray<uint8> bytes;\n\tFObjectWriter(actor, bytes);\n\tFFileHelper::SaveArrayToFile(bytes, *FString(\"D:\\\\Goulandis\\\\UE4\\\\MyProject\\\\actor.txt\"));\n}\n```\n\n```c++\nASerializationActor * AOperatActor::LoadActor()\n{\n\tASerializationActor* actor = GetWorld()->SpawnActor<ASerializationActor>();\n\tTArray<uint8> bytes;\n\tFFileHelper::LoadFileToArray(bytes, *FString(\"D:\\\\Goulandis\\\\UE4\\\\MyProject\\\\actor.txt\"));\n\tFObjectReader reader(actor,bytes);\n\tUE_LOG(LogTemp, Warning, TEXT(\"NewStr:%s\"), *actor->str);\n\treturn actor;\n}\n```\n\n运行结果：\n\n![](https://img-blog.csdnimg.cn/20210512145820162.png#pic_center)\n\n## 3.反射\n\n### 搜索所有的Object\n\nC++本身的反射系统RTTI相当薄弱，所以UE在C++的基础上借助UObject自己实现了一套反射系统，同时借鉴了C#的长处提供了一系列反射用的系统函数。\n\n```c++\nTArray<UObject*> result;\nGetObjectsOfClass(UClass::StaticClass(), result);   //获取所有的class和interface\nGetObjectsOfClass(UEnum::StaticClass(), result);   //获取所有的enum\nGetObjectsOfClass(UScriptStruct::StaticClass(), result);   //获取所有的struct\n```\n\n\n\n### 运行时创建对象\n\n```c++\nvoid AOperatActor::FindSerializationObj()\n{\n\tUClass* uclass = FindObject<UClass>(ANY_PACKAGE, TEXT(\"SerializationObj\"));\n\tUSerializationObj* obj = Cast<USerializationObj>(uclass->GetDefaultObject());\n\tobj->PrintStr();\n}\n```\n\nUE4提供FindObject模板函数来搜索指定的类的类型信息，返回的类型元素据通过UClass类型对象存储，UClass对象就是UE4专门用来存储元数据的类型，UClass中提供了大量的方法来操作元数据，[UClass](https://docs.unrealengine.com/en-US/API/Runtime/CoreUObject/UObject/UClass/index.html)，这里使用GetDefaultObject函数调用默认的构造函数创建SerializationObj类型的对象，需要注意的是GetDefaultObject返回的是一个UObject对象，所以需要使用Cast来做类型转换。\n\n热加载\n\n","source":"_posts/【UE4】UE4GamePlay架构.md","raw":"---\ntitle: 【UE4】GamePlay架构\ndate: 2021-02-26 09:37:18\ntags: UE4\ncategories: 学习笔记\npassword:\nabstract:\nmessage:\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n参考博客：[UE4官方文档](https://docs.unrealengine.com/en-US/index.html)、[大钊](https://zhuanlan.zhihu.com/p/22813908)、[南京周润发](https://zhuanlan.zhihu.com/p/67055774)、[带带大师兄](https://blog.csdn.net/qq_29523119/article/details/84981218)\n\n# 一、整体框架\n\n首先来看一下整体框架：\n<!--more-->\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210226143303.png)\n\n\n\n<font color=red> 红色部分为主体，从右往左为组合关系，至上而下为派生关系。</font>\n\n在整个UE宇宙的构成中，UEngine就类似化学元素，UObject就类似物质，物质通过演化便衍生出了物体—AActor和UActorComponent，AActor继续演化就出现了生物APawn，人—ACharacter，于是世界便有了信息—AInfo，规则—AGameMode，大量的物体、生物组合在一起便形成了大陆—ULevel，不同的大陆组合在一起便形成了世界—UWorld，世界有着自己的信息—FWorldContext和客观规律—UGameInstance。\n\n而在UE这个宇宙有很多个Word，如编辑时的World，编辑时运行的World，运行时的World等等，查看源码就可知道UE宇宙有五大世界。\n\n```c++\nnamespace EWorldType\n{\n\tenum Type\n\t{\n\t\tNone,\t\t// An untyped world, in most cases this will be the vestigial worlds of streamed in sub-levels\n\t\tGame,\t\t// The game world\n\t\tEditor,\t\t// A world being edited in the editor\n\t\tPIE,\t\t// A Play In Editor world\n\t\tPreview,\t// A preview world for an editor tool\n\t\tInactive\t// An editor world that was loaded but not currently being edited in the level editor\n\t};\n}\n```\n\n首先我们先了解一下这些类的具体作用，然后再细致的了解各个类。\n\n## 1.UEngine\n\nUEngine类是UE的基础，UEngine提供一些最底层的交互—与操作系统的交互，而根据不同的运行模式UE与操作系统的交互模式又有少许不同，所以UEngine又派生出了UGameEngine和UEditerEngine来负责不同运行模式下的交互模式。\n\n其中有一个很重要的全局指针GEngine，通过GEngine可以访问各种UE的全局资源，同时GEngine还提供多线程访问能力。\n\n关于UEngine的资料实在是太少了，官方文档中对UEngine的描述也就一句话，对UEngine的理解也就止步于此了。\n\n## 2.UObject\n\nUObject是构成UE世界最基础的物质，所以UObject提供供UE世界运行的最基本的功能：\n\n- Garbage collection：垃圾收集\n- Reference updating：引用自动更新\n- Reflection：反射\n- Serialization：序列化\n- Automatic updating of default property changes：自动检测默认变量的更改\n- Automatic property initialization：自动变量初始化\n- Automatic editor integration：和虚幻引擎编辑器的自动交互\n- Type information available at runtime：运行时类型识别\n- Network replication：网络复制\n\n在之后再深入浅出的讲解各个功能。\n\n## 3.AActor\n\nAActor是派生自UObject的一个及其重要的类，AActor在UObject的基础上再进一步提供了：\n\n- Replication：网络复制\n- Spawn：动态创建\n- Tick：每帧运行\n\nReplicatoin使AActor有了分裂复制的生育能力，Spawn使AActor在UE世界中出生，在UE4世界中死去，Tick使AActor有了心跳，AActor便组成了丰富多彩的UE世界。\n\nAActor拥有一个庞大的子孙族群，ALevelScriptActor、ANavigationObjectBase、APawn、AController、AInfo这些都是AActor的直系后代，而这些后代也都各自拥有自己的庞大分支族群，构成了UE世界中最强大的种族AActor。\n\n### ALevelScriptActor\n\nALevelScriptActor在官方文档中的表述就是ULevelScriptBlueprint生成的类的基类，通过名称我们就很容易联想到关卡蓝图，没错ULevelScriptBlueprint就是我们最常用的关卡蓝图，ULevelScriptBlueprint继承自UObject，所以ULevelScriptBlueprint的子类是一个多继承的虚继承类，而ALevelScriptActor就为其提供AActor的能力。\n\n在官方文档中有提及默认关卡蓝图是可以通过DefualtGame.ini配置文件替换成自定义关卡蓝图的，具体使用方法在后面在探讨。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210309211442.png)\n\n### ANavigationObjectBase\n\nANavigationObjectBase的资料实在是少的可怜，就连官方文档也是没有一个字的描述，源码也是相当简单，总共就70行，由ANavigationObjectBase是APlayerState的基类，和它继承的接口INavAgentInterface可以猜测ANavigationObjectBase应该和网络复制有关，具体细节留到以后更熟悉UE4了再深入探讨吧。\n\n### APlayerStart\n\nAPlayerStart的作用就是记录APawn在游戏开始时生成的Position与Rotation信息，UE设计APlayerStart的初忠就是想让游戏的关卡设十师和场景设计师的工作分离开来，也就解耦合。那么，如果Level中不存在APlayerStart ，APawn 会出生在哪是呢？答案是世界原点(0，0，0)\n\n\n### APawn\n\nAPawn在AActor的基础上再度添加了：\n\n- 被Controller控制\n- PhysicsCollision：物理碰撞\n- MovementInput：移动响应接口\n\n等能力，有了MovementInput接口APawn就拥有了可运动的能力，这里UE的逻辑划分十分精妙，UE将一个可运动的物体巧妙地划分成了APwan和AController，APawn重点表现在物体，而这个物体具备运动能力，但是自身不具备运动技巧；而AController这是控制APawn运动地大脑，用来控制APawn如何运动，如果把APawn比作是提线木偶，那么AController就是控制木偶运动地线。\n\n到了APawn这一代，AActor的衍化之旅开始衍化出现于玩家间交互的能力，而这之中的佼佼者便是ACharacter。\n\n### ACharacter\n\nACharacter是APwan的特化加强版，在UE世界中可以称之为“人”，ACharacter是一个专门为人形角色定制的APawn，自带CharacterMovement组件，可以使人形角色像人一样行走。\n\n### ADefaultPawn\n\n最初始的APawn使最基本的APawn类，只提供APawn的一些基本能力，而没有提供支持这些能力的组件，而在具体实际使用情况中我们使用的APawn应该还需要组合一些其他的能力，以适应不同的场景，如：我们知道APawn可以运动，但在实际场景中我们是要确定这个APawn是因该直立行走还是爬行，是用轮子行驶还是用翅膀飞行，APawn在玩家眼里应该长什么样子，是人还是蛇，是因该左球形碰撞还是应该做方形碰撞，这些都是APawn不具备的能力，这时ADefaultPawn便出现了，ADefaultPawn自带DefualtPawnMovement、CollisionComponent、StaticMeshCompnent三件套，为ADefaultPawn提供了默认的场景表现。\n\n### ASpectatorPawn\n\n在游戏中存在一种特殊的玩家—观战玩家，这类玩家不需要具体表现形式，只需要一些相机的漫游能力，于是ASpectatorPawn出现了，ASpectatorPawn继承自ADefaultPawn，ASpectatorPawn提供了一个基本的USpectatorPawnMovement（不带重力漫游），并关闭了StaticMesh的显示，碰撞也设置到了“Spectator”通道。\n\n### AController\n\nAController就是控制APawn运动的大脑了，ACtroller负责处理一些直接与玩家交互的控制逻辑，AController是从AActor派生的与APawn同级的子类，在UE的设计中，在同一时刻一个AController和一个APawn之间是1:1的关系，AController可以在多个APawn之间通过Possess/UnPossess切换。AController有两种控制APawn的方式，一种是AController直接附在APawn的身上控制APawn的移动，如驾驶汽车，一种是以上帝的视角控制APawn的移动，如控制第三人称的角色。\n\n### APlayerController\n\nAPlayerController是由AController派生出来专门用于负责玩家交互逻辑的AController，APlayerController提供了：\n\n- Camera管理\n- Input输入响应\n- UPlayer关联\n- HUD显示\n- Level切换\n- Voice音源监听\n\n这些能力。\n\n### AAIController\n\n在一个游戏中有玩家控制的角色也可以有NPC，那么NPC的行动逻辑有谁来控制呢？答案就是AAIController，AAIController与APlayerController完全不同，因为一个NPC不要管理Camera，不需要响应玩家的输入，不需要关联UPlayer，不需要显示HUD，不需要监听音源，只有Level切换可能会在少数情况下需要，那么AAIController因该做什么呢？UE为它设计的是这些事：\n\n- Navigation：自动寻路\n- AI Component：用于启动运行行为树，使用黑板数据\n- Task系统：让AI去完成一些任务\n\n当然一个游戏中是至少需要一个APlayerController的，但是可以没有AAIController。\n\n### AInfo\n\nAInfo是一些数据保存类的基类，AInfo不需要运动和碰撞，也不需要物理表现，仅仅只是保存数据，所以UE在AInfo中将这些功能都隐藏了，之所以不直接继承自UObject，而继承自AActor是因为游戏数据是需要具备网络复制的能力的，而UObject不具备这个能力\n\n### AWordSetting\n\nAWordSetting继承自AInfo用来配置和保存一些Level配置，主要用于配置Level的GameMode信息，光照信息，导航系统，声音系统，LOD系统，物理加速度等关卡信息。由此可以知道一个Level对应一个AWordSetting，但是一个AWordSetting可以应用在多个Level上。\n\n### AGameMode\n\nAGameMode就是用于配置AWorldSetting中的GameMode属性的。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210310162744.png)\n\n在UE的设计中AGameMode就是游戏世界的逻辑，及整个游戏的玩法规则，而在实际情况中一个游戏既可以只有一个玩法也可以有多种玩法规则，所以AWordSetting与AGameMode的对应关系也是一个AWorldSetting只能对应一个AGameMode，而一个AGameMode可以对应多个AWorldSetting。那么AGameMode应该负责哪些逻辑呢？UE是这么规定的：\n\n- Class登记：记录GameMode中各种类的信息\n- Spawn：创建Pawn和PlayerController等\n- 游戏进度：游戏暂停重启的逻辑\n- 过场动画逻辑\n- 多人游戏的步调同步\n\n\n### AGameState\n\nAGameState用于保存游戏数据，如任务进度，游戏活动等。\n\n### APlayerState\n\nAPlayerState是一个用于存储玩家状态的类，在一个游戏客户端，尤其是网络游戏客户端中是可以存在多个APlayerState对象的，不同的APlayerState保存不同玩家的状态，同时APlayerState也可以存在于服务器中。APlayerState的生命周期为一整个Level的生命周期。\n\n到这是AActor家族下的几个重要成员的基本功能我们便有了一个大概的了解了，这里我们来捋一下这些成员之间的关系和在UE世界中的地位。\n![Alt](https://i.loli.net/2021/03/10/3Ccrl7uNo4QRbUK.jpg)\n\n## 4.UActorComponent\n\nUActorComponent是UE向U3D看齐的一个产物，虽然UE世界有了Actor就有了形形色色的物体生物，但是不同的生物拥有不同的技能，而同一个Actor可以会某个技能也可以不会，这种概念使用组合的方式组合到Actor下是最理想的，于是Component便出现了，UActorComponent直接继承自UObject，与AActor同级，Component既可以嵌套在Actor下，也可以嵌套在其他的Component下，但是需要注意的是，UActorComponent这一级是不提供互相嵌套的能力的，只有到其子类USceneComponent一级才提供互相嵌套能力。\n\n### USceneComponent\n\nUSceneComponent主要提供两大能力，一是Transform，二是SceneComponent的互相嵌套。一般我们直接在Level里创建的Actor都会默认带有一个SceneComponent组件。\n\n### UPrimitiveComponent\n\nUPrimitiveComponent主要提供Actor用于物体渲染和碰撞相关的基础能力。\n\n### UMeshComponent\n\nUMeshComponent由UPrimitiveComponent派生而来，主要提供具体的渲染显示方面的能力。\n\n### UChildActorComponent\n\n从名字就可以窥探其功能一二了，UChildComponent在Actor中主要用于链接Actor与Component，提供Component和Actor的嵌套能力。\n\n## 5.ULevel\n\nULevel可以看作是UE世界的大陆，是AActor的容器，前面提到的ALevelScriptActor便是ULevel默认带有的关卡蓝图，在这个关卡蓝图中编写便是这块大陆的逻辑，同事ULevel也默认带有一个AWorldSetting。\n\n## 6.UWorld\n\n在UE中所有的ULevel互相联系就构成了一个UWorld，ULevel构建UWorld的方式有两种，一种是以SubLevel的形式，像关卡流一样，一个关卡链接下一个关卡，来组成UWorld，一种是每一个ULevel就是这个大地图的UWorld中的一块地图，ULevel之间以相对位置衔接在一起，构成一个大地图来组成这个UWorld。无论是那种构成形式，在一个UWorld中都有一个PersistentLevel，PersistenetLevel就是主Level，是玩家最初始的出生地，这里用的是最初始而不是游戏开始，是因为，现在很多在游戏开始时玩家的出点可能不是PersistentLevel而是上一次玩家离线时的位置。\n\n## 7.FWorldContext\n\nFWorldContext不对开发者公开，是UE内部用来处理引擎UWorld上下文的类，比如当我们从编辑状态的EditorWorld点击播放切换到PIEWorld即运行状态时，这个过程中EditorWorld到PIEWorld之间的信息交换就是通过FWorldContext实现的。可以说FWorldContext处理的是UWorld级的通信。\n\n## 8.UGameInstance\n\nUGameInstance可以说是凌驾于所有AActor、UActorComponent、ULevel、UWorld之上的类，通常情况下一个Game中应该只有一个，这里的Gam是UEngine中提到的所有World的总和，当然这不是绝对的，对于更高层次的开发者，UE也是提供了多个UGameInstance协同的扩展的。\n\n所以UGameInstance主要处理：\n\n- UWorld、ULevel之间的切换\n- UPlayer的创建，这里的UPlayer又和前面的APlayerController有所不同，这一点在后面再介绍。\n- 全局配置\n- GameMode的切换\n\n## 9.UNetDriver\n\n从名字就可以略知一二，UNetDriver是UE处理网络同步相关的类，UNetDriver中有两个主要的成员：\n\n```c++\nclass UNetConnection* ServerConnection;\nTArray<class UNetConnection*> ClientConnections;\n```\n\nServerConnection是客户端到服务器的连接，ClientConnections数组是服务器到客户端群的连接的数组。而在UNetConnnection中又有一个很重要的成员：\n\n```c++\nTMap<TWeakObjectPtr<AActor>,class UActorChannel*> ActorChannels\n```\n\nActorChannels是在服务器与客户端完成连接后用于实现Actor同步的对象。\n\n## 10.UPlayer\n\nUPlayer即玩家，ULevel可以切换，UWorld可以交替，但是尽管ULevel、UWorld如何变换，玩家还是那个玩家，所以UPlayer是和UGameInstance同一级别的存在，那么，UPlayer、AController、APawn之间到底是什么关系呢?\n\nUE源码对UPlayer是这么解释：\n\n```\nPlayer: Corresponds to a real player (a local camera or remote net player).\n```\n\n很显然，UE对UPlayer的定位就是与玩家交互的类，即UPlayer是直接与底层硬件输入相关的类，如处理鼠标键盘的输入或游戏手柄的输入，当然游戏与人之间的交互也不仅限于这两种，还有VR设备的交互，语音交互，重力感应等等，谁也不知道未来还会有什么样的游戏交互出现，所以UE并没有把UPlayer隐藏起来，开发者依然可以创建自己的UPlayer。而然在大多数情况下，我们是不需要直接操作UPlayer的，因为一些常规的底层交互UE已经封装好了。\n\n所以UPlayer是处理底层输入的，而AController则是直接对接UPlayer，通过接收UPlayer的输入来处理对APawn的控制逻辑，最后APawn更具AController的控制逻辑做出响应的行为，于是玩家到角色的交互过程便实现了。\n\n### ULocalPlayer\n\n在一个单机游戏中UPlayer是唯一的存在，但是在一个网络联级游戏中，表示同一实体的UPlayer即存在于玩家本地的客户端中，同时也存在于其他玩家的多个客户端中，那么玩家的输入就既要作用于本地的APawn上，同时在其他玩家的客户端中的表示这个实体的APawn也要做出响应的反应，于是UE便将UPlayer又派生出了两个子类，ULocalPlayer和UNetConnection。其中ULocalPlayer就是处理本地客户端的输入逻辑的类。\n\n### UNetConnection\n\nUNetConnection就是处理其他玩家在本地客户端中的APawn的类，所以UNetConnection也是一个玩家。\n\n## 11.USaveGame\n\n前面提到了AGameState是一个保存游戏数据的类，这个保存是一个临时保存，所以当游戏程序关闭之后AGameState中数据也就不存在了，而USaveGame就是用来保存存档的类，USaveGame提供游戏数据永久性保存，我们只需要往USaveGame中添加我们要保存的属性字段，就可以直接调用USaveGame的接口直接将游戏数据序列化保存到本地文件中，相当的方便。\n\n花了这么长的篇幅也就简要的介绍了一下GamePlay的整体框架，总共由这11个类组成，说起来不多，但是里面的门道却是相当深奥，这需要在以后的使用中慢慢学习消化。\n\n那么接下来就开始各个类的详细使用学习了。\n\n# 二、UObject\n\n首先我们来看UObject提供的功能：\n\n- Garbage collection：垃圾收集\n- Reference updating：引用自动更新\n- Reflection：反射\n- Serialization：序列化\n- Automatic updating of default property changes：自动检测默认变量的更改\n- Automatic property initialization：自动变量初始化\n- Automatic editor integration：和虚幻引擎编辑器的自动交互\n- Type information available at runtime：运行时类型识别\n- Network replication：网络复制\n\n## 1.垃圾回收\n\n首先我们来研究研究UE4是如何进行垃圾回收的。\n\n这里推荐两位大佬的博客：[带带大师兄](https://zhuanlan.zhihu.com/p/67055774)、[南京周润发](https://blog.csdn.net/qq_29523119/article/details/84981218)\n\n可以配合着看。\n\n由于C++不提供GC功能，所有UE自己实现了一套GC功能，使用的也是最经典的`标记-清理`垃圾回收方式。\n\n### GC的过程\n\nUEGC分为来两个阶段，第一个阶段UE从根集合开始遍历，遍历所有可达对象，于是UE就知道了哪些对象还在被引用，哪些对象已经不可被引用了。第二阶段UE会逐步的清理这些不可达对象，形式为分帧分批清理，为什么要这么做呢？想想我们卸载一次性Level时的感受就知道了，分批处理可以保证我们在使用UE时的顺滑而不卡顿。\n\nUEGC的主要函数是在UObjectGlobals.h头文件中CollectGarbage函数\n\n```c++\nvoid CollectGarbage(EObjectFlags KeepFlags, bool bPerformFullPurge)\n{\n\t// No other thread may be performing UObject operations while we're running\n\tAcquireGCLock();\n\n\t// Perform actual garbage collection\n\tCollectGarbageInternal(KeepFlags, bPerformFullPurge);\n\n\t// Other threads are free to use UObjects\n\tReleaseGCLock();\n}\n```\n\n可以看到GC的整体流程很自然的划分成了三个阶段，获取GC锁、执行CollectGarbageInternal和释放GC锁。使用锁的原因是UEGC是多线程的，为了防止在GC的过程中对象被其他线程访问，以保证异步加载的稳定。而CollectGarbageInternal函数则进行垃圾回收和对象标记与清理，两个参数KeepFlags表示这些被标记的对象无论是否被引用都将被保留，bPerformFullPurge表示GC时进行全清理还是分帧分批清理。\n\n那么GC又是如何进行对象标记的呢？还是看源码\n\n```c++\n/** \n * Deletes all unreferenced objects, keeping objects that have any of the passed in KeepFlags set\n *\n * @param\tKeepFlags\t\t\tobjects with those flags will be kept regardless of being referenced or not\n * @param\tbPerformFullPurge\tif true, perform a full purge after the mark pass\n */\nvoid CollectGarbageInternal(EObjectFlags KeepFlags, bool bPerformFullPurge)\n{\n\tSCOPE_TIME_GUARD(TEXT(\"Collect Garbage\"));\n\tSCOPED_NAMED_EVENT(CollectGarbageInternal, FColor::Red);\n\tCSV_EVENT_GLOBAL(TEXT(\"GC\"));\n\tCSV_SCOPED_TIMING_STAT_EXCLUSIVE(GarbageCollection);\n\n\tFGCCSyncObject::Get().ResetGCIsWaiting();\n\n#if defined(WITH_CODE_GUARD_HANDLER) && WITH_CODE_GUARD_HANDLER\n\tvoid CheckImageIntegrityAtRuntime();\n\tCheckImageIntegrityAtRuntime();\n#endif\n\n\tDECLARE_SCOPE_CYCLE_COUNTER( TEXT( \"CollectGarbageInternal\" ), STAT_CollectGarbageInternal, STATGROUP_GC );\n\tSTAT_ADD_CUSTOMMESSAGE_NAME( STAT_NamedMarker, TEXT( \"GarbageCollection - Begin\" ) );\n\n\t// We can't collect garbage while there's a load in progress. E.g. one potential issue is Import.XObject\n\tcheck(!IsLoading());\n\n\t// Reset GC skip counter\n\tGNumAttemptsSinceLastGC = 0;\n\n\t// Flush streaming before GC if requested\n\tif (GFlushStreamingOnGC)\n\t{\n\t\tif (IsAsyncLoading())\n\t\t{\n\t\t\tUE_LOG(LogGarbage, Log, TEXT(\"CollectGarbageInternal() is flushing async loading\"));\n\t\t}\n\t\tFGCCSyncObject::Get().GCUnlock();\n\t\tFlushAsyncLoading();\n\t\tFGCCSyncObject::Get().GCLock();\n\t}\n\n\t// Route callbacks so we can ensure that we are e.g. not in the middle of loading something by flushing\n\t// the async loading, etc...\n\tFCoreUObjectDelegates::GetPreGarbageCollectDelegate().Broadcast();\n\tGLastGCFrame = GFrameCounter;\n\n\t{\n\t\t// Set 'I'm garbage collecting' flag - might be checked inside various functions.\n\t\t// This has to be unlocked before we call post GC callbacks\n\t\tFGCScopeLock GCLock;\n\n\t\tUE_LOG(LogGarbage, Log, TEXT(\"Collecting garbage%s\"), IsAsyncLoading() ? TEXT(\" while async loading\") : TEXT(\"\"));\n\n\t\t// Make sure previous incremental purge has finished or we do a full purge pass in case we haven't kicked one\n\t\t// off yet since the last call to garbage collection.\n\t\tif (GObjIncrementalPurgeIsInProgress || GObjPurgeIsRequired)\n\t\t{\n\t\t\tIncrementalPurgeGarbage(false);\n\t\t\tFMemory::Trim();\n\t\t}\n\t\tcheck(!GObjIncrementalPurgeIsInProgress);\n\t\tcheck(!GObjPurgeIsRequired);\n\n#if VERIFY_DISREGARD_GC_ASSUMPTIONS\n\t\t// Only verify assumptions if option is enabled. This avoids false positives in the Editor or commandlets.\n\t\tif ((GUObjectArray.DisregardForGCEnabled() || GUObjectClusters.GetNumAllocatedClusters()) && GShouldVerifyGCAssumptions)\n\t\t{\n\t\t\tDECLARE_SCOPE_CYCLE_COUNTER(TEXT(\"CollectGarbageInternal.VerifyGCAssumptions\"), STAT_CollectGarbageInternal_VerifyGCAssumptions, STATGROUP_GC);\n\t\t\tconst double StartTime = FPlatformTime::Seconds();\n\t\t\tVerifyGCAssumptions();\n\t\t\tVerifyClustersAssumptions();\n\t\t\tUE_LOG(LogGarbage, Log, TEXT(\"%f ms for Verify GC Assumptions\"), (FPlatformTime::Seconds() - StartTime) * 1000);\n\t\t}\n#endif\n\n\t\t// Fall back to single threaded GC if processor count is 1 or parallel GC is disabled\n\t\t// or detailed per class gc stats are enabled (not thread safe)\n\t\t// Temporarily forcing single-threaded GC in the editor until Modify() can be safely removed from HandleObjectReference.\n\t\tconst bool bForceSingleThreadedGC = !FApp::ShouldUseThreadingForPerformance() || !FPlatformProcess::SupportsMultithreading() ||\n#if PLATFORM_SUPPORTS_MULTITHREADED_GC\n\t\t(FPlatformMisc::NumberOfCores() < 2 || GAllowParallelGC == 0 || PERF_DETAILED_PER_CLASS_GC_STATS);\n#else\t//PLATFORM_SUPPORTS_MULTITHREADED_GC\n\t\t\ttrue;\n#endif\t//PLATFORM_SUPPORTS_MULTITHREADED_GC\n\n\t\t// Perform reachability analysis.\n\t\t{\n\t\t\tconst double StartTime = FPlatformTime::Seconds();\n\t\t\tFRealtimeGC TagUsedRealtimeGC;\n            //-----------------------------------------------------------\n\t\t\tTagUsedRealtimeGC.PerformReachabilityAnalysis(KeepFlags, bForceSingleThreadedGC);\n            //-----------------------------------------------------------\n\t\t\tUE_LOG(LogGarbage, Log, TEXT(\"%f ms for GC\"), (FPlatformTime::Seconds() - StartTime) * 1000);\n\t\t}\n\n\t\t// Reconstruct clusters if needed\n\t\tif (GUObjectClusters.ClustersNeedDissolving())\n\t\t{\n\t\t\tconst double StartTime = FPlatformTime::Seconds();\n\t\t\tGUObjectClusters.DissolveClusters();\n\t\t\tUE_LOG(LogGarbage, Log, TEXT(\"%f ms for dissolving GC clusters\"), (FPlatformTime::Seconds() - StartTime) * 1000);\n\t\t}\n\n\t\t// Fire post-reachability analysis hooks\n\t\tFCoreUObjectDelegates::PostReachabilityAnalysis.Broadcast();\n\t\t\n\t\t{\n\t\t\tFGCArrayPool::Get().ClearWeakReferences(bPerformFullPurge);\n\n\t\t\tGatherUnreachableObjects(bForceSingleThreadedGC);\n\n\t\t\tif (bPerformFullPurge || !GIncrementalBeginDestroyEnabled)\n\t\t\t{\n\t\t\t\tUnhashUnreachableObjects(/**bUseTimeLimit = */ false);\n\t\t\t\tFScopedCBDProfile::DumpProfile();\n\t\t\t}\n\t\t}\n\n\t\t// Set flag to indicate that we are relying on a purge to be performed.\n\t\tGObjPurgeIsRequired = true;\n\t\t// Reset purged count.\n\t\tGPurgedObjectCountSinceLastMarkPhase = 0;\n\t\tGObjCurrentPurgeObjectIndexResetPastPermanent = true;\n\n\t\t// Perform a full purge by not using a time limit for the incremental purge. The Editor always does a full purge.\n\t\tif (bPerformFullPurge || GIsEditor)\n\t\t{\n\t\t\tIncrementalPurgeGarbage(false);\n\t\t}\n\n\t\tif (bPerformFullPurge)\n\t\t{\n\t\t\tShrinkUObjectHashTables();\n\t\t}\n\n\t\t// Destroy all pending delete linkers\n\t\tDeleteLoaders();\n\n\t\t// Trim allocator memory\n\t\tFMemory::Trim();\n\t}\n\n\t// Route callbacks to verify GC assumptions\n\tFCoreUObjectDelegates::GetPostGarbageCollect().Broadcast();\n\n\tSTAT_ADD_CUSTOMMESSAGE_NAME( STAT_NamedMarker, TEXT( \"GarbageCollection - End\" ) );\n}\n\n```\n\n我在PerformReachabilityAnalysis函数处做了标记，GC时UE就是通过这个函数进行对象标记的，PerformReachabilityAnalysis函数会做多线程实时的分析对象的引用关系，然后标记出可达与不可达对象。标记是如何进行的还得深入到PerformReachabilityAnalysis函数，再上源码\n\n```c++\n/**\n\t * Performs reachability analysis.\n\t *\n\t * @param KeepFlags\t\tObjects with these flags will be kept regardless of being referenced or not\n\t */\n\tvoid PerformReachabilityAnalysis(EObjectFlags KeepFlags, bool bForceSingleThreaded = false)\n\t{\n\t\tLLM_SCOPE(ELLMTag::GC);\n\n\t\tSCOPED_NAMED_EVENT(FRealtimeGC_PerformReachabilityAnalysis, FColor::Red);\n\t\tDECLARE_SCOPE_CYCLE_COUNTER(TEXT(\"FRealtimeGC::PerformReachabilityAnalysis\"), STAT_FArchiveRealtimeGC_PerformReachabilityAnalysis, STATGROUP_GC);\n\n\t\t/** Growing array of objects that require serialization */\n\t\tFGCArrayStruct* ArrayStruct = FGCArrayPool::Get().GetArrayStructFromPool();\n\t\tTArray<UObject*>& ObjectsToSerialize = ArrayStruct->ObjectsToSerialize;\n\n\t\t// Reset object count.\n\t\tGObjectCountDuringLastMarkPhase.Reset();\n\n\t\t// Make sure GC referencer object is checked for references to other objects even if it resides in permanent object pool\n\t\tif (FPlatformProperties::RequiresCookedData() && FGCObject::GGCObjectReferencer && GUObjectArray.IsDisregardForGC(FGCObject::GGCObjectReferencer))\n\t\t{\n\t\t\tObjectsToSerialize.Add(FGCObject::GGCObjectReferencer);\n\t\t}\n\n\t\t{\n\t\t\tconst double StartTime = FPlatformTime::Seconds();\n\t\t\tMarkObjectsAsUnreachable(ObjectsToSerialize, KeepFlags, bForceSingleThreaded);\n\t\t\tUE_LOG(LogGarbage, Verbose, TEXT(\"%f ms for Mark Phase (%d Objects To Serialize\"), (FPlatformTime::Seconds() - StartTime) * 1000, ObjectsToSerialize.Num());\n\t\t}\n\n\t\t{\n\t\t\tconst double StartTime = FPlatformTime::Seconds();\n\t\t\tPerformReachabilityAnalysisOnObjects(ArrayStruct, bForceSingleThreaded);\n\t\t\tUE_LOG(LogGarbage, Verbose, TEXT(\"%f ms for Reachability Analysis\"), (FPlatformTime::Seconds() - StartTime) * 1000);\n\t\t}\n        \n\t\t// Allowing external systems to add object roots. This can't be done through AddReferencedObjects\n\t\t// because it may require tracing objects (via FGarbageCollectionTracer) multiple times\n\t\tFCoreUObjectDelegates::TraceExternalRootsForReachabilityAnalysis.Broadcast(*this, KeepFlags, bForceSingleThreaded);\n\n\t\tFGCArrayPool::Get().ReturnToPool(ArrayStruct);\n\n#if UE_BUILD_DEBUG\n\t\tFGCArrayPool::Get().CheckLeaks();\n#endif\n\t}\n```\n\n首先前面的宏暂时可以忽略掉，\n\n第一步，`FGCArrayStruct* ArrayStruct = FGCArrayPool::Get().GetArrayStructFromPool();`UE将UObject的所有的强引用和弱引用都存储大ArrayStruct数据结构中，FGCArrayPool是UEGC的主要执行类\n\n第二步，`TArray<UObject*>& ObjectsToSerialize = ArrayStruct->ObjectsToSerialize;`分离UObject的强引用到ObjectsToSerialize 数组中。\n\n这是FGCArrayStruct结构体的源码：\n\n```c++\nstruct FGCArrayStruct\n{\n\tTArray<UObject*> ObjectsToSerialize;\n\tTArray<UObject**> WeakReferences;\n};\n```\n\nObjectsToSerialize存储强引用，WeakReferences存储弱引用。\n\n第三步，`GObjectCountDuringLastMarkPhase.Reset();`重置对象的引用计数。\n\n第四步，通过一个if判断标记可达对象，于是可达对象与不可达对象就被标记出来了，接下来便是GC清理。\n\n### GC的触发\n\nUE的GC发生在游戏线程上，支持多线程GC，和大多数主流语言的GC一样支持自动触发和手动触发。\n\n**手动触发**\n\n手动触发UE也提供了两种方式，其一是通过C++函数：\n\n```c++\nGEngine->ForceGarbageCollection();\n```\n\n这里需要注意的是`GEngine`在`Engine.h`头文件下。\n\n手动触发的使用场景一般是在卸载某些资源后，手动触发GC回收这些资源在使用过程中的无用对象。\n\n其二是蓝图节点：\n\n![](D:\\Git\\Hexo\\source\\_posts\\【UE4】UE4GamePlay架构\\Snipaste_2021-03-19_21-54-55.png)\n\n手动调用这两个函数，UE会跳过GC算法，在下一次Tick时直接进行GC。\n\n<font color=red> 这里有一点需要注意，在大多数情况下，手动GC一般只能回收NewObject函数创建的对象，而UWorld()->SpawnActor函数创建的对象无论如何调用都无法销毁，这是因为，当UE创建一个Actor之后在UWorld中就已经保存了这个Actor的引用，所以无论我们如何释放Actor的引用，这个Actor的引用计数都不会归零，所以要销毁一个Actor还是需要通过Actor->Destroy()函数。</font>\n\n我们可以个一个例子：\n\n```c++\n//AACtor.cpp\nAActor1::AActor1()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tUE_LOG(LogTemp, Warning, TEXT(\"Actor1 Created\"));\n}\n\nAActor1::~AActor1()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"Actor1 Destryed\"));\n}\n```\n\n```c++\n//AMyActor.h\nUCLASS()\nclass INSIDEUE4_API AMyActor2 : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAMyActor2();\n\tAActor1 *a;//注意这里没有加UPROPERTY()宏\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n};\n```\n\n```c++\n//AMyActor2\nAMyActor2::AMyActor2()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyActor2::BeginPlay()\n{\n\tSuper::BeginPlay();\n\ta = UWorld()->SpawnActor<AActor1>();\n\ta = NULL;\n\tGEngine->ForceGarbageCollection();\n}\n\nvoid AMyActor2::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```\n\nOutputLog:\n\n```\nLogTemp: Warning: Actor1 Created\n```\n\n可以看到使用UWorld()->SpawnActor创建的Actor即使手动强制GC也没有被回收，因为这个Actor是可达对象。\n\n**自动触发**\n\n要想UE自动触发的GC能能够回收我们创建的对象，那么我们创建的对象就必须继承自UObject，至于加不加UPROPERTY()宏似乎不影响GC的回收，如下面的测试结果，还是以上面的例子为例，把BeginPlay函数改为如下：\n\n```c++\n//AMyActor2\nAMyActor2::AMyActor2()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyActor2::BeginPlay()\n{\n\tSuper::BeginPlay();\n\ta = NewObject<AActor1>();\n\ta = NULL;\n\tGEngine->ForceGarbageCollection();\n}\n\nvoid AMyActor2::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```\n\n我们将MyActor2拖入场景中，运行，OutputLog输出，可以找到下面两句：\n\n```c++\nLogTemp: Warning: Actor1 Created\n\nLogTemp: Warning: Actor1 Destryed\n```\n\n可以看到，没有使用UPROPERTY()宏的变量a依旧在手动GC时被回收了，这里为了效果明显点使用了手动强制回收，其实使用自动GC也是一样的。\n\n<font color=green>这里有提个疑问：</font>\n\n当我们在一个继承自UObject的类组合一个继承自UObject的对象，如果在这个对象定义前没有使用UPROPERTY()宏，那么在Play后UE会调用一次这个对象的析构函数，但是这个对象依然可以被使用，而如果在定义这个对象前使用了UPROPERTY()宏，那么这对象将和组合类被析构时一起被析构。疑问为什么UE会调用一次被组合对象的析构且析构后依然可以使用这个对象。如：\n\n```c++\n//UMyObject.cpp\nUMyObject::UMyObject()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"UMyObject Created\"));\n}\n\nUMyObject::~UMyObject()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"UMyObject Destoryed\"));\n}\n\nvoid UMyObject::Fun()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"UMyObject\"));\n}\n```\n\n```c++\n//AMyActor2.h\nUCLASS()\nclass INSIDEUE4_API AMyActor2 : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAMyActor2();\n\tUPROPERTY()\n\tUMyObject* obj;\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n};\n```\n\n```c++\n//AMyActor2.cpp\nvoid AMyActor2::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tobj = NewObject<UMyObject>();\n}\n```\n\n使用UPROPERTY()宏的输出结果：\n\n```c++\n//在点击Play后输出结果\nLogTemp: Warning: AMyActor2 Created\nLogTemp: Warning: UMyObject Created\n//再点击Stop后输出结果\nLogTemp: Warning: UMyObject Destoryed\nLogTemp: Warning: AMyActor2 Destroyed\n```\n\n不使用UPROPERTY()宏的输出结果：\n\n```c++\n//在点击Play后输出结果\nLogTemp: Warning: AMyActor2 Created\nLogTemp: Warning: UMyObject Created\nLogTemp: Warning: UMyObject Destoryed\n//再点击Stop后输出结果\nLogTemp: Warning: AMyActor2 Destroyed\n```\n\n很明显在Play后UMyObject对象的析构函数被调用了，但是此时如果继续访问UMyObject里的成员依旧可以访问。\n\n### TWeakObjectPtr、TWeakPtr（既保存引用又可GC）\n\n有时我们可能需要在一个类里面临时保存一些对象，但是一旦保存了引用，就需要手动释放才能保证这些对象可以被GC自动回收，关于这个方面UE也贴心的为我们提供了<font color=red> TWeakObjectPtr</font>指针，当然，这也是C++弱指针的UE魔改办罢了，使用这个指针既可以引用对象，但是又不会造成引用计数+1。可以通过一个例子很好的看出来。\n\n```c++\n//AACtor1.cpp\nAActor1::AActor1()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tUE_LOG(LogTemp, Warning, TEXT(\"Actor1 Created\"));\n}\n\nAActor1::~AActor1()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"Actor1 Destryed\"));\n}\n```\n\n```c++\n//AMyActor2\nUCLASS()\nclass INSIDEUE4_API AMyActor2 : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAMyActor2();\n\tAActor1* a;\n\tTWeakObjectPtr<AActor1> p;\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n};\n```\n\n```c++\n//AMyActor2.cpp/BeginPlay()\nvoid AMyActor2::BeginPlay()\n{\n\tSuper::BeginPlay();\n\ta = NewObject<AActor1>();\n\tp = a;\n\ta = NULL;\n\tGEngine->ForceGarbageCollection();\n}\n```\n\nOutputLog:\n\n```\nLogTemp: Warning: Actor1 Created\n\nLogTemp: Warning: Actor1 Destryed\n```\n\n可以看到，AActor1对象依旧被强制回收了。\n\n而TWeakPtr则对于自定义类的弱指针。\n\n<font color=red>注意：弱指针不可以被用来作为TSet或TMap的Key，因为一个对象被GC时无法通知一个容器的Key，但是可以用来作为容器的Value。</font>\n\n### TSharedPtr、TSharedRef（自定义类的GC）\n\n自定义类的GC，UE也贴心的提供了<font color=red> TSharedPtr和TSharedRef</font>对象来为自定义类支持GC，TSharedPtr本质上是一个被封装过的指针，使用形式上依然保留指针的风格。\n\n<font color=red> 创建TSharedPtr指针指向一个自定义类时，需要使用`MakeShareable()`函数，如：</font>\n\n```c++\nTSharedPtr<UMyObject> p = MakeShareable(NewObject<UMyObject>());\nTSharedPtr<FActor> f = MakeShareable(new FActor());\n```\n\nTSharedPtr和TSharedRef都可以为自定义类提供GC功能，二者的区别只在于TSharedPtr可以为null，而SharedRef不可以。我在网上查询发现有三种方法构建TSharedRef，分别为：\n\n第一种：\n\n```c++\nTSharedRef<FActor> ref(new FActor());\n```\n\n第二种：\n\n```c++\nTSharedRef<FActor> ref = MakeShared<FActor>(new FActor());\n```\n\n第三种：\n\n```c++\nTSharedPtr<FActor> ptr = MakeShareable<FActor>(new FActor());\nTSharedRef<FActor> ref = ptr.ToSharedRef();\n```\n\n其中第二种方法在编写时没有任何问题但在编译时无法通过，并提示：\n\n```\nThe TSharedRef() constructor is for internal usage only for hot-reload purposes. Please do NOT use it.\n```\n\n使用的编译环境为：UE4.22 + VS2017\n\n### FGCObject（在自定义类中控制UObject对象的GC）\n\n当我们在一个自定义类中组合一个UObject对象时，如果不做特殊处理也会出现GC触发中发现的疑问，在自定义类没有被析构时，UObject的对象的析构函数就被调用了，但是对象依然可以被使用。目前没有发现这种情况会导致什么样的后果，但是作为一个合格的UE程序还是应该尽量避免这种情况的发生，那么在一个自定义类中组合一个UObject对象，应该如何控制UObject对象的GC呢？\n\nUE4提供了一个叫做<font color=red>FGCObject</font>的类，位于<font color=red>GCObject.h</font>头文件中，我们需要使自定义类继承自FGCObject类，然后再实现AddReferencedObjects函数，并在函数中通过Collector.AddReferencedObject()函数将所有的UObject对象UE4自动管理即可。\n\n如：\n\n```c++\nclass INSIDEUE4_API FActor : FGCObject\n{\npublic:\n\tFActor();\n\t~FActor();\n\tUMyObject* obj;\n\n\tvirtual void AddReferencedObjects(FReferenceCollector& Collector) override\n\t{\n\t\tCollector.AddReferencedObject(obj);\n\t}\n};\n```\n\n然后，UObject对象就会在FActor对象析构时才被析构。\n\n## 2.序列化\n\n### FObjectWriter和FObjectReader序列化对象到文件和从文件读取\n\nFObjectWriter可以将对象数据序列化为二进制流，然后配合FFileHelper将流写入文件即可实现对象状态存储到文件。\n\n```c++\nvoid AOperatActor::SaveObject()\n{\n\tUSerializationObj* obj= NewObject<USerializationObj>();\n\tUE_LOG(LogTemp, Warning, TEXT(\"OldStr:%s\"), *obj->str);\n\tobj->str = TEXT(\"OperatActor\");\n\tTArray<uint8> bytes;\n\tFObjectWriter(obj, bytes);\t\n\tFFileHelper::SaveArrayToFile(bytes, *FString(\"D:\\\\Goulandis\\\\UE4\\\\MyProject\\\\obj.txt\"));\t\n}\n```\n\n配合FFileHelper将文件中的对象状态读入字节数组，FObjectReader就可以将字节数组中的对象状态写入新的对象中。\n\n```c++\nUSerializationObj* AOperatActor::LoadObject()\n{\n\tUSerializationObj* newObj = NewObject<USerializationObj>();\n\tTArray<uint8> bytes;\n\tFFileHelper::LoadFileToArray(bytes, *FString(\"D:\\\\Goulandis\\\\UE4\\\\MyProject\\\\obj.txt\"));\n\tFObjectReader reader(newObj, bytes);\n\tUE_LOG(LogTemp, Warning, TEXT(\"NewStr:%s\"), *newObj->str);\n\treturn newObj;\n}\n```\n\n看一下运行结果：\n\n![](https://img-blog.csdnimg.cn/20210512145024267.png#pic_center)\n\n可以看到，新创建的USerializationObj对象的状态是被修改过后的状态。\n\nActor的使用方式和UObject是一样的：\n\n```c++\nvoid AOperatActor::SaveActor()\n{\n\tASerializationActor* actor = GetWorld()->SpawnActor<ASerializationActor>();\n\tUE_LOG(LogTemp, Warning, TEXT(\"OldStr:%s\"), *actor->str);\n\tactor->str = TEXT(\"NewActor\");\n\tTArray<uint8> bytes;\n\tFObjectWriter(actor, bytes);\n\tFFileHelper::SaveArrayToFile(bytes, *FString(\"D:\\\\Goulandis\\\\UE4\\\\MyProject\\\\actor.txt\"));\n}\n```\n\n```c++\nASerializationActor * AOperatActor::LoadActor()\n{\n\tASerializationActor* actor = GetWorld()->SpawnActor<ASerializationActor>();\n\tTArray<uint8> bytes;\n\tFFileHelper::LoadFileToArray(bytes, *FString(\"D:\\\\Goulandis\\\\UE4\\\\MyProject\\\\actor.txt\"));\n\tFObjectReader reader(actor,bytes);\n\tUE_LOG(LogTemp, Warning, TEXT(\"NewStr:%s\"), *actor->str);\n\treturn actor;\n}\n```\n\n运行结果：\n\n![](https://img-blog.csdnimg.cn/20210512145820162.png#pic_center)\n\n## 3.反射\n\n### 搜索所有的Object\n\nC++本身的反射系统RTTI相当薄弱，所以UE在C++的基础上借助UObject自己实现了一套反射系统，同时借鉴了C#的长处提供了一系列反射用的系统函数。\n\n```c++\nTArray<UObject*> result;\nGetObjectsOfClass(UClass::StaticClass(), result);   //获取所有的class和interface\nGetObjectsOfClass(UEnum::StaticClass(), result);   //获取所有的enum\nGetObjectsOfClass(UScriptStruct::StaticClass(), result);   //获取所有的struct\n```\n\n\n\n### 运行时创建对象\n\n```c++\nvoid AOperatActor::FindSerializationObj()\n{\n\tUClass* uclass = FindObject<UClass>(ANY_PACKAGE, TEXT(\"SerializationObj\"));\n\tUSerializationObj* obj = Cast<USerializationObj>(uclass->GetDefaultObject());\n\tobj->PrintStr();\n}\n```\n\nUE4提供FindObject模板函数来搜索指定的类的类型信息，返回的类型元素据通过UClass类型对象存储，UClass对象就是UE4专门用来存储元数据的类型，UClass中提供了大量的方法来操作元数据，[UClass](https://docs.unrealengine.com/en-US/API/Runtime/CoreUObject/UObject/UClass/index.html)，这里使用GetDefaultObject函数调用默认的构造函数创建SerializationObj类型的对象，需要注意的是GetDefaultObject返回的是一个UObject对象，所以需要使用Cast来做类型转换。\n\n热加载\n\n","slug":"【UE4】UE4GamePlay架构","published":1,"updated":"2021-05-13T11:01:22.596Z","_id":"ckmbr23xl0000tor784r9da7m","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p>参考博客：<a href=\"https://docs.unrealengine.com/en-US/index.html\">UE4官方文档</a>、<a href=\"https://zhuanlan.zhihu.com/p/22813908\">大钊</a>、<a href=\"https://zhuanlan.zhihu.com/p/67055774\">南京周润发</a>、<a href=\"https://blog.csdn.net/qq_29523119/article/details/84981218\">带带大师兄</a></p>\n<h1 id=\"一、整体框架\"><a href=\"#一、整体框架\" class=\"headerlink\" title=\"一、整体框架\"></a>一、整体框架</h1><p>首先来看一下整体框架：</p>\n<a id=\"more\"></a>\n\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210226143303.png\"></p>\n<p><font color=\"red\"> 红色部分为主体，从右往左为组合关系，至上而下为派生关系。</font></p>\n<p>在整个UE宇宙的构成中，UEngine就类似化学元素，UObject就类似物质，物质通过演化便衍生出了物体—AActor和UActorComponent，AActor继续演化就出现了生物APawn，人—ACharacter，于是世界便有了信息—AInfo，规则—AGameMode，大量的物体、生物组合在一起便形成了大陆—ULevel，不同的大陆组合在一起便形成了世界—UWorld，世界有着自己的信息—FWorldContext和客观规律—UGameInstance。</p>\n<p>而在UE这个宇宙有很多个Word，如编辑时的World，编辑时运行的World，运行时的World等等，查看源码就可知道UE宇宙有五大世界。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">namespace</span> EWorldType<br>&#123;<br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">Type</span></span><br><span class=\"hljs-class\">\t&#123;</span><br>\t\tNone,\t\t<span class=\"hljs-comment\">// An untyped world, in most cases this will be the vestigial worlds of streamed in sub-levels</span><br>\t\tGame,\t\t<span class=\"hljs-comment\">// The game world</span><br>\t\tEditor,\t\t<span class=\"hljs-comment\">// A world being edited in the editor</span><br>\t\tPIE,\t\t<span class=\"hljs-comment\">// A Play In Editor world</span><br>\t\tPreview,\t<span class=\"hljs-comment\">// A preview world for an editor tool</span><br>\t\tInactive\t<span class=\"hljs-comment\">// An editor world that was loaded but not currently being edited in the level editor</span><br>\t&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>首先我们先了解一下这些类的具体作用，然后再细致的了解各个类。</p>\n<h2 id=\"1-UEngine\"><a href=\"#1-UEngine\" class=\"headerlink\" title=\"1.UEngine\"></a>1.UEngine</h2><p>UEngine类是UE的基础，UEngine提供一些最底层的交互—与操作系统的交互，而根据不同的运行模式UE与操作系统的交互模式又有少许不同，所以UEngine又派生出了UGameEngine和UEditerEngine来负责不同运行模式下的交互模式。</p>\n<p>其中有一个很重要的全局指针GEngine，通过GEngine可以访问各种UE的全局资源，同时GEngine还提供多线程访问能力。</p>\n<p>关于UEngine的资料实在是太少了，官方文档中对UEngine的描述也就一句话，对UEngine的理解也就止步于此了。</p>\n<h2 id=\"2-UObject\"><a href=\"#2-UObject\" class=\"headerlink\" title=\"2.UObject\"></a>2.UObject</h2><p>UObject是构成UE世界最基础的物质，所以UObject提供供UE世界运行的最基本的功能：</p>\n<ul>\n<li>Garbage collection：垃圾收集</li>\n<li>Reference updating：引用自动更新</li>\n<li>Reflection：反射</li>\n<li>Serialization：序列化</li>\n<li>Automatic updating of default property changes：自动检测默认变量的更改</li>\n<li>Automatic property initialization：自动变量初始化</li>\n<li>Automatic editor integration：和虚幻引擎编辑器的自动交互</li>\n<li>Type information available at runtime：运行时类型识别</li>\n<li>Network replication：网络复制</li>\n</ul>\n<p>在之后再深入浅出的讲解各个功能。</p>\n<h2 id=\"3-AActor\"><a href=\"#3-AActor\" class=\"headerlink\" title=\"3.AActor\"></a>3.AActor</h2><p>AActor是派生自UObject的一个及其重要的类，AActor在UObject的基础上再进一步提供了：</p>\n<ul>\n<li>Replication：网络复制</li>\n<li>Spawn：动态创建</li>\n<li>Tick：每帧运行</li>\n</ul>\n<p>Replicatoin使AActor有了分裂复制的生育能力，Spawn使AActor在UE世界中出生，在UE4世界中死去，Tick使AActor有了心跳，AActor便组成了丰富多彩的UE世界。</p>\n<p>AActor拥有一个庞大的子孙族群，ALevelScriptActor、ANavigationObjectBase、APawn、AController、AInfo这些都是AActor的直系后代，而这些后代也都各自拥有自己的庞大分支族群，构成了UE世界中最强大的种族AActor。</p>\n<h3 id=\"ALevelScriptActor\"><a href=\"#ALevelScriptActor\" class=\"headerlink\" title=\"ALevelScriptActor\"></a>ALevelScriptActor</h3><p>ALevelScriptActor在官方文档中的表述就是ULevelScriptBlueprint生成的类的基类，通过名称我们就很容易联想到关卡蓝图，没错ULevelScriptBlueprint就是我们最常用的关卡蓝图，ULevelScriptBlueprint继承自UObject，所以ULevelScriptBlueprint的子类是一个多继承的虚继承类，而ALevelScriptActor就为其提供AActor的能力。</p>\n<p>在官方文档中有提及默认关卡蓝图是可以通过DefualtGame.ini配置文件替换成自定义关卡蓝图的，具体使用方法在后面在探讨。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210309211442.png\"></p>\n<h3 id=\"ANavigationObjectBase\"><a href=\"#ANavigationObjectBase\" class=\"headerlink\" title=\"ANavigationObjectBase\"></a>ANavigationObjectBase</h3><p>ANavigationObjectBase的资料实在是少的可怜，就连官方文档也是没有一个字的描述，源码也是相当简单，总共就70行，由ANavigationObjectBase是APlayerState的基类，和它继承的接口INavAgentInterface可以猜测ANavigationObjectBase应该和网络复制有关，具体细节留到以后更熟悉UE4了再深入探讨吧。</p>\n<h3 id=\"APlayerStart\"><a href=\"#APlayerStart\" class=\"headerlink\" title=\"APlayerStart\"></a>APlayerStart</h3><p>APlayerStart的作用就是记录APawn在游戏开始时生成的Position与Rotation信息，UE设计APlayerStart的初忠就是想让游戏的关卡设十师和场景设计师的工作分离开来，也就解耦合。那么，如果Level中不存在APlayerStart ，APawn 会出生在哪是呢？答案是世界原点(0，0，0)</p>\n<h3 id=\"APawn\"><a href=\"#APawn\" class=\"headerlink\" title=\"APawn\"></a>APawn</h3><p>APawn在AActor的基础上再度添加了：</p>\n<ul>\n<li>被Controller控制</li>\n<li>PhysicsCollision：物理碰撞</li>\n<li>MovementInput：移动响应接口</li>\n</ul>\n<p>等能力，有了MovementInput接口APawn就拥有了可运动的能力，这里UE的逻辑划分十分精妙，UE将一个可运动的物体巧妙地划分成了APwan和AController，APawn重点表现在物体，而这个物体具备运动能力，但是自身不具备运动技巧；而AController这是控制APawn运动地大脑，用来控制APawn如何运动，如果把APawn比作是提线木偶，那么AController就是控制木偶运动地线。</p>\n<p>到了APawn这一代，AActor的衍化之旅开始衍化出现于玩家间交互的能力，而这之中的佼佼者便是ACharacter。</p>\n<h3 id=\"ACharacter\"><a href=\"#ACharacter\" class=\"headerlink\" title=\"ACharacter\"></a>ACharacter</h3><p>ACharacter是APwan的特化加强版，在UE世界中可以称之为“人”，ACharacter是一个专门为人形角色定制的APawn，自带CharacterMovement组件，可以使人形角色像人一样行走。</p>\n<h3 id=\"ADefaultPawn\"><a href=\"#ADefaultPawn\" class=\"headerlink\" title=\"ADefaultPawn\"></a>ADefaultPawn</h3><p>最初始的APawn使最基本的APawn类，只提供APawn的一些基本能力，而没有提供支持这些能力的组件，而在具体实际使用情况中我们使用的APawn应该还需要组合一些其他的能力，以适应不同的场景，如：我们知道APawn可以运动，但在实际场景中我们是要确定这个APawn是因该直立行走还是爬行，是用轮子行驶还是用翅膀飞行，APawn在玩家眼里应该长什么样子，是人还是蛇，是因该左球形碰撞还是应该做方形碰撞，这些都是APawn不具备的能力，这时ADefaultPawn便出现了，ADefaultPawn自带DefualtPawnMovement、CollisionComponent、StaticMeshCompnent三件套，为ADefaultPawn提供了默认的场景表现。</p>\n<h3 id=\"ASpectatorPawn\"><a href=\"#ASpectatorPawn\" class=\"headerlink\" title=\"ASpectatorPawn\"></a>ASpectatorPawn</h3><p>在游戏中存在一种特殊的玩家—观战玩家，这类玩家不需要具体表现形式，只需要一些相机的漫游能力，于是ASpectatorPawn出现了，ASpectatorPawn继承自ADefaultPawn，ASpectatorPawn提供了一个基本的USpectatorPawnMovement（不带重力漫游），并关闭了StaticMesh的显示，碰撞也设置到了“Spectator”通道。</p>\n<h3 id=\"AController\"><a href=\"#AController\" class=\"headerlink\" title=\"AController\"></a>AController</h3><p>AController就是控制APawn运动的大脑了，ACtroller负责处理一些直接与玩家交互的控制逻辑，AController是从AActor派生的与APawn同级的子类，在UE的设计中，在同一时刻一个AController和一个APawn之间是1:1的关系，AController可以在多个APawn之间通过Possess/UnPossess切换。AController有两种控制APawn的方式，一种是AController直接附在APawn的身上控制APawn的移动，如驾驶汽车，一种是以上帝的视角控制APawn的移动，如控制第三人称的角色。</p>\n<h3 id=\"APlayerController\"><a href=\"#APlayerController\" class=\"headerlink\" title=\"APlayerController\"></a>APlayerController</h3><p>APlayerController是由AController派生出来专门用于负责玩家交互逻辑的AController，APlayerController提供了：</p>\n<ul>\n<li>Camera管理</li>\n<li>Input输入响应</li>\n<li>UPlayer关联</li>\n<li>HUD显示</li>\n<li>Level切换</li>\n<li>Voice音源监听</li>\n</ul>\n<p>这些能力。</p>\n<h3 id=\"AAIController\"><a href=\"#AAIController\" class=\"headerlink\" title=\"AAIController\"></a>AAIController</h3><p>在一个游戏中有玩家控制的角色也可以有NPC，那么NPC的行动逻辑有谁来控制呢？答案就是AAIController，AAIController与APlayerController完全不同，因为一个NPC不要管理Camera，不需要响应玩家的输入，不需要关联UPlayer，不需要显示HUD，不需要监听音源，只有Level切换可能会在少数情况下需要，那么AAIController因该做什么呢？UE为它设计的是这些事：</p>\n<ul>\n<li>Navigation：自动寻路</li>\n<li>AI Component：用于启动运行行为树，使用黑板数据</li>\n<li>Task系统：让AI去完成一些任务</li>\n</ul>\n<p>当然一个游戏中是至少需要一个APlayerController的，但是可以没有AAIController。</p>\n<h3 id=\"AInfo\"><a href=\"#AInfo\" class=\"headerlink\" title=\"AInfo\"></a>AInfo</h3><p>AInfo是一些数据保存类的基类，AInfo不需要运动和碰撞，也不需要物理表现，仅仅只是保存数据，所以UE在AInfo中将这些功能都隐藏了，之所以不直接继承自UObject，而继承自AActor是因为游戏数据是需要具备网络复制的能力的，而UObject不具备这个能力</p>\n<h3 id=\"AWordSetting\"><a href=\"#AWordSetting\" class=\"headerlink\" title=\"AWordSetting\"></a>AWordSetting</h3><p>AWordSetting继承自AInfo用来配置和保存一些Level配置，主要用于配置Level的GameMode信息，光照信息，导航系统，声音系统，LOD系统，物理加速度等关卡信息。由此可以知道一个Level对应一个AWordSetting，但是一个AWordSetting可以应用在多个Level上。</p>\n<h3 id=\"AGameMode\"><a href=\"#AGameMode\" class=\"headerlink\" title=\"AGameMode\"></a>AGameMode</h3><p>AGameMode就是用于配置AWorldSetting中的GameMode属性的。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210310162744.png\"></p>\n<p>在UE的设计中AGameMode就是游戏世界的逻辑，及整个游戏的玩法规则，而在实际情况中一个游戏既可以只有一个玩法也可以有多种玩法规则，所以AWordSetting与AGameMode的对应关系也是一个AWorldSetting只能对应一个AGameMode，而一个AGameMode可以对应多个AWorldSetting。那么AGameMode应该负责哪些逻辑呢？UE是这么规定的：</p>\n<ul>\n<li>Class登记：记录GameMode中各种类的信息</li>\n<li>Spawn：创建Pawn和PlayerController等</li>\n<li>游戏进度：游戏暂停重启的逻辑</li>\n<li>过场动画逻辑</li>\n<li>多人游戏的步调同步</li>\n</ul>\n<h3 id=\"AGameState\"><a href=\"#AGameState\" class=\"headerlink\" title=\"AGameState\"></a>AGameState</h3><p>AGameState用于保存游戏数据，如任务进度，游戏活动等。</p>\n<h3 id=\"APlayerState\"><a href=\"#APlayerState\" class=\"headerlink\" title=\"APlayerState\"></a>APlayerState</h3><p>APlayerState是一个用于存储玩家状态的类，在一个游戏客户端，尤其是网络游戏客户端中是可以存在多个APlayerState对象的，不同的APlayerState保存不同玩家的状态，同时APlayerState也可以存在于服务器中。APlayerState的生命周期为一整个Level的生命周期。</p>\n<p>到这是AActor家族下的几个重要成员的基本功能我们便有了一个大概的了解了，这里我们来捋一下这些成员之间的关系和在UE世界中的地位。<br><img src=\"https://i.loli.net/2021/03/10/3Ccrl7uNo4QRbUK.jpg\" alt=\"Alt\"></p>\n<h2 id=\"4-UActorComponent\"><a href=\"#4-UActorComponent\" class=\"headerlink\" title=\"4.UActorComponent\"></a>4.UActorComponent</h2><p>UActorComponent是UE向U3D看齐的一个产物，虽然UE世界有了Actor就有了形形色色的物体生物，但是不同的生物拥有不同的技能，而同一个Actor可以会某个技能也可以不会，这种概念使用组合的方式组合到Actor下是最理想的，于是Component便出现了，UActorComponent直接继承自UObject，与AActor同级，Component既可以嵌套在Actor下，也可以嵌套在其他的Component下，但是需要注意的是，UActorComponent这一级是不提供互相嵌套的能力的，只有到其子类USceneComponent一级才提供互相嵌套能力。</p>\n<h3 id=\"USceneComponent\"><a href=\"#USceneComponent\" class=\"headerlink\" title=\"USceneComponent\"></a>USceneComponent</h3><p>USceneComponent主要提供两大能力，一是Transform，二是SceneComponent的互相嵌套。一般我们直接在Level里创建的Actor都会默认带有一个SceneComponent组件。</p>\n<h3 id=\"UPrimitiveComponent\"><a href=\"#UPrimitiveComponent\" class=\"headerlink\" title=\"UPrimitiveComponent\"></a>UPrimitiveComponent</h3><p>UPrimitiveComponent主要提供Actor用于物体渲染和碰撞相关的基础能力。</p>\n<h3 id=\"UMeshComponent\"><a href=\"#UMeshComponent\" class=\"headerlink\" title=\"UMeshComponent\"></a>UMeshComponent</h3><p>UMeshComponent由UPrimitiveComponent派生而来，主要提供具体的渲染显示方面的能力。</p>\n<h3 id=\"UChildActorComponent\"><a href=\"#UChildActorComponent\" class=\"headerlink\" title=\"UChildActorComponent\"></a>UChildActorComponent</h3><p>从名字就可以窥探其功能一二了，UChildComponent在Actor中主要用于链接Actor与Component，提供Component和Actor的嵌套能力。</p>\n<h2 id=\"5-ULevel\"><a href=\"#5-ULevel\" class=\"headerlink\" title=\"5.ULevel\"></a>5.ULevel</h2><p>ULevel可以看作是UE世界的大陆，是AActor的容器，前面提到的ALevelScriptActor便是ULevel默认带有的关卡蓝图，在这个关卡蓝图中编写便是这块大陆的逻辑，同事ULevel也默认带有一个AWorldSetting。</p>\n<h2 id=\"6-UWorld\"><a href=\"#6-UWorld\" class=\"headerlink\" title=\"6.UWorld\"></a>6.UWorld</h2><p>在UE中所有的ULevel互相联系就构成了一个UWorld，ULevel构建UWorld的方式有两种，一种是以SubLevel的形式，像关卡流一样，一个关卡链接下一个关卡，来组成UWorld，一种是每一个ULevel就是这个大地图的UWorld中的一块地图，ULevel之间以相对位置衔接在一起，构成一个大地图来组成这个UWorld。无论是那种构成形式，在一个UWorld中都有一个PersistentLevel，PersistenetLevel就是主Level，是玩家最初始的出生地，这里用的是最初始而不是游戏开始，是因为，现在很多在游戏开始时玩家的出点可能不是PersistentLevel而是上一次玩家离线时的位置。</p>\n<h2 id=\"7-FWorldContext\"><a href=\"#7-FWorldContext\" class=\"headerlink\" title=\"7.FWorldContext\"></a>7.FWorldContext</h2><p>FWorldContext不对开发者公开，是UE内部用来处理引擎UWorld上下文的类，比如当我们从编辑状态的EditorWorld点击播放切换到PIEWorld即运行状态时，这个过程中EditorWorld到PIEWorld之间的信息交换就是通过FWorldContext实现的。可以说FWorldContext处理的是UWorld级的通信。</p>\n<h2 id=\"8-UGameInstance\"><a href=\"#8-UGameInstance\" class=\"headerlink\" title=\"8.UGameInstance\"></a>8.UGameInstance</h2><p>UGameInstance可以说是凌驾于所有AActor、UActorComponent、ULevel、UWorld之上的类，通常情况下一个Game中应该只有一个，这里的Gam是UEngine中提到的所有World的总和，当然这不是绝对的，对于更高层次的开发者，UE也是提供了多个UGameInstance协同的扩展的。</p>\n<p>所以UGameInstance主要处理：</p>\n<ul>\n<li>UWorld、ULevel之间的切换</li>\n<li>UPlayer的创建，这里的UPlayer又和前面的APlayerController有所不同，这一点在后面再介绍。</li>\n<li>全局配置</li>\n<li>GameMode的切换</li>\n</ul>\n<h2 id=\"9-UNetDriver\"><a href=\"#9-UNetDriver\" class=\"headerlink\" title=\"9.UNetDriver\"></a>9.UNetDriver</h2><p>从名字就可以略知一二，UNetDriver是UE处理网络同步相关的类，UNetDriver中有两个主要的成员：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UNetConnection</span>* <span class=\"hljs-title\">ServerConnection</span>;</span><br>TArray&lt;<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UNetConnection</span>*&gt;</span> ClientConnections;<br></code></pre></td></tr></table></figure>\n<p>ServerConnection是客户端到服务器的连接，ClientConnections数组是服务器到客户端群的连接的数组。而在UNetConnnection中又有一个很重要的成员：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">TMap&lt;TWeakObjectPtr&lt;AActor&gt;,<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UActorChannel</span>*&gt;</span> ActorChannels<br></code></pre></td></tr></table></figure>\n<p>ActorChannels是在服务器与客户端完成连接后用于实现Actor同步的对象。</p>\n<h2 id=\"10-UPlayer\"><a href=\"#10-UPlayer\" class=\"headerlink\" title=\"10.UPlayer\"></a>10.UPlayer</h2><p>UPlayer即玩家，ULevel可以切换，UWorld可以交替，但是尽管ULevel、UWorld如何变换，玩家还是那个玩家，所以UPlayer是和UGameInstance同一级别的存在，那么，UPlayer、AController、APawn之间到底是什么关系呢?</p>\n<p>UE源码对UPlayer是这么解释：</p>\n<figure class=\"highlight sqf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sqf\"><span class=\"hljs-built_in\">Player</span>: Corresponds <span class=\"hljs-keyword\">to</span> a real <span class=\"hljs-built_in\">player</span> (a <span class=\"hljs-built_in\">local</span> camera <span class=\"hljs-built_in\">or</span> remote net <span class=\"hljs-built_in\">player</span>).<br></code></pre></td></tr></table></figure>\n<p>很显然，UE对UPlayer的定位就是与玩家交互的类，即UPlayer是直接与底层硬件输入相关的类，如处理鼠标键盘的输入或游戏手柄的输入，当然游戏与人之间的交互也不仅限于这两种，还有VR设备的交互，语音交互，重力感应等等，谁也不知道未来还会有什么样的游戏交互出现，所以UE并没有把UPlayer隐藏起来，开发者依然可以创建自己的UPlayer。而然在大多数情况下，我们是不需要直接操作UPlayer的，因为一些常规的底层交互UE已经封装好了。</p>\n<p>所以UPlayer是处理底层输入的，而AController则是直接对接UPlayer，通过接收UPlayer的输入来处理对APawn的控制逻辑，最后APawn更具AController的控制逻辑做出响应的行为，于是玩家到角色的交互过程便实现了。</p>\n<h3 id=\"ULocalPlayer\"><a href=\"#ULocalPlayer\" class=\"headerlink\" title=\"ULocalPlayer\"></a>ULocalPlayer</h3><p>在一个单机游戏中UPlayer是唯一的存在，但是在一个网络联级游戏中，表示同一实体的UPlayer即存在于玩家本地的客户端中，同时也存在于其他玩家的多个客户端中，那么玩家的输入就既要作用于本地的APawn上，同时在其他玩家的客户端中的表示这个实体的APawn也要做出响应的反应，于是UE便将UPlayer又派生出了两个子类，ULocalPlayer和UNetConnection。其中ULocalPlayer就是处理本地客户端的输入逻辑的类。</p>\n<h3 id=\"UNetConnection\"><a href=\"#UNetConnection\" class=\"headerlink\" title=\"UNetConnection\"></a>UNetConnection</h3><p>UNetConnection就是处理其他玩家在本地客户端中的APawn的类，所以UNetConnection也是一个玩家。</p>\n<h2 id=\"11-USaveGame\"><a href=\"#11-USaveGame\" class=\"headerlink\" title=\"11.USaveGame\"></a>11.USaveGame</h2><p>前面提到了AGameState是一个保存游戏数据的类，这个保存是一个临时保存，所以当游戏程序关闭之后AGameState中数据也就不存在了，而USaveGame就是用来保存存档的类，USaveGame提供游戏数据永久性保存，我们只需要往USaveGame中添加我们要保存的属性字段，就可以直接调用USaveGame的接口直接将游戏数据序列化保存到本地文件中，相当的方便。</p>\n<p>花了这么长的篇幅也就简要的介绍了一下GamePlay的整体框架，总共由这11个类组成，说起来不多，但是里面的门道却是相当深奥，这需要在以后的使用中慢慢学习消化。</p>\n<p>那么接下来就开始各个类的详细使用学习了。</p>\n<h1 id=\"二、UObject\"><a href=\"#二、UObject\" class=\"headerlink\" title=\"二、UObject\"></a>二、UObject</h1><p>首先我们来看UObject提供的功能：</p>\n<ul>\n<li>Garbage collection：垃圾收集</li>\n<li>Reference updating：引用自动更新</li>\n<li>Reflection：反射</li>\n<li>Serialization：序列化</li>\n<li>Automatic updating of default property changes：自动检测默认变量的更改</li>\n<li>Automatic property initialization：自动变量初始化</li>\n<li>Automatic editor integration：和虚幻引擎编辑器的自动交互</li>\n<li>Type information available at runtime：运行时类型识别</li>\n<li>Network replication：网络复制</li>\n</ul>\n<h2 id=\"1-垃圾回收\"><a href=\"#1-垃圾回收\" class=\"headerlink\" title=\"1.垃圾回收\"></a>1.垃圾回收</h2><p>首先我们来研究研究UE4是如何进行垃圾回收的。</p>\n<p>这里推荐两位大佬的博客：<a href=\"https://zhuanlan.zhihu.com/p/67055774\">带带大师兄</a>、<a href=\"https://blog.csdn.net/qq_29523119/article/details/84981218\">南京周润发</a></p>\n<p>可以配合着看。</p>\n<p>由于C++不提供GC功能，所有UE自己实现了一套GC功能，使用的也是最经典的<code>标记-清理</code>垃圾回收方式。</p>\n<h3 id=\"GC的过程\"><a href=\"#GC的过程\" class=\"headerlink\" title=\"GC的过程\"></a>GC的过程</h3><p>UEGC分为来两个阶段，第一个阶段UE从根集合开始遍历，遍历所有可达对象，于是UE就知道了哪些对象还在被引用，哪些对象已经不可被引用了。第二阶段UE会逐步的清理这些不可达对象，形式为分帧分批清理，为什么要这么做呢？想想我们卸载一次性Level时的感受就知道了，分批处理可以保证我们在使用UE时的顺滑而不卡顿。</p>\n<p>UEGC的主要函数是在UObjectGlobals.h头文件中CollectGarbage函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">CollectGarbage</span><span class=\"hljs-params\">(EObjectFlags KeepFlags, <span class=\"hljs-keyword\">bool</span> bPerformFullPurge)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// No other thread may be performing UObject operations while we&#x27;re running</span><br>\tAcquireGCLock();<br><br>\t<span class=\"hljs-comment\">// Perform actual garbage collection</span><br>\tCollectGarbageInternal(KeepFlags, bPerformFullPurge);<br><br>\t<span class=\"hljs-comment\">// Other threads are free to use UObjects</span><br>\tReleaseGCLock();<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>可以看到GC的整体流程很自然的划分成了三个阶段，获取GC锁、执行CollectGarbageInternal和释放GC锁。使用锁的原因是UEGC是多线程的，为了防止在GC的过程中对象被其他线程访问，以保证异步加载的稳定。而CollectGarbageInternal函数则进行垃圾回收和对象标记与清理，两个参数KeepFlags表示这些被标记的对象无论是否被引用都将被保留，bPerformFullPurge表示GC时进行全清理还是分帧分批清理。</p>\n<p>那么GC又是如何进行对象标记的呢？还是看源码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/** </span><br><span class=\"hljs-comment\"> * Deletes all unreferenced objects, keeping objects that have any of the passed in KeepFlags set</span><br><span class=\"hljs-comment\"> *</span><br><span class=\"hljs-comment\"> * @param\tKeepFlags\t\t\tobjects with those flags will be kept regardless of being referenced or not</span><br><span class=\"hljs-comment\"> * @param\tbPerformFullPurge\tif true, perform a full purge after the mark pass</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">CollectGarbageInternal</span><span class=\"hljs-params\">(EObjectFlags KeepFlags, <span class=\"hljs-keyword\">bool</span> bPerformFullPurge)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tSCOPE_TIME_GUARD(TEXT(<span class=\"hljs-string\">&quot;Collect Garbage&quot;</span>));<br>\tSCOPED_NAMED_EVENT(CollectGarbageInternal, FColor::Red);<br>\tCSV_EVENT_GLOBAL(TEXT(<span class=\"hljs-string\">&quot;GC&quot;</span>));<br>\tCSV_SCOPED_TIMING_STAT_EXCLUSIVE(GarbageCollection);<br><br>\tFGCCSyncObject::Get().ResetGCIsWaiting();<br><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">if</span> defined(WITH_CODE_GUARD_HANDLER) &amp;&amp; WITH_CODE_GUARD_HANDLER</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">CheckImageIntegrityAtRuntime</span><span class=\"hljs-params\">()</span></span>;<br>\tCheckImageIntegrityAtRuntime();<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">endif</span></span><br><br>\tDECLARE_SCOPE_CYCLE_COUNTER( TEXT( <span class=\"hljs-string\">&quot;CollectGarbageInternal&quot;</span> ), STAT_CollectGarbageInternal, STATGROUP_GC );<br>\tSTAT_ADD_CUSTOMMESSAGE_NAME( STAT_NamedMarker, TEXT( <span class=\"hljs-string\">&quot;GarbageCollection - Begin&quot;</span> ) );<br><br>\t<span class=\"hljs-comment\">// We can&#x27;t collect garbage while there&#x27;s a load in progress. E.g. one potential issue is Import.XObject</span><br>\tcheck(!IsLoading());<br><br>\t<span class=\"hljs-comment\">// Reset GC skip counter</span><br>\tGNumAttemptsSinceLastGC = <span class=\"hljs-number\">0</span>;<br><br>\t<span class=\"hljs-comment\">// Flush streaming before GC if requested</span><br>\t<span class=\"hljs-keyword\">if</span> (GFlushStreamingOnGC)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (IsAsyncLoading())<br>\t\t&#123;<br>\t\t\tUE_LOG(LogGarbage, Log, TEXT(<span class=\"hljs-string\">&quot;CollectGarbageInternal() is flushing async loading&quot;</span>));<br>\t\t&#125;<br>\t\tFGCCSyncObject::Get().GCUnlock();<br>\t\tFlushAsyncLoading();<br>\t\tFGCCSyncObject::Get().GCLock();<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// Route callbacks so we can ensure that we are e.g. not in the middle of loading something by flushing</span><br>\t<span class=\"hljs-comment\">// the async loading, etc...</span><br>\tFCoreUObjectDelegates::GetPreGarbageCollectDelegate().Broadcast();<br>\tGLastGCFrame = GFrameCounter;<br><br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// Set &#x27;I&#x27;m garbage collecting&#x27; flag - might be checked inside various functions.</span><br>\t\t<span class=\"hljs-comment\">// This has to be unlocked before we call post GC callbacks</span><br>\t\tFGCScopeLock GCLock;<br><br>\t\tUE_LOG(LogGarbage, Log, TEXT(<span class=\"hljs-string\">&quot;Collecting garbage%s&quot;</span>), IsAsyncLoading() ? TEXT(<span class=\"hljs-string\">&quot; while async loading&quot;</span>) : TEXT(<span class=\"hljs-string\">&quot;&quot;</span>));<br><br>\t\t<span class=\"hljs-comment\">// Make sure previous incremental purge has finished or we do a full purge pass in case we haven&#x27;t kicked one</span><br>\t\t<span class=\"hljs-comment\">// off yet since the last call to garbage collection.</span><br>\t\t<span class=\"hljs-keyword\">if</span> (GObjIncrementalPurgeIsInProgress || GObjPurgeIsRequired)<br>\t\t&#123;<br>\t\t\tIncrementalPurgeGarbage(<span class=\"hljs-literal\">false</span>);<br>\t\t\tFMemory::Trim();<br>\t\t&#125;<br>\t\tcheck(!GObjIncrementalPurgeIsInProgress);<br>\t\tcheck(!GObjPurgeIsRequired);<br><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">if</span> VERIFY_DISREGARD_GC_ASSUMPTIONS</span><br>\t\t<span class=\"hljs-comment\">// Only verify assumptions if option is enabled. This avoids false positives in the Editor or commandlets.</span><br>\t\t<span class=\"hljs-keyword\">if</span> ((GUObjectArray.DisregardForGCEnabled() || GUObjectClusters.GetNumAllocatedClusters()) &amp;&amp; GShouldVerifyGCAssumptions)<br>\t\t&#123;<br>\t\t\tDECLARE_SCOPE_CYCLE_COUNTER(TEXT(<span class=\"hljs-string\">&quot;CollectGarbageInternal.VerifyGCAssumptions&quot;</span>), STAT_CollectGarbageInternal_VerifyGCAssumptions, STATGROUP_GC);<br>\t\t\t<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">double</span> StartTime = FPlatformTime::Seconds();<br>\t\t\tVerifyGCAssumptions();<br>\t\t\tVerifyClustersAssumptions();<br>\t\t\tUE_LOG(LogGarbage, Log, TEXT(<span class=\"hljs-string\">&quot;%f ms for Verify GC Assumptions&quot;</span>), (FPlatformTime::Seconds() - StartTime) * <span class=\"hljs-number\">1000</span>);<br>\t\t&#125;<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">endif</span></span><br><br>\t\t<span class=\"hljs-comment\">// Fall back to single threaded GC if processor count is 1 or parallel GC is disabled</span><br>\t\t<span class=\"hljs-comment\">// or detailed per class gc stats are enabled (not thread safe)</span><br>\t\t<span class=\"hljs-comment\">// Temporarily forcing single-threaded GC in the editor until Modify() can be safely removed from HandleObjectReference.</span><br>\t\t<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">bool</span> bForceSingleThreadedGC = !FApp::ShouldUseThreadingForPerformance() || !FPlatformProcess::SupportsMultithreading() ||<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">if</span> PLATFORM_SUPPORTS_MULTITHREADED_GC</span><br>\t\t(FPlatformMisc::NumberOfCores() &lt; <span class=\"hljs-number\">2</span> || GAllowParallelGC == <span class=\"hljs-number\">0</span> || PERF_DETAILED_PER_CLASS_GC_STATS);<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">else</span>\t<span class=\"hljs-comment\">//PLATFORM_SUPPORTS_MULTITHREADED_GC</span></span><br>\t\t\t<span class=\"hljs-literal\">true</span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">endif</span>\t<span class=\"hljs-comment\">//PLATFORM_SUPPORTS_MULTITHREADED_GC</span></span><br><br>\t\t<span class=\"hljs-comment\">// Perform reachability analysis.</span><br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">double</span> StartTime = FPlatformTime::Seconds();<br>\t\t\tFRealtimeGC TagUsedRealtimeGC;<br>            <span class=\"hljs-comment\">//-----------------------------------------------------------</span><br>\t\t\tTagUsedRealtimeGC.PerformReachabilityAnalysis(KeepFlags, bForceSingleThreadedGC);<br>            <span class=\"hljs-comment\">//-----------------------------------------------------------</span><br>\t\t\tUE_LOG(LogGarbage, Log, TEXT(<span class=\"hljs-string\">&quot;%f ms for GC&quot;</span>), (FPlatformTime::Seconds() - StartTime) * <span class=\"hljs-number\">1000</span>);<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// Reconstruct clusters if needed</span><br>\t\t<span class=\"hljs-keyword\">if</span> (GUObjectClusters.ClustersNeedDissolving())<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">double</span> StartTime = FPlatformTime::Seconds();<br>\t\t\tGUObjectClusters.DissolveClusters();<br>\t\t\tUE_LOG(LogGarbage, Log, TEXT(<span class=\"hljs-string\">&quot;%f ms for dissolving GC clusters&quot;</span>), (FPlatformTime::Seconds() - StartTime) * <span class=\"hljs-number\">1000</span>);<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// Fire post-reachability analysis hooks</span><br>\t\tFCoreUObjectDelegates::PostReachabilityAnalysis.Broadcast();<br>\t\t<br>\t\t&#123;<br>\t\t\tFGCArrayPool::Get().ClearWeakReferences(bPerformFullPurge);<br><br>\t\t\tGatherUnreachableObjects(bForceSingleThreadedGC);<br><br>\t\t\t<span class=\"hljs-keyword\">if</span> (bPerformFullPurge || !GIncrementalBeginDestroyEnabled)<br>\t\t\t&#123;<br>\t\t\t\tUnhashUnreachableObjects(<span class=\"hljs-comment\">/**bUseTimeLimit = */</span> <span class=\"hljs-literal\">false</span>);<br>\t\t\t\tFScopedCBDProfile::DumpProfile();<br>\t\t\t&#125;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// Set flag to indicate that we are relying on a purge to be performed.</span><br>\t\tGObjPurgeIsRequired = <span class=\"hljs-literal\">true</span>;<br>\t\t<span class=\"hljs-comment\">// Reset purged count.</span><br>\t\tGPurgedObjectCountSinceLastMarkPhase = <span class=\"hljs-number\">0</span>;<br>\t\tGObjCurrentPurgeObjectIndexResetPastPermanent = <span class=\"hljs-literal\">true</span>;<br><br>\t\t<span class=\"hljs-comment\">// Perform a full purge by not using a time limit for the incremental purge. The Editor always does a full purge.</span><br>\t\t<span class=\"hljs-keyword\">if</span> (bPerformFullPurge || GIsEditor)<br>\t\t&#123;<br>\t\t\tIncrementalPurgeGarbage(<span class=\"hljs-literal\">false</span>);<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-keyword\">if</span> (bPerformFullPurge)<br>\t\t&#123;<br>\t\t\tShrinkUObjectHashTables();<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// Destroy all pending delete linkers</span><br>\t\tDeleteLoaders();<br><br>\t\t<span class=\"hljs-comment\">// Trim allocator memory</span><br>\t\tFMemory::Trim();<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// Route callbacks to verify GC assumptions</span><br>\tFCoreUObjectDelegates::GetPostGarbageCollect().Broadcast();<br><br>\tSTAT_ADD_CUSTOMMESSAGE_NAME( STAT_NamedMarker, TEXT( <span class=\"hljs-string\">&quot;GarbageCollection - End&quot;</span> ) );<br>&#125;<br><br></code></pre></td></tr></table></figure>\n<p>我在PerformReachabilityAnalysis函数处做了标记，GC时UE就是通过这个函数进行对象标记的，PerformReachabilityAnalysis函数会做多线程实时的分析对象的引用关系，然后标记出可达与不可达对象。标记是如何进行的还得深入到PerformReachabilityAnalysis函数，再上源码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * Performs reachability analysis.</span><br><span class=\"hljs-comment\">\t *</span><br><span class=\"hljs-comment\">\t * @param KeepFlags\t\tObjects with these flags will be kept regardless of being referenced or not</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">PerformReachabilityAnalysis</span><span class=\"hljs-params\">(EObjectFlags KeepFlags, <span class=\"hljs-keyword\">bool</span> bForceSingleThreaded = <span class=\"hljs-literal\">false</span>)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tLLM_SCOPE(ELLMTag::GC);<br><br>\t\tSCOPED_NAMED_EVENT(FRealtimeGC_PerformReachabilityAnalysis, FColor::Red);<br>\t\tDECLARE_SCOPE_CYCLE_COUNTER(TEXT(<span class=\"hljs-string\">&quot;FRealtimeGC::PerformReachabilityAnalysis&quot;</span>), STAT_FArchiveRealtimeGC_PerformReachabilityAnalysis, STATGROUP_GC);<br><br>\t\t<span class=\"hljs-comment\">/** Growing array of objects that require serialization */</span><br>\t\tFGCArrayStruct* ArrayStruct = FGCArrayPool::Get().GetArrayStructFromPool();<br>\t\tTArray&lt;UObject*&gt;&amp; ObjectsToSerialize = ArrayStruct-&gt;ObjectsToSerialize;<br><br>\t\t<span class=\"hljs-comment\">// Reset object count.</span><br>\t\tGObjectCountDuringLastMarkPhase.Reset();<br><br>\t\t<span class=\"hljs-comment\">// Make sure GC referencer object is checked for references to other objects even if it resides in permanent object pool</span><br>\t\t<span class=\"hljs-keyword\">if</span> (FPlatformProperties::RequiresCookedData() &amp;&amp; FGCObject::GGCObjectReferencer &amp;&amp; GUObjectArray.IsDisregardForGC(FGCObject::GGCObjectReferencer))<br>\t\t&#123;<br>\t\t\tObjectsToSerialize.Add(FGCObject::GGCObjectReferencer);<br>\t\t&#125;<br><br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">double</span> StartTime = FPlatformTime::Seconds();<br>\t\t\tMarkObjectsAsUnreachable(ObjectsToSerialize, KeepFlags, bForceSingleThreaded);<br>\t\t\tUE_LOG(LogGarbage, Verbose, TEXT(<span class=\"hljs-string\">&quot;%f ms for Mark Phase (%d Objects To Serialize&quot;</span>), (FPlatformTime::Seconds() - StartTime) * <span class=\"hljs-number\">1000</span>, ObjectsToSerialize.Num());<br>\t\t&#125;<br><br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">double</span> StartTime = FPlatformTime::Seconds();<br>\t\t\tPerformReachabilityAnalysisOnObjects(ArrayStruct, bForceSingleThreaded);<br>\t\t\tUE_LOG(LogGarbage, Verbose, TEXT(<span class=\"hljs-string\">&quot;%f ms for Reachability Analysis&quot;</span>), (FPlatformTime::Seconds() - StartTime) * <span class=\"hljs-number\">1000</span>);<br>\t\t&#125;<br>        <br>\t\t<span class=\"hljs-comment\">// Allowing external systems to add object roots. This can&#x27;t be done through AddReferencedObjects</span><br>\t\t<span class=\"hljs-comment\">// because it may require tracing objects (via FGarbageCollectionTracer) multiple times</span><br>\t\tFCoreUObjectDelegates::TraceExternalRootsForReachabilityAnalysis.Broadcast(*<span class=\"hljs-keyword\">this</span>, KeepFlags, bForceSingleThreaded);<br><br>\t\tFGCArrayPool::Get().ReturnToPool(ArrayStruct);<br><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">if</span> UE_BUILD_DEBUG</span><br>\t\tFGCArrayPool::Get().CheckLeaks();<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">endif</span></span><br>\t&#125;<br></code></pre></td></tr></table></figure>\n<p>首先前面的宏暂时可以忽略掉，</p>\n<p>第一步，<code>FGCArrayStruct* ArrayStruct = FGCArrayPool::Get().GetArrayStructFromPool();</code>UE将UObject的所有的强引用和弱引用都存储大ArrayStruct数据结构中，FGCArrayPool是UEGC的主要执行类</p>\n<p>第二步，<code>TArray&lt;UObject*&gt;&amp; ObjectsToSerialize = ArrayStruct-&gt;ObjectsToSerialize;</code>分离UObject的强引用到ObjectsToSerialize 数组中。</p>\n<p>这是FGCArrayStruct结构体的源码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">FGCArrayStruct</span></span><br><span class=\"hljs-class\">&#123;</span><br>\tTArray&lt;UObject*&gt; ObjectsToSerialize;<br>\tTArray&lt;UObject**&gt; WeakReferences;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>ObjectsToSerialize存储强引用，WeakReferences存储弱引用。</p>\n<p>第三步，<code>GObjectCountDuringLastMarkPhase.Reset();</code>重置对象的引用计数。</p>\n<p>第四步，通过一个if判断标记可达对象，于是可达对象与不可达对象就被标记出来了，接下来便是GC清理。</p>\n<h3 id=\"GC的触发\"><a href=\"#GC的触发\" class=\"headerlink\" title=\"GC的触发\"></a>GC的触发</h3><p>UE的GC发生在游戏线程上，支持多线程GC，和大多数主流语言的GC一样支持自动触发和手动触发。</p>\n<p><strong>手动触发</strong></p>\n<p>手动触发UE也提供了两种方式，其一是通过C++函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">GEngine-&gt;ForceGarbageCollection();<br></code></pre></td></tr></table></figure>\n<p>这里需要注意的是<code>GEngine</code>在<code>Engine.h</code>头文件下。</p>\n<p>手动触发的使用场景一般是在卸载某些资源后，手动触发GC回收这些资源在使用过程中的无用对象。</p>\n<p>其二是蓝图节点：</p>\n<p><img src=\"/2021/02/26/%E3%80%90UE4%E3%80%91UE4GamePlay%E6%9E%B6%E6%9E%84/Git\\Hexo\\source_posts\\【UE4】UE4GamePlay架构\\Snipaste_2021-03-19_21-54-55.png\"></p>\n<p>手动调用这两个函数，UE会跳过GC算法，在下一次Tick时直接进行GC。</p>\n<p><font color=\"red\"> 这里有一点需要注意，在大多数情况下，手动GC一般只能回收NewObject函数创建的对象，而UWorld()-&gt;SpawnActor函数创建的对象无论如何调用都无法销毁，这是因为，当UE创建一个Actor之后在UWorld中就已经保存了这个Actor的引用，所以无论我们如何释放Actor的引用，这个Actor的引用计数都不会归零，所以要销毁一个Actor还是需要通过Actor-&gt;Destroy()函数。</font></p>\n<p>我们可以个一个例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//AACtor.cpp</span><br>AActor1::AActor1()<br>&#123;<br>\tPrimaryActorTick.bCanEverTick = <span class=\"hljs-literal\">true</span>;<br>\tUE_LOG(LogTemp, Warning, TEXT(<span class=\"hljs-string\">&quot;Actor1 Created&quot;</span>));<br>&#125;<br><br>AActor1::~AActor1()<br>&#123;<br>\tUE_LOG(LogTemp, Warning, TEXT(<span class=\"hljs-string\">&quot;Actor1 Destryed&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//AMyActor.h</span><br>UCLASS()<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">INSIDEUE4_API</span> <span class=\"hljs-title\">AMyActor2</span> :</span> <span class=\"hljs-keyword\">public</span> AActor<br>&#123;<br>\tGENERATED_BODY()<br>\t<br><span class=\"hljs-keyword\">public</span>:\t<br>\tAMyActor2();<br>\tAActor1 *a;<span class=\"hljs-comment\">//注意这里没有加UPROPERTY()宏</span><br><br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">BeginPlay</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">override</span></span>;<br><br><span class=\"hljs-keyword\">public</span>:\t<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Tick</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">float</span> DeltaTime)</span> <span class=\"hljs-keyword\">override</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//AMyActor2</span><br>AMyActor2::AMyActor2()<br>&#123;<br>\tPrimaryActorTick.bCanEverTick = <span class=\"hljs-literal\">true</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">AMyActor2::BeginPlay</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tSuper::BeginPlay();<br>\ta = UWorld()-&gt;SpawnActor&lt;AActor1&gt;();<br>\ta = <span class=\"hljs-literal\">NULL</span>;<br>\tGEngine-&gt;ForceGarbageCollection();<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">AMyActor2::Tick</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">float</span> DeltaTime)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tSuper::Tick(DeltaTime);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>OutputLog:</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs groovy\"><span class=\"hljs-attr\">LogTemp:</span> <span class=\"hljs-attr\">Warning:</span> Actor1 Created<br></code></pre></td></tr></table></figure>\n<p>可以看到使用UWorld()-&gt;SpawnActor创建的Actor即使手动强制GC也没有被回收，因为这个Actor是可达对象。</p>\n<p><strong>自动触发</strong></p>\n<p>要想UE自动触发的GC能能够回收我们创建的对象，那么我们创建的对象就必须继承自UObject，至于加不加UPROPERTY()宏似乎不影响GC的回收，如下面的测试结果，还是以上面的例子为例，把BeginPlay函数改为如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//AMyActor2</span><br>AMyActor2::AMyActor2()<br>&#123;<br>\tPrimaryActorTick.bCanEverTick = <span class=\"hljs-literal\">true</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">AMyActor2::BeginPlay</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tSuper::BeginPlay();<br>\ta = NewObject&lt;AActor1&gt;();<br>\ta = <span class=\"hljs-literal\">NULL</span>;<br>\tGEngine-&gt;ForceGarbageCollection();<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">AMyActor2::Tick</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">float</span> DeltaTime)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tSuper::Tick(DeltaTime);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>我们将MyActor2拖入场景中，运行，OutputLog输出，可以找到下面两句：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">LogTemp: Warning: Actor1 Created<br><br>LogTemp: Warning: Actor1 Destryed<br></code></pre></td></tr></table></figure>\n<p>可以看到，没有使用UPROPERTY()宏的变量a依旧在手动GC时被回收了，这里为了效果明显点使用了手动强制回收，其实使用自动GC也是一样的。</p>\n<p><font color=\"green\">这里有提个疑问：</font></p>\n<p>当我们在一个继承自UObject的类组合一个继承自UObject的对象，如果在这个对象定义前没有使用UPROPERTY()宏，那么在Play后UE会调用一次这个对象的析构函数，但是这个对象依然可以被使用，而如果在定义这个对象前使用了UPROPERTY()宏，那么这对象将和组合类被析构时一起被析构。疑问为什么UE会调用一次被组合对象的析构且析构后依然可以使用这个对象。如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//UMyObject.cpp</span><br>UMyObject::UMyObject()<br>&#123;<br>\tUE_LOG(LogTemp, Warning, TEXT(<span class=\"hljs-string\">&quot;UMyObject Created&quot;</span>));<br>&#125;<br><br>UMyObject::~UMyObject()<br>&#123;<br>\tUE_LOG(LogTemp, Warning, TEXT(<span class=\"hljs-string\">&quot;UMyObject Destoryed&quot;</span>));<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">UMyObject::Fun</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tUE_LOG(LogTemp, Warning, TEXT(<span class=\"hljs-string\">&quot;UMyObject&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//AMyActor2.h</span><br>UCLASS()<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">INSIDEUE4_API</span> <span class=\"hljs-title\">AMyActor2</span> :</span> <span class=\"hljs-keyword\">public</span> AActor<br>&#123;<br>\tGENERATED_BODY()<br>\t<br><span class=\"hljs-keyword\">public</span>:\t<br>\tAMyActor2();<br>\tUPROPERTY()<br>\tUMyObject* obj;<br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">BeginPlay</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">override</span></span>;<br><br><span class=\"hljs-keyword\">public</span>:\t<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Tick</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">float</span> DeltaTime)</span> <span class=\"hljs-keyword\">override</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//AMyActor2.cpp</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">AMyActor2::BeginPlay</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tSuper::BeginPlay();<br>\tobj = NewObject&lt;UMyObject&gt;();<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>使用UPROPERTY()宏的输出结果：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//在点击Play后输出结果</span><br>LogTemp: Warning: AMyActor2 Created<br>LogTemp: Warning: UMyObject Created<br><span class=\"hljs-comment\">//再点击Stop后输出结果</span><br>LogTemp: Warning: UMyObject Destoryed<br>LogTemp: Warning: AMyActor2 Destroyed<br></code></pre></td></tr></table></figure>\n<p>不使用UPROPERTY()宏的输出结果：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//在点击Play后输出结果</span><br>LogTemp: Warning: AMyActor2 Created<br>LogTemp: Warning: UMyObject Created<br>LogTemp: Warning: UMyObject Destoryed<br><span class=\"hljs-comment\">//再点击Stop后输出结果</span><br>LogTemp: Warning: AMyActor2 Destroyed<br></code></pre></td></tr></table></figure>\n<p>很明显在Play后UMyObject对象的析构函数被调用了，但是此时如果继续访问UMyObject里的成员依旧可以访问。</p>\n<h3 id=\"TWeakObjectPtr、TWeakPtr（既保存引用又可GC）\"><a href=\"#TWeakObjectPtr、TWeakPtr（既保存引用又可GC）\" class=\"headerlink\" title=\"TWeakObjectPtr、TWeakPtr（既保存引用又可GC）\"></a>TWeakObjectPtr、TWeakPtr（既保存引用又可GC）</h3><p>有时我们可能需要在一个类里面临时保存一些对象，但是一旦保存了引用，就需要手动释放才能保证这些对象可以被GC自动回收，关于这个方面UE也贴心的为我们提供了<font color=\"red\"> TWeakObjectPtr</font>指针，当然，这也是C++弱指针的UE魔改办罢了，使用这个指针既可以引用对象，但是又不会造成引用计数+1。可以通过一个例子很好的看出来。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//AACtor1.cpp</span><br>AActor1::AActor1()<br>&#123;<br>\tPrimaryActorTick.bCanEverTick = <span class=\"hljs-literal\">true</span>;<br>\tUE_LOG(LogTemp, Warning, TEXT(<span class=\"hljs-string\">&quot;Actor1 Created&quot;</span>));<br>&#125;<br><br>AActor1::~AActor1()<br>&#123;<br>\tUE_LOG(LogTemp, Warning, TEXT(<span class=\"hljs-string\">&quot;Actor1 Destryed&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//AMyActor2</span><br>UCLASS()<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">INSIDEUE4_API</span> <span class=\"hljs-title\">AMyActor2</span> :</span> <span class=\"hljs-keyword\">public</span> AActor<br>&#123;<br>\tGENERATED_BODY()<br>\t<br><span class=\"hljs-keyword\">public</span>:\t<br>\tAMyActor2();<br>\tAActor1* a;<br>\tTWeakObjectPtr&lt;AActor1&gt; p;<br><br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">BeginPlay</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">override</span></span>;<br><br><span class=\"hljs-keyword\">public</span>:\t<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Tick</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">float</span> DeltaTime)</span> <span class=\"hljs-keyword\">override</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//AMyActor2.cpp/BeginPlay()</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">AMyActor2::BeginPlay</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tSuper::BeginPlay();<br>\ta = NewObject&lt;AActor1&gt;();<br>\tp = a;<br>\ta = <span class=\"hljs-literal\">NULL</span>;<br>\tGEngine-&gt;ForceGarbageCollection();<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>OutputLog:</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs groovy\"><span class=\"hljs-attr\">LogTemp:</span> <span class=\"hljs-attr\">Warning:</span> Actor1 Created<br><br><span class=\"hljs-attr\">LogTemp:</span> <span class=\"hljs-attr\">Warning:</span> Actor1 Destryed<br></code></pre></td></tr></table></figure>\n<p>可以看到，AActor1对象依旧被强制回收了。</p>\n<p>而TWeakPtr则对于自定义类的弱指针。</p>\n<p><font color=\"red\">注意：弱指针不可以被用来作为TSet或TMap的Key，因为一个对象被GC时无法通知一个容器的Key，但是可以用来作为容器的Value。</font></p>\n<h3 id=\"TSharedPtr、TSharedRef（自定义类的GC）\"><a href=\"#TSharedPtr、TSharedRef（自定义类的GC）\" class=\"headerlink\" title=\"TSharedPtr、TSharedRef（自定义类的GC）\"></a>TSharedPtr、TSharedRef（自定义类的GC）</h3><p>自定义类的GC，UE也贴心的提供了<font color=\"red\"> TSharedPtr和TSharedRef</font>对象来为自定义类支持GC，TSharedPtr本质上是一个被封装过的指针，使用形式上依然保留指针的风格。</p>\n<p><font color=\"red\"> 创建TSharedPtr指针指向一个自定义类时，需要使用<code>MakeShareable()</code>函数，如：</font></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">TSharedPtr&lt;UMyObject&gt; p = MakeShareable(NewObject&lt;UMyObject&gt;());<br>TSharedPtr&lt;FActor&gt; f = MakeShareable(<span class=\"hljs-keyword\">new</span> FActor());<br></code></pre></td></tr></table></figure>\n<p>TSharedPtr和TSharedRef都可以为自定义类提供GC功能，二者的区别只在于TSharedPtr可以为null，而SharedRef不可以。我在网上查询发现有三种方法构建TSharedRef，分别为：</p>\n<p>第一种：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">TSharedRef&lt;FActor&gt; <span class=\"hljs-title\">ref</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">new</span> FActor())</span></span>;<br></code></pre></td></tr></table></figure>\n<p>第二种：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">TSharedRef&lt;FActor&gt; ref = MakeShared&lt;FActor&gt;(<span class=\"hljs-keyword\">new</span> FActor());<br></code></pre></td></tr></table></figure>\n<p>第三种：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">TSharedPtr&lt;FActor&gt; ptr = MakeShareable&lt;FActor&gt;(<span class=\"hljs-keyword\">new</span> FActor());<br>TSharedRef&lt;FActor&gt; ref = ptr.ToSharedRef();<br></code></pre></td></tr></table></figure>\n<p>其中第二种方法在编写时没有任何问题但在编译时无法通过，并提示：</p>\n<figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs delphi\">The TSharedRef() <span class=\"hljs-function\"><span class=\"hljs-keyword\">constructor</span> <span class=\"hljs-title\">is</span> <span class=\"hljs-title\">for</span> <span class=\"hljs-title\">internal</span> <span class=\"hljs-title\">usage</span> <span class=\"hljs-title\">only</span> <span class=\"hljs-title\">for</span> <span class=\"hljs-title\">hot</span>-<span class=\"hljs-title\">reload</span> <span class=\"hljs-title\">purposes</span>. <span class=\"hljs-title\">Please</span> <span class=\"hljs-title\">do</span> <span class=\"hljs-title\">NOT</span> <span class=\"hljs-title\">use</span> <span class=\"hljs-title\">it</span>.</span><br></code></pre></td></tr></table></figure>\n<p>使用的编译环境为：UE4.22 + VS2017</p>\n<h3 id=\"FGCObject（在自定义类中控制UObject对象的GC）\"><a href=\"#FGCObject（在自定义类中控制UObject对象的GC）\" class=\"headerlink\" title=\"FGCObject（在自定义类中控制UObject对象的GC）\"></a>FGCObject（在自定义类中控制UObject对象的GC）</h3><p>当我们在一个自定义类中组合一个UObject对象时，如果不做特殊处理也会出现GC触发中发现的疑问，在自定义类没有被析构时，UObject的对象的析构函数就被调用了，但是对象依然可以被使用。目前没有发现这种情况会导致什么样的后果，但是作为一个合格的UE程序还是应该尽量避免这种情况的发生，那么在一个自定义类中组合一个UObject对象，应该如何控制UObject对象的GC呢？</p>\n<p>UE4提供了一个叫做<font color=\"red\">FGCObject</font>的类，位于<font color=\"red\">GCObject.h</font>头文件中，我们需要使自定义类继承自FGCObject类，然后再实现AddReferencedObjects函数，并在函数中通过Collector.AddReferencedObject()函数将所有的UObject对象UE4自动管理即可。</p>\n<p>如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">INSIDEUE4_API</span> <span class=\"hljs-title\">FActor</span> :</span> FGCObject<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\tFActor();<br>\t~FActor();<br>\tUMyObject* obj;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">AddReferencedObjects</span><span class=\"hljs-params\">(FReferenceCollector&amp; Collector)</span> <span class=\"hljs-keyword\">override</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tCollector.AddReferencedObject(obj);<br>\t&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>然后，UObject对象就会在FActor对象析构时才被析构。</p>\n<h2 id=\"2-序列化\"><a href=\"#2-序列化\" class=\"headerlink\" title=\"2.序列化\"></a>2.序列化</h2><h3 id=\"FObjectWriter和FObjectReader序列化对象到文件和从文件读取\"><a href=\"#FObjectWriter和FObjectReader序列化对象到文件和从文件读取\" class=\"headerlink\" title=\"FObjectWriter和FObjectReader序列化对象到文件和从文件读取\"></a>FObjectWriter和FObjectReader序列化对象到文件和从文件读取</h3><p>FObjectWriter可以将对象数据序列化为二进制流，然后配合FFileHelper将流写入文件即可实现对象状态存储到文件。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">AOperatActor::SaveObject</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tUSerializationObj* obj= NewObject&lt;USerializationObj&gt;();<br>\tUE_LOG(LogTemp, Warning, TEXT(<span class=\"hljs-string\">&quot;OldStr:%s&quot;</span>), *obj-&gt;str);<br>\tobj-&gt;str = TEXT(<span class=\"hljs-string\">&quot;OperatActor&quot;</span>);<br>\tTArray&lt;uint8&gt; bytes;<br>\tFObjectWriter(obj, bytes);\t<br>\tFFileHelper::SaveArrayToFile(bytes, *FString(<span class=\"hljs-string\">&quot;D:\\\\Goulandis\\\\UE4\\\\MyProject\\\\obj.txt&quot;</span>));\t<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>配合FFileHelper将文件中的对象状态读入字节数组，FObjectReader就可以将字节数组中的对象状态写入新的对象中。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">USerializationObj* <span class=\"hljs-title\">AOperatActor::LoadObject</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tUSerializationObj* newObj = NewObject&lt;USerializationObj&gt;();<br>\tTArray&lt;uint8&gt; bytes;<br>\tFFileHelper::LoadFileToArray(bytes, *FString(<span class=\"hljs-string\">&quot;D:\\\\Goulandis\\\\UE4\\\\MyProject\\\\obj.txt&quot;</span>));<br>\t<span class=\"hljs-function\">FObjectReader <span class=\"hljs-title\">reader</span><span class=\"hljs-params\">(newObj, bytes)</span></span>;<br>\tUE_LOG(LogTemp, Warning, TEXT(<span class=\"hljs-string\">&quot;NewStr:%s&quot;</span>), *newObj-&gt;str);<br>\t<span class=\"hljs-keyword\">return</span> newObj;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>看一下运行结果：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210512145024267.png#pic_center\"></p>\n<p>可以看到，新创建的USerializationObj对象的状态是被修改过后的状态。</p>\n<p>Actor的使用方式和UObject是一样的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">AOperatActor::SaveActor</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tASerializationActor* actor = GetWorld()-&gt;SpawnActor&lt;ASerializationActor&gt;();<br>\tUE_LOG(LogTemp, Warning, TEXT(<span class=\"hljs-string\">&quot;OldStr:%s&quot;</span>), *actor-&gt;str);<br>\tactor-&gt;str = TEXT(<span class=\"hljs-string\">&quot;NewActor&quot;</span>);<br>\tTArray&lt;uint8&gt; bytes;<br>\tFObjectWriter(actor, bytes);<br>\tFFileHelper::SaveArrayToFile(bytes, *FString(<span class=\"hljs-string\">&quot;D:\\\\Goulandis\\\\UE4\\\\MyProject\\\\actor.txt&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">ASerializationActor * <span class=\"hljs-title\">AOperatActor::LoadActor</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tASerializationActor* actor = GetWorld()-&gt;SpawnActor&lt;ASerializationActor&gt;();<br>\tTArray&lt;uint8&gt; bytes;<br>\tFFileHelper::LoadFileToArray(bytes, *FString(<span class=\"hljs-string\">&quot;D:\\\\Goulandis\\\\UE4\\\\MyProject\\\\actor.txt&quot;</span>));<br>\t<span class=\"hljs-function\">FObjectReader <span class=\"hljs-title\">reader</span><span class=\"hljs-params\">(actor,bytes)</span></span>;<br>\tUE_LOG(LogTemp, Warning, TEXT(<span class=\"hljs-string\">&quot;NewStr:%s&quot;</span>), *actor-&gt;str);<br>\t<span class=\"hljs-keyword\">return</span> actor;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210512145820162.png#pic_center\"></p>\n<h2 id=\"3-反射\"><a href=\"#3-反射\" class=\"headerlink\" title=\"3.反射\"></a>3.反射</h2><h3 id=\"搜索所有的Object\"><a href=\"#搜索所有的Object\" class=\"headerlink\" title=\"搜索所有的Object\"></a>搜索所有的Object</h3><p>C++本身的反射系统RTTI相当薄弱，所以UE在C++的基础上借助UObject自己实现了一套反射系统，同时借鉴了C#的长处提供了一系列反射用的系统函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">TArray&lt;UObject*&gt; result;<br>GetObjectsOfClass(UClass::StaticClass(), result);   <span class=\"hljs-comment\">//获取所有的class和interface</span><br>GetObjectsOfClass(UEnum::StaticClass(), result);   <span class=\"hljs-comment\">//获取所有的enum</span><br>GetObjectsOfClass(UScriptStruct::StaticClass(), result);   <span class=\"hljs-comment\">//获取所有的struct</span><br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"运行时创建对象\"><a href=\"#运行时创建对象\" class=\"headerlink\" title=\"运行时创建对象\"></a>运行时创建对象</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">AOperatActor::FindSerializationObj</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tUClass* uclass = FindObject&lt;UClass&gt;(ANY_PACKAGE, TEXT(<span class=\"hljs-string\">&quot;SerializationObj&quot;</span>));<br>\tUSerializationObj* obj = Cast&lt;USerializationObj&gt;(uclass-&gt;GetDefaultObject());<br>\tobj-&gt;PrintStr();<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>UE4提供FindObject模板函数来搜索指定的类的类型信息，返回的类型元素据通过UClass类型对象存储，UClass对象就是UE4专门用来存储元数据的类型，UClass中提供了大量的方法来操作元数据，<a href=\"https://docs.unrealengine.com/en-US/API/Runtime/CoreUObject/UObject/UClass/index.html\">UClass</a>，这里使用GetDefaultObject函数调用默认的构造函数创建SerializationObj类型的对象，需要注意的是GetDefaultObject返回的是一个UObject对象，所以需要使用Cast来做类型转换。</p>\n<p>热加载</p>\n","site":{"data":{}},"excerpt":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p>参考博客：<a href=\"https://docs.unrealengine.com/en-US/index.html\">UE4官方文档</a>、<a href=\"https://zhuanlan.zhihu.com/p/22813908\">大钊</a>、<a href=\"https://zhuanlan.zhihu.com/p/67055774\">南京周润发</a>、<a href=\"https://blog.csdn.net/qq_29523119/article/details/84981218\">带带大师兄</a></p>\n<h1 id=\"一、整体框架\"><a href=\"#一、整体框架\" class=\"headerlink\" title=\"一、整体框架\"></a>一、整体框架</h1><p>首先来看一下整体框架：</p>","more":"<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210226143303.png\"></p>\n<p><font color=\"red\"> 红色部分为主体，从右往左为组合关系，至上而下为派生关系。</font></p>\n<p>在整个UE宇宙的构成中，UEngine就类似化学元素，UObject就类似物质，物质通过演化便衍生出了物体—AActor和UActorComponent，AActor继续演化就出现了生物APawn，人—ACharacter，于是世界便有了信息—AInfo，规则—AGameMode，大量的物体、生物组合在一起便形成了大陆—ULevel，不同的大陆组合在一起便形成了世界—UWorld，世界有着自己的信息—FWorldContext和客观规律—UGameInstance。</p>\n<p>而在UE这个宇宙有很多个Word，如编辑时的World，编辑时运行的World，运行时的World等等，查看源码就可知道UE宇宙有五大世界。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">namespace</span> EWorldType<br>&#123;<br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">Type</span></span><br><span class=\"hljs-class\">\t&#123;</span><br>\t\tNone,\t\t<span class=\"hljs-comment\">// An untyped world, in most cases this will be the vestigial worlds of streamed in sub-levels</span><br>\t\tGame,\t\t<span class=\"hljs-comment\">// The game world</span><br>\t\tEditor,\t\t<span class=\"hljs-comment\">// A world being edited in the editor</span><br>\t\tPIE,\t\t<span class=\"hljs-comment\">// A Play In Editor world</span><br>\t\tPreview,\t<span class=\"hljs-comment\">// A preview world for an editor tool</span><br>\t\tInactive\t<span class=\"hljs-comment\">// An editor world that was loaded but not currently being edited in the level editor</span><br>\t&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>首先我们先了解一下这些类的具体作用，然后再细致的了解各个类。</p>\n<h2 id=\"1-UEngine\"><a href=\"#1-UEngine\" class=\"headerlink\" title=\"1.UEngine\"></a>1.UEngine</h2><p>UEngine类是UE的基础，UEngine提供一些最底层的交互—与操作系统的交互，而根据不同的运行模式UE与操作系统的交互模式又有少许不同，所以UEngine又派生出了UGameEngine和UEditerEngine来负责不同运行模式下的交互模式。</p>\n<p>其中有一个很重要的全局指针GEngine，通过GEngine可以访问各种UE的全局资源，同时GEngine还提供多线程访问能力。</p>\n<p>关于UEngine的资料实在是太少了，官方文档中对UEngine的描述也就一句话，对UEngine的理解也就止步于此了。</p>\n<h2 id=\"2-UObject\"><a href=\"#2-UObject\" class=\"headerlink\" title=\"2.UObject\"></a>2.UObject</h2><p>UObject是构成UE世界最基础的物质，所以UObject提供供UE世界运行的最基本的功能：</p>\n<ul>\n<li>Garbage collection：垃圾收集</li>\n<li>Reference updating：引用自动更新</li>\n<li>Reflection：反射</li>\n<li>Serialization：序列化</li>\n<li>Automatic updating of default property changes：自动检测默认变量的更改</li>\n<li>Automatic property initialization：自动变量初始化</li>\n<li>Automatic editor integration：和虚幻引擎编辑器的自动交互</li>\n<li>Type information available at runtime：运行时类型识别</li>\n<li>Network replication：网络复制</li>\n</ul>\n<p>在之后再深入浅出的讲解各个功能。</p>\n<h2 id=\"3-AActor\"><a href=\"#3-AActor\" class=\"headerlink\" title=\"3.AActor\"></a>3.AActor</h2><p>AActor是派生自UObject的一个及其重要的类，AActor在UObject的基础上再进一步提供了：</p>\n<ul>\n<li>Replication：网络复制</li>\n<li>Spawn：动态创建</li>\n<li>Tick：每帧运行</li>\n</ul>\n<p>Replicatoin使AActor有了分裂复制的生育能力，Spawn使AActor在UE世界中出生，在UE4世界中死去，Tick使AActor有了心跳，AActor便组成了丰富多彩的UE世界。</p>\n<p>AActor拥有一个庞大的子孙族群，ALevelScriptActor、ANavigationObjectBase、APawn、AController、AInfo这些都是AActor的直系后代，而这些后代也都各自拥有自己的庞大分支族群，构成了UE世界中最强大的种族AActor。</p>\n<h3 id=\"ALevelScriptActor\"><a href=\"#ALevelScriptActor\" class=\"headerlink\" title=\"ALevelScriptActor\"></a>ALevelScriptActor</h3><p>ALevelScriptActor在官方文档中的表述就是ULevelScriptBlueprint生成的类的基类，通过名称我们就很容易联想到关卡蓝图，没错ULevelScriptBlueprint就是我们最常用的关卡蓝图，ULevelScriptBlueprint继承自UObject，所以ULevelScriptBlueprint的子类是一个多继承的虚继承类，而ALevelScriptActor就为其提供AActor的能力。</p>\n<p>在官方文档中有提及默认关卡蓝图是可以通过DefualtGame.ini配置文件替换成自定义关卡蓝图的，具体使用方法在后面在探讨。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210309211442.png\"></p>\n<h3 id=\"ANavigationObjectBase\"><a href=\"#ANavigationObjectBase\" class=\"headerlink\" title=\"ANavigationObjectBase\"></a>ANavigationObjectBase</h3><p>ANavigationObjectBase的资料实在是少的可怜，就连官方文档也是没有一个字的描述，源码也是相当简单，总共就70行，由ANavigationObjectBase是APlayerState的基类，和它继承的接口INavAgentInterface可以猜测ANavigationObjectBase应该和网络复制有关，具体细节留到以后更熟悉UE4了再深入探讨吧。</p>\n<h3 id=\"APlayerStart\"><a href=\"#APlayerStart\" class=\"headerlink\" title=\"APlayerStart\"></a>APlayerStart</h3><p>APlayerStart的作用就是记录APawn在游戏开始时生成的Position与Rotation信息，UE设计APlayerStart的初忠就是想让游戏的关卡设十师和场景设计师的工作分离开来，也就解耦合。那么，如果Level中不存在APlayerStart ，APawn 会出生在哪是呢？答案是世界原点(0，0，0)</p>\n<h3 id=\"APawn\"><a href=\"#APawn\" class=\"headerlink\" title=\"APawn\"></a>APawn</h3><p>APawn在AActor的基础上再度添加了：</p>\n<ul>\n<li>被Controller控制</li>\n<li>PhysicsCollision：物理碰撞</li>\n<li>MovementInput：移动响应接口</li>\n</ul>\n<p>等能力，有了MovementInput接口APawn就拥有了可运动的能力，这里UE的逻辑划分十分精妙，UE将一个可运动的物体巧妙地划分成了APwan和AController，APawn重点表现在物体，而这个物体具备运动能力，但是自身不具备运动技巧；而AController这是控制APawn运动地大脑，用来控制APawn如何运动，如果把APawn比作是提线木偶，那么AController就是控制木偶运动地线。</p>\n<p>到了APawn这一代，AActor的衍化之旅开始衍化出现于玩家间交互的能力，而这之中的佼佼者便是ACharacter。</p>\n<h3 id=\"ACharacter\"><a href=\"#ACharacter\" class=\"headerlink\" title=\"ACharacter\"></a>ACharacter</h3><p>ACharacter是APwan的特化加强版，在UE世界中可以称之为“人”，ACharacter是一个专门为人形角色定制的APawn，自带CharacterMovement组件，可以使人形角色像人一样行走。</p>\n<h3 id=\"ADefaultPawn\"><a href=\"#ADefaultPawn\" class=\"headerlink\" title=\"ADefaultPawn\"></a>ADefaultPawn</h3><p>最初始的APawn使最基本的APawn类，只提供APawn的一些基本能力，而没有提供支持这些能力的组件，而在具体实际使用情况中我们使用的APawn应该还需要组合一些其他的能力，以适应不同的场景，如：我们知道APawn可以运动，但在实际场景中我们是要确定这个APawn是因该直立行走还是爬行，是用轮子行驶还是用翅膀飞行，APawn在玩家眼里应该长什么样子，是人还是蛇，是因该左球形碰撞还是应该做方形碰撞，这些都是APawn不具备的能力，这时ADefaultPawn便出现了，ADefaultPawn自带DefualtPawnMovement、CollisionComponent、StaticMeshCompnent三件套，为ADefaultPawn提供了默认的场景表现。</p>\n<h3 id=\"ASpectatorPawn\"><a href=\"#ASpectatorPawn\" class=\"headerlink\" title=\"ASpectatorPawn\"></a>ASpectatorPawn</h3><p>在游戏中存在一种特殊的玩家—观战玩家，这类玩家不需要具体表现形式，只需要一些相机的漫游能力，于是ASpectatorPawn出现了，ASpectatorPawn继承自ADefaultPawn，ASpectatorPawn提供了一个基本的USpectatorPawnMovement（不带重力漫游），并关闭了StaticMesh的显示，碰撞也设置到了“Spectator”通道。</p>\n<h3 id=\"AController\"><a href=\"#AController\" class=\"headerlink\" title=\"AController\"></a>AController</h3><p>AController就是控制APawn运动的大脑了，ACtroller负责处理一些直接与玩家交互的控制逻辑，AController是从AActor派生的与APawn同级的子类，在UE的设计中，在同一时刻一个AController和一个APawn之间是1:1的关系，AController可以在多个APawn之间通过Possess/UnPossess切换。AController有两种控制APawn的方式，一种是AController直接附在APawn的身上控制APawn的移动，如驾驶汽车，一种是以上帝的视角控制APawn的移动，如控制第三人称的角色。</p>\n<h3 id=\"APlayerController\"><a href=\"#APlayerController\" class=\"headerlink\" title=\"APlayerController\"></a>APlayerController</h3><p>APlayerController是由AController派生出来专门用于负责玩家交互逻辑的AController，APlayerController提供了：</p>\n<ul>\n<li>Camera管理</li>\n<li>Input输入响应</li>\n<li>UPlayer关联</li>\n<li>HUD显示</li>\n<li>Level切换</li>\n<li>Voice音源监听</li>\n</ul>\n<p>这些能力。</p>\n<h3 id=\"AAIController\"><a href=\"#AAIController\" class=\"headerlink\" title=\"AAIController\"></a>AAIController</h3><p>在一个游戏中有玩家控制的角色也可以有NPC，那么NPC的行动逻辑有谁来控制呢？答案就是AAIController，AAIController与APlayerController完全不同，因为一个NPC不要管理Camera，不需要响应玩家的输入，不需要关联UPlayer，不需要显示HUD，不需要监听音源，只有Level切换可能会在少数情况下需要，那么AAIController因该做什么呢？UE为它设计的是这些事：</p>\n<ul>\n<li>Navigation：自动寻路</li>\n<li>AI Component：用于启动运行行为树，使用黑板数据</li>\n<li>Task系统：让AI去完成一些任务</li>\n</ul>\n<p>当然一个游戏中是至少需要一个APlayerController的，但是可以没有AAIController。</p>\n<h3 id=\"AInfo\"><a href=\"#AInfo\" class=\"headerlink\" title=\"AInfo\"></a>AInfo</h3><p>AInfo是一些数据保存类的基类，AInfo不需要运动和碰撞，也不需要物理表现，仅仅只是保存数据，所以UE在AInfo中将这些功能都隐藏了，之所以不直接继承自UObject，而继承自AActor是因为游戏数据是需要具备网络复制的能力的，而UObject不具备这个能力</p>\n<h3 id=\"AWordSetting\"><a href=\"#AWordSetting\" class=\"headerlink\" title=\"AWordSetting\"></a>AWordSetting</h3><p>AWordSetting继承自AInfo用来配置和保存一些Level配置，主要用于配置Level的GameMode信息，光照信息，导航系统，声音系统，LOD系统，物理加速度等关卡信息。由此可以知道一个Level对应一个AWordSetting，但是一个AWordSetting可以应用在多个Level上。</p>\n<h3 id=\"AGameMode\"><a href=\"#AGameMode\" class=\"headerlink\" title=\"AGameMode\"></a>AGameMode</h3><p>AGameMode就是用于配置AWorldSetting中的GameMode属性的。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210310162744.png\"></p>\n<p>在UE的设计中AGameMode就是游戏世界的逻辑，及整个游戏的玩法规则，而在实际情况中一个游戏既可以只有一个玩法也可以有多种玩法规则，所以AWordSetting与AGameMode的对应关系也是一个AWorldSetting只能对应一个AGameMode，而一个AGameMode可以对应多个AWorldSetting。那么AGameMode应该负责哪些逻辑呢？UE是这么规定的：</p>\n<ul>\n<li>Class登记：记录GameMode中各种类的信息</li>\n<li>Spawn：创建Pawn和PlayerController等</li>\n<li>游戏进度：游戏暂停重启的逻辑</li>\n<li>过场动画逻辑</li>\n<li>多人游戏的步调同步</li>\n</ul>\n<h3 id=\"AGameState\"><a href=\"#AGameState\" class=\"headerlink\" title=\"AGameState\"></a>AGameState</h3><p>AGameState用于保存游戏数据，如任务进度，游戏活动等。</p>\n<h3 id=\"APlayerState\"><a href=\"#APlayerState\" class=\"headerlink\" title=\"APlayerState\"></a>APlayerState</h3><p>APlayerState是一个用于存储玩家状态的类，在一个游戏客户端，尤其是网络游戏客户端中是可以存在多个APlayerState对象的，不同的APlayerState保存不同玩家的状态，同时APlayerState也可以存在于服务器中。APlayerState的生命周期为一整个Level的生命周期。</p>\n<p>到这是AActor家族下的几个重要成员的基本功能我们便有了一个大概的了解了，这里我们来捋一下这些成员之间的关系和在UE世界中的地位。<br><img src=\"https://i.loli.net/2021/03/10/3Ccrl7uNo4QRbUK.jpg\" alt=\"Alt\"></p>\n<h2 id=\"4-UActorComponent\"><a href=\"#4-UActorComponent\" class=\"headerlink\" title=\"4.UActorComponent\"></a>4.UActorComponent</h2><p>UActorComponent是UE向U3D看齐的一个产物，虽然UE世界有了Actor就有了形形色色的物体生物，但是不同的生物拥有不同的技能，而同一个Actor可以会某个技能也可以不会，这种概念使用组合的方式组合到Actor下是最理想的，于是Component便出现了，UActorComponent直接继承自UObject，与AActor同级，Component既可以嵌套在Actor下，也可以嵌套在其他的Component下，但是需要注意的是，UActorComponent这一级是不提供互相嵌套的能力的，只有到其子类USceneComponent一级才提供互相嵌套能力。</p>\n<h3 id=\"USceneComponent\"><a href=\"#USceneComponent\" class=\"headerlink\" title=\"USceneComponent\"></a>USceneComponent</h3><p>USceneComponent主要提供两大能力，一是Transform，二是SceneComponent的互相嵌套。一般我们直接在Level里创建的Actor都会默认带有一个SceneComponent组件。</p>\n<h3 id=\"UPrimitiveComponent\"><a href=\"#UPrimitiveComponent\" class=\"headerlink\" title=\"UPrimitiveComponent\"></a>UPrimitiveComponent</h3><p>UPrimitiveComponent主要提供Actor用于物体渲染和碰撞相关的基础能力。</p>\n<h3 id=\"UMeshComponent\"><a href=\"#UMeshComponent\" class=\"headerlink\" title=\"UMeshComponent\"></a>UMeshComponent</h3><p>UMeshComponent由UPrimitiveComponent派生而来，主要提供具体的渲染显示方面的能力。</p>\n<h3 id=\"UChildActorComponent\"><a href=\"#UChildActorComponent\" class=\"headerlink\" title=\"UChildActorComponent\"></a>UChildActorComponent</h3><p>从名字就可以窥探其功能一二了，UChildComponent在Actor中主要用于链接Actor与Component，提供Component和Actor的嵌套能力。</p>\n<h2 id=\"5-ULevel\"><a href=\"#5-ULevel\" class=\"headerlink\" title=\"5.ULevel\"></a>5.ULevel</h2><p>ULevel可以看作是UE世界的大陆，是AActor的容器，前面提到的ALevelScriptActor便是ULevel默认带有的关卡蓝图，在这个关卡蓝图中编写便是这块大陆的逻辑，同事ULevel也默认带有一个AWorldSetting。</p>\n<h2 id=\"6-UWorld\"><a href=\"#6-UWorld\" class=\"headerlink\" title=\"6.UWorld\"></a>6.UWorld</h2><p>在UE中所有的ULevel互相联系就构成了一个UWorld，ULevel构建UWorld的方式有两种，一种是以SubLevel的形式，像关卡流一样，一个关卡链接下一个关卡，来组成UWorld，一种是每一个ULevel就是这个大地图的UWorld中的一块地图，ULevel之间以相对位置衔接在一起，构成一个大地图来组成这个UWorld。无论是那种构成形式，在一个UWorld中都有一个PersistentLevel，PersistenetLevel就是主Level，是玩家最初始的出生地，这里用的是最初始而不是游戏开始，是因为，现在很多在游戏开始时玩家的出点可能不是PersistentLevel而是上一次玩家离线时的位置。</p>\n<h2 id=\"7-FWorldContext\"><a href=\"#7-FWorldContext\" class=\"headerlink\" title=\"7.FWorldContext\"></a>7.FWorldContext</h2><p>FWorldContext不对开发者公开，是UE内部用来处理引擎UWorld上下文的类，比如当我们从编辑状态的EditorWorld点击播放切换到PIEWorld即运行状态时，这个过程中EditorWorld到PIEWorld之间的信息交换就是通过FWorldContext实现的。可以说FWorldContext处理的是UWorld级的通信。</p>\n<h2 id=\"8-UGameInstance\"><a href=\"#8-UGameInstance\" class=\"headerlink\" title=\"8.UGameInstance\"></a>8.UGameInstance</h2><p>UGameInstance可以说是凌驾于所有AActor、UActorComponent、ULevel、UWorld之上的类，通常情况下一个Game中应该只有一个，这里的Gam是UEngine中提到的所有World的总和，当然这不是绝对的，对于更高层次的开发者，UE也是提供了多个UGameInstance协同的扩展的。</p>\n<p>所以UGameInstance主要处理：</p>\n<ul>\n<li>UWorld、ULevel之间的切换</li>\n<li>UPlayer的创建，这里的UPlayer又和前面的APlayerController有所不同，这一点在后面再介绍。</li>\n<li>全局配置</li>\n<li>GameMode的切换</li>\n</ul>\n<h2 id=\"9-UNetDriver\"><a href=\"#9-UNetDriver\" class=\"headerlink\" title=\"9.UNetDriver\"></a>9.UNetDriver</h2><p>从名字就可以略知一二，UNetDriver是UE处理网络同步相关的类，UNetDriver中有两个主要的成员：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UNetConnection</span>* <span class=\"hljs-title\">ServerConnection</span>;</span><br>TArray&lt;<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UNetConnection</span>*&gt;</span> ClientConnections;<br></code></pre></td></tr></table></figure>\n<p>ServerConnection是客户端到服务器的连接，ClientConnections数组是服务器到客户端群的连接的数组。而在UNetConnnection中又有一个很重要的成员：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">TMap&lt;TWeakObjectPtr&lt;AActor&gt;,<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UActorChannel</span>*&gt;</span> ActorChannels<br></code></pre></td></tr></table></figure>\n<p>ActorChannels是在服务器与客户端完成连接后用于实现Actor同步的对象。</p>\n<h2 id=\"10-UPlayer\"><a href=\"#10-UPlayer\" class=\"headerlink\" title=\"10.UPlayer\"></a>10.UPlayer</h2><p>UPlayer即玩家，ULevel可以切换，UWorld可以交替，但是尽管ULevel、UWorld如何变换，玩家还是那个玩家，所以UPlayer是和UGameInstance同一级别的存在，那么，UPlayer、AController、APawn之间到底是什么关系呢?</p>\n<p>UE源码对UPlayer是这么解释：</p>\n<figure class=\"highlight sqf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sqf\"><span class=\"hljs-built_in\">Player</span>: Corresponds <span class=\"hljs-keyword\">to</span> a real <span class=\"hljs-built_in\">player</span> (a <span class=\"hljs-built_in\">local</span> camera <span class=\"hljs-built_in\">or</span> remote net <span class=\"hljs-built_in\">player</span>).<br></code></pre></td></tr></table></figure>\n<p>很显然，UE对UPlayer的定位就是与玩家交互的类，即UPlayer是直接与底层硬件输入相关的类，如处理鼠标键盘的输入或游戏手柄的输入，当然游戏与人之间的交互也不仅限于这两种，还有VR设备的交互，语音交互，重力感应等等，谁也不知道未来还会有什么样的游戏交互出现，所以UE并没有把UPlayer隐藏起来，开发者依然可以创建自己的UPlayer。而然在大多数情况下，我们是不需要直接操作UPlayer的，因为一些常规的底层交互UE已经封装好了。</p>\n<p>所以UPlayer是处理底层输入的，而AController则是直接对接UPlayer，通过接收UPlayer的输入来处理对APawn的控制逻辑，最后APawn更具AController的控制逻辑做出响应的行为，于是玩家到角色的交互过程便实现了。</p>\n<h3 id=\"ULocalPlayer\"><a href=\"#ULocalPlayer\" class=\"headerlink\" title=\"ULocalPlayer\"></a>ULocalPlayer</h3><p>在一个单机游戏中UPlayer是唯一的存在，但是在一个网络联级游戏中，表示同一实体的UPlayer即存在于玩家本地的客户端中，同时也存在于其他玩家的多个客户端中，那么玩家的输入就既要作用于本地的APawn上，同时在其他玩家的客户端中的表示这个实体的APawn也要做出响应的反应，于是UE便将UPlayer又派生出了两个子类，ULocalPlayer和UNetConnection。其中ULocalPlayer就是处理本地客户端的输入逻辑的类。</p>\n<h3 id=\"UNetConnection\"><a href=\"#UNetConnection\" class=\"headerlink\" title=\"UNetConnection\"></a>UNetConnection</h3><p>UNetConnection就是处理其他玩家在本地客户端中的APawn的类，所以UNetConnection也是一个玩家。</p>\n<h2 id=\"11-USaveGame\"><a href=\"#11-USaveGame\" class=\"headerlink\" title=\"11.USaveGame\"></a>11.USaveGame</h2><p>前面提到了AGameState是一个保存游戏数据的类，这个保存是一个临时保存，所以当游戏程序关闭之后AGameState中数据也就不存在了，而USaveGame就是用来保存存档的类，USaveGame提供游戏数据永久性保存，我们只需要往USaveGame中添加我们要保存的属性字段，就可以直接调用USaveGame的接口直接将游戏数据序列化保存到本地文件中，相当的方便。</p>\n<p>花了这么长的篇幅也就简要的介绍了一下GamePlay的整体框架，总共由这11个类组成，说起来不多，但是里面的门道却是相当深奥，这需要在以后的使用中慢慢学习消化。</p>\n<p>那么接下来就开始各个类的详细使用学习了。</p>\n<h1 id=\"二、UObject\"><a href=\"#二、UObject\" class=\"headerlink\" title=\"二、UObject\"></a>二、UObject</h1><p>首先我们来看UObject提供的功能：</p>\n<ul>\n<li>Garbage collection：垃圾收集</li>\n<li>Reference updating：引用自动更新</li>\n<li>Reflection：反射</li>\n<li>Serialization：序列化</li>\n<li>Automatic updating of default property changes：自动检测默认变量的更改</li>\n<li>Automatic property initialization：自动变量初始化</li>\n<li>Automatic editor integration：和虚幻引擎编辑器的自动交互</li>\n<li>Type information available at runtime：运行时类型识别</li>\n<li>Network replication：网络复制</li>\n</ul>\n<h2 id=\"1-垃圾回收\"><a href=\"#1-垃圾回收\" class=\"headerlink\" title=\"1.垃圾回收\"></a>1.垃圾回收</h2><p>首先我们来研究研究UE4是如何进行垃圾回收的。</p>\n<p>这里推荐两位大佬的博客：<a href=\"https://zhuanlan.zhihu.com/p/67055774\">带带大师兄</a>、<a href=\"https://blog.csdn.net/qq_29523119/article/details/84981218\">南京周润发</a></p>\n<p>可以配合着看。</p>\n<p>由于C++不提供GC功能，所有UE自己实现了一套GC功能，使用的也是最经典的<code>标记-清理</code>垃圾回收方式。</p>\n<h3 id=\"GC的过程\"><a href=\"#GC的过程\" class=\"headerlink\" title=\"GC的过程\"></a>GC的过程</h3><p>UEGC分为来两个阶段，第一个阶段UE从根集合开始遍历，遍历所有可达对象，于是UE就知道了哪些对象还在被引用，哪些对象已经不可被引用了。第二阶段UE会逐步的清理这些不可达对象，形式为分帧分批清理，为什么要这么做呢？想想我们卸载一次性Level时的感受就知道了，分批处理可以保证我们在使用UE时的顺滑而不卡顿。</p>\n<p>UEGC的主要函数是在UObjectGlobals.h头文件中CollectGarbage函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">CollectGarbage</span><span class=\"hljs-params\">(EObjectFlags KeepFlags, <span class=\"hljs-keyword\">bool</span> bPerformFullPurge)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// No other thread may be performing UObject operations while we&#x27;re running</span><br>\tAcquireGCLock();<br><br>\t<span class=\"hljs-comment\">// Perform actual garbage collection</span><br>\tCollectGarbageInternal(KeepFlags, bPerformFullPurge);<br><br>\t<span class=\"hljs-comment\">// Other threads are free to use UObjects</span><br>\tReleaseGCLock();<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>可以看到GC的整体流程很自然的划分成了三个阶段，获取GC锁、执行CollectGarbageInternal和释放GC锁。使用锁的原因是UEGC是多线程的，为了防止在GC的过程中对象被其他线程访问，以保证异步加载的稳定。而CollectGarbageInternal函数则进行垃圾回收和对象标记与清理，两个参数KeepFlags表示这些被标记的对象无论是否被引用都将被保留，bPerformFullPurge表示GC时进行全清理还是分帧分批清理。</p>\n<p>那么GC又是如何进行对象标记的呢？还是看源码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/** </span><br><span class=\"hljs-comment\"> * Deletes all unreferenced objects, keeping objects that have any of the passed in KeepFlags set</span><br><span class=\"hljs-comment\"> *</span><br><span class=\"hljs-comment\"> * @param\tKeepFlags\t\t\tobjects with those flags will be kept regardless of being referenced or not</span><br><span class=\"hljs-comment\"> * @param\tbPerformFullPurge\tif true, perform a full purge after the mark pass</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">CollectGarbageInternal</span><span class=\"hljs-params\">(EObjectFlags KeepFlags, <span class=\"hljs-keyword\">bool</span> bPerformFullPurge)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tSCOPE_TIME_GUARD(TEXT(<span class=\"hljs-string\">&quot;Collect Garbage&quot;</span>));<br>\tSCOPED_NAMED_EVENT(CollectGarbageInternal, FColor::Red);<br>\tCSV_EVENT_GLOBAL(TEXT(<span class=\"hljs-string\">&quot;GC&quot;</span>));<br>\tCSV_SCOPED_TIMING_STAT_EXCLUSIVE(GarbageCollection);<br><br>\tFGCCSyncObject::Get().ResetGCIsWaiting();<br><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">if</span> defined(WITH_CODE_GUARD_HANDLER) &amp;&amp; WITH_CODE_GUARD_HANDLER</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">CheckImageIntegrityAtRuntime</span><span class=\"hljs-params\">()</span></span>;<br>\tCheckImageIntegrityAtRuntime();<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">endif</span></span><br><br>\tDECLARE_SCOPE_CYCLE_COUNTER( TEXT( <span class=\"hljs-string\">&quot;CollectGarbageInternal&quot;</span> ), STAT_CollectGarbageInternal, STATGROUP_GC );<br>\tSTAT_ADD_CUSTOMMESSAGE_NAME( STAT_NamedMarker, TEXT( <span class=\"hljs-string\">&quot;GarbageCollection - Begin&quot;</span> ) );<br><br>\t<span class=\"hljs-comment\">// We can&#x27;t collect garbage while there&#x27;s a load in progress. E.g. one potential issue is Import.XObject</span><br>\tcheck(!IsLoading());<br><br>\t<span class=\"hljs-comment\">// Reset GC skip counter</span><br>\tGNumAttemptsSinceLastGC = <span class=\"hljs-number\">0</span>;<br><br>\t<span class=\"hljs-comment\">// Flush streaming before GC if requested</span><br>\t<span class=\"hljs-keyword\">if</span> (GFlushStreamingOnGC)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (IsAsyncLoading())<br>\t\t&#123;<br>\t\t\tUE_LOG(LogGarbage, Log, TEXT(<span class=\"hljs-string\">&quot;CollectGarbageInternal() is flushing async loading&quot;</span>));<br>\t\t&#125;<br>\t\tFGCCSyncObject::Get().GCUnlock();<br>\t\tFlushAsyncLoading();<br>\t\tFGCCSyncObject::Get().GCLock();<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// Route callbacks so we can ensure that we are e.g. not in the middle of loading something by flushing</span><br>\t<span class=\"hljs-comment\">// the async loading, etc...</span><br>\tFCoreUObjectDelegates::GetPreGarbageCollectDelegate().Broadcast();<br>\tGLastGCFrame = GFrameCounter;<br><br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// Set &#x27;I&#x27;m garbage collecting&#x27; flag - might be checked inside various functions.</span><br>\t\t<span class=\"hljs-comment\">// This has to be unlocked before we call post GC callbacks</span><br>\t\tFGCScopeLock GCLock;<br><br>\t\tUE_LOG(LogGarbage, Log, TEXT(<span class=\"hljs-string\">&quot;Collecting garbage%s&quot;</span>), IsAsyncLoading() ? TEXT(<span class=\"hljs-string\">&quot; while async loading&quot;</span>) : TEXT(<span class=\"hljs-string\">&quot;&quot;</span>));<br><br>\t\t<span class=\"hljs-comment\">// Make sure previous incremental purge has finished or we do a full purge pass in case we haven&#x27;t kicked one</span><br>\t\t<span class=\"hljs-comment\">// off yet since the last call to garbage collection.</span><br>\t\t<span class=\"hljs-keyword\">if</span> (GObjIncrementalPurgeIsInProgress || GObjPurgeIsRequired)<br>\t\t&#123;<br>\t\t\tIncrementalPurgeGarbage(<span class=\"hljs-literal\">false</span>);<br>\t\t\tFMemory::Trim();<br>\t\t&#125;<br>\t\tcheck(!GObjIncrementalPurgeIsInProgress);<br>\t\tcheck(!GObjPurgeIsRequired);<br><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">if</span> VERIFY_DISREGARD_GC_ASSUMPTIONS</span><br>\t\t<span class=\"hljs-comment\">// Only verify assumptions if option is enabled. This avoids false positives in the Editor or commandlets.</span><br>\t\t<span class=\"hljs-keyword\">if</span> ((GUObjectArray.DisregardForGCEnabled() || GUObjectClusters.GetNumAllocatedClusters()) &amp;&amp; GShouldVerifyGCAssumptions)<br>\t\t&#123;<br>\t\t\tDECLARE_SCOPE_CYCLE_COUNTER(TEXT(<span class=\"hljs-string\">&quot;CollectGarbageInternal.VerifyGCAssumptions&quot;</span>), STAT_CollectGarbageInternal_VerifyGCAssumptions, STATGROUP_GC);<br>\t\t\t<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">double</span> StartTime = FPlatformTime::Seconds();<br>\t\t\tVerifyGCAssumptions();<br>\t\t\tVerifyClustersAssumptions();<br>\t\t\tUE_LOG(LogGarbage, Log, TEXT(<span class=\"hljs-string\">&quot;%f ms for Verify GC Assumptions&quot;</span>), (FPlatformTime::Seconds() - StartTime) * <span class=\"hljs-number\">1000</span>);<br>\t\t&#125;<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">endif</span></span><br><br>\t\t<span class=\"hljs-comment\">// Fall back to single threaded GC if processor count is 1 or parallel GC is disabled</span><br>\t\t<span class=\"hljs-comment\">// or detailed per class gc stats are enabled (not thread safe)</span><br>\t\t<span class=\"hljs-comment\">// Temporarily forcing single-threaded GC in the editor until Modify() can be safely removed from HandleObjectReference.</span><br>\t\t<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">bool</span> bForceSingleThreadedGC = !FApp::ShouldUseThreadingForPerformance() || !FPlatformProcess::SupportsMultithreading() ||<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">if</span> PLATFORM_SUPPORTS_MULTITHREADED_GC</span><br>\t\t(FPlatformMisc::NumberOfCores() &lt; <span class=\"hljs-number\">2</span> || GAllowParallelGC == <span class=\"hljs-number\">0</span> || PERF_DETAILED_PER_CLASS_GC_STATS);<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">else</span>\t<span class=\"hljs-comment\">//PLATFORM_SUPPORTS_MULTITHREADED_GC</span></span><br>\t\t\t<span class=\"hljs-literal\">true</span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">endif</span>\t<span class=\"hljs-comment\">//PLATFORM_SUPPORTS_MULTITHREADED_GC</span></span><br><br>\t\t<span class=\"hljs-comment\">// Perform reachability analysis.</span><br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">double</span> StartTime = FPlatformTime::Seconds();<br>\t\t\tFRealtimeGC TagUsedRealtimeGC;<br>            <span class=\"hljs-comment\">//-----------------------------------------------------------</span><br>\t\t\tTagUsedRealtimeGC.PerformReachabilityAnalysis(KeepFlags, bForceSingleThreadedGC);<br>            <span class=\"hljs-comment\">//-----------------------------------------------------------</span><br>\t\t\tUE_LOG(LogGarbage, Log, TEXT(<span class=\"hljs-string\">&quot;%f ms for GC&quot;</span>), (FPlatformTime::Seconds() - StartTime) * <span class=\"hljs-number\">1000</span>);<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// Reconstruct clusters if needed</span><br>\t\t<span class=\"hljs-keyword\">if</span> (GUObjectClusters.ClustersNeedDissolving())<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">double</span> StartTime = FPlatformTime::Seconds();<br>\t\t\tGUObjectClusters.DissolveClusters();<br>\t\t\tUE_LOG(LogGarbage, Log, TEXT(<span class=\"hljs-string\">&quot;%f ms for dissolving GC clusters&quot;</span>), (FPlatformTime::Seconds() - StartTime) * <span class=\"hljs-number\">1000</span>);<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// Fire post-reachability analysis hooks</span><br>\t\tFCoreUObjectDelegates::PostReachabilityAnalysis.Broadcast();<br>\t\t<br>\t\t&#123;<br>\t\t\tFGCArrayPool::Get().ClearWeakReferences(bPerformFullPurge);<br><br>\t\t\tGatherUnreachableObjects(bForceSingleThreadedGC);<br><br>\t\t\t<span class=\"hljs-keyword\">if</span> (bPerformFullPurge || !GIncrementalBeginDestroyEnabled)<br>\t\t\t&#123;<br>\t\t\t\tUnhashUnreachableObjects(<span class=\"hljs-comment\">/**bUseTimeLimit = */</span> <span class=\"hljs-literal\">false</span>);<br>\t\t\t\tFScopedCBDProfile::DumpProfile();<br>\t\t\t&#125;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// Set flag to indicate that we are relying on a purge to be performed.</span><br>\t\tGObjPurgeIsRequired = <span class=\"hljs-literal\">true</span>;<br>\t\t<span class=\"hljs-comment\">// Reset purged count.</span><br>\t\tGPurgedObjectCountSinceLastMarkPhase = <span class=\"hljs-number\">0</span>;<br>\t\tGObjCurrentPurgeObjectIndexResetPastPermanent = <span class=\"hljs-literal\">true</span>;<br><br>\t\t<span class=\"hljs-comment\">// Perform a full purge by not using a time limit for the incremental purge. The Editor always does a full purge.</span><br>\t\t<span class=\"hljs-keyword\">if</span> (bPerformFullPurge || GIsEditor)<br>\t\t&#123;<br>\t\t\tIncrementalPurgeGarbage(<span class=\"hljs-literal\">false</span>);<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-keyword\">if</span> (bPerformFullPurge)<br>\t\t&#123;<br>\t\t\tShrinkUObjectHashTables();<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// Destroy all pending delete linkers</span><br>\t\tDeleteLoaders();<br><br>\t\t<span class=\"hljs-comment\">// Trim allocator memory</span><br>\t\tFMemory::Trim();<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// Route callbacks to verify GC assumptions</span><br>\tFCoreUObjectDelegates::GetPostGarbageCollect().Broadcast();<br><br>\tSTAT_ADD_CUSTOMMESSAGE_NAME( STAT_NamedMarker, TEXT( <span class=\"hljs-string\">&quot;GarbageCollection - End&quot;</span> ) );<br>&#125;<br><br></code></pre></td></tr></table></figure>\n<p>我在PerformReachabilityAnalysis函数处做了标记，GC时UE就是通过这个函数进行对象标记的，PerformReachabilityAnalysis函数会做多线程实时的分析对象的引用关系，然后标记出可达与不可达对象。标记是如何进行的还得深入到PerformReachabilityAnalysis函数，再上源码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * Performs reachability analysis.</span><br><span class=\"hljs-comment\">\t *</span><br><span class=\"hljs-comment\">\t * @param KeepFlags\t\tObjects with these flags will be kept regardless of being referenced or not</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">PerformReachabilityAnalysis</span><span class=\"hljs-params\">(EObjectFlags KeepFlags, <span class=\"hljs-keyword\">bool</span> bForceSingleThreaded = <span class=\"hljs-literal\">false</span>)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tLLM_SCOPE(ELLMTag::GC);<br><br>\t\tSCOPED_NAMED_EVENT(FRealtimeGC_PerformReachabilityAnalysis, FColor::Red);<br>\t\tDECLARE_SCOPE_CYCLE_COUNTER(TEXT(<span class=\"hljs-string\">&quot;FRealtimeGC::PerformReachabilityAnalysis&quot;</span>), STAT_FArchiveRealtimeGC_PerformReachabilityAnalysis, STATGROUP_GC);<br><br>\t\t<span class=\"hljs-comment\">/** Growing array of objects that require serialization */</span><br>\t\tFGCArrayStruct* ArrayStruct = FGCArrayPool::Get().GetArrayStructFromPool();<br>\t\tTArray&lt;UObject*&gt;&amp; ObjectsToSerialize = ArrayStruct-&gt;ObjectsToSerialize;<br><br>\t\t<span class=\"hljs-comment\">// Reset object count.</span><br>\t\tGObjectCountDuringLastMarkPhase.Reset();<br><br>\t\t<span class=\"hljs-comment\">// Make sure GC referencer object is checked for references to other objects even if it resides in permanent object pool</span><br>\t\t<span class=\"hljs-keyword\">if</span> (FPlatformProperties::RequiresCookedData() &amp;&amp; FGCObject::GGCObjectReferencer &amp;&amp; GUObjectArray.IsDisregardForGC(FGCObject::GGCObjectReferencer))<br>\t\t&#123;<br>\t\t\tObjectsToSerialize.Add(FGCObject::GGCObjectReferencer);<br>\t\t&#125;<br><br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">double</span> StartTime = FPlatformTime::Seconds();<br>\t\t\tMarkObjectsAsUnreachable(ObjectsToSerialize, KeepFlags, bForceSingleThreaded);<br>\t\t\tUE_LOG(LogGarbage, Verbose, TEXT(<span class=\"hljs-string\">&quot;%f ms for Mark Phase (%d Objects To Serialize&quot;</span>), (FPlatformTime::Seconds() - StartTime) * <span class=\"hljs-number\">1000</span>, ObjectsToSerialize.Num());<br>\t\t&#125;<br><br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">double</span> StartTime = FPlatformTime::Seconds();<br>\t\t\tPerformReachabilityAnalysisOnObjects(ArrayStruct, bForceSingleThreaded);<br>\t\t\tUE_LOG(LogGarbage, Verbose, TEXT(<span class=\"hljs-string\">&quot;%f ms for Reachability Analysis&quot;</span>), (FPlatformTime::Seconds() - StartTime) * <span class=\"hljs-number\">1000</span>);<br>\t\t&#125;<br>        <br>\t\t<span class=\"hljs-comment\">// Allowing external systems to add object roots. This can&#x27;t be done through AddReferencedObjects</span><br>\t\t<span class=\"hljs-comment\">// because it may require tracing objects (via FGarbageCollectionTracer) multiple times</span><br>\t\tFCoreUObjectDelegates::TraceExternalRootsForReachabilityAnalysis.Broadcast(*<span class=\"hljs-keyword\">this</span>, KeepFlags, bForceSingleThreaded);<br><br>\t\tFGCArrayPool::Get().ReturnToPool(ArrayStruct);<br><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">if</span> UE_BUILD_DEBUG</span><br>\t\tFGCArrayPool::Get().CheckLeaks();<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">endif</span></span><br>\t&#125;<br></code></pre></td></tr></table></figure>\n<p>首先前面的宏暂时可以忽略掉，</p>\n<p>第一步，<code>FGCArrayStruct* ArrayStruct = FGCArrayPool::Get().GetArrayStructFromPool();</code>UE将UObject的所有的强引用和弱引用都存储大ArrayStruct数据结构中，FGCArrayPool是UEGC的主要执行类</p>\n<p>第二步，<code>TArray&lt;UObject*&gt;&amp; ObjectsToSerialize = ArrayStruct-&gt;ObjectsToSerialize;</code>分离UObject的强引用到ObjectsToSerialize 数组中。</p>\n<p>这是FGCArrayStruct结构体的源码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">FGCArrayStruct</span></span><br><span class=\"hljs-class\">&#123;</span><br>\tTArray&lt;UObject*&gt; ObjectsToSerialize;<br>\tTArray&lt;UObject**&gt; WeakReferences;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>ObjectsToSerialize存储强引用，WeakReferences存储弱引用。</p>\n<p>第三步，<code>GObjectCountDuringLastMarkPhase.Reset();</code>重置对象的引用计数。</p>\n<p>第四步，通过一个if判断标记可达对象，于是可达对象与不可达对象就被标记出来了，接下来便是GC清理。</p>\n<h3 id=\"GC的触发\"><a href=\"#GC的触发\" class=\"headerlink\" title=\"GC的触发\"></a>GC的触发</h3><p>UE的GC发生在游戏线程上，支持多线程GC，和大多数主流语言的GC一样支持自动触发和手动触发。</p>\n<p><strong>手动触发</strong></p>\n<p>手动触发UE也提供了两种方式，其一是通过C++函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">GEngine-&gt;ForceGarbageCollection();<br></code></pre></td></tr></table></figure>\n<p>这里需要注意的是<code>GEngine</code>在<code>Engine.h</code>头文件下。</p>\n<p>手动触发的使用场景一般是在卸载某些资源后，手动触发GC回收这些资源在使用过程中的无用对象。</p>\n<p>其二是蓝图节点：</p>\n<p><img src=\"/2021/02/26/%E3%80%90UE4%E3%80%91UE4GamePlay%E6%9E%B6%E6%9E%84/Git\\Hexo\\source_posts\\【UE4】UE4GamePlay架构\\Snipaste_2021-03-19_21-54-55.png\"></p>\n<p>手动调用这两个函数，UE会跳过GC算法，在下一次Tick时直接进行GC。</p>\n<p><font color=\"red\"> 这里有一点需要注意，在大多数情况下，手动GC一般只能回收NewObject函数创建的对象，而UWorld()-&gt;SpawnActor函数创建的对象无论如何调用都无法销毁，这是因为，当UE创建一个Actor之后在UWorld中就已经保存了这个Actor的引用，所以无论我们如何释放Actor的引用，这个Actor的引用计数都不会归零，所以要销毁一个Actor还是需要通过Actor-&gt;Destroy()函数。</font></p>\n<p>我们可以个一个例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//AACtor.cpp</span><br>AActor1::AActor1()<br>&#123;<br>\tPrimaryActorTick.bCanEverTick = <span class=\"hljs-literal\">true</span>;<br>\tUE_LOG(LogTemp, Warning, TEXT(<span class=\"hljs-string\">&quot;Actor1 Created&quot;</span>));<br>&#125;<br><br>AActor1::~AActor1()<br>&#123;<br>\tUE_LOG(LogTemp, Warning, TEXT(<span class=\"hljs-string\">&quot;Actor1 Destryed&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//AMyActor.h</span><br>UCLASS()<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">INSIDEUE4_API</span> <span class=\"hljs-title\">AMyActor2</span> :</span> <span class=\"hljs-keyword\">public</span> AActor<br>&#123;<br>\tGENERATED_BODY()<br>\t<br><span class=\"hljs-keyword\">public</span>:\t<br>\tAMyActor2();<br>\tAActor1 *a;<span class=\"hljs-comment\">//注意这里没有加UPROPERTY()宏</span><br><br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">BeginPlay</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">override</span></span>;<br><br><span class=\"hljs-keyword\">public</span>:\t<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Tick</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">float</span> DeltaTime)</span> <span class=\"hljs-keyword\">override</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//AMyActor2</span><br>AMyActor2::AMyActor2()<br>&#123;<br>\tPrimaryActorTick.bCanEverTick = <span class=\"hljs-literal\">true</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">AMyActor2::BeginPlay</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tSuper::BeginPlay();<br>\ta = UWorld()-&gt;SpawnActor&lt;AActor1&gt;();<br>\ta = <span class=\"hljs-literal\">NULL</span>;<br>\tGEngine-&gt;ForceGarbageCollection();<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">AMyActor2::Tick</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">float</span> DeltaTime)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tSuper::Tick(DeltaTime);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>OutputLog:</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs groovy\"><span class=\"hljs-attr\">LogTemp:</span> <span class=\"hljs-attr\">Warning:</span> Actor1 Created<br></code></pre></td></tr></table></figure>\n<p>可以看到使用UWorld()-&gt;SpawnActor创建的Actor即使手动强制GC也没有被回收，因为这个Actor是可达对象。</p>\n<p><strong>自动触发</strong></p>\n<p>要想UE自动触发的GC能能够回收我们创建的对象，那么我们创建的对象就必须继承自UObject，至于加不加UPROPERTY()宏似乎不影响GC的回收，如下面的测试结果，还是以上面的例子为例，把BeginPlay函数改为如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//AMyActor2</span><br>AMyActor2::AMyActor2()<br>&#123;<br>\tPrimaryActorTick.bCanEverTick = <span class=\"hljs-literal\">true</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">AMyActor2::BeginPlay</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tSuper::BeginPlay();<br>\ta = NewObject&lt;AActor1&gt;();<br>\ta = <span class=\"hljs-literal\">NULL</span>;<br>\tGEngine-&gt;ForceGarbageCollection();<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">AMyActor2::Tick</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">float</span> DeltaTime)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tSuper::Tick(DeltaTime);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>我们将MyActor2拖入场景中，运行，OutputLog输出，可以找到下面两句：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">LogTemp: Warning: Actor1 Created<br><br>LogTemp: Warning: Actor1 Destryed<br></code></pre></td></tr></table></figure>\n<p>可以看到，没有使用UPROPERTY()宏的变量a依旧在手动GC时被回收了，这里为了效果明显点使用了手动强制回收，其实使用自动GC也是一样的。</p>\n<p><font color=\"green\">这里有提个疑问：</font></p>\n<p>当我们在一个继承自UObject的类组合一个继承自UObject的对象，如果在这个对象定义前没有使用UPROPERTY()宏，那么在Play后UE会调用一次这个对象的析构函数，但是这个对象依然可以被使用，而如果在定义这个对象前使用了UPROPERTY()宏，那么这对象将和组合类被析构时一起被析构。疑问为什么UE会调用一次被组合对象的析构且析构后依然可以使用这个对象。如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//UMyObject.cpp</span><br>UMyObject::UMyObject()<br>&#123;<br>\tUE_LOG(LogTemp, Warning, TEXT(<span class=\"hljs-string\">&quot;UMyObject Created&quot;</span>));<br>&#125;<br><br>UMyObject::~UMyObject()<br>&#123;<br>\tUE_LOG(LogTemp, Warning, TEXT(<span class=\"hljs-string\">&quot;UMyObject Destoryed&quot;</span>));<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">UMyObject::Fun</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tUE_LOG(LogTemp, Warning, TEXT(<span class=\"hljs-string\">&quot;UMyObject&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//AMyActor2.h</span><br>UCLASS()<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">INSIDEUE4_API</span> <span class=\"hljs-title\">AMyActor2</span> :</span> <span class=\"hljs-keyword\">public</span> AActor<br>&#123;<br>\tGENERATED_BODY()<br>\t<br><span class=\"hljs-keyword\">public</span>:\t<br>\tAMyActor2();<br>\tUPROPERTY()<br>\tUMyObject* obj;<br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">BeginPlay</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">override</span></span>;<br><br><span class=\"hljs-keyword\">public</span>:\t<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Tick</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">float</span> DeltaTime)</span> <span class=\"hljs-keyword\">override</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//AMyActor2.cpp</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">AMyActor2::BeginPlay</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tSuper::BeginPlay();<br>\tobj = NewObject&lt;UMyObject&gt;();<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>使用UPROPERTY()宏的输出结果：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//在点击Play后输出结果</span><br>LogTemp: Warning: AMyActor2 Created<br>LogTemp: Warning: UMyObject Created<br><span class=\"hljs-comment\">//再点击Stop后输出结果</span><br>LogTemp: Warning: UMyObject Destoryed<br>LogTemp: Warning: AMyActor2 Destroyed<br></code></pre></td></tr></table></figure>\n<p>不使用UPROPERTY()宏的输出结果：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//在点击Play后输出结果</span><br>LogTemp: Warning: AMyActor2 Created<br>LogTemp: Warning: UMyObject Created<br>LogTemp: Warning: UMyObject Destoryed<br><span class=\"hljs-comment\">//再点击Stop后输出结果</span><br>LogTemp: Warning: AMyActor2 Destroyed<br></code></pre></td></tr></table></figure>\n<p>很明显在Play后UMyObject对象的析构函数被调用了，但是此时如果继续访问UMyObject里的成员依旧可以访问。</p>\n<h3 id=\"TWeakObjectPtr、TWeakPtr（既保存引用又可GC）\"><a href=\"#TWeakObjectPtr、TWeakPtr（既保存引用又可GC）\" class=\"headerlink\" title=\"TWeakObjectPtr、TWeakPtr（既保存引用又可GC）\"></a>TWeakObjectPtr、TWeakPtr（既保存引用又可GC）</h3><p>有时我们可能需要在一个类里面临时保存一些对象，但是一旦保存了引用，就需要手动释放才能保证这些对象可以被GC自动回收，关于这个方面UE也贴心的为我们提供了<font color=\"red\"> TWeakObjectPtr</font>指针，当然，这也是C++弱指针的UE魔改办罢了，使用这个指针既可以引用对象，但是又不会造成引用计数+1。可以通过一个例子很好的看出来。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//AACtor1.cpp</span><br>AActor1::AActor1()<br>&#123;<br>\tPrimaryActorTick.bCanEverTick = <span class=\"hljs-literal\">true</span>;<br>\tUE_LOG(LogTemp, Warning, TEXT(<span class=\"hljs-string\">&quot;Actor1 Created&quot;</span>));<br>&#125;<br><br>AActor1::~AActor1()<br>&#123;<br>\tUE_LOG(LogTemp, Warning, TEXT(<span class=\"hljs-string\">&quot;Actor1 Destryed&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//AMyActor2</span><br>UCLASS()<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">INSIDEUE4_API</span> <span class=\"hljs-title\">AMyActor2</span> :</span> <span class=\"hljs-keyword\">public</span> AActor<br>&#123;<br>\tGENERATED_BODY()<br>\t<br><span class=\"hljs-keyword\">public</span>:\t<br>\tAMyActor2();<br>\tAActor1* a;<br>\tTWeakObjectPtr&lt;AActor1&gt; p;<br><br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">BeginPlay</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">override</span></span>;<br><br><span class=\"hljs-keyword\">public</span>:\t<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Tick</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">float</span> DeltaTime)</span> <span class=\"hljs-keyword\">override</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//AMyActor2.cpp/BeginPlay()</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">AMyActor2::BeginPlay</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tSuper::BeginPlay();<br>\ta = NewObject&lt;AActor1&gt;();<br>\tp = a;<br>\ta = <span class=\"hljs-literal\">NULL</span>;<br>\tGEngine-&gt;ForceGarbageCollection();<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>OutputLog:</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs groovy\"><span class=\"hljs-attr\">LogTemp:</span> <span class=\"hljs-attr\">Warning:</span> Actor1 Created<br><br><span class=\"hljs-attr\">LogTemp:</span> <span class=\"hljs-attr\">Warning:</span> Actor1 Destryed<br></code></pre></td></tr></table></figure>\n<p>可以看到，AActor1对象依旧被强制回收了。</p>\n<p>而TWeakPtr则对于自定义类的弱指针。</p>\n<p><font color=\"red\">注意：弱指针不可以被用来作为TSet或TMap的Key，因为一个对象被GC时无法通知一个容器的Key，但是可以用来作为容器的Value。</font></p>\n<h3 id=\"TSharedPtr、TSharedRef（自定义类的GC）\"><a href=\"#TSharedPtr、TSharedRef（自定义类的GC）\" class=\"headerlink\" title=\"TSharedPtr、TSharedRef（自定义类的GC）\"></a>TSharedPtr、TSharedRef（自定义类的GC）</h3><p>自定义类的GC，UE也贴心的提供了<font color=\"red\"> TSharedPtr和TSharedRef</font>对象来为自定义类支持GC，TSharedPtr本质上是一个被封装过的指针，使用形式上依然保留指针的风格。</p>\n<p><font color=\"red\"> 创建TSharedPtr指针指向一个自定义类时，需要使用<code>MakeShareable()</code>函数，如：</font></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">TSharedPtr&lt;UMyObject&gt; p = MakeShareable(NewObject&lt;UMyObject&gt;());<br>TSharedPtr&lt;FActor&gt; f = MakeShareable(<span class=\"hljs-keyword\">new</span> FActor());<br></code></pre></td></tr></table></figure>\n<p>TSharedPtr和TSharedRef都可以为自定义类提供GC功能，二者的区别只在于TSharedPtr可以为null，而SharedRef不可以。我在网上查询发现有三种方法构建TSharedRef，分别为：</p>\n<p>第一种：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">TSharedRef&lt;FActor&gt; <span class=\"hljs-title\">ref</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">new</span> FActor())</span></span>;<br></code></pre></td></tr></table></figure>\n<p>第二种：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">TSharedRef&lt;FActor&gt; ref = MakeShared&lt;FActor&gt;(<span class=\"hljs-keyword\">new</span> FActor());<br></code></pre></td></tr></table></figure>\n<p>第三种：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">TSharedPtr&lt;FActor&gt; ptr = MakeShareable&lt;FActor&gt;(<span class=\"hljs-keyword\">new</span> FActor());<br>TSharedRef&lt;FActor&gt; ref = ptr.ToSharedRef();<br></code></pre></td></tr></table></figure>\n<p>其中第二种方法在编写时没有任何问题但在编译时无法通过，并提示：</p>\n<figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs delphi\">The TSharedRef() <span class=\"hljs-function\"><span class=\"hljs-keyword\">constructor</span> <span class=\"hljs-title\">is</span> <span class=\"hljs-title\">for</span> <span class=\"hljs-title\">internal</span> <span class=\"hljs-title\">usage</span> <span class=\"hljs-title\">only</span> <span class=\"hljs-title\">for</span> <span class=\"hljs-title\">hot</span>-<span class=\"hljs-title\">reload</span> <span class=\"hljs-title\">purposes</span>. <span class=\"hljs-title\">Please</span> <span class=\"hljs-title\">do</span> <span class=\"hljs-title\">NOT</span> <span class=\"hljs-title\">use</span> <span class=\"hljs-title\">it</span>.</span><br></code></pre></td></tr></table></figure>\n<p>使用的编译环境为：UE4.22 + VS2017</p>\n<h3 id=\"FGCObject（在自定义类中控制UObject对象的GC）\"><a href=\"#FGCObject（在自定义类中控制UObject对象的GC）\" class=\"headerlink\" title=\"FGCObject（在自定义类中控制UObject对象的GC）\"></a>FGCObject（在自定义类中控制UObject对象的GC）</h3><p>当我们在一个自定义类中组合一个UObject对象时，如果不做特殊处理也会出现GC触发中发现的疑问，在自定义类没有被析构时，UObject的对象的析构函数就被调用了，但是对象依然可以被使用。目前没有发现这种情况会导致什么样的后果，但是作为一个合格的UE程序还是应该尽量避免这种情况的发生，那么在一个自定义类中组合一个UObject对象，应该如何控制UObject对象的GC呢？</p>\n<p>UE4提供了一个叫做<font color=\"red\">FGCObject</font>的类，位于<font color=\"red\">GCObject.h</font>头文件中，我们需要使自定义类继承自FGCObject类，然后再实现AddReferencedObjects函数，并在函数中通过Collector.AddReferencedObject()函数将所有的UObject对象UE4自动管理即可。</p>\n<p>如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">INSIDEUE4_API</span> <span class=\"hljs-title\">FActor</span> :</span> FGCObject<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\tFActor();<br>\t~FActor();<br>\tUMyObject* obj;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">AddReferencedObjects</span><span class=\"hljs-params\">(FReferenceCollector&amp; Collector)</span> <span class=\"hljs-keyword\">override</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tCollector.AddReferencedObject(obj);<br>\t&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>然后，UObject对象就会在FActor对象析构时才被析构。</p>\n<h2 id=\"2-序列化\"><a href=\"#2-序列化\" class=\"headerlink\" title=\"2.序列化\"></a>2.序列化</h2><h3 id=\"FObjectWriter和FObjectReader序列化对象到文件和从文件读取\"><a href=\"#FObjectWriter和FObjectReader序列化对象到文件和从文件读取\" class=\"headerlink\" title=\"FObjectWriter和FObjectReader序列化对象到文件和从文件读取\"></a>FObjectWriter和FObjectReader序列化对象到文件和从文件读取</h3><p>FObjectWriter可以将对象数据序列化为二进制流，然后配合FFileHelper将流写入文件即可实现对象状态存储到文件。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">AOperatActor::SaveObject</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tUSerializationObj* obj= NewObject&lt;USerializationObj&gt;();<br>\tUE_LOG(LogTemp, Warning, TEXT(<span class=\"hljs-string\">&quot;OldStr:%s&quot;</span>), *obj-&gt;str);<br>\tobj-&gt;str = TEXT(<span class=\"hljs-string\">&quot;OperatActor&quot;</span>);<br>\tTArray&lt;uint8&gt; bytes;<br>\tFObjectWriter(obj, bytes);\t<br>\tFFileHelper::SaveArrayToFile(bytes, *FString(<span class=\"hljs-string\">&quot;D:\\\\Goulandis\\\\UE4\\\\MyProject\\\\obj.txt&quot;</span>));\t<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>配合FFileHelper将文件中的对象状态读入字节数组，FObjectReader就可以将字节数组中的对象状态写入新的对象中。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">USerializationObj* <span class=\"hljs-title\">AOperatActor::LoadObject</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tUSerializationObj* newObj = NewObject&lt;USerializationObj&gt;();<br>\tTArray&lt;uint8&gt; bytes;<br>\tFFileHelper::LoadFileToArray(bytes, *FString(<span class=\"hljs-string\">&quot;D:\\\\Goulandis\\\\UE4\\\\MyProject\\\\obj.txt&quot;</span>));<br>\t<span class=\"hljs-function\">FObjectReader <span class=\"hljs-title\">reader</span><span class=\"hljs-params\">(newObj, bytes)</span></span>;<br>\tUE_LOG(LogTemp, Warning, TEXT(<span class=\"hljs-string\">&quot;NewStr:%s&quot;</span>), *newObj-&gt;str);<br>\t<span class=\"hljs-keyword\">return</span> newObj;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>看一下运行结果：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210512145024267.png#pic_center\"></p>\n<p>可以看到，新创建的USerializationObj对象的状态是被修改过后的状态。</p>\n<p>Actor的使用方式和UObject是一样的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">AOperatActor::SaveActor</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tASerializationActor* actor = GetWorld()-&gt;SpawnActor&lt;ASerializationActor&gt;();<br>\tUE_LOG(LogTemp, Warning, TEXT(<span class=\"hljs-string\">&quot;OldStr:%s&quot;</span>), *actor-&gt;str);<br>\tactor-&gt;str = TEXT(<span class=\"hljs-string\">&quot;NewActor&quot;</span>);<br>\tTArray&lt;uint8&gt; bytes;<br>\tFObjectWriter(actor, bytes);<br>\tFFileHelper::SaveArrayToFile(bytes, *FString(<span class=\"hljs-string\">&quot;D:\\\\Goulandis\\\\UE4\\\\MyProject\\\\actor.txt&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">ASerializationActor * <span class=\"hljs-title\">AOperatActor::LoadActor</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tASerializationActor* actor = GetWorld()-&gt;SpawnActor&lt;ASerializationActor&gt;();<br>\tTArray&lt;uint8&gt; bytes;<br>\tFFileHelper::LoadFileToArray(bytes, *FString(<span class=\"hljs-string\">&quot;D:\\\\Goulandis\\\\UE4\\\\MyProject\\\\actor.txt&quot;</span>));<br>\t<span class=\"hljs-function\">FObjectReader <span class=\"hljs-title\">reader</span><span class=\"hljs-params\">(actor,bytes)</span></span>;<br>\tUE_LOG(LogTemp, Warning, TEXT(<span class=\"hljs-string\">&quot;NewStr:%s&quot;</span>), *actor-&gt;str);<br>\t<span class=\"hljs-keyword\">return</span> actor;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210512145820162.png#pic_center\"></p>\n<h2 id=\"3-反射\"><a href=\"#3-反射\" class=\"headerlink\" title=\"3.反射\"></a>3.反射</h2><h3 id=\"搜索所有的Object\"><a href=\"#搜索所有的Object\" class=\"headerlink\" title=\"搜索所有的Object\"></a>搜索所有的Object</h3><p>C++本身的反射系统RTTI相当薄弱，所以UE在C++的基础上借助UObject自己实现了一套反射系统，同时借鉴了C#的长处提供了一系列反射用的系统函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">TArray&lt;UObject*&gt; result;<br>GetObjectsOfClass(UClass::StaticClass(), result);   <span class=\"hljs-comment\">//获取所有的class和interface</span><br>GetObjectsOfClass(UEnum::StaticClass(), result);   <span class=\"hljs-comment\">//获取所有的enum</span><br>GetObjectsOfClass(UScriptStruct::StaticClass(), result);   <span class=\"hljs-comment\">//获取所有的struct</span><br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"运行时创建对象\"><a href=\"#运行时创建对象\" class=\"headerlink\" title=\"运行时创建对象\"></a>运行时创建对象</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">AOperatActor::FindSerializationObj</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tUClass* uclass = FindObject&lt;UClass&gt;(ANY_PACKAGE, TEXT(<span class=\"hljs-string\">&quot;SerializationObj&quot;</span>));<br>\tUSerializationObj* obj = Cast&lt;USerializationObj&gt;(uclass-&gt;GetDefaultObject());<br>\tobj-&gt;PrintStr();<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>UE4提供FindObject模板函数来搜索指定的类的类型信息，返回的类型元素据通过UClass类型对象存储，UClass对象就是UE4专门用来存储元数据的类型，UClass中提供了大量的方法来操作元数据，<a href=\"https://docs.unrealengine.com/en-US/API/Runtime/CoreUObject/UObject/UClass/index.html\">UClass</a>，这里使用GetDefaultObject函数调用默认的构造函数创建SerializationObj类型的对象，需要注意的是GetDefaultObject返回的是一个UObject对象，所以需要使用Cast来做类型转换。</p>\n<p>热加载</p>"},{"title":"【C++】C++11新特性","date":"2021-03-17T07:12:33.000Z","password":null,"abstract":null,"message":null,"_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n\n\n<!--more-->\n\n# 一、auto类型推导\n\nauto这个关键字其实在C++11之前就已经存在了，在C++98中的auto关键字的作用是指明变量的存储类型，与static相对，在比较老C++书籍中可以找得到相关内容，只是在我们的实际编程中基本上被忽略，这是因为我们在创建变量时默认的存储类型就是auto—自动存储类型的，不需要显示表示，只有在需要声明静态变量时才会显示表示static，以指明变量的存储类型为静态存储类型。如：\n\n```c++\nauto int a = 0;\nint b = 0;\nstatic int c = 0;\n```\n\n这里a和b的存储类型都是auto类型。\n\n在C++11之后，C++标准摒弃了C++98的auto关键字的用法，将auto关键字的功能换成了自动类型推导，就和现在大多数脚本语言中的var一样。\n\n<font color=red> 需要注意的是，在自动类型推导中，小数会被默认推导成double类型而不是float。</font>\n\nauto的出现并不意味着C++变成了弱类型语言，auto在程序中仅仅只起到占位符的作用，在编译期间它才会被替换成具体的类型，所以在运行时类型依然是明确的。\n\n<font color=red>auto关键字支持多变量声明，但是同时声明的变量必须是同一类型的，否则会出现编译不通过的错误。</font>如：\n\n```c++\nauto a = 1,b = 1.1;\n```\n\n这种情况会报错。\n\n<font color=red> 在声明auto变量时，必须对变量进行初始化。</font>这种情况是语法错误：\n\n```c++\nauto a,b;\n```\n\n## auto、指针与引用\n\n先来看一个例子：\n\n```c++\nint a = 0;\nauto *p1 = &a;\nauto p2 = &a;\nauto p3 = p1;\nauto &r1 = a;\nauto r2 = r1;\n\n\ncout << typeid(p1).name() << endl;\ncout << typeid(p2).name() << endl;\ncout << typeid(p3).name() << endl;\ncout << typeid(r1).name() << endl;\ncout << typeid(r2).name() << endl;\n```\n\n输出结果：\n\n```c++\nint *\nint *\nint *\nint\nint\n```\n\n可以看到<font color =red>auto推导出了指针类型，却忽略了&类型</font>，这一点是需要注意的。\n\n## auto与const\n\n还是先来看一个例子：\n\n```c++\nconst int a = 0;\nauto c1 = a;\nconst auto c2 = a;\nconst auto *p = &a;\nconst auto &r1 = a;\nauto &r2 = r1;\n\t\ncout << typeid(c1).name() << endl;\ncout << typeid(c2).name() << endl;\ncout << typeid(p).name() << endl;\ncout << typeid(r1).name() << endl;\ncout << typeid(r2).name() << endl;\n```\n\n输出结果：\n\n```c++\nint\nint\nint const *\nint\nint\n```\n\n可以看到除了指针类型，其他的都被推导成了int类型，我们再在上面的代码中加一些代码：\n\n```c++\nconst int a = 0;\nauto c1 = a;\nconst auto c2 = a;\nconst auto *p = &a;\nconst auto &r1 = a;\nauto &r2 = r1;\n\t\ncout << typeid(c1).name() << endl;\ncout << typeid(c2).name() << endl;\ncout << typeid(p).name() << endl;\ncout << typeid(r1).name() << endl;\ncout << typeid(r2).name() << endl;\n\t\nint b = 0;\nc1 = 2;\nc2 = 2;\np = b;\nr1 = 2;\nr2 = 2;\n```\n\n当我们添加了这段代码之后，除了`c1=2`，其他的行都会报语法错误，所以尽c2，r1，r2被推导为int类型，但是const的约束依旧存在，但是c1没有报语法错误，也就是说c1实际上是非const类型，即`auto c1 = a`，在默认情况下auto将c1推导为非常量，如果需要设置为常量则需要显示标识const。\n\n关于`typeid().name()` 有一点很迷，就是在C++的语法中，只有常量指针类型在类型名上带有const，如上面的int const *，而其他的无论是指针常量、常量引用在类型上都是忽略const的，但是在我们把一个变量常量的地址赋予一个非常量指针时，则会报：\n\n![](【UE4】UE4GamePlay架构\\Snipaste_2021-03-18_14-34-58.png)\n\n在网上没有找到相关的解析，推测在C++语法上是只有常量指针类型带有const，没有其他的带有const的类型的，而出现上面的提示十有八九是编辑器做的，而非C++本身的。\n\n## 总结\n\n- auto的作用是类型推导，本质是占位符，在编译阶段，编译器会将正确的类型替换到auto位置上；\n- auto可以和任何类型搭配，包括指针与引用；\n- 在声明auto变量时必须对uto变量初始化；\n- auto关键字可以用作函数返回值类型。\n\n# 二、decltype类型推导\n\n由于auto的使用在有些方面上收到限制，比如，声明auto变量时必须对变量进行初始化，而在实际使用时，可能没法进行初始化，于是decltype就出现了，decltype也是C++的一个关键字。\n\ndecltype通过表达式来推导类型，表达式可以是一个变量、常量、或者函数，使用形式为`decltype(exp),exp为表达式`如：\n\n```c++\nauto fun(int* a)\n{\n\treturn *a * 0.2f;\n}\n\nint main()\n{\n\tint b = 0;\n\tdecltype(fun(&b)) a;\n}\n```\n\n和auto一样decltype也可以用作函数返回值类型。\n\n## decltype与auto的区别\n\n- auto关键字声明的变量必须初始化，decltype不需要；\n- auto在类中只能用于定义静态成员，decltype可以用于任何成员；\n- decltype的使用上比auto更灵活；\n- auto更具初始值来推导类型，decltype根据表达式来推导类型。\n\n# 三、返回类型后置语法\n\n有时候我们写函数需要用到函数参数来推导，由于C++的返回值是前置语法，所以返回值是无法使用函数参数的，于是便有了返回值类型后置语法，先看一个例子：\n\n```c++\ntemplate<typename T,typename U>\nauto fun(T a,U b)->decltype(a+b)\n{\n\treturn a+b;\n}\n```\n\n返回值类型后置语法可以将decltype使用参数推导出的类型赋予auto中，所以在这个语法中auto，decltype是必不可少的。\n\n我们仔细思考后会发现好像直接这样使用也是可以达到最终效果的：\n\n```c++\ntemplate<typename T,typename U>\nauto fun(T a,U b)\n{\n\treturn a+b;\n}\n```\n\n那么返回值后置类型语法的作用又是什么呢？事实上我们在多想一下就会明白，`auto fun(T a,U b)->decltype(a+b)`语法把auto的类型限制在decltype(a+b)的推导类型的范围内了，而auto fun(T a,U b)中auto是可以为任何类型的。但是在大多数使用场景下似乎还是没什么区别。\n\n到这里只有一句感叹，C++在类型推导上相较于主流脚本语言的类型推导还是薄弱了很多很多。\n\n# 四、左值与右值","source":"_posts/【C++】C++11新特性.md","raw":"---\ntitle: 【C++】C++11新特性\ndate: 2021-03-17 15:12:33\ntags: CPlus\ncategories: 知识记录\npassword:\nabstract:\nmessage:\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n\n\n<!--more-->\n\n# 一、auto类型推导\n\nauto这个关键字其实在C++11之前就已经存在了，在C++98中的auto关键字的作用是指明变量的存储类型，与static相对，在比较老C++书籍中可以找得到相关内容，只是在我们的实际编程中基本上被忽略，这是因为我们在创建变量时默认的存储类型就是auto—自动存储类型的，不需要显示表示，只有在需要声明静态变量时才会显示表示static，以指明变量的存储类型为静态存储类型。如：\n\n```c++\nauto int a = 0;\nint b = 0;\nstatic int c = 0;\n```\n\n这里a和b的存储类型都是auto类型。\n\n在C++11之后，C++标准摒弃了C++98的auto关键字的用法，将auto关键字的功能换成了自动类型推导，就和现在大多数脚本语言中的var一样。\n\n<font color=red> 需要注意的是，在自动类型推导中，小数会被默认推导成double类型而不是float。</font>\n\nauto的出现并不意味着C++变成了弱类型语言，auto在程序中仅仅只起到占位符的作用，在编译期间它才会被替换成具体的类型，所以在运行时类型依然是明确的。\n\n<font color=red>auto关键字支持多变量声明，但是同时声明的变量必须是同一类型的，否则会出现编译不通过的错误。</font>如：\n\n```c++\nauto a = 1,b = 1.1;\n```\n\n这种情况会报错。\n\n<font color=red> 在声明auto变量时，必须对变量进行初始化。</font>这种情况是语法错误：\n\n```c++\nauto a,b;\n```\n\n## auto、指针与引用\n\n先来看一个例子：\n\n```c++\nint a = 0;\nauto *p1 = &a;\nauto p2 = &a;\nauto p3 = p1;\nauto &r1 = a;\nauto r2 = r1;\n\n\ncout << typeid(p1).name() << endl;\ncout << typeid(p2).name() << endl;\ncout << typeid(p3).name() << endl;\ncout << typeid(r1).name() << endl;\ncout << typeid(r2).name() << endl;\n```\n\n输出结果：\n\n```c++\nint *\nint *\nint *\nint\nint\n```\n\n可以看到<font color =red>auto推导出了指针类型，却忽略了&类型</font>，这一点是需要注意的。\n\n## auto与const\n\n还是先来看一个例子：\n\n```c++\nconst int a = 0;\nauto c1 = a;\nconst auto c2 = a;\nconst auto *p = &a;\nconst auto &r1 = a;\nauto &r2 = r1;\n\t\ncout << typeid(c1).name() << endl;\ncout << typeid(c2).name() << endl;\ncout << typeid(p).name() << endl;\ncout << typeid(r1).name() << endl;\ncout << typeid(r2).name() << endl;\n```\n\n输出结果：\n\n```c++\nint\nint\nint const *\nint\nint\n```\n\n可以看到除了指针类型，其他的都被推导成了int类型，我们再在上面的代码中加一些代码：\n\n```c++\nconst int a = 0;\nauto c1 = a;\nconst auto c2 = a;\nconst auto *p = &a;\nconst auto &r1 = a;\nauto &r2 = r1;\n\t\ncout << typeid(c1).name() << endl;\ncout << typeid(c2).name() << endl;\ncout << typeid(p).name() << endl;\ncout << typeid(r1).name() << endl;\ncout << typeid(r2).name() << endl;\n\t\nint b = 0;\nc1 = 2;\nc2 = 2;\np = b;\nr1 = 2;\nr2 = 2;\n```\n\n当我们添加了这段代码之后，除了`c1=2`，其他的行都会报语法错误，所以尽c2，r1，r2被推导为int类型，但是const的约束依旧存在，但是c1没有报语法错误，也就是说c1实际上是非const类型，即`auto c1 = a`，在默认情况下auto将c1推导为非常量，如果需要设置为常量则需要显示标识const。\n\n关于`typeid().name()` 有一点很迷，就是在C++的语法中，只有常量指针类型在类型名上带有const，如上面的int const *，而其他的无论是指针常量、常量引用在类型上都是忽略const的，但是在我们把一个变量常量的地址赋予一个非常量指针时，则会报：\n\n![](【UE4】UE4GamePlay架构\\Snipaste_2021-03-18_14-34-58.png)\n\n在网上没有找到相关的解析，推测在C++语法上是只有常量指针类型带有const，没有其他的带有const的类型的，而出现上面的提示十有八九是编辑器做的，而非C++本身的。\n\n## 总结\n\n- auto的作用是类型推导，本质是占位符，在编译阶段，编译器会将正确的类型替换到auto位置上；\n- auto可以和任何类型搭配，包括指针与引用；\n- 在声明auto变量时必须对uto变量初始化；\n- auto关键字可以用作函数返回值类型。\n\n# 二、decltype类型推导\n\n由于auto的使用在有些方面上收到限制，比如，声明auto变量时必须对变量进行初始化，而在实际使用时，可能没法进行初始化，于是decltype就出现了，decltype也是C++的一个关键字。\n\ndecltype通过表达式来推导类型，表达式可以是一个变量、常量、或者函数，使用形式为`decltype(exp),exp为表达式`如：\n\n```c++\nauto fun(int* a)\n{\n\treturn *a * 0.2f;\n}\n\nint main()\n{\n\tint b = 0;\n\tdecltype(fun(&b)) a;\n}\n```\n\n和auto一样decltype也可以用作函数返回值类型。\n\n## decltype与auto的区别\n\n- auto关键字声明的变量必须初始化，decltype不需要；\n- auto在类中只能用于定义静态成员，decltype可以用于任何成员；\n- decltype的使用上比auto更灵活；\n- auto更具初始值来推导类型，decltype根据表达式来推导类型。\n\n# 三、返回类型后置语法\n\n有时候我们写函数需要用到函数参数来推导，由于C++的返回值是前置语法，所以返回值是无法使用函数参数的，于是便有了返回值类型后置语法，先看一个例子：\n\n```c++\ntemplate<typename T,typename U>\nauto fun(T a,U b)->decltype(a+b)\n{\n\treturn a+b;\n}\n```\n\n返回值类型后置语法可以将decltype使用参数推导出的类型赋予auto中，所以在这个语法中auto，decltype是必不可少的。\n\n我们仔细思考后会发现好像直接这样使用也是可以达到最终效果的：\n\n```c++\ntemplate<typename T,typename U>\nauto fun(T a,U b)\n{\n\treturn a+b;\n}\n```\n\n那么返回值后置类型语法的作用又是什么呢？事实上我们在多想一下就会明白，`auto fun(T a,U b)->decltype(a+b)`语法把auto的类型限制在decltype(a+b)的推导类型的范围内了，而auto fun(T a,U b)中auto是可以为任何类型的。但是在大多数使用场景下似乎还是没什么区别。\n\n到这里只有一句感叹，C++在类型推导上相较于主流脚本语言的类型推导还是薄弱了很多很多。\n\n# 四、左值与右值","slug":"【C++】C++11新特性","published":1,"updated":"2021-03-18T09:23:18.369Z","_id":"ckmd48me60000nwr70ydedtft","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n\n\n<a id=\"more\"></a>\n\n<h1 id=\"一、auto类型推导\"><a href=\"#一、auto类型推导\" class=\"headerlink\" title=\"一、auto类型推导\"></a>一、auto类型推导</h1><p>auto这个关键字其实在C++11之前就已经存在了，在C++98中的auto关键字的作用是指明变量的存储类型，与static相对，在比较老C++书籍中可以找得到相关内容，只是在我们的实际编程中基本上被忽略，这是因为我们在创建变量时默认的存储类型就是auto—自动存储类型的，不需要显示表示，只有在需要声明静态变量时才会显示表示static，以指明变量的存储类型为静态存储类型。如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">auto</span> <span class=\"hljs-keyword\">int</span> a = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">int</span> b = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> c = <span class=\"hljs-number\">0</span>;<br></code></pre></td></tr></table></figure>\n<p>这里a和b的存储类型都是auto类型。</p>\n<p>在C++11之后，C++标准摒弃了C++98的auto关键字的用法，将auto关键字的功能换成了自动类型推导，就和现在大多数脚本语言中的var一样。</p>\n<p><font color=\"red\"> 需要注意的是，在自动类型推导中，小数会被默认推导成double类型而不是float。</font></p>\n<p>auto的出现并不意味着C++变成了弱类型语言，auto在程序中仅仅只起到占位符的作用，在编译期间它才会被替换成具体的类型，所以在运行时类型依然是明确的。</p>\n<p><font color=\"red\">auto关键字支持多变量声明，但是同时声明的变量必须是同一类型的，否则会出现编译不通过的错误。</font>如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">auto</span> a = <span class=\"hljs-number\">1</span>,b = <span class=\"hljs-number\">1.1</span>;<br></code></pre></td></tr></table></figure>\n<p>这种情况会报错。</p>\n<p><font color=\"red\"> 在声明auto变量时，必须对变量进行初始化。</font>这种情况是语法错误：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">auto</span> a,b;<br></code></pre></td></tr></table></figure>\n<h2 id=\"auto、指针与引用\"><a href=\"#auto、指针与引用\" class=\"headerlink\" title=\"auto、指针与引用\"></a>auto、指针与引用</h2><p>先来看一个例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">int</span> a = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">auto</span> *p1 = &amp;a;<br><span class=\"hljs-keyword\">auto</span> p2 = &amp;a;<br><span class=\"hljs-keyword\">auto</span> p3 = p1;<br><span class=\"hljs-keyword\">auto</span> &amp;r1 = a;<br><span class=\"hljs-keyword\">auto</span> r2 = r1;<br><br><br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-keyword\">typeid</span>(p1).name() &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-keyword\">typeid</span>(p2).name() &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-keyword\">typeid</span>(p3).name() &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-keyword\">typeid</span>(r1).name() &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-keyword\">typeid</span>(r2).name() &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">int</span> *<br><span class=\"hljs-keyword\">int</span> *<br><span class=\"hljs-keyword\">int</span> *<br><span class=\"hljs-keyword\">int</span><br><span class=\"hljs-keyword\">int</span><br></code></pre></td></tr></table></figure>\n<p>可以看到<font color=\"red\">auto推导出了指针类型，却忽略了&amp;类型</font>，这一点是需要注意的。</p>\n<h2 id=\"auto与const\"><a href=\"#auto与const\" class=\"headerlink\" title=\"auto与const\"></a>auto与const</h2><p>还是先来看一个例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">int</span> a = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">auto</span> c1 = a;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">auto</span> c2 = a;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">auto</span> *p = &amp;a;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">auto</span> &amp;r1 = a;<br><span class=\"hljs-keyword\">auto</span> &amp;r2 = r1;<br>\t<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-keyword\">typeid</span>(c1).name() &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-keyword\">typeid</span>(c2).name() &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-keyword\">typeid</span>(p).name() &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-keyword\">typeid</span>(r1).name() &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-keyword\">typeid</span>(r2).name() &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">int</span><br><span class=\"hljs-keyword\">int</span><br><span class=\"hljs-keyword\">int</span> <span class=\"hljs-keyword\">const</span> *<br><span class=\"hljs-keyword\">int</span><br><span class=\"hljs-keyword\">int</span><br></code></pre></td></tr></table></figure>\n<p>可以看到除了指针类型，其他的都被推导成了int类型，我们再在上面的代码中加一些代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">int</span> a = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">auto</span> c1 = a;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">auto</span> c2 = a;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">auto</span> *p = &amp;a;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">auto</span> &amp;r1 = a;<br><span class=\"hljs-keyword\">auto</span> &amp;r2 = r1;<br>\t<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-keyword\">typeid</span>(c1).name() &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-keyword\">typeid</span>(c2).name() &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-keyword\">typeid</span>(p).name() &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-keyword\">typeid</span>(r1).name() &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-keyword\">typeid</span>(r2).name() &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t<br><span class=\"hljs-keyword\">int</span> b = <span class=\"hljs-number\">0</span>;<br>c1 = <span class=\"hljs-number\">2</span>;<br>c2 = <span class=\"hljs-number\">2</span>;<br>p = b;<br>r1 = <span class=\"hljs-number\">2</span>;<br>r2 = <span class=\"hljs-number\">2</span>;<br></code></pre></td></tr></table></figure>\n<p>当我们添加了这段代码之后，除了<code>c1=2</code>，其他的行都会报语法错误，所以尽c2，r1，r2被推导为int类型，但是const的约束依旧存在，但是c1没有报语法错误，也就是说c1实际上是非const类型，即<code>auto c1 = a</code>，在默认情况下auto将c1推导为非常量，如果需要设置为常量则需要显示标识const。</p>\n<p>关于<code>typeid().name()</code> 有一点很迷，就是在C++的语法中，只有常量指针类型在类型名上带有const，如上面的int const *，而其他的无论是指针常量、常量引用在类型上都是忽略const的，但是在我们把一个变量常量的地址赋予一个非常量指针时，则会报：</p>\n<p><img src=\"/2021/03/17/%E3%80%90C++%E3%80%91C++11%E6%96%B0%E7%89%B9%E6%80%A7/%E3%80%90UE4%E3%80%91UE4GamePlay%E6%9E%B6%E6%9E%84%5CSnipaste_2021-03-18_14-34-58.png\"></p>\n<p>在网上没有找到相关的解析，推测在C++语法上是只有常量指针类型带有const，没有其他的带有const的类型的，而出现上面的提示十有八九是编辑器做的，而非C++本身的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>auto的作用是类型推导，本质是占位符，在编译阶段，编译器会将正确的类型替换到auto位置上；</li>\n<li>auto可以和任何类型搭配，包括指针与引用；</li>\n<li>在声明auto变量时必须对uto变量初始化；</li>\n<li>auto关键字可以用作函数返回值类型。</li>\n</ul>\n<h1 id=\"二、decltype类型推导\"><a href=\"#二、decltype类型推导\" class=\"headerlink\" title=\"二、decltype类型推导\"></a>二、decltype类型推导</h1><p>由于auto的使用在有些方面上收到限制，比如，声明auto变量时必须对变量进行初始化，而在实际使用时，可能没法进行初始化，于是decltype就出现了，decltype也是C++的一个关键字。</p>\n<p>decltype通过表达式来推导类型，表达式可以是一个变量、常量、或者函数，使用形式为<code>decltype(exp),exp为表达式</code>如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">auto</span> <span class=\"hljs-title\">fun</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>* a)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> *a * <span class=\"hljs-number\">0.2f</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">int</span> b = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">decltype</span>(fun(&amp;b)) a;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>和auto一样decltype也可以用作函数返回值类型。</p>\n<h2 id=\"decltype与auto的区别\"><a href=\"#decltype与auto的区别\" class=\"headerlink\" title=\"decltype与auto的区别\"></a>decltype与auto的区别</h2><ul>\n<li>auto关键字声明的变量必须初始化，decltype不需要；</li>\n<li>auto在类中只能用于定义静态成员，decltype可以用于任何成员；</li>\n<li>decltype的使用上比auto更灵活；</li>\n<li>auto更具初始值来推导类型，decltype根据表达式来推导类型。</li>\n</ul>\n<h1 id=\"三、返回类型后置语法\"><a href=\"#三、返回类型后置语法\" class=\"headerlink\" title=\"三、返回类型后置语法\"></a>三、返回类型后置语法</h1><p>有时候我们写函数需要用到函数参数来推导，由于C++的返回值是前置语法，所以返回值是无法使用函数参数的，于是便有了返回值类型后置语法，先看一个例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T,<span class=\"hljs-keyword\">typename</span> U&gt;<br>auto fun(T a,U b)-&gt;decltype(a+b)<br>&#123;<br>\t<span class=\"hljs-keyword\">return</span> a+b;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>返回值类型后置语法可以将decltype使用参数推导出的类型赋予auto中，所以在这个语法中auto，decltype是必不可少的。</p>\n<p>我们仔细思考后会发现好像直接这样使用也是可以达到最终效果的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T,<span class=\"hljs-keyword\">typename</span> U&gt;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">auto</span> <span class=\"hljs-title\">fun</span><span class=\"hljs-params\">(T a,U b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> a+b;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>那么返回值后置类型语法的作用又是什么呢？事实上我们在多想一下就会明白，<code>auto fun(T a,U b)-&gt;decltype(a+b)</code>语法把auto的类型限制在decltype(a+b)的推导类型的范围内了，而auto fun(T a,U b)中auto是可以为任何类型的。但是在大多数使用场景下似乎还是没什么区别。</p>\n<p>到这里只有一句感叹，C++在类型推导上相较于主流脚本语言的类型推导还是薄弱了很多很多。</p>\n<h1 id=\"四、左值与右值\"><a href=\"#四、左值与右值\" class=\"headerlink\" title=\"四、左值与右值\"></a>四、左值与右值</h1>","site":{"data":{}},"excerpt":"<meta name=\"referrer\" content=\"no-referrer\">","more":"<h1 id=\"一、auto类型推导\"><a href=\"#一、auto类型推导\" class=\"headerlink\" title=\"一、auto类型推导\"></a>一、auto类型推导</h1><p>auto这个关键字其实在C++11之前就已经存在了，在C++98中的auto关键字的作用是指明变量的存储类型，与static相对，在比较老C++书籍中可以找得到相关内容，只是在我们的实际编程中基本上被忽略，这是因为我们在创建变量时默认的存储类型就是auto—自动存储类型的，不需要显示表示，只有在需要声明静态变量时才会显示表示static，以指明变量的存储类型为静态存储类型。如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">auto</span> <span class=\"hljs-keyword\">int</span> a = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">int</span> b = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> c = <span class=\"hljs-number\">0</span>;<br></code></pre></td></tr></table></figure>\n<p>这里a和b的存储类型都是auto类型。</p>\n<p>在C++11之后，C++标准摒弃了C++98的auto关键字的用法，将auto关键字的功能换成了自动类型推导，就和现在大多数脚本语言中的var一样。</p>\n<p><font color=\"red\"> 需要注意的是，在自动类型推导中，小数会被默认推导成double类型而不是float。</font></p>\n<p>auto的出现并不意味着C++变成了弱类型语言，auto在程序中仅仅只起到占位符的作用，在编译期间它才会被替换成具体的类型，所以在运行时类型依然是明确的。</p>\n<p><font color=\"red\">auto关键字支持多变量声明，但是同时声明的变量必须是同一类型的，否则会出现编译不通过的错误。</font>如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">auto</span> a = <span class=\"hljs-number\">1</span>,b = <span class=\"hljs-number\">1.1</span>;<br></code></pre></td></tr></table></figure>\n<p>这种情况会报错。</p>\n<p><font color=\"red\"> 在声明auto变量时，必须对变量进行初始化。</font>这种情况是语法错误：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">auto</span> a,b;<br></code></pre></td></tr></table></figure>\n<h2 id=\"auto、指针与引用\"><a href=\"#auto、指针与引用\" class=\"headerlink\" title=\"auto、指针与引用\"></a>auto、指针与引用</h2><p>先来看一个例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">int</span> a = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">auto</span> *p1 = &amp;a;<br><span class=\"hljs-keyword\">auto</span> p2 = &amp;a;<br><span class=\"hljs-keyword\">auto</span> p3 = p1;<br><span class=\"hljs-keyword\">auto</span> &amp;r1 = a;<br><span class=\"hljs-keyword\">auto</span> r2 = r1;<br><br><br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-keyword\">typeid</span>(p1).name() &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-keyword\">typeid</span>(p2).name() &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-keyword\">typeid</span>(p3).name() &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-keyword\">typeid</span>(r1).name() &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-keyword\">typeid</span>(r2).name() &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">int</span> *<br><span class=\"hljs-keyword\">int</span> *<br><span class=\"hljs-keyword\">int</span> *<br><span class=\"hljs-keyword\">int</span><br><span class=\"hljs-keyword\">int</span><br></code></pre></td></tr></table></figure>\n<p>可以看到<font color=\"red\">auto推导出了指针类型，却忽略了&amp;类型</font>，这一点是需要注意的。</p>\n<h2 id=\"auto与const\"><a href=\"#auto与const\" class=\"headerlink\" title=\"auto与const\"></a>auto与const</h2><p>还是先来看一个例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">int</span> a = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">auto</span> c1 = a;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">auto</span> c2 = a;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">auto</span> *p = &amp;a;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">auto</span> &amp;r1 = a;<br><span class=\"hljs-keyword\">auto</span> &amp;r2 = r1;<br>\t<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-keyword\">typeid</span>(c1).name() &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-keyword\">typeid</span>(c2).name() &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-keyword\">typeid</span>(p).name() &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-keyword\">typeid</span>(r1).name() &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-keyword\">typeid</span>(r2).name() &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br></code></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">int</span><br><span class=\"hljs-keyword\">int</span><br><span class=\"hljs-keyword\">int</span> <span class=\"hljs-keyword\">const</span> *<br><span class=\"hljs-keyword\">int</span><br><span class=\"hljs-keyword\">int</span><br></code></pre></td></tr></table></figure>\n<p>可以看到除了指针类型，其他的都被推导成了int类型，我们再在上面的代码中加一些代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">int</span> a = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">auto</span> c1 = a;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">auto</span> c2 = a;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">auto</span> *p = &amp;a;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">auto</span> &amp;r1 = a;<br><span class=\"hljs-keyword\">auto</span> &amp;r2 = r1;<br>\t<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-keyword\">typeid</span>(c1).name() &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-keyword\">typeid</span>(c2).name() &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-keyword\">typeid</span>(p).name() &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-keyword\">typeid</span>(r1).name() &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br><span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-keyword\">typeid</span>(r2).name() &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t<br><span class=\"hljs-keyword\">int</span> b = <span class=\"hljs-number\">0</span>;<br>c1 = <span class=\"hljs-number\">2</span>;<br>c2 = <span class=\"hljs-number\">2</span>;<br>p = b;<br>r1 = <span class=\"hljs-number\">2</span>;<br>r2 = <span class=\"hljs-number\">2</span>;<br></code></pre></td></tr></table></figure>\n<p>当我们添加了这段代码之后，除了<code>c1=2</code>，其他的行都会报语法错误，所以尽c2，r1，r2被推导为int类型，但是const的约束依旧存在，但是c1没有报语法错误，也就是说c1实际上是非const类型，即<code>auto c1 = a</code>，在默认情况下auto将c1推导为非常量，如果需要设置为常量则需要显示标识const。</p>\n<p>关于<code>typeid().name()</code> 有一点很迷，就是在C++的语法中，只有常量指针类型在类型名上带有const，如上面的int const *，而其他的无论是指针常量、常量引用在类型上都是忽略const的，但是在我们把一个变量常量的地址赋予一个非常量指针时，则会报：</p>\n<p><img src=\"/2021/03/17/%E3%80%90C++%E3%80%91C++11%E6%96%B0%E7%89%B9%E6%80%A7/%E3%80%90UE4%E3%80%91UE4GamePlay%E6%9E%B6%E6%9E%84%5CSnipaste_2021-03-18_14-34-58.png\"></p>\n<p>在网上没有找到相关的解析，推测在C++语法上是只有常量指针类型带有const，没有其他的带有const的类型的，而出现上面的提示十有八九是编辑器做的，而非C++本身的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>auto的作用是类型推导，本质是占位符，在编译阶段，编译器会将正确的类型替换到auto位置上；</li>\n<li>auto可以和任何类型搭配，包括指针与引用；</li>\n<li>在声明auto变量时必须对uto变量初始化；</li>\n<li>auto关键字可以用作函数返回值类型。</li>\n</ul>\n<h1 id=\"二、decltype类型推导\"><a href=\"#二、decltype类型推导\" class=\"headerlink\" title=\"二、decltype类型推导\"></a>二、decltype类型推导</h1><p>由于auto的使用在有些方面上收到限制，比如，声明auto变量时必须对变量进行初始化，而在实际使用时，可能没法进行初始化，于是decltype就出现了，decltype也是C++的一个关键字。</p>\n<p>decltype通过表达式来推导类型，表达式可以是一个变量、常量、或者函数，使用形式为<code>decltype(exp),exp为表达式</code>如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">auto</span> <span class=\"hljs-title\">fun</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>* a)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> *a * <span class=\"hljs-number\">0.2f</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">int</span> b = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">decltype</span>(fun(&amp;b)) a;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>和auto一样decltype也可以用作函数返回值类型。</p>\n<h2 id=\"decltype与auto的区别\"><a href=\"#decltype与auto的区别\" class=\"headerlink\" title=\"decltype与auto的区别\"></a>decltype与auto的区别</h2><ul>\n<li>auto关键字声明的变量必须初始化，decltype不需要；</li>\n<li>auto在类中只能用于定义静态成员，decltype可以用于任何成员；</li>\n<li>decltype的使用上比auto更灵活；</li>\n<li>auto更具初始值来推导类型，decltype根据表达式来推导类型。</li>\n</ul>\n<h1 id=\"三、返回类型后置语法\"><a href=\"#三、返回类型后置语法\" class=\"headerlink\" title=\"三、返回类型后置语法\"></a>三、返回类型后置语法</h1><p>有时候我们写函数需要用到函数参数来推导，由于C++的返回值是前置语法，所以返回值是无法使用函数参数的，于是便有了返回值类型后置语法，先看一个例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T,<span class=\"hljs-keyword\">typename</span> U&gt;<br>auto fun(T a,U b)-&gt;decltype(a+b)<br>&#123;<br>\t<span class=\"hljs-keyword\">return</span> a+b;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>返回值类型后置语法可以将decltype使用参数推导出的类型赋予auto中，所以在这个语法中auto，decltype是必不可少的。</p>\n<p>我们仔细思考后会发现好像直接这样使用也是可以达到最终效果的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T,<span class=\"hljs-keyword\">typename</span> U&gt;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">auto</span> <span class=\"hljs-title\">fun</span><span class=\"hljs-params\">(T a,U b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> a+b;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>那么返回值后置类型语法的作用又是什么呢？事实上我们在多想一下就会明白，<code>auto fun(T a,U b)-&gt;decltype(a+b)</code>语法把auto的类型限制在decltype(a+b)的推导类型的范围内了，而auto fun(T a,U b)中auto是可以为任何类型的。但是在大多数使用场景下似乎还是没什么区别。</p>\n<p>到这里只有一句感叹，C++在类型推导上相较于主流脚本语言的类型推导还是薄弱了很多很多。</p>\n<h1 id=\"四、左值与右值\"><a href=\"#四、左值与右值\" class=\"headerlink\" title=\"四、左值与右值\"></a>四、左值与右值</h1>"},{"title":"【BAT】BATWindows自动脚本同步GitHUb远程仓库","date":"2021-05-14T09:29:28.000Z","password":null,"abstract":null,"message":null,"_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n\n\n<!--more-->\n\nWindows自动脚本，我已自动同步GitHub仓库为例。\n\n先上源码，可以直接用TXT写，然后将文件后缀改为.bat。\n\n```shell\nstart \"C:\\Windows\\System32\\cmd.exe\"\nG:\ncd Git\\Temp\ngit add .\ngit commit -m \"From Auto Updata\"\ngit push\npause\ntaskkill /f /im cmd.exe\n```\n\n- start \"C:\\Windows\\System32\\cmd.exe\"：打开Windows CMD控制台\n- G：切换到G盘，因为我的Git仓库放在G盘\n- cd Git\\Temp：进入远程仓库所在的文件夹Temp，我的远程仓库放在G:/Goulandis/Git/Temp文件夹下\n- `git add .`到`git push`是git同步远程仓库的命令\n- pause：pause命令用于暂停命令继续执行，本例中可有可无，这里加上主要是为了方便查看执行过程\n- taskkill /f /im cmd.exe：自动关闭CMD\n\n将文件后缀改为.bat之后，再将文件放入G:Goulandis(这是我电脑的路径)，这是根据cd Git\\Temp决定的，我的Git文件夹就在G:Goulandis文件夹下，所以我将脚本放在G:Goulandis文件夹下，当然若觉得麻烦，也可直接将脚本放在Temp文件下，也就是仓库的.git文件夹所在的文件夹下，这时就不需要进行盘符和文件夹切换了，即上面代码中第二第三行删除。\n\n双击运行，测试一下执行效果：\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171713.png)\n\n如果自动脚本很多的话，有一种更便捷的方法，就是专门为自动脚本创建一个文件夹，然后将其路径添加进环境变量中","source":"_posts/【BAT】BATWindows自动脚本同步GitHUb远程仓库.md","raw":"---\ntitle: 【BAT】BATWindows自动脚本同步GitHUb远程仓库\ndate: 2021-05-14 17:29:28\ntags: BAT\ncategories: 知识记录\npassword:\nabstract:\nmessage:\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n\n\n<!--more-->\n\nWindows自动脚本，我已自动同步GitHub仓库为例。\n\n先上源码，可以直接用TXT写，然后将文件后缀改为.bat。\n\n```shell\nstart \"C:\\Windows\\System32\\cmd.exe\"\nG:\ncd Git\\Temp\ngit add .\ngit commit -m \"From Auto Updata\"\ngit push\npause\ntaskkill /f /im cmd.exe\n```\n\n- start \"C:\\Windows\\System32\\cmd.exe\"：打开Windows CMD控制台\n- G：切换到G盘，因为我的Git仓库放在G盘\n- cd Git\\Temp：进入远程仓库所在的文件夹Temp，我的远程仓库放在G:/Goulandis/Git/Temp文件夹下\n- `git add .`到`git push`是git同步远程仓库的命令\n- pause：pause命令用于暂停命令继续执行，本例中可有可无，这里加上主要是为了方便查看执行过程\n- taskkill /f /im cmd.exe：自动关闭CMD\n\n将文件后缀改为.bat之后，再将文件放入G:Goulandis(这是我电脑的路径)，这是根据cd Git\\Temp决定的，我的Git文件夹就在G:Goulandis文件夹下，所以我将脚本放在G:Goulandis文件夹下，当然若觉得麻烦，也可直接将脚本放在Temp文件下，也就是仓库的.git文件夹所在的文件夹下，这时就不需要进行盘符和文件夹切换了，即上面代码中第二第三行删除。\n\n双击运行，测试一下执行效果：\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171713.png)\n\n如果自动脚本很多的话，有一种更便捷的方法，就是专门为自动脚本创建一个文件夹，然后将其路径添加进环境变量中","slug":"【BAT】BATWindows自动脚本同步GitHUb远程仓库","published":1,"updated":"2021-05-14T10:14:04.728Z","_id":"ckoo4kchv0000wkr76j803iop","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n\n\n<a id=\"more\"></a>\n\n<p>Windows自动脚本，我已自动同步GitHub仓库为例。</p>\n<p>先上源码，可以直接用TXT写，然后将文件后缀改为.bat。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">start &quot;C:\\Windows\\System32\\cmd.exe&quot;<br>G:<br>cd Git\\Temp<br>git add .<br>git commit -m &quot;From Auto Updata&quot;<br>git push<br>pause<br>taskkill /f /im cmd.exe<br></code></pre></td></tr></table></figure>\n<ul>\n<li>start “C:\\Windows\\System32\\cmd.exe”：打开Windows CMD控制台</li>\n<li>G：切换到G盘，因为我的Git仓库放在G盘</li>\n<li>cd Git\\Temp：进入远程仓库所在的文件夹Temp，我的远程仓库放在G:/Goulandis/Git/Temp文件夹下</li>\n<li><code>git add .</code>到<code>git push</code>是git同步远程仓库的命令</li>\n<li>pause：pause命令用于暂停命令继续执行，本例中可有可无，这里加上主要是为了方便查看执行过程</li>\n<li>taskkill /f /im cmd.exe：自动关闭CMD</li>\n</ul>\n<p>将文件后缀改为.bat之后，再将文件放入G:Goulandis(这是我电脑的路径)，这是根据cd Git\\Temp决定的，我的Git文件夹就在G:Goulandis文件夹下，所以我将脚本放在G:Goulandis文件夹下，当然若觉得麻烦，也可直接将脚本放在Temp文件下，也就是仓库的.git文件夹所在的文件夹下，这时就不需要进行盘符和文件夹切换了，即上面代码中第二第三行删除。</p>\n<p>双击运行，测试一下执行效果：</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171713.png\"></p>\n<p>如果自动脚本很多的话，有一种更便捷的方法，就是专门为自动脚本创建一个文件夹，然后将其路径添加进环境变量中</p>\n","site":{"data":{}},"excerpt":"<meta name=\"referrer\" content=\"no-referrer\">","more":"<p>Windows自动脚本，我已自动同步GitHub仓库为例。</p>\n<p>先上源码，可以直接用TXT写，然后将文件后缀改为.bat。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">start &quot;C:\\Windows\\System32\\cmd.exe&quot;<br>G:<br>cd Git\\Temp<br>git add .<br>git commit -m &quot;From Auto Updata&quot;<br>git push<br>pause<br>taskkill /f /im cmd.exe<br></code></pre></td></tr></table></figure>\n<ul>\n<li>start “C:\\Windows\\System32\\cmd.exe”：打开Windows CMD控制台</li>\n<li>G：切换到G盘，因为我的Git仓库放在G盘</li>\n<li>cd Git\\Temp：进入远程仓库所在的文件夹Temp，我的远程仓库放在G:/Goulandis/Git/Temp文件夹下</li>\n<li><code>git add .</code>到<code>git push</code>是git同步远程仓库的命令</li>\n<li>pause：pause命令用于暂停命令继续执行，本例中可有可无，这里加上主要是为了方便查看执行过程</li>\n<li>taskkill /f /im cmd.exe：自动关闭CMD</li>\n</ul>\n<p>将文件后缀改为.bat之后，再将文件放入G:Goulandis(这是我电脑的路径)，这是根据cd Git\\Temp决定的，我的Git文件夹就在G:Goulandis文件夹下，所以我将脚本放在G:Goulandis文件夹下，当然若觉得麻烦，也可直接将脚本放在Temp文件下，也就是仓库的.git文件夹所在的文件夹下，这时就不需要进行盘符和文件夹切换了，即上面代码中第二第三行删除。</p>\n<p>双击运行，测试一下执行效果：</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171713.png\"></p>\n<p>如果自动脚本很多的话，有一种更便捷的方法，就是专门为自动脚本创建一个文件夹，然后将其路径添加进环境变量中</p>"},{"title":"【UE4】UE4使用蓝图动态修改粒子参数","date":"2021-05-14T09:28:45.000Z","password":null,"abstract":null,"message":null,"_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n\n\n<!--more-->\n\n如果对UE4联级粒子P_Water系统比较熟悉的可能对动态修改粒子参数不陌生。\n\nUE4的联级粒子系统大部分的模块都拥有一个<font color = red> Distribution</font>子栏，其中可以选择如下模式\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171010.png)\n\n其中<font color = red> Distribution Vector Particle Parameter</font>就是参数模式，选择之后Distribution栏会变成这样\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171019.png)\n\n其中Parameter Name就是参数的名字，在蓝图调用参数时需要用到。Min Input、Max Input、Min Output、Max Output分别限制参数的的最小输入、最大输入、最小输出、最大输出。\n\nUE4的粒子系统提供8中类型的参数供外部控制：\n\n- Actor Parameters\n- Auto Attachment Parameters\n- Color Parameters\n- Float Parameters\n- Float Rand Parameters\n- Material Parameters\n- Vector Parameters\n- Vector Rand Parameters\n\n8中参数类型的用法是一样的，这里我们以Vector Parameters，用以修改粒子的发射速度Initial Velocity为例。\n\n首先将Initial Velocity模块的的Velocity/Start Velocity/Distribution选择Distribution Vector Particle Parameter模式，在Parameter Name栏设置参数名字为WaterSpeed，再设置好输入输出限制。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171025.png)\n\n然后就可以在蓝图中使用这个参数了，首先打开关卡蓝图，我这里创建一个专门的函数SetWaterSpeed用来修改这个参数，蓝图脚本如下：\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171031.png)\n\nP_Water是放在场景中的粒子系统，获取粒子系统的ParticleSystemComponent粒子系统组件，这样就可以通过Set Vector Parameter函数来获取组上指定名字的参数了，由于Set Vector Parameter是按名字来获取参数的，所以同一种类型参数尽量不要重名。\n\n然后进行函数调用。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171037.png)\n\n测试一下粒子发射速度是否改变\n\n初始状态\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171043.png)\n\n按下Up键后\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171051.png)\n\n按下Down键后\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171059.png)\n\n目前尚未找到如何读取粒子系统的参数的方法。","source":"_posts/【UE4】UE4使用蓝图动态修改粒子参数.md","raw":"---\ntitle: 【UE4】UE4使用蓝图动态修改粒子参数\ndate: 2021-05-14 17:28:45\ntags: UE4\ncategories: 学习笔记\npassword:\nabstract:\nmessage:\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n\n\n<!--more-->\n\n如果对UE4联级粒子P_Water系统比较熟悉的可能对动态修改粒子参数不陌生。\n\nUE4的联级粒子系统大部分的模块都拥有一个<font color = red> Distribution</font>子栏，其中可以选择如下模式\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171010.png)\n\n其中<font color = red> Distribution Vector Particle Parameter</font>就是参数模式，选择之后Distribution栏会变成这样\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171019.png)\n\n其中Parameter Name就是参数的名字，在蓝图调用参数时需要用到。Min Input、Max Input、Min Output、Max Output分别限制参数的的最小输入、最大输入、最小输出、最大输出。\n\nUE4的粒子系统提供8中类型的参数供外部控制：\n\n- Actor Parameters\n- Auto Attachment Parameters\n- Color Parameters\n- Float Parameters\n- Float Rand Parameters\n- Material Parameters\n- Vector Parameters\n- Vector Rand Parameters\n\n8中参数类型的用法是一样的，这里我们以Vector Parameters，用以修改粒子的发射速度Initial Velocity为例。\n\n首先将Initial Velocity模块的的Velocity/Start Velocity/Distribution选择Distribution Vector Particle Parameter模式，在Parameter Name栏设置参数名字为WaterSpeed，再设置好输入输出限制。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171025.png)\n\n然后就可以在蓝图中使用这个参数了，首先打开关卡蓝图，我这里创建一个专门的函数SetWaterSpeed用来修改这个参数，蓝图脚本如下：\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171031.png)\n\nP_Water是放在场景中的粒子系统，获取粒子系统的ParticleSystemComponent粒子系统组件，这样就可以通过Set Vector Parameter函数来获取组上指定名字的参数了，由于Set Vector Parameter是按名字来获取参数的，所以同一种类型参数尽量不要重名。\n\n然后进行函数调用。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171037.png)\n\n测试一下粒子发射速度是否改变\n\n初始状态\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171043.png)\n\n按下Up键后\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171051.png)\n\n按下Down键后\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171059.png)\n\n目前尚未找到如何读取粒子系统的参数的方法。","slug":"【UE4】UE4使用蓝图动态修改粒子参数","published":1,"updated":"2021-05-14T10:16:15.067Z","_id":"ckoo4kchy0001wkr7d9hf8dbn","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n\n\n<a id=\"more\"></a>\n\n<p>如果对UE4联级粒子P_Water系统比较熟悉的可能对动态修改粒子参数不陌生。</p>\n<p>UE4的联级粒子系统大部分的模块都拥有一个<font color=\"red\"> Distribution</font>子栏，其中可以选择如下模式</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171010.png\"></p>\n<p>其中<font color=\"red\"> Distribution Vector Particle Parameter</font>就是参数模式，选择之后Distribution栏会变成这样</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171019.png\"></p>\n<p>其中Parameter Name就是参数的名字，在蓝图调用参数时需要用到。Min Input、Max Input、Min Output、Max Output分别限制参数的的最小输入、最大输入、最小输出、最大输出。</p>\n<p>UE4的粒子系统提供8中类型的参数供外部控制：</p>\n<ul>\n<li>Actor Parameters</li>\n<li>Auto Attachment Parameters</li>\n<li>Color Parameters</li>\n<li>Float Parameters</li>\n<li>Float Rand Parameters</li>\n<li>Material Parameters</li>\n<li>Vector Parameters</li>\n<li>Vector Rand Parameters</li>\n</ul>\n<p>8中参数类型的用法是一样的，这里我们以Vector Parameters，用以修改粒子的发射速度Initial Velocity为例。</p>\n<p>首先将Initial Velocity模块的的Velocity/Start Velocity/Distribution选择Distribution Vector Particle Parameter模式，在Parameter Name栏设置参数名字为WaterSpeed，再设置好输入输出限制。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171025.png\"></p>\n<p>然后就可以在蓝图中使用这个参数了，首先打开关卡蓝图，我这里创建一个专门的函数SetWaterSpeed用来修改这个参数，蓝图脚本如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171031.png\"></p>\n<p>P_Water是放在场景中的粒子系统，获取粒子系统的ParticleSystemComponent粒子系统组件，这样就可以通过Set Vector Parameter函数来获取组上指定名字的参数了，由于Set Vector Parameter是按名字来获取参数的，所以同一种类型参数尽量不要重名。</p>\n<p>然后进行函数调用。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171037.png\"></p>\n<p>测试一下粒子发射速度是否改变</p>\n<p>初始状态</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171043.png\"></p>\n<p>按下Up键后</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171051.png\"></p>\n<p>按下Down键后</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171059.png\"></p>\n<p>目前尚未找到如何读取粒子系统的参数的方法。</p>\n","site":{"data":{}},"excerpt":"<meta name=\"referrer\" content=\"no-referrer\">","more":"<p>如果对UE4联级粒子P_Water系统比较熟悉的可能对动态修改粒子参数不陌生。</p>\n<p>UE4的联级粒子系统大部分的模块都拥有一个<font color=\"red\"> Distribution</font>子栏，其中可以选择如下模式</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171010.png\"></p>\n<p>其中<font color=\"red\"> Distribution Vector Particle Parameter</font>就是参数模式，选择之后Distribution栏会变成这样</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171019.png\"></p>\n<p>其中Parameter Name就是参数的名字，在蓝图调用参数时需要用到。Min Input、Max Input、Min Output、Max Output分别限制参数的的最小输入、最大输入、最小输出、最大输出。</p>\n<p>UE4的粒子系统提供8中类型的参数供外部控制：</p>\n<ul>\n<li>Actor Parameters</li>\n<li>Auto Attachment Parameters</li>\n<li>Color Parameters</li>\n<li>Float Parameters</li>\n<li>Float Rand Parameters</li>\n<li>Material Parameters</li>\n<li>Vector Parameters</li>\n<li>Vector Rand Parameters</li>\n</ul>\n<p>8中参数类型的用法是一样的，这里我们以Vector Parameters，用以修改粒子的发射速度Initial Velocity为例。</p>\n<p>首先将Initial Velocity模块的的Velocity/Start Velocity/Distribution选择Distribution Vector Particle Parameter模式，在Parameter Name栏设置参数名字为WaterSpeed，再设置好输入输出限制。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171025.png\"></p>\n<p>然后就可以在蓝图中使用这个参数了，首先打开关卡蓝图，我这里创建一个专门的函数SetWaterSpeed用来修改这个参数，蓝图脚本如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171031.png\"></p>\n<p>P_Water是放在场景中的粒子系统，获取粒子系统的ParticleSystemComponent粒子系统组件，这样就可以通过Set Vector Parameter函数来获取组上指定名字的参数了，由于Set Vector Parameter是按名字来获取参数的，所以同一种类型参数尽量不要重名。</p>\n<p>然后进行函数调用。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171037.png\"></p>\n<p>测试一下粒子发射速度是否改变</p>\n<p>初始状态</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171043.png\"></p>\n<p>按下Up键后</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171051.png\"></p>\n<p>按下Down键后</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171059.png\"></p>\n<p>目前尚未找到如何读取粒子系统的参数的方法。</p>"},{"title":"【UE4】UE4Socket编程","date":"2021-05-14T09:26:00.000Z","password":null,"abstract":null,"message":null,"_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n\n\n<!--more-->\n\n# 一、基于C++的服务器\n\n当然服务器也是可以使用UE4写的，不过对于一般的不需要UI的服务器来说，直接使用C++控制台程序编写要方便得多。\n\n## 1.所需头文件和静态库\n\n`#include <winsock.h>`\n\n`#pragma comment(lib \"ws2_32.lib\")`\n\n<font color=red> 需要注意的是，winsock.h是Windows环境使用的头文件，对于其他的环境需要使用其他的头文件，如在Linux下使用的是socket.h。</font>\n\n有的时候也是用winsock2.h，winsockt2.h是winsockt.h的升级版，一个文件中不可同时存在winsockt.h和winsockt2.h，因为winsockt2.h中有重定义winsockt.h中的内容。\n\n## 2.创建套接字\n\n**Server.h**\n\n```C++\n#include <winsock.h>\n\n#pragma comment(lib, \"ws2_32.lib\")\n\nclass Server\n{\npublic:\n\tWSADATA wsd;//存放套接字的属性，如：版本信息等\n\tSOCKET serverSocket;\n\tSOCKET clientSocket;\n\tSOCKADDR_IN serverAddr;//用于设置套接字使用的地址类型，端口和\n\n\tServer(int port);\n\t~Server();\n\n\tSOCKET ClientListen();\n\tvoid Receive(SOCKET clientSocket);\n};\n```\n\n**创建套接字**\n\n```C++\nServer::Server(int port)\n{\n\t//打开2.2版本的套接字，注册套接字\n\tif (WSAStartup(MAKEWORD(2, 2), &wsd) != 0)\n\t{\n\t\tcout << \"初始化套接字动态库错误\" << endl;\n\t\treturn;\n\t}\n\t//创建套接字，AF_INET--使用Inter使用，SOCK_STREAM--使用流式传输，IPPROTO_TCP--使用TCP连接\n\tserverSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\tif (serverSocket == INVALID_SOCKET)\n\t{\n\t\tcout << \"套接字创建失败\" << endl;\n\t\tWSACleanup();//注销套接字\n\t\treturn;\n\t}\n\n\tserverAddr.sin_family = AF_INET;//配置地址类型为InterIP\n\tserverAddr.sin_port = htons(port);//配置占用端口\n\tserverAddr.sin_addr.S_un.S_addr = INADDR_ANY;//接受任何IP类型\n\t//将IP和端口与套接字绑定\n\tint ret = bind(serverSocket, (LPSOCKADDR)&serverAddr, sizeof(SOCKADDR_IN));\n\tif (ret == SOCKET_ERROR)\n\t{\n\t\tcout << \"套接字绑定失败\" << endl;\n\t\tclosesocket(serverSocket);//关闭套接字\n\t\tWSACleanup();\n\t\treturn;\n\t}\n}\n```\n\n其间也可以加一个版本判断，判断注册的套接字是否是2.2版本的\n\n```C++\nif (LOBYTE(wsd.wVersion != 2 || HIBYTE(wsd.wVersion) != 2))\n{\n\tcout << \"套接字版本错误，需要打开2.2版本的套接字\" << endl;\n\tWSACleanup();\n\treturn;\n}\n```\n\n## 3.套接字监听\n\nC++没有提供专门的异步套接字监听方法，如果不想使用阻塞的方式，即同步方式监听套接字的话，就需要通过线程来实现异步监听了。\n\n```C++\nSOCKET Server::ClientListen()\n{\n\tint ret = listen(serverSocket, SOMAXCONN);//开启套接字监听，SOMAXCONN--监听队列设为最大\n\tif (ret == SOCKET_ERROR)\n\t{\n\t\tcout << \"监听时发生错误\" << endl;\n\t\tclosesocket(serverSocket);\n\t\tWSACleanup();\n\t\treturn NULL;\n\t}\n\tsockaddr_in clientAddr;//用于存储接收到的客户端的地址信息\n\tint clientAddrLen = sizeof(clientAddr);\n    //接受serverSocket缓冲区里clientAddrlen长度的内容，即一个套接字\n\tSOCKET clientSocket = accept(serverSocket, (sockaddr FAR*)&clientAddr, &clientAddrLen);\n\tif (clientSocket == INVALID_SOCKET)\n\t{\n\t\tcout << \"接受客户端时发生错误\" << endl;\n\t\tclosesocket(serverSocket);\n\t\tWSACleanup();\n\t\treturn NULL;\n\t}\n\tcout << \"接受到客户端\" << endl;\n\treturn clientSocket;\n}\n```\n\n## 4.接受消息\n\n获取到客户端的套接字后，就可以就收客户端发送过来的消息了。\n\n```C++\nvoid Server::Receive(SOCKET clientSocket)\n{\n\tchar receiveBuff[50];//接受消息内容缓冲数组\n    //接受消息\n\trecv(clientSocket, receiveBuff, strlen(receiveBuff), 0);\n\tprintf(\"%s\\n\", receiveBuff);\n}\n```\n\n## 5.发送消息\n\n```C++\nvoid Server::Send(SOCKET clientSocket, char * sendBuff)\n{\n    //发送sendBuff发送消息数组钟的内容到clientSocket套接字\n\tsend(clientSocket, sendBuff, strlen(sendBuff) + 1, 0);\n}\n```\n\n# 二、GameMode与GameInstance\n\n由于UE4在换关卡的时候会删除世界大纲中的上一关卡中的所有的内容，所以对于需要在整个游戏运行期间都必须工作的套接字来说，需要在一个从游戏开始运行到游戏程序关闭都存在的场所中工作，这个场所就是GameInstance，而使用自定义GameInstance需要用到GameMode，所以在写UE4客户端套接字之前，我们有必要先了解GameInstance和GameMode。\n\n## 1.GameInstance\n\n要了解GameInstance，首先我们要对UE的引擎结构有一点点的了解。\n\nUE的宇宙是由UEngine这个创世神管理的各个World组成的，每个World就是一个个平行世界，编辑模式是一个World，运行模式是一个World，而每个World又由各个Level组成，每个Level又由各个Actor组成，而每个Actor拥有各种不同Component从而形成了各式各样的Actor，于是多姿多彩的UE世界便展开了，而GameInstance就是凌驾于World之上的存在。\n\n<font color=red> GameInstance的生命周期就是整个游戏进程的生命周期，从游戏开始到游戏程序关闭，并且GameInstance在整个游戏进程中只存在一个对象，即单例，就如名字一般</font>。所以任何凌驾于Level和World之上的逻辑都应该在GameInstance中保存和实现，比如游戏网络连接，因为Level在切换时UE4会清空上一个Level在世界大纲中所有内容，然后加载下一个Level的内容，此时如果把游戏网络连接的逻辑放在Level或World中，这些逻辑就会被清空，在上一个Level内容被清空到下一个Level中重新加载网络连接逻辑的期间游戏会处于网络孤立状态。在游戏运行期间World在任意时刻其实都是是唯一的，为什么网络连接的逻辑不能放在World中，而要放在GameInstance中呢?这是因为UE在加载新的Level时，其实是在销毁前一个World，创建了一个新的World。但是World依然只有一个。\n\n**使用GameInstance**\n\n使用GameInstance的方法很简单，就是创建一个类继承自UGameInstance的子类，这个子类就继承到了GameInstance的所有属性了。\n\n但是GameInstance不存在于世界大纲中该如何执行在其中实现的逻辑代码呢？这就是我们接下来要来了解的GameMode的事了。\n\n## 2.GameMode\n\n首先我们需要知道什么是GameMode，在UE4里GameMode是对应World层存在的，UE4给予GameMode的职责就是处理与实现游戏逻辑，即游戏的玩法，这里我们要区分GameMode与LevelBlueptint，LevelBlueprint是对应Level存在在，每一个Level有且只有一个LevelBlueprint，而GameMode是对应World存在的，每一个World有且只有一个GameMode，但是一个UE4游戏中是可以有多个GameMode，就像一个游戏可以有多种规则玩法一样。\n\n在UE4里GameInstance里的内容可以被全局调用，那么我们为什么要使用GameMode来实现网络连接而不是用更易理解的LevelBlueprint呢？这是因为GameMode提供了内容在拥有不同GameMode的World中迁移的能力，加以大多数游戏一般只有一中游戏规则，即一个GameMode，所以在GameMode中做网络连接的逻辑是较为恰当的。\n\n**使用GameMode**\n\nGameMode实质上是一个继承自GameModeBase的蓝图类，我们只需创建一个继承自GameModeBase的GameMode，就可以在GameMode中编写蓝图脚本调用C++函数来实现游戏逻辑了，为什么在GameMode中只进行函数调用呢？因为如果所有的代码逻辑都在GameMode中实现就会显得GameMode过于臃肿，所以GameMode一般进行函数调用，而函数的实现则在C++类中处理。\n\n至此，客户端的网络部分的代码逻辑在什么地方编写就基本确定了。\n\n# 三、UE4客户端\n\n## 1.前提准备\n\n- UE4编写网络模块的逻辑需要在.Build.cs文件里添加两个模块<font color=red> \"Sockets\", \"Networking\"</font>；\n\n- 创建一个继承自UGameInstance的类作为网络部分的代码实现模块；\n\n- 创建一个继承自GameModeBase的GameMode，并在Settings/Project Settings/Maps&Mode下设置项目默认的GameMode和GameInstance。\n\n  ![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171635.png)\n\n## 2.连接服务器\n\n**.h**\n\n```C++\n#pragma once\n#include \"FReceiveThread.h\"\n#include \"Runtime/NEtworking/Public/Networking.h\"\n#include \"CoreMinimal.h\"\n#include \"Engine/GameInstance.h\"\n#include \"ServerConnector.generated.h\"\n\nUCLASS()\nclass MYGAME_API UServerConnector : public UGameInstance\n{\n\tGENERATED_BODY()\nprivate:\n\n\tFSocket *connectSocket;\n\tFIPv4Address ip;\n\tTSharedPtr<FReceiveThread> receiveThread;\n\npublic:\n\n\tFString msg;\n\npublic:\n\tUServerConnector() {}\n\t//create socket and connect server\n\tUFUNCTION(BlueprintCallable,Category=\"ClientSocket\")\n\tbool ServerConnect(FString ip,int32 port);\n\t//send message to server\n\tUFUNCTION(BlueprintCallable, Category = \"ClientSocket\")\n\tbool Send(FString msg);\n\t//receive message from server\n\tUFUNCTION(BlueprintCallable, Category = \"ClientSocket\")\n\tbool Receive();\n\t\n};\n```\n\n**连接Server**\n\n```C++\nbool UServerConnector::ServerConnect(FString ip, int32 port)\n{\n\tFIPv4Address::Parse(ip,this->ip);//将字符串表示的ip转换成点分十进制的ip\n    //创建服务器套接字地址，PLATFROM_SOCKTSUBSYSTEM--选择当前系统的套接字\n\tTSharedPtr<FInternetAddr> addr = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)->CreateInternetAddr();\n\taddr->SetIp(this->ip.Value);//向套接字地址绑定服务器ip\n\taddr->SetPort(port);//向套接字地址绑定服务器端口\n    //创建客户端套接字，NAME_Stream--使用流式传输，Default--套接字描述，false使用TCP，Ture使用UDP连接\n\tconnectSocket = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)->CreateSocket(NAME_Stream, TEXT(\"Default\"), false);\n\tif (!connectSocket->Connect(*addr))//连接服务器\n\t{\n\t\tUE_LOG(LogTemp, Error, TEXT(\"ServerConnector.cpp:Connect Failed\"));\n\t\treturn false;\n\t}\n\tUE_LOG(LogTemp, Error, TEXT(\"Connect Succeed\"));\n\treturn true;\n}\n```\n\n## 3.发送消息\n\n```C++\nbool UServerConnector::Send(FString msg){    //将字符串形式的消息转换成TCHAR*类型，因为二进制流的转换只支持TCHAR类型\tTCHAR *seriallizedChar = msg.GetCharArray().GetData();\tint32 size = FCString::Strlen(seriallizedChar) + 1;//计算消息的内存大小\tint32 sent = 0;//这一行是Send函数的格式要求，提供给Send内部使用的参数    //将消息转化成二进制流并向服务器发送消息\tif (!connectSocket->Send((uint8*)TCHAR_TO_UTF8(seriallizedChar), size, sent))\t{\t\tUE_LOG(LogTemp, Error, TEXT(\"Message Send Failly\"));\t\treturn false;\t}\tUE_LOG(LogTemp, Error, TEXT(\"Message Send Successlly\"));\treturn true;}\n```\n\n## 4接受消息\n\n接受消息就需要使用到UE4线程了，那么首先我们就需要了解UE4线程。\n\n在UE4中线程就是一个继承自FRunnable的类，我们创建这个类的对象的同时就开启了线程，<font color=red> 要注意的是继承自FRunnable的类是一个自定义类，即以F开头的类，并且自定义类在UE4的内容浏览器中是不显示的</font>。\n\n**需要包含的头文件**\n\n- #include \"Runnable.h\"\n\n- #include \"RunnableThread.h\"\n\n  或者我们也可以直接只包含#include \"ThreadingBase.h\"头文件，ThreadingBase.h里面就已经包含了线程所需要的所有的头文件\n\n### **.h**\n\n```C++\n#pragma once#include \"CoreMinimal.h\"#include \"Runnable.h\"#include \"RunnableThread.h\"#include \"Networking.h\"//#include \"ThreadingBase.h\"class MYGAME_API FReceiveThread : public FRunnable{private:\tFRunnableThread* thread = nullptr;\t\tbool threadRuning;\tFSocket* socket;//需要读取消息的线程public:\tFString msg;private:\t\t\tvirtual uint32 Run() override;\tvirtual void Stop() override;public:\tFReceiveThread(FSocket* socket);\t~FReceiveThread();;};\n```\n\n**.cpp**\n\n```C++\n#include \"FReceiveThread.h\"FReceiveThread::FReceiveThread(FSocket* socket){\tthis->socket = socket;\tthread = FRunnableThread::Create(this, TEXT(\"ReceiveThread\"), 0);\tthreadRuning = true;}uint32 FReceiveThread::Run(){\tif (!socket) return 0;\tTArray<uint8> buff;\tint32 readType = 0;\twhile (threadRuning)\t{\t\tbuff.Init(0, 1024u);\t\tsocket->Recv(buff.GetData(), buff.Num(), readType);\t\tmsg = FString(ANSI_TO_TCHAR(reinterpret_cast<const char*>(buff.GetData())));\t\tUE_LOG(LogTemp, Error, TEXT(\"%s\"), *msg);\t}\treturn 1;}void FReceiveThread::Stop(){\tthreadRuning = false;\tif (thread) thread->WaitForCompletion();}FReceiveThread::~FReceiveThread(){\tthreadRuning = false;\tdelete thread;\tthread = NULL;}\n```\n\n\n\n","source":"_posts/【UE4】UE4Socket编程.md","raw":"---\ntitle: 【UE4】UE4Socket编程\ndate: 2021-05-14 17:26:00\ntags: UE4\ncategories: 学习笔记\npassword:\nabstract:\nmessage:\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n\n\n<!--more-->\n\n# 一、基于C++的服务器\n\n当然服务器也是可以使用UE4写的，不过对于一般的不需要UI的服务器来说，直接使用C++控制台程序编写要方便得多。\n\n## 1.所需头文件和静态库\n\n`#include <winsock.h>`\n\n`#pragma comment(lib \"ws2_32.lib\")`\n\n<font color=red> 需要注意的是，winsock.h是Windows环境使用的头文件，对于其他的环境需要使用其他的头文件，如在Linux下使用的是socket.h。</font>\n\n有的时候也是用winsock2.h，winsockt2.h是winsockt.h的升级版，一个文件中不可同时存在winsockt.h和winsockt2.h，因为winsockt2.h中有重定义winsockt.h中的内容。\n\n## 2.创建套接字\n\n**Server.h**\n\n```C++\n#include <winsock.h>\n\n#pragma comment(lib, \"ws2_32.lib\")\n\nclass Server\n{\npublic:\n\tWSADATA wsd;//存放套接字的属性，如：版本信息等\n\tSOCKET serverSocket;\n\tSOCKET clientSocket;\n\tSOCKADDR_IN serverAddr;//用于设置套接字使用的地址类型，端口和\n\n\tServer(int port);\n\t~Server();\n\n\tSOCKET ClientListen();\n\tvoid Receive(SOCKET clientSocket);\n};\n```\n\n**创建套接字**\n\n```C++\nServer::Server(int port)\n{\n\t//打开2.2版本的套接字，注册套接字\n\tif (WSAStartup(MAKEWORD(2, 2), &wsd) != 0)\n\t{\n\t\tcout << \"初始化套接字动态库错误\" << endl;\n\t\treturn;\n\t}\n\t//创建套接字，AF_INET--使用Inter使用，SOCK_STREAM--使用流式传输，IPPROTO_TCP--使用TCP连接\n\tserverSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\tif (serverSocket == INVALID_SOCKET)\n\t{\n\t\tcout << \"套接字创建失败\" << endl;\n\t\tWSACleanup();//注销套接字\n\t\treturn;\n\t}\n\n\tserverAddr.sin_family = AF_INET;//配置地址类型为InterIP\n\tserverAddr.sin_port = htons(port);//配置占用端口\n\tserverAddr.sin_addr.S_un.S_addr = INADDR_ANY;//接受任何IP类型\n\t//将IP和端口与套接字绑定\n\tint ret = bind(serverSocket, (LPSOCKADDR)&serverAddr, sizeof(SOCKADDR_IN));\n\tif (ret == SOCKET_ERROR)\n\t{\n\t\tcout << \"套接字绑定失败\" << endl;\n\t\tclosesocket(serverSocket);//关闭套接字\n\t\tWSACleanup();\n\t\treturn;\n\t}\n}\n```\n\n其间也可以加一个版本判断，判断注册的套接字是否是2.2版本的\n\n```C++\nif (LOBYTE(wsd.wVersion != 2 || HIBYTE(wsd.wVersion) != 2))\n{\n\tcout << \"套接字版本错误，需要打开2.2版本的套接字\" << endl;\n\tWSACleanup();\n\treturn;\n}\n```\n\n## 3.套接字监听\n\nC++没有提供专门的异步套接字监听方法，如果不想使用阻塞的方式，即同步方式监听套接字的话，就需要通过线程来实现异步监听了。\n\n```C++\nSOCKET Server::ClientListen()\n{\n\tint ret = listen(serverSocket, SOMAXCONN);//开启套接字监听，SOMAXCONN--监听队列设为最大\n\tif (ret == SOCKET_ERROR)\n\t{\n\t\tcout << \"监听时发生错误\" << endl;\n\t\tclosesocket(serverSocket);\n\t\tWSACleanup();\n\t\treturn NULL;\n\t}\n\tsockaddr_in clientAddr;//用于存储接收到的客户端的地址信息\n\tint clientAddrLen = sizeof(clientAddr);\n    //接受serverSocket缓冲区里clientAddrlen长度的内容，即一个套接字\n\tSOCKET clientSocket = accept(serverSocket, (sockaddr FAR*)&clientAddr, &clientAddrLen);\n\tif (clientSocket == INVALID_SOCKET)\n\t{\n\t\tcout << \"接受客户端时发生错误\" << endl;\n\t\tclosesocket(serverSocket);\n\t\tWSACleanup();\n\t\treturn NULL;\n\t}\n\tcout << \"接受到客户端\" << endl;\n\treturn clientSocket;\n}\n```\n\n## 4.接受消息\n\n获取到客户端的套接字后，就可以就收客户端发送过来的消息了。\n\n```C++\nvoid Server::Receive(SOCKET clientSocket)\n{\n\tchar receiveBuff[50];//接受消息内容缓冲数组\n    //接受消息\n\trecv(clientSocket, receiveBuff, strlen(receiveBuff), 0);\n\tprintf(\"%s\\n\", receiveBuff);\n}\n```\n\n## 5.发送消息\n\n```C++\nvoid Server::Send(SOCKET clientSocket, char * sendBuff)\n{\n    //发送sendBuff发送消息数组钟的内容到clientSocket套接字\n\tsend(clientSocket, sendBuff, strlen(sendBuff) + 1, 0);\n}\n```\n\n# 二、GameMode与GameInstance\n\n由于UE4在换关卡的时候会删除世界大纲中的上一关卡中的所有的内容，所以对于需要在整个游戏运行期间都必须工作的套接字来说，需要在一个从游戏开始运行到游戏程序关闭都存在的场所中工作，这个场所就是GameInstance，而使用自定义GameInstance需要用到GameMode，所以在写UE4客户端套接字之前，我们有必要先了解GameInstance和GameMode。\n\n## 1.GameInstance\n\n要了解GameInstance，首先我们要对UE的引擎结构有一点点的了解。\n\nUE的宇宙是由UEngine这个创世神管理的各个World组成的，每个World就是一个个平行世界，编辑模式是一个World，运行模式是一个World，而每个World又由各个Level组成，每个Level又由各个Actor组成，而每个Actor拥有各种不同Component从而形成了各式各样的Actor，于是多姿多彩的UE世界便展开了，而GameInstance就是凌驾于World之上的存在。\n\n<font color=red> GameInstance的生命周期就是整个游戏进程的生命周期，从游戏开始到游戏程序关闭，并且GameInstance在整个游戏进程中只存在一个对象，即单例，就如名字一般</font>。所以任何凌驾于Level和World之上的逻辑都应该在GameInstance中保存和实现，比如游戏网络连接，因为Level在切换时UE4会清空上一个Level在世界大纲中所有内容，然后加载下一个Level的内容，此时如果把游戏网络连接的逻辑放在Level或World中，这些逻辑就会被清空，在上一个Level内容被清空到下一个Level中重新加载网络连接逻辑的期间游戏会处于网络孤立状态。在游戏运行期间World在任意时刻其实都是是唯一的，为什么网络连接的逻辑不能放在World中，而要放在GameInstance中呢?这是因为UE在加载新的Level时，其实是在销毁前一个World，创建了一个新的World。但是World依然只有一个。\n\n**使用GameInstance**\n\n使用GameInstance的方法很简单，就是创建一个类继承自UGameInstance的子类，这个子类就继承到了GameInstance的所有属性了。\n\n但是GameInstance不存在于世界大纲中该如何执行在其中实现的逻辑代码呢？这就是我们接下来要来了解的GameMode的事了。\n\n## 2.GameMode\n\n首先我们需要知道什么是GameMode，在UE4里GameMode是对应World层存在的，UE4给予GameMode的职责就是处理与实现游戏逻辑，即游戏的玩法，这里我们要区分GameMode与LevelBlueptint，LevelBlueprint是对应Level存在在，每一个Level有且只有一个LevelBlueprint，而GameMode是对应World存在的，每一个World有且只有一个GameMode，但是一个UE4游戏中是可以有多个GameMode，就像一个游戏可以有多种规则玩法一样。\n\n在UE4里GameInstance里的内容可以被全局调用，那么我们为什么要使用GameMode来实现网络连接而不是用更易理解的LevelBlueprint呢？这是因为GameMode提供了内容在拥有不同GameMode的World中迁移的能力，加以大多数游戏一般只有一中游戏规则，即一个GameMode，所以在GameMode中做网络连接的逻辑是较为恰当的。\n\n**使用GameMode**\n\nGameMode实质上是一个继承自GameModeBase的蓝图类，我们只需创建一个继承自GameModeBase的GameMode，就可以在GameMode中编写蓝图脚本调用C++函数来实现游戏逻辑了，为什么在GameMode中只进行函数调用呢？因为如果所有的代码逻辑都在GameMode中实现就会显得GameMode过于臃肿，所以GameMode一般进行函数调用，而函数的实现则在C++类中处理。\n\n至此，客户端的网络部分的代码逻辑在什么地方编写就基本确定了。\n\n# 三、UE4客户端\n\n## 1.前提准备\n\n- UE4编写网络模块的逻辑需要在.Build.cs文件里添加两个模块<font color=red> \"Sockets\", \"Networking\"</font>；\n\n- 创建一个继承自UGameInstance的类作为网络部分的代码实现模块；\n\n- 创建一个继承自GameModeBase的GameMode，并在Settings/Project Settings/Maps&Mode下设置项目默认的GameMode和GameInstance。\n\n  ![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171635.png)\n\n## 2.连接服务器\n\n**.h**\n\n```C++\n#pragma once\n#include \"FReceiveThread.h\"\n#include \"Runtime/NEtworking/Public/Networking.h\"\n#include \"CoreMinimal.h\"\n#include \"Engine/GameInstance.h\"\n#include \"ServerConnector.generated.h\"\n\nUCLASS()\nclass MYGAME_API UServerConnector : public UGameInstance\n{\n\tGENERATED_BODY()\nprivate:\n\n\tFSocket *connectSocket;\n\tFIPv4Address ip;\n\tTSharedPtr<FReceiveThread> receiveThread;\n\npublic:\n\n\tFString msg;\n\npublic:\n\tUServerConnector() {}\n\t//create socket and connect server\n\tUFUNCTION(BlueprintCallable,Category=\"ClientSocket\")\n\tbool ServerConnect(FString ip,int32 port);\n\t//send message to server\n\tUFUNCTION(BlueprintCallable, Category = \"ClientSocket\")\n\tbool Send(FString msg);\n\t//receive message from server\n\tUFUNCTION(BlueprintCallable, Category = \"ClientSocket\")\n\tbool Receive();\n\t\n};\n```\n\n**连接Server**\n\n```C++\nbool UServerConnector::ServerConnect(FString ip, int32 port)\n{\n\tFIPv4Address::Parse(ip,this->ip);//将字符串表示的ip转换成点分十进制的ip\n    //创建服务器套接字地址，PLATFROM_SOCKTSUBSYSTEM--选择当前系统的套接字\n\tTSharedPtr<FInternetAddr> addr = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)->CreateInternetAddr();\n\taddr->SetIp(this->ip.Value);//向套接字地址绑定服务器ip\n\taddr->SetPort(port);//向套接字地址绑定服务器端口\n    //创建客户端套接字，NAME_Stream--使用流式传输，Default--套接字描述，false使用TCP，Ture使用UDP连接\n\tconnectSocket = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)->CreateSocket(NAME_Stream, TEXT(\"Default\"), false);\n\tif (!connectSocket->Connect(*addr))//连接服务器\n\t{\n\t\tUE_LOG(LogTemp, Error, TEXT(\"ServerConnector.cpp:Connect Failed\"));\n\t\treturn false;\n\t}\n\tUE_LOG(LogTemp, Error, TEXT(\"Connect Succeed\"));\n\treturn true;\n}\n```\n\n## 3.发送消息\n\n```C++\nbool UServerConnector::Send(FString msg){    //将字符串形式的消息转换成TCHAR*类型，因为二进制流的转换只支持TCHAR类型\tTCHAR *seriallizedChar = msg.GetCharArray().GetData();\tint32 size = FCString::Strlen(seriallizedChar) + 1;//计算消息的内存大小\tint32 sent = 0;//这一行是Send函数的格式要求，提供给Send内部使用的参数    //将消息转化成二进制流并向服务器发送消息\tif (!connectSocket->Send((uint8*)TCHAR_TO_UTF8(seriallizedChar), size, sent))\t{\t\tUE_LOG(LogTemp, Error, TEXT(\"Message Send Failly\"));\t\treturn false;\t}\tUE_LOG(LogTemp, Error, TEXT(\"Message Send Successlly\"));\treturn true;}\n```\n\n## 4接受消息\n\n接受消息就需要使用到UE4线程了，那么首先我们就需要了解UE4线程。\n\n在UE4中线程就是一个继承自FRunnable的类，我们创建这个类的对象的同时就开启了线程，<font color=red> 要注意的是继承自FRunnable的类是一个自定义类，即以F开头的类，并且自定义类在UE4的内容浏览器中是不显示的</font>。\n\n**需要包含的头文件**\n\n- #include \"Runnable.h\"\n\n- #include \"RunnableThread.h\"\n\n  或者我们也可以直接只包含#include \"ThreadingBase.h\"头文件，ThreadingBase.h里面就已经包含了线程所需要的所有的头文件\n\n### **.h**\n\n```C++\n#pragma once#include \"CoreMinimal.h\"#include \"Runnable.h\"#include \"RunnableThread.h\"#include \"Networking.h\"//#include \"ThreadingBase.h\"class MYGAME_API FReceiveThread : public FRunnable{private:\tFRunnableThread* thread = nullptr;\t\tbool threadRuning;\tFSocket* socket;//需要读取消息的线程public:\tFString msg;private:\t\t\tvirtual uint32 Run() override;\tvirtual void Stop() override;public:\tFReceiveThread(FSocket* socket);\t~FReceiveThread();;};\n```\n\n**.cpp**\n\n```C++\n#include \"FReceiveThread.h\"FReceiveThread::FReceiveThread(FSocket* socket){\tthis->socket = socket;\tthread = FRunnableThread::Create(this, TEXT(\"ReceiveThread\"), 0);\tthreadRuning = true;}uint32 FReceiveThread::Run(){\tif (!socket) return 0;\tTArray<uint8> buff;\tint32 readType = 0;\twhile (threadRuning)\t{\t\tbuff.Init(0, 1024u);\t\tsocket->Recv(buff.GetData(), buff.Num(), readType);\t\tmsg = FString(ANSI_TO_TCHAR(reinterpret_cast<const char*>(buff.GetData())));\t\tUE_LOG(LogTemp, Error, TEXT(\"%s\"), *msg);\t}\treturn 1;}void FReceiveThread::Stop(){\tthreadRuning = false;\tif (thread) thread->WaitForCompletion();}FReceiveThread::~FReceiveThread(){\tthreadRuning = false;\tdelete thread;\tthread = NULL;}\n```\n\n\n\n","slug":"【UE4】UE4Socket编程","published":1,"updated":"2021-05-14T10:14:39.411Z","_id":"ckoo4kchz0002wkr739j7ft11","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n\n\n<a id=\"more\"></a>\n\n<h1 id=\"一、基于C-的服务器\"><a href=\"#一、基于C-的服务器\" class=\"headerlink\" title=\"一、基于C++的服务器\"></a>一、基于C++的服务器</h1><p>当然服务器也是可以使用UE4写的，不过对于一般的不需要UI的服务器来说，直接使用C++控制台程序编写要方便得多。</p>\n<h2 id=\"1-所需头文件和静态库\"><a href=\"#1-所需头文件和静态库\" class=\"headerlink\" title=\"1.所需头文件和静态库\"></a>1.所需头文件和静态库</h2><p><code>#include &lt;winsock.h&gt;</code></p>\n<p><code>#pragma comment(lib &quot;ws2_32.lib&quot;)</code></p>\n<p><font color=\"red\"> 需要注意的是，winsock.h是Windows环境使用的头文件，对于其他的环境需要使用其他的头文件，如在Linux下使用的是socket.h。</font></p>\n<p>有的时候也是用winsock2.h，winsockt2.h是winsockt.h的升级版，一个文件中不可同时存在winsockt.h和winsockt2.h，因为winsockt2.h中有重定义winsockt.h中的内容。</p>\n<h2 id=\"2-创建套接字\"><a href=\"#2-创建套接字\" class=\"headerlink\" title=\"2.创建套接字\"></a>2.创建套接字</h2><p><strong>Server.h</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;winsock.h&gt;</span></span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> comment(lib, <span class=\"hljs-meta-string\">&quot;ws2_32.lib&quot;</span>)</span><br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Server</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\tWSADATA wsd;<span class=\"hljs-comment\">//存放套接字的属性，如：版本信息等</span><br>\tSOCKET serverSocket;<br>\tSOCKET clientSocket;<br>\tSOCKADDR_IN serverAddr;<span class=\"hljs-comment\">//用于设置套接字使用的地址类型，端口和</span><br><br>\tServer(<span class=\"hljs-keyword\">int</span> port);<br>\t~Server();<br><br>\t<span class=\"hljs-function\">SOCKET <span class=\"hljs-title\">ClientListen</span><span class=\"hljs-params\">()</span></span>;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Receive</span><span class=\"hljs-params\">(SOCKET clientSocket)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p><strong>创建套接字</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">Server::Server(<span class=\"hljs-keyword\">int</span> port)<br>&#123;<br>\t<span class=\"hljs-comment\">//打开2.2版本的套接字，注册套接字</span><br>\t<span class=\"hljs-keyword\">if</span> (WSAStartup(MAKEWORD(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>), &amp;wsd) != <span class=\"hljs-number\">0</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;初始化套接字动态库错误&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t&#125;<br>\t<span class=\"hljs-comment\">//创建套接字，AF_INET--使用Inter使用，SOCK_STREAM--使用流式传输，IPPROTO_TCP--使用TCP连接</span><br>\tserverSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);<br>\t<span class=\"hljs-keyword\">if</span> (serverSocket == INVALID_SOCKET)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;套接字创建失败&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t\tWSACleanup();<span class=\"hljs-comment\">//注销套接字</span><br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t&#125;<br><br>\tserverAddr.sin_family = AF_INET;<span class=\"hljs-comment\">//配置地址类型为InterIP</span><br>\tserverAddr.sin_port = htons(port);<span class=\"hljs-comment\">//配置占用端口</span><br>\tserverAddr.sin_addr.S_un.S_addr = INADDR_ANY;<span class=\"hljs-comment\">//接受任何IP类型</span><br>\t<span class=\"hljs-comment\">//将IP和端口与套接字绑定</span><br>\t<span class=\"hljs-keyword\">int</span> ret = bind(serverSocket, (LPSOCKADDR)&amp;serverAddr, <span class=\"hljs-keyword\">sizeof</span>(SOCKADDR_IN));<br>\t<span class=\"hljs-keyword\">if</span> (ret == SOCKET_ERROR)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;套接字绑定失败&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t\tclosesocket(serverSocket);<span class=\"hljs-comment\">//关闭套接字</span><br>\t\tWSACleanup();<br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>其间也可以加一个版本判断，判断注册的套接字是否是2.2版本的</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">if</span> (LOBYTE(wsd.wVersion != <span class=\"hljs-number\">2</span> || HIBYTE(wsd.wVersion) != <span class=\"hljs-number\">2</span>))<br>&#123;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;套接字版本错误，需要打开2.2版本的套接字&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\tWSACleanup();<br>\t<span class=\"hljs-keyword\">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"3-套接字监听\"><a href=\"#3-套接字监听\" class=\"headerlink\" title=\"3.套接字监听\"></a>3.套接字监听</h2><p>C++没有提供专门的异步套接字监听方法，如果不想使用阻塞的方式，即同步方式监听套接字的话，就需要通过线程来实现异步监听了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\">SOCKET <span class=\"hljs-title\">Server::ClientListen</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">int</span> ret = listen(serverSocket, SOMAXCONN);<span class=\"hljs-comment\">//开启套接字监听，SOMAXCONN--监听队列设为最大</span><br>\t<span class=\"hljs-keyword\">if</span> (ret == SOCKET_ERROR)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;监听时发生错误&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t\tclosesocket(serverSocket);<br>\t\tWSACleanup();<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>\t&#125;<br>\tsockaddr_in clientAddr;<span class=\"hljs-comment\">//用于存储接收到的客户端的地址信息</span><br>\t<span class=\"hljs-keyword\">int</span> clientAddrLen = <span class=\"hljs-keyword\">sizeof</span>(clientAddr);<br>    <span class=\"hljs-comment\">//接受serverSocket缓冲区里clientAddrlen长度的内容，即一个套接字</span><br>\tSOCKET clientSocket = accept(serverSocket, (sockaddr FAR*)&amp;clientAddr, &amp;clientAddrLen);<br>\t<span class=\"hljs-keyword\">if</span> (clientSocket == INVALID_SOCKET)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;接受客户端时发生错误&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t\tclosesocket(serverSocket);<br>\t\tWSACleanup();<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>\t&#125;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;接受到客户端&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t<span class=\"hljs-keyword\">return</span> clientSocket;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"4-接受消息\"><a href=\"#4-接受消息\" class=\"headerlink\" title=\"4.接受消息\"></a>4.接受消息</h2><p>获取到客户端的套接字后，就可以就收客户端发送过来的消息了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Server::Receive</span><span class=\"hljs-params\">(SOCKET clientSocket)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">char</span> receiveBuff[<span class=\"hljs-number\">50</span>];<span class=\"hljs-comment\">//接受消息内容缓冲数组</span><br>    <span class=\"hljs-comment\">//接受消息</span><br>\trecv(clientSocket, receiveBuff, <span class=\"hljs-built_in\">strlen</span>(receiveBuff), <span class=\"hljs-number\">0</span>);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s\\n&quot;</span>, receiveBuff);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"5-发送消息\"><a href=\"#5-发送消息\" class=\"headerlink\" title=\"5.发送消息\"></a>5.发送消息</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Server::Send</span><span class=\"hljs-params\">(SOCKET clientSocket, <span class=\"hljs-keyword\">char</span> * sendBuff)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//发送sendBuff发送消息数组钟的内容到clientSocket套接字</span><br>\tsend(clientSocket, sendBuff, <span class=\"hljs-built_in\">strlen</span>(sendBuff) + <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"二、GameMode与GameInstance\"><a href=\"#二、GameMode与GameInstance\" class=\"headerlink\" title=\"二、GameMode与GameInstance\"></a>二、GameMode与GameInstance</h1><p>由于UE4在换关卡的时候会删除世界大纲中的上一关卡中的所有的内容，所以对于需要在整个游戏运行期间都必须工作的套接字来说，需要在一个从游戏开始运行到游戏程序关闭都存在的场所中工作，这个场所就是GameInstance，而使用自定义GameInstance需要用到GameMode，所以在写UE4客户端套接字之前，我们有必要先了解GameInstance和GameMode。</p>\n<h2 id=\"1-GameInstance\"><a href=\"#1-GameInstance\" class=\"headerlink\" title=\"1.GameInstance\"></a>1.GameInstance</h2><p>要了解GameInstance，首先我们要对UE的引擎结构有一点点的了解。</p>\n<p>UE的宇宙是由UEngine这个创世神管理的各个World组成的，每个World就是一个个平行世界，编辑模式是一个World，运行模式是一个World，而每个World又由各个Level组成，每个Level又由各个Actor组成，而每个Actor拥有各种不同Component从而形成了各式各样的Actor，于是多姿多彩的UE世界便展开了，而GameInstance就是凌驾于World之上的存在。</p>\n<p><font color=\"red\"> GameInstance的生命周期就是整个游戏进程的生命周期，从游戏开始到游戏程序关闭，并且GameInstance在整个游戏进程中只存在一个对象，即单例，就如名字一般</font>。所以任何凌驾于Level和World之上的逻辑都应该在GameInstance中保存和实现，比如游戏网络连接，因为Level在切换时UE4会清空上一个Level在世界大纲中所有内容，然后加载下一个Level的内容，此时如果把游戏网络连接的逻辑放在Level或World中，这些逻辑就会被清空，在上一个Level内容被清空到下一个Level中重新加载网络连接逻辑的期间游戏会处于网络孤立状态。在游戏运行期间World在任意时刻其实都是是唯一的，为什么网络连接的逻辑不能放在World中，而要放在GameInstance中呢?这是因为UE在加载新的Level时，其实是在销毁前一个World，创建了一个新的World。但是World依然只有一个。</p>\n<p><strong>使用GameInstance</strong></p>\n<p>使用GameInstance的方法很简单，就是创建一个类继承自UGameInstance的子类，这个子类就继承到了GameInstance的所有属性了。</p>\n<p>但是GameInstance不存在于世界大纲中该如何执行在其中实现的逻辑代码呢？这就是我们接下来要来了解的GameMode的事了。</p>\n<h2 id=\"2-GameMode\"><a href=\"#2-GameMode\" class=\"headerlink\" title=\"2.GameMode\"></a>2.GameMode</h2><p>首先我们需要知道什么是GameMode，在UE4里GameMode是对应World层存在的，UE4给予GameMode的职责就是处理与实现游戏逻辑，即游戏的玩法，这里我们要区分GameMode与LevelBlueptint，LevelBlueprint是对应Level存在在，每一个Level有且只有一个LevelBlueprint，而GameMode是对应World存在的，每一个World有且只有一个GameMode，但是一个UE4游戏中是可以有多个GameMode，就像一个游戏可以有多种规则玩法一样。</p>\n<p>在UE4里GameInstance里的内容可以被全局调用，那么我们为什么要使用GameMode来实现网络连接而不是用更易理解的LevelBlueprint呢？这是因为GameMode提供了内容在拥有不同GameMode的World中迁移的能力，加以大多数游戏一般只有一中游戏规则，即一个GameMode，所以在GameMode中做网络连接的逻辑是较为恰当的。</p>\n<p><strong>使用GameMode</strong></p>\n<p>GameMode实质上是一个继承自GameModeBase的蓝图类，我们只需创建一个继承自GameModeBase的GameMode，就可以在GameMode中编写蓝图脚本调用C++函数来实现游戏逻辑了，为什么在GameMode中只进行函数调用呢？因为如果所有的代码逻辑都在GameMode中实现就会显得GameMode过于臃肿，所以GameMode一般进行函数调用，而函数的实现则在C++类中处理。</p>\n<p>至此，客户端的网络部分的代码逻辑在什么地方编写就基本确定了。</p>\n<h1 id=\"三、UE4客户端\"><a href=\"#三、UE4客户端\" class=\"headerlink\" title=\"三、UE4客户端\"></a>三、UE4客户端</h1><h2 id=\"1-前提准备\"><a href=\"#1-前提准备\" class=\"headerlink\" title=\"1.前提准备\"></a>1.前提准备</h2><ul>\n<li><p>UE4编写网络模块的逻辑需要在.Build.cs文件里添加两个模块<font color=\"red\"> “Sockets”, “Networking”</font>；</p>\n</li>\n<li><p>创建一个继承自UGameInstance的类作为网络部分的代码实现模块；</p>\n</li>\n<li><p>创建一个继承自GameModeBase的GameMode，并在Settings/Project Settings/Maps&amp;Mode下设置项目默认的GameMode和GameInstance。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171635.png\"></p>\n</li>\n</ul>\n<h2 id=\"2-连接服务器\"><a href=\"#2-连接服务器\" class=\"headerlink\" title=\"2.连接服务器\"></a>2.连接服务器</h2><p><strong>.h</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> once</span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;FReceiveThread.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;Runtime/NEtworking/Public/Networking.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;CoreMinimal.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;Engine/GameInstance.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;ServerConnector.generated.h&quot;</span></span><br><br>UCLASS()<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MYGAME_API</span> <span class=\"hljs-title\">UServerConnector</span> :</span> <span class=\"hljs-keyword\">public</span> UGameInstance<br>&#123;<br>\tGENERATED_BODY()<br><span class=\"hljs-keyword\">private</span>:<br><br>\tFSocket *connectSocket;<br>\tFIPv4Address ip;<br>\tTSharedPtr&lt;FReceiveThread&gt; receiveThread;<br><br><span class=\"hljs-keyword\">public</span>:<br><br>\tFString msg;<br><br><span class=\"hljs-keyword\">public</span>:<br>\tUServerConnector() &#123;&#125;<br>\t<span class=\"hljs-comment\">//create socket and connect server</span><br>\tUFUNCTION(BlueprintCallable,Category=<span class=\"hljs-string\">&quot;ClientSocket&quot;</span>)<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">ServerConnect</span><span class=\"hljs-params\">(FString ip,int32 port)</span></span>;<br>\t<span class=\"hljs-comment\">//send message to server</span><br>\tUFUNCTION(BlueprintCallable, Category = <span class=\"hljs-string\">&quot;ClientSocket&quot;</span>)<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">Send</span><span class=\"hljs-params\">(FString msg)</span></span>;<br>\t<span class=\"hljs-comment\">//receive message from server</span><br>\tUFUNCTION(BlueprintCallable, Category = <span class=\"hljs-string\">&quot;ClientSocket&quot;</span>)<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">Receive</span><span class=\"hljs-params\">()</span></span>;<br>\t<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p><strong>连接Server</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">UServerConnector::ServerConnect</span><span class=\"hljs-params\">(FString ip, int32 port)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tFIPv4Address::Parse(ip,<span class=\"hljs-keyword\">this</span>-&gt;ip);<span class=\"hljs-comment\">//将字符串表示的ip转换成点分十进制的ip</span><br>    <span class=\"hljs-comment\">//创建服务器套接字地址，PLATFROM_SOCKTSUBSYSTEM--选择当前系统的套接字</span><br>\tTSharedPtr&lt;FInternetAddr&gt; addr = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateInternetAddr();<br>\taddr-&gt;SetIp(<span class=\"hljs-keyword\">this</span>-&gt;ip.Value);<span class=\"hljs-comment\">//向套接字地址绑定服务器ip</span><br>\taddr-&gt;SetPort(port);<span class=\"hljs-comment\">//向套接字地址绑定服务器端口</span><br>    <span class=\"hljs-comment\">//创建客户端套接字，NAME_Stream--使用流式传输，Default--套接字描述，false使用TCP，Ture使用UDP连接</span><br>\tconnectSocket = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateSocket(NAME_Stream, TEXT(<span class=\"hljs-string\">&quot;Default&quot;</span>), <span class=\"hljs-literal\">false</span>);<br>\t<span class=\"hljs-keyword\">if</span> (!connectSocket-&gt;Connect(*addr))<span class=\"hljs-comment\">//连接服务器</span><br>\t&#123;<br>\t\tUE_LOG(LogTemp, Error, TEXT(<span class=\"hljs-string\">&quot;ServerConnector.cpp:Connect Failed&quot;</span>));<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t&#125;<br>\tUE_LOG(LogTemp, Error, TEXT(<span class=\"hljs-string\">&quot;Connect Succeed&quot;</span>));<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"3-发送消息\"><a href=\"#3-发送消息\" class=\"headerlink\" title=\"3.发送消息\"></a>3.发送消息</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">UServerConnector::Send</span><span class=\"hljs-params\">(FString msg)</span></span>&#123;    <span class=\"hljs-comment\">//将字符串形式的消息转换成TCHAR*类型，因为二进制流的转换只支持TCHAR类型\tTCHAR *seriallizedChar = msg.GetCharArray().GetData();\tint32 size = FCString::Strlen(seriallizedChar) + 1;//计算消息的内存大小\tint32 sent = 0;//这一行是Send函数的格式要求，提供给Send内部使用的参数    //将消息转化成二进制流并向服务器发送消息\tif (!connectSocket-&gt;Send((uint8*)TCHAR_TO_UTF8(seriallizedChar), size, sent))\t&#123;\t\tUE_LOG(LogTemp, Error, TEXT(&quot;Message Send Failly&quot;));\t\treturn false;\t&#125;\tUE_LOG(LogTemp, Error, TEXT(&quot;Message Send Successlly&quot;));\treturn true;&#125;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"4接受消息\"><a href=\"#4接受消息\" class=\"headerlink\" title=\"4接受消息\"></a>4接受消息</h2><p>接受消息就需要使用到UE4线程了，那么首先我们就需要了解UE4线程。</p>\n<p>在UE4中线程就是一个继承自FRunnable的类，我们创建这个类的对象的同时就开启了线程，<font color=\"red\"> 要注意的是继承自FRunnable的类是一个自定义类，即以F开头的类，并且自定义类在UE4的内容浏览器中是不显示的</font>。</p>\n<p><strong>需要包含的头文件</strong></p>\n<ul>\n<li><p>#include “Runnable.h”</p>\n</li>\n<li><p>#include “RunnableThread.h”</p>\n<p>或者我们也可以直接只包含#include “ThreadingBase.h”头文件，ThreadingBase.h里面就已经包含了线程所需要的所有的头文件</p>\n</li>\n</ul>\n<h3 id=\"h\"><a href=\"#h\" class=\"headerlink\" title=\".h\"></a><strong>.h</strong></h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> once#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;CoreMinimal.h&quot;</span>#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;Runnable.h&quot;</span>#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;RunnableThread.h&quot;</span>#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;Networking.h&quot;</span><span class=\"hljs-comment\">//#include &quot;ThreadingBase.h&quot;class MYGAME_API FReceiveThread : public FRunnable&#123;private:\tFRunnableThread* thread = nullptr;\t\tbool threadRuning;\tFSocket* socket;//需要读取消息的线程public:\tFString msg;private:\t\t\tvirtual uint32 Run() override;\tvirtual void Stop() override;public:\tFReceiveThread(FSocket* socket);\t~FReceiveThread();;&#125;;</span></span><br></code></pre></td></tr></table></figure>\n<p><strong>.cpp</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;FReceiveThread.h&quot;</span>FReceiveThread::FReceiveThread(FSocket* socket)&#123;\tthis-&gt;socket = socket;\tthread = FRunnableThread::Create(this, TEXT(<span class=\"hljs-meta-string\">&quot;ReceiveThread&quot;</span>), 0);\tthreadRuning = true;&#125;uint32 FReceiveThread::Run()&#123;\t<span class=\"hljs-meta-keyword\">if</span> (!socket) return 0;\tTArray<span class=\"hljs-meta-string\">&lt;uint8&gt; buff;\tint32 readType = 0;\twhile (threadRuning)\t&#123;\t\tbuff.Init(0, 1024u);\t\tsocket-&gt;Recv(buff.GetData(), buff.Num(), readType);\t\tmsg = FString(ANSI_TO_TCHAR(reinterpret_cast&lt;const char*&gt;(buff.GetData())));\t\tUE_LOG(LogTemp, Error, TEXT(&quot;%s&quot;), *msg);\t&#125;\treturn 1;&#125;void FReceiveThread::Stop()&#123;\tthreadRuning = false;\tif (thread) thread-&gt;WaitForCompletion();&#125;FReceiveThread::~FReceiveThread()&#123;\tthreadRuning = false;\tdelete thread;\tthread = NULL;&#125;</span></span><br></code></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"<meta name=\"referrer\" content=\"no-referrer\">","more":"<h1 id=\"一、基于C-的服务器\"><a href=\"#一、基于C-的服务器\" class=\"headerlink\" title=\"一、基于C++的服务器\"></a>一、基于C++的服务器</h1><p>当然服务器也是可以使用UE4写的，不过对于一般的不需要UI的服务器来说，直接使用C++控制台程序编写要方便得多。</p>\n<h2 id=\"1-所需头文件和静态库\"><a href=\"#1-所需头文件和静态库\" class=\"headerlink\" title=\"1.所需头文件和静态库\"></a>1.所需头文件和静态库</h2><p><code>#include &lt;winsock.h&gt;</code></p>\n<p><code>#pragma comment(lib &quot;ws2_32.lib&quot;)</code></p>\n<p><font color=\"red\"> 需要注意的是，winsock.h是Windows环境使用的头文件，对于其他的环境需要使用其他的头文件，如在Linux下使用的是socket.h。</font></p>\n<p>有的时候也是用winsock2.h，winsockt2.h是winsockt.h的升级版，一个文件中不可同时存在winsockt.h和winsockt2.h，因为winsockt2.h中有重定义winsockt.h中的内容。</p>\n<h2 id=\"2-创建套接字\"><a href=\"#2-创建套接字\" class=\"headerlink\" title=\"2.创建套接字\"></a>2.创建套接字</h2><p><strong>Server.h</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;winsock.h&gt;</span></span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> comment(lib, <span class=\"hljs-meta-string\">&quot;ws2_32.lib&quot;</span>)</span><br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Server</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\tWSADATA wsd;<span class=\"hljs-comment\">//存放套接字的属性，如：版本信息等</span><br>\tSOCKET serverSocket;<br>\tSOCKET clientSocket;<br>\tSOCKADDR_IN serverAddr;<span class=\"hljs-comment\">//用于设置套接字使用的地址类型，端口和</span><br><br>\tServer(<span class=\"hljs-keyword\">int</span> port);<br>\t~Server();<br><br>\t<span class=\"hljs-function\">SOCKET <span class=\"hljs-title\">ClientListen</span><span class=\"hljs-params\">()</span></span>;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Receive</span><span class=\"hljs-params\">(SOCKET clientSocket)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p><strong>创建套接字</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">Server::Server(<span class=\"hljs-keyword\">int</span> port)<br>&#123;<br>\t<span class=\"hljs-comment\">//打开2.2版本的套接字，注册套接字</span><br>\t<span class=\"hljs-keyword\">if</span> (WSAStartup(MAKEWORD(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>), &amp;wsd) != <span class=\"hljs-number\">0</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;初始化套接字动态库错误&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t&#125;<br>\t<span class=\"hljs-comment\">//创建套接字，AF_INET--使用Inter使用，SOCK_STREAM--使用流式传输，IPPROTO_TCP--使用TCP连接</span><br>\tserverSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);<br>\t<span class=\"hljs-keyword\">if</span> (serverSocket == INVALID_SOCKET)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;套接字创建失败&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t\tWSACleanup();<span class=\"hljs-comment\">//注销套接字</span><br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t&#125;<br><br>\tserverAddr.sin_family = AF_INET;<span class=\"hljs-comment\">//配置地址类型为InterIP</span><br>\tserverAddr.sin_port = htons(port);<span class=\"hljs-comment\">//配置占用端口</span><br>\tserverAddr.sin_addr.S_un.S_addr = INADDR_ANY;<span class=\"hljs-comment\">//接受任何IP类型</span><br>\t<span class=\"hljs-comment\">//将IP和端口与套接字绑定</span><br>\t<span class=\"hljs-keyword\">int</span> ret = bind(serverSocket, (LPSOCKADDR)&amp;serverAddr, <span class=\"hljs-keyword\">sizeof</span>(SOCKADDR_IN));<br>\t<span class=\"hljs-keyword\">if</span> (ret == SOCKET_ERROR)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;套接字绑定失败&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t\tclosesocket(serverSocket);<span class=\"hljs-comment\">//关闭套接字</span><br>\t\tWSACleanup();<br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>其间也可以加一个版本判断，判断注册的套接字是否是2.2版本的</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">if</span> (LOBYTE(wsd.wVersion != <span class=\"hljs-number\">2</span> || HIBYTE(wsd.wVersion) != <span class=\"hljs-number\">2</span>))<br>&#123;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;套接字版本错误，需要打开2.2版本的套接字&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\tWSACleanup();<br>\t<span class=\"hljs-keyword\">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"3-套接字监听\"><a href=\"#3-套接字监听\" class=\"headerlink\" title=\"3.套接字监听\"></a>3.套接字监听</h2><p>C++没有提供专门的异步套接字监听方法，如果不想使用阻塞的方式，即同步方式监听套接字的话，就需要通过线程来实现异步监听了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\">SOCKET <span class=\"hljs-title\">Server::ClientListen</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">int</span> ret = listen(serverSocket, SOMAXCONN);<span class=\"hljs-comment\">//开启套接字监听，SOMAXCONN--监听队列设为最大</span><br>\t<span class=\"hljs-keyword\">if</span> (ret == SOCKET_ERROR)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;监听时发生错误&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t\tclosesocket(serverSocket);<br>\t\tWSACleanup();<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>\t&#125;<br>\tsockaddr_in clientAddr;<span class=\"hljs-comment\">//用于存储接收到的客户端的地址信息</span><br>\t<span class=\"hljs-keyword\">int</span> clientAddrLen = <span class=\"hljs-keyword\">sizeof</span>(clientAddr);<br>    <span class=\"hljs-comment\">//接受serverSocket缓冲区里clientAddrlen长度的内容，即一个套接字</span><br>\tSOCKET clientSocket = accept(serverSocket, (sockaddr FAR*)&amp;clientAddr, &amp;clientAddrLen);<br>\t<span class=\"hljs-keyword\">if</span> (clientSocket == INVALID_SOCKET)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;接受客户端时发生错误&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t\tclosesocket(serverSocket);<br>\t\tWSACleanup();<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>\t&#125;<br>\t<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;接受到客户端&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;<br>\t<span class=\"hljs-keyword\">return</span> clientSocket;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"4-接受消息\"><a href=\"#4-接受消息\" class=\"headerlink\" title=\"4.接受消息\"></a>4.接受消息</h2><p>获取到客户端的套接字后，就可以就收客户端发送过来的消息了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Server::Receive</span><span class=\"hljs-params\">(SOCKET clientSocket)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">char</span> receiveBuff[<span class=\"hljs-number\">50</span>];<span class=\"hljs-comment\">//接受消息内容缓冲数组</span><br>    <span class=\"hljs-comment\">//接受消息</span><br>\trecv(clientSocket, receiveBuff, <span class=\"hljs-built_in\">strlen</span>(receiveBuff), <span class=\"hljs-number\">0</span>);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s\\n&quot;</span>, receiveBuff);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"5-发送消息\"><a href=\"#5-发送消息\" class=\"headerlink\" title=\"5.发送消息\"></a>5.发送消息</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Server::Send</span><span class=\"hljs-params\">(SOCKET clientSocket, <span class=\"hljs-keyword\">char</span> * sendBuff)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//发送sendBuff发送消息数组钟的内容到clientSocket套接字</span><br>\tsend(clientSocket, sendBuff, <span class=\"hljs-built_in\">strlen</span>(sendBuff) + <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"二、GameMode与GameInstance\"><a href=\"#二、GameMode与GameInstance\" class=\"headerlink\" title=\"二、GameMode与GameInstance\"></a>二、GameMode与GameInstance</h1><p>由于UE4在换关卡的时候会删除世界大纲中的上一关卡中的所有的内容，所以对于需要在整个游戏运行期间都必须工作的套接字来说，需要在一个从游戏开始运行到游戏程序关闭都存在的场所中工作，这个场所就是GameInstance，而使用自定义GameInstance需要用到GameMode，所以在写UE4客户端套接字之前，我们有必要先了解GameInstance和GameMode。</p>\n<h2 id=\"1-GameInstance\"><a href=\"#1-GameInstance\" class=\"headerlink\" title=\"1.GameInstance\"></a>1.GameInstance</h2><p>要了解GameInstance，首先我们要对UE的引擎结构有一点点的了解。</p>\n<p>UE的宇宙是由UEngine这个创世神管理的各个World组成的，每个World就是一个个平行世界，编辑模式是一个World，运行模式是一个World，而每个World又由各个Level组成，每个Level又由各个Actor组成，而每个Actor拥有各种不同Component从而形成了各式各样的Actor，于是多姿多彩的UE世界便展开了，而GameInstance就是凌驾于World之上的存在。</p>\n<p><font color=\"red\"> GameInstance的生命周期就是整个游戏进程的生命周期，从游戏开始到游戏程序关闭，并且GameInstance在整个游戏进程中只存在一个对象，即单例，就如名字一般</font>。所以任何凌驾于Level和World之上的逻辑都应该在GameInstance中保存和实现，比如游戏网络连接，因为Level在切换时UE4会清空上一个Level在世界大纲中所有内容，然后加载下一个Level的内容，此时如果把游戏网络连接的逻辑放在Level或World中，这些逻辑就会被清空，在上一个Level内容被清空到下一个Level中重新加载网络连接逻辑的期间游戏会处于网络孤立状态。在游戏运行期间World在任意时刻其实都是是唯一的，为什么网络连接的逻辑不能放在World中，而要放在GameInstance中呢?这是因为UE在加载新的Level时，其实是在销毁前一个World，创建了一个新的World。但是World依然只有一个。</p>\n<p><strong>使用GameInstance</strong></p>\n<p>使用GameInstance的方法很简单，就是创建一个类继承自UGameInstance的子类，这个子类就继承到了GameInstance的所有属性了。</p>\n<p>但是GameInstance不存在于世界大纲中该如何执行在其中实现的逻辑代码呢？这就是我们接下来要来了解的GameMode的事了。</p>\n<h2 id=\"2-GameMode\"><a href=\"#2-GameMode\" class=\"headerlink\" title=\"2.GameMode\"></a>2.GameMode</h2><p>首先我们需要知道什么是GameMode，在UE4里GameMode是对应World层存在的，UE4给予GameMode的职责就是处理与实现游戏逻辑，即游戏的玩法，这里我们要区分GameMode与LevelBlueptint，LevelBlueprint是对应Level存在在，每一个Level有且只有一个LevelBlueprint，而GameMode是对应World存在的，每一个World有且只有一个GameMode，但是一个UE4游戏中是可以有多个GameMode，就像一个游戏可以有多种规则玩法一样。</p>\n<p>在UE4里GameInstance里的内容可以被全局调用，那么我们为什么要使用GameMode来实现网络连接而不是用更易理解的LevelBlueprint呢？这是因为GameMode提供了内容在拥有不同GameMode的World中迁移的能力，加以大多数游戏一般只有一中游戏规则，即一个GameMode，所以在GameMode中做网络连接的逻辑是较为恰当的。</p>\n<p><strong>使用GameMode</strong></p>\n<p>GameMode实质上是一个继承自GameModeBase的蓝图类，我们只需创建一个继承自GameModeBase的GameMode，就可以在GameMode中编写蓝图脚本调用C++函数来实现游戏逻辑了，为什么在GameMode中只进行函数调用呢？因为如果所有的代码逻辑都在GameMode中实现就会显得GameMode过于臃肿，所以GameMode一般进行函数调用，而函数的实现则在C++类中处理。</p>\n<p>至此，客户端的网络部分的代码逻辑在什么地方编写就基本确定了。</p>\n<h1 id=\"三、UE4客户端\"><a href=\"#三、UE4客户端\" class=\"headerlink\" title=\"三、UE4客户端\"></a>三、UE4客户端</h1><h2 id=\"1-前提准备\"><a href=\"#1-前提准备\" class=\"headerlink\" title=\"1.前提准备\"></a>1.前提准备</h2><ul>\n<li><p>UE4编写网络模块的逻辑需要在.Build.cs文件里添加两个模块<font color=\"red\"> “Sockets”, “Networking”</font>；</p>\n</li>\n<li><p>创建一个继承自UGameInstance的类作为网络部分的代码实现模块；</p>\n</li>\n<li><p>创建一个继承自GameModeBase的GameMode，并在Settings/Project Settings/Maps&amp;Mode下设置项目默认的GameMode和GameInstance。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171635.png\"></p>\n</li>\n</ul>\n<h2 id=\"2-连接服务器\"><a href=\"#2-连接服务器\" class=\"headerlink\" title=\"2.连接服务器\"></a>2.连接服务器</h2><p><strong>.h</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> once</span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;FReceiveThread.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;Runtime/NEtworking/Public/Networking.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;CoreMinimal.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;Engine/GameInstance.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;ServerConnector.generated.h&quot;</span></span><br><br>UCLASS()<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MYGAME_API</span> <span class=\"hljs-title\">UServerConnector</span> :</span> <span class=\"hljs-keyword\">public</span> UGameInstance<br>&#123;<br>\tGENERATED_BODY()<br><span class=\"hljs-keyword\">private</span>:<br><br>\tFSocket *connectSocket;<br>\tFIPv4Address ip;<br>\tTSharedPtr&lt;FReceiveThread&gt; receiveThread;<br><br><span class=\"hljs-keyword\">public</span>:<br><br>\tFString msg;<br><br><span class=\"hljs-keyword\">public</span>:<br>\tUServerConnector() &#123;&#125;<br>\t<span class=\"hljs-comment\">//create socket and connect server</span><br>\tUFUNCTION(BlueprintCallable,Category=<span class=\"hljs-string\">&quot;ClientSocket&quot;</span>)<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">ServerConnect</span><span class=\"hljs-params\">(FString ip,int32 port)</span></span>;<br>\t<span class=\"hljs-comment\">//send message to server</span><br>\tUFUNCTION(BlueprintCallable, Category = <span class=\"hljs-string\">&quot;ClientSocket&quot;</span>)<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">Send</span><span class=\"hljs-params\">(FString msg)</span></span>;<br>\t<span class=\"hljs-comment\">//receive message from server</span><br>\tUFUNCTION(BlueprintCallable, Category = <span class=\"hljs-string\">&quot;ClientSocket&quot;</span>)<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">Receive</span><span class=\"hljs-params\">()</span></span>;<br>\t<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p><strong>连接Server</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">UServerConnector::ServerConnect</span><span class=\"hljs-params\">(FString ip, int32 port)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tFIPv4Address::Parse(ip,<span class=\"hljs-keyword\">this</span>-&gt;ip);<span class=\"hljs-comment\">//将字符串表示的ip转换成点分十进制的ip</span><br>    <span class=\"hljs-comment\">//创建服务器套接字地址，PLATFROM_SOCKTSUBSYSTEM--选择当前系统的套接字</span><br>\tTSharedPtr&lt;FInternetAddr&gt; addr = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateInternetAddr();<br>\taddr-&gt;SetIp(<span class=\"hljs-keyword\">this</span>-&gt;ip.Value);<span class=\"hljs-comment\">//向套接字地址绑定服务器ip</span><br>\taddr-&gt;SetPort(port);<span class=\"hljs-comment\">//向套接字地址绑定服务器端口</span><br>    <span class=\"hljs-comment\">//创建客户端套接字，NAME_Stream--使用流式传输，Default--套接字描述，false使用TCP，Ture使用UDP连接</span><br>\tconnectSocket = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateSocket(NAME_Stream, TEXT(<span class=\"hljs-string\">&quot;Default&quot;</span>), <span class=\"hljs-literal\">false</span>);<br>\t<span class=\"hljs-keyword\">if</span> (!connectSocket-&gt;Connect(*addr))<span class=\"hljs-comment\">//连接服务器</span><br>\t&#123;<br>\t\tUE_LOG(LogTemp, Error, TEXT(<span class=\"hljs-string\">&quot;ServerConnector.cpp:Connect Failed&quot;</span>));<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t&#125;<br>\tUE_LOG(LogTemp, Error, TEXT(<span class=\"hljs-string\">&quot;Connect Succeed&quot;</span>));<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"3-发送消息\"><a href=\"#3-发送消息\" class=\"headerlink\" title=\"3.发送消息\"></a>3.发送消息</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">UServerConnector::Send</span><span class=\"hljs-params\">(FString msg)</span></span>&#123;    <span class=\"hljs-comment\">//将字符串形式的消息转换成TCHAR*类型，因为二进制流的转换只支持TCHAR类型\tTCHAR *seriallizedChar = msg.GetCharArray().GetData();\tint32 size = FCString::Strlen(seriallizedChar) + 1;//计算消息的内存大小\tint32 sent = 0;//这一行是Send函数的格式要求，提供给Send内部使用的参数    //将消息转化成二进制流并向服务器发送消息\tif (!connectSocket-&gt;Send((uint8*)TCHAR_TO_UTF8(seriallizedChar), size, sent))\t&#123;\t\tUE_LOG(LogTemp, Error, TEXT(&quot;Message Send Failly&quot;));\t\treturn false;\t&#125;\tUE_LOG(LogTemp, Error, TEXT(&quot;Message Send Successlly&quot;));\treturn true;&#125;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"4接受消息\"><a href=\"#4接受消息\" class=\"headerlink\" title=\"4接受消息\"></a>4接受消息</h2><p>接受消息就需要使用到UE4线程了，那么首先我们就需要了解UE4线程。</p>\n<p>在UE4中线程就是一个继承自FRunnable的类，我们创建这个类的对象的同时就开启了线程，<font color=\"red\"> 要注意的是继承自FRunnable的类是一个自定义类，即以F开头的类，并且自定义类在UE4的内容浏览器中是不显示的</font>。</p>\n<p><strong>需要包含的头文件</strong></p>\n<ul>\n<li><p>#include “Runnable.h”</p>\n</li>\n<li><p>#include “RunnableThread.h”</p>\n<p>或者我们也可以直接只包含#include “ThreadingBase.h”头文件，ThreadingBase.h里面就已经包含了线程所需要的所有的头文件</p>\n</li>\n</ul>\n<h3 id=\"h\"><a href=\"#h\" class=\"headerlink\" title=\".h\"></a><strong>.h</strong></h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> once#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;CoreMinimal.h&quot;</span>#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;Runnable.h&quot;</span>#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;RunnableThread.h&quot;</span>#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;Networking.h&quot;</span><span class=\"hljs-comment\">//#include &quot;ThreadingBase.h&quot;class MYGAME_API FReceiveThread : public FRunnable&#123;private:\tFRunnableThread* thread = nullptr;\t\tbool threadRuning;\tFSocket* socket;//需要读取消息的线程public:\tFString msg;private:\t\t\tvirtual uint32 Run() override;\tvirtual void Stop() override;public:\tFReceiveThread(FSocket* socket);\t~FReceiveThread();;&#125;;</span></span><br></code></pre></td></tr></table></figure>\n<p><strong>.cpp</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;FReceiveThread.h&quot;</span>FReceiveThread::FReceiveThread(FSocket* socket)&#123;\tthis-&gt;socket = socket;\tthread = FRunnableThread::Create(this, TEXT(<span class=\"hljs-meta-string\">&quot;ReceiveThread&quot;</span>), 0);\tthreadRuning = true;&#125;uint32 FReceiveThread::Run()&#123;\t<span class=\"hljs-meta-keyword\">if</span> (!socket) return 0;\tTArray<span class=\"hljs-meta-string\">&lt;uint8&gt; buff;\tint32 readType = 0;\twhile (threadRuning)\t&#123;\t\tbuff.Init(0, 1024u);\t\tsocket-&gt;Recv(buff.GetData(), buff.Num(), readType);\t\tmsg = FString(ANSI_TO_TCHAR(reinterpret_cast&lt;const char*&gt;(buff.GetData())));\t\tUE_LOG(LogTemp, Error, TEXT(&quot;%s&quot;), *msg);\t&#125;\treturn 1;&#125;void FReceiveThread::Stop()&#123;\tthreadRuning = false;\tif (thread) thread-&gt;WaitForCompletion();&#125;FReceiveThread::~FReceiveThread()&#123;\tthreadRuning = false;\tdelete thread;\tthread = NULL;&#125;</span></span><br></code></pre></td></tr></table></figure>"},{"title":"【UE4】UE4角色控制","date":"2021-05-14T09:27:32.000Z","password":null,"abstract":null,"message":null,"_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n\n\n<!--more-->\n\n# 一、UE4的角色控制框架\n\n做角色控制之前，我们首先要了解UE4的角色控制框架，了解引擎是如何控制角色移动和做出各种骚姿势的。\n\n## 1.Pawn\n\nPawn类就是UE4里可用于操控的游戏物体，Pawn类继承自Actor拥有Actor的所有特性，并且Pawn还带有\n\n- Controller：可以被操控；\n- PhysicsCollision：物理碰撞；\n- MovementInput：事件响应，大多数情况下用于键盘输入事件响应。\n\n## 2.Character\n\nCharacter就是我们即将要使用的类，Character继承自Pawn，也拥有可操控性，物理碰撞和事件响应，除此之外，Character还拥有CapsuleComponent(椭圆碰撞体)，ArrowComponent(角色正面方向)，Mesh。我们向Mesh上添加模型，Character便拥有了可显示的网格。\n\n当然Pawn派生的还有defaultPawn,SpectatorPawn，这里就不探讨了。\n\n## 3.Controller\n\nController也派生自Actor，是与Pawn平级的类，Controller负责控制Pawn及Pawn的派生类，但Controller一般负责高层面的控制，如角色切换，多角色控制等，而Pawn和Character负责处理角色自身的简单控制逻辑，如角色的移动，跑，蹲，跳等运动逻辑。\n\n由于Controller是独立Pawn存在的，所以Controller可以独立存在与World中，如：上帝视角。\n\n一个Controller可以控制多个Pawn，一个Pawn也可以被多个Controller控制。\n\n但是一个Pawn要想被控制就必须关联至少一个Controller，否则尽管在Pawn中编写了控制逻辑，我们依然无法操控Pawn。\n\n# 二、角色控制\n\n与U3D的角色控制一样，在UE4中进行角色控制前也需要进行按键的映射注册。\n\n## 1.注册按键映射\n\n在`Project Settings/Input/Bindings`下，有一个Action Mappings(行为映射)和一个Axis Mappings(轴映射)，Action Mappings是与角色三维坐标轴无关的映射，一般用于触发角色的行为，如：跳，蹲，拾取等行为，并且UE4还为Action Mappings封装好了组合键，在U3D中，组合键的逻辑是需要我们自己写的。Axis Mappings是与角色三维坐标轴有关的映射，一般用于触发角色的移动与视角控制。\n\n<font color= red> 我们将映射注册好之后，UE4会自动按照我们的命名创建触发事件蓝图，这个在后面详细讲解</font>。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171219.png)\n\n这里详细说一下视角控制，视角控制一般使用鼠标来控制(当然也可以使用键盘，只是大多数情况下使用鼠标)，所有我们使用的映射是Mouse Y和Mouse X，我们用一张图来理解Mouse Y和Mouse X的方向：\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171226.png)\n\nMouse Y就是鼠标的Y轴，Mouse X就是鼠标的X轴。\n\n## 2.使用角色蓝图编写控制逻辑\n\n首先我们创建一个继承自Character的蓝图类，然后为Character中添加SpringArm组件并在SpringArm组件下添加Camera组件，SpringArm组件是专门为Camera服务的组件，用于连接Mesh和Camera，可以对Camera进行一些操作，如相机偏移等。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171233.png)\n\n然后向Mesh中添加我们需要的模型，一个Character基本组件就搭建好了\n\n然后我们就可以在Character蓝图类的Event Graph中编写控制逻辑了。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171240.png)\n\nInput Axis MoveForword，Input Axis MoveRight，Input Axis LookUp，Input Axis Turn都是UE4按照我们注册按键映射时的名字为我们创建好的事件，当我们按下对应的键时事件就会被触发。\n\nUE4使用MovementComponent封装好了Pawn的移动实现，Character中也自带有一个CharacterMovement，我们只需要向组件中添加输入就可以使角色移动了，Add Movement Input函数就是用于MovementComponent组件输入的函数，我们只需要传给Add Movement Input函数移动方向和值就可以使角色按照我们规定的方向移动，移动方向的获取，UE4也封装好了Get Forward Vector(正前方)和Get Right Vector(正右方)来获取某一个轴上的正前与正右的方向矢量，Get Control Rotation函数可以获取角色当前的方向矢量，而角色的前后左右移动是在Z轴的垂直面，即XY平面上移动，所以我们需要获取Z轴的正前正右的方向矢量，我们可以使用Break将角色当前的方向矢量拆开成xyz三个标量，只拿Z轴的值再使用Make封装成矢量，这样Get Forward Vector和Get Right Vector所拿到就是Z轴的正前方与正右方了。\n\n而角色的视角转向，UE4使用的是 Controller Yaw，Controller Pitch，Controller Roll来控制的，Controller Yaw控制的是角色的上下方向的视角旋转，Controller Pitch控制的是角色的左右方向的视角旋转，Controller Roll控制的是角色的前后方向的视角旋转，和MoveComponent一样UE4也提供Add Controller Yaw Input，Add Controller Pitch Input，Add Controller Roll Input分别为三者传值。我们只需要将映射对应的值输入给三个函数即可实现角色视角的旋转控制了，然后勾选SpringArm的Details/Camera Settings/Use Pawn Controller Rotation，将视角旋转控制应用到相机上，这样角色就可以通过鼠标进行视角控制了。\n\n## 3.关联角色控制器\n\nUE4的角色控制框架规定了，我们必须为角色关联一个Controller才可以对角色进行控制。\n\n在角色的Details/Input/Auto Receive Input选项中可以切换控制器，UE4为我们封装好了一个Controller--Player 0，我们选择Player 0就可以对角色进行控制了。其他的Palyer 1，Player 2等是用于其他的用途的，我们这里不探讨。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171247.png)\n\n#  三、配置骨骼动画\n\n完成以上步骤，我们的角色就可以在场景中自由自动了，但是这个移动只是纯移动，并不带有移动动画，要想移动更真实，我们还需要为角色配置骨骼动画。\n\n需要注意的是不是什么动画都可以往角色身上套的，只有和角色骨骼相匹配的动画才可以被角色使用，如果我们想要使用某些动画，我们就需要设置模型的骨骼为这些动画配套的骨骼。\n\n## 1.配置骨骼\n\n在导入模型的时候就可以为模型选定骨骼，选定好骨骼的模型导入工程后就不能在更换骨骼了，想要更换骨骼就需要重新导入。这里我们使用UE4自带的骨骼。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171254.png)\n\n还有一步是为模型添加物理资产，在模型视图的Asset Details/Physics/Physics Asset选择与骨骼动画配套的物理资产，至于这个物理资产具体是干什么的这里不深究。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171300.png)\n\n\n\n## 2.混合空间\n\n如上图，我们可以看到一个Blend Space和一个Bland Space 1D，这是UE4专门用来处理某一类动画混合的模块。Blend Space是二维混合空间，可以混合两个方向上的动作，比如，向前前后是一个方向，向左向右是一个方向，Blend Space就可以混合这两个方向的所有动作；而Blend Space 1D则只能混合一个方向上的动作。\n\n这里我们需要为角色前后左右两个方向上的移动添加动作，所以选择Blend Space。打开混合空间\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171307.png)\n\n在动作混合视图中UE4已经为我们预设好了很多骨骼动画，横轴与纵轴的名字要命名规范，因为这两个轴的名字会作为混合空间的参数，从外界传值进来的。横轴纵轴的最大值最小值和分割数都可以根据自己的实际需求设置。\n\nPreview Base Pose是用来设置关键帧姿势的，有的骨骼动画直接包含了姿势动作，Preview Base Pose会自动赋值，有的骨骼动画只包含了动作，这时就需要我们手动赋予姿势了，如我们后面需要用到的扭头的动画。\n\n然后添加上我们需要的动画即可，当Speed变化时，角色的动画会在Idle-Walk-Run之间切换，当Deriction变化时，角色的动画会在Left和Right之间切换。\n\n## 3.动画蓝图\n\nAnimation Blueprint是UE4封装的专门用于管理动画的类，Animation Blueprint可以管理骨骼动画的混合空间也可以直接管理骨骼动画。\n\n在Content Browser中右键选择Animation/Animation Blueprint，然后Parent Class选择父类为AnimInstance，Target Skeletion选择我们角色应用的骨骼，就可以创建一个管理我们选定的骨骼动画的管理蓝图了。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171314.png)\n\n进入动画蓝图，在Anim  Graph视图，我们可以看见一个Final Animation Pose节点，这是UE4封装好的处理角色最终要显示的动画的模块，右键添加添加一个状态机。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171320.png)\n\n双击状态机，进入状态机里，右键添加一个状态并命名为Idle_Walk_Run。一个状态机可以管理多个状态。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171328.png)\n\n双击进入状态，在右侧Asset Browser中选择我们配置好的混合空间，并在左侧MyBlueprint/Variables中添加两个变量Speed和Deriction分别给混合空间的横轴Speed和纵轴Deriction赋值。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171335.png)\n\n然后在动画蓝图的Event Graph中编写逻辑为Speed和Deriction变量赋值。\n\n<img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171341.png\" style=\"zoom:200%;\" />\n\n直接看到角色移动的控制逻辑，UE4为我们封装好了Caculate Deriction来计算角色的移动方向，我们只需要使用Get Velocity和GetActorRotation获取角色的速度矢量和旋转方向赋值给Calculate Deriction既可以了，速度矢量的模，UE4也封装好了VectorLength来计算。\n\n最后在角色蓝图的Mesh的Details/Animation中将Animation Mode设置成Use Animation Blueprint，将Anim Class设置成我们创建的动画蓝图，这样我们的动画就可以应用到我们的角色上了。\n\n# 四、多动画管理\n\n我们的游戏角色一般不可能只有移动的动画，一般还会有其他的动画，如拾取，下蹲等，这时我们就需要进行多动画混合空间的管理了。\n\n多动画管理有两类，一类是与角色移动动画同级的混合动画，在一个时刻是能播放一个动画，二者不兼容，如下蹲，一类是可以在角色移动动画播放的同时也可以播放的混合动画，在一个时刻两个动画都可以播放，二者兼容，如角色站立时扭头。\n\n## 1.不兼容的同级动画管理\n\n按照第三步，我们也可以创建一个Blend Space来混合下蹲动画。当然如果下蹲动画只有一个，就没必要使用Blend Space了，可以直接使用动画蓝图来管理动画。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171351.png)\n\n同样，我们创建一个状态机Crouch，在状态机里配置下蹲动画。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171400.png)\n\n需要注意的是，下蹲动画的横轴和纵轴也需要命名为Speed和Deriction，因为我们的下蹲移动使用的也是前后左右两个方向来控制动画。\n\n然后在动画蓝图的Anim Graph中添加一个Blend Poses by bool来管理移动与下蹲动画，并创建一个bool值来判断动画的执行\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171406.png)\n\nIs Crouch为true时走True Pose,为False时走False Pose，并且可以设置两个分支的动画过度时间。\n\n然后就是在Event Graph中编写下蹲动画的控制逻辑。如步骤三中逻辑控制图的下蹲控制逻辑，UE4甚至封装好了下蹲判断，Is Crouching，可以直接判断角色当前是否处于下蹲状态，直接将这个状态赋值给IsCrouch变量，然后使用Get MoveMen Component给Is Crouching传值。\n\n当然如果我们有更多的不兼容动画需要管理，UE4也为我们提供了Blend Poses by int来管理\n\n## 2.可兼容动画管理\n\n可兼容的动画的混合就不是使用Blend Space来混合了，而是使用Aim Offset来混合。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171413.png)\n\n一般可兼容的动画使用的是关键帧，即只有动画没有姿势，我们需要将动画应用到某一姿势上去，如上图应用到Idle上的Idle的扭头动作。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171419.png)\n\n","source":"_posts/【UE4】UE4角色控制.md","raw":"---\ntitle: 【UE4】UE4角色控制\ndate: 2021-05-14 17:27:32\ntags: UE4\ncategories: 学习笔记\npassword:\nabstract:\nmessage:\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n\n\n<!--more-->\n\n# 一、UE4的角色控制框架\n\n做角色控制之前，我们首先要了解UE4的角色控制框架，了解引擎是如何控制角色移动和做出各种骚姿势的。\n\n## 1.Pawn\n\nPawn类就是UE4里可用于操控的游戏物体，Pawn类继承自Actor拥有Actor的所有特性，并且Pawn还带有\n\n- Controller：可以被操控；\n- PhysicsCollision：物理碰撞；\n- MovementInput：事件响应，大多数情况下用于键盘输入事件响应。\n\n## 2.Character\n\nCharacter就是我们即将要使用的类，Character继承自Pawn，也拥有可操控性，物理碰撞和事件响应，除此之外，Character还拥有CapsuleComponent(椭圆碰撞体)，ArrowComponent(角色正面方向)，Mesh。我们向Mesh上添加模型，Character便拥有了可显示的网格。\n\n当然Pawn派生的还有defaultPawn,SpectatorPawn，这里就不探讨了。\n\n## 3.Controller\n\nController也派生自Actor，是与Pawn平级的类，Controller负责控制Pawn及Pawn的派生类，但Controller一般负责高层面的控制，如角色切换，多角色控制等，而Pawn和Character负责处理角色自身的简单控制逻辑，如角色的移动，跑，蹲，跳等运动逻辑。\n\n由于Controller是独立Pawn存在的，所以Controller可以独立存在与World中，如：上帝视角。\n\n一个Controller可以控制多个Pawn，一个Pawn也可以被多个Controller控制。\n\n但是一个Pawn要想被控制就必须关联至少一个Controller，否则尽管在Pawn中编写了控制逻辑，我们依然无法操控Pawn。\n\n# 二、角色控制\n\n与U3D的角色控制一样，在UE4中进行角色控制前也需要进行按键的映射注册。\n\n## 1.注册按键映射\n\n在`Project Settings/Input/Bindings`下，有一个Action Mappings(行为映射)和一个Axis Mappings(轴映射)，Action Mappings是与角色三维坐标轴无关的映射，一般用于触发角色的行为，如：跳，蹲，拾取等行为，并且UE4还为Action Mappings封装好了组合键，在U3D中，组合键的逻辑是需要我们自己写的。Axis Mappings是与角色三维坐标轴有关的映射，一般用于触发角色的移动与视角控制。\n\n<font color= red> 我们将映射注册好之后，UE4会自动按照我们的命名创建触发事件蓝图，这个在后面详细讲解</font>。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171219.png)\n\n这里详细说一下视角控制，视角控制一般使用鼠标来控制(当然也可以使用键盘，只是大多数情况下使用鼠标)，所有我们使用的映射是Mouse Y和Mouse X，我们用一张图来理解Mouse Y和Mouse X的方向：\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171226.png)\n\nMouse Y就是鼠标的Y轴，Mouse X就是鼠标的X轴。\n\n## 2.使用角色蓝图编写控制逻辑\n\n首先我们创建一个继承自Character的蓝图类，然后为Character中添加SpringArm组件并在SpringArm组件下添加Camera组件，SpringArm组件是专门为Camera服务的组件，用于连接Mesh和Camera，可以对Camera进行一些操作，如相机偏移等。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171233.png)\n\n然后向Mesh中添加我们需要的模型，一个Character基本组件就搭建好了\n\n然后我们就可以在Character蓝图类的Event Graph中编写控制逻辑了。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171240.png)\n\nInput Axis MoveForword，Input Axis MoveRight，Input Axis LookUp，Input Axis Turn都是UE4按照我们注册按键映射时的名字为我们创建好的事件，当我们按下对应的键时事件就会被触发。\n\nUE4使用MovementComponent封装好了Pawn的移动实现，Character中也自带有一个CharacterMovement，我们只需要向组件中添加输入就可以使角色移动了，Add Movement Input函数就是用于MovementComponent组件输入的函数，我们只需要传给Add Movement Input函数移动方向和值就可以使角色按照我们规定的方向移动，移动方向的获取，UE4也封装好了Get Forward Vector(正前方)和Get Right Vector(正右方)来获取某一个轴上的正前与正右的方向矢量，Get Control Rotation函数可以获取角色当前的方向矢量，而角色的前后左右移动是在Z轴的垂直面，即XY平面上移动，所以我们需要获取Z轴的正前正右的方向矢量，我们可以使用Break将角色当前的方向矢量拆开成xyz三个标量，只拿Z轴的值再使用Make封装成矢量，这样Get Forward Vector和Get Right Vector所拿到就是Z轴的正前方与正右方了。\n\n而角色的视角转向，UE4使用的是 Controller Yaw，Controller Pitch，Controller Roll来控制的，Controller Yaw控制的是角色的上下方向的视角旋转，Controller Pitch控制的是角色的左右方向的视角旋转，Controller Roll控制的是角色的前后方向的视角旋转，和MoveComponent一样UE4也提供Add Controller Yaw Input，Add Controller Pitch Input，Add Controller Roll Input分别为三者传值。我们只需要将映射对应的值输入给三个函数即可实现角色视角的旋转控制了，然后勾选SpringArm的Details/Camera Settings/Use Pawn Controller Rotation，将视角旋转控制应用到相机上，这样角色就可以通过鼠标进行视角控制了。\n\n## 3.关联角色控制器\n\nUE4的角色控制框架规定了，我们必须为角色关联一个Controller才可以对角色进行控制。\n\n在角色的Details/Input/Auto Receive Input选项中可以切换控制器，UE4为我们封装好了一个Controller--Player 0，我们选择Player 0就可以对角色进行控制了。其他的Palyer 1，Player 2等是用于其他的用途的，我们这里不探讨。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171247.png)\n\n#  三、配置骨骼动画\n\n完成以上步骤，我们的角色就可以在场景中自由自动了，但是这个移动只是纯移动，并不带有移动动画，要想移动更真实，我们还需要为角色配置骨骼动画。\n\n需要注意的是不是什么动画都可以往角色身上套的，只有和角色骨骼相匹配的动画才可以被角色使用，如果我们想要使用某些动画，我们就需要设置模型的骨骼为这些动画配套的骨骼。\n\n## 1.配置骨骼\n\n在导入模型的时候就可以为模型选定骨骼，选定好骨骼的模型导入工程后就不能在更换骨骼了，想要更换骨骼就需要重新导入。这里我们使用UE4自带的骨骼。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171254.png)\n\n还有一步是为模型添加物理资产，在模型视图的Asset Details/Physics/Physics Asset选择与骨骼动画配套的物理资产，至于这个物理资产具体是干什么的这里不深究。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171300.png)\n\n\n\n## 2.混合空间\n\n如上图，我们可以看到一个Blend Space和一个Bland Space 1D，这是UE4专门用来处理某一类动画混合的模块。Blend Space是二维混合空间，可以混合两个方向上的动作，比如，向前前后是一个方向，向左向右是一个方向，Blend Space就可以混合这两个方向的所有动作；而Blend Space 1D则只能混合一个方向上的动作。\n\n这里我们需要为角色前后左右两个方向上的移动添加动作，所以选择Blend Space。打开混合空间\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171307.png)\n\n在动作混合视图中UE4已经为我们预设好了很多骨骼动画，横轴与纵轴的名字要命名规范，因为这两个轴的名字会作为混合空间的参数，从外界传值进来的。横轴纵轴的最大值最小值和分割数都可以根据自己的实际需求设置。\n\nPreview Base Pose是用来设置关键帧姿势的，有的骨骼动画直接包含了姿势动作，Preview Base Pose会自动赋值，有的骨骼动画只包含了动作，这时就需要我们手动赋予姿势了，如我们后面需要用到的扭头的动画。\n\n然后添加上我们需要的动画即可，当Speed变化时，角色的动画会在Idle-Walk-Run之间切换，当Deriction变化时，角色的动画会在Left和Right之间切换。\n\n## 3.动画蓝图\n\nAnimation Blueprint是UE4封装的专门用于管理动画的类，Animation Blueprint可以管理骨骼动画的混合空间也可以直接管理骨骼动画。\n\n在Content Browser中右键选择Animation/Animation Blueprint，然后Parent Class选择父类为AnimInstance，Target Skeletion选择我们角色应用的骨骼，就可以创建一个管理我们选定的骨骼动画的管理蓝图了。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171314.png)\n\n进入动画蓝图，在Anim  Graph视图，我们可以看见一个Final Animation Pose节点，这是UE4封装好的处理角色最终要显示的动画的模块，右键添加添加一个状态机。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171320.png)\n\n双击状态机，进入状态机里，右键添加一个状态并命名为Idle_Walk_Run。一个状态机可以管理多个状态。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171328.png)\n\n双击进入状态，在右侧Asset Browser中选择我们配置好的混合空间，并在左侧MyBlueprint/Variables中添加两个变量Speed和Deriction分别给混合空间的横轴Speed和纵轴Deriction赋值。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171335.png)\n\n然后在动画蓝图的Event Graph中编写逻辑为Speed和Deriction变量赋值。\n\n<img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171341.png\" style=\"zoom:200%;\" />\n\n直接看到角色移动的控制逻辑，UE4为我们封装好了Caculate Deriction来计算角色的移动方向，我们只需要使用Get Velocity和GetActorRotation获取角色的速度矢量和旋转方向赋值给Calculate Deriction既可以了，速度矢量的模，UE4也封装好了VectorLength来计算。\n\n最后在角色蓝图的Mesh的Details/Animation中将Animation Mode设置成Use Animation Blueprint，将Anim Class设置成我们创建的动画蓝图，这样我们的动画就可以应用到我们的角色上了。\n\n# 四、多动画管理\n\n我们的游戏角色一般不可能只有移动的动画，一般还会有其他的动画，如拾取，下蹲等，这时我们就需要进行多动画混合空间的管理了。\n\n多动画管理有两类，一类是与角色移动动画同级的混合动画，在一个时刻是能播放一个动画，二者不兼容，如下蹲，一类是可以在角色移动动画播放的同时也可以播放的混合动画，在一个时刻两个动画都可以播放，二者兼容，如角色站立时扭头。\n\n## 1.不兼容的同级动画管理\n\n按照第三步，我们也可以创建一个Blend Space来混合下蹲动画。当然如果下蹲动画只有一个，就没必要使用Blend Space了，可以直接使用动画蓝图来管理动画。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171351.png)\n\n同样，我们创建一个状态机Crouch，在状态机里配置下蹲动画。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171400.png)\n\n需要注意的是，下蹲动画的横轴和纵轴也需要命名为Speed和Deriction，因为我们的下蹲移动使用的也是前后左右两个方向来控制动画。\n\n然后在动画蓝图的Anim Graph中添加一个Blend Poses by bool来管理移动与下蹲动画，并创建一个bool值来判断动画的执行\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171406.png)\n\nIs Crouch为true时走True Pose,为False时走False Pose，并且可以设置两个分支的动画过度时间。\n\n然后就是在Event Graph中编写下蹲动画的控制逻辑。如步骤三中逻辑控制图的下蹲控制逻辑，UE4甚至封装好了下蹲判断，Is Crouching，可以直接判断角色当前是否处于下蹲状态，直接将这个状态赋值给IsCrouch变量，然后使用Get MoveMen Component给Is Crouching传值。\n\n当然如果我们有更多的不兼容动画需要管理，UE4也为我们提供了Blend Poses by int来管理\n\n## 2.可兼容动画管理\n\n可兼容的动画的混合就不是使用Blend Space来混合了，而是使用Aim Offset来混合。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171413.png)\n\n一般可兼容的动画使用的是关键帧，即只有动画没有姿势，我们需要将动画应用到某一姿势上去，如上图应用到Idle上的Idle的扭头动作。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171419.png)\n\n","slug":"【UE4】UE4角色控制","published":1,"updated":"2021-05-14T10:15:18.645Z","_id":"ckoo4kci10003wkr7hns74gep","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n\n\n<a id=\"more\"></a>\n\n<h1 id=\"一、UE4的角色控制框架\"><a href=\"#一、UE4的角色控制框架\" class=\"headerlink\" title=\"一、UE4的角色控制框架\"></a>一、UE4的角色控制框架</h1><p>做角色控制之前，我们首先要了解UE4的角色控制框架，了解引擎是如何控制角色移动和做出各种骚姿势的。</p>\n<h2 id=\"1-Pawn\"><a href=\"#1-Pawn\" class=\"headerlink\" title=\"1.Pawn\"></a>1.Pawn</h2><p>Pawn类就是UE4里可用于操控的游戏物体，Pawn类继承自Actor拥有Actor的所有特性，并且Pawn还带有</p>\n<ul>\n<li>Controller：可以被操控；</li>\n<li>PhysicsCollision：物理碰撞；</li>\n<li>MovementInput：事件响应，大多数情况下用于键盘输入事件响应。</li>\n</ul>\n<h2 id=\"2-Character\"><a href=\"#2-Character\" class=\"headerlink\" title=\"2.Character\"></a>2.Character</h2><p>Character就是我们即将要使用的类，Character继承自Pawn，也拥有可操控性，物理碰撞和事件响应，除此之外，Character还拥有CapsuleComponent(椭圆碰撞体)，ArrowComponent(角色正面方向)，Mesh。我们向Mesh上添加模型，Character便拥有了可显示的网格。</p>\n<p>当然Pawn派生的还有defaultPawn,SpectatorPawn，这里就不探讨了。</p>\n<h2 id=\"3-Controller\"><a href=\"#3-Controller\" class=\"headerlink\" title=\"3.Controller\"></a>3.Controller</h2><p>Controller也派生自Actor，是与Pawn平级的类，Controller负责控制Pawn及Pawn的派生类，但Controller一般负责高层面的控制，如角色切换，多角色控制等，而Pawn和Character负责处理角色自身的简单控制逻辑，如角色的移动，跑，蹲，跳等运动逻辑。</p>\n<p>由于Controller是独立Pawn存在的，所以Controller可以独立存在与World中，如：上帝视角。</p>\n<p>一个Controller可以控制多个Pawn，一个Pawn也可以被多个Controller控制。</p>\n<p>但是一个Pawn要想被控制就必须关联至少一个Controller，否则尽管在Pawn中编写了控制逻辑，我们依然无法操控Pawn。</p>\n<h1 id=\"二、角色控制\"><a href=\"#二、角色控制\" class=\"headerlink\" title=\"二、角色控制\"></a>二、角色控制</h1><p>与U3D的角色控制一样，在UE4中进行角色控制前也需要进行按键的映射注册。</p>\n<h2 id=\"1-注册按键映射\"><a href=\"#1-注册按键映射\" class=\"headerlink\" title=\"1.注册按键映射\"></a>1.注册按键映射</h2><p>在<code>Project Settings/Input/Bindings</code>下，有一个Action Mappings(行为映射)和一个Axis Mappings(轴映射)，Action Mappings是与角色三维坐标轴无关的映射，一般用于触发角色的行为，如：跳，蹲，拾取等行为，并且UE4还为Action Mappings封装好了组合键，在U3D中，组合键的逻辑是需要我们自己写的。Axis Mappings是与角色三维坐标轴有关的映射，一般用于触发角色的移动与视角控制。</p>\n<p><font color=\"red\"> 我们将映射注册好之后，UE4会自动按照我们的命名创建触发事件蓝图，这个在后面详细讲解</font>。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171219.png\"></p>\n<p>这里详细说一下视角控制，视角控制一般使用鼠标来控制(当然也可以使用键盘，只是大多数情况下使用鼠标)，所有我们使用的映射是Mouse Y和Mouse X，我们用一张图来理解Mouse Y和Mouse X的方向：</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171226.png\"></p>\n<p>Mouse Y就是鼠标的Y轴，Mouse X就是鼠标的X轴。</p>\n<h2 id=\"2-使用角色蓝图编写控制逻辑\"><a href=\"#2-使用角色蓝图编写控制逻辑\" class=\"headerlink\" title=\"2.使用角色蓝图编写控制逻辑\"></a>2.使用角色蓝图编写控制逻辑</h2><p>首先我们创建一个继承自Character的蓝图类，然后为Character中添加SpringArm组件并在SpringArm组件下添加Camera组件，SpringArm组件是专门为Camera服务的组件，用于连接Mesh和Camera，可以对Camera进行一些操作，如相机偏移等。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171233.png\"></p>\n<p>然后向Mesh中添加我们需要的模型，一个Character基本组件就搭建好了</p>\n<p>然后我们就可以在Character蓝图类的Event Graph中编写控制逻辑了。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171240.png\"></p>\n<p>Input Axis MoveForword，Input Axis MoveRight，Input Axis LookUp，Input Axis Turn都是UE4按照我们注册按键映射时的名字为我们创建好的事件，当我们按下对应的键时事件就会被触发。</p>\n<p>UE4使用MovementComponent封装好了Pawn的移动实现，Character中也自带有一个CharacterMovement，我们只需要向组件中添加输入就可以使角色移动了，Add Movement Input函数就是用于MovementComponent组件输入的函数，我们只需要传给Add Movement Input函数移动方向和值就可以使角色按照我们规定的方向移动，移动方向的获取，UE4也封装好了Get Forward Vector(正前方)和Get Right Vector(正右方)来获取某一个轴上的正前与正右的方向矢量，Get Control Rotation函数可以获取角色当前的方向矢量，而角色的前后左右移动是在Z轴的垂直面，即XY平面上移动，所以我们需要获取Z轴的正前正右的方向矢量，我们可以使用Break将角色当前的方向矢量拆开成xyz三个标量，只拿Z轴的值再使用Make封装成矢量，这样Get Forward Vector和Get Right Vector所拿到就是Z轴的正前方与正右方了。</p>\n<p>而角色的视角转向，UE4使用的是 Controller Yaw，Controller Pitch，Controller Roll来控制的，Controller Yaw控制的是角色的上下方向的视角旋转，Controller Pitch控制的是角色的左右方向的视角旋转，Controller Roll控制的是角色的前后方向的视角旋转，和MoveComponent一样UE4也提供Add Controller Yaw Input，Add Controller Pitch Input，Add Controller Roll Input分别为三者传值。我们只需要将映射对应的值输入给三个函数即可实现角色视角的旋转控制了，然后勾选SpringArm的Details/Camera Settings/Use Pawn Controller Rotation，将视角旋转控制应用到相机上，这样角色就可以通过鼠标进行视角控制了。</p>\n<h2 id=\"3-关联角色控制器\"><a href=\"#3-关联角色控制器\" class=\"headerlink\" title=\"3.关联角色控制器\"></a>3.关联角色控制器</h2><p>UE4的角色控制框架规定了，我们必须为角色关联一个Controller才可以对角色进行控制。</p>\n<p>在角色的Details/Input/Auto Receive Input选项中可以切换控制器，UE4为我们封装好了一个Controller–Player 0，我们选择Player 0就可以对角色进行控制了。其他的Palyer 1，Player 2等是用于其他的用途的，我们这里不探讨。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171247.png\"></p>\n<h1 id=\"三、配置骨骼动画\"><a href=\"#三、配置骨骼动画\" class=\"headerlink\" title=\"三、配置骨骼动画\"></a>三、配置骨骼动画</h1><p>完成以上步骤，我们的角色就可以在场景中自由自动了，但是这个移动只是纯移动，并不带有移动动画，要想移动更真实，我们还需要为角色配置骨骼动画。</p>\n<p>需要注意的是不是什么动画都可以往角色身上套的，只有和角色骨骼相匹配的动画才可以被角色使用，如果我们想要使用某些动画，我们就需要设置模型的骨骼为这些动画配套的骨骼。</p>\n<h2 id=\"1-配置骨骼\"><a href=\"#1-配置骨骼\" class=\"headerlink\" title=\"1.配置骨骼\"></a>1.配置骨骼</h2><p>在导入模型的时候就可以为模型选定骨骼，选定好骨骼的模型导入工程后就不能在更换骨骼了，想要更换骨骼就需要重新导入。这里我们使用UE4自带的骨骼。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171254.png\"></p>\n<p>还有一步是为模型添加物理资产，在模型视图的Asset Details/Physics/Physics Asset选择与骨骼动画配套的物理资产，至于这个物理资产具体是干什么的这里不深究。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171300.png\"></p>\n<h2 id=\"2-混合空间\"><a href=\"#2-混合空间\" class=\"headerlink\" title=\"2.混合空间\"></a>2.混合空间</h2><p>如上图，我们可以看到一个Blend Space和一个Bland Space 1D，这是UE4专门用来处理某一类动画混合的模块。Blend Space是二维混合空间，可以混合两个方向上的动作，比如，向前前后是一个方向，向左向右是一个方向，Blend Space就可以混合这两个方向的所有动作；而Blend Space 1D则只能混合一个方向上的动作。</p>\n<p>这里我们需要为角色前后左右两个方向上的移动添加动作，所以选择Blend Space。打开混合空间</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171307.png\"></p>\n<p>在动作混合视图中UE4已经为我们预设好了很多骨骼动画，横轴与纵轴的名字要命名规范，因为这两个轴的名字会作为混合空间的参数，从外界传值进来的。横轴纵轴的最大值最小值和分割数都可以根据自己的实际需求设置。</p>\n<p>Preview Base Pose是用来设置关键帧姿势的，有的骨骼动画直接包含了姿势动作，Preview Base Pose会自动赋值，有的骨骼动画只包含了动作，这时就需要我们手动赋予姿势了，如我们后面需要用到的扭头的动画。</p>\n<p>然后添加上我们需要的动画即可，当Speed变化时，角色的动画会在Idle-Walk-Run之间切换，当Deriction变化时，角色的动画会在Left和Right之间切换。</p>\n<h2 id=\"3-动画蓝图\"><a href=\"#3-动画蓝图\" class=\"headerlink\" title=\"3.动画蓝图\"></a>3.动画蓝图</h2><p>Animation Blueprint是UE4封装的专门用于管理动画的类，Animation Blueprint可以管理骨骼动画的混合空间也可以直接管理骨骼动画。</p>\n<p>在Content Browser中右键选择Animation/Animation Blueprint，然后Parent Class选择父类为AnimInstance，Target Skeletion选择我们角色应用的骨骼，就可以创建一个管理我们选定的骨骼动画的管理蓝图了。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171314.png\"></p>\n<p>进入动画蓝图，在Anim  Graph视图，我们可以看见一个Final Animation Pose节点，这是UE4封装好的处理角色最终要显示的动画的模块，右键添加添加一个状态机。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171320.png\"></p>\n<p>双击状态机，进入状态机里，右键添加一个状态并命名为Idle_Walk_Run。一个状态机可以管理多个状态。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171328.png\"></p>\n<p>双击进入状态，在右侧Asset Browser中选择我们配置好的混合空间，并在左侧MyBlueprint/Variables中添加两个变量Speed和Deriction分别给混合空间的横轴Speed和纵轴Deriction赋值。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171335.png\"></p>\n<p>然后在动画蓝图的Event Graph中编写逻辑为Speed和Deriction变量赋值。</p>\n<img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171341.png\" style=\"zoom:200%;\">\n\n<p>直接看到角色移动的控制逻辑，UE4为我们封装好了Caculate Deriction来计算角色的移动方向，我们只需要使用Get Velocity和GetActorRotation获取角色的速度矢量和旋转方向赋值给Calculate Deriction既可以了，速度矢量的模，UE4也封装好了VectorLength来计算。</p>\n<p>最后在角色蓝图的Mesh的Details/Animation中将Animation Mode设置成Use Animation Blueprint，将Anim Class设置成我们创建的动画蓝图，这样我们的动画就可以应用到我们的角色上了。</p>\n<h1 id=\"四、多动画管理\"><a href=\"#四、多动画管理\" class=\"headerlink\" title=\"四、多动画管理\"></a>四、多动画管理</h1><p>我们的游戏角色一般不可能只有移动的动画，一般还会有其他的动画，如拾取，下蹲等，这时我们就需要进行多动画混合空间的管理了。</p>\n<p>多动画管理有两类，一类是与角色移动动画同级的混合动画，在一个时刻是能播放一个动画，二者不兼容，如下蹲，一类是可以在角色移动动画播放的同时也可以播放的混合动画，在一个时刻两个动画都可以播放，二者兼容，如角色站立时扭头。</p>\n<h2 id=\"1-不兼容的同级动画管理\"><a href=\"#1-不兼容的同级动画管理\" class=\"headerlink\" title=\"1.不兼容的同级动画管理\"></a>1.不兼容的同级动画管理</h2><p>按照第三步，我们也可以创建一个Blend Space来混合下蹲动画。当然如果下蹲动画只有一个，就没必要使用Blend Space了，可以直接使用动画蓝图来管理动画。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171351.png\"></p>\n<p>同样，我们创建一个状态机Crouch，在状态机里配置下蹲动画。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171400.png\"></p>\n<p>需要注意的是，下蹲动画的横轴和纵轴也需要命名为Speed和Deriction，因为我们的下蹲移动使用的也是前后左右两个方向来控制动画。</p>\n<p>然后在动画蓝图的Anim Graph中添加一个Blend Poses by bool来管理移动与下蹲动画，并创建一个bool值来判断动画的执行</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171406.png\"></p>\n<p>Is Crouch为true时走True Pose,为False时走False Pose，并且可以设置两个分支的动画过度时间。</p>\n<p>然后就是在Event Graph中编写下蹲动画的控制逻辑。如步骤三中逻辑控制图的下蹲控制逻辑，UE4甚至封装好了下蹲判断，Is Crouching，可以直接判断角色当前是否处于下蹲状态，直接将这个状态赋值给IsCrouch变量，然后使用Get MoveMen Component给Is Crouching传值。</p>\n<p>当然如果我们有更多的不兼容动画需要管理，UE4也为我们提供了Blend Poses by int来管理</p>\n<h2 id=\"2-可兼容动画管理\"><a href=\"#2-可兼容动画管理\" class=\"headerlink\" title=\"2.可兼容动画管理\"></a>2.可兼容动画管理</h2><p>可兼容的动画的混合就不是使用Blend Space来混合了，而是使用Aim Offset来混合。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171413.png\"></p>\n<p>一般可兼容的动画使用的是关键帧，即只有动画没有姿势，我们需要将动画应用到某一姿势上去，如上图应用到Idle上的Idle的扭头动作。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171419.png\"></p>\n","site":{"data":{}},"excerpt":"<meta name=\"referrer\" content=\"no-referrer\">","more":"<h1 id=\"一、UE4的角色控制框架\"><a href=\"#一、UE4的角色控制框架\" class=\"headerlink\" title=\"一、UE4的角色控制框架\"></a>一、UE4的角色控制框架</h1><p>做角色控制之前，我们首先要了解UE4的角色控制框架，了解引擎是如何控制角色移动和做出各种骚姿势的。</p>\n<h2 id=\"1-Pawn\"><a href=\"#1-Pawn\" class=\"headerlink\" title=\"1.Pawn\"></a>1.Pawn</h2><p>Pawn类就是UE4里可用于操控的游戏物体，Pawn类继承自Actor拥有Actor的所有特性，并且Pawn还带有</p>\n<ul>\n<li>Controller：可以被操控；</li>\n<li>PhysicsCollision：物理碰撞；</li>\n<li>MovementInput：事件响应，大多数情况下用于键盘输入事件响应。</li>\n</ul>\n<h2 id=\"2-Character\"><a href=\"#2-Character\" class=\"headerlink\" title=\"2.Character\"></a>2.Character</h2><p>Character就是我们即将要使用的类，Character继承自Pawn，也拥有可操控性，物理碰撞和事件响应，除此之外，Character还拥有CapsuleComponent(椭圆碰撞体)，ArrowComponent(角色正面方向)，Mesh。我们向Mesh上添加模型，Character便拥有了可显示的网格。</p>\n<p>当然Pawn派生的还有defaultPawn,SpectatorPawn，这里就不探讨了。</p>\n<h2 id=\"3-Controller\"><a href=\"#3-Controller\" class=\"headerlink\" title=\"3.Controller\"></a>3.Controller</h2><p>Controller也派生自Actor，是与Pawn平级的类，Controller负责控制Pawn及Pawn的派生类，但Controller一般负责高层面的控制，如角色切换，多角色控制等，而Pawn和Character负责处理角色自身的简单控制逻辑，如角色的移动，跑，蹲，跳等运动逻辑。</p>\n<p>由于Controller是独立Pawn存在的，所以Controller可以独立存在与World中，如：上帝视角。</p>\n<p>一个Controller可以控制多个Pawn，一个Pawn也可以被多个Controller控制。</p>\n<p>但是一个Pawn要想被控制就必须关联至少一个Controller，否则尽管在Pawn中编写了控制逻辑，我们依然无法操控Pawn。</p>\n<h1 id=\"二、角色控制\"><a href=\"#二、角色控制\" class=\"headerlink\" title=\"二、角色控制\"></a>二、角色控制</h1><p>与U3D的角色控制一样，在UE4中进行角色控制前也需要进行按键的映射注册。</p>\n<h2 id=\"1-注册按键映射\"><a href=\"#1-注册按键映射\" class=\"headerlink\" title=\"1.注册按键映射\"></a>1.注册按键映射</h2><p>在<code>Project Settings/Input/Bindings</code>下，有一个Action Mappings(行为映射)和一个Axis Mappings(轴映射)，Action Mappings是与角色三维坐标轴无关的映射，一般用于触发角色的行为，如：跳，蹲，拾取等行为，并且UE4还为Action Mappings封装好了组合键，在U3D中，组合键的逻辑是需要我们自己写的。Axis Mappings是与角色三维坐标轴有关的映射，一般用于触发角色的移动与视角控制。</p>\n<p><font color=\"red\"> 我们将映射注册好之后，UE4会自动按照我们的命名创建触发事件蓝图，这个在后面详细讲解</font>。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171219.png\"></p>\n<p>这里详细说一下视角控制，视角控制一般使用鼠标来控制(当然也可以使用键盘，只是大多数情况下使用鼠标)，所有我们使用的映射是Mouse Y和Mouse X，我们用一张图来理解Mouse Y和Mouse X的方向：</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171226.png\"></p>\n<p>Mouse Y就是鼠标的Y轴，Mouse X就是鼠标的X轴。</p>\n<h2 id=\"2-使用角色蓝图编写控制逻辑\"><a href=\"#2-使用角色蓝图编写控制逻辑\" class=\"headerlink\" title=\"2.使用角色蓝图编写控制逻辑\"></a>2.使用角色蓝图编写控制逻辑</h2><p>首先我们创建一个继承自Character的蓝图类，然后为Character中添加SpringArm组件并在SpringArm组件下添加Camera组件，SpringArm组件是专门为Camera服务的组件，用于连接Mesh和Camera，可以对Camera进行一些操作，如相机偏移等。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171233.png\"></p>\n<p>然后向Mesh中添加我们需要的模型，一个Character基本组件就搭建好了</p>\n<p>然后我们就可以在Character蓝图类的Event Graph中编写控制逻辑了。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171240.png\"></p>\n<p>Input Axis MoveForword，Input Axis MoveRight，Input Axis LookUp，Input Axis Turn都是UE4按照我们注册按键映射时的名字为我们创建好的事件，当我们按下对应的键时事件就会被触发。</p>\n<p>UE4使用MovementComponent封装好了Pawn的移动实现，Character中也自带有一个CharacterMovement，我们只需要向组件中添加输入就可以使角色移动了，Add Movement Input函数就是用于MovementComponent组件输入的函数，我们只需要传给Add Movement Input函数移动方向和值就可以使角色按照我们规定的方向移动，移动方向的获取，UE4也封装好了Get Forward Vector(正前方)和Get Right Vector(正右方)来获取某一个轴上的正前与正右的方向矢量，Get Control Rotation函数可以获取角色当前的方向矢量，而角色的前后左右移动是在Z轴的垂直面，即XY平面上移动，所以我们需要获取Z轴的正前正右的方向矢量，我们可以使用Break将角色当前的方向矢量拆开成xyz三个标量，只拿Z轴的值再使用Make封装成矢量，这样Get Forward Vector和Get Right Vector所拿到就是Z轴的正前方与正右方了。</p>\n<p>而角色的视角转向，UE4使用的是 Controller Yaw，Controller Pitch，Controller Roll来控制的，Controller Yaw控制的是角色的上下方向的视角旋转，Controller Pitch控制的是角色的左右方向的视角旋转，Controller Roll控制的是角色的前后方向的视角旋转，和MoveComponent一样UE4也提供Add Controller Yaw Input，Add Controller Pitch Input，Add Controller Roll Input分别为三者传值。我们只需要将映射对应的值输入给三个函数即可实现角色视角的旋转控制了，然后勾选SpringArm的Details/Camera Settings/Use Pawn Controller Rotation，将视角旋转控制应用到相机上，这样角色就可以通过鼠标进行视角控制了。</p>\n<h2 id=\"3-关联角色控制器\"><a href=\"#3-关联角色控制器\" class=\"headerlink\" title=\"3.关联角色控制器\"></a>3.关联角色控制器</h2><p>UE4的角色控制框架规定了，我们必须为角色关联一个Controller才可以对角色进行控制。</p>\n<p>在角色的Details/Input/Auto Receive Input选项中可以切换控制器，UE4为我们封装好了一个Controller–Player 0，我们选择Player 0就可以对角色进行控制了。其他的Palyer 1，Player 2等是用于其他的用途的，我们这里不探讨。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171247.png\"></p>\n<h1 id=\"三、配置骨骼动画\"><a href=\"#三、配置骨骼动画\" class=\"headerlink\" title=\"三、配置骨骼动画\"></a>三、配置骨骼动画</h1><p>完成以上步骤，我们的角色就可以在场景中自由自动了，但是这个移动只是纯移动，并不带有移动动画，要想移动更真实，我们还需要为角色配置骨骼动画。</p>\n<p>需要注意的是不是什么动画都可以往角色身上套的，只有和角色骨骼相匹配的动画才可以被角色使用，如果我们想要使用某些动画，我们就需要设置模型的骨骼为这些动画配套的骨骼。</p>\n<h2 id=\"1-配置骨骼\"><a href=\"#1-配置骨骼\" class=\"headerlink\" title=\"1.配置骨骼\"></a>1.配置骨骼</h2><p>在导入模型的时候就可以为模型选定骨骼，选定好骨骼的模型导入工程后就不能在更换骨骼了，想要更换骨骼就需要重新导入。这里我们使用UE4自带的骨骼。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171254.png\"></p>\n<p>还有一步是为模型添加物理资产，在模型视图的Asset Details/Physics/Physics Asset选择与骨骼动画配套的物理资产，至于这个物理资产具体是干什么的这里不深究。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171300.png\"></p>\n<h2 id=\"2-混合空间\"><a href=\"#2-混合空间\" class=\"headerlink\" title=\"2.混合空间\"></a>2.混合空间</h2><p>如上图，我们可以看到一个Blend Space和一个Bland Space 1D，这是UE4专门用来处理某一类动画混合的模块。Blend Space是二维混合空间，可以混合两个方向上的动作，比如，向前前后是一个方向，向左向右是一个方向，Blend Space就可以混合这两个方向的所有动作；而Blend Space 1D则只能混合一个方向上的动作。</p>\n<p>这里我们需要为角色前后左右两个方向上的移动添加动作，所以选择Blend Space。打开混合空间</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171307.png\"></p>\n<p>在动作混合视图中UE4已经为我们预设好了很多骨骼动画，横轴与纵轴的名字要命名规范，因为这两个轴的名字会作为混合空间的参数，从外界传值进来的。横轴纵轴的最大值最小值和分割数都可以根据自己的实际需求设置。</p>\n<p>Preview Base Pose是用来设置关键帧姿势的，有的骨骼动画直接包含了姿势动作，Preview Base Pose会自动赋值，有的骨骼动画只包含了动作，这时就需要我们手动赋予姿势了，如我们后面需要用到的扭头的动画。</p>\n<p>然后添加上我们需要的动画即可，当Speed变化时，角色的动画会在Idle-Walk-Run之间切换，当Deriction变化时，角色的动画会在Left和Right之间切换。</p>\n<h2 id=\"3-动画蓝图\"><a href=\"#3-动画蓝图\" class=\"headerlink\" title=\"3.动画蓝图\"></a>3.动画蓝图</h2><p>Animation Blueprint是UE4封装的专门用于管理动画的类，Animation Blueprint可以管理骨骼动画的混合空间也可以直接管理骨骼动画。</p>\n<p>在Content Browser中右键选择Animation/Animation Blueprint，然后Parent Class选择父类为AnimInstance，Target Skeletion选择我们角色应用的骨骼，就可以创建一个管理我们选定的骨骼动画的管理蓝图了。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171314.png\"></p>\n<p>进入动画蓝图，在Anim  Graph视图，我们可以看见一个Final Animation Pose节点，这是UE4封装好的处理角色最终要显示的动画的模块，右键添加添加一个状态机。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171320.png\"></p>\n<p>双击状态机，进入状态机里，右键添加一个状态并命名为Idle_Walk_Run。一个状态机可以管理多个状态。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171328.png\"></p>\n<p>双击进入状态，在右侧Asset Browser中选择我们配置好的混合空间，并在左侧MyBlueprint/Variables中添加两个变量Speed和Deriction分别给混合空间的横轴Speed和纵轴Deriction赋值。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171335.png\"></p>\n<p>然后在动画蓝图的Event Graph中编写逻辑为Speed和Deriction变量赋值。</p>\n<img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171341.png\" style=\"zoom:200%;\">\n\n<p>直接看到角色移动的控制逻辑，UE4为我们封装好了Caculate Deriction来计算角色的移动方向，我们只需要使用Get Velocity和GetActorRotation获取角色的速度矢量和旋转方向赋值给Calculate Deriction既可以了，速度矢量的模，UE4也封装好了VectorLength来计算。</p>\n<p>最后在角色蓝图的Mesh的Details/Animation中将Animation Mode设置成Use Animation Blueprint，将Anim Class设置成我们创建的动画蓝图，这样我们的动画就可以应用到我们的角色上了。</p>\n<h1 id=\"四、多动画管理\"><a href=\"#四、多动画管理\" class=\"headerlink\" title=\"四、多动画管理\"></a>四、多动画管理</h1><p>我们的游戏角色一般不可能只有移动的动画，一般还会有其他的动画，如拾取，下蹲等，这时我们就需要进行多动画混合空间的管理了。</p>\n<p>多动画管理有两类，一类是与角色移动动画同级的混合动画，在一个时刻是能播放一个动画，二者不兼容，如下蹲，一类是可以在角色移动动画播放的同时也可以播放的混合动画，在一个时刻两个动画都可以播放，二者兼容，如角色站立时扭头。</p>\n<h2 id=\"1-不兼容的同级动画管理\"><a href=\"#1-不兼容的同级动画管理\" class=\"headerlink\" title=\"1.不兼容的同级动画管理\"></a>1.不兼容的同级动画管理</h2><p>按照第三步，我们也可以创建一个Blend Space来混合下蹲动画。当然如果下蹲动画只有一个，就没必要使用Blend Space了，可以直接使用动画蓝图来管理动画。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171351.png\"></p>\n<p>同样，我们创建一个状态机Crouch，在状态机里配置下蹲动画。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171400.png\"></p>\n<p>需要注意的是，下蹲动画的横轴和纵轴也需要命名为Speed和Deriction，因为我们的下蹲移动使用的也是前后左右两个方向来控制动画。</p>\n<p>然后在动画蓝图的Anim Graph中添加一个Blend Poses by bool来管理移动与下蹲动画，并创建一个bool值来判断动画的执行</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171406.png\"></p>\n<p>Is Crouch为true时走True Pose,为False时走False Pose，并且可以设置两个分支的动画过度时间。</p>\n<p>然后就是在Event Graph中编写下蹲动画的控制逻辑。如步骤三中逻辑控制图的下蹲控制逻辑，UE4甚至封装好了下蹲判断，Is Crouching，可以直接判断角色当前是否处于下蹲状态，直接将这个状态赋值给IsCrouch变量，然后使用Get MoveMen Component给Is Crouching传值。</p>\n<p>当然如果我们有更多的不兼容动画需要管理，UE4也为我们提供了Blend Poses by int来管理</p>\n<h2 id=\"2-可兼容动画管理\"><a href=\"#2-可兼容动画管理\" class=\"headerlink\" title=\"2.可兼容动画管理\"></a>2.可兼容动画管理</h2><p>可兼容的动画的混合就不是使用Blend Space来混合了，而是使用Aim Offset来混合。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171413.png\"></p>\n<p>一般可兼容的动画使用的是关键帧，即只有动画没有姿势，我们需要将动画应用到某一姿势上去，如上图应用到Idle上的Idle的扭头动作。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171419.png\"></p>"},{"title":"【UE4】UE4内嵌Web及与Web通信","date":"2021-05-14T09:28:03.000Z","password":null,"abstract":null,"message":null,"_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n\n\n<!--more-->\n\nUE4嵌入Web及UE4到Web的通信，我使用UE 4.22.3版本，以UE4嵌入ECharts并与ECharts通信为例。\n\n# 一、自定义WebBrowser\n\nUwebBrowser是UE4自带的用于浏览Web的插件类，为了后面进行UE4与Web的通信，所以这里我们需要自定义一个UWebBrowser类。\n\n## 1.创建自定义WebBrowser类\n\n在C++ Classes中右键创建一个自己的继承自widget类的C++类--MyWebBrowser。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170722.png)\n\n## 2.编写自定义WebBrowser\n\n然后在VS中搜索WebBrowser.cpp和WebBrowser.h这是UE4自带的WebBrowser类，虽说是写一个自定义的WebBrowser，但是我们的自定义的WebBrowser在功能上基本和UE4自带的webBrowser一致，所以我们只需将UE4自带的WebBrowser中的代码拷贝到我们自己的MyWebBrowser中稍作修改即可。\n\n当然拷贝时不是全盘拷贝，只需拷贝如下WebBrowser.h中虚线一下的部分拷贝到我们的MyWebBrowser.h中。有时可能出现FOnUrlChanged和FOnBeforePopup报错，等VS反应一下就好了，有时可以直接编译，报红也是可以编译通过的。\n\n```C++\n/*WebBrowser.h*/\n\n#pragma once\n#include \"Components/Widget.h\"\n#include \"WebBrowser.generated.h\"\n\nUCLASS()\nclass WEBBROWSERWIDGET_API UWebBrowser : public UWidget\n{\n    /*--------------------------------------------------------------------------------------*/\n\tGENERATED_UCLASS_BODY()\n\npublic:\n\tDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnUrlChanged, const FText&, Text);\n\tDECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnBeforePopup, FString, URL, FString, Frame);\n\n\t/**\n\t * Load the specified URL\n\t *\n\t * @param NewURL New URL to load\n\t */\n\tUFUNCTION(BlueprintCallable, Category=\"Web Browser\")\n\tvoid LoadURL(FString NewURL);\n\n\t/**\n\t * Load a string as data to create a web page\n\t *\n\t * @param Contents String to load\n\t * @param DummyURL Dummy URL for the page\n\t */\n\tUFUNCTION(BlueprintCallable, Category=\"Web Browser\")\n\tvoid LoadString(FString Contents, FString DummyURL);\n\n\t/**\n\t* Executes a JavaScript string in the context of the web page\n\t*\n\t* @param ScriptText JavaScript string to execute\n\t*/\n\tUFUNCTION(BlueprintCallable, Category = \"Web Browser\")\n\tvoid ExecuteJavascript(const FString& ScriptText);\n\n\t/**\n\t * Get the current title of the web page\n\t */\n\tUFUNCTION(BlueprintCallable, Category=\"Web Browser\")\n\tFText GetTitleText() const;\n\n\t/**\n\t* Gets the currently loaded URL.\n\t*\n\t* @return The URL, or empty string if no document is loaded.\n\t*/\n\tUFUNCTION(BlueprintCallable, Category = \"Web Browser\")\n\tFString GetUrl() const;\n\n\t/** Called when the Url changes. */\n\tUPROPERTY(BlueprintAssignable, Category = \"Web Browser|Event\")\n\tFOnUrlChanged OnUrlChanged;\n\n\t/** Called when a popup is about to spawn. */\n\tUPROPERTY(BlueprintAssignable, Category = \"Web Browser|Event\")\n\tFOnBeforePopup OnBeforePopup;\n\npublic:\n\n\t//~ Begin UWidget interface\n\tvirtual void SynchronizeProperties() override;\n\t// End UWidget interface\n\n\tvirtual void ReleaseSlateResources(bool bReleaseChildren) override;\n\n#if WITH_EDITOR\n\tvirtual const FText GetPaletteCategory() override;\n#endif\n\nprotected:\n\t/** URL that the browser will initially navigate to. The URL should include the protocol, eg http:// */\n\tUPROPERTY(EditAnywhere, Category=Appearance)\n\tFString InitialURL;\n\n\t/** Should the browser window support transparency. */\n\tUPROPERTY(EditAnywhere, Category=Appearance)\n\tbool bSupportsTransparency;\n\nprotected:\n\tTSharedPtr<class SWebBrowser> WebBrowserWidget;\n\nprotected:\n\t// UWidget interface\n\tvirtual TSharedRef<SWidget> RebuildWidget() override;\n\t// End of UWidget interface\n\n\tvoid HandleOnUrlChanged(const FText& Text);\n\tbool HandleOnBeforePopup(FString URL, FString Frame);\n};\n```\n\nWebBrowser.cpp则是全盘拷贝到我们的MyWebBrowser.cpp中，然后将所有的UWebBrowser修改为UMyWebBrowser，将#include \"WebBrowser.h\"改为我们自己的#include \"MyWebBrowser.h\"即可。\n\n这里需要注意，有时会因为引擎位置不同导致#include \"SWebBrowser.h\"头文件打不开，此时我们需要给SWebBrowser.h一个路径即可，如：#include \"Runtime/WebBrowser/Public/SWebBrowser.h\"。\n\n然后如下的代码中的Experimental，可以改也可以不改，这段代码主要控制我们自定义的MyWebBrowser显示在UI的Palette中的分栏位置，这里我都改为My。\n\n```C++\n#if WITH_EDITOR\n\nconst FText UWebBrowser::GetPaletteCategory()\n{\n\treturn LOCTEXT(\"Experimental\", \"Experimental\");\n}\n\n#endif\n```\n\n然后就可以编译了。\n\n## 3.完整代码\n\n这里贴出完整代码，供参考。\n\n```C++\n/*MyWebBrowser.h*/\n\n// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/Widget.h\"\n#include \"MyWebBrowser.generated.h\"\n\nUCLASS()\nclass WEBTEST_API UMyWebBrowser : public UWidget\n{\n\tGENERATED_UCLASS_BODY()\n\npublic:\n\tDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnUrlChanged, const FText&, Text);\n\tDECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnBeforePopup, FString, URL, FString, Frame);\n\n\t/**\n\t * Load the specified URL\n\t *\n\t * @param NewURL New URL to load\n\t */\n\tUFUNCTION(BlueprintCallable, Category = \"Web Browser\")\n\t\tvoid LoadURL(FString NewURL);\n\n\t/**\n\t * Load a string as data to create a web page\n\t *\n\t * @param Contents String to load\n\t * @param DummyURL Dummy URL for the page\n\t */\n\tUFUNCTION(BlueprintCallable, Category = \"Web Browser\")\n\t\tvoid LoadString(FString Contents, FString DummyURL);\n\n\t/**\n\t* Executes a JavaScript string in the context of the web page\n\t*\n\t* @param ScriptText JavaScript string to execute\n\t*/\n\tUFUNCTION(BlueprintCallable, Category = \"Web Browser\")\n\t\tvoid ExecuteJavascript(const FString& ScriptText);\n\n\t/**\n\t * Get the current title of the web page\n\t */\n\tUFUNCTION(BlueprintCallable, Category = \"Web Browser\")\n\t\tFText GetTitleText() const;\n\n\t/**\n\t* Gets the currently loaded URL.\n\t*\n\t* @return The URL, or empty string if no document is loaded.\n\t*/\n\tUFUNCTION(BlueprintCallable, Category = \"Web Browser\")\n\t\tFString GetUrl() const;\n\n\t/** Called when the Url changes. */\n\tUPROPERTY(BlueprintAssignable, Category = \"Web Browser|Event\")\n\tFOnUrlChanged OnUrlChanged;\n\n\t/** Called when a popup is about to spawn. */\n\tUPROPERTY(BlueprintAssignable, Category = \"Web Browser|Event\")\n\tFOnBeforePopup OnBeforePopup;\n\npublic:\n\n\t//~ Begin UWidget interface\n\tvirtual void SynchronizeProperties() override;\n\t// End UWidget interface\n\n\tvirtual void ReleaseSlateResources(bool bReleaseChildren) override;\n\n#if WITH_EDITOR\n\tvirtual const FText GetPaletteCategory() override;\n#endif\n\nprotected:\n\t/** URL that the browser will initially navigate to. The URL should include the protocol, eg http:// */\n\tUPROPERTY(EditAnywhere, Category = Appearance)\n\t\tFString InitialURL;\n\n\t/** Should the browser window support transparency. */\n\tUPROPERTY(EditAnywhere, Category = Appearance)\n\t\tbool bSupportsTransparency;\n\nprotected:\n\tTSharedPtr<class SWebBrowser> WebBrowserWidget;\n\nprotected:\n\t// UWidget interface\n\tvirtual TSharedRef<SWidget> RebuildWidget() override;\n\t// End of UWidget interface\n\n\tvoid HandleOnUrlChanged(const FText& Text);\n\tbool HandleOnBeforePopup(FString URL, FString Frame);\n};\n\n```\n\n```C++\n/*MyWebBrowser.cpp*/\n\n// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"MyWebBrowser.h\"\n#include \"Runtime/WebBrowser/Public/SWebBrowser.h\"\n#include \"Widgets/Layout/SBox.h\"\n#include \"Widgets/Text/STextBlock.h\"\n#include \"Async/TaskGraphInterfaces.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n#if WITH_EDITOR\n#include \"Materials/MaterialInterface.h\"\n#include \"Materials/MaterialExpressionMaterialFunctionCall.h\"\n#include \"Materials/MaterialExpressionTextureSample.h\"\n#include \"Materials/MaterialExpressionTextureSampleParameter2D.h\"\n#include \"Materials/MaterialFunction.h\"\n#include \"Factories/MaterialFactoryNew.h\"\n#include \"AssetRegistryModule.h\"\n#include \"PackageHelperFunctions.h\"\n#endif\n\n#define LOCTEXT_NAMESPACE \"WebBrowser\"\n\n/////////////////////////////////////////////////////\n// UWebBrowser\n\nUMyWebBrowser::UMyWebBrowser(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer)\n{\n\tbIsVariable = true;\n}\n\nvoid UMyWebBrowser::LoadURL(FString NewURL)\n{\n\tif (WebBrowserWidget.IsValid())\n\t{\n\t\treturn WebBrowserWidget->LoadURL(NewURL);\n\t}\n}\n\nvoid UMyWebBrowser::LoadString(FString Contents, FString DummyURL)\n{\n\tif (WebBrowserWidget.IsValid())\n\t{\n\t\treturn WebBrowserWidget->LoadString(Contents, DummyURL);\n\t}\n}\n\nvoid UMyWebBrowser::ExecuteJavascript(const FString& ScriptText)\n{\n\tif (WebBrowserWidget.IsValid())\n\t{\n\t\treturn WebBrowserWidget->ExecuteJavascript(ScriptText);\n\t}\n}\n\nFText UMyWebBrowser::GetTitleText() const\n{\n\tif (WebBrowserWidget.IsValid())\n\t{\n\t\treturn WebBrowserWidget->GetTitleText();\n\t}\n\n\treturn FText::GetEmpty();\n}\n\nFString UMyWebBrowser::GetUrl() const\n{\n\tif (WebBrowserWidget.IsValid())\n\t{\n\t\treturn WebBrowserWidget->GetUrl();\n\t}\n\n\treturn FString();\n}\n\nvoid UMyWebBrowser::ReleaseSlateResources(bool bReleaseChildren)\n{\n\tSuper::ReleaseSlateResources(bReleaseChildren);\n\n\tWebBrowserWidget.Reset();\n}\n\nTSharedRef<SWidget> UMyWebBrowser::RebuildWidget()\n{\n\tif (IsDesignTime())\n\t{\n\t\treturn SNew(SBox)\n\t\t\t.HAlign(HAlign_Center)\n\t\t\t.VAlign(VAlign_Center)\n\t\t\t[\n\t\t\t\tSNew(STextBlock)\n\t\t\t\t.Text(LOCTEXT(\"Web Browser\", \"Web Browser\"))\n\t\t\t];\n\t}\n\telse\n\t{\n\t\tWebBrowserWidget = SNew(SWebBrowser)\n\t\t\t.InitialURL(InitialURL)\n\t\t\t.ShowControls(false)\n\t\t\t.SupportsTransparency(bSupportsTransparency)\n\t\t\t.OnUrlChanged(BIND_UOBJECT_DELEGATE(FOnTextChanged, HandleOnUrlChanged))\n\t\t\t.OnBeforePopup(BIND_UOBJECT_DELEGATE(FOnBeforePopupDelegate, HandleOnBeforePopup));\n\n\t\treturn WebBrowserWidget.ToSharedRef();\n\t}\n}\n\nvoid UMyWebBrowser::SynchronizeProperties()\n{\n\tSuper::SynchronizeProperties();\n\n\tif (WebBrowserWidget.IsValid())\n\t{\n\n\t}\n}\n\nvoid UMyWebBrowser::HandleOnUrlChanged(const FText& InText)\n{\n\tOnUrlChanged.Broadcast(InText);\n}\n\nbool UMyWebBrowser::HandleOnBeforePopup(FString URL, FString Frame)\n{\n\tif (OnBeforePopup.IsBound())\n\t{\n\t\tif (IsInGameThread())\n\t\t{\n\t\t\tOnBeforePopup.Broadcast(URL, Frame);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Retry on the GameThread.\n\t\t\tTWeakObjectPtr<UMyWebBrowser> WeakThis = this;\n\t\t\tFFunctionGraphTask::CreateAndDispatchWhenReady([WeakThis, URL, Frame]()\n\t\t\t{\n\t\t\t\tif (WeakThis.IsValid())\n\t\t\t\t{\n\t\t\t\t\tWeakThis->HandleOnBeforePopup(URL, Frame);\n\t\t\t\t}\n\t\t\t}, TStatId(), nullptr, ENamedThreads::GameThread);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n#if WITH_EDITOR\n\nconst FText UMyWebBrowser::GetPaletteCategory()\n{\n\treturn LOCTEXT(\"My\", \"My\");\n}\n\n#endif\n\n/////////////////////////////////////////////////////\n\n#undef LOCTEXT_NAMESPACE\n\n```\n\n\n\n# 二、嵌入Web页面\n\n我们创建的MyWebBrowser继承自Widget属于UI范畴，所以Web显示操作属于UI操作。\n\n## 1.创建Web嵌入所用UI\n\n在Content Browser中右键/User Interface/Widget Buleprint，创建UI蓝图，这里我命名为WebBrowser。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170745.png)\n\n打开WebBrowser，如果上面代码都编译通过了，那么在UI的Palette中应该会有一My栏，栏中有一个My Web Browser控件，这就是我们创建的自定义WebBrowser。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170752.png)\n\n将My Web Browser拖入Hierachy中的Canvas Panel中并调整好大小。\n\n## 2.显示UI\n\n打开关卡蓝图，写入如下蓝图脚本：\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170758.png)\n\n注意，Class中填入的是我们刚创建的UI蓝图webBrowser。\n\n## 3.嵌入Web\n\n在UI蓝图webBrowser的Graph中写入如下蓝图脚本，在New URL中下入www.baidu.com用以测试。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170806.png)\n\n运行测试\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170812.png)\n\n测试通过。\n\n# 三、UE4到Web通信\n\nUE4到Web的通信，这里以UE4到ECharts的通信为例，首先到ECharts官网下载一个自己喜欢的图表源码到本地。\n\nECharts官网： https://www.echartsjs.com/zh/index.html \n\n我以折线图为例\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170819.png)\n\nECharts上手较为简单，官方有5分钟快速上手教程，有详尽的API解释，这里不多累赘。\n\n这里以使用UE4设置折线图Y轴的最大值和最小值为例。\n\n## 1.通信前的准备\n\nUE4到Web的通信需要通过SWebBrowser类的一个函数来绑定通信对象，然后通过这个对象进行数据通信。\n\n首先我们需要定义一个函数\n\n```C++\nUFUNCTION(BlueprintCallable, Category = \"Web Browser\")\nvoid UMyWebBrowser::BindUObject(const FString & Name, UObject * Object, bool bIsPermanent);\n```\n\n函数调用SWebBrowser类里的`void SWebBrowser::BindUObject(const FString & Name, UObject * Object, bool bIsPermanent);`函数实现通信中介的创建。\n\n这里要注意BindUObject函数需要暴露给蓝图调用。\n\n函数实现\n\n```C++\nvoid UMyWebBrowser::BindUObject(const FString & Name, UObject * Object, bool bIsPermanent)\n{\n\tif (WebBrowserWidget.IsValid())\n\t{\n\t\tWebBrowserWidget->BindUObject(Name, Object, bIsPermanent);\n\t}\n}\n```\n\n## 2.创建通信对象与数据传递方法\n\n然后再在WebBrowser的Graph的蓝图脚本中添加BindUObject的调用创建通信中介对象。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170828.png)\n\n其中Name中填写的就是通信中介对象的名字，名字可以自定义，这里命的名字在Web中调用时用的对象名，中介对象就是Self，即当前Widget对象。\n\nUE4到Web的通信是Web主动调用UE4的方法，通信的数据则是这个方法的返回值，Web可以获取到这个返回值，通过这个对象中的这个方法的返回值即可达到数据通信的目的。\n\n在WebBrowser的My Blueprint/Functions中添加两个用于数据传递的方法，GetMin和GetMax。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170833.png)\n\n<font color = red>这里要注意，用于数据传递的方法的返回值的名字必须是`ReturnValue`否则数据无法传递。</font>\n\n之后就可以在Web中操作通过obj这个对象操作这些函数来获取UE4里的Min和Max变量了。\n\n这里贴出Web源码：\n\n```javascript\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <!-- 引入 echarts.js -->\n\t<script src=\"C:/Users/Administrator/Desktop/ECharts/echarts.min.js\"></script>\n    <script src=\"C:/Users/Administrator/Desktop/ECharts/jquery.min.js\"></script>\n</head>\n<body style = \"background-color:#d8d8d8\">\n    <!-- 为ECharts准备一个具备大小（宽高）的Dom -->\n\t<div id=\"main\" style=\"width: 1000px;height:450px;position:1px; top:1px;\">CHART</div>\n\t<script type=\"text/javascript\">\n         \n\t\tvar myChart = echarts.init(document.getElementById(\"main\"));\n\t\tvar x = [1,2,3,4,5,6,7,8,9,10,12,13,14,15,16,17,18,19,20,20,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40];\n\t\tvar y = [];\n\t\t\n\t\tvar y_min = 0;\n\t\tvar y_max = 1;\n\t\t\n\t\tfunction Set(){\n\t\t\toption = {\n\t\t\t\ttooltip :\n\t\t\t\t{\n\t\t\t\t\ttrigger : 'axis',\n\t\t\t\t\t//十字锚点\n\t\t\t\t\taxisPointer:\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'cross',\n\t\t\t\t\t\tanimation: false,\n\t\t\t\t\t\tlabel: {backgroundColor: '#505765'},\n\t\t\t\t\t\tlineStyle : {type : 'dashed'}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\txAxis: {data: x},\n\t\t\t\tyAxis: \n\t\t\t\t{\n\t\t\t\t\tsplitLine: {show: false },\n\t\t\t\t\tmin : y_min,\n\t\t\t\t\tmax : y_max\n\t\t\t\t},\n\t\t\t\tdataZoom: [\n\t\t\t\t\t{startValue: '2014-06-01'}, \n\t\t\t\t\t{type: 'inside'}\n\t\t\t\t],\t\n\t\t\t\tseries: {\n\t\t\t\t\ttype: 'line',\n\t\t\t\t\tdata: y\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction SetYMinAndMax(){\n\t\t\tue.obj.getmin().then(function(ReturnValue){\n\t\t\t\ty_min = ReturnValue;\n\t\t\t});\n\t\t\tue.obj.getmax().then(function(ReturnValue){\n\t\t\t\ty_max = ReturnValue;\n\t\t\t});\n\t\t}\n\t\t\n\t\tfunction AddData(){\n\t\t\ty.push(Math.random());\n\t\t}\n\t\t\n\t\tSetYMinAndMax();\n\t\tsetInterval(function(){\n\t\t\tAddData();\n\t\t\tSet();\n\t\t\tmyChart.setOption(option);\n\t\t},1000);\n    </script>\t\t\n</body>\n</html>\n```\n\n其中SetYMinAndMax函数便是UE4与Web的数据通信。\n\n```javascript\nfunction SetYMinAndMax(){\n\t\t\tue.obj.getmin().then(function(ReturnValue){\n\t\t\t\ty_min = ReturnValue;\n\t\t\t});\n\t\t\tue.obj.getmax().then(function(ReturnValue){\n\t\t\t\ty_max = ReturnValue;\n\t\t\t});\n\t\t}\n```\n\n<font color = red>这里还需要注意，ue.obj.getmin()和ue.obj.getmax()必须使用小写，否则也无法通信，其次匿名函数function(ReturnValue)的参数名也必须为ReturnValue不可更改，否则数据依然无法传递。</font>\n\n然后测试一下数据传递是否正确。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170845.png)\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170850.png)\n\n可以看到Y轴的最大值由1改为了Max变量的值2。数据传递成功。\n\n上面的Web程序要运行还需要两个文件`echarts.min.js`和`jquery.min.js`，文件放在：\n\n这是B站上的视频教程：https://www.bilibili.com/video/av47212309","source":"_posts/【UE4】UE4内嵌Web及与Web通信.md","raw":"---\ntitle: 【UE4】UE4内嵌Web及与Web通信\ndate: 2021-05-14 17:28:03\ntags: UE4\ncategories: 知识记录\npassword:\nabstract:\nmessage:\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n\n\n<!--more-->\n\nUE4嵌入Web及UE4到Web的通信，我使用UE 4.22.3版本，以UE4嵌入ECharts并与ECharts通信为例。\n\n# 一、自定义WebBrowser\n\nUwebBrowser是UE4自带的用于浏览Web的插件类，为了后面进行UE4与Web的通信，所以这里我们需要自定义一个UWebBrowser类。\n\n## 1.创建自定义WebBrowser类\n\n在C++ Classes中右键创建一个自己的继承自widget类的C++类--MyWebBrowser。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170722.png)\n\n## 2.编写自定义WebBrowser\n\n然后在VS中搜索WebBrowser.cpp和WebBrowser.h这是UE4自带的WebBrowser类，虽说是写一个自定义的WebBrowser，但是我们的自定义的WebBrowser在功能上基本和UE4自带的webBrowser一致，所以我们只需将UE4自带的WebBrowser中的代码拷贝到我们自己的MyWebBrowser中稍作修改即可。\n\n当然拷贝时不是全盘拷贝，只需拷贝如下WebBrowser.h中虚线一下的部分拷贝到我们的MyWebBrowser.h中。有时可能出现FOnUrlChanged和FOnBeforePopup报错，等VS反应一下就好了，有时可以直接编译，报红也是可以编译通过的。\n\n```C++\n/*WebBrowser.h*/\n\n#pragma once\n#include \"Components/Widget.h\"\n#include \"WebBrowser.generated.h\"\n\nUCLASS()\nclass WEBBROWSERWIDGET_API UWebBrowser : public UWidget\n{\n    /*--------------------------------------------------------------------------------------*/\n\tGENERATED_UCLASS_BODY()\n\npublic:\n\tDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnUrlChanged, const FText&, Text);\n\tDECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnBeforePopup, FString, URL, FString, Frame);\n\n\t/**\n\t * Load the specified URL\n\t *\n\t * @param NewURL New URL to load\n\t */\n\tUFUNCTION(BlueprintCallable, Category=\"Web Browser\")\n\tvoid LoadURL(FString NewURL);\n\n\t/**\n\t * Load a string as data to create a web page\n\t *\n\t * @param Contents String to load\n\t * @param DummyURL Dummy URL for the page\n\t */\n\tUFUNCTION(BlueprintCallable, Category=\"Web Browser\")\n\tvoid LoadString(FString Contents, FString DummyURL);\n\n\t/**\n\t* Executes a JavaScript string in the context of the web page\n\t*\n\t* @param ScriptText JavaScript string to execute\n\t*/\n\tUFUNCTION(BlueprintCallable, Category = \"Web Browser\")\n\tvoid ExecuteJavascript(const FString& ScriptText);\n\n\t/**\n\t * Get the current title of the web page\n\t */\n\tUFUNCTION(BlueprintCallable, Category=\"Web Browser\")\n\tFText GetTitleText() const;\n\n\t/**\n\t* Gets the currently loaded URL.\n\t*\n\t* @return The URL, or empty string if no document is loaded.\n\t*/\n\tUFUNCTION(BlueprintCallable, Category = \"Web Browser\")\n\tFString GetUrl() const;\n\n\t/** Called when the Url changes. */\n\tUPROPERTY(BlueprintAssignable, Category = \"Web Browser|Event\")\n\tFOnUrlChanged OnUrlChanged;\n\n\t/** Called when a popup is about to spawn. */\n\tUPROPERTY(BlueprintAssignable, Category = \"Web Browser|Event\")\n\tFOnBeforePopup OnBeforePopup;\n\npublic:\n\n\t//~ Begin UWidget interface\n\tvirtual void SynchronizeProperties() override;\n\t// End UWidget interface\n\n\tvirtual void ReleaseSlateResources(bool bReleaseChildren) override;\n\n#if WITH_EDITOR\n\tvirtual const FText GetPaletteCategory() override;\n#endif\n\nprotected:\n\t/** URL that the browser will initially navigate to. The URL should include the protocol, eg http:// */\n\tUPROPERTY(EditAnywhere, Category=Appearance)\n\tFString InitialURL;\n\n\t/** Should the browser window support transparency. */\n\tUPROPERTY(EditAnywhere, Category=Appearance)\n\tbool bSupportsTransparency;\n\nprotected:\n\tTSharedPtr<class SWebBrowser> WebBrowserWidget;\n\nprotected:\n\t// UWidget interface\n\tvirtual TSharedRef<SWidget> RebuildWidget() override;\n\t// End of UWidget interface\n\n\tvoid HandleOnUrlChanged(const FText& Text);\n\tbool HandleOnBeforePopup(FString URL, FString Frame);\n};\n```\n\nWebBrowser.cpp则是全盘拷贝到我们的MyWebBrowser.cpp中，然后将所有的UWebBrowser修改为UMyWebBrowser，将#include \"WebBrowser.h\"改为我们自己的#include \"MyWebBrowser.h\"即可。\n\n这里需要注意，有时会因为引擎位置不同导致#include \"SWebBrowser.h\"头文件打不开，此时我们需要给SWebBrowser.h一个路径即可，如：#include \"Runtime/WebBrowser/Public/SWebBrowser.h\"。\n\n然后如下的代码中的Experimental，可以改也可以不改，这段代码主要控制我们自定义的MyWebBrowser显示在UI的Palette中的分栏位置，这里我都改为My。\n\n```C++\n#if WITH_EDITOR\n\nconst FText UWebBrowser::GetPaletteCategory()\n{\n\treturn LOCTEXT(\"Experimental\", \"Experimental\");\n}\n\n#endif\n```\n\n然后就可以编译了。\n\n## 3.完整代码\n\n这里贴出完整代码，供参考。\n\n```C++\n/*MyWebBrowser.h*/\n\n// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/Widget.h\"\n#include \"MyWebBrowser.generated.h\"\n\nUCLASS()\nclass WEBTEST_API UMyWebBrowser : public UWidget\n{\n\tGENERATED_UCLASS_BODY()\n\npublic:\n\tDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnUrlChanged, const FText&, Text);\n\tDECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnBeforePopup, FString, URL, FString, Frame);\n\n\t/**\n\t * Load the specified URL\n\t *\n\t * @param NewURL New URL to load\n\t */\n\tUFUNCTION(BlueprintCallable, Category = \"Web Browser\")\n\t\tvoid LoadURL(FString NewURL);\n\n\t/**\n\t * Load a string as data to create a web page\n\t *\n\t * @param Contents String to load\n\t * @param DummyURL Dummy URL for the page\n\t */\n\tUFUNCTION(BlueprintCallable, Category = \"Web Browser\")\n\t\tvoid LoadString(FString Contents, FString DummyURL);\n\n\t/**\n\t* Executes a JavaScript string in the context of the web page\n\t*\n\t* @param ScriptText JavaScript string to execute\n\t*/\n\tUFUNCTION(BlueprintCallable, Category = \"Web Browser\")\n\t\tvoid ExecuteJavascript(const FString& ScriptText);\n\n\t/**\n\t * Get the current title of the web page\n\t */\n\tUFUNCTION(BlueprintCallable, Category = \"Web Browser\")\n\t\tFText GetTitleText() const;\n\n\t/**\n\t* Gets the currently loaded URL.\n\t*\n\t* @return The URL, or empty string if no document is loaded.\n\t*/\n\tUFUNCTION(BlueprintCallable, Category = \"Web Browser\")\n\t\tFString GetUrl() const;\n\n\t/** Called when the Url changes. */\n\tUPROPERTY(BlueprintAssignable, Category = \"Web Browser|Event\")\n\tFOnUrlChanged OnUrlChanged;\n\n\t/** Called when a popup is about to spawn. */\n\tUPROPERTY(BlueprintAssignable, Category = \"Web Browser|Event\")\n\tFOnBeforePopup OnBeforePopup;\n\npublic:\n\n\t//~ Begin UWidget interface\n\tvirtual void SynchronizeProperties() override;\n\t// End UWidget interface\n\n\tvirtual void ReleaseSlateResources(bool bReleaseChildren) override;\n\n#if WITH_EDITOR\n\tvirtual const FText GetPaletteCategory() override;\n#endif\n\nprotected:\n\t/** URL that the browser will initially navigate to. The URL should include the protocol, eg http:// */\n\tUPROPERTY(EditAnywhere, Category = Appearance)\n\t\tFString InitialURL;\n\n\t/** Should the browser window support transparency. */\n\tUPROPERTY(EditAnywhere, Category = Appearance)\n\t\tbool bSupportsTransparency;\n\nprotected:\n\tTSharedPtr<class SWebBrowser> WebBrowserWidget;\n\nprotected:\n\t// UWidget interface\n\tvirtual TSharedRef<SWidget> RebuildWidget() override;\n\t// End of UWidget interface\n\n\tvoid HandleOnUrlChanged(const FText& Text);\n\tbool HandleOnBeforePopup(FString URL, FString Frame);\n};\n\n```\n\n```C++\n/*MyWebBrowser.cpp*/\n\n// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"MyWebBrowser.h\"\n#include \"Runtime/WebBrowser/Public/SWebBrowser.h\"\n#include \"Widgets/Layout/SBox.h\"\n#include \"Widgets/Text/STextBlock.h\"\n#include \"Async/TaskGraphInterfaces.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n#if WITH_EDITOR\n#include \"Materials/MaterialInterface.h\"\n#include \"Materials/MaterialExpressionMaterialFunctionCall.h\"\n#include \"Materials/MaterialExpressionTextureSample.h\"\n#include \"Materials/MaterialExpressionTextureSampleParameter2D.h\"\n#include \"Materials/MaterialFunction.h\"\n#include \"Factories/MaterialFactoryNew.h\"\n#include \"AssetRegistryModule.h\"\n#include \"PackageHelperFunctions.h\"\n#endif\n\n#define LOCTEXT_NAMESPACE \"WebBrowser\"\n\n/////////////////////////////////////////////////////\n// UWebBrowser\n\nUMyWebBrowser::UMyWebBrowser(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer)\n{\n\tbIsVariable = true;\n}\n\nvoid UMyWebBrowser::LoadURL(FString NewURL)\n{\n\tif (WebBrowserWidget.IsValid())\n\t{\n\t\treturn WebBrowserWidget->LoadURL(NewURL);\n\t}\n}\n\nvoid UMyWebBrowser::LoadString(FString Contents, FString DummyURL)\n{\n\tif (WebBrowserWidget.IsValid())\n\t{\n\t\treturn WebBrowserWidget->LoadString(Contents, DummyURL);\n\t}\n}\n\nvoid UMyWebBrowser::ExecuteJavascript(const FString& ScriptText)\n{\n\tif (WebBrowserWidget.IsValid())\n\t{\n\t\treturn WebBrowserWidget->ExecuteJavascript(ScriptText);\n\t}\n}\n\nFText UMyWebBrowser::GetTitleText() const\n{\n\tif (WebBrowserWidget.IsValid())\n\t{\n\t\treturn WebBrowserWidget->GetTitleText();\n\t}\n\n\treturn FText::GetEmpty();\n}\n\nFString UMyWebBrowser::GetUrl() const\n{\n\tif (WebBrowserWidget.IsValid())\n\t{\n\t\treturn WebBrowserWidget->GetUrl();\n\t}\n\n\treturn FString();\n}\n\nvoid UMyWebBrowser::ReleaseSlateResources(bool bReleaseChildren)\n{\n\tSuper::ReleaseSlateResources(bReleaseChildren);\n\n\tWebBrowserWidget.Reset();\n}\n\nTSharedRef<SWidget> UMyWebBrowser::RebuildWidget()\n{\n\tif (IsDesignTime())\n\t{\n\t\treturn SNew(SBox)\n\t\t\t.HAlign(HAlign_Center)\n\t\t\t.VAlign(VAlign_Center)\n\t\t\t[\n\t\t\t\tSNew(STextBlock)\n\t\t\t\t.Text(LOCTEXT(\"Web Browser\", \"Web Browser\"))\n\t\t\t];\n\t}\n\telse\n\t{\n\t\tWebBrowserWidget = SNew(SWebBrowser)\n\t\t\t.InitialURL(InitialURL)\n\t\t\t.ShowControls(false)\n\t\t\t.SupportsTransparency(bSupportsTransparency)\n\t\t\t.OnUrlChanged(BIND_UOBJECT_DELEGATE(FOnTextChanged, HandleOnUrlChanged))\n\t\t\t.OnBeforePopup(BIND_UOBJECT_DELEGATE(FOnBeforePopupDelegate, HandleOnBeforePopup));\n\n\t\treturn WebBrowserWidget.ToSharedRef();\n\t}\n}\n\nvoid UMyWebBrowser::SynchronizeProperties()\n{\n\tSuper::SynchronizeProperties();\n\n\tif (WebBrowserWidget.IsValid())\n\t{\n\n\t}\n}\n\nvoid UMyWebBrowser::HandleOnUrlChanged(const FText& InText)\n{\n\tOnUrlChanged.Broadcast(InText);\n}\n\nbool UMyWebBrowser::HandleOnBeforePopup(FString URL, FString Frame)\n{\n\tif (OnBeforePopup.IsBound())\n\t{\n\t\tif (IsInGameThread())\n\t\t{\n\t\t\tOnBeforePopup.Broadcast(URL, Frame);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Retry on the GameThread.\n\t\t\tTWeakObjectPtr<UMyWebBrowser> WeakThis = this;\n\t\t\tFFunctionGraphTask::CreateAndDispatchWhenReady([WeakThis, URL, Frame]()\n\t\t\t{\n\t\t\t\tif (WeakThis.IsValid())\n\t\t\t\t{\n\t\t\t\t\tWeakThis->HandleOnBeforePopup(URL, Frame);\n\t\t\t\t}\n\t\t\t}, TStatId(), nullptr, ENamedThreads::GameThread);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n#if WITH_EDITOR\n\nconst FText UMyWebBrowser::GetPaletteCategory()\n{\n\treturn LOCTEXT(\"My\", \"My\");\n}\n\n#endif\n\n/////////////////////////////////////////////////////\n\n#undef LOCTEXT_NAMESPACE\n\n```\n\n\n\n# 二、嵌入Web页面\n\n我们创建的MyWebBrowser继承自Widget属于UI范畴，所以Web显示操作属于UI操作。\n\n## 1.创建Web嵌入所用UI\n\n在Content Browser中右键/User Interface/Widget Buleprint，创建UI蓝图，这里我命名为WebBrowser。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170745.png)\n\n打开WebBrowser，如果上面代码都编译通过了，那么在UI的Palette中应该会有一My栏，栏中有一个My Web Browser控件，这就是我们创建的自定义WebBrowser。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170752.png)\n\n将My Web Browser拖入Hierachy中的Canvas Panel中并调整好大小。\n\n## 2.显示UI\n\n打开关卡蓝图，写入如下蓝图脚本：\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170758.png)\n\n注意，Class中填入的是我们刚创建的UI蓝图webBrowser。\n\n## 3.嵌入Web\n\n在UI蓝图webBrowser的Graph中写入如下蓝图脚本，在New URL中下入www.baidu.com用以测试。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170806.png)\n\n运行测试\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170812.png)\n\n测试通过。\n\n# 三、UE4到Web通信\n\nUE4到Web的通信，这里以UE4到ECharts的通信为例，首先到ECharts官网下载一个自己喜欢的图表源码到本地。\n\nECharts官网： https://www.echartsjs.com/zh/index.html \n\n我以折线图为例\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170819.png)\n\nECharts上手较为简单，官方有5分钟快速上手教程，有详尽的API解释，这里不多累赘。\n\n这里以使用UE4设置折线图Y轴的最大值和最小值为例。\n\n## 1.通信前的准备\n\nUE4到Web的通信需要通过SWebBrowser类的一个函数来绑定通信对象，然后通过这个对象进行数据通信。\n\n首先我们需要定义一个函数\n\n```C++\nUFUNCTION(BlueprintCallable, Category = \"Web Browser\")\nvoid UMyWebBrowser::BindUObject(const FString & Name, UObject * Object, bool bIsPermanent);\n```\n\n函数调用SWebBrowser类里的`void SWebBrowser::BindUObject(const FString & Name, UObject * Object, bool bIsPermanent);`函数实现通信中介的创建。\n\n这里要注意BindUObject函数需要暴露给蓝图调用。\n\n函数实现\n\n```C++\nvoid UMyWebBrowser::BindUObject(const FString & Name, UObject * Object, bool bIsPermanent)\n{\n\tif (WebBrowserWidget.IsValid())\n\t{\n\t\tWebBrowserWidget->BindUObject(Name, Object, bIsPermanent);\n\t}\n}\n```\n\n## 2.创建通信对象与数据传递方法\n\n然后再在WebBrowser的Graph的蓝图脚本中添加BindUObject的调用创建通信中介对象。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170828.png)\n\n其中Name中填写的就是通信中介对象的名字，名字可以自定义，这里命的名字在Web中调用时用的对象名，中介对象就是Self，即当前Widget对象。\n\nUE4到Web的通信是Web主动调用UE4的方法，通信的数据则是这个方法的返回值，Web可以获取到这个返回值，通过这个对象中的这个方法的返回值即可达到数据通信的目的。\n\n在WebBrowser的My Blueprint/Functions中添加两个用于数据传递的方法，GetMin和GetMax。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170833.png)\n\n<font color = red>这里要注意，用于数据传递的方法的返回值的名字必须是`ReturnValue`否则数据无法传递。</font>\n\n之后就可以在Web中操作通过obj这个对象操作这些函数来获取UE4里的Min和Max变量了。\n\n这里贴出Web源码：\n\n```javascript\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <!-- 引入 echarts.js -->\n\t<script src=\"C:/Users/Administrator/Desktop/ECharts/echarts.min.js\"></script>\n    <script src=\"C:/Users/Administrator/Desktop/ECharts/jquery.min.js\"></script>\n</head>\n<body style = \"background-color:#d8d8d8\">\n    <!-- 为ECharts准备一个具备大小（宽高）的Dom -->\n\t<div id=\"main\" style=\"width: 1000px;height:450px;position:1px; top:1px;\">CHART</div>\n\t<script type=\"text/javascript\">\n         \n\t\tvar myChart = echarts.init(document.getElementById(\"main\"));\n\t\tvar x = [1,2,3,4,5,6,7,8,9,10,12,13,14,15,16,17,18,19,20,20,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40];\n\t\tvar y = [];\n\t\t\n\t\tvar y_min = 0;\n\t\tvar y_max = 1;\n\t\t\n\t\tfunction Set(){\n\t\t\toption = {\n\t\t\t\ttooltip :\n\t\t\t\t{\n\t\t\t\t\ttrigger : 'axis',\n\t\t\t\t\t//十字锚点\n\t\t\t\t\taxisPointer:\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'cross',\n\t\t\t\t\t\tanimation: false,\n\t\t\t\t\t\tlabel: {backgroundColor: '#505765'},\n\t\t\t\t\t\tlineStyle : {type : 'dashed'}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\txAxis: {data: x},\n\t\t\t\tyAxis: \n\t\t\t\t{\n\t\t\t\t\tsplitLine: {show: false },\n\t\t\t\t\tmin : y_min,\n\t\t\t\t\tmax : y_max\n\t\t\t\t},\n\t\t\t\tdataZoom: [\n\t\t\t\t\t{startValue: '2014-06-01'}, \n\t\t\t\t\t{type: 'inside'}\n\t\t\t\t],\t\n\t\t\t\tseries: {\n\t\t\t\t\ttype: 'line',\n\t\t\t\t\tdata: y\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction SetYMinAndMax(){\n\t\t\tue.obj.getmin().then(function(ReturnValue){\n\t\t\t\ty_min = ReturnValue;\n\t\t\t});\n\t\t\tue.obj.getmax().then(function(ReturnValue){\n\t\t\t\ty_max = ReturnValue;\n\t\t\t});\n\t\t}\n\t\t\n\t\tfunction AddData(){\n\t\t\ty.push(Math.random());\n\t\t}\n\t\t\n\t\tSetYMinAndMax();\n\t\tsetInterval(function(){\n\t\t\tAddData();\n\t\t\tSet();\n\t\t\tmyChart.setOption(option);\n\t\t},1000);\n    </script>\t\t\n</body>\n</html>\n```\n\n其中SetYMinAndMax函数便是UE4与Web的数据通信。\n\n```javascript\nfunction SetYMinAndMax(){\n\t\t\tue.obj.getmin().then(function(ReturnValue){\n\t\t\t\ty_min = ReturnValue;\n\t\t\t});\n\t\t\tue.obj.getmax().then(function(ReturnValue){\n\t\t\t\ty_max = ReturnValue;\n\t\t\t});\n\t\t}\n```\n\n<font color = red>这里还需要注意，ue.obj.getmin()和ue.obj.getmax()必须使用小写，否则也无法通信，其次匿名函数function(ReturnValue)的参数名也必须为ReturnValue不可更改，否则数据依然无法传递。</font>\n\n然后测试一下数据传递是否正确。\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170845.png)\n\n![](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170850.png)\n\n可以看到Y轴的最大值由1改为了Max变量的值2。数据传递成功。\n\n上面的Web程序要运行还需要两个文件`echarts.min.js`和`jquery.min.js`，文件放在：\n\n这是B站上的视频教程：https://www.bilibili.com/video/av47212309","slug":"【UE4】UE4内嵌Web及与Web通信","published":1,"updated":"2021-05-14T10:15:40.522Z","_id":"ckoo4kci20004wkr7cr5hc3ey","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n\n\n<a id=\"more\"></a>\n\n<p>UE4嵌入Web及UE4到Web的通信，我使用UE 4.22.3版本，以UE4嵌入ECharts并与ECharts通信为例。</p>\n<h1 id=\"一、自定义WebBrowser\"><a href=\"#一、自定义WebBrowser\" class=\"headerlink\" title=\"一、自定义WebBrowser\"></a>一、自定义WebBrowser</h1><p>UwebBrowser是UE4自带的用于浏览Web的插件类，为了后面进行UE4与Web的通信，所以这里我们需要自定义一个UWebBrowser类。</p>\n<h2 id=\"1-创建自定义WebBrowser类\"><a href=\"#1-创建自定义WebBrowser类\" class=\"headerlink\" title=\"1.创建自定义WebBrowser类\"></a>1.创建自定义WebBrowser类</h2><p>在C++ Classes中右键创建一个自己的继承自widget类的C++类–MyWebBrowser。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170722.png\"></p>\n<h2 id=\"2-编写自定义WebBrowser\"><a href=\"#2-编写自定义WebBrowser\" class=\"headerlink\" title=\"2.编写自定义WebBrowser\"></a>2.编写自定义WebBrowser</h2><p>然后在VS中搜索WebBrowser.cpp和WebBrowser.h这是UE4自带的WebBrowser类，虽说是写一个自定义的WebBrowser，但是我们的自定义的WebBrowser在功能上基本和UE4自带的webBrowser一致，所以我们只需将UE4自带的WebBrowser中的代码拷贝到我们自己的MyWebBrowser中稍作修改即可。</p>\n<p>当然拷贝时不是全盘拷贝，只需拷贝如下WebBrowser.h中虚线一下的部分拷贝到我们的MyWebBrowser.h中。有时可能出现FOnUrlChanged和FOnBeforePopup报错，等VS反应一下就好了，有时可以直接编译，报红也是可以编译通过的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">/*WebBrowser.h*/</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> once</span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;Components/Widget.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;WebBrowser.generated.h&quot;</span></span><br><br>UCLASS()<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">WEBBROWSERWIDGET_API</span> <span class=\"hljs-title\">UWebBrowser</span> :</span> <span class=\"hljs-keyword\">public</span> UWidget<br>&#123;<br>    <span class=\"hljs-comment\">/*--------------------------------------------------------------------------------------*/</span><br>\tGENERATED_UCLASS_BODY()<br><br><span class=\"hljs-keyword\">public</span>:<br>\tDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnUrlChanged, <span class=\"hljs-keyword\">const</span> FText&amp;, Text);<br>\tDECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnBeforePopup, FString, URL, FString, Frame);<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * Load the specified URL</span><br><span class=\"hljs-comment\">\t *</span><br><span class=\"hljs-comment\">\t * @param NewURL New URL to load</span><br><span class=\"hljs-comment\">\t */</span><br>\tUFUNCTION(BlueprintCallable, Category=<span class=\"hljs-string\">&quot;Web Browser&quot;</span>)<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">LoadURL</span><span class=\"hljs-params\">(FString NewURL)</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * Load a string as data to create a web page</span><br><span class=\"hljs-comment\">\t *</span><br><span class=\"hljs-comment\">\t * @param Contents String to load</span><br><span class=\"hljs-comment\">\t * @param DummyURL Dummy URL for the page</span><br><span class=\"hljs-comment\">\t */</span><br>\tUFUNCTION(BlueprintCallable, Category=<span class=\"hljs-string\">&quot;Web Browser&quot;</span>)<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">LoadString</span><span class=\"hljs-params\">(FString Contents, FString DummyURL)</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t* Executes a JavaScript string in the context of the web page</span><br><span class=\"hljs-comment\">\t*</span><br><span class=\"hljs-comment\">\t* @param ScriptText JavaScript string to execute</span><br><span class=\"hljs-comment\">\t*/</span><br>\tUFUNCTION(BlueprintCallable, Category = <span class=\"hljs-string\">&quot;Web Browser&quot;</span>)<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ExecuteJavascript</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> FString&amp; ScriptText)</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * Get the current title of the web page</span><br><span class=\"hljs-comment\">\t */</span><br>\tUFUNCTION(BlueprintCallable, Category=<span class=\"hljs-string\">&quot;Web Browser&quot;</span>)<br>\t<span class=\"hljs-function\">FText <span class=\"hljs-title\">GetTitleText</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">const</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t* Gets the currently loaded URL.</span><br><span class=\"hljs-comment\">\t*</span><br><span class=\"hljs-comment\">\t* @return The URL, or empty string if no document is loaded.</span><br><span class=\"hljs-comment\">\t*/</span><br>\tUFUNCTION(BlueprintCallable, Category = <span class=\"hljs-string\">&quot;Web Browser&quot;</span>)<br>\t<span class=\"hljs-function\">FString <span class=\"hljs-title\">GetUrl</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">const</span></span>;<br><br>\t<span class=\"hljs-comment\">/** Called when the Url changes. */</span><br>\tUPROPERTY(BlueprintAssignable, Category = <span class=\"hljs-string\">&quot;Web Browser|Event&quot;</span>)<br>\tFOnUrlChanged OnUrlChanged;<br><br>\t<span class=\"hljs-comment\">/** Called when a popup is about to spawn. */</span><br>\tUPROPERTY(BlueprintAssignable, Category = <span class=\"hljs-string\">&quot;Web Browser|Event&quot;</span>)<br>\tFOnBeforePopup OnBeforePopup;<br><br><span class=\"hljs-keyword\">public</span>:<br><br>\t<span class=\"hljs-comment\">//~ Begin UWidget interface</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">SynchronizeProperties</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">override</span></span>;<br>\t<span class=\"hljs-comment\">// End UWidget interface</span><br><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ReleaseSlateResources</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">bool</span> bReleaseChildren)</span> <span class=\"hljs-keyword\">override</span></span>;<br><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">if</span> WITH_EDITOR</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">const</span> FText <span class=\"hljs-title\">GetPaletteCategory</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">override</span></span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">endif</span></span><br><br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-comment\">/** URL that the browser will initially navigate to. The URL should include the protocol, eg http:// */</span><br>\tUPROPERTY(EditAnywhere, Category=Appearance)<br>\tFString InitialURL;<br><br>\t<span class=\"hljs-comment\">/** Should the browser window support transparency. */</span><br>\tUPROPERTY(EditAnywhere, Category=Appearance)<br>\t<span class=\"hljs-keyword\">bool</span> bSupportsTransparency;<br><br><span class=\"hljs-keyword\">protected</span>:<br>\tTSharedPtr&lt;<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SWebBrowser</span>&gt;</span> WebBrowserWidget;<br><br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-comment\">// UWidget interface</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> TSharedRef&lt;SWidget&gt; <span class=\"hljs-title\">RebuildWidget</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">override</span></span>;<br>\t<span class=\"hljs-comment\">// End of UWidget interface</span><br><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">HandleOnUrlChanged</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> FText&amp; Text)</span></span>;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">HandleOnBeforePopup</span><span class=\"hljs-params\">(FString URL, FString Frame)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>WebBrowser.cpp则是全盘拷贝到我们的MyWebBrowser.cpp中，然后将所有的UWebBrowser修改为UMyWebBrowser，将#include “WebBrowser.h”改为我们自己的#include “MyWebBrowser.h”即可。</p>\n<p>这里需要注意，有时会因为引擎位置不同导致#include “SWebBrowser.h”头文件打不开，此时我们需要给SWebBrowser.h一个路径即可，如：#include “Runtime/WebBrowser/Public/SWebBrowser.h”。</p>\n<p>然后如下的代码中的Experimental，可以改也可以不改，这段代码主要控制我们自定义的MyWebBrowser显示在UI的Palette中的分栏位置，这里我都改为My。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">if</span> WITH_EDITOR</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">const</span> FText <span class=\"hljs-title\">UWebBrowser::GetPaletteCategory</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> LOCTEXT(<span class=\"hljs-string\">&quot;Experimental&quot;</span>, <span class=\"hljs-string\">&quot;Experimental&quot;</span>);<br>&#125;<br><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">endif</span></span><br></code></pre></td></tr></table></figure>\n<p>然后就可以编译了。</p>\n<h2 id=\"3-完整代码\"><a href=\"#3-完整代码\" class=\"headerlink\" title=\"3.完整代码\"></a>3.完整代码</h2><p>这里贴出完整代码，供参考。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">/*MyWebBrowser.h*/</span><br><br><span class=\"hljs-comment\">// Fill out your copyright notice in the Description page of Project Settings.</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> once</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;CoreMinimal.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;Components/Widget.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;MyWebBrowser.generated.h&quot;</span></span><br><br>UCLASS()<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">WEBTEST_API</span> <span class=\"hljs-title\">UMyWebBrowser</span> :</span> <span class=\"hljs-keyword\">public</span> UWidget<br>&#123;<br>\tGENERATED_UCLASS_BODY()<br><br><span class=\"hljs-keyword\">public</span>:<br>\tDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnUrlChanged, <span class=\"hljs-keyword\">const</span> FText&amp;, Text);<br>\tDECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnBeforePopup, FString, URL, FString, Frame);<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * Load the specified URL</span><br><span class=\"hljs-comment\">\t *</span><br><span class=\"hljs-comment\">\t * @param NewURL New URL to load</span><br><span class=\"hljs-comment\">\t */</span><br>\tUFUNCTION(BlueprintCallable, Category = <span class=\"hljs-string\">&quot;Web Browser&quot;</span>)<br>\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">LoadURL</span><span class=\"hljs-params\">(FString NewURL)</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * Load a string as data to create a web page</span><br><span class=\"hljs-comment\">\t *</span><br><span class=\"hljs-comment\">\t * @param Contents String to load</span><br><span class=\"hljs-comment\">\t * @param DummyURL Dummy URL for the page</span><br><span class=\"hljs-comment\">\t */</span><br>\tUFUNCTION(BlueprintCallable, Category = <span class=\"hljs-string\">&quot;Web Browser&quot;</span>)<br>\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">LoadString</span><span class=\"hljs-params\">(FString Contents, FString DummyURL)</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t* Executes a JavaScript string in the context of the web page</span><br><span class=\"hljs-comment\">\t*</span><br><span class=\"hljs-comment\">\t* @param ScriptText JavaScript string to execute</span><br><span class=\"hljs-comment\">\t*/</span><br>\tUFUNCTION(BlueprintCallable, Category = <span class=\"hljs-string\">&quot;Web Browser&quot;</span>)<br>\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ExecuteJavascript</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> FString&amp; ScriptText)</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * Get the current title of the web page</span><br><span class=\"hljs-comment\">\t */</span><br>\tUFUNCTION(BlueprintCallable, Category = <span class=\"hljs-string\">&quot;Web Browser&quot;</span>)<br>\t\t<span class=\"hljs-function\">FText <span class=\"hljs-title\">GetTitleText</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">const</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t* Gets the currently loaded URL.</span><br><span class=\"hljs-comment\">\t*</span><br><span class=\"hljs-comment\">\t* @return The URL, or empty string if no document is loaded.</span><br><span class=\"hljs-comment\">\t*/</span><br>\tUFUNCTION(BlueprintCallable, Category = <span class=\"hljs-string\">&quot;Web Browser&quot;</span>)<br>\t\t<span class=\"hljs-function\">FString <span class=\"hljs-title\">GetUrl</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">const</span></span>;<br><br>\t<span class=\"hljs-comment\">/** Called when the Url changes. */</span><br>\tUPROPERTY(BlueprintAssignable, Category = <span class=\"hljs-string\">&quot;Web Browser|Event&quot;</span>)<br>\tFOnUrlChanged OnUrlChanged;<br><br>\t<span class=\"hljs-comment\">/** Called when a popup is about to spawn. */</span><br>\tUPROPERTY(BlueprintAssignable, Category = <span class=\"hljs-string\">&quot;Web Browser|Event&quot;</span>)<br>\tFOnBeforePopup OnBeforePopup;<br><br><span class=\"hljs-keyword\">public</span>:<br><br>\t<span class=\"hljs-comment\">//~ Begin UWidget interface</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">SynchronizeProperties</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">override</span></span>;<br>\t<span class=\"hljs-comment\">// End UWidget interface</span><br><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ReleaseSlateResources</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">bool</span> bReleaseChildren)</span> <span class=\"hljs-keyword\">override</span></span>;<br><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">if</span> WITH_EDITOR</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">const</span> FText <span class=\"hljs-title\">GetPaletteCategory</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">override</span></span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">endif</span></span><br><br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-comment\">/** URL that the browser will initially navigate to. The URL should include the protocol, eg http:// */</span><br>\tUPROPERTY(EditAnywhere, Category = Appearance)<br>\t\tFString InitialURL;<br><br>\t<span class=\"hljs-comment\">/** Should the browser window support transparency. */</span><br>\tUPROPERTY(EditAnywhere, Category = Appearance)<br>\t\t<span class=\"hljs-keyword\">bool</span> bSupportsTransparency;<br><br><span class=\"hljs-keyword\">protected</span>:<br>\tTSharedPtr&lt;<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SWebBrowser</span>&gt;</span> WebBrowserWidget;<br><br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-comment\">// UWidget interface</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> TSharedRef&lt;SWidget&gt; <span class=\"hljs-title\">RebuildWidget</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">override</span></span>;<br>\t<span class=\"hljs-comment\">// End of UWidget interface</span><br><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">HandleOnUrlChanged</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> FText&amp; Text)</span></span>;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">HandleOnBeforePopup</span><span class=\"hljs-params\">(FString URL, FString Frame)</span></span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">/*MyWebBrowser.cpp*/</span><br><br><span class=\"hljs-comment\">// Fill out your copyright notice in the Description page of Project Settings.</span><br><br><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;MyWebBrowser.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;Runtime/WebBrowser/Public/SWebBrowser.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;Widgets/Layout/SBox.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;Widgets/Text/STextBlock.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;Async/TaskGraphInterfaces.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;UObject/ConstructorHelpers.h&quot;</span></span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">if</span> WITH_EDITOR</span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;Materials/MaterialInterface.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;Materials/MaterialExpressionMaterialFunctionCall.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;Materials/MaterialExpressionTextureSample.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;Materials/MaterialExpressionTextureSampleParameter2D.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;Materials/MaterialFunction.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;Factories/MaterialFactoryNew.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;AssetRegistryModule.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;PackageHelperFunctions.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">endif</span></span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> LOCTEXT_NAMESPACE <span class=\"hljs-meta-string\">&quot;WebBrowser&quot;</span></span><br><br><span class=\"hljs-comment\">/////////////////////////////////////////////////////</span><br><span class=\"hljs-comment\">// UWebBrowser</span><br><br>UMyWebBrowser::UMyWebBrowser(<span class=\"hljs-keyword\">const</span> FObjectInitializer&amp; ObjectInitializer)<br>\t: Super(ObjectInitializer)<br>&#123;<br>\tbIsVariable = <span class=\"hljs-literal\">true</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">UMyWebBrowser::LoadURL</span><span class=\"hljs-params\">(FString NewURL)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">if</span> (WebBrowserWidget.IsValid())<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> WebBrowserWidget-&gt;LoadURL(NewURL);<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">UMyWebBrowser::LoadString</span><span class=\"hljs-params\">(FString Contents, FString DummyURL)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">if</span> (WebBrowserWidget.IsValid())<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> WebBrowserWidget-&gt;LoadString(Contents, DummyURL);<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">UMyWebBrowser::ExecuteJavascript</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> FString&amp; ScriptText)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">if</span> (WebBrowserWidget.IsValid())<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> WebBrowserWidget-&gt;ExecuteJavascript(ScriptText);<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\">FText <span class=\"hljs-title\">UMyWebBrowser::GetTitleText</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">const</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">if</span> (WebBrowserWidget.IsValid())<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> WebBrowserWidget-&gt;GetTitleText();<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> FText::GetEmpty();<br>&#125;<br><br><span class=\"hljs-function\">FString <span class=\"hljs-title\">UMyWebBrowser::GetUrl</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">const</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">if</span> (WebBrowserWidget.IsValid())<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> WebBrowserWidget-&gt;GetUrl();<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> FString();<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">UMyWebBrowser::ReleaseSlateResources</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">bool</span> bReleaseChildren)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tSuper::ReleaseSlateResources(bReleaseChildren);<br><br>\tWebBrowserWidget.Reset();<br>&#125;<br><br><span class=\"hljs-function\">TSharedRef&lt;SWidget&gt; <span class=\"hljs-title\">UMyWebBrowser::RebuildWidget</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">if</span> (IsDesignTime())<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> SNew(SBox)<br>\t\t\t.HAlign(HAlign_Center)<br>\t\t\t.VAlign(VAlign_Center)<br>\t\t\t[<br>\t\t\t\tSNew(STextBlock)<br>\t\t\t\t.Text(LOCTEXT(<span class=\"hljs-string\">&quot;Web Browser&quot;</span>, <span class=\"hljs-string\">&quot;Web Browser&quot;</span>))<br>\t\t\t];<br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span><br>\t&#123;<br>\t\tWebBrowserWidget = SNew(SWebBrowser)<br>\t\t\t.InitialURL(InitialURL)<br>\t\t\t.ShowControls(<span class=\"hljs-literal\">false</span>)<br>\t\t\t.SupportsTransparency(bSupportsTransparency)<br>\t\t\t.OnUrlChanged(BIND_UOBJECT_DELEGATE(FOnTextChanged, HandleOnUrlChanged))<br>\t\t\t.OnBeforePopup(BIND_UOBJECT_DELEGATE(FOnBeforePopupDelegate, HandleOnBeforePopup));<br><br>\t\t<span class=\"hljs-keyword\">return</span> WebBrowserWidget.ToSharedRef();<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">UMyWebBrowser::SynchronizeProperties</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tSuper::SynchronizeProperties();<br><br>\t<span class=\"hljs-keyword\">if</span> (WebBrowserWidget.IsValid())<br>\t&#123;<br><br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">UMyWebBrowser::HandleOnUrlChanged</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> FText&amp; InText)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tOnUrlChanged.Broadcast(InText);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">UMyWebBrowser::HandleOnBeforePopup</span><span class=\"hljs-params\">(FString URL, FString Frame)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">if</span> (OnBeforePopup.IsBound())<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (IsInGameThread())<br>\t\t&#123;<br>\t\t\tOnBeforePopup.Broadcast(URL, Frame);<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span><br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// Retry on the GameThread.</span><br>\t\t\tTWeakObjectPtr&lt;UMyWebBrowser&gt; WeakThis = <span class=\"hljs-keyword\">this</span>;<br>\t\t\tFFunctionGraphTask::CreateAndDispatchWhenReady([WeakThis, URL, Frame]()<br>\t\t\t&#123;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span> (WeakThis.IsValid())<br>\t\t\t\t&#123;<br>\t\t\t\t\tWeakThis-&gt;HandleOnBeforePopup(URL, Frame);<br>\t\t\t\t&#125;<br>\t\t\t&#125;, TStatId(), <span class=\"hljs-literal\">nullptr</span>, ENamedThreads::GameThread);<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>&#125;<br><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">if</span> WITH_EDITOR</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">const</span> FText <span class=\"hljs-title\">UMyWebBrowser::GetPaletteCategory</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> LOCTEXT(<span class=\"hljs-string\">&quot;My&quot;</span>, <span class=\"hljs-string\">&quot;My&quot;</span>);<br>&#125;<br><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">endif</span></span><br><br><span class=\"hljs-comment\">/////////////////////////////////////////////////////</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">undef</span> LOCTEXT_NAMESPACE</span><br><br></code></pre></td></tr></table></figure>\n\n\n<h1 id=\"二、嵌入Web页面\"><a href=\"#二、嵌入Web页面\" class=\"headerlink\" title=\"二、嵌入Web页面\"></a>二、嵌入Web页面</h1><p>我们创建的MyWebBrowser继承自Widget属于UI范畴，所以Web显示操作属于UI操作。</p>\n<h2 id=\"1-创建Web嵌入所用UI\"><a href=\"#1-创建Web嵌入所用UI\" class=\"headerlink\" title=\"1.创建Web嵌入所用UI\"></a>1.创建Web嵌入所用UI</h2><p>在Content Browser中右键/User Interface/Widget Buleprint，创建UI蓝图，这里我命名为WebBrowser。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170745.png\"></p>\n<p>打开WebBrowser，如果上面代码都编译通过了，那么在UI的Palette中应该会有一My栏，栏中有一个My Web Browser控件，这就是我们创建的自定义WebBrowser。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170752.png\"></p>\n<p>将My Web Browser拖入Hierachy中的Canvas Panel中并调整好大小。</p>\n<h2 id=\"2-显示UI\"><a href=\"#2-显示UI\" class=\"headerlink\" title=\"2.显示UI\"></a>2.显示UI</h2><p>打开关卡蓝图，写入如下蓝图脚本：</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170758.png\"></p>\n<p>注意，Class中填入的是我们刚创建的UI蓝图webBrowser。</p>\n<h2 id=\"3-嵌入Web\"><a href=\"#3-嵌入Web\" class=\"headerlink\" title=\"3.嵌入Web\"></a>3.嵌入Web</h2><p>在UI蓝图webBrowser的Graph中写入如下蓝图脚本，在New URL中下入<a href=\"http://www.baidu.com用以测试./\">www.baidu.com用以测试。</a></p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170806.png\"></p>\n<p>运行测试</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170812.png\"></p>\n<p>测试通过。</p>\n<h1 id=\"三、UE4到Web通信\"><a href=\"#三、UE4到Web通信\" class=\"headerlink\" title=\"三、UE4到Web通信\"></a>三、UE4到Web通信</h1><p>UE4到Web的通信，这里以UE4到ECharts的通信为例，首先到ECharts官网下载一个自己喜欢的图表源码到本地。</p>\n<p>ECharts官网： <a href=\"https://www.echartsjs.com/zh/index.html\">https://www.echartsjs.com/zh/index.html</a> </p>\n<p>我以折线图为例</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170819.png\"></p>\n<p>ECharts上手较为简单，官方有5分钟快速上手教程，有详尽的API解释，这里不多累赘。</p>\n<p>这里以使用UE4设置折线图Y轴的最大值和最小值为例。</p>\n<h2 id=\"1-通信前的准备\"><a href=\"#1-通信前的准备\" class=\"headerlink\" title=\"1.通信前的准备\"></a>1.通信前的准备</h2><p>UE4到Web的通信需要通过SWebBrowser类的一个函数来绑定通信对象，然后通过这个对象进行数据通信。</p>\n<p>首先我们需要定义一个函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">UFUNCTION(BlueprintCallable, Category = <span class=\"hljs-string\">&quot;Web Browser&quot;</span>)<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">UMyWebBrowser::BindUObject</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> FString &amp; Name, UObject * Object, <span class=\"hljs-keyword\">bool</span> bIsPermanent)</span></span>;<br></code></pre></td></tr></table></figure>\n<p>函数调用SWebBrowser类里的<code>void SWebBrowser::BindUObject(const FString &amp; Name, UObject * Object, bool bIsPermanent);</code>函数实现通信中介的创建。</p>\n<p>这里要注意BindUObject函数需要暴露给蓝图调用。</p>\n<p>函数实现</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">UMyWebBrowser::BindUObject</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> FString &amp; Name, UObject * Object, <span class=\"hljs-keyword\">bool</span> bIsPermanent)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">if</span> (WebBrowserWidget.IsValid())<br>\t&#123;<br>\t\tWebBrowserWidget-&gt;BindUObject(Name, Object, bIsPermanent);<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"2-创建通信对象与数据传递方法\"><a href=\"#2-创建通信对象与数据传递方法\" class=\"headerlink\" title=\"2.创建通信对象与数据传递方法\"></a>2.创建通信对象与数据传递方法</h2><p>然后再在WebBrowser的Graph的蓝图脚本中添加BindUObject的调用创建通信中介对象。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170828.png\"></p>\n<p>其中Name中填写的就是通信中介对象的名字，名字可以自定义，这里命的名字在Web中调用时用的对象名，中介对象就是Self，即当前Widget对象。</p>\n<p>UE4到Web的通信是Web主动调用UE4的方法，通信的数据则是这个方法的返回值，Web可以获取到这个返回值，通过这个对象中的这个方法的返回值即可达到数据通信的目的。</p>\n<p>在WebBrowser的My Blueprint/Functions中添加两个用于数据传递的方法，GetMin和GetMax。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170833.png\"></p>\n<p><font color=\"red\">这里要注意，用于数据传递的方法的返回值的名字必须是<code>ReturnValue</code>否则数据无法传递。</font></p>\n<p>之后就可以在Web中操作通过obj这个对象操作这些函数来获取UE4里的Min和Max变量了。</p>\n<p>这里贴出Web源码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;meta charset=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;<br>    &lt;!-- 引入 echarts.js --&gt;<br>\t&lt;script src=<span class=\"hljs-string\">&quot;C:/Users/Administrator/Desktop/ECharts/echarts.min.js&quot;</span>&gt;&lt;/script&gt;<br>    &lt;script src=<span class=\"hljs-string\">&quot;C:/Users/Administrator/Desktop/ECharts/jquery.min.js&quot;</span>&gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body style = <span class=\"hljs-string\">&quot;background-color:#d8d8d8&quot;</span>&gt;<br>    &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt;<br>\t&lt;div id=<span class=\"hljs-string\">&quot;main&quot;</span> style=<span class=\"hljs-string\">&quot;width: 1000px;height:450px;position:1px; top:1px;&quot;</span>&gt;CHART&lt;/div&gt;<br>\t&lt;script type=<span class=\"hljs-string\">&quot;text/javascript&quot;</span>&gt;<br>         <br>\t\t<span class=\"hljs-keyword\">var</span> myChart = echarts.init(<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;main&quot;</span>));<br>\t\t<span class=\"hljs-keyword\">var</span> x = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">9</span>,<span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">12</span>,<span class=\"hljs-number\">13</span>,<span class=\"hljs-number\">14</span>,<span class=\"hljs-number\">15</span>,<span class=\"hljs-number\">16</span>,<span class=\"hljs-number\">17</span>,<span class=\"hljs-number\">18</span>,<span class=\"hljs-number\">19</span>,<span class=\"hljs-number\">20</span>,<span class=\"hljs-number\">20</span>,<span class=\"hljs-number\">22</span>,<span class=\"hljs-number\">23</span>,<span class=\"hljs-number\">24</span>,<span class=\"hljs-number\">25</span>,<span class=\"hljs-number\">26</span>,<span class=\"hljs-number\">27</span>,<span class=\"hljs-number\">28</span>,<span class=\"hljs-number\">29</span>,<span class=\"hljs-number\">30</span>,<span class=\"hljs-number\">31</span>,<span class=\"hljs-number\">32</span>,<span class=\"hljs-number\">33</span>,<span class=\"hljs-number\">34</span>,<span class=\"hljs-number\">35</span>,<span class=\"hljs-number\">36</span>,<span class=\"hljs-number\">37</span>,<span class=\"hljs-number\">38</span>,<span class=\"hljs-number\">39</span>,<span class=\"hljs-number\">40</span>];<br>\t\t<span class=\"hljs-keyword\">var</span> y = [];<br>\t\t<br>\t\t<span class=\"hljs-keyword\">var</span> y_min = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">var</span> y_max = <span class=\"hljs-number\">1</span>;<br>\t\t<br>\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Set</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>\t\t\toption = &#123;<br>\t\t\t\ttooltip :<br>\t\t\t\t&#123;<br>\t\t\t\t\ttrigger : <span class=\"hljs-string\">&#x27;axis&#x27;</span>,<br>\t\t\t\t\t<span class=\"hljs-comment\">//十字锚点</span><br>\t\t\t\t\taxisPointer:<br>\t\t\t\t\t&#123;<br>\t\t\t\t\t\ttype: <span class=\"hljs-string\">&#x27;cross&#x27;</span>,<br>\t\t\t\t\t\tanimation: <span class=\"hljs-literal\">false</span>,<br>\t\t\t\t\t\tlabel: &#123;<span class=\"hljs-attr\">backgroundColor</span>: <span class=\"hljs-string\">&#x27;#505765&#x27;</span>&#125;,<br>\t\t\t\t\t\tlineStyle : &#123;<span class=\"hljs-attr\">type</span> : <span class=\"hljs-string\">&#x27;dashed&#x27;</span>&#125;<br>\t\t\t\t\t&#125;<br>\t\t\t\t&#125;,<br>\t\t\t\txAxis: &#123;<span class=\"hljs-attr\">data</span>: x&#125;,<br>\t\t\t\tyAxis: <br>\t\t\t\t&#123;<br>\t\t\t\t\tsplitLine: &#123;<span class=\"hljs-attr\">show</span>: <span class=\"hljs-literal\">false</span> &#125;,<br>\t\t\t\t\tmin : y_min,<br>\t\t\t\t\tmax : y_max<br>\t\t\t\t&#125;,<br>\t\t\t\tdataZoom: [<br>\t\t\t\t\t&#123;<span class=\"hljs-attr\">startValue</span>: <span class=\"hljs-string\">&#x27;2014-06-01&#x27;</span>&#125;, <br>\t\t\t\t\t&#123;<span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;inside&#x27;</span>&#125;<br>\t\t\t\t],\t<br>\t\t\t\tseries: &#123;<br>\t\t\t\t\ttype: <span class=\"hljs-string\">&#x27;line&#x27;</span>,<br>\t\t\t\t\tdata: y<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\t<br>\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SetYMinAndMax</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>\t\t\tue.obj.getmin().then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">ReturnValue</span>)</span>&#123;<br>\t\t\t\ty_min = ReturnValue;<br>\t\t\t&#125;);<br>\t\t\tue.obj.getmax().then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">ReturnValue</span>)</span>&#123;<br>\t\t\t\ty_max = ReturnValue;<br>\t\t\t&#125;);<br>\t\t&#125;<br>\t\t<br>\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">AddData</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>\t\t\ty.push(<span class=\"hljs-built_in\">Math</span>.random());<br>\t\t&#125;<br>\t\t<br>\t\tSetYMinAndMax();<br>\t\t<span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>\t\t\tAddData();<br>\t\t\t<span class=\"hljs-built_in\">Set</span>();<br>\t\t\tmyChart.setOption(option);<br>\t\t&#125;,<span class=\"hljs-number\">1000</span>);<br>    &lt;/script&gt;\t\t<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>\n<p>其中SetYMinAndMax函数便是UE4与Web的数据通信。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SetYMinAndMax</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>\t\t\tue.obj.getmin().then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">ReturnValue</span>)</span>&#123;<br>\t\t\t\ty_min = ReturnValue;<br>\t\t\t&#125;);<br>\t\t\tue.obj.getmax().then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">ReturnValue</span>)</span>&#123;<br>\t\t\t\ty_max = ReturnValue;<br>\t\t\t&#125;);<br>\t\t&#125;<br></code></pre></td></tr></table></figure>\n<p><font color=\"red\">这里还需要注意，ue.obj.getmin()和ue.obj.getmax()必须使用小写，否则也无法通信，其次匿名函数function(ReturnValue)的参数名也必须为ReturnValue不可更改，否则数据依然无法传递。</font></p>\n<p>然后测试一下数据传递是否正确。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170845.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170850.png\"></p>\n<p>可以看到Y轴的最大值由1改为了Max变量的值2。数据传递成功。</p>\n<p>上面的Web程序要运行还需要两个文件<code>echarts.min.js</code>和<code>jquery.min.js</code>，文件放在：</p>\n<p>这是B站上的视频教程：<a href=\"https://www.bilibili.com/video/av47212309\">https://www.bilibili.com/video/av47212309</a></p>\n","site":{"data":{}},"excerpt":"<meta name=\"referrer\" content=\"no-referrer\">","more":"<p>UE4嵌入Web及UE4到Web的通信，我使用UE 4.22.3版本，以UE4嵌入ECharts并与ECharts通信为例。</p>\n<h1 id=\"一、自定义WebBrowser\"><a href=\"#一、自定义WebBrowser\" class=\"headerlink\" title=\"一、自定义WebBrowser\"></a>一、自定义WebBrowser</h1><p>UwebBrowser是UE4自带的用于浏览Web的插件类，为了后面进行UE4与Web的通信，所以这里我们需要自定义一个UWebBrowser类。</p>\n<h2 id=\"1-创建自定义WebBrowser类\"><a href=\"#1-创建自定义WebBrowser类\" class=\"headerlink\" title=\"1.创建自定义WebBrowser类\"></a>1.创建自定义WebBrowser类</h2><p>在C++ Classes中右键创建一个自己的继承自widget类的C++类–MyWebBrowser。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170722.png\"></p>\n<h2 id=\"2-编写自定义WebBrowser\"><a href=\"#2-编写自定义WebBrowser\" class=\"headerlink\" title=\"2.编写自定义WebBrowser\"></a>2.编写自定义WebBrowser</h2><p>然后在VS中搜索WebBrowser.cpp和WebBrowser.h这是UE4自带的WebBrowser类，虽说是写一个自定义的WebBrowser，但是我们的自定义的WebBrowser在功能上基本和UE4自带的webBrowser一致，所以我们只需将UE4自带的WebBrowser中的代码拷贝到我们自己的MyWebBrowser中稍作修改即可。</p>\n<p>当然拷贝时不是全盘拷贝，只需拷贝如下WebBrowser.h中虚线一下的部分拷贝到我们的MyWebBrowser.h中。有时可能出现FOnUrlChanged和FOnBeforePopup报错，等VS反应一下就好了，有时可以直接编译，报红也是可以编译通过的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">/*WebBrowser.h*/</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> once</span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;Components/Widget.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;WebBrowser.generated.h&quot;</span></span><br><br>UCLASS()<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">WEBBROWSERWIDGET_API</span> <span class=\"hljs-title\">UWebBrowser</span> :</span> <span class=\"hljs-keyword\">public</span> UWidget<br>&#123;<br>    <span class=\"hljs-comment\">/*--------------------------------------------------------------------------------------*/</span><br>\tGENERATED_UCLASS_BODY()<br><br><span class=\"hljs-keyword\">public</span>:<br>\tDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnUrlChanged, <span class=\"hljs-keyword\">const</span> FText&amp;, Text);<br>\tDECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnBeforePopup, FString, URL, FString, Frame);<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * Load the specified URL</span><br><span class=\"hljs-comment\">\t *</span><br><span class=\"hljs-comment\">\t * @param NewURL New URL to load</span><br><span class=\"hljs-comment\">\t */</span><br>\tUFUNCTION(BlueprintCallable, Category=<span class=\"hljs-string\">&quot;Web Browser&quot;</span>)<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">LoadURL</span><span class=\"hljs-params\">(FString NewURL)</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * Load a string as data to create a web page</span><br><span class=\"hljs-comment\">\t *</span><br><span class=\"hljs-comment\">\t * @param Contents String to load</span><br><span class=\"hljs-comment\">\t * @param DummyURL Dummy URL for the page</span><br><span class=\"hljs-comment\">\t */</span><br>\tUFUNCTION(BlueprintCallable, Category=<span class=\"hljs-string\">&quot;Web Browser&quot;</span>)<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">LoadString</span><span class=\"hljs-params\">(FString Contents, FString DummyURL)</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t* Executes a JavaScript string in the context of the web page</span><br><span class=\"hljs-comment\">\t*</span><br><span class=\"hljs-comment\">\t* @param ScriptText JavaScript string to execute</span><br><span class=\"hljs-comment\">\t*/</span><br>\tUFUNCTION(BlueprintCallable, Category = <span class=\"hljs-string\">&quot;Web Browser&quot;</span>)<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ExecuteJavascript</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> FString&amp; ScriptText)</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * Get the current title of the web page</span><br><span class=\"hljs-comment\">\t */</span><br>\tUFUNCTION(BlueprintCallable, Category=<span class=\"hljs-string\">&quot;Web Browser&quot;</span>)<br>\t<span class=\"hljs-function\">FText <span class=\"hljs-title\">GetTitleText</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">const</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t* Gets the currently loaded URL.</span><br><span class=\"hljs-comment\">\t*</span><br><span class=\"hljs-comment\">\t* @return The URL, or empty string if no document is loaded.</span><br><span class=\"hljs-comment\">\t*/</span><br>\tUFUNCTION(BlueprintCallable, Category = <span class=\"hljs-string\">&quot;Web Browser&quot;</span>)<br>\t<span class=\"hljs-function\">FString <span class=\"hljs-title\">GetUrl</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">const</span></span>;<br><br>\t<span class=\"hljs-comment\">/** Called when the Url changes. */</span><br>\tUPROPERTY(BlueprintAssignable, Category = <span class=\"hljs-string\">&quot;Web Browser|Event&quot;</span>)<br>\tFOnUrlChanged OnUrlChanged;<br><br>\t<span class=\"hljs-comment\">/** Called when a popup is about to spawn. */</span><br>\tUPROPERTY(BlueprintAssignable, Category = <span class=\"hljs-string\">&quot;Web Browser|Event&quot;</span>)<br>\tFOnBeforePopup OnBeforePopup;<br><br><span class=\"hljs-keyword\">public</span>:<br><br>\t<span class=\"hljs-comment\">//~ Begin UWidget interface</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">SynchronizeProperties</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">override</span></span>;<br>\t<span class=\"hljs-comment\">// End UWidget interface</span><br><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ReleaseSlateResources</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">bool</span> bReleaseChildren)</span> <span class=\"hljs-keyword\">override</span></span>;<br><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">if</span> WITH_EDITOR</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">const</span> FText <span class=\"hljs-title\">GetPaletteCategory</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">override</span></span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">endif</span></span><br><br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-comment\">/** URL that the browser will initially navigate to. The URL should include the protocol, eg http:// */</span><br>\tUPROPERTY(EditAnywhere, Category=Appearance)<br>\tFString InitialURL;<br><br>\t<span class=\"hljs-comment\">/** Should the browser window support transparency. */</span><br>\tUPROPERTY(EditAnywhere, Category=Appearance)<br>\t<span class=\"hljs-keyword\">bool</span> bSupportsTransparency;<br><br><span class=\"hljs-keyword\">protected</span>:<br>\tTSharedPtr&lt;<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SWebBrowser</span>&gt;</span> WebBrowserWidget;<br><br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-comment\">// UWidget interface</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> TSharedRef&lt;SWidget&gt; <span class=\"hljs-title\">RebuildWidget</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">override</span></span>;<br>\t<span class=\"hljs-comment\">// End of UWidget interface</span><br><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">HandleOnUrlChanged</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> FText&amp; Text)</span></span>;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">HandleOnBeforePopup</span><span class=\"hljs-params\">(FString URL, FString Frame)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>WebBrowser.cpp则是全盘拷贝到我们的MyWebBrowser.cpp中，然后将所有的UWebBrowser修改为UMyWebBrowser，将#include “WebBrowser.h”改为我们自己的#include “MyWebBrowser.h”即可。</p>\n<p>这里需要注意，有时会因为引擎位置不同导致#include “SWebBrowser.h”头文件打不开，此时我们需要给SWebBrowser.h一个路径即可，如：#include “Runtime/WebBrowser/Public/SWebBrowser.h”。</p>\n<p>然后如下的代码中的Experimental，可以改也可以不改，这段代码主要控制我们自定义的MyWebBrowser显示在UI的Palette中的分栏位置，这里我都改为My。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">if</span> WITH_EDITOR</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">const</span> FText <span class=\"hljs-title\">UWebBrowser::GetPaletteCategory</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> LOCTEXT(<span class=\"hljs-string\">&quot;Experimental&quot;</span>, <span class=\"hljs-string\">&quot;Experimental&quot;</span>);<br>&#125;<br><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">endif</span></span><br></code></pre></td></tr></table></figure>\n<p>然后就可以编译了。</p>\n<h2 id=\"3-完整代码\"><a href=\"#3-完整代码\" class=\"headerlink\" title=\"3.完整代码\"></a>3.完整代码</h2><p>这里贴出完整代码，供参考。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">/*MyWebBrowser.h*/</span><br><br><span class=\"hljs-comment\">// Fill out your copyright notice in the Description page of Project Settings.</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> once</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;CoreMinimal.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;Components/Widget.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;MyWebBrowser.generated.h&quot;</span></span><br><br>UCLASS()<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">WEBTEST_API</span> <span class=\"hljs-title\">UMyWebBrowser</span> :</span> <span class=\"hljs-keyword\">public</span> UWidget<br>&#123;<br>\tGENERATED_UCLASS_BODY()<br><br><span class=\"hljs-keyword\">public</span>:<br>\tDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnUrlChanged, <span class=\"hljs-keyword\">const</span> FText&amp;, Text);<br>\tDECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnBeforePopup, FString, URL, FString, Frame);<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * Load the specified URL</span><br><span class=\"hljs-comment\">\t *</span><br><span class=\"hljs-comment\">\t * @param NewURL New URL to load</span><br><span class=\"hljs-comment\">\t */</span><br>\tUFUNCTION(BlueprintCallable, Category = <span class=\"hljs-string\">&quot;Web Browser&quot;</span>)<br>\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">LoadURL</span><span class=\"hljs-params\">(FString NewURL)</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * Load a string as data to create a web page</span><br><span class=\"hljs-comment\">\t *</span><br><span class=\"hljs-comment\">\t * @param Contents String to load</span><br><span class=\"hljs-comment\">\t * @param DummyURL Dummy URL for the page</span><br><span class=\"hljs-comment\">\t */</span><br>\tUFUNCTION(BlueprintCallable, Category = <span class=\"hljs-string\">&quot;Web Browser&quot;</span>)<br>\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">LoadString</span><span class=\"hljs-params\">(FString Contents, FString DummyURL)</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t* Executes a JavaScript string in the context of the web page</span><br><span class=\"hljs-comment\">\t*</span><br><span class=\"hljs-comment\">\t* @param ScriptText JavaScript string to execute</span><br><span class=\"hljs-comment\">\t*/</span><br>\tUFUNCTION(BlueprintCallable, Category = <span class=\"hljs-string\">&quot;Web Browser&quot;</span>)<br>\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ExecuteJavascript</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> FString&amp; ScriptText)</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * Get the current title of the web page</span><br><span class=\"hljs-comment\">\t */</span><br>\tUFUNCTION(BlueprintCallable, Category = <span class=\"hljs-string\">&quot;Web Browser&quot;</span>)<br>\t\t<span class=\"hljs-function\">FText <span class=\"hljs-title\">GetTitleText</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">const</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t* Gets the currently loaded URL.</span><br><span class=\"hljs-comment\">\t*</span><br><span class=\"hljs-comment\">\t* @return The URL, or empty string if no document is loaded.</span><br><span class=\"hljs-comment\">\t*/</span><br>\tUFUNCTION(BlueprintCallable, Category = <span class=\"hljs-string\">&quot;Web Browser&quot;</span>)<br>\t\t<span class=\"hljs-function\">FString <span class=\"hljs-title\">GetUrl</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">const</span></span>;<br><br>\t<span class=\"hljs-comment\">/** Called when the Url changes. */</span><br>\tUPROPERTY(BlueprintAssignable, Category = <span class=\"hljs-string\">&quot;Web Browser|Event&quot;</span>)<br>\tFOnUrlChanged OnUrlChanged;<br><br>\t<span class=\"hljs-comment\">/** Called when a popup is about to spawn. */</span><br>\tUPROPERTY(BlueprintAssignable, Category = <span class=\"hljs-string\">&quot;Web Browser|Event&quot;</span>)<br>\tFOnBeforePopup OnBeforePopup;<br><br><span class=\"hljs-keyword\">public</span>:<br><br>\t<span class=\"hljs-comment\">//~ Begin UWidget interface</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">SynchronizeProperties</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">override</span></span>;<br>\t<span class=\"hljs-comment\">// End UWidget interface</span><br><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ReleaseSlateResources</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">bool</span> bReleaseChildren)</span> <span class=\"hljs-keyword\">override</span></span>;<br><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">if</span> WITH_EDITOR</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">const</span> FText <span class=\"hljs-title\">GetPaletteCategory</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">override</span></span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">endif</span></span><br><br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-comment\">/** URL that the browser will initially navigate to. The URL should include the protocol, eg http:// */</span><br>\tUPROPERTY(EditAnywhere, Category = Appearance)<br>\t\tFString InitialURL;<br><br>\t<span class=\"hljs-comment\">/** Should the browser window support transparency. */</span><br>\tUPROPERTY(EditAnywhere, Category = Appearance)<br>\t\t<span class=\"hljs-keyword\">bool</span> bSupportsTransparency;<br><br><span class=\"hljs-keyword\">protected</span>:<br>\tTSharedPtr&lt;<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SWebBrowser</span>&gt;</span> WebBrowserWidget;<br><br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-comment\">// UWidget interface</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> TSharedRef&lt;SWidget&gt; <span class=\"hljs-title\">RebuildWidget</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">override</span></span>;<br>\t<span class=\"hljs-comment\">// End of UWidget interface</span><br><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">HandleOnUrlChanged</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> FText&amp; Text)</span></span>;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">HandleOnBeforePopup</span><span class=\"hljs-params\">(FString URL, FString Frame)</span></span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">/*MyWebBrowser.cpp*/</span><br><br><span class=\"hljs-comment\">// Fill out your copyright notice in the Description page of Project Settings.</span><br><br><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;MyWebBrowser.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;Runtime/WebBrowser/Public/SWebBrowser.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;Widgets/Layout/SBox.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;Widgets/Text/STextBlock.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;Async/TaskGraphInterfaces.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;UObject/ConstructorHelpers.h&quot;</span></span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">if</span> WITH_EDITOR</span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;Materials/MaterialInterface.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;Materials/MaterialExpressionMaterialFunctionCall.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;Materials/MaterialExpressionTextureSample.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;Materials/MaterialExpressionTextureSampleParameter2D.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;Materials/MaterialFunction.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;Factories/MaterialFactoryNew.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;AssetRegistryModule.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;PackageHelperFunctions.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">endif</span></span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> LOCTEXT_NAMESPACE <span class=\"hljs-meta-string\">&quot;WebBrowser&quot;</span></span><br><br><span class=\"hljs-comment\">/////////////////////////////////////////////////////</span><br><span class=\"hljs-comment\">// UWebBrowser</span><br><br>UMyWebBrowser::UMyWebBrowser(<span class=\"hljs-keyword\">const</span> FObjectInitializer&amp; ObjectInitializer)<br>\t: Super(ObjectInitializer)<br>&#123;<br>\tbIsVariable = <span class=\"hljs-literal\">true</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">UMyWebBrowser::LoadURL</span><span class=\"hljs-params\">(FString NewURL)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">if</span> (WebBrowserWidget.IsValid())<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> WebBrowserWidget-&gt;LoadURL(NewURL);<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">UMyWebBrowser::LoadString</span><span class=\"hljs-params\">(FString Contents, FString DummyURL)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">if</span> (WebBrowserWidget.IsValid())<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> WebBrowserWidget-&gt;LoadString(Contents, DummyURL);<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">UMyWebBrowser::ExecuteJavascript</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> FString&amp; ScriptText)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">if</span> (WebBrowserWidget.IsValid())<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> WebBrowserWidget-&gt;ExecuteJavascript(ScriptText);<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\">FText <span class=\"hljs-title\">UMyWebBrowser::GetTitleText</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">const</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">if</span> (WebBrowserWidget.IsValid())<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> WebBrowserWidget-&gt;GetTitleText();<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> FText::GetEmpty();<br>&#125;<br><br><span class=\"hljs-function\">FString <span class=\"hljs-title\">UMyWebBrowser::GetUrl</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">const</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">if</span> (WebBrowserWidget.IsValid())<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> WebBrowserWidget-&gt;GetUrl();<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> FString();<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">UMyWebBrowser::ReleaseSlateResources</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">bool</span> bReleaseChildren)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tSuper::ReleaseSlateResources(bReleaseChildren);<br><br>\tWebBrowserWidget.Reset();<br>&#125;<br><br><span class=\"hljs-function\">TSharedRef&lt;SWidget&gt; <span class=\"hljs-title\">UMyWebBrowser::RebuildWidget</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">if</span> (IsDesignTime())<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> SNew(SBox)<br>\t\t\t.HAlign(HAlign_Center)<br>\t\t\t.VAlign(VAlign_Center)<br>\t\t\t[<br>\t\t\t\tSNew(STextBlock)<br>\t\t\t\t.Text(LOCTEXT(<span class=\"hljs-string\">&quot;Web Browser&quot;</span>, <span class=\"hljs-string\">&quot;Web Browser&quot;</span>))<br>\t\t\t];<br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span><br>\t&#123;<br>\t\tWebBrowserWidget = SNew(SWebBrowser)<br>\t\t\t.InitialURL(InitialURL)<br>\t\t\t.ShowControls(<span class=\"hljs-literal\">false</span>)<br>\t\t\t.SupportsTransparency(bSupportsTransparency)<br>\t\t\t.OnUrlChanged(BIND_UOBJECT_DELEGATE(FOnTextChanged, HandleOnUrlChanged))<br>\t\t\t.OnBeforePopup(BIND_UOBJECT_DELEGATE(FOnBeforePopupDelegate, HandleOnBeforePopup));<br><br>\t\t<span class=\"hljs-keyword\">return</span> WebBrowserWidget.ToSharedRef();<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">UMyWebBrowser::SynchronizeProperties</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tSuper::SynchronizeProperties();<br><br>\t<span class=\"hljs-keyword\">if</span> (WebBrowserWidget.IsValid())<br>\t&#123;<br><br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">UMyWebBrowser::HandleOnUrlChanged</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> FText&amp; InText)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tOnUrlChanged.Broadcast(InText);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">UMyWebBrowser::HandleOnBeforePopup</span><span class=\"hljs-params\">(FString URL, FString Frame)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">if</span> (OnBeforePopup.IsBound())<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (IsInGameThread())<br>\t\t&#123;<br>\t\t\tOnBeforePopup.Broadcast(URL, Frame);<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span><br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// Retry on the GameThread.</span><br>\t\t\tTWeakObjectPtr&lt;UMyWebBrowser&gt; WeakThis = <span class=\"hljs-keyword\">this</span>;<br>\t\t\tFFunctionGraphTask::CreateAndDispatchWhenReady([WeakThis, URL, Frame]()<br>\t\t\t&#123;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span> (WeakThis.IsValid())<br>\t\t\t\t&#123;<br>\t\t\t\t\tWeakThis-&gt;HandleOnBeforePopup(URL, Frame);<br>\t\t\t\t&#125;<br>\t\t\t&#125;, TStatId(), <span class=\"hljs-literal\">nullptr</span>, ENamedThreads::GameThread);<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>&#125;<br><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">if</span> WITH_EDITOR</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">const</span> FText <span class=\"hljs-title\">UMyWebBrowser::GetPaletteCategory</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> LOCTEXT(<span class=\"hljs-string\">&quot;My&quot;</span>, <span class=\"hljs-string\">&quot;My&quot;</span>);<br>&#125;<br><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">endif</span></span><br><br><span class=\"hljs-comment\">/////////////////////////////////////////////////////</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">undef</span> LOCTEXT_NAMESPACE</span><br><br></code></pre></td></tr></table></figure>\n\n\n<h1 id=\"二、嵌入Web页面\"><a href=\"#二、嵌入Web页面\" class=\"headerlink\" title=\"二、嵌入Web页面\"></a>二、嵌入Web页面</h1><p>我们创建的MyWebBrowser继承自Widget属于UI范畴，所以Web显示操作属于UI操作。</p>\n<h2 id=\"1-创建Web嵌入所用UI\"><a href=\"#1-创建Web嵌入所用UI\" class=\"headerlink\" title=\"1.创建Web嵌入所用UI\"></a>1.创建Web嵌入所用UI</h2><p>在Content Browser中右键/User Interface/Widget Buleprint，创建UI蓝图，这里我命名为WebBrowser。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170745.png\"></p>\n<p>打开WebBrowser，如果上面代码都编译通过了，那么在UI的Palette中应该会有一My栏，栏中有一个My Web Browser控件，这就是我们创建的自定义WebBrowser。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170752.png\"></p>\n<p>将My Web Browser拖入Hierachy中的Canvas Panel中并调整好大小。</p>\n<h2 id=\"2-显示UI\"><a href=\"#2-显示UI\" class=\"headerlink\" title=\"2.显示UI\"></a>2.显示UI</h2><p>打开关卡蓝图，写入如下蓝图脚本：</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170758.png\"></p>\n<p>注意，Class中填入的是我们刚创建的UI蓝图webBrowser。</p>\n<h2 id=\"3-嵌入Web\"><a href=\"#3-嵌入Web\" class=\"headerlink\" title=\"3.嵌入Web\"></a>3.嵌入Web</h2><p>在UI蓝图webBrowser的Graph中写入如下蓝图脚本，在New URL中下入<a href=\"http://www.baidu.com用以测试./\">www.baidu.com用以测试。</a></p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170806.png\"></p>\n<p>运行测试</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170812.png\"></p>\n<p>测试通过。</p>\n<h1 id=\"三、UE4到Web通信\"><a href=\"#三、UE4到Web通信\" class=\"headerlink\" title=\"三、UE4到Web通信\"></a>三、UE4到Web通信</h1><p>UE4到Web的通信，这里以UE4到ECharts的通信为例，首先到ECharts官网下载一个自己喜欢的图表源码到本地。</p>\n<p>ECharts官网： <a href=\"https://www.echartsjs.com/zh/index.html\">https://www.echartsjs.com/zh/index.html</a> </p>\n<p>我以折线图为例</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170819.png\"></p>\n<p>ECharts上手较为简单，官方有5分钟快速上手教程，有详尽的API解释，这里不多累赘。</p>\n<p>这里以使用UE4设置折线图Y轴的最大值和最小值为例。</p>\n<h2 id=\"1-通信前的准备\"><a href=\"#1-通信前的准备\" class=\"headerlink\" title=\"1.通信前的准备\"></a>1.通信前的准备</h2><p>UE4到Web的通信需要通过SWebBrowser类的一个函数来绑定通信对象，然后通过这个对象进行数据通信。</p>\n<p>首先我们需要定义一个函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">UFUNCTION(BlueprintCallable, Category = <span class=\"hljs-string\">&quot;Web Browser&quot;</span>)<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">UMyWebBrowser::BindUObject</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> FString &amp; Name, UObject * Object, <span class=\"hljs-keyword\">bool</span> bIsPermanent)</span></span>;<br></code></pre></td></tr></table></figure>\n<p>函数调用SWebBrowser类里的<code>void SWebBrowser::BindUObject(const FString &amp; Name, UObject * Object, bool bIsPermanent);</code>函数实现通信中介的创建。</p>\n<p>这里要注意BindUObject函数需要暴露给蓝图调用。</p>\n<p>函数实现</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">UMyWebBrowser::BindUObject</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> FString &amp; Name, UObject * Object, <span class=\"hljs-keyword\">bool</span> bIsPermanent)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">if</span> (WebBrowserWidget.IsValid())<br>\t&#123;<br>\t\tWebBrowserWidget-&gt;BindUObject(Name, Object, bIsPermanent);<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"2-创建通信对象与数据传递方法\"><a href=\"#2-创建通信对象与数据传递方法\" class=\"headerlink\" title=\"2.创建通信对象与数据传递方法\"></a>2.创建通信对象与数据传递方法</h2><p>然后再在WebBrowser的Graph的蓝图脚本中添加BindUObject的调用创建通信中介对象。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170828.png\"></p>\n<p>其中Name中填写的就是通信中介对象的名字，名字可以自定义，这里命的名字在Web中调用时用的对象名，中介对象就是Self，即当前Widget对象。</p>\n<p>UE4到Web的通信是Web主动调用UE4的方法，通信的数据则是这个方法的返回值，Web可以获取到这个返回值，通过这个对象中的这个方法的返回值即可达到数据通信的目的。</p>\n<p>在WebBrowser的My Blueprint/Functions中添加两个用于数据传递的方法，GetMin和GetMax。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170833.png\"></p>\n<p><font color=\"red\">这里要注意，用于数据传递的方法的返回值的名字必须是<code>ReturnValue</code>否则数据无法传递。</font></p>\n<p>之后就可以在Web中操作通过obj这个对象操作这些函数来获取UE4里的Min和Max变量了。</p>\n<p>这里贴出Web源码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;meta charset=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;<br>    &lt;!-- 引入 echarts.js --&gt;<br>\t&lt;script src=<span class=\"hljs-string\">&quot;C:/Users/Administrator/Desktop/ECharts/echarts.min.js&quot;</span>&gt;&lt;/script&gt;<br>    &lt;script src=<span class=\"hljs-string\">&quot;C:/Users/Administrator/Desktop/ECharts/jquery.min.js&quot;</span>&gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body style = <span class=\"hljs-string\">&quot;background-color:#d8d8d8&quot;</span>&gt;<br>    &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt;<br>\t&lt;div id=<span class=\"hljs-string\">&quot;main&quot;</span> style=<span class=\"hljs-string\">&quot;width: 1000px;height:450px;position:1px; top:1px;&quot;</span>&gt;CHART&lt;/div&gt;<br>\t&lt;script type=<span class=\"hljs-string\">&quot;text/javascript&quot;</span>&gt;<br>         <br>\t\t<span class=\"hljs-keyword\">var</span> myChart = echarts.init(<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;main&quot;</span>));<br>\t\t<span class=\"hljs-keyword\">var</span> x = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">9</span>,<span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">12</span>,<span class=\"hljs-number\">13</span>,<span class=\"hljs-number\">14</span>,<span class=\"hljs-number\">15</span>,<span class=\"hljs-number\">16</span>,<span class=\"hljs-number\">17</span>,<span class=\"hljs-number\">18</span>,<span class=\"hljs-number\">19</span>,<span class=\"hljs-number\">20</span>,<span class=\"hljs-number\">20</span>,<span class=\"hljs-number\">22</span>,<span class=\"hljs-number\">23</span>,<span class=\"hljs-number\">24</span>,<span class=\"hljs-number\">25</span>,<span class=\"hljs-number\">26</span>,<span class=\"hljs-number\">27</span>,<span class=\"hljs-number\">28</span>,<span class=\"hljs-number\">29</span>,<span class=\"hljs-number\">30</span>,<span class=\"hljs-number\">31</span>,<span class=\"hljs-number\">32</span>,<span class=\"hljs-number\">33</span>,<span class=\"hljs-number\">34</span>,<span class=\"hljs-number\">35</span>,<span class=\"hljs-number\">36</span>,<span class=\"hljs-number\">37</span>,<span class=\"hljs-number\">38</span>,<span class=\"hljs-number\">39</span>,<span class=\"hljs-number\">40</span>];<br>\t\t<span class=\"hljs-keyword\">var</span> y = [];<br>\t\t<br>\t\t<span class=\"hljs-keyword\">var</span> y_min = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">var</span> y_max = <span class=\"hljs-number\">1</span>;<br>\t\t<br>\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Set</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>\t\t\toption = &#123;<br>\t\t\t\ttooltip :<br>\t\t\t\t&#123;<br>\t\t\t\t\ttrigger : <span class=\"hljs-string\">&#x27;axis&#x27;</span>,<br>\t\t\t\t\t<span class=\"hljs-comment\">//十字锚点</span><br>\t\t\t\t\taxisPointer:<br>\t\t\t\t\t&#123;<br>\t\t\t\t\t\ttype: <span class=\"hljs-string\">&#x27;cross&#x27;</span>,<br>\t\t\t\t\t\tanimation: <span class=\"hljs-literal\">false</span>,<br>\t\t\t\t\t\tlabel: &#123;<span class=\"hljs-attr\">backgroundColor</span>: <span class=\"hljs-string\">&#x27;#505765&#x27;</span>&#125;,<br>\t\t\t\t\t\tlineStyle : &#123;<span class=\"hljs-attr\">type</span> : <span class=\"hljs-string\">&#x27;dashed&#x27;</span>&#125;<br>\t\t\t\t\t&#125;<br>\t\t\t\t&#125;,<br>\t\t\t\txAxis: &#123;<span class=\"hljs-attr\">data</span>: x&#125;,<br>\t\t\t\tyAxis: <br>\t\t\t\t&#123;<br>\t\t\t\t\tsplitLine: &#123;<span class=\"hljs-attr\">show</span>: <span class=\"hljs-literal\">false</span> &#125;,<br>\t\t\t\t\tmin : y_min,<br>\t\t\t\t\tmax : y_max<br>\t\t\t\t&#125;,<br>\t\t\t\tdataZoom: [<br>\t\t\t\t\t&#123;<span class=\"hljs-attr\">startValue</span>: <span class=\"hljs-string\">&#x27;2014-06-01&#x27;</span>&#125;, <br>\t\t\t\t\t&#123;<span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;inside&#x27;</span>&#125;<br>\t\t\t\t],\t<br>\t\t\t\tseries: &#123;<br>\t\t\t\t\ttype: <span class=\"hljs-string\">&#x27;line&#x27;</span>,<br>\t\t\t\t\tdata: y<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\t<br>\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SetYMinAndMax</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>\t\t\tue.obj.getmin().then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">ReturnValue</span>)</span>&#123;<br>\t\t\t\ty_min = ReturnValue;<br>\t\t\t&#125;);<br>\t\t\tue.obj.getmax().then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">ReturnValue</span>)</span>&#123;<br>\t\t\t\ty_max = ReturnValue;<br>\t\t\t&#125;);<br>\t\t&#125;<br>\t\t<br>\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">AddData</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>\t\t\ty.push(<span class=\"hljs-built_in\">Math</span>.random());<br>\t\t&#125;<br>\t\t<br>\t\tSetYMinAndMax();<br>\t\t<span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>\t\t\tAddData();<br>\t\t\t<span class=\"hljs-built_in\">Set</span>();<br>\t\t\tmyChart.setOption(option);<br>\t\t&#125;,<span class=\"hljs-number\">1000</span>);<br>    &lt;/script&gt;\t\t<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>\n<p>其中SetYMinAndMax函数便是UE4与Web的数据通信。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SetYMinAndMax</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>\t\t\tue.obj.getmin().then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">ReturnValue</span>)</span>&#123;<br>\t\t\t\ty_min = ReturnValue;<br>\t\t\t&#125;);<br>\t\t\tue.obj.getmax().then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">ReturnValue</span>)</span>&#123;<br>\t\t\t\ty_max = ReturnValue;<br>\t\t\t&#125;);<br>\t\t&#125;<br></code></pre></td></tr></table></figure>\n<p><font color=\"red\">这里还需要注意，ue.obj.getmin()和ue.obj.getmax()必须使用小写，否则也无法通信，其次匿名函数function(ReturnValue)的参数名也必须为ReturnValue不可更改，否则数据依然无法传递。</font></p>\n<p>然后测试一下数据传递是否正确。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170845.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170850.png\"></p>\n<p>可以看到Y轴的最大值由1改为了Max变量的值2。数据传递成功。</p>\n<p>上面的Web程序要运行还需要两个文件<code>echarts.min.js</code>和<code>jquery.min.js</code>，文件放在：</p>\n<p>这是B站上的视频教程：<a href=\"https://www.bilibili.com/video/av47212309\">https://www.bilibili.com/video/av47212309</a></p>"},{"title":"【UE4】UE4基于Spline的测距功能","date":"2021-05-14T09:41:32.000Z","password":null,"abstract":null,"message":null,"_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 基于Spline的测距功能插件\n\n<!--more-->\n\n# 一、功能分析\n\n这里首先分析一下整个插件的功能部件\n\n- SplineActor---基于Spline的线条显示模块\n\n- Ranging---对整个插件功能的整体控制\n\n- DistancePanel---距离显示UI\n\n- Point---线上的点，集成DistancePanel\n\n- FunLib---高复用函数集合\n\n  资产状况：\n\n  ![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174241.png)\n\n\n由于使用屏幕坐标转世界坐标的方式实现测距功能可能及其复杂，所以这里使用比较直观简便的三维Spline来实现测距功能。\n\n# 二、制作线上的点Point\n\n## 1.Point的结构分析\n\nPoint是一个拥有StaticMesh和WedgitComponent组件的Actor，StaticMesh我这里使用Shape，Materials是自己做的一个发光材质。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174247.png)\n\n\n## 2.MeshMeterial材质\n\nMaterials蓝图：\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174258.png)\n\n\n## 3.Point核心函数实现\n\nPoint主要实现一个函数两个事件\n\n- 函数ShowDistance---负责距离显示\n- 事件InitFontInfo---负责获取初始字体信息\n- 事件ShowText---控制距离是否显示\n\n在构造函数需要记录DistancePanel的初始位置信息和初始字体信息。\n\nConstructScript：记录DistancePanel的初始位置信息和初始字体信息\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174305.png)\n\n\nInitFontInfo：记录字体的初始信息\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174317.png)\n\n\nShowText：设置显示字体的大小。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174323.png)\n\n\nTick函数：SetActorRotation设置点上的文字跟随摄像机旋转使之始终面向摄像机，GetMouseLocation->SetActorLocation->ShowText当SureLocation为false时即未确定点的位置时设置点跟随鼠标移动，当点跟随鼠标移动时不显示距离。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174329.png)\n\n\n- FontInfo：是一个SlateFontInfoStructure结构体用于设置距离显示的字体样式。\n- SureLocation：bool变量，确认点是否已经确定了位置坐标，当点没有确定位置坐标时，点将跟随鼠标移动。\n- InitScale3D：Vector变量，保存DistancePanel的初始大小。\n- SureAdsorb：bool变量，控制闭环吸附，当为true时，起点具有吸附功能，可以将终点吸附到起点位置实现闭环。\n\nShowDistance：将输入的距离信息显示出来。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174336.png)\n\n\n至此点的设计完毕。\n\n# 三、用于显示的Widget\n\n创建一个UserWidget命名为DistancePanel，DistancePanel比较简单，CanvasPanel下就一个Text即可，只有一个函数UpdateTextScale，然后在EventConstruct中记录Text的初始大小。\n\nEventConstruct：\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174342.png)\n\n\nUpdateTextScale：更新Text的大小，使Text跟随摄像机距离地板的远近变大变小，以保证Text的大小在视野中保持不变。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174347.png)\n\n\n# 三、使用Spline制作线段\n\n## 1.SplineActor结构分析\n\nSpline是UE4的样条线组件，Spline是一组点和线的集合，但是Spline的点和线只有在编辑模式下可见，在运行模式下不可见，Spline可以通过选中其中的点按下Alt键并拖动鼠标来添加新的点。\n\n我们需要一个Actor作为Spline的载体，创建一个Actor命名为Spline。Spline的组件结构为：\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174354.png)\n\n\n- StaticMesh：使用Shape和自定义的材质，这个Mesh作为起点使用。\n- Spline：样条线组件，此Actor的核心组件。\n- Sphere：球型触发器，用于起点吸附。\n\n## 2.在编辑模式下实现Spline编辑\n\n在编辑模式下实现样条线的编辑需要在构造函数中实现下面的逻辑：\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174403.png)\n\n\n核心函数分析：\n\n- AddSplineMeshComponent：这是一个自定义的封装函数，作用就是提高复用率，\n\n ![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174410.png)\n\n\n  StaticMesh决定线的样式，Meterial决定线的颜色；\n\n- AttachToMeshComponent：将添加的SplineMeshComponent组件设置StaticMesh为父节点；\n\n- Set Start and End：函数根据Get LocationandTangentatSplinePoint函数获取的起点和终点的位置和切角，将生成的SplineMeshComponent组件附着在上面。\n\n这样我们的Spline样条线就被设置成了我们设定的模样，并且在运行时可见。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174417.png)\n\n\n## 3.运行时动态添加Spline的点\n\n由于在运行模式下无法像在编辑模式下通过Alt键拖动点来添加Spline的点，所以我们需要通过蓝图来实现。这项功能封装在AddPoint函数中。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174423.png)\n\n\nAddPoint函数通过输入的坐标位置动态生成Spline的点\n\n- AddSplinePoint：向Spline中添加新的点；\n- SpawnActorPoint：目的是在Spline的生成的新点的位置处生成一个具象化的Point；\n- Sequence的的Then0分支作用是当生成一个新的Point时，确定上一个Point的位置坐标；\n- PointArray是一个Point类型的数组，用于存储生成的Point的引用，SplineMeshComponentArray是一个SplineMeshComponent类型的数组，用于存储生成的SplineMeshComponent组件的引用，两个数组的作用是方便之后对Point和SplineMeshComponent的操作。\n- AddSplineMeshComponent、AttachToComponent和SetSartandEnd函数作用和构造函数中一样；\n- UpddateTotaldistance函数用于更新距离显示，具体实现在后面介绍。\n\nAddPoint函数在AddPointEvent事件中调用。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174433.png)\n\n\n\n- GetMouseLocation是FunLib库中的一个函数负责获取鼠标坐在的屏幕坐标转换成空间坐标。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174439.png)\n\n\n\n## 4.实时更新样条线\n\n实时更新样条线的功能封装在UpdateCurrentSplinePoint函数中。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174446.png)\n\n\nUpdateCurrentSplinePoint函数在SplineActor的Tick函数中调用，每帧删除前一个Spline的点，在新的坐标位置下添加一个新的Spline的点，由于Point是跟随鼠标移动的，所以通过这个操作在宏观上的表现就是Spline的点在跟随鼠标一点，之所以使用这种方式，是因为Spline中的点似乎没办法直接修改位置。\n\n每帧设置好位置之后再重新渲染一遍Mesh组件，就达到如下效果了：\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174453.gif)\n\n\n这样在运行状态下编辑Spline样条线就制作完成了。\n\n# 四、实时更新距离\n\n实时更新距离的功能封装在UpdateTotalDistance函数下。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174502.png)\n\n\n- Ranging变量就是Ranging类型，存储Ranging的引用，在重新计算总距离前先将存储中距离的变量TotalDistance清零；\n- 然后一次取PointArray中的Point来计算Point与Point之间的距离，0号索引的Point较为特殊需要与其他索引的Point分开计算，因为0号索引的Point需要与SplineActor的位置计算距离；\n- ShowDistance函数封装在Point类中，负责将输入的距离显示出来。\n\n显示总距离专门创建了一个DistancePanel来显示。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174508.png)\n\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180451.png)\n\n\n- HiddenTotalDistance控制总距离是否显示。\n\n到这里基本的功能就基本实现了，下面实现一些必要的附加功能。\n\n# 五、封装Ranging类\n\n由于SplineActor类是插件的核心类，不宜对外开放调用接口，且SplineActor类自身拥有Mesh，直接拖入场景中会显示Mesh，效果不佳，所以在SplineActor之外再封装一成没有Mesh的Ranging是十分必要的，有Ranging类提供对外调用的接口。\n\nRanging类的封装函数和变量：\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180459.png)\n\n\n\n- SetupRanging：启动测距，在鼠标所在位置生成SplineActor；\n\n  ![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180504.png)\n\n\n- AddPoint：封装SplineActor中的AddPointEvent事件；\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180511.png)\n\n\n- EndRanging：结束测距，封装ActorSpline的DeleteLastPoint函数，函数的具体实现在之后介绍；\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180516.png)\n\n\n- Remove：删除所有的点线，封装SplineActor的RemoveAllPoint函数，函数的具体实现在之后介绍；\n\n ![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180522.png)\n\n\n- SplineActor：存储SplineActor的引用；\n\n- TotalDistance：存储总距离的值；\n\n- DistanceUint：显示总距离时的单位；\n\n- K：存储SplineActor中DistancePanel随相机距离变化大小的变化倍率；我这里设定的值为0.0002。\n\n文字随相机距离变化的函数实现封装在Ranging的UpdeteDistancePanelScale事件中，事件在Ranging的Tick函数中调用。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180542.png)\n\n\n# 六、保持Point的DistancePanel组件的大小不变\n\n为了保证观感效果，Point的显示距离的DistancePanel组件的大小应该跟随相机的远近保持保持一定的大小，以保证相机贴近地面时，文字不会过大，相机原理地面时文字不过过小而看不见。\n\n实现原理就在Ranging的UpdateDistancePanelScale事件中。\n\n# 七、返回上一步功能\n\n当我们确定点的位置时会出现位置确定错误的情况，所以返回上一步的功能也是十分必要的，具体实现在SplineActor的DeleteLastPoint函数中。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180550.png)\n\n\n原理是移除上一个Spline的点和其匹配的Point、SplineMeshComponent并删除数组中对应的元素，然后更新一次距离，如果剩下最后一个点时，再撤回就直接将SplineActor删除并把显示总距离的DistancePanel移除，防止再创建SplineActor时再生成一个DiatancePanel而出现两个DistancePanel。\n\n# 八、移除所有的点\n\n当测距完成后需要清除所有的点，所以此功能也是必要的，具体实现在SplineActor的RemoveAllPoint中。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180557.png)\n\n\n# 九、起点吸附功能\n\n起点吸附是为了实现闭环。具体实现在SplineActor的EventActorBeginOverlap事件中。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180603.png)\n\n\n原理就是当SplineActor的Sphere触发器检测到Point时将此Point的坐标设置到起点的坐标处。\n\n# 九、整体效果预览\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180609.gif)\n\n","source":"_posts/【UE4】UE4基于Spline的测距功能.md","raw":"---\ntitle: 【UE4】UE4基于Spline的测距功能\ndate: 2021-05-14 17:41:32\ntags: UE4\ncategories: 知识记录\npassword:\nabstract:\nmessage:\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 基于Spline的测距功能插件\n\n<!--more-->\n\n# 一、功能分析\n\n这里首先分析一下整个插件的功能部件\n\n- SplineActor---基于Spline的线条显示模块\n\n- Ranging---对整个插件功能的整体控制\n\n- DistancePanel---距离显示UI\n\n- Point---线上的点，集成DistancePanel\n\n- FunLib---高复用函数集合\n\n  资产状况：\n\n  ![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174241.png)\n\n\n由于使用屏幕坐标转世界坐标的方式实现测距功能可能及其复杂，所以这里使用比较直观简便的三维Spline来实现测距功能。\n\n# 二、制作线上的点Point\n\n## 1.Point的结构分析\n\nPoint是一个拥有StaticMesh和WedgitComponent组件的Actor，StaticMesh我这里使用Shape，Materials是自己做的一个发光材质。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174247.png)\n\n\n## 2.MeshMeterial材质\n\nMaterials蓝图：\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174258.png)\n\n\n## 3.Point核心函数实现\n\nPoint主要实现一个函数两个事件\n\n- 函数ShowDistance---负责距离显示\n- 事件InitFontInfo---负责获取初始字体信息\n- 事件ShowText---控制距离是否显示\n\n在构造函数需要记录DistancePanel的初始位置信息和初始字体信息。\n\nConstructScript：记录DistancePanel的初始位置信息和初始字体信息\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174305.png)\n\n\nInitFontInfo：记录字体的初始信息\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174317.png)\n\n\nShowText：设置显示字体的大小。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174323.png)\n\n\nTick函数：SetActorRotation设置点上的文字跟随摄像机旋转使之始终面向摄像机，GetMouseLocation->SetActorLocation->ShowText当SureLocation为false时即未确定点的位置时设置点跟随鼠标移动，当点跟随鼠标移动时不显示距离。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174329.png)\n\n\n- FontInfo：是一个SlateFontInfoStructure结构体用于设置距离显示的字体样式。\n- SureLocation：bool变量，确认点是否已经确定了位置坐标，当点没有确定位置坐标时，点将跟随鼠标移动。\n- InitScale3D：Vector变量，保存DistancePanel的初始大小。\n- SureAdsorb：bool变量，控制闭环吸附，当为true时，起点具有吸附功能，可以将终点吸附到起点位置实现闭环。\n\nShowDistance：将输入的距离信息显示出来。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174336.png)\n\n\n至此点的设计完毕。\n\n# 三、用于显示的Widget\n\n创建一个UserWidget命名为DistancePanel，DistancePanel比较简单，CanvasPanel下就一个Text即可，只有一个函数UpdateTextScale，然后在EventConstruct中记录Text的初始大小。\n\nEventConstruct：\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174342.png)\n\n\nUpdateTextScale：更新Text的大小，使Text跟随摄像机距离地板的远近变大变小，以保证Text的大小在视野中保持不变。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174347.png)\n\n\n# 三、使用Spline制作线段\n\n## 1.SplineActor结构分析\n\nSpline是UE4的样条线组件，Spline是一组点和线的集合，但是Spline的点和线只有在编辑模式下可见，在运行模式下不可见，Spline可以通过选中其中的点按下Alt键并拖动鼠标来添加新的点。\n\n我们需要一个Actor作为Spline的载体，创建一个Actor命名为Spline。Spline的组件结构为：\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174354.png)\n\n\n- StaticMesh：使用Shape和自定义的材质，这个Mesh作为起点使用。\n- Spline：样条线组件，此Actor的核心组件。\n- Sphere：球型触发器，用于起点吸附。\n\n## 2.在编辑模式下实现Spline编辑\n\n在编辑模式下实现样条线的编辑需要在构造函数中实现下面的逻辑：\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174403.png)\n\n\n核心函数分析：\n\n- AddSplineMeshComponent：这是一个自定义的封装函数，作用就是提高复用率，\n\n ![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174410.png)\n\n\n  StaticMesh决定线的样式，Meterial决定线的颜色；\n\n- AttachToMeshComponent：将添加的SplineMeshComponent组件设置StaticMesh为父节点；\n\n- Set Start and End：函数根据Get LocationandTangentatSplinePoint函数获取的起点和终点的位置和切角，将生成的SplineMeshComponent组件附着在上面。\n\n这样我们的Spline样条线就被设置成了我们设定的模样，并且在运行时可见。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174417.png)\n\n\n## 3.运行时动态添加Spline的点\n\n由于在运行模式下无法像在编辑模式下通过Alt键拖动点来添加Spline的点，所以我们需要通过蓝图来实现。这项功能封装在AddPoint函数中。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174423.png)\n\n\nAddPoint函数通过输入的坐标位置动态生成Spline的点\n\n- AddSplinePoint：向Spline中添加新的点；\n- SpawnActorPoint：目的是在Spline的生成的新点的位置处生成一个具象化的Point；\n- Sequence的的Then0分支作用是当生成一个新的Point时，确定上一个Point的位置坐标；\n- PointArray是一个Point类型的数组，用于存储生成的Point的引用，SplineMeshComponentArray是一个SplineMeshComponent类型的数组，用于存储生成的SplineMeshComponent组件的引用，两个数组的作用是方便之后对Point和SplineMeshComponent的操作。\n- AddSplineMeshComponent、AttachToComponent和SetSartandEnd函数作用和构造函数中一样；\n- UpddateTotaldistance函数用于更新距离显示，具体实现在后面介绍。\n\nAddPoint函数在AddPointEvent事件中调用。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174433.png)\n\n\n\n- GetMouseLocation是FunLib库中的一个函数负责获取鼠标坐在的屏幕坐标转换成空间坐标。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174439.png)\n\n\n\n## 4.实时更新样条线\n\n实时更新样条线的功能封装在UpdateCurrentSplinePoint函数中。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174446.png)\n\n\nUpdateCurrentSplinePoint函数在SplineActor的Tick函数中调用，每帧删除前一个Spline的点，在新的坐标位置下添加一个新的Spline的点，由于Point是跟随鼠标移动的，所以通过这个操作在宏观上的表现就是Spline的点在跟随鼠标一点，之所以使用这种方式，是因为Spline中的点似乎没办法直接修改位置。\n\n每帧设置好位置之后再重新渲染一遍Mesh组件，就达到如下效果了：\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174453.gif)\n\n\n这样在运行状态下编辑Spline样条线就制作完成了。\n\n# 四、实时更新距离\n\n实时更新距离的功能封装在UpdateTotalDistance函数下。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174502.png)\n\n\n- Ranging变量就是Ranging类型，存储Ranging的引用，在重新计算总距离前先将存储中距离的变量TotalDistance清零；\n- 然后一次取PointArray中的Point来计算Point与Point之间的距离，0号索引的Point较为特殊需要与其他索引的Point分开计算，因为0号索引的Point需要与SplineActor的位置计算距离；\n- ShowDistance函数封装在Point类中，负责将输入的距离显示出来。\n\n显示总距离专门创建了一个DistancePanel来显示。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174508.png)\n\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180451.png)\n\n\n- HiddenTotalDistance控制总距离是否显示。\n\n到这里基本的功能就基本实现了，下面实现一些必要的附加功能。\n\n# 五、封装Ranging类\n\n由于SplineActor类是插件的核心类，不宜对外开放调用接口，且SplineActor类自身拥有Mesh，直接拖入场景中会显示Mesh，效果不佳，所以在SplineActor之外再封装一成没有Mesh的Ranging是十分必要的，有Ranging类提供对外调用的接口。\n\nRanging类的封装函数和变量：\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180459.png)\n\n\n\n- SetupRanging：启动测距，在鼠标所在位置生成SplineActor；\n\n  ![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180504.png)\n\n\n- AddPoint：封装SplineActor中的AddPointEvent事件；\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180511.png)\n\n\n- EndRanging：结束测距，封装ActorSpline的DeleteLastPoint函数，函数的具体实现在之后介绍；\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180516.png)\n\n\n- Remove：删除所有的点线，封装SplineActor的RemoveAllPoint函数，函数的具体实现在之后介绍；\n\n ![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180522.png)\n\n\n- SplineActor：存储SplineActor的引用；\n\n- TotalDistance：存储总距离的值；\n\n- DistanceUint：显示总距离时的单位；\n\n- K：存储SplineActor中DistancePanel随相机距离变化大小的变化倍率；我这里设定的值为0.0002。\n\n文字随相机距离变化的函数实现封装在Ranging的UpdeteDistancePanelScale事件中，事件在Ranging的Tick函数中调用。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180542.png)\n\n\n# 六、保持Point的DistancePanel组件的大小不变\n\n为了保证观感效果，Point的显示距离的DistancePanel组件的大小应该跟随相机的远近保持保持一定的大小，以保证相机贴近地面时，文字不会过大，相机原理地面时文字不过过小而看不见。\n\n实现原理就在Ranging的UpdateDistancePanelScale事件中。\n\n# 七、返回上一步功能\n\n当我们确定点的位置时会出现位置确定错误的情况，所以返回上一步的功能也是十分必要的，具体实现在SplineActor的DeleteLastPoint函数中。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180550.png)\n\n\n原理是移除上一个Spline的点和其匹配的Point、SplineMeshComponent并删除数组中对应的元素，然后更新一次距离，如果剩下最后一个点时，再撤回就直接将SplineActor删除并把显示总距离的DistancePanel移除，防止再创建SplineActor时再生成一个DiatancePanel而出现两个DistancePanel。\n\n# 八、移除所有的点\n\n当测距完成后需要清除所有的点，所以此功能也是必要的，具体实现在SplineActor的RemoveAllPoint中。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180557.png)\n\n\n# 九、起点吸附功能\n\n起点吸附是为了实现闭环。具体实现在SplineActor的EventActorBeginOverlap事件中。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180603.png)\n\n\n原理就是当SplineActor的Sphere触发器检测到Point时将此Point的坐标设置到起点的坐标处。\n\n# 九、整体效果预览\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180609.gif)\n\n","slug":"【UE4】UE4基于Spline的测距功能","published":1,"updated":"2021-05-14T10:15:00.905Z","_id":"ckoo5uhf50000k8r76288a6yl","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h1 id=\"基于Spline的测距功能插件\"><a href=\"#基于Spline的测距功能插件\" class=\"headerlink\" title=\"基于Spline的测距功能插件\"></a>基于Spline的测距功能插件</h1><a id=\"more\"></a>\n\n<h1 id=\"一、功能分析\"><a href=\"#一、功能分析\" class=\"headerlink\" title=\"一、功能分析\"></a>一、功能分析</h1><p>这里首先分析一下整个插件的功能部件</p>\n<ul>\n<li><p>SplineActor—基于Spline的线条显示模块</p>\n</li>\n<li><p>Ranging—对整个插件功能的整体控制</p>\n</li>\n<li><p>DistancePanel—距离显示UI</p>\n</li>\n<li><p>Point—线上的点，集成DistancePanel</p>\n</li>\n<li><p>FunLib—高复用函数集合</p>\n<p>资产状况：</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174241.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n</ul>\n<p>由于使用屏幕坐标转世界坐标的方式实现测距功能可能及其复杂，所以这里使用比较直观简便的三维Spline来实现测距功能。</p>\n<h1 id=\"二、制作线上的点Point\"><a href=\"#二、制作线上的点Point\" class=\"headerlink\" title=\"二、制作线上的点Point\"></a>二、制作线上的点Point</h1><h2 id=\"1-Point的结构分析\"><a href=\"#1-Point的结构分析\" class=\"headerlink\" title=\"1.Point的结构分析\"></a>1.Point的结构分析</h2><p>Point是一个拥有StaticMesh和WedgitComponent组件的Actor，StaticMesh我这里使用Shape，Materials是自己做的一个发光材质。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174247.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"2-MeshMeterial材质\"><a href=\"#2-MeshMeterial材质\" class=\"headerlink\" title=\"2.MeshMeterial材质\"></a>2.MeshMeterial材质</h2><p>Materials蓝图：</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174258.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"3-Point核心函数实现\"><a href=\"#3-Point核心函数实现\" class=\"headerlink\" title=\"3.Point核心函数实现\"></a>3.Point核心函数实现</h2><p>Point主要实现一个函数两个事件</p>\n<ul>\n<li>函数ShowDistance—负责距离显示</li>\n<li>事件InitFontInfo—负责获取初始字体信息</li>\n<li>事件ShowText—控制距离是否显示</li>\n</ul>\n<p>在构造函数需要记录DistancePanel的初始位置信息和初始字体信息。</p>\n<p>ConstructScript：记录DistancePanel的初始位置信息和初始字体信息</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174305.png\" alt=\"在这里插入图片描述\"></p>\n<p>InitFontInfo：记录字体的初始信息</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174317.png\" alt=\"在这里插入图片描述\"></p>\n<p>ShowText：设置显示字体的大小。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174323.png\" alt=\"在这里插入图片描述\"></p>\n<p>Tick函数：SetActorRotation设置点上的文字跟随摄像机旋转使之始终面向摄像机，GetMouseLocation-&gt;SetActorLocation-&gt;ShowText当SureLocation为false时即未确定点的位置时设置点跟随鼠标移动，当点跟随鼠标移动时不显示距离。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174329.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>FontInfo：是一个SlateFontInfoStructure结构体用于设置距离显示的字体样式。</li>\n<li>SureLocation：bool变量，确认点是否已经确定了位置坐标，当点没有确定位置坐标时，点将跟随鼠标移动。</li>\n<li>InitScale3D：Vector变量，保存DistancePanel的初始大小。</li>\n<li>SureAdsorb：bool变量，控制闭环吸附，当为true时，起点具有吸附功能，可以将终点吸附到起点位置实现闭环。</li>\n</ul>\n<p>ShowDistance：将输入的距离信息显示出来。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174336.png\" alt=\"在这里插入图片描述\"></p>\n<p>至此点的设计完毕。</p>\n<h1 id=\"三、用于显示的Widget\"><a href=\"#三、用于显示的Widget\" class=\"headerlink\" title=\"三、用于显示的Widget\"></a>三、用于显示的Widget</h1><p>创建一个UserWidget命名为DistancePanel，DistancePanel比较简单，CanvasPanel下就一个Text即可，只有一个函数UpdateTextScale，然后在EventConstruct中记录Text的初始大小。</p>\n<p>EventConstruct：</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174342.png\" alt=\"在这里插入图片描述\"></p>\n<p>UpdateTextScale：更新Text的大小，使Text跟随摄像机距离地板的远近变大变小，以保证Text的大小在视野中保持不变。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174347.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"三、使用Spline制作线段\"><a href=\"#三、使用Spline制作线段\" class=\"headerlink\" title=\"三、使用Spline制作线段\"></a>三、使用Spline制作线段</h1><h2 id=\"1-SplineActor结构分析\"><a href=\"#1-SplineActor结构分析\" class=\"headerlink\" title=\"1.SplineActor结构分析\"></a>1.SplineActor结构分析</h2><p>Spline是UE4的样条线组件，Spline是一组点和线的集合，但是Spline的点和线只有在编辑模式下可见，在运行模式下不可见，Spline可以通过选中其中的点按下Alt键并拖动鼠标来添加新的点。</p>\n<p>我们需要一个Actor作为Spline的载体，创建一个Actor命名为Spline。Spline的组件结构为：</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174354.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>StaticMesh：使用Shape和自定义的材质，这个Mesh作为起点使用。</li>\n<li>Spline：样条线组件，此Actor的核心组件。</li>\n<li>Sphere：球型触发器，用于起点吸附。</li>\n</ul>\n<h2 id=\"2-在编辑模式下实现Spline编辑\"><a href=\"#2-在编辑模式下实现Spline编辑\" class=\"headerlink\" title=\"2.在编辑模式下实现Spline编辑\"></a>2.在编辑模式下实现Spline编辑</h2><p>在编辑模式下实现样条线的编辑需要在构造函数中实现下面的逻辑：</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174403.png\" alt=\"在这里插入图片描述\"></p>\n<p>核心函数分析：</p>\n<ul>\n<li><p>AddSplineMeshComponent：这是一个自定义的封装函数，作用就是提高复用率，</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174410.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n</ul>\n<p>  StaticMesh决定线的样式，Meterial决定线的颜色；</p>\n<ul>\n<li><p>AttachToMeshComponent：将添加的SplineMeshComponent组件设置StaticMesh为父节点；</p>\n</li>\n<li><p>Set Start and End：函数根据Get LocationandTangentatSplinePoint函数获取的起点和终点的位置和切角，将生成的SplineMeshComponent组件附着在上面。</p>\n</li>\n</ul>\n<p>这样我们的Spline样条线就被设置成了我们设定的模样，并且在运行时可见。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174417.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"3-运行时动态添加Spline的点\"><a href=\"#3-运行时动态添加Spline的点\" class=\"headerlink\" title=\"3.运行时动态添加Spline的点\"></a>3.运行时动态添加Spline的点</h2><p>由于在运行模式下无法像在编辑模式下通过Alt键拖动点来添加Spline的点，所以我们需要通过蓝图来实现。这项功能封装在AddPoint函数中。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174423.png\" alt=\"在这里插入图片描述\"></p>\n<p>AddPoint函数通过输入的坐标位置动态生成Spline的点</p>\n<ul>\n<li>AddSplinePoint：向Spline中添加新的点；</li>\n<li>SpawnActorPoint：目的是在Spline的生成的新点的位置处生成一个具象化的Point；</li>\n<li>Sequence的的Then0分支作用是当生成一个新的Point时，确定上一个Point的位置坐标；</li>\n<li>PointArray是一个Point类型的数组，用于存储生成的Point的引用，SplineMeshComponentArray是一个SplineMeshComponent类型的数组，用于存储生成的SplineMeshComponent组件的引用，两个数组的作用是方便之后对Point和SplineMeshComponent的操作。</li>\n<li>AddSplineMeshComponent、AttachToComponent和SetSartandEnd函数作用和构造函数中一样；</li>\n<li>UpddateTotaldistance函数用于更新距离显示，具体实现在后面介绍。</li>\n</ul>\n<p>AddPoint函数在AddPointEvent事件中调用。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174433.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>GetMouseLocation是FunLib库中的一个函数负责获取鼠标坐在的屏幕坐标转换成空间坐标。</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174439.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"4-实时更新样条线\"><a href=\"#4-实时更新样条线\" class=\"headerlink\" title=\"4.实时更新样条线\"></a>4.实时更新样条线</h2><p>实时更新样条线的功能封装在UpdateCurrentSplinePoint函数中。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174446.png\" alt=\"在这里插入图片描述\"></p>\n<p>UpdateCurrentSplinePoint函数在SplineActor的Tick函数中调用，每帧删除前一个Spline的点，在新的坐标位置下添加一个新的Spline的点，由于Point是跟随鼠标移动的，所以通过这个操作在宏观上的表现就是Spline的点在跟随鼠标一点，之所以使用这种方式，是因为Spline中的点似乎没办法直接修改位置。</p>\n<p>每帧设置好位置之后再重新渲染一遍Mesh组件，就达到如下效果了：</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174453.gif\" alt=\"在这里插入图片描述\"></p>\n<p>这样在运行状态下编辑Spline样条线就制作完成了。</p>\n<h1 id=\"四、实时更新距离\"><a href=\"#四、实时更新距离\" class=\"headerlink\" title=\"四、实时更新距离\"></a>四、实时更新距离</h1><p>实时更新距离的功能封装在UpdateTotalDistance函数下。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174502.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>Ranging变量就是Ranging类型，存储Ranging的引用，在重新计算总距离前先将存储中距离的变量TotalDistance清零；</li>\n<li>然后一次取PointArray中的Point来计算Point与Point之间的距离，0号索引的Point较为特殊需要与其他索引的Point分开计算，因为0号索引的Point需要与SplineActor的位置计算距离；</li>\n<li>ShowDistance函数封装在Point类中，负责将输入的距离显示出来。</li>\n</ul>\n<p>显示总距离专门创建了一个DistancePanel来显示。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174508.png\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180451.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>HiddenTotalDistance控制总距离是否显示。</li>\n</ul>\n<p>到这里基本的功能就基本实现了，下面实现一些必要的附加功能。</p>\n<h1 id=\"五、封装Ranging类\"><a href=\"#五、封装Ranging类\" class=\"headerlink\" title=\"五、封装Ranging类\"></a>五、封装Ranging类</h1><p>由于SplineActor类是插件的核心类，不宜对外开放调用接口，且SplineActor类自身拥有Mesh，直接拖入场景中会显示Mesh，效果不佳，所以在SplineActor之外再封装一成没有Mesh的Ranging是十分必要的，有Ranging类提供对外调用的接口。</p>\n<p>Ranging类的封装函数和变量：<br><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180459.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li><p>SetupRanging：启动测距，在鼠标所在位置生成SplineActor；</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180504.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n</ul>\n<ul>\n<li>AddPoint：封装SplineActor中的AddPointEvent事件；</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180511.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>EndRanging：结束测距，封装ActorSpline的DeleteLastPoint函数，函数的具体实现在之后介绍；</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180516.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li><p>Remove：删除所有的点线，封装SplineActor的RemoveAllPoint函数，函数的具体实现在之后介绍；</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180522.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n</ul>\n<ul>\n<li><p>SplineActor：存储SplineActor的引用；</p>\n</li>\n<li><p>TotalDistance：存储总距离的值；</p>\n</li>\n<li><p>DistanceUint：显示总距离时的单位；</p>\n</li>\n<li><p>K：存储SplineActor中DistancePanel随相机距离变化大小的变化倍率；我这里设定的值为0.0002。</p>\n</li>\n</ul>\n<p>文字随相机距离变化的函数实现封装在Ranging的UpdeteDistancePanelScale事件中，事件在Ranging的Tick函数中调用。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180542.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"六、保持Point的DistancePanel组件的大小不变\"><a href=\"#六、保持Point的DistancePanel组件的大小不变\" class=\"headerlink\" title=\"六、保持Point的DistancePanel组件的大小不变\"></a>六、保持Point的DistancePanel组件的大小不变</h1><p>为了保证观感效果，Point的显示距离的DistancePanel组件的大小应该跟随相机的远近保持保持一定的大小，以保证相机贴近地面时，文字不会过大，相机原理地面时文字不过过小而看不见。</p>\n<p>实现原理就在Ranging的UpdateDistancePanelScale事件中。</p>\n<h1 id=\"七、返回上一步功能\"><a href=\"#七、返回上一步功能\" class=\"headerlink\" title=\"七、返回上一步功能\"></a>七、返回上一步功能</h1><p>当我们确定点的位置时会出现位置确定错误的情况，所以返回上一步的功能也是十分必要的，具体实现在SplineActor的DeleteLastPoint函数中。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180550.png\" alt=\"在这里插入图片描述\"></p>\n<p>原理是移除上一个Spline的点和其匹配的Point、SplineMeshComponent并删除数组中对应的元素，然后更新一次距离，如果剩下最后一个点时，再撤回就直接将SplineActor删除并把显示总距离的DistancePanel移除，防止再创建SplineActor时再生成一个DiatancePanel而出现两个DistancePanel。</p>\n<h1 id=\"八、移除所有的点\"><a href=\"#八、移除所有的点\" class=\"headerlink\" title=\"八、移除所有的点\"></a>八、移除所有的点</h1><p>当测距完成后需要清除所有的点，所以此功能也是必要的，具体实现在SplineActor的RemoveAllPoint中。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180557.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"九、起点吸附功能\"><a href=\"#九、起点吸附功能\" class=\"headerlink\" title=\"九、起点吸附功能\"></a>九、起点吸附功能</h1><p>起点吸附是为了实现闭环。具体实现在SplineActor的EventActorBeginOverlap事件中。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180603.png\" alt=\"在这里插入图片描述\"></p>\n<p>原理就是当SplineActor的Sphere触发器检测到Point时将此Point的坐标设置到起点的坐标处。</p>\n<h1 id=\"九、整体效果预览\"><a href=\"#九、整体效果预览\" class=\"headerlink\" title=\"九、整体效果预览\"></a>九、整体效果预览</h1><p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180609.gif\" alt=\"在这里插入图片描述\"></p>\n","site":{"data":{}},"excerpt":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h1 id=\"基于Spline的测距功能插件\"><a href=\"#基于Spline的测距功能插件\" class=\"headerlink\" title=\"基于Spline的测距功能插件\"></a>基于Spline的测距功能插件</h1>","more":"<h1 id=\"一、功能分析\"><a href=\"#一、功能分析\" class=\"headerlink\" title=\"一、功能分析\"></a>一、功能分析</h1><p>这里首先分析一下整个插件的功能部件</p>\n<ul>\n<li><p>SplineActor—基于Spline的线条显示模块</p>\n</li>\n<li><p>Ranging—对整个插件功能的整体控制</p>\n</li>\n<li><p>DistancePanel—距离显示UI</p>\n</li>\n<li><p>Point—线上的点，集成DistancePanel</p>\n</li>\n<li><p>FunLib—高复用函数集合</p>\n<p>资产状况：</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174241.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n</ul>\n<p>由于使用屏幕坐标转世界坐标的方式实现测距功能可能及其复杂，所以这里使用比较直观简便的三维Spline来实现测距功能。</p>\n<h1 id=\"二、制作线上的点Point\"><a href=\"#二、制作线上的点Point\" class=\"headerlink\" title=\"二、制作线上的点Point\"></a>二、制作线上的点Point</h1><h2 id=\"1-Point的结构分析\"><a href=\"#1-Point的结构分析\" class=\"headerlink\" title=\"1.Point的结构分析\"></a>1.Point的结构分析</h2><p>Point是一个拥有StaticMesh和WedgitComponent组件的Actor，StaticMesh我这里使用Shape，Materials是自己做的一个发光材质。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174247.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"2-MeshMeterial材质\"><a href=\"#2-MeshMeterial材质\" class=\"headerlink\" title=\"2.MeshMeterial材质\"></a>2.MeshMeterial材质</h2><p>Materials蓝图：</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174258.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"3-Point核心函数实现\"><a href=\"#3-Point核心函数实现\" class=\"headerlink\" title=\"3.Point核心函数实现\"></a>3.Point核心函数实现</h2><p>Point主要实现一个函数两个事件</p>\n<ul>\n<li>函数ShowDistance—负责距离显示</li>\n<li>事件InitFontInfo—负责获取初始字体信息</li>\n<li>事件ShowText—控制距离是否显示</li>\n</ul>\n<p>在构造函数需要记录DistancePanel的初始位置信息和初始字体信息。</p>\n<p>ConstructScript：记录DistancePanel的初始位置信息和初始字体信息</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174305.png\" alt=\"在这里插入图片描述\"></p>\n<p>InitFontInfo：记录字体的初始信息</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174317.png\" alt=\"在这里插入图片描述\"></p>\n<p>ShowText：设置显示字体的大小。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174323.png\" alt=\"在这里插入图片描述\"></p>\n<p>Tick函数：SetActorRotation设置点上的文字跟随摄像机旋转使之始终面向摄像机，GetMouseLocation-&gt;SetActorLocation-&gt;ShowText当SureLocation为false时即未确定点的位置时设置点跟随鼠标移动，当点跟随鼠标移动时不显示距离。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174329.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>FontInfo：是一个SlateFontInfoStructure结构体用于设置距离显示的字体样式。</li>\n<li>SureLocation：bool变量，确认点是否已经确定了位置坐标，当点没有确定位置坐标时，点将跟随鼠标移动。</li>\n<li>InitScale3D：Vector变量，保存DistancePanel的初始大小。</li>\n<li>SureAdsorb：bool变量，控制闭环吸附，当为true时，起点具有吸附功能，可以将终点吸附到起点位置实现闭环。</li>\n</ul>\n<p>ShowDistance：将输入的距离信息显示出来。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174336.png\" alt=\"在这里插入图片描述\"></p>\n<p>至此点的设计完毕。</p>\n<h1 id=\"三、用于显示的Widget\"><a href=\"#三、用于显示的Widget\" class=\"headerlink\" title=\"三、用于显示的Widget\"></a>三、用于显示的Widget</h1><p>创建一个UserWidget命名为DistancePanel，DistancePanel比较简单，CanvasPanel下就一个Text即可，只有一个函数UpdateTextScale，然后在EventConstruct中记录Text的初始大小。</p>\n<p>EventConstruct：</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174342.png\" alt=\"在这里插入图片描述\"></p>\n<p>UpdateTextScale：更新Text的大小，使Text跟随摄像机距离地板的远近变大变小，以保证Text的大小在视野中保持不变。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174347.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"三、使用Spline制作线段\"><a href=\"#三、使用Spline制作线段\" class=\"headerlink\" title=\"三、使用Spline制作线段\"></a>三、使用Spline制作线段</h1><h2 id=\"1-SplineActor结构分析\"><a href=\"#1-SplineActor结构分析\" class=\"headerlink\" title=\"1.SplineActor结构分析\"></a>1.SplineActor结构分析</h2><p>Spline是UE4的样条线组件，Spline是一组点和线的集合，但是Spline的点和线只有在编辑模式下可见，在运行模式下不可见，Spline可以通过选中其中的点按下Alt键并拖动鼠标来添加新的点。</p>\n<p>我们需要一个Actor作为Spline的载体，创建一个Actor命名为Spline。Spline的组件结构为：</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174354.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>StaticMesh：使用Shape和自定义的材质，这个Mesh作为起点使用。</li>\n<li>Spline：样条线组件，此Actor的核心组件。</li>\n<li>Sphere：球型触发器，用于起点吸附。</li>\n</ul>\n<h2 id=\"2-在编辑模式下实现Spline编辑\"><a href=\"#2-在编辑模式下实现Spline编辑\" class=\"headerlink\" title=\"2.在编辑模式下实现Spline编辑\"></a>2.在编辑模式下实现Spline编辑</h2><p>在编辑模式下实现样条线的编辑需要在构造函数中实现下面的逻辑：</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174403.png\" alt=\"在这里插入图片描述\"></p>\n<p>核心函数分析：</p>\n<ul>\n<li><p>AddSplineMeshComponent：这是一个自定义的封装函数，作用就是提高复用率，</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174410.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n</ul>\n<p>  StaticMesh决定线的样式，Meterial决定线的颜色；</p>\n<ul>\n<li><p>AttachToMeshComponent：将添加的SplineMeshComponent组件设置StaticMesh为父节点；</p>\n</li>\n<li><p>Set Start and End：函数根据Get LocationandTangentatSplinePoint函数获取的起点和终点的位置和切角，将生成的SplineMeshComponent组件附着在上面。</p>\n</li>\n</ul>\n<p>这样我们的Spline样条线就被设置成了我们设定的模样，并且在运行时可见。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174417.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"3-运行时动态添加Spline的点\"><a href=\"#3-运行时动态添加Spline的点\" class=\"headerlink\" title=\"3.运行时动态添加Spline的点\"></a>3.运行时动态添加Spline的点</h2><p>由于在运行模式下无法像在编辑模式下通过Alt键拖动点来添加Spline的点，所以我们需要通过蓝图来实现。这项功能封装在AddPoint函数中。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174423.png\" alt=\"在这里插入图片描述\"></p>\n<p>AddPoint函数通过输入的坐标位置动态生成Spline的点</p>\n<ul>\n<li>AddSplinePoint：向Spline中添加新的点；</li>\n<li>SpawnActorPoint：目的是在Spline的生成的新点的位置处生成一个具象化的Point；</li>\n<li>Sequence的的Then0分支作用是当生成一个新的Point时，确定上一个Point的位置坐标；</li>\n<li>PointArray是一个Point类型的数组，用于存储生成的Point的引用，SplineMeshComponentArray是一个SplineMeshComponent类型的数组，用于存储生成的SplineMeshComponent组件的引用，两个数组的作用是方便之后对Point和SplineMeshComponent的操作。</li>\n<li>AddSplineMeshComponent、AttachToComponent和SetSartandEnd函数作用和构造函数中一样；</li>\n<li>UpddateTotaldistance函数用于更新距离显示，具体实现在后面介绍。</li>\n</ul>\n<p>AddPoint函数在AddPointEvent事件中调用。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174433.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>GetMouseLocation是FunLib库中的一个函数负责获取鼠标坐在的屏幕坐标转换成空间坐标。</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174439.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"4-实时更新样条线\"><a href=\"#4-实时更新样条线\" class=\"headerlink\" title=\"4.实时更新样条线\"></a>4.实时更新样条线</h2><p>实时更新样条线的功能封装在UpdateCurrentSplinePoint函数中。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174446.png\" alt=\"在这里插入图片描述\"></p>\n<p>UpdateCurrentSplinePoint函数在SplineActor的Tick函数中调用，每帧删除前一个Spline的点，在新的坐标位置下添加一个新的Spline的点，由于Point是跟随鼠标移动的，所以通过这个操作在宏观上的表现就是Spline的点在跟随鼠标一点，之所以使用这种方式，是因为Spline中的点似乎没办法直接修改位置。</p>\n<p>每帧设置好位置之后再重新渲染一遍Mesh组件，就达到如下效果了：</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174453.gif\" alt=\"在这里插入图片描述\"></p>\n<p>这样在运行状态下编辑Spline样条线就制作完成了。</p>\n<h1 id=\"四、实时更新距离\"><a href=\"#四、实时更新距离\" class=\"headerlink\" title=\"四、实时更新距离\"></a>四、实时更新距离</h1><p>实时更新距离的功能封装在UpdateTotalDistance函数下。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174502.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>Ranging变量就是Ranging类型，存储Ranging的引用，在重新计算总距离前先将存储中距离的变量TotalDistance清零；</li>\n<li>然后一次取PointArray中的Point来计算Point与Point之间的距离，0号索引的Point较为特殊需要与其他索引的Point分开计算，因为0号索引的Point需要与SplineActor的位置计算距离；</li>\n<li>ShowDistance函数封装在Point类中，负责将输入的距离显示出来。</li>\n</ul>\n<p>显示总距离专门创建了一个DistancePanel来显示。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174508.png\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180451.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>HiddenTotalDistance控制总距离是否显示。</li>\n</ul>\n<p>到这里基本的功能就基本实现了，下面实现一些必要的附加功能。</p>\n<h1 id=\"五、封装Ranging类\"><a href=\"#五、封装Ranging类\" class=\"headerlink\" title=\"五、封装Ranging类\"></a>五、封装Ranging类</h1><p>由于SplineActor类是插件的核心类，不宜对外开放调用接口，且SplineActor类自身拥有Mesh，直接拖入场景中会显示Mesh，效果不佳，所以在SplineActor之外再封装一成没有Mesh的Ranging是十分必要的，有Ranging类提供对外调用的接口。</p>\n<p>Ranging类的封装函数和变量：<br><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180459.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li><p>SetupRanging：启动测距，在鼠标所在位置生成SplineActor；</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180504.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n</ul>\n<ul>\n<li>AddPoint：封装SplineActor中的AddPointEvent事件；</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180511.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>EndRanging：结束测距，封装ActorSpline的DeleteLastPoint函数，函数的具体实现在之后介绍；</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180516.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li><p>Remove：删除所有的点线，封装SplineActor的RemoveAllPoint函数，函数的具体实现在之后介绍；</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180522.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n</ul>\n<ul>\n<li><p>SplineActor：存储SplineActor的引用；</p>\n</li>\n<li><p>TotalDistance：存储总距离的值；</p>\n</li>\n<li><p>DistanceUint：显示总距离时的单位；</p>\n</li>\n<li><p>K：存储SplineActor中DistancePanel随相机距离变化大小的变化倍率；我这里设定的值为0.0002。</p>\n</li>\n</ul>\n<p>文字随相机距离变化的函数实现封装在Ranging的UpdeteDistancePanelScale事件中，事件在Ranging的Tick函数中调用。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180542.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"六、保持Point的DistancePanel组件的大小不变\"><a href=\"#六、保持Point的DistancePanel组件的大小不变\" class=\"headerlink\" title=\"六、保持Point的DistancePanel组件的大小不变\"></a>六、保持Point的DistancePanel组件的大小不变</h1><p>为了保证观感效果，Point的显示距离的DistancePanel组件的大小应该跟随相机的远近保持保持一定的大小，以保证相机贴近地面时，文字不会过大，相机原理地面时文字不过过小而看不见。</p>\n<p>实现原理就在Ranging的UpdateDistancePanelScale事件中。</p>\n<h1 id=\"七、返回上一步功能\"><a href=\"#七、返回上一步功能\" class=\"headerlink\" title=\"七、返回上一步功能\"></a>七、返回上一步功能</h1><p>当我们确定点的位置时会出现位置确定错误的情况，所以返回上一步的功能也是十分必要的，具体实现在SplineActor的DeleteLastPoint函数中。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180550.png\" alt=\"在这里插入图片描述\"></p>\n<p>原理是移除上一个Spline的点和其匹配的Point、SplineMeshComponent并删除数组中对应的元素，然后更新一次距离，如果剩下最后一个点时，再撤回就直接将SplineActor删除并把显示总距离的DistancePanel移除，防止再创建SplineActor时再生成一个DiatancePanel而出现两个DistancePanel。</p>\n<h1 id=\"八、移除所有的点\"><a href=\"#八、移除所有的点\" class=\"headerlink\" title=\"八、移除所有的点\"></a>八、移除所有的点</h1><p>当测距完成后需要清除所有的点，所以此功能也是必要的，具体实现在SplineActor的RemoveAllPoint中。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180557.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"九、起点吸附功能\"><a href=\"#九、起点吸附功能\" class=\"headerlink\" title=\"九、起点吸附功能\"></a>九、起点吸附功能</h1><p>起点吸附是为了实现闭环。具体实现在SplineActor的EventActorBeginOverlap事件中。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180603.png\" alt=\"在这里插入图片描述\"></p>\n<p>原理就是当SplineActor的Sphere触发器检测到Point时将此Point的坐标设置到起点的坐标处。</p>\n<h1 id=\"九、整体效果预览\"><a href=\"#九、整体效果预览\" class=\"headerlink\" title=\"九、整体效果预览\"></a>九、整体效果预览</h1><p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180609.gif\" alt=\"在这里插入图片描述\"></p>"},{"title":"【UE4】UE4实现自定义框选","date":"2021-05-14T09:41:51.000Z","password":null,"abstract":null,"message":null,"_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n要在UE4中实现自定义框选功能，首先我们来分析一下顶顶一框选插件需要些什么模块？\n\n- 绘制模块\n- 显示模块\n- 计算模块\n\n嗯，大概分这么三个模块，好，现在我们一个个模块来分析实现。首先分析实现一下显示模块。\n\n<!--more-->\n\n<font color=green>提示：</font>\n\n<font color=green>如果功能需要打包成插件，请先浏览第四章</font>\n\n# 一、显示模块\n\n首先我们需要做一些准备\n\n## 1.创建Wedgit作为显示载体\n\nUE4绘制直线的方式很多，这里我使用DrawLine在RenderTarget里绘制，绘制的实现放在后面说。\n\n然后我们需要让自定义框选的线显示在屏幕上，那么使用`wedgit`来显示是比较理想的，所以我们来创建一个widget，命名为`CustomSelectUI`，并为CustomSelectUI添加一个`image`作为显示的载体，命名为Background。\n\n## 2.创建Material作为RenderTarget的显示载体\n\n光一个image也是无法显示我们绘制的线的，因为我们的线是画在RenderTarget里的，而image没法直接使用RenderTarget，所以我们还需要创建一个Material来承载RenderTarget。这里创建一个Material命名为Mat_Paint。\n\n## 3.为Material创建一个Texture\n\n创建的Texture是有讲究的，Texture必须是存黑色的即RPG(0,0,0)，然后分辨率可自定义。这里我使用PS制作了一个纯黑的PNG图片，并设置分辨率为2048x2048，并导入到UE4生成Texture，并命名为Mat_Transparent_Max。\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180719.png)\n\n使用纯黑色的原因在第四小节说明。\n\n## 4.实现Material的作用\n\nMaterial出来作为RenerTarget的载体外，还有设置笔刷的颜色，以及使背景透明的作用。\n\n先来看一下Mat_Paint的蓝图\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180725.png)\n\n首先将Mat_Paint节点的`Details/Material/Material Domain`更换为User Interface，即将Material改为Material Interface。\n\n并未Mat_Paint添加一个Texture，将之前创建的Mat_Transparent_Max拖入Mat_Paint中，右键节点选择Convert to Parameter将节点参数化，并取名`RT_Texture`，这是为了后面动态设置做的准备。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180731.png)\n\n然后将RT_Texture连接到Mat_Paint中的Opacity上，Opacity节点是Material控制材质透明度的接口，在Opacity中RGB(0,0,0)表示全透明，RGB(1,1,1)表示不透明，即纯黑色表示全透明，纯白色表示不透明，这就是为什么我们需要一张纯黑色的Texture的原因。因为我们需要一个透明的材质赋予image这样我们才能看到Wedgit后面的场景，使场景不会被我们的image遮挡。\n\n然后创建一个Constant3Vector，并且也将其参数化，命名为PaintColor，这为之后修改画笔颜色预留接口。将PaintColor连接到Mat_Paint的Final Color上。Final Color接口控制着材质最终显示的颜色。\n\n到这里，擦材质我们就做好了。\n\n## 5.显示\n\n这里我在CustomSelectUI构造时为Background添加Mat_Paint动态材质。我们来看一下蓝图\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180738.png)\n\n- RenderMat变量是Material Instance Dynamic类型用于存储动态创建的Mat_Paint，方便之后使用；\n- LineLinearColor变量是LinearColor类型，用于设置画笔颜色\n\n到这里显示部分就完成了。\n\n# 二、绘制模块\n\n## 1.获取鼠标在屏幕中的位置坐标\n\n线的绘制我使用DrawLine函数根据鼠标点击的点来绘制点与点之间的直线，绘制模块最终要的两个步骤就是获取鼠标点击的屏幕上的点和根据点集绘制多边形。\n\n实现获取鼠标在屏幕上的位置，这里我们需要重写两个函数，OnMouseButtonUp和OnMouseButtonDown,我们来看一下蓝图。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180748.png)\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180754.png)\n\n- MouseDown用于标识鼠标的按下与抬起，true表示按下，false表示抬起。\n\n- Setup控制是否开始绘制。\n\n- IsFirstPoint标识第一个点与其余点。\n- PolygonPoints是存储鼠标点击的点的数组，启动绘制之后鼠标每点击一次变向数组中添加一个Vector2D元素。\n- CurrentPoint存储鼠标当前点击的屏幕坐标。\n- StartPoint存储绘制直线的起点的屏幕坐标。\n- MousePositionAdaptDPI是自己封装的获取鼠标屏幕坐标的函数，之所以封装是为例修改方便。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180801.png)\n\n到此，获取鼠标的屏幕坐标就实现了，接下来要根据鼠标点击确定的点集PolygonPoints绘制直线。\n\n## 2.绘制直线\n\n再绘制直线之前，需要做一些准备工作，即创建直线绘制的载体RenderTarget并用之前创建好的RenderMat承载，然后将RenderMat绑定到Background上显示。这里我绑定到Setup按钮的OnClicked事件下。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180807.png)\n\n- CreateCanvasRenderTarget2D函数负责创建RenderTarget，RenderTarget可以直接使用引擎默认的，也可以自己创建自定义的，这里我使用引擎默认的。\n\n  ![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180812.png)\n\n  Width和Height控制着RenderTarget的长宽比例，超出这个比例的部分屏幕将无法绘制，如：\n\n  ![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180820.png)\n\n  红框部分的屏幕比例就是1920：1080，超出着部分的屏幕将无法绘制，当然在全屏运行的情况下不会出现这种问题。出现这个问题是因为我的计算机屏幕尺寸就是1920：1080，运行时，UE4的实际运行窗口是蓝色部分，很明显由于windows菜单栏和UE运行窗口的菜单栏占据了屏幕的部分像素，所以UE的实际运行窗口是蓝色部分，其比例显然不是1920：1080，所以超出部分就没办法绘制了。这个RenderTarget的比例可以根据自己的实际需求更改。\n\n- SetupCustomSelect函数负责绘制的启动与关闭\n\n ![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180828.png)\n准备工作结束后便可以开始绘制直线了，直线的绘制放在Tick函数下，每帧绘制。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180834.png)\n\n- LineThickness控制直线绘制时的粗细程度。\n\n- StartPaint是具体的直线绘制函数。\n\n  ![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180840.png)\n\n  其中RenderColor必须设置纯白色，只有这样绘制出来的直线才是不透明的。\n\n<font color=red>绘制直线这里有一点需要注意，即需要设置我们Background的锚点为左上角，因为RenderTarget的原点在左上角，只有这样鼠标点击的位置才会和绘制的位置匹配，否则会出现位置偏移的问题。</font>\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180848.png)\n\n## 3.清除绘制内容\n\n考虑到会有绘制出错的情况，所以添加一个清除绘制内容的功能。清除绘制内容原理比较简单，只需要清除RenderTarget缓存和PolygonPoints点击即可。\n\n这里我绑定在Delete按钮的OnClicked事件下。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180854.png)\n\n## 4.结束绘制\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180859.png)\n\n结束绘制之后就要开始计算框选内容了，SureSelect函数负责这方面的实现，计算后面讲解。\n\n结束绘制之后需要将最后一个点和第一个点连接来，确保多边形是一个封闭的多边形。EndPaint函数负责这个功能的实现。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180904.png)\n\n# 三、计算\n\n计算这里需要用到C++了，在蓝图的SureSelect函数里调用C++的计算函数。\n\n创建一个继承自Actor的C++类，并命名为CustomSelectActor，下面贴出C++源码：\n\n`.h`\n\n```c++\n#pragma once\n\n#define LeastPointNum 4\n#define ActorSamplingPoints 9\n\n#include \"Runtime/Engine/Classes/Kismet/GameplayStatics.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n#include \"EngineUtils.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CustomSelectActor.generated.h\"\n\nUSTRUCT()\nstruct FBoxPointSet\n{\n\tGENERATED_USTRUCT_BODY()\npublic:\n\tTArray<FVector2D> points;\n\tFBoxPointSet()\n\t{\n\t\tpoints.Init(FVector2D(0, 0), 9);\n\t}\n};\n\nUCLASS()\nclass CUSTOMSELECT_API ACustomSelectActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tconst FVector BoundsPointMapping[8] =\n\t{\n\t\tFVector(1, 1, 1),\n\t\tFVector(1, 1, -1),\n\t\tFVector(1, -1, 1),\n\t\tFVector(1, -1, -1),\n\t\tFVector(-1, 1, 1),\n\t\tFVector(-1, 1, -1),\n\t\tFVector(-1, -1, 1),\n\t\tFVector(-1, -1, -1)\n\t};\n\nprotected:\n\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tACustomSelectActor();\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvoid GetMax(TArray<FVector2D>& points, float& max_x, float& max_y, int& len);\n\tvoid GetMin(TArray<FVector2D>& points, float& min_x, float& min_y, int& len);\n\tvoid SpwanVertArr(TArray<FVector2D>& polygonPoints, TArray<float>& vertx, TArray<float>& verty, int& len);\n\tbool PNPoly(int nvert, TArray<float> vertx, TArray<float> verty, float testx, float testy);\n\tUFUNCTION(BlueprintImplementableEvent)\n\tbool ProjectWorldLocationToWidgetPosition(APlayerController* player_ctrl, FVector worldLocation, FVector2D& screenPosition);\n\tvoid GetFBoxPointsSet(\n\t\tTArray<FBoxPointSet>& fboxPointsArr,\n\t\tTArray<AActor*>& actorArr,\n\t\tTSubclassOf<AActor>& classFilter,\n\t\tbool& bIncludeNonCollidingComponents,\n\t\tAPlayerController* player_ctrl);\n\tvoid GetActorsRefByPointsSet(\n\t\tTArray<AActor*>& outActors,\n\t\tTArray<float>& vertx,\n\t\tTArray<float>& verty,\n\t\tTArray<FBoxPointSet>& fboxPointsArr,\n\t\tTArray<AActor*>& actorArr,\n\t\tTArray<FVector2D>& polygonPoints,\n\t\tint& len);\n\tUFUNCTION(BlueprintCallable, Category = \"CustomSelect\")\n\tbool CustomSelect(\n\t\tTArray<AActor*>& outActors,\n\t\tTArray<FVector2D> polygonPoints,\n\t\tTSubclassOf<AActor> classFilter,\n\t\tAPlayerController * player_ctrl,\n\t\tbool bIncludeNonCollidingComponents);\n\tUFUNCTION(BlueprintCallable, Category = \"CustomSelect\")\n\tfloat CompuePolygonArea(const TArray<FVector2D> polygonPoints);\n};\n\n```\n\n`.cpp`\n\n```c++\n#include \"CustomSelectActor.h\"\n\nACustomSelectActor::ACustomSelectActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n}\n\nvoid ACustomSelectActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\nvoid ACustomSelectActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\nvoid ACustomSelectActor::GetMax(TArray<FVector2D>& points, float& max_x, float& max_y, int& len)\n{\n\tmax_x = points[0].X;\n\tmax_y = points[0].Y;\n\tfor (int i = 1; i < len; i++)\n\t{\n\t\tif (max_x < points[i].X)\n\t\t{\n\t\t\tmax_x = points[i].X;\n\t\t}\n\t\tif (max_y < points[i].Y)\n\t\t{\n\t\t\tmax_y = points[i].Y;\n\t\t}\n\t}\n}\n\nvoid ACustomSelectActor::GetMin(TArray<FVector2D>& points, float& min_x, float& min_y, int& len)\n{\n\tmin_x = points[0].X;\n\tmin_y = points[0].Y;\n\tfor (int i = 1; i < len; i++)\n\t{\n\t\tif (min_x > points[i].X)\n\t\t{\n\t\t\tmin_x = points[i].X;\n\t\t}\n\t\tif (min_y > points[i].Y)\n\t\t{\n\t\t\tmin_y = points[i].Y;\n\t\t}\n\t}\n}\n\nvoid ACustomSelectActor::SpwanVertArr(TArray<FVector2D>& polygonPoints, TArray<float>& vertx, TArray<float>& verty, int& len)\n{\n\tfor (int i = 0; i < len; i++)\n\t{\n\t\tvertx.Add(polygonPoints[i].X);\n\t\tverty.Add(polygonPoints[i].Y);\n\t}\n}\n\nbool ACustomSelectActor::PNPoly(int nvert, TArray<float> vertx, TArray<float> verty, float testx, float testy)\n{\n\tbool ret = false;\n\tfor (int i = 0, j = nvert - 1; i < nvert; j = i++)\n\t{\n\t\tif (((verty[i] > testy) != (verty[j] > testy)) && (testx < (vertx[j] - vertx[i]) * (testy - verty[i]) / (verty[j] - verty[i]) + vertx[i]))\n\t\t{\n\t\t\tret = !ret;\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid ACustomSelectActor::GetFBoxPointsSet(\n\tTArray<FBoxPointSet>& fboxPointsArr,\n\tTArray<AActor*>& actorArr,\n\tTSubclassOf<AActor>& classFilter,\n\tbool& bIncludeNonCollidingComponents,\n\tAPlayerController * player_ctrl)\n{\n\tint i = 0;\n\tfor (TActorIterator<AActor> Itr(GWorld->GetWorld(), classFilter); Itr; ++Itr)\n\t{\n\t\tAActor* EachActor = *Itr;\n\t\tconst FBox EachActorBounds = Cast<AActor>(EachActor)->GetComponentsBoundingBox(bIncludeNonCollidingComponents);\n\t\tconst FVector BoxCenter = EachActorBounds.GetCenter();\n\t\tconst FVector BoxExtents = EachActorBounds.GetExtent();\n\t\tFBox2D ActorBox2D(ForceInit);\n\t\tfboxPointsArr.Add(FBoxPointSet());\n\t\tfor (uint8 BoundsPointItr = 0; BoundsPointItr < 8; BoundsPointItr++)\n\t\t{\n\t\t\tFVector2D ScreenPos;\n\t\t\tif (ProjectWorldLocationToWidgetPosition(player_ctrl, BoxCenter + (BoundsPointMapping[BoundsPointItr] * BoxExtents), ScreenPos))\n\t\t\t{\n\t\t\t\tActorBox2D += ScreenPos;\n\t\t\t\tfboxPointsArr[i].points[BoundsPointItr + 1] = ScreenPos;\n\t\t\t}\n\t\t}\n\t\tfboxPointsArr[i].points[0] = ActorBox2D.GetCenter();\n\t\tactorArr.Add(EachActor);\n\t\ti++;\n\t}\n}\n\nvoid ACustomSelectActor::GetActorsRefByPointsSet(\n\tTArray<AActor*>& outActors,\n\tTArray<float>& vertx,\n\tTArray<float>& verty,\n\tTArray<FBoxPointSet>& fboxPointsArr,\n\tTArray<AActor*>& actorArr,\n\tTArray<FVector2D>& polygonPoints,\n\tint& len)\n{\n\tint fboxlen = fboxPointsArr.Num();\n\tint pointslen = polygonPoints.Num();\n\tfloat max_x = 0;\n\tfloat max_y = 0;\n\tfloat min_x = 0;\n\tfloat min_y = 0;\n\tGetMax(polygonPoints, max_x, max_y, len);\n\tGetMin(polygonPoints, min_x, min_y, len);\n\tfor (int i = 0; i < fboxlen; i++)\n\t{\n\t\tfor (int j = 0; j < ActorSamplingPoints; j++)\n\t\t{\n\t\t\tif (fboxPointsArr[i].points[j].X<min_x || fboxPointsArr[i].points[j].X>max_x ||\n\t\t\t\tfboxPointsArr[i].points[j].Y<min_y || fboxPointsArr[i].points[j].Y>max_y)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t\tj = ActorSamplingPoints;\n\t\t\t}\n\t\t\tif (PNPoly(len, vertx, verty, fboxPointsArr[i].points[j].X, fboxPointsArr[i].points[j].Y))\n\t\t\t{\n\t\t\t\toutActors.Add(actorArr[i]);\n\t\t\t\tj = ActorSamplingPoints;\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool ACustomSelectActor::CustomSelect(\n\tTArray<AActor*>& outActors,\n\tTArray<FVector2D> polygonPoints,\n\tTSubclassOf<AActor> classFilter,\n\tAPlayerController * player_ctrl,\n\tbool bIncludeNonCollidingComponents)\n{\n\tint len = polygonPoints.Num();\n\tif (len < LeastPointNum)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Polygon has too few points\"));\n\t\treturn false;\n\t}\n\tTArray<float> vertx;\n\tTArray<float> verty;\n\tSpwanVertArr(polygonPoints, vertx, verty, len);\n\tTArray<AActor*> actorArr;\n\tTArray<FBoxPointSet> fboxPointsArr;\n\tGetFBoxPointsSet(fboxPointsArr, actorArr, classFilter, bIncludeNonCollidingComponents, player_ctrl);\n\tGetActorsRefByPointsSet(outActors, vertx, verty, fboxPointsArr, actorArr, polygonPoints, len);\n\treturn true;\n}\n\nfloat ACustomSelectActor::CompuePolygonArea(const TArray<FVector2D> polygonPoints)\n{\n\tint point_num = polygonPoints.Num();\n\tif (point_num < 3)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"The area is not polygon!\"));\n\t\treturn 0.0;\n\t}\n\tdouble s = polygonPoints[0].Y * (polygonPoints[point_num - 1].X - polygonPoints[1].X);\n\tfor (int i = 1; i < point_num; ++i)\n\t\ts += polygonPoints[i].Y * (polygonPoints[i - 1].X - polygonPoints[(i + 1) % point_num].X);\n\treturn fabs(s / 2.0);\n}\n\n```\n\n- `BoundsPointMapping[8]`用于确定场景中Actor的边界盒子的8个点。\n\n- 结构体FBoxPointSet是用来存储采样点集的数据结构，这里我取Actor边界盒子的8个点加中点一共9个点作为采样点集。\n\n- GetMax和GetMin计算多边形点集的横纵坐标的最大值和最小值。\n\n- SpawnVertArr负责将多边形点集分成横坐标点集和纵坐标点集。\n\n- PNPoly函数使用PNPoly算法判断一个点是否在多边形内部。\n\n- ProjectWorldLocationToWidgetPosition函数是一个由C++父类声明，由蓝图子类实现的函数，负责将场景中的Actor的边界盒子的点的空间坐标投影到屏幕坐标。之所以使用这种方式是因为ProjectWorldLocationToWidgetPosition蓝图节点没有C++版本，而必须使用ProjectWorldLocationToWidgetPosition蓝图节点的原因是ProjectWorldLocationToWidgetPosition蓝图节点投影出来的坐标会根据屏幕尺寸变化而自动适应，其他的空间坐标转屏幕坐标的蓝图节点在非全屏与全屏下会出现位置偏移。\n\n  ![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180923.png)\n  所以这里需要创建一个继承自CustomSelectActor的蓝图子类来重写ProjectWorldLocationToWidgetPosition函数。\n\n- GetFBoxPointsSet函数负责获取世界中所有Actor的采样点集。\n\n- GetActorsRefByPointsSet函数负责使用PNPoly函数取在多边形内部的Actor的引用。\n\n- CustomSelect函数否则暴漏给蓝图提供数据输入输出的接口。\n\n- CompuePolygonArea函数负责计算多边形的面积，目前还有一些问题，暂时不用理睬。\n\n至此多边形框选功能就完全实现了。来看一下效果：\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180929.png)\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180935.png)\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180942.png)\n\n\n# 四、将功能包成UE4插件\n\n如果需要将功能打包成插件，那么就需要将CustomSelectActor的C++类创建在插件里。\n\n## 1.创建一个空插件\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180952.png)\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180958.png)\n\n创建之后需要在VS中编一下项目，然后关闭引擎，重新打开项目，以便引擎重新加载dll文件，因为插件不属于引擎的一部分，所以引擎没办法直接热加载插件内容。\n\n## 2.在插件文件夹下创建C++类\n\n我们需要将CustomSelectActor类创建在插件文件夹下，创建好空插件后，再创建C++类时可以选择创建文件夹。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514181004.png)\n然后按一、二、三的步骤实现功能即可。\n\n## 3.打包插件\n\n进入插件管理点集打包\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514181009.png)\n至此插件就打包好了。\n\n参考博客：\nhttps://blog.csdn.net/weixin_36369675/article/details/88419361\nhttps://www.cnblogs.com/anningwang/p/7581545.html\nhttps://www.cnblogs.com/TenosDoIt/p/4047211.html","source":"_posts/【UE4】UE4实现自定义框选.md","raw":"---\ntitle: 【UE4】UE4实现自定义框选\ndate: 2021-05-14 17:41:51\ntags: UE4\ncategories: 知识记录\npassword:\nabstract:\nmessage:\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n要在UE4中实现自定义框选功能，首先我们来分析一下顶顶一框选插件需要些什么模块？\n\n- 绘制模块\n- 显示模块\n- 计算模块\n\n嗯，大概分这么三个模块，好，现在我们一个个模块来分析实现。首先分析实现一下显示模块。\n\n<!--more-->\n\n<font color=green>提示：</font>\n\n<font color=green>如果功能需要打包成插件，请先浏览第四章</font>\n\n# 一、显示模块\n\n首先我们需要做一些准备\n\n## 1.创建Wedgit作为显示载体\n\nUE4绘制直线的方式很多，这里我使用DrawLine在RenderTarget里绘制，绘制的实现放在后面说。\n\n然后我们需要让自定义框选的线显示在屏幕上，那么使用`wedgit`来显示是比较理想的，所以我们来创建一个widget，命名为`CustomSelectUI`，并为CustomSelectUI添加一个`image`作为显示的载体，命名为Background。\n\n## 2.创建Material作为RenderTarget的显示载体\n\n光一个image也是无法显示我们绘制的线的，因为我们的线是画在RenderTarget里的，而image没法直接使用RenderTarget，所以我们还需要创建一个Material来承载RenderTarget。这里创建一个Material命名为Mat_Paint。\n\n## 3.为Material创建一个Texture\n\n创建的Texture是有讲究的，Texture必须是存黑色的即RPG(0,0,0)，然后分辨率可自定义。这里我使用PS制作了一个纯黑的PNG图片，并设置分辨率为2048x2048，并导入到UE4生成Texture，并命名为Mat_Transparent_Max。\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180719.png)\n\n使用纯黑色的原因在第四小节说明。\n\n## 4.实现Material的作用\n\nMaterial出来作为RenerTarget的载体外，还有设置笔刷的颜色，以及使背景透明的作用。\n\n先来看一下Mat_Paint的蓝图\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180725.png)\n\n首先将Mat_Paint节点的`Details/Material/Material Domain`更换为User Interface，即将Material改为Material Interface。\n\n并未Mat_Paint添加一个Texture，将之前创建的Mat_Transparent_Max拖入Mat_Paint中，右键节点选择Convert to Parameter将节点参数化，并取名`RT_Texture`，这是为了后面动态设置做的准备。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180731.png)\n\n然后将RT_Texture连接到Mat_Paint中的Opacity上，Opacity节点是Material控制材质透明度的接口，在Opacity中RGB(0,0,0)表示全透明，RGB(1,1,1)表示不透明，即纯黑色表示全透明，纯白色表示不透明，这就是为什么我们需要一张纯黑色的Texture的原因。因为我们需要一个透明的材质赋予image这样我们才能看到Wedgit后面的场景，使场景不会被我们的image遮挡。\n\n然后创建一个Constant3Vector，并且也将其参数化，命名为PaintColor，这为之后修改画笔颜色预留接口。将PaintColor连接到Mat_Paint的Final Color上。Final Color接口控制着材质最终显示的颜色。\n\n到这里，擦材质我们就做好了。\n\n## 5.显示\n\n这里我在CustomSelectUI构造时为Background添加Mat_Paint动态材质。我们来看一下蓝图\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180738.png)\n\n- RenderMat变量是Material Instance Dynamic类型用于存储动态创建的Mat_Paint，方便之后使用；\n- LineLinearColor变量是LinearColor类型，用于设置画笔颜色\n\n到这里显示部分就完成了。\n\n# 二、绘制模块\n\n## 1.获取鼠标在屏幕中的位置坐标\n\n线的绘制我使用DrawLine函数根据鼠标点击的点来绘制点与点之间的直线，绘制模块最终要的两个步骤就是获取鼠标点击的屏幕上的点和根据点集绘制多边形。\n\n实现获取鼠标在屏幕上的位置，这里我们需要重写两个函数，OnMouseButtonUp和OnMouseButtonDown,我们来看一下蓝图。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180748.png)\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180754.png)\n\n- MouseDown用于标识鼠标的按下与抬起，true表示按下，false表示抬起。\n\n- Setup控制是否开始绘制。\n\n- IsFirstPoint标识第一个点与其余点。\n- PolygonPoints是存储鼠标点击的点的数组，启动绘制之后鼠标每点击一次变向数组中添加一个Vector2D元素。\n- CurrentPoint存储鼠标当前点击的屏幕坐标。\n- StartPoint存储绘制直线的起点的屏幕坐标。\n- MousePositionAdaptDPI是自己封装的获取鼠标屏幕坐标的函数，之所以封装是为例修改方便。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180801.png)\n\n到此，获取鼠标的屏幕坐标就实现了，接下来要根据鼠标点击确定的点集PolygonPoints绘制直线。\n\n## 2.绘制直线\n\n再绘制直线之前，需要做一些准备工作，即创建直线绘制的载体RenderTarget并用之前创建好的RenderMat承载，然后将RenderMat绑定到Background上显示。这里我绑定到Setup按钮的OnClicked事件下。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180807.png)\n\n- CreateCanvasRenderTarget2D函数负责创建RenderTarget，RenderTarget可以直接使用引擎默认的，也可以自己创建自定义的，这里我使用引擎默认的。\n\n  ![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180812.png)\n\n  Width和Height控制着RenderTarget的长宽比例，超出这个比例的部分屏幕将无法绘制，如：\n\n  ![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180820.png)\n\n  红框部分的屏幕比例就是1920：1080，超出着部分的屏幕将无法绘制，当然在全屏运行的情况下不会出现这种问题。出现这个问题是因为我的计算机屏幕尺寸就是1920：1080，运行时，UE4的实际运行窗口是蓝色部分，很明显由于windows菜单栏和UE运行窗口的菜单栏占据了屏幕的部分像素，所以UE的实际运行窗口是蓝色部分，其比例显然不是1920：1080，所以超出部分就没办法绘制了。这个RenderTarget的比例可以根据自己的实际需求更改。\n\n- SetupCustomSelect函数负责绘制的启动与关闭\n\n ![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180828.png)\n准备工作结束后便可以开始绘制直线了，直线的绘制放在Tick函数下，每帧绘制。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180834.png)\n\n- LineThickness控制直线绘制时的粗细程度。\n\n- StartPaint是具体的直线绘制函数。\n\n  ![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180840.png)\n\n  其中RenderColor必须设置纯白色，只有这样绘制出来的直线才是不透明的。\n\n<font color=red>绘制直线这里有一点需要注意，即需要设置我们Background的锚点为左上角，因为RenderTarget的原点在左上角，只有这样鼠标点击的位置才会和绘制的位置匹配，否则会出现位置偏移的问题。</font>\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180848.png)\n\n## 3.清除绘制内容\n\n考虑到会有绘制出错的情况，所以添加一个清除绘制内容的功能。清除绘制内容原理比较简单，只需要清除RenderTarget缓存和PolygonPoints点击即可。\n\n这里我绑定在Delete按钮的OnClicked事件下。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180854.png)\n\n## 4.结束绘制\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180859.png)\n\n结束绘制之后就要开始计算框选内容了，SureSelect函数负责这方面的实现，计算后面讲解。\n\n结束绘制之后需要将最后一个点和第一个点连接来，确保多边形是一个封闭的多边形。EndPaint函数负责这个功能的实现。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180904.png)\n\n# 三、计算\n\n计算这里需要用到C++了，在蓝图的SureSelect函数里调用C++的计算函数。\n\n创建一个继承自Actor的C++类，并命名为CustomSelectActor，下面贴出C++源码：\n\n`.h`\n\n```c++\n#pragma once\n\n#define LeastPointNum 4\n#define ActorSamplingPoints 9\n\n#include \"Runtime/Engine/Classes/Kismet/GameplayStatics.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n#include \"EngineUtils.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CustomSelectActor.generated.h\"\n\nUSTRUCT()\nstruct FBoxPointSet\n{\n\tGENERATED_USTRUCT_BODY()\npublic:\n\tTArray<FVector2D> points;\n\tFBoxPointSet()\n\t{\n\t\tpoints.Init(FVector2D(0, 0), 9);\n\t}\n};\n\nUCLASS()\nclass CUSTOMSELECT_API ACustomSelectActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tconst FVector BoundsPointMapping[8] =\n\t{\n\t\tFVector(1, 1, 1),\n\t\tFVector(1, 1, -1),\n\t\tFVector(1, -1, 1),\n\t\tFVector(1, -1, -1),\n\t\tFVector(-1, 1, 1),\n\t\tFVector(-1, 1, -1),\n\t\tFVector(-1, -1, 1),\n\t\tFVector(-1, -1, -1)\n\t};\n\nprotected:\n\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tACustomSelectActor();\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvoid GetMax(TArray<FVector2D>& points, float& max_x, float& max_y, int& len);\n\tvoid GetMin(TArray<FVector2D>& points, float& min_x, float& min_y, int& len);\n\tvoid SpwanVertArr(TArray<FVector2D>& polygonPoints, TArray<float>& vertx, TArray<float>& verty, int& len);\n\tbool PNPoly(int nvert, TArray<float> vertx, TArray<float> verty, float testx, float testy);\n\tUFUNCTION(BlueprintImplementableEvent)\n\tbool ProjectWorldLocationToWidgetPosition(APlayerController* player_ctrl, FVector worldLocation, FVector2D& screenPosition);\n\tvoid GetFBoxPointsSet(\n\t\tTArray<FBoxPointSet>& fboxPointsArr,\n\t\tTArray<AActor*>& actorArr,\n\t\tTSubclassOf<AActor>& classFilter,\n\t\tbool& bIncludeNonCollidingComponents,\n\t\tAPlayerController* player_ctrl);\n\tvoid GetActorsRefByPointsSet(\n\t\tTArray<AActor*>& outActors,\n\t\tTArray<float>& vertx,\n\t\tTArray<float>& verty,\n\t\tTArray<FBoxPointSet>& fboxPointsArr,\n\t\tTArray<AActor*>& actorArr,\n\t\tTArray<FVector2D>& polygonPoints,\n\t\tint& len);\n\tUFUNCTION(BlueprintCallable, Category = \"CustomSelect\")\n\tbool CustomSelect(\n\t\tTArray<AActor*>& outActors,\n\t\tTArray<FVector2D> polygonPoints,\n\t\tTSubclassOf<AActor> classFilter,\n\t\tAPlayerController * player_ctrl,\n\t\tbool bIncludeNonCollidingComponents);\n\tUFUNCTION(BlueprintCallable, Category = \"CustomSelect\")\n\tfloat CompuePolygonArea(const TArray<FVector2D> polygonPoints);\n};\n\n```\n\n`.cpp`\n\n```c++\n#include \"CustomSelectActor.h\"\n\nACustomSelectActor::ACustomSelectActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n}\n\nvoid ACustomSelectActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\nvoid ACustomSelectActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\nvoid ACustomSelectActor::GetMax(TArray<FVector2D>& points, float& max_x, float& max_y, int& len)\n{\n\tmax_x = points[0].X;\n\tmax_y = points[0].Y;\n\tfor (int i = 1; i < len; i++)\n\t{\n\t\tif (max_x < points[i].X)\n\t\t{\n\t\t\tmax_x = points[i].X;\n\t\t}\n\t\tif (max_y < points[i].Y)\n\t\t{\n\t\t\tmax_y = points[i].Y;\n\t\t}\n\t}\n}\n\nvoid ACustomSelectActor::GetMin(TArray<FVector2D>& points, float& min_x, float& min_y, int& len)\n{\n\tmin_x = points[0].X;\n\tmin_y = points[0].Y;\n\tfor (int i = 1; i < len; i++)\n\t{\n\t\tif (min_x > points[i].X)\n\t\t{\n\t\t\tmin_x = points[i].X;\n\t\t}\n\t\tif (min_y > points[i].Y)\n\t\t{\n\t\t\tmin_y = points[i].Y;\n\t\t}\n\t}\n}\n\nvoid ACustomSelectActor::SpwanVertArr(TArray<FVector2D>& polygonPoints, TArray<float>& vertx, TArray<float>& verty, int& len)\n{\n\tfor (int i = 0; i < len; i++)\n\t{\n\t\tvertx.Add(polygonPoints[i].X);\n\t\tverty.Add(polygonPoints[i].Y);\n\t}\n}\n\nbool ACustomSelectActor::PNPoly(int nvert, TArray<float> vertx, TArray<float> verty, float testx, float testy)\n{\n\tbool ret = false;\n\tfor (int i = 0, j = nvert - 1; i < nvert; j = i++)\n\t{\n\t\tif (((verty[i] > testy) != (verty[j] > testy)) && (testx < (vertx[j] - vertx[i]) * (testy - verty[i]) / (verty[j] - verty[i]) + vertx[i]))\n\t\t{\n\t\t\tret = !ret;\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid ACustomSelectActor::GetFBoxPointsSet(\n\tTArray<FBoxPointSet>& fboxPointsArr,\n\tTArray<AActor*>& actorArr,\n\tTSubclassOf<AActor>& classFilter,\n\tbool& bIncludeNonCollidingComponents,\n\tAPlayerController * player_ctrl)\n{\n\tint i = 0;\n\tfor (TActorIterator<AActor> Itr(GWorld->GetWorld(), classFilter); Itr; ++Itr)\n\t{\n\t\tAActor* EachActor = *Itr;\n\t\tconst FBox EachActorBounds = Cast<AActor>(EachActor)->GetComponentsBoundingBox(bIncludeNonCollidingComponents);\n\t\tconst FVector BoxCenter = EachActorBounds.GetCenter();\n\t\tconst FVector BoxExtents = EachActorBounds.GetExtent();\n\t\tFBox2D ActorBox2D(ForceInit);\n\t\tfboxPointsArr.Add(FBoxPointSet());\n\t\tfor (uint8 BoundsPointItr = 0; BoundsPointItr < 8; BoundsPointItr++)\n\t\t{\n\t\t\tFVector2D ScreenPos;\n\t\t\tif (ProjectWorldLocationToWidgetPosition(player_ctrl, BoxCenter + (BoundsPointMapping[BoundsPointItr] * BoxExtents), ScreenPos))\n\t\t\t{\n\t\t\t\tActorBox2D += ScreenPos;\n\t\t\t\tfboxPointsArr[i].points[BoundsPointItr + 1] = ScreenPos;\n\t\t\t}\n\t\t}\n\t\tfboxPointsArr[i].points[0] = ActorBox2D.GetCenter();\n\t\tactorArr.Add(EachActor);\n\t\ti++;\n\t}\n}\n\nvoid ACustomSelectActor::GetActorsRefByPointsSet(\n\tTArray<AActor*>& outActors,\n\tTArray<float>& vertx,\n\tTArray<float>& verty,\n\tTArray<FBoxPointSet>& fboxPointsArr,\n\tTArray<AActor*>& actorArr,\n\tTArray<FVector2D>& polygonPoints,\n\tint& len)\n{\n\tint fboxlen = fboxPointsArr.Num();\n\tint pointslen = polygonPoints.Num();\n\tfloat max_x = 0;\n\tfloat max_y = 0;\n\tfloat min_x = 0;\n\tfloat min_y = 0;\n\tGetMax(polygonPoints, max_x, max_y, len);\n\tGetMin(polygonPoints, min_x, min_y, len);\n\tfor (int i = 0; i < fboxlen; i++)\n\t{\n\t\tfor (int j = 0; j < ActorSamplingPoints; j++)\n\t\t{\n\t\t\tif (fboxPointsArr[i].points[j].X<min_x || fboxPointsArr[i].points[j].X>max_x ||\n\t\t\t\tfboxPointsArr[i].points[j].Y<min_y || fboxPointsArr[i].points[j].Y>max_y)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t\tj = ActorSamplingPoints;\n\t\t\t}\n\t\t\tif (PNPoly(len, vertx, verty, fboxPointsArr[i].points[j].X, fboxPointsArr[i].points[j].Y))\n\t\t\t{\n\t\t\t\toutActors.Add(actorArr[i]);\n\t\t\t\tj = ActorSamplingPoints;\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool ACustomSelectActor::CustomSelect(\n\tTArray<AActor*>& outActors,\n\tTArray<FVector2D> polygonPoints,\n\tTSubclassOf<AActor> classFilter,\n\tAPlayerController * player_ctrl,\n\tbool bIncludeNonCollidingComponents)\n{\n\tint len = polygonPoints.Num();\n\tif (len < LeastPointNum)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Polygon has too few points\"));\n\t\treturn false;\n\t}\n\tTArray<float> vertx;\n\tTArray<float> verty;\n\tSpwanVertArr(polygonPoints, vertx, verty, len);\n\tTArray<AActor*> actorArr;\n\tTArray<FBoxPointSet> fboxPointsArr;\n\tGetFBoxPointsSet(fboxPointsArr, actorArr, classFilter, bIncludeNonCollidingComponents, player_ctrl);\n\tGetActorsRefByPointsSet(outActors, vertx, verty, fboxPointsArr, actorArr, polygonPoints, len);\n\treturn true;\n}\n\nfloat ACustomSelectActor::CompuePolygonArea(const TArray<FVector2D> polygonPoints)\n{\n\tint point_num = polygonPoints.Num();\n\tif (point_num < 3)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"The area is not polygon!\"));\n\t\treturn 0.0;\n\t}\n\tdouble s = polygonPoints[0].Y * (polygonPoints[point_num - 1].X - polygonPoints[1].X);\n\tfor (int i = 1; i < point_num; ++i)\n\t\ts += polygonPoints[i].Y * (polygonPoints[i - 1].X - polygonPoints[(i + 1) % point_num].X);\n\treturn fabs(s / 2.0);\n}\n\n```\n\n- `BoundsPointMapping[8]`用于确定场景中Actor的边界盒子的8个点。\n\n- 结构体FBoxPointSet是用来存储采样点集的数据结构，这里我取Actor边界盒子的8个点加中点一共9个点作为采样点集。\n\n- GetMax和GetMin计算多边形点集的横纵坐标的最大值和最小值。\n\n- SpawnVertArr负责将多边形点集分成横坐标点集和纵坐标点集。\n\n- PNPoly函数使用PNPoly算法判断一个点是否在多边形内部。\n\n- ProjectWorldLocationToWidgetPosition函数是一个由C++父类声明，由蓝图子类实现的函数，负责将场景中的Actor的边界盒子的点的空间坐标投影到屏幕坐标。之所以使用这种方式是因为ProjectWorldLocationToWidgetPosition蓝图节点没有C++版本，而必须使用ProjectWorldLocationToWidgetPosition蓝图节点的原因是ProjectWorldLocationToWidgetPosition蓝图节点投影出来的坐标会根据屏幕尺寸变化而自动适应，其他的空间坐标转屏幕坐标的蓝图节点在非全屏与全屏下会出现位置偏移。\n\n  ![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180923.png)\n  所以这里需要创建一个继承自CustomSelectActor的蓝图子类来重写ProjectWorldLocationToWidgetPosition函数。\n\n- GetFBoxPointsSet函数负责获取世界中所有Actor的采样点集。\n\n- GetActorsRefByPointsSet函数负责使用PNPoly函数取在多边形内部的Actor的引用。\n\n- CustomSelect函数否则暴漏给蓝图提供数据输入输出的接口。\n\n- CompuePolygonArea函数负责计算多边形的面积，目前还有一些问题，暂时不用理睬。\n\n至此多边形框选功能就完全实现了。来看一下效果：\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180929.png)\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180935.png)\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180942.png)\n\n\n# 四、将功能包成UE4插件\n\n如果需要将功能打包成插件，那么就需要将CustomSelectActor的C++类创建在插件里。\n\n## 1.创建一个空插件\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180952.png)\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180958.png)\n\n创建之后需要在VS中编一下项目，然后关闭引擎，重新打开项目，以便引擎重新加载dll文件，因为插件不属于引擎的一部分，所以引擎没办法直接热加载插件内容。\n\n## 2.在插件文件夹下创建C++类\n\n我们需要将CustomSelectActor类创建在插件文件夹下，创建好空插件后，再创建C++类时可以选择创建文件夹。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514181004.png)\n然后按一、二、三的步骤实现功能即可。\n\n## 3.打包插件\n\n进入插件管理点集打包\n\n![在这里插入图片描述](https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514181009.png)\n至此插件就打包好了。\n\n参考博客：\nhttps://blog.csdn.net/weixin_36369675/article/details/88419361\nhttps://www.cnblogs.com/anningwang/p/7581545.html\nhttps://www.cnblogs.com/TenosDoIt/p/4047211.html","slug":"【UE4】UE4实现自定义框选","published":1,"updated":"2021-05-14T10:15:54.486Z","_id":"ckoo5uhf90001k8r75bob2tt2","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p>要在UE4中实现自定义框选功能，首先我们来分析一下顶顶一框选插件需要些什么模块？</p>\n<ul>\n<li>绘制模块</li>\n<li>显示模块</li>\n<li>计算模块</li>\n</ul>\n<p>嗯，大概分这么三个模块，好，现在我们一个个模块来分析实现。首先分析实现一下显示模块。</p>\n<a id=\"more\"></a>\n\n<p><font color=\"green\">提示：</font></p>\n<p><font color=\"green\">如果功能需要打包成插件，请先浏览第四章</font></p>\n<h1 id=\"一、显示模块\"><a href=\"#一、显示模块\" class=\"headerlink\" title=\"一、显示模块\"></a>一、显示模块</h1><p>首先我们需要做一些准备</p>\n<h2 id=\"1-创建Wedgit作为显示载体\"><a href=\"#1-创建Wedgit作为显示载体\" class=\"headerlink\" title=\"1.创建Wedgit作为显示载体\"></a>1.创建Wedgit作为显示载体</h2><p>UE4绘制直线的方式很多，这里我使用DrawLine在RenderTarget里绘制，绘制的实现放在后面说。</p>\n<p>然后我们需要让自定义框选的线显示在屏幕上，那么使用<code>wedgit</code>来显示是比较理想的，所以我们来创建一个widget，命名为<code>CustomSelectUI</code>，并为CustomSelectUI添加一个<code>image</code>作为显示的载体，命名为Background。</p>\n<h2 id=\"2-创建Material作为RenderTarget的显示载体\"><a href=\"#2-创建Material作为RenderTarget的显示载体\" class=\"headerlink\" title=\"2.创建Material作为RenderTarget的显示载体\"></a>2.创建Material作为RenderTarget的显示载体</h2><p>光一个image也是无法显示我们绘制的线的，因为我们的线是画在RenderTarget里的，而image没法直接使用RenderTarget，所以我们还需要创建一个Material来承载RenderTarget。这里创建一个Material命名为Mat_Paint。</p>\n<h2 id=\"3-为Material创建一个Texture\"><a href=\"#3-为Material创建一个Texture\" class=\"headerlink\" title=\"3.为Material创建一个Texture\"></a>3.为Material创建一个Texture</h2><p>创建的Texture是有讲究的，Texture必须是存黑色的即RPG(0,0,0)，然后分辨率可自定义。这里我使用PS制作了一个纯黑的PNG图片，并设置分辨率为2048x2048，并导入到UE4生成Texture，并命名为Mat_Transparent_Max。<br><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180719.png\" alt=\"在这里插入图片描述\"></p>\n<p>使用纯黑色的原因在第四小节说明。</p>\n<h2 id=\"4-实现Material的作用\"><a href=\"#4-实现Material的作用\" class=\"headerlink\" title=\"4.实现Material的作用\"></a>4.实现Material的作用</h2><p>Material出来作为RenerTarget的载体外，还有设置笔刷的颜色，以及使背景透明的作用。</p>\n<p>先来看一下Mat_Paint的蓝图</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180725.png\" alt=\"在这里插入图片描述\"></p>\n<p>首先将Mat_Paint节点的<code>Details/Material/Material Domain</code>更换为User Interface，即将Material改为Material Interface。</p>\n<p>并未Mat_Paint添加一个Texture，将之前创建的Mat_Transparent_Max拖入Mat_Paint中，右键节点选择Convert to Parameter将节点参数化，并取名<code>RT_Texture</code>，这是为了后面动态设置做的准备。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180731.png\" alt=\"在这里插入图片描述\"></p>\n<p>然后将RT_Texture连接到Mat_Paint中的Opacity上，Opacity节点是Material控制材质透明度的接口，在Opacity中RGB(0,0,0)表示全透明，RGB(1,1,1)表示不透明，即纯黑色表示全透明，纯白色表示不透明，这就是为什么我们需要一张纯黑色的Texture的原因。因为我们需要一个透明的材质赋予image这样我们才能看到Wedgit后面的场景，使场景不会被我们的image遮挡。</p>\n<p>然后创建一个Constant3Vector，并且也将其参数化，命名为PaintColor，这为之后修改画笔颜色预留接口。将PaintColor连接到Mat_Paint的Final Color上。Final Color接口控制着材质最终显示的颜色。</p>\n<p>到这里，擦材质我们就做好了。</p>\n<h2 id=\"5-显示\"><a href=\"#5-显示\" class=\"headerlink\" title=\"5.显示\"></a>5.显示</h2><p>这里我在CustomSelectUI构造时为Background添加Mat_Paint动态材质。我们来看一下蓝图</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180738.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>RenderMat变量是Material Instance Dynamic类型用于存储动态创建的Mat_Paint，方便之后使用；</li>\n<li>LineLinearColor变量是LinearColor类型，用于设置画笔颜色</li>\n</ul>\n<p>到这里显示部分就完成了。</p>\n<h1 id=\"二、绘制模块\"><a href=\"#二、绘制模块\" class=\"headerlink\" title=\"二、绘制模块\"></a>二、绘制模块</h1><h2 id=\"1-获取鼠标在屏幕中的位置坐标\"><a href=\"#1-获取鼠标在屏幕中的位置坐标\" class=\"headerlink\" title=\"1.获取鼠标在屏幕中的位置坐标\"></a>1.获取鼠标在屏幕中的位置坐标</h2><p>线的绘制我使用DrawLine函数根据鼠标点击的点来绘制点与点之间的直线，绘制模块最终要的两个步骤就是获取鼠标点击的屏幕上的点和根据点集绘制多边形。</p>\n<p>实现获取鼠标在屏幕上的位置，这里我们需要重写两个函数，OnMouseButtonUp和OnMouseButtonDown,我们来看一下蓝图。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180748.png\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180754.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li><p>MouseDown用于标识鼠标的按下与抬起，true表示按下，false表示抬起。</p>\n</li>\n<li><p>Setup控制是否开始绘制。</p>\n</li>\n<li><p>IsFirstPoint标识第一个点与其余点。</p>\n</li>\n<li><p>PolygonPoints是存储鼠标点击的点的数组，启动绘制之后鼠标每点击一次变向数组中添加一个Vector2D元素。</p>\n</li>\n<li><p>CurrentPoint存储鼠标当前点击的屏幕坐标。</p>\n</li>\n<li><p>StartPoint存储绘制直线的起点的屏幕坐标。</p>\n</li>\n<li><p>MousePositionAdaptDPI是自己封装的获取鼠标屏幕坐标的函数，之所以封装是为例修改方便。</p>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180801.png\" alt=\"在这里插入图片描述\"></p>\n<p>到此，获取鼠标的屏幕坐标就实现了，接下来要根据鼠标点击确定的点集PolygonPoints绘制直线。</p>\n<h2 id=\"2-绘制直线\"><a href=\"#2-绘制直线\" class=\"headerlink\" title=\"2.绘制直线\"></a>2.绘制直线</h2><p>再绘制直线之前，需要做一些准备工作，即创建直线绘制的载体RenderTarget并用之前创建好的RenderMat承载，然后将RenderMat绑定到Background上显示。这里我绑定到Setup按钮的OnClicked事件下。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180807.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li><p>CreateCanvasRenderTarget2D函数负责创建RenderTarget，RenderTarget可以直接使用引擎默认的，也可以自己创建自定义的，这里我使用引擎默认的。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180812.png\" alt=\"在这里插入图片描述\"></p>\n<p>Width和Height控制着RenderTarget的长宽比例，超出这个比例的部分屏幕将无法绘制，如：</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180820.png\" alt=\"在这里插入图片描述\"></p>\n<p>红框部分的屏幕比例就是1920：1080，超出着部分的屏幕将无法绘制，当然在全屏运行的情况下不会出现这种问题。出现这个问题是因为我的计算机屏幕尺寸就是1920：1080，运行时，UE4的实际运行窗口是蓝色部分，很明显由于windows菜单栏和UE运行窗口的菜单栏占据了屏幕的部分像素，所以UE的实际运行窗口是蓝色部分，其比例显然不是1920：1080，所以超出部分就没办法绘制了。这个RenderTarget的比例可以根据自己的实际需求更改。</p>\n</li>\n<li><p>SetupCustomSelect函数负责绘制的启动与关闭</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180828.png\" alt=\"在这里插入图片描述\"><br>准备工作结束后便可以开始绘制直线了，直线的绘制放在Tick函数下，每帧绘制。</p>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180834.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li><p>LineThickness控制直线绘制时的粗细程度。</p>\n</li>\n<li><p>StartPaint是具体的直线绘制函数。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180840.png\" alt=\"在这里插入图片描述\"></p>\n<p>其中RenderColor必须设置纯白色，只有这样绘制出来的直线才是不透明的。</p>\n</li>\n</ul>\n<p><font color=\"red\">绘制直线这里有一点需要注意，即需要设置我们Background的锚点为左上角，因为RenderTarget的原点在左上角，只有这样鼠标点击的位置才会和绘制的位置匹配，否则会出现位置偏移的问题。</font></p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180848.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"3-清除绘制内容\"><a href=\"#3-清除绘制内容\" class=\"headerlink\" title=\"3.清除绘制内容\"></a>3.清除绘制内容</h2><p>考虑到会有绘制出错的情况，所以添加一个清除绘制内容的功能。清除绘制内容原理比较简单，只需要清除RenderTarget缓存和PolygonPoints点击即可。</p>\n<p>这里我绑定在Delete按钮的OnClicked事件下。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180854.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"4-结束绘制\"><a href=\"#4-结束绘制\" class=\"headerlink\" title=\"4.结束绘制\"></a>4.结束绘制</h2><p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180859.png\" alt=\"在这里插入图片描述\"></p>\n<p>结束绘制之后就要开始计算框选内容了，SureSelect函数负责这方面的实现，计算后面讲解。</p>\n<p>结束绘制之后需要将最后一个点和第一个点连接来，确保多边形是一个封闭的多边形。EndPaint函数负责这个功能的实现。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180904.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"三、计算\"><a href=\"#三、计算\" class=\"headerlink\" title=\"三、计算\"></a>三、计算</h1><p>计算这里需要用到C++了，在蓝图的SureSelect函数里调用C++的计算函数。</p>\n<p>创建一个继承自Actor的C++类，并命名为CustomSelectActor，下面贴出C++源码：</p>\n<p><code>.h</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> once</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> LeastPointNum 4</span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> ActorSamplingPoints 9</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;Runtime/Engine/Classes/Kismet/GameplayStatics.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;Engine/World.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;GameFramework/Actor.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;EngineUtils.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;GameFramework/PlayerController.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;CoreMinimal.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;GameFramework/Actor.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;CustomSelectActor.generated.h&quot;</span></span><br><br>USTRUCT()<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">FBoxPointSet</span></span><br><span class=\"hljs-class\">&#123;</span><br>\tGENERATED_USTRUCT_BODY()<br><span class=\"hljs-keyword\">public</span>:<br>\tTArray&lt;FVector2D&gt; points;<br>\tFBoxPointSet()<br>\t&#123;<br>\t\tpoints.Init(FVector2D(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>), <span class=\"hljs-number\">9</span>);<br>\t&#125;<br>&#125;;<br><br>UCLASS()<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CUSTOMSELECT_API</span> <span class=\"hljs-title\">ACustomSelectActor</span> :</span> <span class=\"hljs-keyword\">public</span> AActor<br>&#123;<br>\tGENERATED_BODY()<br>\t<br><span class=\"hljs-keyword\">public</span>:\t<br>\t<span class=\"hljs-keyword\">const</span> FVector BoundsPointMapping[<span class=\"hljs-number\">8</span>] =<br>\t&#123;<br>\t\tFVector(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>),<br>\t\tFVector(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">-1</span>),<br>\t\tFVector(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>),<br>\t\tFVector(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-1</span>),<br>\t\tFVector(<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>),<br>\t\tFVector(<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">-1</span>),<br>\t\tFVector(<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>),<br>\t\tFVector(<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-1</span>)<br>\t&#125;;<br><br><span class=\"hljs-keyword\">protected</span>:<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">BeginPlay</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">override</span></span>;<br><br><span class=\"hljs-keyword\">public</span>:\t<br>\tACustomSelectActor();<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Tick</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">float</span> DeltaTime)</span> <span class=\"hljs-keyword\">override</span></span>;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">GetMax</span><span class=\"hljs-params\">(TArray&lt;FVector2D&gt;&amp; points, <span class=\"hljs-keyword\">float</span>&amp; max_x, <span class=\"hljs-keyword\">float</span>&amp; max_y, <span class=\"hljs-keyword\">int</span>&amp; len)</span></span>;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">GetMin</span><span class=\"hljs-params\">(TArray&lt;FVector2D&gt;&amp; points, <span class=\"hljs-keyword\">float</span>&amp; min_x, <span class=\"hljs-keyword\">float</span>&amp; min_y, <span class=\"hljs-keyword\">int</span>&amp; len)</span></span>;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">SpwanVertArr</span><span class=\"hljs-params\">(TArray&lt;FVector2D&gt;&amp; polygonPoints, TArray&lt;<span class=\"hljs-keyword\">float</span>&gt;&amp; vertx, TArray&lt;<span class=\"hljs-keyword\">float</span>&gt;&amp; verty, <span class=\"hljs-keyword\">int</span>&amp; len)</span></span>;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">PNPoly</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> nvert, TArray&lt;<span class=\"hljs-keyword\">float</span>&gt; vertx, TArray&lt;<span class=\"hljs-keyword\">float</span>&gt; verty, <span class=\"hljs-keyword\">float</span> testx, <span class=\"hljs-keyword\">float</span> testy)</span></span>;<br>\tUFUNCTION(BlueprintImplementableEvent)<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">ProjectWorldLocationToWidgetPosition</span><span class=\"hljs-params\">(APlayerController* player_ctrl, FVector worldLocation, FVector2D&amp; screenPosition)</span></span>;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">GetFBoxPointsSet</span><span class=\"hljs-params\">(</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t\tTArray&lt;FBoxPointSet&gt;&amp; fboxPointsArr,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t\tTArray&lt;AActor*&gt;&amp; actorArr,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t\tTSubclassOf&lt;AActor&gt;&amp; classFilter,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t\t<span class=\"hljs-keyword\">bool</span>&amp; bIncludeNonCollidingComponents,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t\tAPlayerController* player_ctrl)</span></span>;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">GetActorsRefByPointsSet</span><span class=\"hljs-params\">(</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t\tTArray&lt;AActor*&gt;&amp; outActors,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t\tTArray&lt;<span class=\"hljs-keyword\">float</span>&gt;&amp; vertx,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t\tTArray&lt;<span class=\"hljs-keyword\">float</span>&gt;&amp; verty,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t\tTArray&lt;FBoxPointSet&gt;&amp; fboxPointsArr,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t\tTArray&lt;AActor*&gt;&amp; actorArr,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t\tTArray&lt;FVector2D&gt;&amp; polygonPoints,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t\t<span class=\"hljs-keyword\">int</span>&amp; len)</span></span>;<br>\tUFUNCTION(BlueprintCallable, Category = <span class=\"hljs-string\">&quot;CustomSelect&quot;</span>)<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">CustomSelect</span><span class=\"hljs-params\">(</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t\tTArray&lt;AActor*&gt;&amp; outActors,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t\tTArray&lt;FVector2D&gt; polygonPoints,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t\tTSubclassOf&lt;AActor&gt; classFilter,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t\tAPlayerController * player_ctrl,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t\t<span class=\"hljs-keyword\">bool</span> bIncludeNonCollidingComponents)</span></span>;<br>\tUFUNCTION(BlueprintCallable, Category = <span class=\"hljs-string\">&quot;CustomSelect&quot;</span>)<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">float</span> <span class=\"hljs-title\">CompuePolygonArea</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> TArray&lt;FVector2D&gt; polygonPoints)</span></span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure>\n<p><code>.cpp</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;CustomSelectActor.h&quot;</span></span><br><br>ACustomSelectActor::ACustomSelectActor()<br>&#123;<br>\tPrimaryActorTick.bCanEverTick = <span class=\"hljs-literal\">false</span>;<br><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ACustomSelectActor::BeginPlay</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tSuper::BeginPlay();<br>\t<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ACustomSelectActor::Tick</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">float</span> DeltaTime)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tSuper::Tick(DeltaTime);<br><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ACustomSelectActor::GetMax</span><span class=\"hljs-params\">(TArray&lt;FVector2D&gt;&amp; points, <span class=\"hljs-keyword\">float</span>&amp; max_x, <span class=\"hljs-keyword\">float</span>&amp; max_y, <span class=\"hljs-keyword\">int</span>&amp; len)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tmax_x = points[<span class=\"hljs-number\">0</span>].X;<br>\tmax_y = points[<span class=\"hljs-number\">0</span>].Y;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; len; i++)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (max_x &lt; points[i].X)<br>\t\t&#123;<br>\t\t\tmax_x = points[i].X;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span> (max_y &lt; points[i].Y)<br>\t\t&#123;<br>\t\t\tmax_y = points[i].Y;<br>\t\t&#125;<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ACustomSelectActor::GetMin</span><span class=\"hljs-params\">(TArray&lt;FVector2D&gt;&amp; points, <span class=\"hljs-keyword\">float</span>&amp; min_x, <span class=\"hljs-keyword\">float</span>&amp; min_y, <span class=\"hljs-keyword\">int</span>&amp; len)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tmin_x = points[<span class=\"hljs-number\">0</span>].X;<br>\tmin_y = points[<span class=\"hljs-number\">0</span>].Y;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; len; i++)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (min_x &gt; points[i].X)<br>\t\t&#123;<br>\t\t\tmin_x = points[i].X;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span> (min_y &gt; points[i].Y)<br>\t\t&#123;<br>\t\t\tmin_y = points[i].Y;<br>\t\t&#125;<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ACustomSelectActor::SpwanVertArr</span><span class=\"hljs-params\">(TArray&lt;FVector2D&gt;&amp; polygonPoints, TArray&lt;<span class=\"hljs-keyword\">float</span>&gt;&amp; vertx, TArray&lt;<span class=\"hljs-keyword\">float</span>&gt;&amp; verty, <span class=\"hljs-keyword\">int</span>&amp; len)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; len; i++)<br>\t&#123;<br>\t\tvertx.Add(polygonPoints[i].X);<br>\t\tverty.Add(polygonPoints[i].Y);<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">ACustomSelectActor::PNPoly</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> nvert, TArray&lt;<span class=\"hljs-keyword\">float</span>&gt; vertx, TArray&lt;<span class=\"hljs-keyword\">float</span>&gt; verty, <span class=\"hljs-keyword\">float</span> testx, <span class=\"hljs-keyword\">float</span> testy)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">bool</span> ret = <span class=\"hljs-literal\">false</span>;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>, j = nvert - <span class=\"hljs-number\">1</span>; i &lt; nvert; j = i++)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (((verty[i] &gt; testy) != (verty[j] &gt; testy)) &amp;&amp; (testx &lt; (vertx[j] - vertx[i]) * (testy - verty[i]) / (verty[j] - verty[i]) + vertx[i]))<br>\t\t&#123;<br>\t\t\tret = !ret;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> ret;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ACustomSelectActor::GetFBoxPointsSet</span><span class=\"hljs-params\">(</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\tTArray&lt;FBoxPointSet&gt;&amp; fboxPointsArr,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\tTArray&lt;AActor*&gt;&amp; actorArr,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\tTSubclassOf&lt;AActor&gt;&amp; classFilter,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t<span class=\"hljs-keyword\">bool</span>&amp; bIncludeNonCollidingComponents,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\tAPlayerController * player_ctrl)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (TActorIterator&lt;AActor&gt; Itr(GWorld-&gt;GetWorld(), classFilter); Itr; ++Itr)<br>\t&#123;<br>\t\tAActor* EachActor = *Itr;<br>\t\t<span class=\"hljs-keyword\">const</span> FBox EachActorBounds = Cast&lt;AActor&gt;(EachActor)-&gt;GetComponentsBoundingBox(bIncludeNonCollidingComponents);<br>\t\t<span class=\"hljs-keyword\">const</span> FVector BoxCenter = EachActorBounds.GetCenter();<br>\t\t<span class=\"hljs-keyword\">const</span> FVector BoxExtents = EachActorBounds.GetExtent();<br>\t\t<span class=\"hljs-function\">FBox2D <span class=\"hljs-title\">ActorBox2D</span><span class=\"hljs-params\">(ForceInit)</span></span>;<br>\t\tfboxPointsArr.Add(FBoxPointSet());<br>\t\t<span class=\"hljs-keyword\">for</span> (uint8 BoundsPointItr = <span class=\"hljs-number\">0</span>; BoundsPointItr &lt; <span class=\"hljs-number\">8</span>; BoundsPointItr++)<br>\t\t&#123;<br>\t\t\tFVector2D ScreenPos;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (ProjectWorldLocationToWidgetPosition(player_ctrl, BoxCenter + (BoundsPointMapping[BoundsPointItr] * BoxExtents), ScreenPos))<br>\t\t\t&#123;<br>\t\t\t\tActorBox2D += ScreenPos;<br>\t\t\t\tfboxPointsArr[i].points[BoundsPointItr + <span class=\"hljs-number\">1</span>] = ScreenPos;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tfboxPointsArr[i].points[<span class=\"hljs-number\">0</span>] = ActorBox2D.GetCenter();<br>\t\tactorArr.Add(EachActor);<br>\t\ti++;<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ACustomSelectActor::GetActorsRefByPointsSet</span><span class=\"hljs-params\">(</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\tTArray&lt;AActor*&gt;&amp; outActors,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\tTArray&lt;<span class=\"hljs-keyword\">float</span>&gt;&amp; vertx,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\tTArray&lt;<span class=\"hljs-keyword\">float</span>&gt;&amp; verty,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\tTArray&lt;FBoxPointSet&gt;&amp; fboxPointsArr,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\tTArray&lt;AActor*&gt;&amp; actorArr,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\tTArray&lt;FVector2D&gt;&amp; polygonPoints,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t<span class=\"hljs-keyword\">int</span>&amp; len)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">int</span> fboxlen = fboxPointsArr.Num();<br>\t<span class=\"hljs-keyword\">int</span> pointslen = polygonPoints.Num();<br>\t<span class=\"hljs-keyword\">float</span> max_x = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">float</span> max_y = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">float</span> min_x = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">float</span> min_y = <span class=\"hljs-number\">0</span>;<br>\tGetMax(polygonPoints, max_x, max_y, len);<br>\tGetMin(polygonPoints, min_x, min_y, len);<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; fboxlen; i++)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; ActorSamplingPoints; j++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (fboxPointsArr[i].points[j].X&lt;min_x || fboxPointsArr[i].points[j].X&gt;max_x ||<br>\t\t\t\tfboxPointsArr[i].points[j].Y&lt;min_y || fboxPointsArr[i].points[j].Y&gt;max_y)<br>\t\t\t&#123;<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t\tj = ActorSamplingPoints;<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (PNPoly(len, vertx, verty, fboxPointsArr[i].points[j].X, fboxPointsArr[i].points[j].Y))<br>\t\t\t&#123;<br>\t\t\t\toutActors.Add(actorArr[i]);<br>\t\t\t\tj = ActorSamplingPoints;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">ACustomSelectActor::CustomSelect</span><span class=\"hljs-params\">(</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\tTArray&lt;AActor*&gt;&amp; outActors,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\tTArray&lt;FVector2D&gt; polygonPoints,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\tTSubclassOf&lt;AActor&gt; classFilter,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\tAPlayerController * player_ctrl,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t<span class=\"hljs-keyword\">bool</span> bIncludeNonCollidingComponents)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">int</span> len = polygonPoints.Num();<br>\t<span class=\"hljs-keyword\">if</span> (len &lt; LeastPointNum)<br>\t&#123;<br>\t\tUE_LOG(LogTemp, Warning, TEXT(<span class=\"hljs-string\">&quot;Polygon has too few points&quot;</span>));<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t&#125;<br>\tTArray&lt;<span class=\"hljs-keyword\">float</span>&gt; vertx;<br>\tTArray&lt;<span class=\"hljs-keyword\">float</span>&gt; verty;<br>\tSpwanVertArr(polygonPoints, vertx, verty, len);<br>\tTArray&lt;AActor*&gt; actorArr;<br>\tTArray&lt;FBoxPointSet&gt; fboxPointsArr;<br>\tGetFBoxPointsSet(fboxPointsArr, actorArr, classFilter, bIncludeNonCollidingComponents, player_ctrl);<br>\tGetActorsRefByPointsSet(outActors, vertx, verty, fboxPointsArr, actorArr, polygonPoints, len);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">float</span> <span class=\"hljs-title\">ACustomSelectActor::CompuePolygonArea</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> TArray&lt;FVector2D&gt; polygonPoints)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">int</span> point_num = polygonPoints.Num();<br>\t<span class=\"hljs-keyword\">if</span> (point_num &lt; <span class=\"hljs-number\">3</span>)<br>\t&#123;<br>\t\tUE_LOG(LogTemp, Warning, TEXT(<span class=\"hljs-string\">&quot;The area is not polygon!&quot;</span>));<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0.0</span>;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">double</span> s = polygonPoints[<span class=\"hljs-number\">0</span>].Y * (polygonPoints[point_num - <span class=\"hljs-number\">1</span>].X - polygonPoints[<span class=\"hljs-number\">1</span>].X);<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; point_num; ++i)<br>\t\ts += polygonPoints[i].Y * (polygonPoints[i - <span class=\"hljs-number\">1</span>].X - polygonPoints[(i + <span class=\"hljs-number\">1</span>) % point_num].X);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">fabs</span>(s / <span class=\"hljs-number\">2.0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>\n<ul>\n<li><p><code>BoundsPointMapping[8]</code>用于确定场景中Actor的边界盒子的8个点。</p>\n</li>\n<li><p>结构体FBoxPointSet是用来存储采样点集的数据结构，这里我取Actor边界盒子的8个点加中点一共9个点作为采样点集。</p>\n</li>\n<li><p>GetMax和GetMin计算多边形点集的横纵坐标的最大值和最小值。</p>\n</li>\n<li><p>SpawnVertArr负责将多边形点集分成横坐标点集和纵坐标点集。</p>\n</li>\n<li><p>PNPoly函数使用PNPoly算法判断一个点是否在多边形内部。</p>\n</li>\n<li><p>ProjectWorldLocationToWidgetPosition函数是一个由C++父类声明，由蓝图子类实现的函数，负责将场景中的Actor的边界盒子的点的空间坐标投影到屏幕坐标。之所以使用这种方式是因为ProjectWorldLocationToWidgetPosition蓝图节点没有C++版本，而必须使用ProjectWorldLocationToWidgetPosition蓝图节点的原因是ProjectWorldLocationToWidgetPosition蓝图节点投影出来的坐标会根据屏幕尺寸变化而自动适应，其他的空间坐标转屏幕坐标的蓝图节点在非全屏与全屏下会出现位置偏移。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180923.png\" alt=\"在这里插入图片描述\"><br>所以这里需要创建一个继承自CustomSelectActor的蓝图子类来重写ProjectWorldLocationToWidgetPosition函数。</p>\n</li>\n<li><p>GetFBoxPointsSet函数负责获取世界中所有Actor的采样点集。</p>\n</li>\n<li><p>GetActorsRefByPointsSet函数负责使用PNPoly函数取在多边形内部的Actor的引用。</p>\n</li>\n<li><p>CustomSelect函数否则暴漏给蓝图提供数据输入输出的接口。</p>\n</li>\n<li><p>CompuePolygonArea函数负责计算多边形的面积，目前还有一些问题，暂时不用理睬。</p>\n</li>\n</ul>\n<p>至此多边形框选功能就完全实现了。来看一下效果：</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180929.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180935.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180942.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"四、将功能包成UE4插件\"><a href=\"#四、将功能包成UE4插件\" class=\"headerlink\" title=\"四、将功能包成UE4插件\"></a>四、将功能包成UE4插件</h1><p>如果需要将功能打包成插件，那么就需要将CustomSelectActor的C++类创建在插件里。</p>\n<h2 id=\"1-创建一个空插件\"><a href=\"#1-创建一个空插件\" class=\"headerlink\" title=\"1.创建一个空插件\"></a>1.创建一个空插件</h2><p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180952.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180958.png\" alt=\"在这里插入图片描述\"></p>\n<p>创建之后需要在VS中编一下项目，然后关闭引擎，重新打开项目，以便引擎重新加载dll文件，因为插件不属于引擎的一部分，所以引擎没办法直接热加载插件内容。</p>\n<h2 id=\"2-在插件文件夹下创建C-类\"><a href=\"#2-在插件文件夹下创建C-类\" class=\"headerlink\" title=\"2.在插件文件夹下创建C++类\"></a>2.在插件文件夹下创建C++类</h2><p>我们需要将CustomSelectActor类创建在插件文件夹下，创建好空插件后，再创建C++类时可以选择创建文件夹。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514181004.png\" alt=\"在这里插入图片描述\"><br>然后按一、二、三的步骤实现功能即可。</p>\n<h2 id=\"3-打包插件\"><a href=\"#3-打包插件\" class=\"headerlink\" title=\"3.打包插件\"></a>3.打包插件</h2><p>进入插件管理点集打包</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514181009.png\" alt=\"在这里插入图片描述\"><br>至此插件就打包好了。</p>\n<p>参考博客：<br><a href=\"https://blog.csdn.net/weixin_36369675/article/details/88419361\">https://blog.csdn.net/weixin_36369675/article/details/88419361</a><br><a href=\"https://www.cnblogs.com/anningwang/p/7581545.html\">https://www.cnblogs.com/anningwang/p/7581545.html</a><br><a href=\"https://www.cnblogs.com/TenosDoIt/p/4047211.html\">https://www.cnblogs.com/TenosDoIt/p/4047211.html</a></p>\n","site":{"data":{}},"excerpt":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p>要在UE4中实现自定义框选功能，首先我们来分析一下顶顶一框选插件需要些什么模块？</p>\n<ul>\n<li>绘制模块</li>\n<li>显示模块</li>\n<li>计算模块</li>\n</ul>\n<p>嗯，大概分这么三个模块，好，现在我们一个个模块来分析实现。首先分析实现一下显示模块。</p>","more":"<p><font color=\"green\">提示：</font></p>\n<p><font color=\"green\">如果功能需要打包成插件，请先浏览第四章</font></p>\n<h1 id=\"一、显示模块\"><a href=\"#一、显示模块\" class=\"headerlink\" title=\"一、显示模块\"></a>一、显示模块</h1><p>首先我们需要做一些准备</p>\n<h2 id=\"1-创建Wedgit作为显示载体\"><a href=\"#1-创建Wedgit作为显示载体\" class=\"headerlink\" title=\"1.创建Wedgit作为显示载体\"></a>1.创建Wedgit作为显示载体</h2><p>UE4绘制直线的方式很多，这里我使用DrawLine在RenderTarget里绘制，绘制的实现放在后面说。</p>\n<p>然后我们需要让自定义框选的线显示在屏幕上，那么使用<code>wedgit</code>来显示是比较理想的，所以我们来创建一个widget，命名为<code>CustomSelectUI</code>，并为CustomSelectUI添加一个<code>image</code>作为显示的载体，命名为Background。</p>\n<h2 id=\"2-创建Material作为RenderTarget的显示载体\"><a href=\"#2-创建Material作为RenderTarget的显示载体\" class=\"headerlink\" title=\"2.创建Material作为RenderTarget的显示载体\"></a>2.创建Material作为RenderTarget的显示载体</h2><p>光一个image也是无法显示我们绘制的线的，因为我们的线是画在RenderTarget里的，而image没法直接使用RenderTarget，所以我们还需要创建一个Material来承载RenderTarget。这里创建一个Material命名为Mat_Paint。</p>\n<h2 id=\"3-为Material创建一个Texture\"><a href=\"#3-为Material创建一个Texture\" class=\"headerlink\" title=\"3.为Material创建一个Texture\"></a>3.为Material创建一个Texture</h2><p>创建的Texture是有讲究的，Texture必须是存黑色的即RPG(0,0,0)，然后分辨率可自定义。这里我使用PS制作了一个纯黑的PNG图片，并设置分辨率为2048x2048，并导入到UE4生成Texture，并命名为Mat_Transparent_Max。<br><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180719.png\" alt=\"在这里插入图片描述\"></p>\n<p>使用纯黑色的原因在第四小节说明。</p>\n<h2 id=\"4-实现Material的作用\"><a href=\"#4-实现Material的作用\" class=\"headerlink\" title=\"4.实现Material的作用\"></a>4.实现Material的作用</h2><p>Material出来作为RenerTarget的载体外，还有设置笔刷的颜色，以及使背景透明的作用。</p>\n<p>先来看一下Mat_Paint的蓝图</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180725.png\" alt=\"在这里插入图片描述\"></p>\n<p>首先将Mat_Paint节点的<code>Details/Material/Material Domain</code>更换为User Interface，即将Material改为Material Interface。</p>\n<p>并未Mat_Paint添加一个Texture，将之前创建的Mat_Transparent_Max拖入Mat_Paint中，右键节点选择Convert to Parameter将节点参数化，并取名<code>RT_Texture</code>，这是为了后面动态设置做的准备。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180731.png\" alt=\"在这里插入图片描述\"></p>\n<p>然后将RT_Texture连接到Mat_Paint中的Opacity上，Opacity节点是Material控制材质透明度的接口，在Opacity中RGB(0,0,0)表示全透明，RGB(1,1,1)表示不透明，即纯黑色表示全透明，纯白色表示不透明，这就是为什么我们需要一张纯黑色的Texture的原因。因为我们需要一个透明的材质赋予image这样我们才能看到Wedgit后面的场景，使场景不会被我们的image遮挡。</p>\n<p>然后创建一个Constant3Vector，并且也将其参数化，命名为PaintColor，这为之后修改画笔颜色预留接口。将PaintColor连接到Mat_Paint的Final Color上。Final Color接口控制着材质最终显示的颜色。</p>\n<p>到这里，擦材质我们就做好了。</p>\n<h2 id=\"5-显示\"><a href=\"#5-显示\" class=\"headerlink\" title=\"5.显示\"></a>5.显示</h2><p>这里我在CustomSelectUI构造时为Background添加Mat_Paint动态材质。我们来看一下蓝图</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180738.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>RenderMat变量是Material Instance Dynamic类型用于存储动态创建的Mat_Paint，方便之后使用；</li>\n<li>LineLinearColor变量是LinearColor类型，用于设置画笔颜色</li>\n</ul>\n<p>到这里显示部分就完成了。</p>\n<h1 id=\"二、绘制模块\"><a href=\"#二、绘制模块\" class=\"headerlink\" title=\"二、绘制模块\"></a>二、绘制模块</h1><h2 id=\"1-获取鼠标在屏幕中的位置坐标\"><a href=\"#1-获取鼠标在屏幕中的位置坐标\" class=\"headerlink\" title=\"1.获取鼠标在屏幕中的位置坐标\"></a>1.获取鼠标在屏幕中的位置坐标</h2><p>线的绘制我使用DrawLine函数根据鼠标点击的点来绘制点与点之间的直线，绘制模块最终要的两个步骤就是获取鼠标点击的屏幕上的点和根据点集绘制多边形。</p>\n<p>实现获取鼠标在屏幕上的位置，这里我们需要重写两个函数，OnMouseButtonUp和OnMouseButtonDown,我们来看一下蓝图。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180748.png\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180754.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li><p>MouseDown用于标识鼠标的按下与抬起，true表示按下，false表示抬起。</p>\n</li>\n<li><p>Setup控制是否开始绘制。</p>\n</li>\n<li><p>IsFirstPoint标识第一个点与其余点。</p>\n</li>\n<li><p>PolygonPoints是存储鼠标点击的点的数组，启动绘制之后鼠标每点击一次变向数组中添加一个Vector2D元素。</p>\n</li>\n<li><p>CurrentPoint存储鼠标当前点击的屏幕坐标。</p>\n</li>\n<li><p>StartPoint存储绘制直线的起点的屏幕坐标。</p>\n</li>\n<li><p>MousePositionAdaptDPI是自己封装的获取鼠标屏幕坐标的函数，之所以封装是为例修改方便。</p>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180801.png\" alt=\"在这里插入图片描述\"></p>\n<p>到此，获取鼠标的屏幕坐标就实现了，接下来要根据鼠标点击确定的点集PolygonPoints绘制直线。</p>\n<h2 id=\"2-绘制直线\"><a href=\"#2-绘制直线\" class=\"headerlink\" title=\"2.绘制直线\"></a>2.绘制直线</h2><p>再绘制直线之前，需要做一些准备工作，即创建直线绘制的载体RenderTarget并用之前创建好的RenderMat承载，然后将RenderMat绑定到Background上显示。这里我绑定到Setup按钮的OnClicked事件下。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180807.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li><p>CreateCanvasRenderTarget2D函数负责创建RenderTarget，RenderTarget可以直接使用引擎默认的，也可以自己创建自定义的，这里我使用引擎默认的。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180812.png\" alt=\"在这里插入图片描述\"></p>\n<p>Width和Height控制着RenderTarget的长宽比例，超出这个比例的部分屏幕将无法绘制，如：</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180820.png\" alt=\"在这里插入图片描述\"></p>\n<p>红框部分的屏幕比例就是1920：1080，超出着部分的屏幕将无法绘制，当然在全屏运行的情况下不会出现这种问题。出现这个问题是因为我的计算机屏幕尺寸就是1920：1080，运行时，UE4的实际运行窗口是蓝色部分，很明显由于windows菜单栏和UE运行窗口的菜单栏占据了屏幕的部分像素，所以UE的实际运行窗口是蓝色部分，其比例显然不是1920：1080，所以超出部分就没办法绘制了。这个RenderTarget的比例可以根据自己的实际需求更改。</p>\n</li>\n<li><p>SetupCustomSelect函数负责绘制的启动与关闭</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180828.png\" alt=\"在这里插入图片描述\"><br>准备工作结束后便可以开始绘制直线了，直线的绘制放在Tick函数下，每帧绘制。</p>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180834.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li><p>LineThickness控制直线绘制时的粗细程度。</p>\n</li>\n<li><p>StartPaint是具体的直线绘制函数。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180840.png\" alt=\"在这里插入图片描述\"></p>\n<p>其中RenderColor必须设置纯白色，只有这样绘制出来的直线才是不透明的。</p>\n</li>\n</ul>\n<p><font color=\"red\">绘制直线这里有一点需要注意，即需要设置我们Background的锚点为左上角，因为RenderTarget的原点在左上角，只有这样鼠标点击的位置才会和绘制的位置匹配，否则会出现位置偏移的问题。</font></p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180848.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"3-清除绘制内容\"><a href=\"#3-清除绘制内容\" class=\"headerlink\" title=\"3.清除绘制内容\"></a>3.清除绘制内容</h2><p>考虑到会有绘制出错的情况，所以添加一个清除绘制内容的功能。清除绘制内容原理比较简单，只需要清除RenderTarget缓存和PolygonPoints点击即可。</p>\n<p>这里我绑定在Delete按钮的OnClicked事件下。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180854.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"4-结束绘制\"><a href=\"#4-结束绘制\" class=\"headerlink\" title=\"4.结束绘制\"></a>4.结束绘制</h2><p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180859.png\" alt=\"在这里插入图片描述\"></p>\n<p>结束绘制之后就要开始计算框选内容了，SureSelect函数负责这方面的实现，计算后面讲解。</p>\n<p>结束绘制之后需要将最后一个点和第一个点连接来，确保多边形是一个封闭的多边形。EndPaint函数负责这个功能的实现。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180904.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"三、计算\"><a href=\"#三、计算\" class=\"headerlink\" title=\"三、计算\"></a>三、计算</h1><p>计算这里需要用到C++了，在蓝图的SureSelect函数里调用C++的计算函数。</p>\n<p>创建一个继承自Actor的C++类，并命名为CustomSelectActor，下面贴出C++源码：</p>\n<p><code>.h</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> once</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> LeastPointNum 4</span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> ActorSamplingPoints 9</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;Runtime/Engine/Classes/Kismet/GameplayStatics.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;Engine/World.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;GameFramework/Actor.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;EngineUtils.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;GameFramework/PlayerController.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;CoreMinimal.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;GameFramework/Actor.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;CustomSelectActor.generated.h&quot;</span></span><br><br>USTRUCT()<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">FBoxPointSet</span></span><br><span class=\"hljs-class\">&#123;</span><br>\tGENERATED_USTRUCT_BODY()<br><span class=\"hljs-keyword\">public</span>:<br>\tTArray&lt;FVector2D&gt; points;<br>\tFBoxPointSet()<br>\t&#123;<br>\t\tpoints.Init(FVector2D(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>), <span class=\"hljs-number\">9</span>);<br>\t&#125;<br>&#125;;<br><br>UCLASS()<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CUSTOMSELECT_API</span> <span class=\"hljs-title\">ACustomSelectActor</span> :</span> <span class=\"hljs-keyword\">public</span> AActor<br>&#123;<br>\tGENERATED_BODY()<br>\t<br><span class=\"hljs-keyword\">public</span>:\t<br>\t<span class=\"hljs-keyword\">const</span> FVector BoundsPointMapping[<span class=\"hljs-number\">8</span>] =<br>\t&#123;<br>\t\tFVector(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>),<br>\t\tFVector(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">-1</span>),<br>\t\tFVector(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>),<br>\t\tFVector(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-1</span>),<br>\t\tFVector(<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>),<br>\t\tFVector(<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">-1</span>),<br>\t\tFVector(<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>),<br>\t\tFVector(<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-1</span>)<br>\t&#125;;<br><br><span class=\"hljs-keyword\">protected</span>:<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">BeginPlay</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">override</span></span>;<br><br><span class=\"hljs-keyword\">public</span>:\t<br>\tACustomSelectActor();<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Tick</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">float</span> DeltaTime)</span> <span class=\"hljs-keyword\">override</span></span>;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">GetMax</span><span class=\"hljs-params\">(TArray&lt;FVector2D&gt;&amp; points, <span class=\"hljs-keyword\">float</span>&amp; max_x, <span class=\"hljs-keyword\">float</span>&amp; max_y, <span class=\"hljs-keyword\">int</span>&amp; len)</span></span>;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">GetMin</span><span class=\"hljs-params\">(TArray&lt;FVector2D&gt;&amp; points, <span class=\"hljs-keyword\">float</span>&amp; min_x, <span class=\"hljs-keyword\">float</span>&amp; min_y, <span class=\"hljs-keyword\">int</span>&amp; len)</span></span>;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">SpwanVertArr</span><span class=\"hljs-params\">(TArray&lt;FVector2D&gt;&amp; polygonPoints, TArray&lt;<span class=\"hljs-keyword\">float</span>&gt;&amp; vertx, TArray&lt;<span class=\"hljs-keyword\">float</span>&gt;&amp; verty, <span class=\"hljs-keyword\">int</span>&amp; len)</span></span>;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">PNPoly</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> nvert, TArray&lt;<span class=\"hljs-keyword\">float</span>&gt; vertx, TArray&lt;<span class=\"hljs-keyword\">float</span>&gt; verty, <span class=\"hljs-keyword\">float</span> testx, <span class=\"hljs-keyword\">float</span> testy)</span></span>;<br>\tUFUNCTION(BlueprintImplementableEvent)<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">ProjectWorldLocationToWidgetPosition</span><span class=\"hljs-params\">(APlayerController* player_ctrl, FVector worldLocation, FVector2D&amp; screenPosition)</span></span>;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">GetFBoxPointsSet</span><span class=\"hljs-params\">(</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t\tTArray&lt;FBoxPointSet&gt;&amp; fboxPointsArr,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t\tTArray&lt;AActor*&gt;&amp; actorArr,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t\tTSubclassOf&lt;AActor&gt;&amp; classFilter,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t\t<span class=\"hljs-keyword\">bool</span>&amp; bIncludeNonCollidingComponents,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t\tAPlayerController* player_ctrl)</span></span>;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">GetActorsRefByPointsSet</span><span class=\"hljs-params\">(</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t\tTArray&lt;AActor*&gt;&amp; outActors,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t\tTArray&lt;<span class=\"hljs-keyword\">float</span>&gt;&amp; vertx,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t\tTArray&lt;<span class=\"hljs-keyword\">float</span>&gt;&amp; verty,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t\tTArray&lt;FBoxPointSet&gt;&amp; fboxPointsArr,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t\tTArray&lt;AActor*&gt;&amp; actorArr,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t\tTArray&lt;FVector2D&gt;&amp; polygonPoints,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t\t<span class=\"hljs-keyword\">int</span>&amp; len)</span></span>;<br>\tUFUNCTION(BlueprintCallable, Category = <span class=\"hljs-string\">&quot;CustomSelect&quot;</span>)<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">CustomSelect</span><span class=\"hljs-params\">(</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t\tTArray&lt;AActor*&gt;&amp; outActors,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t\tTArray&lt;FVector2D&gt; polygonPoints,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t\tTSubclassOf&lt;AActor&gt; classFilter,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t\tAPlayerController * player_ctrl,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t\t<span class=\"hljs-keyword\">bool</span> bIncludeNonCollidingComponents)</span></span>;<br>\tUFUNCTION(BlueprintCallable, Category = <span class=\"hljs-string\">&quot;CustomSelect&quot;</span>)<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">float</span> <span class=\"hljs-title\">CompuePolygonArea</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> TArray&lt;FVector2D&gt; polygonPoints)</span></span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure>\n<p><code>.cpp</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;CustomSelectActor.h&quot;</span></span><br><br>ACustomSelectActor::ACustomSelectActor()<br>&#123;<br>\tPrimaryActorTick.bCanEverTick = <span class=\"hljs-literal\">false</span>;<br><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ACustomSelectActor::BeginPlay</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tSuper::BeginPlay();<br>\t<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ACustomSelectActor::Tick</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">float</span> DeltaTime)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tSuper::Tick(DeltaTime);<br><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ACustomSelectActor::GetMax</span><span class=\"hljs-params\">(TArray&lt;FVector2D&gt;&amp; points, <span class=\"hljs-keyword\">float</span>&amp; max_x, <span class=\"hljs-keyword\">float</span>&amp; max_y, <span class=\"hljs-keyword\">int</span>&amp; len)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tmax_x = points[<span class=\"hljs-number\">0</span>].X;<br>\tmax_y = points[<span class=\"hljs-number\">0</span>].Y;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; len; i++)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (max_x &lt; points[i].X)<br>\t\t&#123;<br>\t\t\tmax_x = points[i].X;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span> (max_y &lt; points[i].Y)<br>\t\t&#123;<br>\t\t\tmax_y = points[i].Y;<br>\t\t&#125;<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ACustomSelectActor::GetMin</span><span class=\"hljs-params\">(TArray&lt;FVector2D&gt;&amp; points, <span class=\"hljs-keyword\">float</span>&amp; min_x, <span class=\"hljs-keyword\">float</span>&amp; min_y, <span class=\"hljs-keyword\">int</span>&amp; len)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tmin_x = points[<span class=\"hljs-number\">0</span>].X;<br>\tmin_y = points[<span class=\"hljs-number\">0</span>].Y;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; len; i++)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (min_x &gt; points[i].X)<br>\t\t&#123;<br>\t\t\tmin_x = points[i].X;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span> (min_y &gt; points[i].Y)<br>\t\t&#123;<br>\t\t\tmin_y = points[i].Y;<br>\t\t&#125;<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ACustomSelectActor::SpwanVertArr</span><span class=\"hljs-params\">(TArray&lt;FVector2D&gt;&amp; polygonPoints, TArray&lt;<span class=\"hljs-keyword\">float</span>&gt;&amp; vertx, TArray&lt;<span class=\"hljs-keyword\">float</span>&gt;&amp; verty, <span class=\"hljs-keyword\">int</span>&amp; len)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; len; i++)<br>\t&#123;<br>\t\tvertx.Add(polygonPoints[i].X);<br>\t\tverty.Add(polygonPoints[i].Y);<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">ACustomSelectActor::PNPoly</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> nvert, TArray&lt;<span class=\"hljs-keyword\">float</span>&gt; vertx, TArray&lt;<span class=\"hljs-keyword\">float</span>&gt; verty, <span class=\"hljs-keyword\">float</span> testx, <span class=\"hljs-keyword\">float</span> testy)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">bool</span> ret = <span class=\"hljs-literal\">false</span>;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>, j = nvert - <span class=\"hljs-number\">1</span>; i &lt; nvert; j = i++)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (((verty[i] &gt; testy) != (verty[j] &gt; testy)) &amp;&amp; (testx &lt; (vertx[j] - vertx[i]) * (testy - verty[i]) / (verty[j] - verty[i]) + vertx[i]))<br>\t\t&#123;<br>\t\t\tret = !ret;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> ret;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ACustomSelectActor::GetFBoxPointsSet</span><span class=\"hljs-params\">(</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\tTArray&lt;FBoxPointSet&gt;&amp; fboxPointsArr,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\tTArray&lt;AActor*&gt;&amp; actorArr,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\tTSubclassOf&lt;AActor&gt;&amp; classFilter,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t<span class=\"hljs-keyword\">bool</span>&amp; bIncludeNonCollidingComponents,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\tAPlayerController * player_ctrl)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (TActorIterator&lt;AActor&gt; Itr(GWorld-&gt;GetWorld(), classFilter); Itr; ++Itr)<br>\t&#123;<br>\t\tAActor* EachActor = *Itr;<br>\t\t<span class=\"hljs-keyword\">const</span> FBox EachActorBounds = Cast&lt;AActor&gt;(EachActor)-&gt;GetComponentsBoundingBox(bIncludeNonCollidingComponents);<br>\t\t<span class=\"hljs-keyword\">const</span> FVector BoxCenter = EachActorBounds.GetCenter();<br>\t\t<span class=\"hljs-keyword\">const</span> FVector BoxExtents = EachActorBounds.GetExtent();<br>\t\t<span class=\"hljs-function\">FBox2D <span class=\"hljs-title\">ActorBox2D</span><span class=\"hljs-params\">(ForceInit)</span></span>;<br>\t\tfboxPointsArr.Add(FBoxPointSet());<br>\t\t<span class=\"hljs-keyword\">for</span> (uint8 BoundsPointItr = <span class=\"hljs-number\">0</span>; BoundsPointItr &lt; <span class=\"hljs-number\">8</span>; BoundsPointItr++)<br>\t\t&#123;<br>\t\t\tFVector2D ScreenPos;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (ProjectWorldLocationToWidgetPosition(player_ctrl, BoxCenter + (BoundsPointMapping[BoundsPointItr] * BoxExtents), ScreenPos))<br>\t\t\t&#123;<br>\t\t\t\tActorBox2D += ScreenPos;<br>\t\t\t\tfboxPointsArr[i].points[BoundsPointItr + <span class=\"hljs-number\">1</span>] = ScreenPos;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tfboxPointsArr[i].points[<span class=\"hljs-number\">0</span>] = ActorBox2D.GetCenter();<br>\t\tactorArr.Add(EachActor);<br>\t\ti++;<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ACustomSelectActor::GetActorsRefByPointsSet</span><span class=\"hljs-params\">(</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\tTArray&lt;AActor*&gt;&amp; outActors,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\tTArray&lt;<span class=\"hljs-keyword\">float</span>&gt;&amp; vertx,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\tTArray&lt;<span class=\"hljs-keyword\">float</span>&gt;&amp; verty,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\tTArray&lt;FBoxPointSet&gt;&amp; fboxPointsArr,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\tTArray&lt;AActor*&gt;&amp; actorArr,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\tTArray&lt;FVector2D&gt;&amp; polygonPoints,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t<span class=\"hljs-keyword\">int</span>&amp; len)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">int</span> fboxlen = fboxPointsArr.Num();<br>\t<span class=\"hljs-keyword\">int</span> pointslen = polygonPoints.Num();<br>\t<span class=\"hljs-keyword\">float</span> max_x = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">float</span> max_y = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">float</span> min_x = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">float</span> min_y = <span class=\"hljs-number\">0</span>;<br>\tGetMax(polygonPoints, max_x, max_y, len);<br>\tGetMin(polygonPoints, min_x, min_y, len);<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; fboxlen; i++)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; ActorSamplingPoints; j++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (fboxPointsArr[i].points[j].X&lt;min_x || fboxPointsArr[i].points[j].X&gt;max_x ||<br>\t\t\t\tfboxPointsArr[i].points[j].Y&lt;min_y || fboxPointsArr[i].points[j].Y&gt;max_y)<br>\t\t\t&#123;<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t\tj = ActorSamplingPoints;<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (PNPoly(len, vertx, verty, fboxPointsArr[i].points[j].X, fboxPointsArr[i].points[j].Y))<br>\t\t\t&#123;<br>\t\t\t\toutActors.Add(actorArr[i]);<br>\t\t\t\tj = ActorSamplingPoints;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">ACustomSelectActor::CustomSelect</span><span class=\"hljs-params\">(</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\tTArray&lt;AActor*&gt;&amp; outActors,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\tTArray&lt;FVector2D&gt; polygonPoints,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\tTSubclassOf&lt;AActor&gt; classFilter,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\tAPlayerController * player_ctrl,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">\t<span class=\"hljs-keyword\">bool</span> bIncludeNonCollidingComponents)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">int</span> len = polygonPoints.Num();<br>\t<span class=\"hljs-keyword\">if</span> (len &lt; LeastPointNum)<br>\t&#123;<br>\t\tUE_LOG(LogTemp, Warning, TEXT(<span class=\"hljs-string\">&quot;Polygon has too few points&quot;</span>));<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t&#125;<br>\tTArray&lt;<span class=\"hljs-keyword\">float</span>&gt; vertx;<br>\tTArray&lt;<span class=\"hljs-keyword\">float</span>&gt; verty;<br>\tSpwanVertArr(polygonPoints, vertx, verty, len);<br>\tTArray&lt;AActor*&gt; actorArr;<br>\tTArray&lt;FBoxPointSet&gt; fboxPointsArr;<br>\tGetFBoxPointsSet(fboxPointsArr, actorArr, classFilter, bIncludeNonCollidingComponents, player_ctrl);<br>\tGetActorsRefByPointsSet(outActors, vertx, verty, fboxPointsArr, actorArr, polygonPoints, len);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">float</span> <span class=\"hljs-title\">ACustomSelectActor::CompuePolygonArea</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> TArray&lt;FVector2D&gt; polygonPoints)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">int</span> point_num = polygonPoints.Num();<br>\t<span class=\"hljs-keyword\">if</span> (point_num &lt; <span class=\"hljs-number\">3</span>)<br>\t&#123;<br>\t\tUE_LOG(LogTemp, Warning, TEXT(<span class=\"hljs-string\">&quot;The area is not polygon!&quot;</span>));<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0.0</span>;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">double</span> s = polygonPoints[<span class=\"hljs-number\">0</span>].Y * (polygonPoints[point_num - <span class=\"hljs-number\">1</span>].X - polygonPoints[<span class=\"hljs-number\">1</span>].X);<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; point_num; ++i)<br>\t\ts += polygonPoints[i].Y * (polygonPoints[i - <span class=\"hljs-number\">1</span>].X - polygonPoints[(i + <span class=\"hljs-number\">1</span>) % point_num].X);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">fabs</span>(s / <span class=\"hljs-number\">2.0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>\n<ul>\n<li><p><code>BoundsPointMapping[8]</code>用于确定场景中Actor的边界盒子的8个点。</p>\n</li>\n<li><p>结构体FBoxPointSet是用来存储采样点集的数据结构，这里我取Actor边界盒子的8个点加中点一共9个点作为采样点集。</p>\n</li>\n<li><p>GetMax和GetMin计算多边形点集的横纵坐标的最大值和最小值。</p>\n</li>\n<li><p>SpawnVertArr负责将多边形点集分成横坐标点集和纵坐标点集。</p>\n</li>\n<li><p>PNPoly函数使用PNPoly算法判断一个点是否在多边形内部。</p>\n</li>\n<li><p>ProjectWorldLocationToWidgetPosition函数是一个由C++父类声明，由蓝图子类实现的函数，负责将场景中的Actor的边界盒子的点的空间坐标投影到屏幕坐标。之所以使用这种方式是因为ProjectWorldLocationToWidgetPosition蓝图节点没有C++版本，而必须使用ProjectWorldLocationToWidgetPosition蓝图节点的原因是ProjectWorldLocationToWidgetPosition蓝图节点投影出来的坐标会根据屏幕尺寸变化而自动适应，其他的空间坐标转屏幕坐标的蓝图节点在非全屏与全屏下会出现位置偏移。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180923.png\" alt=\"在这里插入图片描述\"><br>所以这里需要创建一个继承自CustomSelectActor的蓝图子类来重写ProjectWorldLocationToWidgetPosition函数。</p>\n</li>\n<li><p>GetFBoxPointsSet函数负责获取世界中所有Actor的采样点集。</p>\n</li>\n<li><p>GetActorsRefByPointsSet函数负责使用PNPoly函数取在多边形内部的Actor的引用。</p>\n</li>\n<li><p>CustomSelect函数否则暴漏给蓝图提供数据输入输出的接口。</p>\n</li>\n<li><p>CompuePolygonArea函数负责计算多边形的面积，目前还有一些问题，暂时不用理睬。</p>\n</li>\n</ul>\n<p>至此多边形框选功能就完全实现了。来看一下效果：</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180929.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180935.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180942.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"四、将功能包成UE4插件\"><a href=\"#四、将功能包成UE4插件\" class=\"headerlink\" title=\"四、将功能包成UE4插件\"></a>四、将功能包成UE4插件</h1><p>如果需要将功能打包成插件，那么就需要将CustomSelectActor的C++类创建在插件里。</p>\n<h2 id=\"1-创建一个空插件\"><a href=\"#1-创建一个空插件\" class=\"headerlink\" title=\"1.创建一个空插件\"></a>1.创建一个空插件</h2><p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180952.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180958.png\" alt=\"在这里插入图片描述\"></p>\n<p>创建之后需要在VS中编一下项目，然后关闭引擎，重新打开项目，以便引擎重新加载dll文件，因为插件不属于引擎的一部分，所以引擎没办法直接热加载插件内容。</p>\n<h2 id=\"2-在插件文件夹下创建C-类\"><a href=\"#2-在插件文件夹下创建C-类\" class=\"headerlink\" title=\"2.在插件文件夹下创建C++类\"></a>2.在插件文件夹下创建C++类</h2><p>我们需要将CustomSelectActor类创建在插件文件夹下，创建好空插件后，再创建C++类时可以选择创建文件夹。</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514181004.png\" alt=\"在这里插入图片描述\"><br>然后按一、二、三的步骤实现功能即可。</p>\n<h2 id=\"3-打包插件\"><a href=\"#3-打包插件\" class=\"headerlink\" title=\"3.打包插件\"></a>3.打包插件</h2><p>进入插件管理点集打包</p>\n<p><img src=\"https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514181009.png\" alt=\"在这里插入图片描述\"><br>至此插件就打包好了。</p>\n<p>参考博客：<br><a href=\"https://blog.csdn.net/weixin_36369675/article/details/88419361\">https://blog.csdn.net/weixin_36369675/article/details/88419361</a><br><a href=\"https://www.cnblogs.com/anningwang/p/7581545.html\">https://www.cnblogs.com/anningwang/p/7581545.html</a><br><a href=\"https://www.cnblogs.com/TenosDoIt/p/4047211.html\">https://www.cnblogs.com/TenosDoIt/p/4047211.html</a></p>"}],"PostAsset":[{"_id":"source/_posts/【C++】C++中的四种转换类型/Snipaste_2019-09-12_10-11-10.png","slug":"Snipaste_2019-09-12_10-11-10.png","post":"ckk9hocah0006dwr78y3x38ht","modified":0,"renderable":0},{"_id":"source/_posts/【C++】C++中的四种转换类型/Snipaste_2019-09-12_10-44-16.png","slug":"Snipaste_2019-09-12_10-44-16.png","post":"ckk9hocah0006dwr78y3x38ht","modified":0,"renderable":0},{"_id":"source/_posts/【C++】C++中的四种转换类型/Snipaste_2019-09-12_11-06-11.png","slug":"Snipaste_2019-09-12_11-06-11.png","post":"ckk9hocah0006dwr78y3x38ht","modified":0,"renderable":0},{"_id":"source/_posts/【C++】C++中的四种转换类型/Snipaste_2019-09-12_11-51-30.png","slug":"Snipaste_2019-09-12_11-51-30.png","post":"ckk9hocah0006dwr78y3x38ht","modified":0,"renderable":0},{"_id":"source/_posts/【C++】C++中的四种转换类型/Snipaste_2019-09-12_16-32-44.png","slug":"Snipaste_2019-09-12_16-32-44.png","post":"ckk9hocah0006dwr78y3x38ht","modified":0,"renderable":0},{"_id":"source/_posts/【C++】C++函数模板的实现机制剖析/Snipaste_2019-10-03_16-51-51.png","slug":"Snipaste_2019-10-03_16-51-51.png","post":"ckk9hocaj000adwr7ajrd7mo3","modified":0,"renderable":0},{"_id":"source/_posts/【C++】C++函数模板的实现机制剖析/Snipaste_2019-10-03_19-57-21.png","slug":"Snipaste_2019-10-03_19-57-21.png","post":"ckk9hocaj000adwr7ajrd7mo3","modified":0,"renderable":0},{"_id":"source/_posts/【C++】C++函数模板的实现机制剖析/Snipaste_2019-10-03_20-07-41.png","slug":"Snipaste_2019-10-03_20-07-41.png","post":"ckk9hocaj000adwr7ajrd7mo3","modified":0,"renderable":0},{"_id":"source/_posts/【C++】C++函数模板的实现机制剖析/Snipaste_2019-10-03_20-08-21.png","slug":"Snipaste_2019-10-03_20-08-21.png","post":"ckk9hocaj000adwr7ajrd7mo3","modified":0,"renderable":0},{"_id":"source/_posts/【C++】C++函数模板的实现机制剖析/Snipaste_2019-10-03_20-12-24.png","slug":"Snipaste_2019-10-03_20-12-24.png","post":"ckk9hocaj000adwr7ajrd7mo3","modified":0,"renderable":0},{"_id":"source/_posts/【C++】全局变量、静态全局变量、局部变量与静态局部变量/Snipaste_2019-09-11_21-35-55.png","slug":"Snipaste_2019-09-11_21-35-55.png","post":"ckk9hocal000gdwr7eaqfdjo9","modified":0,"renderable":0},{"_id":"source/_posts/【C++】全局变量、静态全局变量、局部变量与静态局部变量/Snipaste_2019-09-11_21-36-28.png","slug":"Snipaste_2019-09-11_21-36-28.png","post":"ckk9hocal000gdwr7eaqfdjo9","modified":0,"renderable":0},{"_id":"source/_posts/【C++】全局变量、静态全局变量、局部变量与静态局部变量/Snipaste_2019-09-11_21-36-38.png","slug":"Snipaste_2019-09-11_21-36-38.png","post":"ckk9hocal000gdwr7eaqfdjo9","modified":0,"renderable":0},{"_id":"source/_posts/【C++】C++面向对象模型初探/Snipaste_2019-10-02_09-07-09.png","slug":"Snipaste_2019-10-02_09-07-09.png","post":"ckk9hocak000bdwr746nx9ti7","modified":0,"renderable":0},{"_id":"source/_posts/【Linux】Linux基础/1.png","slug":"1.png","post":"ckk9hocao000mdwr79a1l3si1","modified":0,"renderable":0},{"_id":"source/_posts/【Linux】Linux基础/2.png","slug":"2.png","post":"ckk9hocao000mdwr79a1l3si1","modified":0,"renderable":0},{"_id":"source/_posts/【Linux】Linux基础/3.png","slug":"3.png","post":"ckk9hocao000mdwr79a1l3si1","modified":0,"renderable":0},{"_id":"source/_posts/【Linux】Linux基础/4.png","slug":"4.png","post":"ckk9hocao000mdwr79a1l3si1","modified":0,"renderable":0},{"_id":"source/_posts/【Linux】Linux基础/5.png","slug":"5.png","post":"ckk9hocao000mdwr79a1l3si1","modified":0,"renderable":0},{"_id":"source/_posts/【Linux】Linux基础/6.png","slug":"6.png","post":"ckk9hocao000mdwr79a1l3si1","modified":0,"renderable":0},{"_id":"source/_posts/【Linux】Linux基础/7.png","slug":"7.png","post":"ckk9hocao000mdwr79a1l3si1","modified":0,"renderable":0},{"_id":"source/_posts/【Linux】Linux基础/8.png","slug":"8.png","post":"ckk9hocao000mdwr79a1l3si1","modified":0,"renderable":0},{"_id":"source/_posts/【Linux】Linux基础/9.png","slug":"9.png","post":"ckk9hocao000mdwr79a1l3si1","modified":0,"renderable":0},{"_id":"source/_posts/【Lua】Lua基础/Lua基础1.png","slug":"Lua基础1.png","post":"ckk9hocaq000sdwr7hpbtfm78","modified":0,"renderable":0},{"_id":"source/_posts/【Lua】Lua基础/Lua基础2.png","slug":"Lua基础2.png","post":"ckk9hocaq000sdwr7hpbtfm78","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-25_10-33-38.png","slug":"Snipaste_2019-10-25_10-33-38.png","post":"ckk9hocas0011dwr7fpb7a6l9","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-25_10-53-07.png","slug":"Snipaste_2019-10-25_10-53-07.png","post":"ckk9hocas0011dwr7fpb7a6l9","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-25_10-57-11.png","slug":"Snipaste_2019-10-25_10-57-11.png","post":"ckk9hocas0011dwr7fpb7a6l9","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-25_11-02-10.png","slug":"Snipaste_2019-10-25_11-02-10.png","post":"ckk9hocas0011dwr7fpb7a6l9","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-25_11-10-28.png","slug":"Snipaste_2019-10-25_11-10-28.png","post":"ckk9hocas0011dwr7fpb7a6l9","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-25_11-17-59.png","slug":"Snipaste_2019-10-25_11-17-59.png","post":"ckk9hocas0011dwr7fpb7a6l9","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-25_11-21-18.png","slug":"Snipaste_2019-10-25_11-21-18.png","post":"ckk9hocas0011dwr7fpb7a6l9","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-25_11-26-07.png","slug":"Snipaste_2019-10-25_11-26-07.png","post":"ckk9hocas0011dwr7fpb7a6l9","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-25_11-30-52.png","slug":"Snipaste_2019-10-25_11-30-52.png","post":"ckk9hocas0011dwr7fpb7a6l9","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-25_11-39-53.png","slug":"Snipaste_2019-10-25_11-39-53.png","post":"ckk9hocas0011dwr7fpb7a6l9","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-25_11-42-14.png","slug":"Snipaste_2019-10-25_11-42-14.png","post":"ckk9hocas0011dwr7fpb7a6l9","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-25_11-46-47.png","slug":"Snipaste_2019-10-25_11-46-47.png","post":"ckk9hocas0011dwr7fpb7a6l9","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-25_11-50-37.png","slug":"Snipaste_2019-10-25_11-50-37.png","post":"ckk9hocas0011dwr7fpb7a6l9","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-25_11-53-42.png","slug":"Snipaste_2019-10-25_11-53-42.png","post":"ckk9hocas0011dwr7fpb7a6l9","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-25_11-56-15.png","slug":"Snipaste_2019-10-25_11-56-15.png","post":"ckk9hocas0011dwr7fpb7a6l9","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-25_13-12-40.png","slug":"Snipaste_2019-10-25_13-12-40.png","post":"ckk9hocas0011dwr7fpb7a6l9","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-25_13-19-47.png","slug":"Snipaste_2019-10-25_13-19-47.png","post":"ckk9hocas0011dwr7fpb7a6l9","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-25_13-32-38.png","slug":"Snipaste_2019-10-25_13-32-38.png","post":"ckk9hocas0011dwr7fpb7a6l9","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-28_17-04-19.png","slug":"Snipaste_2019-10-28_17-04-19.png","post":"ckk9hocas0011dwr7fpb7a6l9","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-28_17-26-35.png","slug":"Snipaste_2019-10-28_17-26-35.png","post":"ckk9hocas0011dwr7fpb7a6l9","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-28_17-28-37.png","slug":"Snipaste_2019-10-28_17-28-37.png","post":"ckk9hocas0011dwr7fpb7a6l9","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4组件/Snipaste_2019-10-29_09-09-05.png","slug":"Snipaste_2019-10-29_09-09-05.png","post":"ckk9hocas0011dwr7fpb7a6l9","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4连接MySQL/Snipaste_2019-10-23_10-36-25.png","slug":"Snipaste_2019-10-23_10-36-25.png","post":"ckk9hocau001adwr74wos09iu","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4连接MySQL/Snipaste_2019-11-05_17-54-58.png","slug":"Snipaste_2019-11-05_17-54-58.png","post":"ckk9hocau001adwr74wos09iu","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4连接MySQL/Snipaste_2019-11-05_18-02-53.png","slug":"Snipaste_2019-11-05_18-02-53.png","post":"ckk9hocau001adwr74wos09iu","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4连接MySQL/Snipaste_2019-11-05_18-14-47.png","slug":"Snipaste_2019-11-05_18-14-47.png","post":"ckk9hocau001adwr74wos09iu","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4连接MySQL/Snipaste_2019-11-05_18-17-44.png","slug":"Snipaste_2019-11-05_18-17-44.png","post":"ckk9hocau001adwr74wos09iu","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4连接MySQL/Snipaste_2019-11-05_18-26-48.png","slug":"Snipaste_2019-11-05_18-26-48.png","post":"ckk9hocau001adwr74wos09iu","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4连接MySQL/Snipaste_2019-11-05_18-27-48.png","slug":"Snipaste_2019-11-05_18-27-48.png","post":"ckk9hocau001adwr74wos09iu","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4连接MySQL/Snipaste_2019-11-05_18-34-52.png","slug":"Snipaste_2019-11-05_18-34-52.png","post":"ckk9hocau001adwr74wos09iu","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4连接MySQL/Snipaste_2019-11-05_19-12-00.png","slug":"Snipaste_2019-11-05_19-12-00.png","post":"ckk9hocau001adwr74wos09iu","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4连接MySQL/Snipaste_2019-11-05_19-14-07.png","slug":"Snipaste_2019-11-05_19-14-07.png","post":"ckk9hocau001adwr74wos09iu","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4联级粒子系统/Snipaste_2019-11-14_09-41-14.png","slug":"Snipaste_2019-11-14_09-41-14.png","post":"ckk9hocat0014dwr7cr2d29ag","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4联级粒子系统/Snipaste_2019-11-14_10-14-27.png","slug":"Snipaste_2019-11-14_10-14-27.png","post":"ckk9hocat0014dwr7cr2d29ag","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4联级粒子系统/Snipaste_2019-11-14_10-25-52.png","slug":"Snipaste_2019-11-14_10-25-52.png","post":"ckk9hocat0014dwr7cr2d29ag","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4联级粒子系统/Snipaste_2019-11-14_10-51-44.png","slug":"Snipaste_2019-11-14_10-51-44.png","post":"ckk9hocat0014dwr7cr2d29ag","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4联级粒子系统/Snipaste_2019-11-14_10-58-31.png","slug":"Snipaste_2019-11-14_10-58-31.png","post":"ckk9hocat0014dwr7cr2d29ag","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4联级粒子系统/Snipaste_2019-11-14_11-03-35.png","slug":"Snipaste_2019-11-14_11-03-35.png","post":"ckk9hocat0014dwr7cr2d29ag","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4联级粒子系统/Snipaste_2019-11-14_11-10-41.png","slug":"Snipaste_2019-11-14_11-10-41.png","post":"ckk9hocat0014dwr7cr2d29ag","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4联级粒子系统/Snipaste_2019-11-14_11-14-32.png","slug":"Snipaste_2019-11-14_11-14-32.png","post":"ckk9hocat0014dwr7cr2d29ag","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4联级粒子系统/Snipaste_2019-11-14_11-50-46.png","slug":"Snipaste_2019-11-14_11-50-46.png","post":"ckk9hocat0014dwr7cr2d29ag","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4联级粒子系统/Snipaste_2019-11-14_19-47-55.png","slug":"Snipaste_2019-11-14_19-47-55.png","post":"ckk9hocat0014dwr7cr2d29ag","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4联级粒子系统/Snipaste_2019-11-14_19-48-16.png","slug":"Snipaste_2019-11-14_19-48-16.png","post":"ckk9hocat0014dwr7cr2d29ag","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4联级粒子系统/Snipaste_2019-11-15_15-05-48.png","slug":"Snipaste_2019-11-15_15-05-48.png","post":"ckk9hocat0014dwr7cr2d29ag","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4联级粒子系统/Snipaste_2019-11-15_15-41-29.png","slug":"Snipaste_2019-11-15_15-41-29.png","post":"ckk9hocat0014dwr7cr2d29ag","modified":0,"renderable":0},{"_id":"source/_posts/【Unity3d】Lightmap/Unity_Lightmap.png","slug":"Unity_Lightmap.png","post":"ckk9hocaw001gdwr7gjee96ri","modified":0,"renderable":0},{"_id":"source/_posts/【Unity3d】Space/Unity3d_Space.png","slug":"Unity3d_Space.png","post":"ckk9hocax001jdwr7fgmhft5u","modified":0,"renderable":0},{"_id":"source/_posts/【Unity3d】Unity常用技巧笔记/Snipaste_2019-08-27_11-35-00.png","slug":"Snipaste_2019-08-27_11-35-00.png","post":"ckk9hocay001mdwr78pvk8fc4","modified":0,"renderable":0},{"_id":"source/_posts/【程序编程】程序编程高级/程序编程高级.png","slug":"程序编程高级.png","post":"ckk9hocb30024dwr7gbbne02d","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190414.jpg","slug":"QQ图片20191012190414.jpg","post":"ckk9hocb20021dwr72cg209tu","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190444.jpg","slug":"QQ图片20191012190444.jpg","post":"ckk9hocb20021dwr72cg209tu","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190448.jpg","slug":"QQ图片20191012190448.jpg","post":"ckk9hocb20021dwr72cg209tu","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190452.jpg","slug":"QQ图片20191012190452.jpg","post":"ckk9hocb20021dwr72cg209tu","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190456.jpg","slug":"QQ图片20191012190456.jpg","post":"ckk9hocb20021dwr72cg209tu","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190500.jpg","slug":"QQ图片20191012190500.jpg","post":"ckk9hocb20021dwr72cg209tu","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190504.jpg","slug":"QQ图片20191012190504.jpg","post":"ckk9hocb20021dwr72cg209tu","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190513.jpg","slug":"QQ图片20191012190513.jpg","post":"ckk9hocb20021dwr72cg209tu","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190518.jpg","slug":"QQ图片20191012190518.jpg","post":"ckk9hocb20021dwr72cg209tu","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190532.jpg","slug":"QQ图片20191012190532.jpg","post":"ckk9hocb20021dwr72cg209tu","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190538.jpg","slug":"QQ图片20191012190538.jpg","post":"ckk9hocb20021dwr72cg209tu","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190542.jpg","slug":"QQ图片20191012190542.jpg","post":"ckk9hocb20021dwr72cg209tu","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190547.jpg","slug":"QQ图片20191012190547.jpg","post":"ckk9hocb20021dwr72cg209tu","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190552.jpg","slug":"QQ图片20191012190552.jpg","post":"ckk9hocb20021dwr72cg209tu","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190556.jpg","slug":"QQ图片20191012190556.jpg","post":"ckk9hocb20021dwr72cg209tu","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190600.jpg","slug":"QQ图片20191012190600.jpg","post":"ckk9hocb20021dwr72cg209tu","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190604.jpg","slug":"QQ图片20191012190604.jpg","post":"ckk9hocb20021dwr72cg209tu","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190607.jpg","slug":"QQ图片20191012190607.jpg","post":"ckk9hocb20021dwr72cg209tu","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190612.jpg","slug":"QQ图片20191012190612.jpg","post":"ckk9hocb20021dwr72cg209tu","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190616.jpg","slug":"QQ图片20191012190616.jpg","post":"ckk9hocb20021dwr72cg209tu","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190622.jpg","slug":"QQ图片20191012190622.jpg","post":"ckk9hocb20021dwr72cg209tu","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190626.jpg","slug":"QQ图片20191012190626.jpg","post":"ckk9hocb20021dwr72cg209tu","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190630.jpg","slug":"QQ图片20191012190630.jpg","post":"ckk9hocb20021dwr72cg209tu","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190634.jpg","slug":"QQ图片20191012190634.jpg","post":"ckk9hocb20021dwr72cg209tu","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190638.jpg","slug":"QQ图片20191012190638.jpg","post":"ckk9hocb20021dwr72cg209tu","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/QQ图片20191012190641.jpg","slug":"QQ图片20191012190641.jpg","post":"ckk9hocb20021dwr72cg209tu","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/Snipaste_2019-09-08_09-15-55.png","slug":"Snipaste_2019-09-08_09-15-55.png","post":"ckk9hocb20021dwr72cg209tu","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/Snipaste_2019-09-08_09-23-19.png","slug":"Snipaste_2019-09-08_09-23-19.png","post":"ckk9hocb20021dwr72cg209tu","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/Snipaste_2019-09-08_09-28-22.png","slug":"Snipaste_2019-09-08_09-28-22.png","post":"ckk9hocb20021dwr72cg209tu","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在武汉跑秋招的日子/Snipaste_2019-09-08_09-34-22.png","slug":"Snipaste_2019-09-08_09-34-22.png","post":"ckk9hocb20021dwr72cg209tu","modified":0,"renderable":0},{"_id":"source/_posts/【C++】C++STL标准模板库/Snipaste_2019-10-06_10-41-56.png","slug":"Snipaste_2019-10-06_10-41-56.png","post":"ckk9hocbh003edwr73uj5h7zl","modified":0,"renderable":0},{"_id":"source/_posts/【C++】C++STL标准模板库/Snipaste_2019-10-06_14-36-13.png","slug":"Snipaste_2019-10-06_14-36-13.png","post":"ckk9hocbh003edwr73uj5h7zl","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-24_09-41-27.png","slug":"Snipaste_2019-10-24_09-41-27.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-24_09-51-55.png","slug":"Snipaste_2019-10-24_09-51-55.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-24_10-45-29.png","slug":"Snipaste_2019-10-24_10-45-29.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-24_10-53-06.png","slug":"Snipaste_2019-10-24_10-53-06.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-24_10-53-34.png","slug":"Snipaste_2019-10-24_10-53-34.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-24_11-09-34.png","slug":"Snipaste_2019-10-24_11-09-34.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-24_11-12-38.png","slug":"Snipaste_2019-10-24_11-12-38.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-24_14-55-47.png","slug":"Snipaste_2019-10-24_14-55-47.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-24_15-11-12.png","slug":"Snipaste_2019-10-24_15-11-12.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-25_17-18-23.png","slug":"Snipaste_2019-10-25_17-18-23.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-25_17-23-07.png","slug":"Snipaste_2019-10-25_17-23-07.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-25_17-23-27.png","slug":"Snipaste_2019-10-25_17-23-27.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-25_17-36-36.png","slug":"Snipaste_2019-10-25_17-36-36.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-31-16.png","slug":"Snipaste_2019-10-25_18-31-16.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-31-23.png","slug":"Snipaste_2019-10-25_18-31-23.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-31-36.png","slug":"Snipaste_2019-10-25_18-31-36.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-31-47.png","slug":"Snipaste_2019-10-25_18-31-47.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-39-15.png","slug":"Snipaste_2019-10-25_18-39-15.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-39-35.png","slug":"Snipaste_2019-10-25_18-39-35.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-39-52.png","slug":"Snipaste_2019-10-25_18-39-52.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-40-45.png","slug":"Snipaste_2019-10-25_18-40-45.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-40-54.png","slug":"Snipaste_2019-10-25_18-40-54.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-40-59.png","slug":"Snipaste_2019-10-25_18-40-59.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-25_19-04-57.png","slug":"Snipaste_2019-10-25_19-04-57.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-25_19-14-34.png","slug":"Snipaste_2019-10-25_19-14-34.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_10-58-33.png","slug":"Snipaste_2019-10-26_10-58-33.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-02-54.png","slug":"Snipaste_2019-10-26_11-02-54.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-21-48.png","slug":"Snipaste_2019-10-26_11-21-48.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-24-33.png","slug":"Snipaste_2019-10-26_11-24-33.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-37-55.png","slug":"Snipaste_2019-10-26_11-37-55.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-42-24.png","slug":"Snipaste_2019-10-26_11-42-24.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-46-46.png","slug":"Snipaste_2019-10-26_11-46-46.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-50-31.png","slug":"Snipaste_2019-10-26_11-50-31.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-53-49.png","slug":"Snipaste_2019-10-26_11-53-49.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-59-54.png","slug":"Snipaste_2019-10-26_11-59-54.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-07-44.png","slug":"Snipaste_2019-10-26_12-07-44.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-07-50.png","slug":"Snipaste_2019-10-26_12-07-50.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-12-59.png","slug":"Snipaste_2019-10-26_12-12-59.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-21-30.png","slug":"Snipaste_2019-10-26_12-21-30.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-25-34.png","slug":"Snipaste_2019-10-26_12-25-34.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-29-34.png","slug":"Snipaste_2019-10-26_12-29-34.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-30-00.png","slug":"Snipaste_2019-10-26_12-30-00.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_17-38-54.png","slug":"Snipaste_2019-10-26_17-38-54.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-26_19-59-29.png","slug":"Snipaste_2019-10-26_19-59-29.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-27_10-32-38.png","slug":"Snipaste_2019-10-27_10-32-38.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-27_10-35-51.png","slug":"Snipaste_2019-10-27_10-35-51.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-27_10-38-13.png","slug":"Snipaste_2019-10-27_10-38-13.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-27_11-01-39.png","slug":"Snipaste_2019-10-27_11-01-39.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-27_11-04-21.png","slug":"Snipaste_2019-10-27_11-04-21.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-27_11-28-43.png","slug":"Snipaste_2019-10-27_11-28-43.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-27_11-31-04.png","slug":"Snipaste_2019-10-27_11-31-04.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-28_15-51-30.png","slug":"Snipaste_2019-10-28_15-51-30.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-28_16-45-41.png","slug":"Snipaste_2019-10-28_16-45-41.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4蓝图基础/Snipaste_2019-10-28_17-00-10.png","slug":"Snipaste_2019-10-28_17-00-10.png","post":"ckk9hocbj003ldwr7e8jt77cw","modified":0,"renderable":0},{"_id":"source/_posts/【C++】C++高级/Snipaste_2019-09-14_09-39-52.png","slug":"Snipaste_2019-09-14_09-39-52.png","post":"ckk9hocbm003xdwr7encjdct0","modified":0,"renderable":0},{"_id":"source/_posts/【C++】C++高级/Snipaste_2019-09-14_16-29-43.png","slug":"Snipaste_2019-09-14_16-29-43.png","post":"ckk9hocbm003xdwr7encjdct0","modified":0,"renderable":0},{"_id":"source/_posts/【C++】C++高级/Snipaste_2019-10-01_16-21-15.png","slug":"Snipaste_2019-10-01_16-21-15.png","post":"ckk9hocbm003xdwr7encjdct0","modified":0,"renderable":0},{"_id":"source/_posts/【C++】C++高级/Snipaste_2019-10-01_16-52-53.png","slug":"Snipaste_2019-10-01_16-52-53.png","post":"ckk9hocbm003xdwr7encjdct0","modified":0,"renderable":0},{"_id":"source/_posts/【C++】C++高级/Snipaste_2019-10-02_15-50-39.png","slug":"Snipaste_2019-10-02_15-50-39.png","post":"ckk9hocbm003xdwr7encjdct0","modified":0,"renderable":0},{"_id":"source/_posts/【C++】C++高级/Snipaste_2019-10-02_16-10-55.png","slug":"Snipaste_2019-10-02_16-10-55.png","post":"ckk9hocbm003xdwr7encjdct0","modified":0,"renderable":0},{"_id":"source/_posts/【C++】C++高级/Snipaste_2019-10-06_10-03-47.png","slug":"Snipaste_2019-10-06_10-03-47.png","post":"ckk9hocbm003xdwr7encjdct0","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在衡变的日子/QQ图片20210202211250.jpg","slug":"QQ图片20210202211250.jpg","post":"ckko29br50000pwr7hthl4tkw","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在衡变的日子/QQ图片20210202211257.jpg","slug":"QQ图片20210202211257.jpg","post":"ckko29br50000pwr7hthl4tkw","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在衡变的日子/QQ图片20210202211300.jpg","slug":"QQ图片20210202211300.jpg","post":"ckko29br50000pwr7hthl4tkw","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在衡变的日子/QQ图片20210202211306.jpg","slug":"QQ图片20210202211306.jpg","post":"ckko29br50000pwr7hthl4tkw","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在衡变的日子/QQ图片20210202211319.jpg","slug":"QQ图片20210202211319.jpg","post":"ckko29br50000pwr7hthl4tkw","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在衡变的日子/QQ图片20210202211323.jpg","slug":"QQ图片20210202211323.jpg","post":"ckko29br50000pwr7hthl4tkw","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在衡变的日子/QQ图片20210202211325.jpg","slug":"QQ图片20210202211325.jpg","post":"ckko29br50000pwr7hthl4tkw","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在衡变的日子/QQ图片20210202211328.jpg","slug":"QQ图片20210202211328.jpg","post":"ckko29br50000pwr7hthl4tkw","modified":0,"renderable":0},{"_id":"source/_posts/【日记】在衡变的日子/QQ图片20210202211910.jpg","slug":"QQ图片20210202211910.jpg","post":"ckko29br50000pwr7hthl4tkw","modified":0,"renderable":0},{"_id":"source/_posts/【Dev】DevExpress应用/Image_20201222193848.png","slug":"Image_20201222193848.png","post":"ckkou93hl0001ekr799tm2wkb","modified":0,"renderable":0},{"_id":"source/_posts/【Dev】DevExpress应用/Snipaste_2020-12-17_19-20-19.png","slug":"Snipaste_2020-12-17_19-20-19.png","post":"ckkou93hl0001ekr799tm2wkb","modified":0,"renderable":0},{"_id":"source/_posts/【Dev】DevExpress应用/Snipaste_2020-12-17_19-29-45.png","slug":"Snipaste_2020-12-17_19-29-45.png","post":"ckkou93hl0001ekr799tm2wkb","modified":0,"renderable":0},{"_id":"source/_posts/【Dev】DevExpress应用/Snipaste_2020-12-17_19-49-11.png","slug":"Snipaste_2020-12-17_19-49-11.png","post":"ckkou93hl0001ekr799tm2wkb","modified":0,"renderable":0},{"_id":"source/_posts/【Dev】DevExpress应用/Snipaste_2020-12-18_09-11-36.png","slug":"Snipaste_2020-12-18_09-11-36.png","post":"ckkou93hl0001ekr799tm2wkb","modified":0,"renderable":0},{"_id":"source/_posts/【Dev】DevExpress应用/Snipaste_2020-12-18_09-13-12.png","slug":"Snipaste_2020-12-18_09-13-12.png","post":"ckkou93hl0001ekr799tm2wkb","modified":0,"renderable":0},{"_id":"source/_posts/【Dev】DevExpress应用/Snipaste_2020-12-22_19-13-20.png","slug":"Snipaste_2020-12-22_19-13-20.png","post":"ckkou93hl0001ekr799tm2wkb","modified":0,"renderable":0},{"_id":"source/_posts/【Dev】DevExpress应用/Snipaste_2021-01-06_21-26-31.png","slug":"Snipaste_2021-01-06_21-26-31.png","post":"ckkou93hl0001ekr799tm2wkb","modified":0,"renderable":0},{"_id":"source/_posts/【Dev】DevExpress应用/Snipaste_2021-01-07_20-38-53.png","slug":"Snipaste_2021-01-07_20-38-53.png","post":"ckkou93hl0001ekr799tm2wkb","modified":0,"renderable":0},{"_id":"source/_posts/【Dev】DevExpress应用/Snipaste_2021-01-07_20-43-04.png","slug":"Snipaste_2021-01-07_20-43-04.png","post":"ckkou93hl0001ekr799tm2wkb","modified":0,"renderable":0},{"_id":"source/_posts/【Dev】DevExpress应用/Snipaste_2021-01-07_20-45-28.png","slug":"Snipaste_2021-01-07_20-45-28.png","post":"ckkou93hl0001ekr799tm2wkb","modified":0,"renderable":0},{"_id":"source/_posts/【Dev】DevExpress应用/Snipaste_2021-01-07_20-45-55.png","slug":"Snipaste_2021-01-07_20-45-55.png","post":"ckkou93hl0001ekr799tm2wkb","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4GamePlay架构/Snipaste_2021-02-26_14-10-33.png","slug":"Snipaste_2021-02-26_14-10-33.png","post":"ckmbr23xl0000tor784r9da7m","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4GamePlay架构/Snipaste_2021-03-09_21-15-31.png","slug":"Snipaste_2021-03-09_21-15-31.png","post":"ckmbr23xl0000tor784r9da7m","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4GamePlay架构/Snipaste_2021-03-10_16-27-31.png","slug":"Snipaste_2021-03-10_16-27-31.png","post":"ckmbr23xl0000tor784r9da7m","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4GamePlay架构/Snipaste_2021-03-18_14-34-58.png","slug":"Snipaste_2021-03-18_14-34-58.png","post":"ckmbr23xl0000tor784r9da7m","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4GamePlay架构/Snipaste_2021-03-19_21-54-55.png","slug":"Snipaste_2021-03-19_21-54-55.png","post":"ckmbr23xl0000tor784r9da7m","modified":0,"renderable":0},{"_id":"source/_posts/【C++】C++STL标准模板库/Snipaste_2021-03-30_09-43-50.png","slug":"Snipaste_2021-03-30_09-43-50.png","post":"ckk9hocbh003edwr73uj5h7zl","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4GamePlay架构/Snipaste_2021-04-01_11-26-15.png","slug":"Snipaste_2021-04-01_11-26-15.png","post":"ckmbr23xl0000tor784r9da7m","modified":0,"renderable":0},{"_id":"source/_posts/【BAT】BATWindows自动脚本同步GitHUb远程仓库/Snipaste_2020-01-21_16-04-19.png","post":"ckoo4kchv0000wkr76j803iop","slug":"Snipaste_2020-01-21_16-04-19.png","modified":1,"renderable":1},{"_id":"source/_posts/【BAT】BATWindows自动脚本同步GitHUb远程仓库/Snipaste_2020-01-21_16-29-49.png","post":"ckoo4kchv0000wkr76j803iop","slug":"Snipaste_2020-01-21_16-29-49.png","modified":1,"renderable":1},{"_id":"source/_posts/【UE4】UE4使用蓝图动态修改粒子参数/Snipaste_2020-01-17_16-11-42.png","slug":"Snipaste_2020-01-17_16-11-42.png","post":"ckoo4kchy0001wkr7d9hf8dbn","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4使用蓝图动态修改粒子参数/Snipaste_2020-01-17_16-14-22.png","slug":"Snipaste_2020-01-17_16-14-22.png","post":"ckoo4kchy0001wkr7d9hf8dbn","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4使用蓝图动态修改粒子参数/Snipaste_2020-01-17_16-32-09.png","slug":"Snipaste_2020-01-17_16-32-09.png","post":"ckoo4kchy0001wkr7d9hf8dbn","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4使用蓝图动态修改粒子参数/Snipaste_2020-01-17_16-36-34.png","slug":"Snipaste_2020-01-17_16-36-34.png","post":"ckoo4kchy0001wkr7d9hf8dbn","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4使用蓝图动态修改粒子参数/Snipaste_2020-01-17_16-41-30.png","slug":"Snipaste_2020-01-17_16-41-30.png","post":"ckoo4kchy0001wkr7d9hf8dbn","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4使用蓝图动态修改粒子参数/Snipaste_2020-01-17_16-43-43.png","slug":"Snipaste_2020-01-17_16-43-43.png","post":"ckoo4kchy0001wkr7d9hf8dbn","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4使用蓝图动态修改粒子参数/Snipaste_2020-01-17_16-43-57.png","slug":"Snipaste_2020-01-17_16-43-57.png","post":"ckoo4kchy0001wkr7d9hf8dbn","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4使用蓝图动态修改粒子参数/Snipaste_2020-01-17_16-44-15.png","slug":"Snipaste_2020-01-17_16-44-15.png","post":"ckoo4kchy0001wkr7d9hf8dbn","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4Socket编程/Snipaste_2019-12-01_19-00-42.png","slug":"Snipaste_2019-12-01_19-00-42.png","post":"ckoo4kchz0002wkr739j7ft11","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4Socket编程/Snipaste_2019-12-02_20-23-53.png","slug":"Snipaste_2019-12-02_20-23-53.png","post":"ckoo4kchz0002wkr739j7ft11","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-07_16-26-46.png","slug":"Snipaste_2019-12-07_16-26-46.png","post":"ckoo4kci10003wkr7hns74gep","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-07_16-53-31.png","slug":"Snipaste_2019-12-07_16-53-31.png","post":"ckoo4kci10003wkr7hns74gep","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-07_17-03-45.png","slug":"Snipaste_2019-12-07_17-03-45.png","post":"ckoo4kci10003wkr7hns74gep","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-07_17-10-49.png","slug":"Snipaste_2019-12-07_17-10-49.png","post":"ckoo4kci10003wkr7hns74gep","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-07_17-43-04.png","slug":"Snipaste_2019-12-07_17-43-04.png","post":"ckoo4kci10003wkr7hns74gep","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-07_18-06-58.png","slug":"Snipaste_2019-12-07_18-06-58.png","post":"ckoo4kci10003wkr7hns74gep","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-07_20-06-13.png","slug":"Snipaste_2019-12-07_20-06-13.png","post":"ckoo4kci10003wkr7hns74gep","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-08_15-41-32.png","slug":"Snipaste_2019-12-08_15-41-32.png","post":"ckoo4kci10003wkr7hns74gep","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-08_15-43-04.png","slug":"Snipaste_2019-12-08_15-43-04.png","post":"ckoo4kci10003wkr7hns74gep","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-08_16-08-15.png","slug":"Snipaste_2019-12-08_16-08-15.png","post":"ckoo4kci10003wkr7hns74gep","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-08_16-26-18.png","slug":"Snipaste_2019-12-08_16-26-18.png","post":"ckoo4kci10003wkr7hns74gep","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-08_16-58-00.png","slug":"Snipaste_2019-12-08_16-58-00.png","post":"ckoo4kci10003wkr7hns74gep","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-08_16-58-04.png","slug":"Snipaste_2019-12-08_16-58-04.png","post":"ckoo4kci10003wkr7hns74gep","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-08_16-58-54.png","slug":"Snipaste_2019-12-08_16-58-54.png","post":"ckoo4kci10003wkr7hns74gep","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-08_17-32-12.png","slug":"Snipaste_2019-12-08_17-32-12.png","post":"ckoo4kci10003wkr7hns74gep","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-08_17-35-49.png","slug":"Snipaste_2019-12-08_17-35-49.png","post":"ckoo4kci10003wkr7hns74gep","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-08_17-47-44.png","slug":"Snipaste_2019-12-08_17-47-44.png","post":"ckoo4kci10003wkr7hns74gep","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-08_18-00-16.png","slug":"Snipaste_2019-12-08_18-00-16.png","post":"ckoo4kci10003wkr7hns74gep","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-08_18-06-31.png","slug":"Snipaste_2019-12-08_18-06-31.png","post":"ckoo4kci10003wkr7hns74gep","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-08_18-32-17.png","slug":"Snipaste_2019-12-08_18-32-17.png","post":"ckoo4kci10003wkr7hns74gep","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-08_18-40-04.png","slug":"Snipaste_2019-12-08_18-40-04.png","post":"ckoo4kci10003wkr7hns74gep","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-08_18-45-34.png","slug":"Snipaste_2019-12-08_18-45-34.png","post":"ckoo4kci10003wkr7hns74gep","modified":0,"renderable":0},{"_id":"source/_posts/【UE4】UE4角色控制/Snipaste_2019-12-08_18-45-47.png","slug":"Snipaste_2019-12-08_18-45-47.png","post":"ckoo4kci10003wkr7hns74gep","modified":0,"renderable":0}],"PostCategory":[{"post_id":"ckk9hoca90000dwr79kkt1xys","category_id":"ckk9hocae0002dwr72kfc6kt2","_id":"ckk9hocak000cdwr7bqr1aaef"},{"post_id":"ckk9hocaj000adwr7ajrd7mo3","category_id":"ckk9hocah0007dwr747zbhgqj","_id":"ckk9hocan000idwr709b94bv2"},{"post_id":"ckk9hocac0001dwr7gfqlepzz","category_id":"ckk9hocah0007dwr747zbhgqj","_id":"ckk9hocao000ndwr7gsqi5d75"},{"post_id":"ckk9hocak000bdwr746nx9ti7","category_id":"ckk9hocah0007dwr747zbhgqj","_id":"ckk9hocap000pdwr71w4z2c6s"},{"post_id":"ckk9hocal000gdwr7eaqfdjo9","category_id":"ckk9hocah0007dwr747zbhgqj","_id":"ckk9hocaq000tdwr7bg0pd13k"},{"post_id":"ckk9hocaf0004dwr7c2d95mo6","category_id":"ckk9hocae0002dwr72kfc6kt2","_id":"ckk9hocar000wdwr72yytgdxy"},{"post_id":"ckk9hocam000hdwr7ht7n3pz9","category_id":"ckk9hocah0007dwr747zbhgqj","_id":"ckk9hocas000zdwr71a832z0z"},{"post_id":"ckk9hocao000mdwr79a1l3si1","category_id":"ckk9hocae0002dwr72kfc6kt2","_id":"ckk9hocas0012dwr76fpqaj6r"},{"post_id":"ckk9hocag0005dwr7b9b63nqp","category_id":"ckk9hocah0007dwr747zbhgqj","_id":"ckk9hocat0015dwr73pyb9hq3"},{"post_id":"ckk9hocao000odwr7743od9tg","category_id":"ckk9hocah0007dwr747zbhgqj","_id":"ckk9hocau0018dwr79prndvwv"},{"post_id":"ckk9hocaq000sdwr7hpbtfm78","category_id":"ckk9hocae0002dwr72kfc6kt2","_id":"ckk9hocav001bdwr70rjs8vb8"},{"post_id":"ckk9hocah0006dwr78y3x38ht","category_id":"ckk9hocah0007dwr747zbhgqj","_id":"ckk9hocaw001edwr78nqm6sxi"},{"post_id":"ckk9hocaq000vdwr77ko3d286","category_id":"ckk9hocae0002dwr72kfc6kt2","_id":"ckk9hocaw001hdwr7fsf09b7u"},{"post_id":"ckk9hocas0011dwr7fpb7a6l9","category_id":"ckk9hocae0002dwr72kfc6kt2","_id":"ckk9hocax001kdwr7bc6v1fog"},{"post_id":"ckk9hocat0014dwr7cr2d29ag","category_id":"ckk9hocae0002dwr72kfc6kt2","_id":"ckk9hocay001ndwr73i0dbj8e"},{"post_id":"ckk9hocau0017dwr75lwb8vmf","category_id":"ckk9hocah0007dwr747zbhgqj","_id":"ckk9hocaz001qdwr7f5tcdw6a"},{"post_id":"ckk9hocau001adwr74wos09iu","category_id":"ckk9hocah0007dwr747zbhgqj","_id":"ckk9hocb0001tdwr7fvic4pgm"},{"post_id":"ckk9hocav001ddwr74z0y3xk5","category_id":"ckk9hocae0002dwr72kfc6kt2","_id":"ckk9hocb1001wdwr7dp0n61u2"},{"post_id":"ckk9hocaw001gdwr7gjee96ri","category_id":"ckk9hocae0002dwr72kfc6kt2","_id":"ckk9hocb1001ydwr7eiu970iu"},{"post_id":"ckk9hocax001jdwr7fgmhft5u","category_id":"ckk9hocae0002dwr72kfc6kt2","_id":"ckk9hocb20022dwr7djfd4kyd"},{"post_id":"ckk9hocay001mdwr78pvk8fc4","category_id":"ckk9hocae0002dwr72kfc6kt2","_id":"ckk9hocb50025dwr708gx0627"},{"post_id":"ckk9hocay001pdwr79y3y9y8t","category_id":"ckk9hocae0002dwr72kfc6kt2","_id":"ckk9hocb60027dwr7gv4i3ipb"},{"post_id":"ckk9hocaz001sdwr73i2j20dm","category_id":"ckk9hocae0002dwr72kfc6kt2","_id":"ckk9hocb6002adwr7bf50f1vl"},{"post_id":"ckk9hocb0001vdwr79ntm2hb7","category_id":"ckk9hocae0002dwr72kfc6kt2","_id":"ckk9hocb6002cdwr7dlme6nlz"},{"post_id":"ckk9hocb30024dwr7gbbne02d","category_id":"ckk9hocae0002dwr72kfc6kt2","_id":"ckk9hocb6002edwr79p611sok"},{"post_id":"ckk9hocb1001xdwr744r64o2j","category_id":"ckk9hocb30023dwr71fa3gojs","_id":"ckk9hocb7002gdwr7evvp0or1"},{"post_id":"ckk9hocb20021dwr72cg209tu","category_id":"ckk9hocb60029dwr73v0w6kmf","_id":"ckk9hocb7002idwr7bftwbmxf"},{"post_id":"ckk9hocbe0038dwr7g7g7hmyk","category_id":"ckk9hocah0007dwr747zbhgqj","_id":"ckk9hocbh003ddwr71uz7hb4g"},{"post_id":"ckk9hocbh003cdwr70i2k320s","category_id":"ckk9hocae0002dwr72kfc6kt2","_id":"ckk9hocbk003mdwr7886t032d"},{"post_id":"ckk9hocbh003edwr73uj5h7zl","category_id":"ckk9hocae0002dwr72kfc6kt2","_id":"ckk9hocbk003pdwr76ocped16"},{"post_id":"ckk9hocbi003idwr74vw2g9xb","category_id":"ckk9hocae0002dwr72kfc6kt2","_id":"ckk9hocbk003rdwr7hiiv1u4e"},{"post_id":"ckk9hocbj003ldwr7e8jt77cw","category_id":"ckk9hocae0002dwr72kfc6kt2","_id":"ckk9hocbl003udwr780kjc6in"},{"post_id":"ckk9hocbm003xdwr7encjdct0","category_id":"ckk9hocae0002dwr72kfc6kt2","_id":"ckk9hocbm003zdwr7ent1gmj1"},{"post_id":"ckko29br50000pwr7hthl4tkw","category_id":"ckk9hocb60029dwr73v0w6kmf","_id":"ckko29bt70002pwr73ycc1tkt"},{"post_id":"ckkou93hl0001ekr799tm2wkb","category_id":"ckk9hocah0007dwr747zbhgqj","_id":"ckkou93ht0003ekr70zwjg8x7"},{"post_id":"ckkou93gg0000ekr70u00eitq","category_id":"ckk9hocae0002dwr72kfc6kt2","_id":"ckkoua5ub0001c0r78n1d1jjl"},{"post_id":"cklakss1f00008gr776mod2zv","category_id":"ckk9hocae0002dwr72kfc6kt2","_id":"cklakss3x00028gr7c2khejr4"},{"post_id":"cklj1h5vc0000y4r7f1oofoww","category_id":"ckk9hocae0002dwr72kfc6kt2","_id":"cklj1h5wd0003y4r79nc37g2e"},{"post_id":"cklj1h5w50001y4r77gugb7rt","category_id":"ckk9hocae0002dwr72kfc6kt2","_id":"cklj1h5wd0004y4r7671sewbl"},{"post_id":"ckmbr23xl0000tor784r9da7m","category_id":"ckk9hocae0002dwr72kfc6kt2","_id":"ckmbr23xn0002tor75em4gu00"},{"post_id":"ckmd48me60000nwr70ydedtft","category_id":"ckk9hocah0007dwr747zbhgqj","_id":"ckmogibea0000ksr7erc56rla"},{"post_id":"ckoo4kchv0000wkr76j803iop","category_id":"ckk9hocah0007dwr747zbhgqj","_id":"ckoo5yapl0001gor7fh0rggnx"},{"post_id":"ckoo4kchz0002wkr739j7ft11","category_id":"ckk9hocae0002dwr72kfc6kt2","_id":"ckoo5z1oo0004gor791ud4eeb"},{"post_id":"ckoo5uhf50000k8r76288a6yl","category_id":"ckk9hocah0007dwr747zbhgqj","_id":"ckoo5zi9m0006gor79co171js"},{"post_id":"ckoo4kci10003wkr7hns74gep","category_id":"ckk9hocae0002dwr72kfc6kt2","_id":"ckoo5zvtx0008gor7hblx2u24"},{"post_id":"ckoo4kci20004wkr7cr5hc3ey","category_id":"ckk9hocah0007dwr747zbhgqj","_id":"ckoo60cla000agor7ew6u7dtl"},{"post_id":"ckoo5uhf90001k8r75bob2tt2","category_id":"ckk9hocah0007dwr747zbhgqj","_id":"ckoo60nhd000cgor70ebf0zsx"},{"post_id":"ckoo4kchy0001wkr7d9hf8dbn","category_id":"ckk9hocae0002dwr72kfc6kt2","_id":"ckoo613hi000egor7faj844oe"}],"PostTag":[{"post_id":"ckk9hoca90000dwr79kkt1xys","tag_id":"ckk9hocaf0003dwr782wmgvg8","_id":"ckk9hocaj0009dwr7fk6m0c9j"},{"post_id":"ckk9hocac0001dwr7gfqlepzz","tag_id":"ckk9hocaf0003dwr782wmgvg8","_id":"ckk9hocal000fdwr71fv3g6ep"},{"post_id":"ckk9hocaf0004dwr7c2d95mo6","tag_id":"ckk9hocaf0003dwr782wmgvg8","_id":"ckk9hocao000ldwr7drl30u0b"},{"post_id":"ckk9hocam000hdwr7ht7n3pz9","tag_id":"ckk9hocaw001fdwr77ukob2zq","_id":"ckk9hocay001odwr778g66w0h"},{"post_id":"ckk9hocao000mdwr79a1l3si1","tag_id":"ckk9hocax001ldwr73ncael3d","_id":"ckk9hocb0001udwr7cp80dee2"},{"post_id":"ckk9hocao000odwr7743od9tg","tag_id":"ckk9hocaz001rdwr79gf07c4s","_id":"ckk9hocb20020dwr7hozu8maa"},{"post_id":"ckk9hocaq000sdwr7hpbtfm78","tag_id":"ckk9hocb1001zdwr7g7oh9e5q","_id":"ckk9hocb60028dwr7bnebew87"},{"post_id":"ckk9hocaq000vdwr77ko3d286","tag_id":"ckk9hocb50026dwr70ythcz35","_id":"ckk9hocb6002ddwr706hp4m5z"},{"post_id":"ckk9hocas0011dwr7fpb7a6l9","tag_id":"ckk9hocb6002bdwr7d5jf3gz2","_id":"ckk9hocb7002hdwr7gdb37ppi"},{"post_id":"ckk9hocat0014dwr7cr2d29ag","tag_id":"ckk9hocb6002bdwr7d5jf3gz2","_id":"ckk9hocb7002kdwr7d4np192p"},{"post_id":"ckk9hocau0017dwr75lwb8vmf","tag_id":"ckk9hocb6002bdwr7d5jf3gz2","_id":"ckk9hocb8002mdwr76r50hyby"},{"post_id":"ckk9hocau001adwr74wos09iu","tag_id":"ckk9hocb6002bdwr7d5jf3gz2","_id":"ckk9hocb8002odwr7fniwbpc0"},{"post_id":"ckk9hocav001ddwr74z0y3xk5","tag_id":"ckk9hocb8002ndwr74ymegvv0","_id":"ckk9hocb8002qdwr7fifrd2jp"},{"post_id":"ckk9hocaw001gdwr7gjee96ri","tag_id":"ckk9hocb8002ndwr74ymegvv0","_id":"ckk9hocb9002sdwr7d5lp14lu"},{"post_id":"ckk9hocax001jdwr7fgmhft5u","tag_id":"ckk9hocb8002ndwr74ymegvv0","_id":"ckk9hocb9002udwr76y7j6942"},{"post_id":"ckk9hocay001mdwr78pvk8fc4","tag_id":"ckk9hocb8002ndwr74ymegvv0","_id":"ckk9hocb9002wdwr73yy81kqc"},{"post_id":"ckk9hocay001pdwr79y3y9y8t","tag_id":"ckk9hocb8002ndwr74ymegvv0","_id":"ckk9hocba002ydwr72pfpaf97"},{"post_id":"ckk9hocaz001sdwr73i2j20dm","tag_id":"ckk9hocb8002ndwr74ymegvv0","_id":"ckk9hocba0030dwr7an5kcsro"},{"post_id":"ckk9hocb0001vdwr79ntm2hb7","tag_id":"ckk9hocba002zdwr74m8kgqes","_id":"ckk9hocba0032dwr7ggcshwua"},{"post_id":"ckk9hocb1001xdwr744r64o2j","tag_id":"ckk9hocba0031dwr7czki697q","_id":"ckk9hocbb0034dwr7dlx03lnl"},{"post_id":"ckk9hocb20021dwr72cg209tu","tag_id":"ckk9hocbb0033dwr7257wdbmv","_id":"ckk9hocbb0036dwr730cs3f4c"},{"post_id":"ckk9hocb30024dwr7gbbne02d","tag_id":"ckk9hocbb0035dwr78nu43x33","_id":"ckk9hocbb0037dwr73frxhy91"},{"post_id":"ckk9hocbe0038dwr7g7g7hmyk","tag_id":"ckk9hocbg003adwr79dsr6kwx","_id":"ckk9hocbi003hdwr73c1p1pmc"},{"post_id":"ckk9hocbj003ldwr7e8jt77cw","tag_id":"ckk9hocb6002bdwr7d5jf3gz2","_id":"ckk9hocbl003tdwr7dox20fdv"},{"post_id":"ckk9hocbh003cdwr70i2k320s","tag_id":"ckk9hocbk003sdwr7ec2meaor","_id":"ckk9hocbl003wdwr779pv0qrc"},{"post_id":"ckko29br50000pwr7hthl4tkw","tag_id":"ckk9hocbb0033dwr7257wdbmv","_id":"ckko29bt60001pwr7hgkab2kp"},{"post_id":"ckkou93hl0001ekr799tm2wkb","tag_id":"ckkou93hm0002ekr7euc6ad59","_id":"ckkou93ht0004ekr79fyg9mu8"},{"post_id":"cklakss1f00008gr776mod2zv","tag_id":"cklakss2z00018gr72r42ez6d","_id":"cklakss3y00038gr7e30w75zz"},{"post_id":"cklj1h5vc0000y4r7f1oofoww","tag_id":"cklj1h5w60002y4r700g6e8ii","_id":"cklj1h5we0006y4r797sn5nkh"},{"post_id":"cklj1h5w50001y4r77gugb7rt","tag_id":"cklj1h5w60002y4r700g6e8ii","_id":"cklj1h5wf0007y4r7eqm87tce"},{"post_id":"ckmbr23xl0000tor784r9da7m","tag_id":"ckk9hocb6002bdwr7d5jf3gz2","_id":"ckmbr23xn0001tor7cwtwhqjc"},{"post_id":"ckk9hocah0006dwr78y3x38ht","tag_id":"ckmd48mfk0001nwr7ceqi003l","_id":"ckmd48mgh0003nwr736cpb54s"},{"post_id":"ckmd48me60000nwr70ydedtft","tag_id":"ckmd48mfk0001nwr7ceqi003l","_id":"ckmd48mgh0004nwr75t7l0778"},{"post_id":"ckk9hocak000bdwr746nx9ti7","tag_id":"ckmd48mfk0001nwr7ceqi003l","_id":"ckmd48mgi0006nwr79epk1g2u"},{"post_id":"ckk9hocaj000adwr7ajrd7mo3","tag_id":"ckmd48mfk0001nwr7ceqi003l","_id":"ckmd48mgj0007nwr7eoa20f0r"},{"post_id":"ckk9hocag0005dwr7b9b63nqp","tag_id":"ckmd48mfk0001nwr7ceqi003l","_id":"ckmd48mgj0008nwr7d52chpv0"},{"post_id":"ckk9hocal000gdwr7eaqfdjo9","tag_id":"ckmd48mfk0001nwr7ceqi003l","_id":"ckmd48mgp0009nwr74a99c8b5"},{"post_id":"ckkou93gg0000ekr70u00eitq","tag_id":"ckmd48mfk0001nwr7ceqi003l","_id":"ckmd48mgq000anwr76h44eodk"},{"post_id":"ckk9hocbh003edwr73uj5h7zl","tag_id":"ckmd48mfk0001nwr7ceqi003l","_id":"ckmd48mgs000bnwr7h1wq21c6"},{"post_id":"ckk9hocbi003idwr74vw2g9xb","tag_id":"ckmd48mfk0001nwr7ceqi003l","_id":"ckmd48mgs000cnwr7dt01f96m"},{"post_id":"ckk9hocbm003xdwr7encjdct0","tag_id":"ckmd48mfk0001nwr7ceqi003l","_id":"ckmd48mgu000dnwr7hc4g642e"},{"post_id":"ckoo4kchv0000wkr76j803iop","tag_id":"ckoo5yapk0000gor7gl0qaf2v","_id":"ckoo5yapl0002gor713ao0e9l"},{"post_id":"ckoo4kchz0002wkr739j7ft11","tag_id":"ckk9hocb6002bdwr7d5jf3gz2","_id":"ckoo5z1oo0003gor762qy4w2h"},{"post_id":"ckoo5uhf50000k8r76288a6yl","tag_id":"ckk9hocb6002bdwr7d5jf3gz2","_id":"ckoo5zi9m0005gor7hptabiv4"},{"post_id":"ckoo4kci10003wkr7hns74gep","tag_id":"ckk9hocb6002bdwr7d5jf3gz2","_id":"ckoo5zvtx0007gor7aa191ezo"},{"post_id":"ckoo4kci20004wkr7cr5hc3ey","tag_id":"ckk9hocb6002bdwr7d5jf3gz2","_id":"ckoo60cla0009gor70xzb75u0"},{"post_id":"ckoo5uhf90001k8r75bob2tt2","tag_id":"ckk9hocb6002bdwr7d5jf3gz2","_id":"ckoo60nhd000bgor7c7jw2srm"},{"post_id":"ckoo4kchy0001wkr7d9hf8dbn","tag_id":"ckk9hocb6002bdwr7d5jf3gz2","_id":"ckoo613hi000dgor727osdcbe"}],"Tag":[{"name":"C#","_id":"ckk9hocaf0003dwr782wmgvg8"},{"name":"C++","_id":"ckk9hocan000jdwr7e12h3gq1"},{"name":"C","_id":"ckk9hocaw001fdwr77ukob2zq"},{"name":"Linux","_id":"ckk9hocax001ldwr73ncael3d"},{"name":"MySQL","_id":"ckk9hocaz001rdwr79gf07c4s"},{"name":"Lua","_id":"ckk9hocb1001zdwr7g7oh9e5q"},{"name":"Qt","_id":"ckk9hocb50026dwr70ythcz35"},{"name":"UE4","_id":"ckk9hocb6002bdwr7d5jf3gz2"},{"name":"Unity3d","_id":"ckk9hocb8002ndwr74ymegvv0"},{"name":"shell","_id":"ckk9hocba002zdwr74m8kgqes"},{"name":"程序问题","_id":"ckk9hocba0031dwr7czki697q"},{"name":"大事件","_id":"ckk9hocbb0033dwr7257wdbmv"},{"name":"程序编程原理","_id":"ckk9hocbb0035dwr78nu43x33"},{"name":"算法","_id":"ckk9hocbg003adwr79dsr6kwx"},{"name":"游戏网络","_id":"ckk9hocbi003gdwr7awnl0blu"},{"name":"网络通信","_id":"ckk9hocbk003ndwr71amh70fy"},{"name":"图形学","_id":"ckk9hocbk003sdwr7ec2meaor"},{"name":"Dev","_id":"ckkou93hm0002ekr7euc6ad59"},{"name":"Python","_id":"cklakss2z00018gr72r42ez6d"},{"name":"计算机网络","_id":"cklj1h5w60002y4r700g6e8ii"},{"name":"CPlus","_id":"ckmd48mfk0001nwr7ceqi003l"},{"name":"BAT","_id":"ckoo5yapk0000gor7gl0qaf2v"}]}}