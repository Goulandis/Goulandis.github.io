<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【C++】C++面向对象模型初探</title>
      <link href="undefined2019/10/01/%E3%80%90C++%E3%80%91C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%88%9D%E6%8E%A2/"/>
      <url>2019/10/01/%E3%80%90C++%E3%80%91C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="1-成员的分开存储"><a href="#1-成员的分开存储" class="headerlink" title="1.成员的分开存储"></a>1.成员的分开存储</h1><p>C++通过将类的成员分开存储的方式来实现面向对象</p><table><thead><tr><th>成员</th><th>存储位置</th></tr></thead><tbody><tr><td>普通成员变量</td><td>栈区，与struct变量有相同的内存布局和字节对齐方式</td></tr><tr><td>静态成员变量</td><td>全局数据区，如此便可以使用类名和类所有的对象都可以访问</td></tr><tr><td>成员函数</td><td>代码段，包括静态成员函数和非静态成员函数</td></tr><tr><td>虚函数</td><td>虚函数表指针(vfptr)存放在栈区，其指向的虚函数表有自身的内存存储空间</td></tr></tbody></table><h1 id="2-C-类的内存分布"><a href="#2-C-类的内存分布" class="headerlink" title="2.C++类的内存分布"></a>2.C++类的内存分布</h1><p>要想更好的了解这些，我们还需了解C++类的内存分布</p><p><img src="/2019/10/01/【C++】C++面向对象模型初探/Snipaste_2019-10-02_09-07-09.png" alt></p><h2 id="Stack："><a href="#Stack：" class="headerlink" title="Stack："></a><strong>Stack：</strong></h2><p>栈，存放Automatic Variables，按内存地址由高到低方向生长，其最大大小由编译时确定，速度快，但自由性差，最大空间不大。保存程序中的局部变量。</p><h2 id="Heap："><a href="#Heap：" class="headerlink" title="Heap："></a><strong>Heap：</strong></h2><p>堆，自由申请的空间，按内存地址由低到高方向生长，其大小由系统内存/虚拟内存上限决定，速度较慢，但自由性大，可用空间大。 动态分配的内存在调用malloc（）或者相关函数产生，在调用free()时释放，由程序员决定而不是一系列规则规定内存持续时间，因此内存块可在一个函数中创建，在另一个函数中释放。由于这点，动态内存分配容易导致堆区内存碎片化。</p><h2 id="Data："><a href="#Data：" class="headerlink" title=".Data："></a><strong>.Data：</strong></h2><p> 存放程序中<font color="red"> 已经初始化的非零全局变量。静态分配。</font></p><p>data又可分为读写（RW）区域和只读（RO）区域。 </p><ul><li>RO段保存常量所以也被称为<code>.constdata</code> eg const数据</li><li>RW段则是普通非常全局变量，静态变量就在其中</li></ul><h2 id="Bss："><a href="#Bss：" class="headerlink" title=".Bss："></a><strong>.Bss：</strong></h2><p>存放程序中<strong>未初始化</strong>的和零值全局变量。静态分配，在程序开始时通常会被清零。</p><h2 id="Text："><a href="#Text：" class="headerlink" title=".Text："></a><strong>.Text：</strong></h2><p>也称为代码段(Code)，用来存放程序执行代码，同时也可能会包含一些常量(如一些字符串常量等）。该段内存为静态分配，只读(某些架构可能允许修改)。<br>这块内存是共享的,当有多个相同进程(Process)存在时，共用同一个text段。</p><hr><p>普通成员变量存储在栈区，使得每一个类的对象都拥有各自独立的普通成员变量。</p><p>静态成员变量存储在全局数据区，是的每一个类的对象都共享一份静态</p><p>成员变量。</p><h1 id="3-this指针"><a href="#3-this指针" class="headerlink" title="3.this指针"></a>3.this指针</h1><p>那么，存放在代码段的成员函数是怎么区分调用对象的呢？</p><p>事实上，<font color="red"> C++为每一个函数都隐式定义了一个函数所属类类型的指针形参–this，而this指针永远指向调用函数的对象</font>，如此函数便可以识别调用自身的是类的哪个对象了。</p><p>这里有一点要注意，<font color="red"> C++并没有为静态成员函数定义this指针，如此，静态成员函数被所有的对象共享</font>。</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h1><p>通过成员的分开存储和普通成员函数的<code>this指针</code>C++便可以识别各个不同的对象，如此便实现了面向对象。</p>]]></content>
      
      
      <categories>
          
          <category> 知识记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【shell】shell基础</title>
      <link href="undefined2019/09/30/%E3%80%90shell%E3%80%91shell%E5%9F%BA%E7%A1%80/"/>
      <url>2019/09/30/%E3%80%90shell%E3%80%91shell%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>由于本文内有大量的markdwon转义未处理，导致远程同步不通过，所以本文引入外部ULR预览</p><p><a href="https://blog.csdn.net/qq_39108291/article/details/101797244" target="_blank" rel="noopener">https://blog.csdn.net/qq_39108291/article/details/101797244</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++】高级</title>
      <link href="undefined2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/"/>
      <url>2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="一、类"><a href="#一、类" class="headerlink" title="一、类"></a>一、类</h1><h2 id="1-浅拷贝与深拷贝"><a href="#1-浅拷贝与深拷贝" class="headerlink" title="1.浅拷贝与深拷贝"></a>1.浅拷贝与深拷贝</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p><font color="red"> C++在进行浅拷贝时，只拷贝栈区的内存空间，不拷贝堆区的内存空间，即浅拷贝只拷贝非指针的成员变量和指针本身，而不拷贝指针所指向的堆区的内容。</font></p><p>我们代码1.1为例</p><pre><code class="c++">//代码1.1class Obj{public:    Obj(char *tp)    {        len = strlen(tp);        p = (char*)malloc(len + 1);        strcpy_s(p, len+1, tp);    }    ~Obj()    {        if (p != NULL)        {            free(p);            p = NULL;            len = 0;        }    }    void Show()    {        cout &lt;&lt; *p &lt;&lt; *(p + 1) &lt;&lt; *(p + 2) &lt;&lt; endl;    }private:    char *p;    int len;};void text(Obj &amp;obj){    Obj obj2 = obj;}int main(){    Obj obj1(&quot;asd&quot;);    text(obj1);    obj1.Show();    system(&quot;pause&quot;);    return 0;}</code></pre><p>我们作一个图示：</p><p><img src="/2019/09/14/【C++】C++高级/B:%5CGit%5CBlog%5Csource_posts%5C%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7%5CSnipaste_2019-10-01_16-21-15.png" alt></p><p>​    我们没有自定义Obj类的拷贝构造函数，所以当代码执行到<code>Obj obj2 = obj1;</code>时，编译器将调用默认的拷贝构造函数，然而，<font color="red"> 编译器默认的拷贝构造函数是一个浅拷贝</font>，所以新创建的对象obj2没有自己的堆区空间，obj2.p指向的是obj1.p所指向的内存地址。</p><p>​    上面的代码编译是通不过的，<font color="red"> 原因在于，对象析构时，同一个内存地址<code>0x0001</code>被对象obj1和obj2一起析构了两次</font>。当代码执行完<code>test(obj1)</code>时，对象obj2被析构，指针obj2.p所指向的内存地址<code>0x0001</code>被释放，所以当代码执行到<code>obj1.Show()</code>时，使用了已经被释放掉的内存<code>0x0001</code>地址，从而导致运行错误。</p><p>​    <font color="green"> <strong>这里我有一个疑问，既然浅拷贝在拷贝有指针的对象时，会出现两次析构而出错，所以浅拷贝只能拷贝没有指针成员的对象，那么浅拷贝和深拷贝似乎没有什么区别了，那么浅拷贝存在的意义是什么呢？</strong></font></p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>C++没有提供给开发者预定义的深拷贝方法，所以要想使用深拷贝，我们需要字写一个拷贝构造函数。</p><p>深拷贝可以解决上面遇到的浅拷贝的问题，因为，<font color="red"> 深拷贝会申请一新的内存空间用于存放拷贝过来的内容，即深拷贝拷贝对象的所有成员，包括指针所指向的内存空间也会一起被拷贝，被拷贝过来的指针会指向一个新的内存地址</font>。</p><p><img src="/2019/09/14/【C++】C++高级/Snipaste_2019-10-01_16-52-53.png" alt></p><h3 id="定义深拷贝构造函数"><a href="#定义深拷贝构造函数" class="headerlink" title="定义深拷贝构造函数"></a>定义深拷贝构造函数</h3><pre><code class="c++">//代码1.2class Obj{public:    Obj(char *tp)    {        len = strlen(tp);        p = (char*)malloc(len + 1);        strcpy_s(p, len+1, tp);    }    //------------------------------    //拷贝构造函数--深拷贝    Obj(const Obj &amp;obj)    {        len = obj.len;        p = (char*)malloc(len + 1);        strcpy_s(p, len + 1, obj.p);    }    //------------------------------    ~Obj()    {        if (p != NULL)        {            free(p);            p = NULL;            len = 0;        }    }    void Show()    {        cout &lt;&lt; *p &lt;&lt; *(p + 1) &lt;&lt; *(p + 2) &lt;&lt; endl;    }private:    char *p;    int len;};</code></pre><p>当一个类中定义了拷贝构造函数，则在对象拷贝时，编译器就不会在调用默认的拷贝构造函数转而调用自定义的拷贝构造函数，当我们把代码1.1中类的定义改为代码1.2中类的定义后，程序就可以正常执行了。</p><p><font color="red">使用深拷贝时，我们还需要注意下面的情况：</font></p><pre><code class="c++">Obj obj1(&quot;asd&quot;);Obj obj3(&quot;fgh&quot;);obj3 = obj1;</code></pre><p>此时，在<code>obj3=obj1;</code>处依旧调用默认的拷贝构造函数，这里我们要弄清楚<code>obj3=obj1</code>和<code>Obj obj3 = obj1</code>之间的区别，<code>obj3=obj1</code>是将<font color="red">obj1赋值给obj3</font>，<code>=</code>赋值与拷贝构造函数没有什么关联，<code>=</code>在赋值时是C++编译器自己调用默认的拷贝构造函数—浅拷贝，和类中有无定义深拷贝无关；而<code>Obj obj3=obj1</code>则是<font color="red">使用obj1来构造obj3</font>，此时如果类中定义了深拷贝构造函数，就会使用深拷贝。要解决这个问题，就需要显示重载<code>=</code>运算符了。</p><h3 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a><font color="blue"><strong>小知识</strong></font></h3><ul><li><font color="blue">在定义拷贝构造函数时，必须使用引用传递，否则会出现无限拷贝的情况，因为，如果我们使用传值传递的话，在传递对象到拷贝构造函数时，又会调用拷贝构造函数将实参拷贝给形参，而这个过程又会将对象传递给拷贝构造函数，从而在此调用拷贝构造函数将实参拷贝给形参，如此无限循环</font></li><li><font color="blue">拷贝构造函数只能有一个参数，且必须是自身类的引用，否则编译器将识别被普通构造函数</font></li></ul><h2 id="2-初始化参数列表"><a href="#2-初始化参数列表" class="headerlink" title="2.初始化参数列表"></a>2.初始化参数列表</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>我们以下面的代码1.3来说明初始化参数列表</p><pre><code class="C++">class A{public:    A(int a)    {        this-&gt;a = a;    }private:    int a;};class B{public :    B(int i)    {        this-&gt;i = i;    }    int i;    A a;};int main(){    B b(1);    system(&quot;pause&quot;);    return 0;}</code></pre><p><strong>运行结果：</strong></p><pre><code>错误    C2512    “A”: 没有合适的默认构造函数可用</code></pre><p>​    这个问题就在于，在类B中组合了一个A类的成员，编译器在构造B类对象时，同时会构造一个A类对象作为B类的成员，然而，因为A类自定义了一个有参的构造函数，所以在构造A类时，编译器不会使用默认构造函数，而是使用自定义的有参构造函数，问题就出在这里，编译器在构造A类时，没有参数传递到A类的有参构造函数中。初始化参数列表就是用于解决这种问题的。</p><p>​    需要说明的是，如果A类中没有自定义有参的构造函数，则在B类构造对象时编译器自动调用A类的默认构造函数构造A类对象成员，就不会报错。</p><p>​    初始化参数列表可以让我们在构造B类对象时，根据参数列表来构造不同的A类成员。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>初始化参数列表的使用如下面的<code>B(int i):a1(1),a2(2,&quot;asd&quot;)</code>：</p><pre><code class="c++">class A{public:    A(int a)    {        this-&gt;a = a;        cout &lt;&lt; &quot;构造小A&quot; &lt;&lt; endl;    }    A(int a, string str)    {        this-&gt;a = a;        this-&gt;str = str;        cout &lt;&lt; &quot;构造大A&quot; &lt;&lt; endl;    }    ~A()    {        cout &lt;&lt; &quot;析构A&quot; &lt;&lt; endl;    }    int a;    string str;};class B{public :    B(int i):a1(1),a2(2,&quot;asd&quot;)    {        this-&gt;i = i;        cout &lt;&lt; &quot;构造B&quot; &lt;&lt; endl;    }    ~B()    {        cout &lt;&lt; &quot;析构B&quot; &lt;&lt; endl;    }    int i;    A a1;    A a2;};void test(){    B b(1);    cout &lt;&lt; b.a1.str &lt;&lt; endl;    cout &lt;&lt; b.a2.str &lt;&lt; endl;}int main(){    test();    system(&quot;pause&quot;);    return 0;}</code></pre><p><strong>输出结果：</strong></p><pre><code>构造小A构造大A构造Basd析构B析构A析构A</code></pre><p>​    值得注意的是<font color="red"> A类对象的构造顺序不是由初始化参数列表的顺序决定的，而是由对象的申明的前后顺序决定的</font>，如：<code>B(int i):a1(1),a2(2,&quot;asd&quot;)</code>和<code>B(int i):a2(2,&quot;asd&quot;),a1(1)</code>的构造顺序是一样的，但是当我们将类B中组合的A类对象的申明顺序改为如下</p><pre><code class="c++">class B{public :    B(int i):a1(1),a2(2,&quot;asd&quot;)    {        this-&gt;i = i;        cout &lt;&lt; &quot;构造B&quot; &lt;&lt; endl;    }    ~B()    {        cout &lt;&lt; &quot;析构B&quot; &lt;&lt; endl;    }    int i;    A a2;    A a1;};</code></pre><p>则构造顺序就变为“先构造a2再构造a1”了。</p><p><font color="red"> 析构的顺序和构造的顺序相反。</font></p><h3 id="小知识-1"><a href="#小知识-1" class="headerlink" title=" 小知识"></a><font color="blue"> 小知识</font></h3><ul><li><font color="blue"> 当一个类中组合了其他的类对象作为成员时，拷贝构造函数也必须使用初始化参数列表，来构造对象成员然后拷贝</font></li></ul><h2 id="3-匿名对象的生命周期"><a href="#3-匿名对象的生命周期" class="headerlink" title="3.匿名对象的生命周期"></a>3.匿名对象的生命周期</h2><h3 id="什么是匿名对象"><a href="#什么是匿名对象" class="headerlink" title="什么是匿名对象"></a>什么是匿名对象</h3><pre><code class="C++">calss A{public:    int a;    A(int a)    {        this-&gt;a = a;    }}void main(){    A(1);}</code></pre><p>上面的语句<code>A(1)</code>创建的就是一个匿名临时的对象，<font color="red"> 需要注意，如果一个类只有无参的构造函数，那么这个类将无法构建匿名对象</font>，匿名对象的生命周期就只在创建匿名对象的这条语句内，如果我们不使用一个对象来接收这个匿名对象，那么匿名对象会在语句结束时被销毁，当我们使用<code>A a = A(1);</code>不会出现匿名对象拷贝到类B对象b的情况，这种语句已经被C++优化成了类B的构造语句。说这么多其实匿名对象没什么卵用。</p><h1 id="二、new和delete"><a href="#二、new和delete" class="headerlink" title="二、new和delete"></a>二、new和delete</h1><h2 id="1-new和delete的用法"><a href="#1-new和delete的用法" class="headerlink" title="1.new和delete的用法"></a>1.new和delete的用法</h2><p><code>new</code>可以为<strong>基础类型</strong>、<strong>数组</strong>、<strong>类</strong>分配内存空间，<code>new</code>分配的内存空间都分配在<strong>堆</strong>上。随意<code>new</code>出来的内存空间必须使用一个指针来指向，不能使用同类型的变量来接收，也禁止不接受。</p><p><strong>new 基础类型</strong></p><pre><code class="c++">int *p = new int;delete p;</code></pre><p><strong>new 数组</strong></p><pre><code class="c++">int *p = new int[10];delete[] p;</code></pre><p><strong>new 类</strong></p><pre><code class="c++">//C++A *p = new A();delete p;//CA *pc = (A*)malloc(A);free(pc);</code></pre><h2 id="2-new-delete和malloc-free的区别"><a href="#2-new-delete和malloc-free的区别" class="headerlink" title="2.new delete和malloc free的区别"></a>2.<code>new delete</code>和<code>malloc free</code>的区别</h2><ul><li><p>在基础类型和基础类型数组方面<code>new delete</code>和<code>malloc free</code>几乎没有什么区别</p></li><li><p><code>new</code>不仅会分配内存还会调用构造函数，而<code>malloc</code>只会分配内存</p></li><li><p><code>delete</code>会调用析构函数来销毁对象，而<code>free</code>只是单纯的释放内存</p></li></ul><h2 id="小知识-2"><a href="#小知识-2" class="headerlink" title=" 小知识"></a><font color="blue"> <strong>小知识</strong></font></h2><p><font color="blue"> <code>new delete</code>和<code>malloc free</code>是可以穿插使用的，即<code>new</code>可以和<code>free</code>搭配使用，<code>malloc</code>可以和<code>delete</code>搭配使用。</font></p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>​    在C++的几个特性中，封装、继承和抽象都相对好理解，而多态则不太好理解，这里就说说C++的多态。</p><h2 id="1-多态分两种："><a href="#1-多态分两种：" class="headerlink" title="1.多态分两种："></a>1.多态分两种：</h2><p>​    静态多态：静态多态指的就是函数重载和运算符重载。</p><pre><code class="c++">class Animal{public:    string name = &quot;动物&quot;;    virtual void speak()    {        cout &lt;&lt; name &lt;&lt; &quot;在叫&quot; &lt;&lt; endl;    }};class Dog : public Animal{public:    string name = &quot;狗&quot;;    void speak()    {        cout &lt;&lt; name &lt;&lt; &quot;在叫&quot; &lt;&lt;endl;    }};string operator+(Animal animal,Dog dog){    return animal.name + &quot;是&quot; + dog.name + &quot;的父类&quot;;}void Run(Animal animal){    cout &lt;&lt; animal.name &lt;&lt;&quot;在跑&quot; &lt;&lt; endl;}void Run(Dog dog){    cout &lt;&lt; dog.name &lt;&lt; &quot;在跑&quot; &lt;&lt; endl;}int main(){    Animal animal;    Dog dog;    Run(animal);    Run(dog);    cout&lt;&lt;animal+dog&lt;&lt;endl;    system(&quot;pause&quot;);}</code></pre><p>​    动态多态：动态多态则是通过继承和虚函数实现标签相同的函数因为传入不同的对象来实现不同的功能。</p><pre><code class="c++">class Animal{public:    string name = &quot;动物&quot;;    virtual void speak()    {        cout &lt;&lt; name &lt;&lt; &quot;在叫&quot; &lt;&lt; endl;    }};class Dog : public Animal{public:    string name = &quot;狗&quot;;    void speak()    {        cout &lt;&lt; name &lt;&lt; &quot;在叫&quot; &lt;&lt;endl;    }};void Speak(Animal *animal){    animal-&gt;speak();}int main(){    Animal animal;    Dog dog;    Speak(&amp;animal);    Speak(&amp;dog);    system(&quot;pause&quot;);    return 0;}</code></pre><p>​    动态多态中只能用父类对象的指针或引用来指向子类或自身对象。</p><h2 id="2-多态的实现原理"><a href="#2-多态的实现原理" class="headerlink" title="2.多态的实现原理"></a>2.多态的实现原理</h2><p>​    C++多态的实现依赖于类的虚函数表，当一个类中定义了虚函数，那么这个类就拥有的了一个记录这个虚函数入口地址的虚函数表，子类继承父类时也会继承父类的虚函数表，当子类重写父类的虚函数时，则子类的虚函数入口地址将覆盖父类的地址，如此当子类对象调用此函数时则从子类的虚函数表中寻找入口地址，当父类的对象调用此函数时则从父类的虚函数表中寻找入口地址。</p><h2 id="3-纯虚函数和抽象类"><a href="#3-纯虚函数和抽象类" class="headerlink" title="3.纯虚函数和抽象类"></a>3.纯虚函数和抽象类</h2><p>​    纯虚函数的定义：</p><pre><code class="c++">virtual void speak() = 0</code></pre><p>​    定义了纯虚函数的类就被成为抽象类，C++引入纯虚函数和抽象类的概念就是为了更好的使用多态，抽象类不能实例化对象，这个特性就规范了继承这个抽象类的子类必须重写父类的虚函数，因为如果继承了抽象类的子类不重写父类的虚函数，那么子类也是一个抽象类，子类便也不能实例化对象，如此便规范了多态实现，防止当子类很多时，出现某个子类在编写时忘记重写父类的虚函数，而导致这个子类没有实现多态。</p><h2 id="4-虚析构函数和纯虚析构函数"><a href="#4-虚析构函数和纯虚析构函数" class="headerlink" title="4.虚析构函数和纯虚析构函数"></a>4.虚析构函数和纯虚析构函数</h2><ul><li>虚析构函数的定义：</li></ul><pre><code class="c++">virtual ~Animal();</code></pre><ul><li>纯虚析构函数的定义：</li></ul><pre><code class="c++">virtual ~Animal() = 0;//纯虚析构函数必须要有申明也要有实现Animal：：~Animal(){    //代码实现}</code></pre><p>​    如果子类在堆区中定义了数据，那么我们使用父类指针或引用来使用多态时，父类指针或引用是无法无法寻找到子在堆区中的数据并释放的。C++引入虚析构函数和纯虚析构函数就是为了解决此类问题。</p><p>​    我们来看一个例子：</p><pre><code class="c++">class Animal{public:    Animal()    {        cout &lt;&lt; &quot;这是Animal的构造函数&quot; &lt;&lt; endl;    }    ~Animal()    {        cout &lt;&lt; &quot;这是Animal的析构函数&quot; &lt;&lt; endl;    }};class Dog : public Animal{public:    int *p;    Dog()    {        p = new int;        cout &lt;&lt; &quot;这是Dog的构造函数&quot; &lt;&lt; endl;    }    ~Dog()    {        cout &lt;&lt; &quot;这是Dog的析构函数&quot; &lt;&lt; endl;        if (p != NULL)        {                    cout &lt;&lt; &quot;释放堆区的p&quot; &lt;&lt; endl;            delete p;            p = NULL;        }    }};int main(){    Animal *animal = new Dog();    delete animal;    system(&quot;pause&quot;);    return 0;}</code></pre><p>输出结果：</p><pre><code>这是Animal的构造函数这是Dog的构造函数这是Animal的析构函数</code></pre><p>可以看到，delete animal后并没有调用Dog的析构函数，释放子类Dog在堆区申请的空间。</p><p>此时虚析构函数和纯虚析构函数便可以起作用了，我们再看一个例子：</p><pre><code class="c++">class Animal{public:    Animal()    {        cout &lt;&lt; &quot;这是Animal的构造函数&quot; &lt;&lt; endl;    }    virtual ~Animal()//把父类的析构函数改为虚析构函数    {        cout &lt;&lt; &quot;这是Animal的析构函数&quot; &lt;&lt; endl;    }};class Dog : public Animal{public:    int *p;    Dog()    {        p = new int;        cout &lt;&lt; &quot;这是Dog的构造函数&quot; &lt;&lt; endl;    }    ~Dog()    {        cout &lt;&lt; &quot;这是Dog的析构函数&quot; &lt;&lt; endl;        if (p != NULL)        {                    cout &lt;&lt; &quot;释放堆区的p&quot; &lt;&lt; endl;            delete p;            p = NULL;        }    }};int main(){    Animal *animal = new Dog();    delete animal;    system(&quot;pause&quot;);    return 0;}</code></pre><p>​    输出结果：</p><pre><code>这是Animal的构造函数这是Dog的构造函数这是Dog的析构函数释放堆区的p这是Animal的析构函数</code></pre><p>​    如此便可以释放子类Dog在堆区申请的空间了，纯虚析构函数和虚析构函数的作用是一样，只是纯虚析构函数有一个和纯虚函数一样的特性，即定义看纯虚析构函数的类也属于抽象类，纯虚析构函数必须实现，如果不实现所有继承了拥有纯虚析构函数的抽象类的派生类都属于抽象类。需要注意的是，因为纯虚析构函数的特性，纯虚析构函数的实现就必须在类外实现了。</p><hr><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>​    文件操作相对来说比较简单，总的来说就是5个步骤，即</p><h2 id="1-操作步骤"><a href="#1-操作步骤" class="headerlink" title="1.操作步骤"></a>1.操作步骤</h2><ul><li><p>​    包含头文件<font color="red">#include<ftream></ftream></font></p></li><li><p>​    创建流对象</p></li><li><p>​    打开文件</p></li><li><p>​    读写文件</p><p>​    <font color="red">需要注意的是C++中文件写的方式是使用符号“&lt;&lt;”，如：fout &lt;&lt; “文件内容”&lt;&lt;endl;</font></p><p>​    <font color="red">同理文件读也可以使用“&gt;&gt;”来读。</font></p></li><li><p>​    关闭文件</p><h3 id="文件写"><a href="#文件写" class="headerlink" title="文件写"></a>文件写</h3></li></ul><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;fstream&gt;using namespace std;void test(){    ofstream fout;    fout.open(&quot;文件测试.txt&quot;, ios::out);    fout &lt;&lt; &quot;姓名：张三&quot; &lt;&lt; endl;    fout &lt;&lt; &quot;性别：男&quot; &lt;&lt; endl;    fout.close();}int main(){    test();    system(&quot;pause&quot;);    return 0;}</code></pre><p>​    输出结果：    </p><p><img src="/2019/09/14/【C++】C++高级/Snipaste_2019-09-14_16-29-43.png" alt></p><h3 id="4种文件读的方式"><a href="#4种文件读的方式" class="headerlink" title="4种文件读的方式"></a>4种文件读的方式</h3><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;fstream&gt;using namespace std;void test(){    ifstream fin;    fin.open(&quot;文件测试.txt&quot;, ios::in);    if (!fin.is_open())//文件读需要多添加一步判断文件是否打开成功的步骤    {        cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl;    }    char str[1024];    string strs;    char chr;    //第一中方式    //while (fin &gt;&gt; str)//操作符&quot;&gt;&gt;&quot;每次只能读取一行数据，读到文件尾“EOF”时结束    //{    //    cout &lt;&lt; str &lt;&lt; endl;    //}    //第二种方式    //while (fin.getline(str, 50))//ifstream::getline(char *str,int num);这个函数只支持字符数组，参数num指的是需要读取的字节数    //{    //    cout &lt;&lt; str &lt;&lt; endl;    //}    //第三种方式    //while (getline(fin, strs))//与第二种方式不同的是，这个getline函数是全局的，且只支持输出到string类型的对象中    //{    //    cout &lt;&lt; strs &lt;&lt; endl;    //}    //第四中方式    while ((chr = fin.get()) != EOF)//get()函数每次只能读取一个字符    {        cout &lt;&lt; chr ;    }    fin.close();}int main(){    test();    system(&quot;pause&quot;);    return 0;}</code></pre><h2 id="2-文件的打开模式"><a href="#2-文件的打开模式" class="headerlink" title="2.文件的打开模式"></a>2.文件的打开模式</h2><p>​    C++提供6中文件的打开方式</p><table><thead><tr><th>打开方式</th><th>解释</th></tr></thead><tbody><tr><td>ios::in</td><td>以读的形式打开</td></tr><tr><td>ios::out</td><td>以写的形式打开，会覆盖源文件</td></tr><tr><td>ios::ate</td><td>以写的形式打开并初始文件位置：文件尾，会覆盖源文件</td></tr><tr><td>ios::app</td><td>以追加的方式打开文件</td></tr><tr><td>ios::trunc</td><td>如果文件存在先删除再创建</td></tr><tr><td>ios::binary</td><td>以二进制的形式打开</td></tr></tbody></table><h2 id="3-读写二进制文件"><a href="#3-读写二进制文件" class="headerlink" title="3.读写二进制文件"></a>3.读写二进制文件</h2><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;fstream&gt;using namespace std;class Person{public:    string name = &quot;张三&quot;;    string sex = &quot;男&quot;;};void test(){    ofstream fout;    fout.open(&quot;二进制文件测试.txt&quot;, ios::out | ios::binary);    Person p;    fout.write((char *)&amp;p, sizeof(Person));//注意这里使用ofstream::write()来写    fout.close;    ifstream fin;    fin.open(&quot;二进制文件测试.txt&quot;, ios::in | ios::binary);    if (!fin.is_open())    {        cout &lt;&lt; &quot;文件打开错误&quot; &lt;&lt; endl;        return;    }    Person pin;    fin.read((char *)&amp;pin, sizeof(Person));//注意这里使用ofstream::read()来读    cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; pin.name &lt;&lt; endl;    cout &lt;&lt; &quot;性别：&quot; &lt;&lt; pin.sex &lt;&lt; endl;    fin.close();}int main(){    test();    system(&quot;pause&quot;);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++】C++中的四种类型转换</title>
      <link href="undefined2019/09/12/%E3%80%90C++%E3%80%91C++%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/"/>
      <url>2019/09/12/%E3%80%90C++%E3%80%91C++%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>C++提供四种类型转换：const_cast、static_cast、dynamic_cast、reinterpret_cast</p><h1 id="1-const-cast"><a href="#1-const-cast" class="headerlink" title="1.const_cast"></a>1.const_cast</h1><p>​    const_cast的存在主要就是针对const字段，C++提供const_cast的目的就是为了消除const字段的const属性，让const字段也可以修改。</p><p>​    const_cast的用法：</p><p>​        const_cast只能将常指针转换为非常指针，不能直接将常字段转换为非常字段，只能通过指针类间接的修改常字段所在的内存的内容。</p><p>​        例：</p><pre><code class="C++">const int a = 1;const int* n = &amp;a;int* m = const_cast&lt;int*&gt;(n) ;*m = 2;</code></pre><p>​    最终的输出结果：</p><pre><code>a = 1,*n = 2,*m = 2&amp;a=n=m</code></pre><p>​        奇怪，指针n，m的确指向了地址&amp;a，之中的内容的确也修改成了2，可为什么字段a的值依旧是1？</p><p>​        经过多方查阅资料和自己的试验，原来对于常字段在预编译的过程中编译器就会给常字段预定义为初始化的值，类似宏定义一般，尽管内存的内容被改变了，但是常字段的值依旧被预定义为初始化的值。</p><p>​        但是，我就疑问了，既然const_cast就是用来修改const字段的，可是只是改变了其内存的值，字段的值依旧没变，那么程序里使用该字段的地方的值依旧没有改变，如此const_cast似乎没有达到想要的结果。</p><p>​        $\color{red}{不过const_cast似乎可以修改const标识的结构体对象中没有再用const标识的字段，也可以修改用const标识的类对象中没有用const标识的公有字段，但是在结构体或类中用const标识的字段就不能再修改了。}$</p><p><img src="/2019/09/12/【C++】C++中的四种转换类型/Snipaste_2019-09-12_10-44-16.png" alt></p><h1 id="2-static-cast"><a href="#2-static-cast" class="headerlink" title="2.static_cast"></a>2.static_cast</h1><p>​    static_cast类型转换的用法几乎和C中的基本类型转换的用法一致，而C++的static_cast类型转换增加的类型检查，在安全性上较C要强。</p><p>​    static_cast支持所有类型之间的转换包括类，对于类在继承过程中的类型转换有两点是需要注意的，一、static_cast类型转换在上行转换是安全的，在下行转换是不安全，（上行转换：从子类转换到父类，下行转换：从父类转换到子类），二、static_cast类型转换在类的转换中因该使用指针转换，即通过指针间接的实现转换，直接对类的对象进行转换类型会被裁剪，并且在下行转换中不使用指针会报错。</p><p><img src="/2019/09/12/【C++】C++中的四种转换类型/Snipaste_2019-09-12_11-51-30.png" alt></p><h1 id="3-dynamic-cast"><a href="#3-dynamic-cast" class="headerlink" title="3.dynamic_cast"></a>3.dynamic_cast</h1><p>​    dynamic_cast类型转换用于类之间的上下行转换，与static_cast不同的是，dynamic_cast类型转换无论上下行都具有类型检查，都可以进行安全的类型转换。上行转换dynamic_cast与static_cast完全一致，下行转换dynamic_cast比static_cast更安全</p><h1 id="4-reinterpret-cast"><a href="#4-reinterpret-cast" class="headerlink" title="4.reinterpret_cast"></a>4.reinterpret_cast</h1><p>​    reinterpret_cast类型转换只能对指针进行操作，reinterpret_cast类型转换提供的是一种更底层的转换模式–比特位上的重新解释，即对某一类型的内存地址的比特位以另一种类型来解释，这可能不好理解，在这放一张图来辅助理解。</p><p><img src="/2019/09/12/【C++】C++中的四种转换类型/Snipaste_2019-09-12_16-32-44.png" alt></p><p>​    p是指向字符串的char类型指针，i是指向整型的指针，i = reinterpret_cast&lt;int*&gt;(p)则将p所指向的内存里的比特位以int类型来重新解释并复制到i所指向的内存地址上，于是在输出 *i 时，输出的是一个整型的数值。</p><p>​    至于为什么cout&lt;&lt;p时不是输出的p所指向的地址而是地址里的内容，我始终没有弄明白，不过不影响对reinterpret_cast类型转换的理解。</p>]]></content>
      
      
      <categories>
          
          <category> 知识记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++】普通全局变量、静态全局变量、普通局部变量与静态局部变量</title>
      <link href="undefined2019/09/11/%E3%80%90C++%E3%80%91%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E9%9D%99%E6%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/"/>
      <url>2019/09/11/%E3%80%90C++%E3%80%91%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E9%9D%99%E6%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="1-普通全局变量"><a href="#1-普通全局变量" class="headerlink" title="1.普通全局变量"></a>1.普通全局变量</h1><p>​    普通全局变量是定义在函数和类外的或由extern标识或直接定义没有static标识的变量。</p><p>​    各个类型的变量之间最主要的区别就是作用域的不同了，普通全局变量的作用域在整个源程序中，全局变量对整个源程序中都是可见的，无论源程序是由单个文件还是多个文件组成，普通全局变量具有external链接属性，所以普通全局变量在整个源程序的各个文件中都可以被引用。</p><h1 id="2-静态全局变量"><a href="#2-静态全局变量" class="headerlink" title="2.静态全局变量"></a>2.静态全局变量</h1><p>​    静态全局变量是定义在函数和类外的由static标识的变量。</p><p>​    静态全局变量具有文件作用域，具有internal链接属性，只能在定义的文件中使用，在其他文件中可以定义同名的变量，而全局变量则不行，这里要注意静态全局变量与类静态全局变量是不同的，类静态全局变量受到类权限限制，不同的访问权限就之间决定了类静态全局变量的作用域，类全局变量的使用与类一致，能使用类的地方就能使用类全局变量。</p><p>​    关于普通全局变量和静态全局变量的区别，我一直没有弄得很清楚，我有在网上查阅很多bolg，大家的说法都出奇的一致，我上面写的也是在查阅很多blog后总结的，但是我实际测试时，普通全局变量和静态全局变量似乎都可以被其他文件使用，并且 在其他文件中定义静态全局变量似乎也没有报错，没有弄明白这个其他文件指的是什么文件。</p><p><img src="/2019/09/11/【C++】全局变量、静态全局变量、局部变量与静态局部变量/Snipaste_2019-09-11_21-36-28.png" alt></p><p><img src="/2019/09/11/【C++】全局变量、静态全局变量、局部变量与静态局部变量/Snipaste_2019-09-11_21-36-28.png" alt></p><h1 id="3-普通局部变量"><a href="#3-普通局部变量" class="headerlink" title="3.普通局部变量"></a>3.普通局部变量</h1><p>​    普通局部变量是定义在函数内的没有static标识的变量。</p><p>​    普通局部变量具有块作用域，生命周期从定义开始到跳出函数结束，普通局部变量每次使用都会初始化一次。</p><h1 id="4-静态局部变量"><a href="#4-静态局部变量" class="headerlink" title="4.静态局部变量"></a>4.静态局部变量</h1><p>​    静态局部变量的作用于和普通局部变量一致，但是静态局部变量的内存地址在函数结束后不会被销毁，且会保存赋值结果，静态局部变量和静态全局变量一样会一直驻留在静态区，静态局部变量只会初始化一次，在下一次函数被调用时不会再初始化而是直接调用。</p>]]></content>
      
      
      <categories>
          
          <category> 知识记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C#】C#两种二维数组的区别</title>
      <link href="undefined2019/09/11/%E3%80%90C#%E3%80%91C#%E4%B8%A4%E7%A7%8D%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>2019/09/11/%E3%80%90C#%E3%80%91C#%E4%B8%A4%E7%A7%8D%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>C#支持两种二维数组的定义方式（以int数组为例）：</p><h1 id="1-普通数组"><a href="#1-普通数组" class="headerlink" title="1.普通数组"></a>1.普通数组</h1><pre><code class="c#">int[,] array = new int[1,2];</code></pre><p>这种方式形式上较为简便，要注意的是new之后的[]里面是一定要注明数组大小的，不注明会报错，也就是说这种方式定义的数组是确定大小的。</p><p>数组的赋值：</p><pre><code class="c#">int[,] array = new int[2,3]{{1,2,3},{4,5,6}};</code></pre><h1 id="2-多播数组"><a href="#2-多播数组" class="headerlink" title="2.多播数组"></a>2.多播数组</h1><pre><code class="c#">int[][] array = new int[2][];</code></pre><p>这种方式需要注明行数，列数不能注明，注明会报错，这种方式定义的是一个函数确定而列数不确定的不确定大小的数组。</p><p>数组的赋值：</p><pre><code class="c#">int[][] array = new int[2][]{new int[]{1,2,3},new int[]{4,5,6}}</code></pre><p>两种二维数组是不能兼容的，即使用方式1定义的二维数组不能使用方式2来使用，反之亦然。</p>]]></content>
      
      
      <categories>
          
          <category> 知识记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Lua】Lua基础</title>
      <link href="undefined2019/09/09/%E3%80%90Lua%E3%80%91Lua%E5%9F%BA%E7%A1%80/"/>
      <url>2019/09/09/%E3%80%90Lua%E3%80%91Lua%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/2019090916141255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190909161442706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>参考博文：<a href="https://www.cnblogs.com/cjswwdz/p/5634442.html" target="_blank" rel="noopener">https://www.cnblogs.com/cjswwdz/p/5634442.html</a></p><p>XMind源文件：<a href="https://github.com/Goulandis/XMinds-2019.8.27/tree/master/Lua" target="_blank" rel="noopener">https://github.com/Goulandis/XMinds-2019.8.27/tree/master/Lua</a></p><p>学习地址：<a href="https://www.bilibili.com/video/av50685253?from=search&amp;seid=12754355294240767428" target="_blank" rel="noopener">https://www.bilibili.com/video/av50685253?from=search&amp;seid=12754355294240767428</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Unity3d】Unity常用技巧笔记</title>
      <link href="undefined2019/08/27/%E3%80%90Unity3d%E3%80%91Unity%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%E7%AC%94%E8%AE%B0/"/>
      <url>2019/08/27/%E3%80%90Unity3d%E3%80%91Unity%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="为Image组件添加sprite"><a href="#为Image组件添加sprite" class="headerlink" title="为Image组件添加sprite"></a>为Image组件添加sprite</h1><p><img src="/2019/08/27/【Unity3d】Unity常用技巧笔记/Snipaste_2019-08-27_11-35-00.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3d </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Unity3d】Space</title>
      <link href="undefined2019/08/25/%E3%80%90Unity3d%E3%80%91Space/"/>
      <url>2019/08/25/%E3%80%90Unity3d%E3%80%91Space/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/08/25/【Unity3d】Space/Unity3d_Space.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3d </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Unity3d】Lightmap</title>
      <link href="undefined2019/08/25/%E3%80%90Unity3d%E3%80%91Lightmap/"/>
      <url>2019/08/25/%E3%80%90Unity3d%E3%80%91Lightmap/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/08/25/【Unity3d】Lightmap/Unity_Lightmap.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3d </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络游戏基础</title>
      <link href="undefined2019/08/25/%E3%80%90%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E3%80%91%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%9F%BA%E7%A1%80/"/>
      <url>2019/08/25/%E3%80%90%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E3%80%91%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/08/25/【网络游戏】网络游戏基础/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%9F%BA%E7%A1%80.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序编程高级</title>
      <link href="undefined2019/08/25/%E3%80%90%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E3%80%91%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7/"/>
      <url>2019/08/25/%E3%80%90%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E3%80%91%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/08/25/【程序编程】程序编程高级/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序编程原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>物联网通信基础</title>
      <link href="undefined2019/08/25/%E3%80%90%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E3%80%91%E7%89%A9%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/"/>
      <url>2019/08/25/%E3%80%90%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E3%80%91%E7%89%A9%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/08/25/【网络通信】物联网通信基础/%E7%89%A9%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt基础</title>
      <link href="undefined2019/08/25/%E3%80%90Qt%E3%80%91Qt%E5%9F%BA%E7%A1%80/"/>
      <url>2019/08/25/%E3%80%90Qt%E3%80%91Qt%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>﻿<img src="https://img-blog.csdnimg.cn/20190825185005696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础</title>
      <link href="undefined2019/08/25/%E3%80%90Linux%E3%80%91Linux%E5%9F%BA%E7%A1%80/"/>
      <url>2019/08/25/%E3%80%90Linux%E3%80%91Linux%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>## </p><center>Linux学习笔记</center><h1 id="l-pwd：查看当前所在路"><a href="#l-pwd：查看当前所在路" class="headerlink" title="l  pwd：查看当前所在路"></a>l  <strong>pwd</strong>：查看当前所在路</h1><p>命令格式：命令 -选项 -参数（目录）</p><p>命令：</p><p>ls：查看当前路径下的文件</p><p>选项：</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td><strong>-d</strong></td><td>只查看当前目录的信息</td></tr><tr><td><strong>-l</strong></td><td>查看详细信息</td></tr><tr><td><strong>-a</strong></td><td>显示所有文件（包含隐藏文件）</td></tr><tr><td><strong>-h</strong></td><td>显示文件大小</td></tr></tbody></table><p>例：ls -l     命令 -选项</p><p>选项可以组合：ls -a -l/ls -al：查看所有文件的详细信息</p><p>ls -al /etc/   命令 -选项 -参数 ：查看etc目录下的所有文件的详细信息</p><h1 id="l-cd-：-路径切换"><a href="#l-cd-：-路径切换" class="headerlink" title="l  cd ： 路径切换"></a>l  <strong>cd</strong> <strong>：</strong> <strong>路径切换</strong></h1><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>“<strong>-</strong>”</td><td>返回到之前目录</td></tr><tr><td>“<strong>..</strong>”</td><td>返回上一级目录（“.”当前目录，“..”上一级目录）</td></tr><tr><td>“<strong>~</strong>”</td><td>到用户所在的家目录（家目录：用户所在目录，如windowsC盘的用户目录）</td></tr></tbody></table><p>touch ：cd到临时目录tmp下可创建新文件    touch 文件名</p><h1 id="l-Linux目录结构"><a href="#l-Linux目录结构" class="headerlink" title="l  Linux目录结构"></a>l  <strong>Linux目录结构</strong></h1><table><thead><tr><th>文件名</th><th>作用</th></tr></thead><tbody><tr><td>/boot</td><td>linux启动时，需要的文件</td></tr><tr><td>/dve</td><td>设备文件</td></tr><tr><td>/etc</td><td>配置文件</td></tr><tr><td>/home</td><td>用户家目录</td></tr><tr><td>/media</td><td>媒体文件</td></tr><tr><td>/mnt</td><td>挂载文件</td></tr><tr><td>/opt</td><td>第三方软件</td></tr><tr><td>/proc</td><td>虚拟化文件</td></tr><tr><td>/root</td><td>管理员的家目录</td></tr><tr><td>/run</td><td>远程文件</td></tr><tr><td>/srv</td><td>压缩过的文件</td></tr><tr><td>/sys</td><td>系统文件</td></tr><tr><td>/usr</td><td>安装的软件，</td></tr><tr><td>/var</td><td>可变数据、日志</td></tr><tr><td>/tmp</td><td>临时文件</td></tr><tr><td>/usr/bin</td><td>普通用户可以使用的命令</td></tr><tr><td>/usr/sbin</td><td>超级用户可以使用的命令</td></tr><tr><td>/usr/lib</td><td>32位库文件</td></tr><tr><td>/usr/lib64</td><td>64位库文件</td></tr></tbody></table><h1 id="l-Linux文件处理"><a href="#l-Linux文件处理" class="headerlink" title="l  Linux文件处理"></a>l  <strong>Linux文件处理</strong></h1><h2 id="文件类型判断："><a href="#文件类型判断：" class="headerlink" title="文件类型判断："></a><strong>文件类型判断：</strong></h2><p>-ls -l</p><p><img src="/2019/08/25/【Linux】Linux基础/1.png" alt="img"></p><table><thead><tr><th>文件以“_”开头</th><th>文件类型</th></tr></thead><tbody><tr><td>“d”</td><td>目录</td></tr><tr><td>“-”</td><td>文件</td></tr><tr><td>“l”</td><td>链接文件（类似win中快捷方式）</td></tr><tr><td>“b”</td><td>设备文件，提供存储接口的设备</td></tr><tr><td>“c”</td><td>设备文件，提供串行结合口的设备—键盘</td></tr></tbody></table><h2 id="文件处理："><a href="#文件处理：" class="headerlink" title="文件处理："></a><strong>文件处理：</strong></h2><p><img src="/2019/08/25/【Linux】Linux基础/2.png" alt="img"></p><p>cp            cp abc a：复制abc并命名为a/多文件复制：cp a abc goulandis/：复制a、abc到goulandis下</p><p>mv            mv 文件1 文件2：将文件1更名为文件2/mv 文件1（文件2 ….） 目录：将文件移动到目录下                 </p><p>rm             rm -f 文件1 （文件2…）：强制删除</p><p>mkdir       mkdir -p （要创建的）目录1/（要创建的）目录2：创建目录1并在目录1下创建目录2</p><h2 id="查看文件："><a href="#查看文件：" class="headerlink" title="查看文件："></a><strong>查看文件：</strong></h2><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><strong>cat/**</strong>路径**</td><td>查看文件</td></tr><tr><td>nl</td><td>显示的时候，顺便出现行号</td></tr><tr><td>tac</td><td>从最后一行开始显示</td></tr><tr><td>head</td><td>显示文件前10行 -n：设置行数</td></tr><tr><td>tail</td><td>显示文件尾10行 -n：设置行数</td></tr><tr><td>wc</td><td>显示文件行数，数字，字节</td></tr><tr><td>more</td><td>一页一页翻动</td></tr><tr><td><strong>less</strong></td><td>一页一页翻动</td></tr></tbody></table><table><thead><tr><th><strong>cat**</strong>和tac<strong>**选项</strong></th><th>作用</th></tr></thead><tbody><tr><td>-A</td><td>整合命令-vET（整合-v、-E、-T）</td></tr><tr><td>-b</td><td>列出行号，但是空白行不标志行号</td></tr><tr><td>-E</td><td>将结尾的断行字符（$）显示出来</td></tr><tr><td>-n</td><td>列出行号，空白行也会标志出来</td></tr><tr><td>-T</td><td>将tab键以^I显示</td></tr><tr><td>-v</td><td>列出一些看不出来的字符</td></tr><tr><td>&lt;区分大小写&gt;</td><td></td></tr></tbody></table><table><thead><tr><th><strong>nl**</strong>的选项**</th><th></th><th></th></tr></thead><tbody><tr><td>总选项</td><td>分选项</td><td>作用</td></tr><tr><td>b</td><td>ba</td><td>无论是否有空，都列出行号</td></tr><tr><td>bt</td><td>如果有空行，则不列出行号（默认）</td><td></td></tr><tr><td>n</td><td>nln</td><td>行号在屏幕最左方</td></tr><tr><td>nrn</td><td>行号在屏幕最右方，前面不加0</td><td></td></tr><tr><td>nrz</td><td>行号在屏幕最右方，前面加0</td><td></td></tr><tr><td>w</td><td></td><td>缩进多少位</td></tr></tbody></table><table><thead><tr><th><strong>more**</strong>的选项**</th><th>作用</th></tr></thead><tbody><tr><td>空格</td><td>向下翻一页</td></tr><tr><td>回车</td><td>向下翻一行</td></tr><tr><td>/字符串</td><td>搜索</td></tr><tr><td>:f</td><td>立刻显示文件名和行数</td></tr><tr><td>b</td><td>翻到第一页</td></tr><tr><td>q</td><td>离开</td></tr></tbody></table><table><thead><tr><th><strong>less**</strong>的选项**</th><th>作用</th></tr></thead><tbody><tr><td><strong>空格</strong></td><td>向下翻动一行</td></tr><tr><td><strong>回车</strong></td><td>向下翻动一页</td></tr><tr><td><strong>pagedown</strong></td><td>向下翻动一页</td></tr><tr><td><strong>pageup</strong></td><td>向上翻动一页</td></tr><tr><td><strong>n</strong></td><td>重复前一个搜索（操作：n）</td></tr><tr><td><strong>N</strong></td><td>反向重复前一个搜索（操作：shift+n）</td></tr><tr><td><strong>q</strong></td><td>退出</td></tr></tbody></table><table><thead><tr><th>head和tail的选项</th><th>作用</th></tr></thead><tbody><tr><td>-n</td><td>指定显示几行，默认10行</td></tr><tr><td>日志文件路径（/var/log/messages）</td><td>查看日志</td></tr></tbody></table><table><thead><tr><th>wc的选项</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>只显示字节</td></tr><tr><td>-w</td><td>只显示字数，一个字被定义为空白、跳格、换行字符、分隔字符串</td></tr><tr><td>-l</td><td>只显示行</td></tr></tbody></table><table><thead><tr><th><strong>Vim编辑器操作命令</strong></th><th>作用</th></tr></thead><tbody><tr><td><strong>i</strong></td><td>插入</td></tr><tr><td><strong>esc</strong></td><td>退出</td></tr><tr><td><strong>u</strong></td><td>撤销</td></tr><tr><td><strong>x</strong></td><td>删除</td></tr><tr><td><strong>v</strong></td><td>选择文本</td></tr><tr><td><strong>y</strong></td><td>复制</td></tr><tr><td><strong>yy</strong></td><td>复制当前行</td></tr><tr><td><strong>dd</strong></td><td>删除光标所在行</td></tr><tr><td><strong>p</strong></td><td>粘贴</td></tr><tr><td><strong>:w</strong></td><td>保存</td></tr><tr><td><strong>:wq</strong></td><td>保存并退出</td></tr><tr><td><strong>:q**</strong>！**</td><td>强制退出</td></tr></tbody></table><h2 id="软链接："><a href="#软链接：" class="headerlink" title="软链接："></a><strong>软链接：</strong></h2><p><img src="/2019/08/25/【Linux】Linux基础/3.png" alt="img"></p><p><img src="/2019/08/25/【Linux】Linux基础/4.png" alt="img"></p><h2 id="硬链接："><a href="#硬链接：" class="headerlink" title="硬链接："></a><strong>硬链接：</strong></h2><p><img src="/2019/08/25/【Linux】Linux基础/5.png" alt></p><p>ls -I ：查看Inode编号</p><h1 id="l-关机操作"><a href="#l-关机操作" class="headerlink" title="l  关机操作"></a>l  <strong>关机操作</strong></h1><table><thead><tr><th>sync</th><th>数据同步写入磁盘</th></tr></thead><tbody><tr><td><strong>shutdown</strong></td><td>常用关机指令</td></tr><tr><td>reboot、halt、poweroff</td><td>重启，关机</td></tr></tbody></table><table><thead><tr><th>shutdown的指令</th><th>作用</th></tr></thead><tbody><tr><td>-t</td><td>添加秒数。几秒后关机</td></tr><tr><td>-k</td><td>不是真关机，二十发出警告信息</td></tr><tr><td><strong>-r</strong></td><td>在系统服务都停止后，重启</td></tr><tr><td><strong>-h</strong></td><td>在系统服务都停止后，关机</td></tr><tr><td>-f</td><td>关闭，并且开机一个后强行略过磁盘检查</td></tr><tr><td>-F</td><td>重启后强制进行磁盘检查</td></tr><tr><td>-c</td><td>取消已经在进行的shutdown指令内容</td></tr><tr><td></td><td>shutdown -h now    现在马上停止服务并关机   shutdown -h 12：00       在12：00时刻停止服务并关机   shutdown -h +10     十分钟以后停止服务并关机   shutdown -r now     现在马上停止服务并重启   shutdown -r +30 ‘the system will reboot’       先发一个警告信息“the system will reboot”，系统将要在30分钟后重启   shutdown -k now ‘the system will reboot’     现在马上发出一个警告信息“the system will reboot”</td></tr></tbody></table><h1 id="l-Linux文件权限"><a href="#l-Linux文件权限" class="headerlink" title="l  Linux文件权限"></a>l  <strong>Linux文件权限</strong></h1><p><img src="/2019/08/25/【Linux】Linux基础/6.png" alt="img"></p><table><thead><tr><th>权限</th><th>连接</th><th>所有者</th><th>所属组</th><th>容量（默认单位B）</th><th>修改日期</th><th>文件名</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th><strong>文件的权限</strong></th><th></th></tr></thead><tbody><tr><td>r、w、x ： 读、写、执行，没有权限就是-</td><td></td></tr><tr><td>第一组rwx</td><td>文件所有者的权限</td></tr><tr><td>第二组rwx</td><td>文件所属组的权限</td></tr><tr><td>第三组rwx</td><td>文件其他人的权限</td></tr></tbody></table><table><thead><tr><th><strong>目录的权限</strong></th><th></th></tr></thead><tbody><tr><td>r</td><td>具有读取目录的结构列表的权限，可以查看目录下有哪些文件</td></tr><tr><td>w</td><td>该权限对于目录来说是很大的</td></tr><tr><td>1</td><td>可以在该目录下新建新的文件和目录</td></tr><tr><td>2</td><td>可以删除已存在的文件和目录</td></tr><tr><td>3</td><td>将已存在的文件和目录重命名</td></tr><tr><td>4</td><td>移动该目录内的文件和目录的位置</td></tr><tr><td>X</td><td>是否可以进入该目录</td></tr></tbody></table><table><thead><tr><th><strong>文件权限的修改</strong></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>命令</td><td>命令作用</td><td>格式</td><td>选项</td><td>选项作用</td><td></td></tr><tr><td>chown</td><td>修改文件的拥有者，前提是要有该拥有者</td><td>chown 拥有者   文件/目录</td><td>-R</td><td>递归修改</td><td></td></tr><tr><td>chgrp</td><td>修改文件所属组，前提是要有该组</td><td></td><td>-R</td><td>递归修改</td><td></td></tr><tr><td>chmod</td><td>修改拥有者和所属组的权限</td><td></td><td></td><td></td><td></td></tr><tr><td>加减法</td><td>chmod    u/g/o+/-/=r/w/x 123：   将文件1213给用户/组/其他人加/减/赋予一个读/写/执行权限</td><td></td><td></td><td></td><td></td></tr><tr><td>数字法</td><td>r=4    w=2  x=1 ： chmod  632 123 ：   将文件123给用户赋予r和w权限，给组赋予wx权限，给其他人赋予w权限</td><td></td><td></td><td></td><td></td></tr><tr><td>chown -R goulandis 123 ： 将123目录下的所有文件包括目录本身的拥有者修改为goulandis</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p><strong>默认权限：</strong></p><p>umask      查看当前用户的umask权限       </p><p>umask –(选项) ：临时修改默认权限</p><p>/etc/bashrc ： 永久修改默认权限（通过修改脚本文件实现）</p><p>umask的选项说明</p><p>0022         拿走的权限</p><p>​         第一个数字表示特殊权限</p><p>​         022=rwxr-xr-x ：不拿走用户的权限、拿走用户组的w权限、拿走其他用户的w权限</p><p>目录无法拿走x权限</p><p>普通用户umask值 0002</p><p>root用户umask值 0022</p><h2 id="文件的特殊权限"><a href="#文件的特殊权限" class="headerlink" title="文件的特殊权限:"></a><strong>文件的特殊权限:</strong></h2><p><img src="/2019/08/25/【Linux】Linux基础/7.png" alt="img"></p><p>当s出现在拥有者的x权限的位置时，表示拥有者有SUID的权限（Set UID）</p><p>当s出现在用户组的x权限的位置时，表示用户组有SGID的权限（Set GID）</p><p>当s出现在其他人的x权限的位置时，表示其他人有SBIT的权限（Sticky Bit）</p><table><thead><tr><th>SUID</th><th>临时获取文件拥有者的权限—–只能针对文件</th></tr></thead><tbody><tr><td>SGID</td><td>可以作用于目录，也可以作用于文件</td></tr><tr><td>作用于文件 ： 和SUID作用一样</td><td></td></tr><tr><td>作用与目录 ： 继承父级目—–目录会不停的继承，下级目录会一直继承父级目录的权限值</td><td></td></tr><tr><td>SBIT</td><td>只有文件的拥有者才能删除修改该目录下的文件—–只能针对目录</td></tr><tr><td>S和T有大小写之分   大写 ： 没有x权限   小写 ： 有x权限</td><td></td></tr><tr><td>数字法 ：SUID=4、SGID=2、SBIT=1</td><td></td></tr></tbody></table><p><img src="/2019/08/25/【Linux】Linux基础/8.png" alt="img"></p><h1 id="l-Linux进程"><a href="#l-Linux进程" class="headerlink" title="l  Linux进程"></a>l  <strong>Linux进程</strong></h1><p>进程 ：已经启动的可执行程序的运行实例</p><p>PID : 进程的ID（每一个进程都有唯一的PID）</p><p>PPID ： 父进程的ID</p><p>任何一个进程都可以创建紫进程</p><table><thead><tr><th>ｐｓ　：　查看当前的进程情况</th><th></th></tr></thead><tbody><tr><td>选项</td><td>作用</td></tr><tr><td>－ａｕｘ／ａｕｘ</td><td>列出所有进程</td></tr><tr><td>－ｅｆ</td><td>列出所有进程</td></tr><tr><td>－ｌ</td><td>列出和当前用户有关的进程</td></tr><tr><td>－ｕ</td><td>查看某一用户的进程</td></tr><tr><td>－ｔｏｐ</td><td>实时查看进程状况</td></tr></tbody></table><p><img src="/2019/08/25/【Linux】Linux基础/9.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#高级</title>
      <link href="undefined2019/08/25/%E3%80%90C#%E3%80%91C#%E9%AB%98%E7%BA%A7/"/>
      <url>2019/08/25/%E3%80%90C#%E3%80%91C#%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20190825170050917.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190825170113521.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20190825170131207.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#中级</title>
      <link href="undefined2019/08/25/%E3%80%90C#%E3%80%91C#%E4%B8%AD%E7%BA%A7/"/>
      <url>2019/08/25/%E3%80%90C#%E3%80%91C#%E4%B8%AD%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p>﻿<img src="https://img-blog.csdnimg.cn/20190825154217891.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++】C++进阶</title>
      <link href="undefined2019/08/23/%E3%80%90C++%E3%80%91C++%E8%BF%9B%E9%98%B6/"/>
      <url>2019/08/23/%E3%80%90C++%E3%80%91C++%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<p>﻿1.C++介绍：<br>    C语言作为结构化和模块化语言适合规模较小的程序，对于大规模的复杂程序，能够高度抽象和建模的C++则更加适合，C++是C语言的加强版，以C语言为基础，并且完全兼容C语言的特性。<br><img src="https://img-blog.csdnimg.cn/20190623193001260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2.C++对C语言的增强语法<br>    2.1.命名空间<br>    2.2.引用<br>    2.3.函数与运算符的重载<br>    2.4.面向对象的特性<br>    2.5.泛型编程<br>    2.6.异常处理<br>    2.7.标准模板库<br>下面笔者就者7个特性进行详细说明：<br>3.命名空间<br>    命名空间是C++提供的一种解决不同文件互相调用时符号名字冲突的方法，一个命名空间就是一个作用域，在不同的命名空间下允许相同的名字符号代表不同的实体。<br>    3.1命名空间的定义<br><img src="https://img-blog.csdnimg.cn/20190623200228628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>        注意：命名空间的声明要在类和函数的外面定义，并且没有分号结束。<br>        3.2.命名空间成员的引用<br>            命名空间名::成员名<br>    如：<br>    1.cpp</p><p>#include<iostream><br>using namesapce std;<br>/*<br>命名空间的声明方式，我们需要用到命名空间中的什么方法就在{}内加入什么方法的声明，当然直接使用“using namespace A”来声明A命名空间也是可以的，但是这种命名方法会将A命名空间下的所有方法都作声明，包括我们可能没有使用的方法，当工程很大时，这种做法会导致代码臃肿。<br><em>/<br>namespace A {<br>    int add(int a,int b);<br>}<br>int add(int a,int b);<br>int mian(){<br>    int a = 1,b = 1;<br>/</em><br>在很多多人编程的时候，如果各程序员之间不一直进行密切的交流，极容易出现变量名或方法名类名等相同的情况，这样    在；多文档联合编译时，编译器会无法区分同名符号而报错，而命名空间就很好的解决了这种问题，我们为各个文档都定义一个唯一的命名空间，这样即使是相同符号也可以通过命名空间唯一标识了，命名空间的出现极大的改善了多人编程的困处<br>*/<br>    cout &lt;&lt; add(a,b)&lt;&lt;”  “&lt;&lt;A::add(a,b)&lt;&lt; endl;<br>    return 0;<br>    }<br>int add(int a,int b){<br>    return(a + b);<br>}<br>    2.cpp</iostream></p><p>#include<iostream><br>namespace A {<br>    int add(int a,int b){<br>        return(a + b)；<br>    }<br>}<br>3.3.命名空间的别名<br>    命名空间是可以另起别命的，别命是已定义的命名空间的可代替的名字，一个命名空间可以有很多个别名，所有的别命和命名空间原名可以互换使用<br>    别命的定义：namespace 别命 = 命名空间原名;<br>    <img src="https://img-blog.csdnimg.cn/2019062320111766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    3.4.命名空间的成员类型<br>        命名空间的成员类型可以是变量、常量、函数、结构体、联合体、枚举、类、嵌套的命名空间<br>    3.5.全局命名空间<br>        在全局作用域中定义的命名空间，大多数命名空间都属于全局命名空间。即自定义的命名空间是全局命名空间的扩张和细分。全局命名空间是隐式声明的，它存在于每一个程序中。<br>        由于全局命名空间是隐含的，它没有名字，所以使用“::成员名字”引用全局命名空间。<br>    3.6.匿名命名空间<br>        匿名命名空间与全局命名空间类似，也没有名字，但是匿名命名空间定义在局部作用域，不能用于多文件编译。<br>        匿名命名空间可以直接使用变量名引用成员。<br>    4.引用<br>        4.1.什么是引用？<br>            引用即别命，是某一个变量或对象的别命，绑定一个引用到一个变量或对象，即引用初始化，之后对引用的操作完全等价于对与其绑定的变量或对象的操作。<br>    4.2.引用的定义<br>        类型 &amp;引用名 = 目标变量名;<br>        需要注意的是：<br>            - &amp;不是求地址运算符，而是起标志作用<br>            - 引用的类型必须和其所绑定的变量类型相同<br>            - 声明应用的同时必须对其初始化，否则系统会报错<br>            - 引用相当于变量或对象的别命，因此不可将已绑定的引用再绑定其他变量或对象，也不可将一个引用绑定另一个引用。<br>    4.3.引用与指针的区别<br>        +占用存储空间上：<br>                -引用占用一个地址空间，本地计算机的一个地址空间是多少位，引用就占多少位的地址空间。<br>                -而指针除了占用一个地址空间外，还占用一个数据空间用于存储其指向的变量或对象的地址。<br>        +在操作上：<br>                -引用声明的同时必须对其初始化，且初始化后引用不可更改，引用不能为空。如：int &amp;a ;是错误的用法，正确的用法应该是：int &amp;a = b;<br>                -指针的声明可以在任何时候初始化，且指针在后续操作中可以变更其指向的变量或对象，指针可以为空。<br>        +存储内容上<br>                -“sizeof引用”得到的是引用所指向的变量或对象的大小<br>                -“sizeof指针”得到的是指针本身的大小<br>        +层级上<br>                -引用只能有一级，引用不可以再指向引用<br>                -指针理论上对级数没有限制<br>        +可以将引用理解为不可更改的指针，即：类型* const 指针变量<br>    4.4.对数组的引用<br>        类型 （&amp;引用名）[数组下标] = 数组名;<br>        如：对int a[3]数组的引用为int (&amp;quote)[3] = a;即将引用名替换成数组名。<br>        这里要注意，“()”是不能省略的，因为如果省略()，则会改变优先级，变成int &amp;(quote[3]) = a;而出现语法错误。<br>    4.5.对指针的引用<br>        类型* &amp;引用名 = 指针名;<br>        如：int* &amp;quote = p;<br>    4.6.引用的作用<br>        引用既可以作为别命使用，还可以作为函数的参数、函数的返回值使用。<br>        需要注意的是，引用作为函数的返回值时不能返回局部变量的引用。<br>    至此，我可能提出这样的疑问：引用能做的事指针也能做，引用不能做的事指针还能做，那么C++么什么要引入“引用”这个概念呢？<br>    这是因为，指针的操作太过于强大，正因如此对指针的使用存在一定的风险，所谓“收益与风险并存”，在很多高版本的编译器中已经不能再操作指针了，如VS2015，而C++之所以还保留着指针，是因为指针的魅力无比诱人，尽管有风险却不愿意就此抛弃。<br>    引用的另一个用处我们举一个例子来说明<br>    如：<br>    int add_1(int b){<br>        b++;<br>    }<br>    int add_2(int &amp;c){<br>        c++;<br>    }<br>    void mian(){<br>        int a = 1;<br>        int &amp;a = a;<br>        cout&lt;&lt;add_1(a)&lt;&lt;endl;<br>        cout&lt;&lt;add_2(&amp;a)&lt;&lt;endl;<br>    }<br>    我们的输出结果是：1 2，为什么呢?因为普通的参数传递，传递的是参数的拷贝，如add_1我们对b++，实际进行运算的是形参b，而实参a却没有发生运算，所以cout&lt;&lt;add_1(a)输出1，而如果传递引用的话，我们在函数add_2中对引用的操作实质上就是对a进行运算，因为&amp;a就是a。<br>    4.7.常引用<br>        const 类型 &amp;引用名 = 目标变量名<br>        常引用可以引用常量也可以引用变量，常引用不允许通过引用对其绑定的变量或对象进行修改。<br>        <img src="https://img-blog.csdnimg.cn/2019062512243728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">5.函数重载<br>    5.1.C++重载的实现<br>    从本质上来说，C++之所以能实现函数的重载是因为C++编译器对函数名的处理方法进行了优化，我们来对比一下C语言编译器和C++编译器对函数名的编译<br>    +C语言编译器<br>        对函数 int add(int a);编译后的名字为：add<br>    +C++编译器<br>        对函数int add(int a);编译后的名字为：addi，对int add(int a,float b);编译后的名字为：addij，C++编译器使用函数名和参数类型的共同组合成编译后函数的唯一标识，即可实现函数的重载。<br>    5.2.重载的定义<br>        重载就是在相同的声明域中函数名相同而参数列表不同，通过函数的参数表唯一标识的函数。<br>    5.3.函数的默认参数<br>        C++可以使用默认参数，即在函数声明时为参数提供一个默认值，当函数调用时没有指定这个参数的值时，编译器会自动使用默认值替换。<br>        <img src="https://img-blog.csdnimg.cn/20190625221621705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>        需要注意的是，默认参数只能放在声明或定义处，能放在声明处就放在声明处。如果某个参数是默认参数，那么其后的参数也必须都是默认参数，如：int add(int a = 1,int b,int c);编译器将报错，而int add(int a,int b = 1,int c = 2);则不会报错，因为参数在传递的时候是从左到右的，首先使用无默认参数的参数列表，当遇到没有传入实参的形参时开始使用默认参数的参数列表。使用默认参数的情况仅限于用在没有没有重载冲突的函数上，如：重载add函数，int add(){…} int add(int a = 1,int b = 2){…},此时调用add();将调用不带参数的add()函数。<br>        <img src="https://img-blog.csdnimg.cn/20190625222013457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">5.4.内联函数<br>    5.4.1.为什么需要内联函数？<br>        在程序执行的过程中，当碰到函数调用时，系统要将程序当前状态保存到栈中，同时跳转到函数代码处执行函数体，此过程需要占用时间和空间，是的程序执行效率低下。当然我们声明一个内联函数只是建议编译器将此函数作为内联函数，但是编译器有自己的判断算法，在编译时编译器会自行判断我们声明的内联函数是否值得变为内联函数，以保证主程序体不会过于臃肿，所以我们声明的内联函数不一定会成为内联函数。<br>    5.4.2.内联函数的定义<br>        inline 返回值类型 函数名(参数列表){函数体;}<br>    5.4.3.内联函数是一种用空间换时间的措施，通常只有较短的函数才定义为内联函数。<br>6.new和delete运算符<br>    6.1.new运算符的功能是在堆区分配内存，通过new运算符获得的内存空间都处于堆上。delete运算符的功能正好与new相反，delete运算符的功能是释放new运算符的在堆区创建的内存，new运算符与delete运算符最好是配套出现，即使用new运算符创建了内存就一定要用delete运算符在不需要的时候此内存的时候将其释放，为什么呢？因为堆区的内存是不会随着程序结束而释放的，堆区的内存只要在操作系统关闭时才会释放，所以如果不手动释放new运算符在堆区创建的内存，则会造成大量无用数据占据着堆区内存，当堆区内存被占满时这会出现系统无堆区内存可用而出现系统死机。<br>    6.2.new/delete运算符的使用<br>        new &lt;数据类型&gt; (参数)<br>        delete &lt;对象指针&gt;/delete &lt;对象数组指针&gt;<br>        <img src="https://img-blog.csdnimg.cn/201907121654256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    6.3.那么C++的new/delete与C语言的malloc/free有什么区别呢？<br>        -它们都是动态管理内存的入口<br>        -malloc/free是C/C++标准库函数，而new/delete是C++操作符<br>        -malloc/free只是动态分分配/释放内存空间，而new/delete除了分配内存空间还会调用构造/析构函数进行初始化/清理（清理成员）<br>        -malloc/free需要手动计算类型大小且返回值为void，而new/delete可以自行计算类型大小返回对应类型的指针<br>        -new/delete在底层是调用了malloc/free的。可以认为是C++对malloc/free的封装<br>        -malloc/free申请空间后需要判空，new/delete则不需要<br>        -new直接跟类型，malloc跟字节数。<br>        new/delete和malloc/free的区别是C++企业招聘时特别喜欢考的一项<br>7.程序的内存空间<br>    7.1.指针的内存操作<br>        -指针不仅可以可以指向变量还可以指向函数<br>        -有new运算符在堆区创建的内存空间由位于栈区的指针确定入口<br>    <img src="https://img-blog.csdnimg.cn/20190712165857369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>说到这，我们有必要了解一下计算机程序的内存结构，供程序运行的内存空间分为：堆区、栈区、.data段、.bss段、.ro段、.txt段，我使用一张图来说明<br><img src="https://img-blog.csdnimg.cn/20190712170749180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>8.面向对象编程的特点<br><img src="https://img-blog.csdnimg.cn/2019071310135053.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>9.C++中的类<br>    9.1.类的定义<br><img src="https://img-blog.csdnimg.cn/2019071310150942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    9.2.访问权限<br>        C++为类的成员添加了三种访问权限<br>        -public–公有成员：权限最高，在public修饰下的成员是类的外部接口，可以被类的成员函数和对象直接访问。<br>        -protected–保护成员：权限居中，可以被类的成员函数和其派生类的成员函数直接访问，但不能被类的对象和派生类的对象直接访问。<br>        -private–私有成员：权限最低，只能通过类的成员函数访问。<br>    9.3.类的成员<br>        -成员变量：类的成员变量用以描述一个对象的属性信息，与一般的变量声明相同，但类的成员变量只能在类的声明体中定义，类的成员变量一般在类的构造函数中初始化，但这不是必须的。<br>        -成员函数：用来描述一个对象的行为动作，与一般的函数声明相同，但只能放在类的声明体中声明，成员函数可以在类内实现也可以在类外实现，但在类内实现则形成内联的成员函数，会使类变得冗杂，所以成员函数的实现最好在类外实现，类成员函数可以重载和带默认参数。<br>    9.5.类的成员函数与成员变量的声明与实现<br>    <img src="https://img-blog.csdnimg.cn/20190713104139644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    9.6.struct和class的区别<br>        -C++对struct关键字扩展了其功能，和class的功能几乎等价<br>        -struct的成员默认访问权限是public，而class是private<br>    9.7.this指针<br>        -this指针是一个特殊的指针，指向对象的自身的首地址<br>        -每一个对象的成员函数都有一个this指针，指向调用的对象，如果要引用整个对象则通过*this引用<br>        -this指针仅能在类的内部使用，即只能在类的声明体或成员函数中使用<br>    9.8.static关键字<br>        9.8.1.static修饰的成员变量–静态成员变量<br>                -static修饰的变量存储在静态变量区<br>                -在类中static关键字修饰的变量被此类的所有对象共享，即所有对象共享这一个变量<br>                -static修饰的变量必须在类外初始化，不可以在定义的时候直接初始化<br>                -static修饰的公有成员变量可以直接通过类名来访问，没有staic修饰的成员变量只能通过对象才能访问<br>        <img src="https://img-blog.csdnimg.cn/20190713105202141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>        9.8.2.static修饰的成员函数–静态成员函数<br>                -static修饰的成员函数也可以直接通过类名访问<br>                -静态成员函数只能访问静态成员变量<br>        9.8.3.类的静态与非静态部分<br>                -静态部分只属于类，与类一起存放在内存的静态区，被所有对象共享<br>                -非静态部分属于对象，每个对象都有自己的非静态部分，互不影响<br>                -静态部分只能直接访问静态部分，非静态部分可以访问所有部分<br>                那么为什么静态部分只能直接访问静态部分，而非静态部分却可以访问所有部分呢？<br>                那是因为，非静态成员变量/函数是属于对象的，只能通过对象来访问，而静态部分是属于类的，使用静态部分时没有确定对象的存在，所以不能确定静态部分应该访问哪个对象的非静态部分，而静态部分是属于类的，所有对象共享，所以通过对象使用非静态部分时，可以访问静态部分。<br>    思导图：<br><img src="https://img-blog.csdnimg.cn/20190623192350471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190712170853343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></iostream></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Unity3d】游戏截屏</title>
      <link href="undefined2019/08/23/%E3%80%90Unity3d%E3%80%91%E6%B8%B8%E6%88%8F%E6%88%AA%E5%B1%8F/"/>
      <url>2019/08/23/%E3%80%90Unity3d%E3%80%91%E6%B8%B8%E6%88%8F%E6%88%AA%E5%B1%8F/</url>
      
        <content type="html"><![CDATA[<p>﻿在Unity3d中游戏截屏操作比较简单，主要使用通过Application类下的CaptureScreenhot方法实现：</p><pre><code>if (Input.GetKeyDown(KeyCode.P)) {            Application.CaptureScreenshot(&quot;截图&quot; +screenhotNom+&quot;.jpg&quot;);            screenhotNom++;//截图序号        }</code></pre><p>截取的图片以设计者规定名字存储在与exe文件一起生成的的Data文件下，没有导出的项目直接存储到工程文件夹下<br><img src="https://img-blog.csdnimg.cn/20190622155156312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3d </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Unity3d】简单的存档与读档</title>
      <link href="undefined2019/08/23/%E3%80%90Unity3d%E3%80%91%E5%AD%98%E6%A1%A3%E4%B8%8E%E8%AF%BB%E6%A1%A3/"/>
      <url>2019/08/23/%E3%80%90Unity3d%E3%80%91%E5%AD%98%E6%A1%A3%E4%B8%8E%E8%AF%BB%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<p>﻿在Unity3d中，游戏的存档与读档主要由PlayerPrefs类来完成，在Windows下PlayerPrefs存档主要存储在注册表中，路径为HKCU\Software[company name][product name] ，这里的company name和product name由作者自己确定，在Edit-&gt;Project Settings-&gt;Player中可以设置<br><img src="https://img-blog.csdnimg.cn/20190622143530421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>PlayerSettings视图<br><img src="https://img-blog.csdnimg.cn/20190622143747327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>那么如何设计游戏存档呢？<br>以笔者个人的经验而言，在游戏设计之初，我们就应该想好需要存档的数据，为需要保存的数据或状态设计可供读取的状态标志，以便以后在设计存档时，提供给PlayerPrefs类的方法使用。<br>PlayerPrefs类提供如下方法供设计者使用<br><img src="https://img-blog.csdnimg.cn/20190622144312778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到，PlayerPrefs类中没有提供对bool型数据的存储方法，由此可以看出为需要保存的数据或状态设计可供读取的状态标志的重要性，否则那些由bool型数据确定的状态将无法被存档。<br><img src="https://img-blog.csdnimg.cn/20190622151126795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下面给一段示例代码：</p><pre><code> /*     * inventory.charge--int--能量电池数量     * inventory.playerTransform--float--玩家位置     * talk.yeshu--int--man的任务进度     * talk.wyeshu--int--women的任务进度      */    void gameSave() {        PlayerPrefs.SetInt(&quot;charge&quot;, inventory.charge);        PlayerPrefs.SetInt(&quot;yeshu&quot;, talk.yeshu);        PlayerPrefs.SetInt(&quot;wyeshu&quot;, talk.wyeshu);        PlayerPrefs.SetFloat(&quot;playerPosition.x&quot;, inventory.playerTransform.position.x);        PlayerPrefs.SetFloat(&quot;playerPosition.y&quot;, inventory.playerTransform.position.y);        PlayerPrefs.SetFloat(&quot;playerPosition.z&quot;, inventory.playerTransform.position.z);        PlayerPrefs.Save();    }    void gameRead() {        if (PlayerPrefs.HasKey(&quot;charge&quot;))//存档读取的一般方式            inventory.charge = PlayerPrefs.GetInt(&quot;charge&quot;);        if (PlayerPrefs.HasKey(&quot;yeshu&quot;))            talk.yeshu = PlayerPrefs.GetInt(&quot;yehsu&quot;);        if (PlayerPrefs.HasKey(&quot;wyeshu&quot;))            talk.wyeshu = PlayerPrefs.GetInt(&quot;wyeshu&quot;);        if (PlayerPrefs.HasKey(&quot;playerPosition.x&quot;))            x = PlayerPrefs.GetFloat(&quot;playerPosition.x&quot;);        if (PlayerPrefs.HasKey(&quot;playerPosition.y&quot;))            y = PlayerPrefs.GetFloat(&quot;playerPosition.y&quot;);        if (PlayerPrefs.HasKey(&quot;playerPosition.z&quot;))            z = PlayerPrefs.GetFloat(&quot;playerPosition.z&quot;);        inventory.playerTransform.position = new Vector3(x, y, z);    }</code></pre><p>那么对于已经产生的注册表我们如何查看呢？<br>在Windows下通过注册表编辑器查看注册表，通过Win+R将呼出“运行”，输入“regedit”即可打开注册表编辑器在HKCU\Software[company name][product name] 路径下即可找到我们已经生成的注册表<br><img src="https://img-blog.csdnimg.cn/20190622151747405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3d </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Unity3d】Animation</title>
      <link href="undefined2019/08/23/%E3%80%90Unity3d%E3%80%91Animation/"/>
      <url>2019/08/23/%E3%80%90Unity3d%E3%80%91Animation/</url>
      
        <content type="html"><![CDATA[<p>﻿1.总索引<br><img src="https://img-blog.csdnimg.cn/2019061314131628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>1.1.视图简介<br><img src="https://img-blog.csdnimg.cn/20190520144632375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190520143240580.png" alt="在这里插入图片描述"><br>2.动画分类<br><img src="https://img-blog.csdnimg.cn/20190613141413854.png" alt="在这里插入图片描述"></p><p>2.1.普通动画<br><img src="https://img-blog.csdnimg.cn/20190613141551260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    2.2.人物角色动画<br>    <img src="https://img-blog.csdnimg.cn/20190613141959166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    2.2.1.人物角色动画的导入<br>    <img src="https://img-blog.csdnimg.cn/20190613142213379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>+大图导向<br>    -骨骼映射视图的打开 <img src="https://img-blog.csdnimg.cn/20190531125401236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    -骨骼映射视图和骨骼映射表的修改<img src="https://img-blog.csdnimg.cn/20190531125301603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>-三种动画的导入方式<br><img src="https://img-blog.csdnimg.cn/20190613142757765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">-模型导入注意事项<br><img src="https://img-blog.csdnimg.cn/20190613142937598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190531130631610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    <img src="https://img-blog.csdnimg.cn/20190531130654193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2.3.IK动画<br><img src="https://img-blog.csdnimg.cn/20190613143849254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2.4.TimeLine<br><img src="https://img-blog.csdnimg.cn/20190613143939800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>+大图导向<br>    -存储<br>    <img src="https://img-blog.csdnimg.cn/20190613144055967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    -Playable Track<br>    <img src="https://img-blog.csdnimg.cn/20190613144133197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.AnimatorController(状态机)<br><img src="https://img-blog.csdnimg.cn/20190613144259619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.1.状态机的打开方式<br><img src="https://img-blog.csdnimg.cn/20190613144350891.png" alt="在这里插入图片描述"><br>3.2.Animator视图简介<br><img src="https://img-blog.csdnimg.cn/20190613144502456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.3.作用<br><img src="https://img-blog.csdnimg.cn/20190613144550261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.4.精细控制<br><img src="https://img-blog.csdnimg.cn/20190613144641944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>+大图导向<br><img src="https://img-blog.csdnimg.cn/20190613144744729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.5.混合树<br><img src="https://img-blog.csdnimg.cn/201906131452528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.5.1.四种2D混合树<br><img src="https://img-blog.csdnimg.cn/20190613145340965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.5.2.大图导向<br> -混合树的创建<br> <img src="https://img-blog.csdnimg.cn/20190613145440631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> -1D混合树Inspector<br> <img src="https://img-blog.csdnimg.cn/20190613144953557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> -2D混合树Inspector<br> <img src="https://img-blog.csdnimg.cn/20190613145057715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.6.Avatar Mask骨骼遮罩<br><img src="https://img-blog.csdnimg.cn/20190613145729200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4.MacthTarget场景动画匹配技术<br><img src="https://img-blog.csdnimg.cn/20190613145909634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4.1.核心方法<br><img src="https://img-blog.csdnimg.cn/20190613150056658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4.2.MacthTarget函数细述<br><img src="https://img-blog.csdnimg.cn/20190613150207340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4.3.难点<br><img src="https://img-blog.csdnimg.cn/20190613150430468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>+大图导向<br><img src="https://img-blog.csdnimg.cn/2019061315050794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>5.相机运动<br><img src="https://img-blog.csdnimg.cn/20190613150709467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>+大图导向<br><img src="https://img-blog.csdnimg.cn/20190613150735692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>6.学习过程中遇到的问题<br><img src="https://img-blog.csdnimg.cn/20190613150827535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>7.函数方法<br><img src="https://img-blog.csdnimg.cn/20190613150913675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>8.动画的Inspector<br><img src="https://img-blog.csdnimg.cn/20190613151018312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3d </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【计算机图形学】多边形填充算法</title>
      <link href="undefined2019/08/23/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E3%80%91%E5%A4%9A%E5%8F%98%E5%BD%A2%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/"/>
      <url>2019/08/23/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E3%80%91%E5%A4%9A%E5%8F%98%E5%BD%A2%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<pre><code> 首先对于如下的多边形：</code></pre><p><img src="https://img-blog.csdnimg.cn/20190618080545123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="1-有效边表填充算法"><a href="#1-有效边表填充算法" class="headerlink" title="1.有效边表填充算法"></a>1.有效边表填充算法</h1><h2 id="1-1-有效边表填充算法分为如下几个步骤："><a href="#1-1-有效边表填充算法分为如下几个步骤：" class="headerlink" title="1.1.有效边表填充算法分为如下几个步骤："></a><strong>1.1.有效边表填充算法分为如下几个步骤</strong>：</h2><p>​    1.1.1.将多边形所有的边分别与扫描线1计算交点，得到交点集，与扫描线计算的边没有顺序要求。<br>​    1.1.2.将点集按标x的大小递增排序，得到有序点集。<br>​    1.1.3.将有序点集两两配对，得到对应的像素区间。<br>​    1.1.4.将像素区间内的像素填充颜色，至此第一条扫描线上处于多边形内的的像素填充完毕。<br>​    1.1.5.扫描线标号加1，重复以上步骤，直至到最后一条扫描线。<br>​    如：对于扫描线3（y=3）与多边形所有的边计算交点，得到与P3P4交于点（4.5，3），与P3P2交于点（2.4，3），与P5P6交于点（8.8，3），与P5P4交于点（7，3）。<br>​    圆整处理得到点集（5，3）、（2，3）、（9，3）、（7，3）。<br>​    递增排序得到有序点集（2，3）、（5，3）、（7，3）、（9，3）。<br>​    两两配对得到扫描线3上的填充像素区间[2，5]、[7，9]。<br>​    填充区间内的所有像素。<br>​    得到如图所示的填充效果：<br><img src="https://img-blog.csdnimg.cn/20190617115850448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>全部填充得到如下效果：<br><img src="https://img-blog.csdnimg.cn/20190617115915999.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-2-至此我们发现如下疑问："><a href="#1-2-至此我们发现如下疑问：" class="headerlink" title="1.2.至此我们发现如下疑问："></a><strong>1.2.至此我们发现如下疑问：</strong></h2><p>​    1.2.1.像素填充的多边形面积大于多边形实际面积。<br>​    可能上图不太明显，我们举一个明显一点的例子，如下正方形：<br><img src="https://img-blog.csdnimg.cn/20190617115935411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们填充后的效果为：<br><img src="https://img-blog.csdnimg.cn/20190617115949648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>​    而正方形的实际面积是4，在显示器上一个像素为一面积，正方形应该占4个像素点，而实际却占了9个像素点，对于这种问题，有效边表填充算法采用“左闭右开”，“下闭上开”的原则进行像素点的填充，按照此原则，正方形的填充效果如下：<br><img src="https://img-blog.csdnimg.cn/20190617120002618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>1.2.1.对于点集（1，3）、（1，8）它们分别为扫描线1与P3P2、P3P4、P5P4、P5P6的交点，而在实际计算中它们仍只是两个点，如果处理不当，计算机可能会两两配对得到区间（3，8）而填充到错误的像素区间。<br>对于此问题，有效边表填充算法采用分类连接点进行处理。<br>有效边表填充算法将多边形的各个连接点分为三类连接点：</p><h3 id="普通连接点："><a href="#普通连接点：" class="headerlink" title="+普通连接点："></a><strong>+普通连接点：</strong></h3><p>​    连接点所在的两条边分别处于其所在的扫描线的上方和下方，如P2点。</p><h3 id="局部最低点："><a href="#局部最低点：" class="headerlink" title="+局部最低点："></a><strong>+局部最低点：</strong></h3><p>​    连接点所在的两条边都处于其所在的扫描线的上方，如P3、P5点。</p><h3 id="局部最高点："><a href="#局部最高点：" class="headerlink" title="+局部最高点："></a><strong>+局部最高点：</strong></h3><p>​    连接点所在的两条边都处于其所在的扫描线的下方，如：P4、P1、P6点。<br>​    在填充开始前，有效边填充算法先对多边形所有的连接点进行分类，判断其在点集中的数量。<br>有效边填充算法采用如下原则对多边形的连接点进行处理：</p><h3 id="1-2-2-普通连接点的处理原则"><a href="#1-2-2-普通连接点的处理原则" class="headerlink" title="1.2.2.普通连接点的处理原则"></a><strong>1.2.2.普通连接点的处理原则</strong></h3><p>​    以P2为例，根据“下闭上开”原则，对于P3P2上的点P2不予填充，P2P1上的点P2需要填充，P2点只填充1次，顾在扫描线7的填充像素点集中P2点的个数记为1，即可以不处理。</p><h3 id="1-2-3-局部最低点的处理原则"><a href="#1-2-3-局部最低点的处理原则" class="headerlink" title="1.2.3.局部最低点的处理原则"></a><strong>1.2.3.局部最低点的处理原则</strong></h3><p>​    以P3为例，根据“下闭上开”原则，对于P3P2上的点P3需要填充，P3P4上的点P3也需要填充，P3填充2次，扫描线1的填充像素点集中，再添加一个P3点，使其中有两个P3点，在像素点集中将P3点的个数记为2，P5点进行同样的处理，这样当算法进行两两配对时，得到的像素区间为[3，3]、[5，5]，如此即可避免出现[3，8]的点集区间，解决此类情况的填充错误。</p><h2 id="1-2-4-局部最高点的处理原则"><a href="#1-2-4-局部最高点的处理原则" class="headerlink" title="1.2.4.局部最高点的处理原则"></a><strong>1.2.4.局部最高点的处理原则</strong></h2><p>​    以P1点为例，根据“下闭上开”原则，对于P2P1上的P1点不予填充，P0P1上的P1点也不予填充，P1填充0次，扫描线12的像素填充点集中P1点的个数记为0，即从点集中删除P1点，这样的处理符合多边形整体的“下闭上开”原则。<br>至此，多边形的有效边表填充算法的填充原理已经完成。<br>但是，我们在填充多边形之前还需要进行一项很重要的工作——根据多边形计算其有效边表，首先我们要了解什么是有效边。<br><strong>有效边</strong>：多边形与当前扫描线相交的边称为有效边，有效边的引入可以有效的避免扫描边与多边形的所有的边进行交点计算，提高算法的效率。<br><strong>有效边表</strong>：有效边按与扫描线交点x坐标递增顺序存放的链表。<br><strong>有效边表节点结构</strong>：<br><img src="https://img-blog.csdnimg.cn/20190618080124847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>示例：扫描线1的有效边表如下：<br><img src="https://img-blog.csdnimg.cn/20190618081306344.png" alt="在这里插入图片描述"><br><strong>桶表</strong>：有效边表按扫描线自增顺序存放的表，可以是链表，也可以是顺序表。<br><strong>桶表的结构</strong>：<br>​    如：多边形P0-P6的桶表为：<br><img src="https://img-blog.csdnimg.cn/20190618082918644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>​    有效边表可以有效的减少计算量，提升多边形的填充效率，如所有的扫描线中，计算机只需要计算扫描线1、扫描线7和扫描线8，且扫描线1只需和边P2P3、P3P4、P4P5、P5P6计算交点，而无需与所有边计算交点，有效边填充算法是目前最有效的多边形填充算法之一。<br>至此，多边形的有效边填充算法全部完成。</p><h1 id="2-边缘填充算法"><a href="#2-边缘填充算法" class="headerlink" title="2.边缘填充算法"></a>2.边缘填充算法</h1><h2 id="2-1-算法原理："><a href="#2-1-算法原理：" class="headerlink" title="2.1.算法原理："></a><strong>2.1.算法原理：</strong></h2><p>​    先计算多边形每条边与扫描线的交点，然后将交点右侧的所有像素颜色全部取补色。</p><h2 id="2-2-补色的定义："><a href="#2-2-补色的定义：" class="headerlink" title="2.2.补色的定义："></a><strong>2.2.补色的定义：</strong></h2><p>​    对于黑白图像，白色的补色为黑色，黑色补色为白色，对于彩色图像，前景色取补就是将前景色置为背景色，背景色取补就是将背景声置为前景色。<br>示例：<br><img src="https://img-blog.csdnimg.cn/20190618092226427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>​    边缘填充算法的填充效率受到右侧填充像素的数量影响，当多边形靠近屏幕左侧时，计算机将填充大量无用像素，大大降低的算法的性能，浪费了系统资源。<br>于是有人提出这样的改进：首先在进行多边形填充之前，先扫描一遍多边形，得出多边形的包围盒，并在适当的位置加入一条栅栏。<br>包围盒：包围多边形的最小矩形。</p><h2 id="2-3-加入包围盒和栅栏的边缘填充算法原理："><a href="#2-3-加入包围盒和栅栏的边缘填充算法原理：" class="headerlink" title="2.3.加入包围盒和栅栏的边缘填充算法原理："></a><strong>2.3.加入包围盒和栅栏的边缘填充算法原理：</strong></h2><p>​    每次填充前先判断当前边在栅栏的左侧还是右侧，若在左侧，则取补边以右，栅栏以左的像素；若在右侧，则取补边以右，栅栏以左的像素。<br>示例：<br><img src="https://img-blog.csdnimg.cn/20190621084324207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>​    可以看出，加入包围盒和栅栏的边缘填充算法极大的减少了需要填充像素的数量，对填充效率的提升是显著的。<br>​    观察边缘填充算法的两幅图，我们是可以察觉到的，边缘填充算法，对多边形的顶点与边的填充不甚理想，边缘填充算法没有给定具体填充时，直线上的点是否包含在填充范围内，笔者试过两种情况的对比——填充时包含直线上的点和填充时不包含直线上的点，得出的结果，多边形的顶点与边的填充都不理想，但是，填充时包含直线上的点的填充方法的最总结果，使多边形在整体上满足“左闭右开”，“下闭上开”原则，顾才用此方法作图。然而，边缘填充算法的填充原理是没有考虑边界的，即多边形的所有像素都填充为一个颜色，无论多边形内部还是多边形的边和顶点，在实际填充效果中，多边形所有像素都填充为一个颜色的填充方式，顶点和边对整体的效果不大，即可以忽略，所以边缘填充算法依旧是效率极高的填充算法之一。</p><h1 id="3-种子填充算法"><a href="#3-种子填充算法" class="headerlink" title="3.种子填充算法"></a>3.种子填充算法</h1><p>3.1.种子填充算法是区域填充算法中的一种，种子填充算法分为：四邻接点种子填充算法和八邻接点种子填充算法。<br>在此之前，我们需要了解一些概念：</p><h3 id="3-1-1-四邻接点："><a href="#3-1-1-四邻接点：" class="headerlink" title="3.1.1.四邻接点："></a><strong>3.1.1.四邻接点：</strong></h3><p>​    任易一个种子像素，其左右上下这四个像素成为这个种子像素的四邻接点。<br><img src="https://img-blog.csdnimg.cn/20190621092132813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-1-2-八邻接点："><a href="#3-1-2-八邻接点：" class="headerlink" title="3.1.2.八邻接点："></a><strong>3.1.2.八邻接点：</strong></h3><p>​    任易一个种子像素，其左右上下及左上、右下、右上、左上这八个像素成为这个种子像素的八邻接点。<br><img src="https://img-blog.csdnimg.cn/20190621092334685.png" alt="在这里插入图片描述"></p><h3 id="3-1-3-四连通域："><a href="#3-1-3-四连通域：" class="headerlink" title="3.1.3.四连通域："></a><strong>3.1.3.四连通域：</strong></h3><p>​    多边形中能被四邻接点遍历填充的区域。</p><h3 id="3-1-4-八连通域："><a href="#3-1-4-八连通域：" class="headerlink" title="3.1.4.八连通域："></a><strong>3.1.4.八连通域：</strong></h3><p>​    多边形中能被八邻接点遍历填充的区域。<br><img src="https://img-blog.csdnimg.cn/20190621094757411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-1-5-四连通边界："><a href="#3-1-5-四连通边界：" class="headerlink" title="3.1.5.四连通边界："></a><strong>3.1.5.四连通边界：</strong></h3><p><img src="https://img-blog.csdnimg.cn/20190621094925910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-1-6-八连通边界："><a href="#3-1-6-八连通边界：" class="headerlink" title="3.1.6.八连通边界："></a><strong>3.1.6.八连通边界：</strong></h3><p><img src="https://img-blog.csdnimg.cn/20190621095031628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="3-2-适用场景："><a href="#3-2-适用场景：" class="headerlink" title="3.2.适用场景："></a><strong>3.2.适用场景：</strong></h2><p>​    区域填充算法适用于多边形的边界与内部使用不同的填充色的场景。</p><h2 id="3-3-多边形边界的颜色："><a href="#3-3-多边形边界的颜色：" class="headerlink" title="3.3.多边形边界的颜色："></a><strong>3.3.多边形边界的颜色：</strong></h2><p>​    边界的颜色由绘制多边形时的画笔确定。</p><h2 id="3-4-多边形内部的颜色填充步骤"><a href="#3-4-多边形内部的颜色填充步骤" class="headerlink" title="3.4.多边形内部的颜色填充步骤"></a><strong>3.4.多边形内部的颜色填充步骤</strong></h2><p>​    3.4.1.在多边形内部任易选择一个像素作为种子像素。<br>​    3.4.2.将种子像素入栈。<br>​    3.4.3.如果栈不为空，则将栈顶元素出栈。<br>​    3.4.4.按填充色绘制出栈像素。<br>​    3.4.5.按四邻接点（左、上、右、下）（或八邻接点（左、左上、上、右上、右、右下、下、左下））顺序搜索与出栈像素相邻的4（或8）个像素，若该像素的颜色不是填充色并且也不是边界色，则把该像素入栈，否则丢弃该像素。<br>​    不难想象，当多边形的面积极大时，入栈的像素像素将是巨量，有的像素可能即是一个像素的邻接点又是另一个像素的邻接点，以致部分像素入栈多次，此情况下填充过程将大量占用栈存储空间，甚至过量占用空间，致使栈空间不足，导致其他程序无空间可用，如此既不能完成填充，又会造成空间溢出，甚至系统崩溃，所以种子填充算法的缺点极为严重。</p><h2 id="3-5-改进——扫描种子填充算法"><a href="#3-5-改进——扫描种子填充算法" class="headerlink" title="3.5.改进——扫描种子填充算法"></a><strong>3.5.改进——扫描种子填充算法</strong></h2><p>​    3.5.1.在多边形内部选择一个像素作为种子像素。<br>​    3.5.2.将种子像素入栈。<br>​    3.5.3.若栈不为空，则将栈顶元素出栈<br>​    3.5.4.沿出栈像素所在扫描线，对出栈像素左右像素依次填充，直至遇到边界像素为止。<br>​    3.5.5.记录该区间的范围，将最左端的像素记为Xl，将最右端的像素记为Xr。<br>​    3.5.6.检查与当前扫描线相邻的上下两条扫描线中在区间[Xl，Xr]里的有关像素是否全为边界像素或以填充像素，若存在非边界且未填充的像素，则把区间最右端像素取作种子像素入栈。<br>​    扫描种子填充像素每次只将区间最右端的像素入栈，极大的减少了入栈像素，不仅减少了栈空间的占用，还有效的提高了填充效率和填充速度。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>