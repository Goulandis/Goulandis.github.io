<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【AI】Stable Diffusion WebUI使用指南</title>
    <link href="/2023/06/03/%E3%80%90AI%E3%80%91Stable-Diffusion-WebUI%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2023/06/03/%E3%80%90AI%E3%80%91Stable-Diffusion-WebUI%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>最近AI绘画实现了真人照片级绘画水准，导致AI绘画大火，公司也让我研究研究，借此机会正好了解一下深度学习在AIGC(AI Generated Content)—-人工智能自动内容生成领域的应用。</p><p>AI绘画是AIGC领域的一个方向，AIGC有技术方向，其中比较火的有Txet-to-Image，Text-to-Video，Text-to-Speech技术，这三种技术都已经有了比较成熟的落地产品，但AIGC对算力的要求极高，一般的消费级显卡根本玩不起，而Stable-Diffusion模型的出现使Text-to-Image技术进入消费级显卡成为了现实，我自己测试过的最低配置是NVIDIA GeForce GTX 1660 Ti 6G + Intel(R) Core(TM) i7-9750H可以实现512x512图像分级的出图速度，即根据步数的不同3-5分钟出一张，测试的最高配置是NVIDIA GeForce RTX 3080 Ti 12G + Gen Intel(R) Core(TM) i7-12700K可以实现512x512秒级的出图速度，即根据步数的不同2-10秒出一张图。这已经是吊炸天级别的优化了。</p><p>我们讨论的就是基于Stable-Diffusion模型实现的NovelAI，一款开源软件。</p><p>我一直认为要想用好一个工具首先要知道它是怎么工作的，所以我们从AI绘画原理来入手，当然本人在接触NovelAI之前没有接触过AI，所以本文只是一些自己在学习的过程中的一些浅显的理解。</p><a id="more"></a><h1 id="一、AI绘画原理"><a href="#一、AI绘画原理" class="headerlink" title="一、AI绘画原理"></a>一、AI绘画原理</h1><p>这里原理学习参考了：</p><p><a href="https://www.bilibili.com/read/cv21564981?spm_id_from=333.999.0.0">【AI绘画】大魔导书：AI 是如何绘画的？Stable Diffusion 原理全解（一）</a>；</p><p><a href="https://zhuanlan.zhihu.com/p/477760524">多模态预训练CLIP</a>；</p><p><a href="https://github.com/CompVis/stable-diffusion">CompVis/稳定扩散：潜在的文本到图像扩散模型</a>；</p><h2 id="1-流程预览"><a href="#1-流程预览" class="headerlink" title="1.流程预览"></a>1.流程预览</h2><p>NovelAI绘画的流程主要分三个步骤，TextEncoder(Clip)，Diffusion(UNet+Scheduler)，ImageDecoder(VAE)，首先来看一下整体的流程：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-02-22_10-22-21.png"></p><h2 id="2-TextEncoder"><a href="#2-TextEncoder" class="headerlink" title="2.TextEncoder"></a>2.TextEncoder</h2><p>学过编程的都知道，机器是无法直接理解自然语言的，而我们输入的描述tag是自然语言，机器自然无法直接理解，所以首先需要经过一次文本编码，将自然语言编程成机器能够理解的字节码，Stable-Diffusion模型采用了Clip中文本编码器，Clip(Constastive Language-Image Pretraining)是OpenAI开源的一个深度学习模型，由图像编码器和文本编码器组成，基于图像和文本并行的多模态模型，通过图像与文本两个分支的特征向量的相似度计算来构建训练目标，形成图像-文本对，以达到Text-to-Image的技术实现。</p><p>Clip将文本转换成的字节码在WebUI上的表现形式就是一串数字，在我使用的版本的WebUI上有一个词元分析器(Tokenizer)就是使用Clip的文本编码器，可以将文本编码成字节码并以数字的形式显示在WebUI上，也可以将数字编码成文本。这串数字是给Clip中的Text Transformer使用的，Text Transfomer会根据这串数字来解析文本对应的图像的生成条件。</p><p>通俗来说，Clip干的活就是将文本解析成机器能理解的语言，然后机器根据自己的理解搜索文本在机器的记忆中对应的画面图像，然后向Diffusion提供生成图像的条件。</p><p>这个过程中Clip有加入77个嵌入向量，Clip会固定占用两个，所以Clip所能接收的最大词元个数就是75个，这里说的是词元的数量，而不是tag的数量，比如我们在WebUI中输入3个字母<code>dlg</code>，Clip从中解析出来了两个词元，标签也会显示词元最大容量和当前使用数量。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-02-23_11-36-58.png"></p><p>我们通过词元分析器也可以分析出<code>dlg</code>对应的两个词元：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-02-23_11-38-33.png"></p><h2 id="3-Diffusion"><a href="#3-Diffusion" class="headerlink" title="3.Diffusion"></a>3.Diffusion</h2><p>Stable Diffusion在Diffusion模块相对于以前的AI绘画的重大突破就是将扩散模型的核心计算从像素空间(即像素的集合)转换到了潜空间(图像的压缩数据)，当模型计算一张512x512的图时，在潜空间中做核心部分的计算用的是一张更小的经过特殊编码的图，如64x64的特殊编码过的图，这可以使计算任务最重的核心计算的计算量大大的减小，并且出图速度提升100倍。</p><p>Stable Diffusion是以去噪的形式来绘制一张图片，在WebUI中的随机种子(seed)就是用来产生一张随机噪点图的，噪点图包含了大量的无规则的像素信息，Diffusion出图的过程就是将随机噪点图中按照Clip给出的出图条件给噪点图去噪的过程。</p><p>对于去噪可以阅读这边博客：<a href="https://www.cnblogs.com/E-Dreamer-Blogs/p/10458846.html">图像处理——去噪 - E-Dreamer</a>。</p><p>去噪的过程先是通过U-Net模型根据图像的生成条件从数据集中提取符合要求像素特征，一张图像的像素特征有很多的维度，如：像素的空间分布，像素颜色特征等，不同类型，不同场景的图像像素的特征也不一样，所以像素的特征提取是一项很复杂的任务，Scheduler就是用来异步处理这些任务的调度器。</p><p>然后在特征提取完成之后，通过Sampler(采样器)对特征相关的图像数据进行采样，完成一次采样之后模型就会根据采样结果来调整像素在噪点图中分布，经过多次采样调整的重复，一张符合文本描述的图片变产生了。</p><p>不同步数对图像的影响：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-02-27_14-45-13.png"></p><p>在WebUI中的采样方法(Sampler)调整的采样的算法，采样步数(Sampling steps)调整的就是采用重复的次数，提示词相关性(CFG Scale)调整的就采样的方向，数字越大就会越严格的按照提示词采样，越小则采样的随机性越强。</p><p>不同CFG Scale对图像的影响：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-02-27_14-55-18.png"></p><p>对于U-Net参考了：<a href="https://zhuanlan.zhihu.com/p/47125912">用U-Net做Auto-Encoder图像重建</a>。</p><h2 id="4-ImageDecoder"><a href="#4-ImageDecoder" class="headerlink" title="4.ImageDecoder"></a>4.ImageDecoder</h2><p>经过Diffusion的步骤，一张符合文本描述的图片实际上已经生成了，但是这张图片是在潜空间中进行计算得出的一张被特殊编码过的图片，是没办法直接进行观看的，所以需要ImageDecoder来进行图片解码，解码完成之后就得到了一张正常的图片了，然后将图片输出出来。</p><h1 id="二、在本地部署-Win10"><a href="#二、在本地部署-Win10" class="headerlink" title="二、在本地部署(Win10)"></a>二、在本地部署(Win10)</h1><p>首先AI绘画有很多的应用，比较有名的如：DALL-E 2、Midjourney、Stable Diffusion、Disco Diffusion、NovelAI、盗梦师、文心·一格，有的使用的自己的技术，但大部分都是使用的Stable Diffusion的开源技术，之前我还把NovelAI和Stable Diffusionr当成是一个东西了，惭愧。</p><p>我们能在自己的电脑上部署AI绘图首先要感谢Stable-Diffusion的开源。</p><p>Stable Diffusion的开源库：<a href="https://github.com/CompVis/stable-diffusion">CompVis/stable-diffusion: A latent text-to-image diffusion model (github.com)</a>。</p><h2 id="1-环境部署"><a href="#1-环境部署" class="headerlink" title="1.环境部署"></a>1.环境部署</h2><p>Stable Diffusion只是提供一个模型，提供基础的文本分析、特征提取、图片生成这些核心功能，但自身是没有可视化UI的，用起来就是各种文件加命令行。</p><p>所以很多牛人就为Stable Diffusion制作了UI界面，其中功能最强的，也是最火的就是大神<a href="https://github.com/AUTOMATIC1111">AUTOMATIC1111</a>制作的WebUI了。</p><p>WebUI原工程：<a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui">AUTOMATIC1111/stable-diffusion-webui: Stable Diffusion web UI (github.com)</a>。</p><p>WebUI已经整合了Stable Diffusion模型，直接克隆下来配置好运行环境就可以使用了。</p><p>运行环境实际上就两东西，一个克隆代码仓库的Git，一个Python3.10以上的Python环境。</p><p>Git直接去<a href="https://git-scm.com/">Git官网下</a>一个就好了，安装好之后，我们在任意文件夹内右键是可以看到<code>Git bash here</code>和<code>Git GUI here</code>两个右键菜单的。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-02-27_15-42-08.png"></p><p>我们选择Git Bash here，键入：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/AUTOMATIC1111/</span>stable-diffusion-webui.git<br></code></pre></td></tr></table></figure><p>就可以将源码下载到当前文件夹内了，下载速度很慢，毕竟WebUI本体有十几G，会科学上网的上梯子或者直接找一个国内镜像肯能更快一点。</p><p>这里推荐一个国内的镜像：<a href="https://jihulab.com/hunter0725/stable-diffusion-webui">Hunter0725 / Stable Diffusion Webui · 极狐GitLab (jihulab.com)</a>。</p><p>然后去<a href="https://www.python.org/">Python官网</a>下载3.10以上的版本，WebUI作者推荐的是3.10.6，安装的时候记得勾选<code>Add Python to PATH</code>，否则WebUI会识别不到Python环境。</p><p>检测是否安装成功，可以在cmd中输入python -V，如果打印了Python的版本号则安装成功了。</p><p>然后我们双击WebUI根目录下的<code>webui-user.bat</code>就可以启动Stable Diffusion服务了。</p><p>如果此时提示还找不到Python环境或者电脑本地有Python环境，我们可以打开webui-user.bat文件，在<code>Set PYTHON=</code>之后填上自己安装的Python路径。</p><p>如果我们要跟换Python版本，或者电脑里装了多个Python版本，我们也可以修改webui-user.bat文件来指定使用的版本。</p><p>如果之前用其他的版本的Python跑过WebUI，现在想换另一个Python版本，操作和上面一样，并且需要将新版本的python.exe拷贝一份到<code>venv/Scripts</code>文件夹替换旧的exe。</p><p>这里我看一下webui-user.bat文件没一行的作用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#设置python路径</span><br><span class="hljs-built_in">set</span> PYTHON=C:\Users\UserName\AppData\Local\Programs\Python\Python310\python.exe<br><span class="hljs-comment">#设置git的路径</span><br><span class="hljs-built_in">set</span> GIT=E:\git\bin\git.exe<br><span class="hljs-comment">#设置venv文件夹路径</span><br><span class="hljs-built_in">set</span> VENV_DIR=E:\stable-diffusion-webui\venv<br><span class="hljs-comment">#设置启动参数</span><br><span class="hljs-built_in">set</span> COMMANDLINE_ARGS=--deepdanbooru --xformers <br></code></pre></td></tr></table></figure><p>在webui-user.bat第一次运行的时候，如果<code>set PYTHON</code>没有指定python路径会默认使用系统变量中的python来构建WebUI自己的虚拟环境，构建完之后，下次启动WebUI就会使用自己虚拟环境中的Python环境，位置在<code>venv\Scripts</code>。</p><p>下载完之后就可以双击webui-user.bat启动webui服务了，然后通过浏览器进入服务器地址就可以进入WebUI了。</p><p>但大多数时候很多库直接通过脚本基本下载不下来，这时候就只能手动下载下来了，具体可以参见第二小节。</p><p>由于墙的原因各种库总会出现链接不上库地址的情况，就算手动下载还要考虑webui使用的版本，所以建议还是使用整合包会方便很多。</p><p>我们可以在<code>set COMMANDLINE_ARGS</code>后添加<code>--autolanch</code>启用自动启动服务，在webui服务启动后会自动使用默认浏览器启动UI界面。</p><h2 id="2-部署遇到的问题"><a href="#2-部署遇到的问题" class="headerlink" title="2.部署遇到的问题"></a>2.部署遇到的问题</h2><p>在webui-user.bat下载依赖时经常会出现连不上git，导致下载失败，然后报Couldn’t install xxxx，没别的办法，我自己使用梯子也会出现连不上的情况，然后根据<a href="https://www.bilibili.com/read/cv19991459/">本地部署stable-diffusion-webui出现Couldn’t install gfpgan错误的解决方法 </a>这个教程更改luanch.py中的源也一样。解决方法有两个，其一找到对应版本的依赖库，手动下载安装，其二多试几次，总有一次能成功，我就是跑了好几次成功了一次，就ok了。</p><p>当然想要更方便，解压即用的，推荐<a href="https://www.bilibili.com/video/BV17d4y1C73R/?spm_id_from=333.999.0.0">秋叶大佬的整合</a>，秋叶大佬甚至提供了启动器，这是一个功能强大的管理器，其中为我们整合了很多优秀的模型、Lora、插件等，并且集成了UI汉化，甚至可以选择Stable Diffusion的版本等等，总之功能很强大，当然整合包和启动器都是Windows版本的，在其他的环境下使用还得自己来。</p><h3 id="GFPGAN安装不上"><a href="#GFPGAN安装不上" class="headerlink" title="GFPGAN安装不上"></a>GFPGAN安装不上</h3><p>gfpgan是腾讯ARC开源的一个库，也不知道为什么开不开梯子，WebUI都无法自行安装这个库，解决办法就是手动安装。</p><p>库地址：<a href="https://github.com/TencentARC/GFPGAN">TencentARC/GFPGAN: GFPGAN aims at developing Practical Algorithms for Real-world Face Restoration. (github.com)</a>。</p><p>使用git将库clone到<code>stable-diffusion-webui\venv\Scripts</code>目录下，然后进入GFPGAN目录，依次次执行</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">E:<span class="hljs-symbol">\s</span>table-diffusion-webui<span class="hljs-symbol">\v</span>env<span class="hljs-symbol">\S</span>cripts<span class="hljs-symbol">\p</span>ython.exe -m pip install basicsr facexlib<br>E:<span class="hljs-symbol">\s</span>table-diffusion-webui<span class="hljs-symbol">\v</span>env<span class="hljs-symbol">\S</span>cripts<span class="hljs-symbol">\p</span>ython.exe -m pip install -r requirements.txt<br></code></pre></td></tr></table></figure><p>安装GFPGAN的依赖库，安装完之后执行</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">E:<span class="hljs-symbol">\s</span>table-diffusion-webui<span class="hljs-symbol">\v</span>env<span class="hljs-symbol">\S</span>cripts<span class="hljs-symbol">\p</span>ython.exe setup.py develop<br></code></pre></td></tr></table></figure><p>安装GFPGAN，然后再启动webui时就会检测到已安装，从而跳过自动安装。</p><h3 id="clip安装不上"><a href="#clip安装不上" class="headerlink" title="clip安装不上"></a>clip安装不上</h3><p>原因也是自动连接时连接不上clip库，解决方法同样是手动安装，将open_clip库clone到<code>stable-diffusion-webui\venv\Scripts</code>目录下，然后进入<a href="https://github.com/mlfoundations/open_clip">open_clip</a>目录，然后执行</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">E:<span class="hljs-symbol">\s</span>table-diffusion-webui<span class="hljs-symbol">\v</span>env<span class="hljs-symbol">\S</span>cripts<span class="hljs-symbol">\p</span>ython.exe setup.py build install<br></code></pre></td></tr></table></figure><p>再启动webui，如果还是提示要安装clip，说明clip没有安装上，上面的命令会构建并安装clip，但不知道为什么我没安装上，于是只能之际再手动安装一次了，可以执行</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">E:<span class="hljs-symbol">\s</span>table-diffusion-webui<span class="hljs-symbol">\v</span>env<span class="hljs-symbol">\S</span>cripts<span class="hljs-symbol">\p</span>ip.exe install clip<br></code></pre></td></tr></table></figure><p>然后再启动webui时就会检测到已安装，从而跳过自动安装。</p><h3 id="缺少xxx模块"><a href="#缺少xxx模块" class="headerlink" title="缺少xxx模块"></a>缺少xxx模块</h3><p>大多数情况都是WebUI在Installing requirements for Web UI时由于网络原因没装上，比较便捷的解决办法就是多跑几次，总有一次能安装上，或者也手动安装。</p><h3 id="repositories中所用到的库下载失败"><a href="#repositories中所用到的库下载失败" class="headerlink" title="repositories中所用到的库下载失败"></a>repositories中所用到的库下载失败</h3><p>所有的库如果都下载不下载，就只能全部手动下载了，一共六个库</p><p><strong><a href="https://github.com/Stability-AI/stablediffusion/">stablediffusion</a></strong></p><p>这个是AI绘图的核心库，Stability-AI公司开源的stablediffusion，直接通过git克隆到<code>repositories</code>目录，克隆下来的库存在stablediffusion目录下，由于还有另一个库叫stable-diffusion，所有AUTOMATIC1111把库命名成了<code>stable-diffusion-stability-ai</code>，所以我们要把库的目录名改成stable-diffusion-stability-ai。</p><p><strong><a href="https://github.com/CompVis/taming-transformers">taming-transfomers</a></strong></p><p><strong><a href="https://github.com/CompVis/stable-diffusion">stable-diffusion</a></strong></p><p><strong><a href="https://github.com/duaneking/k-diffusion-sd">k-diffusion-sd</a></strong></p><p>k-diffusion-sd库AUTOMATIC1111命名为了k-diffusion，同样也要把库目录名改过来。</p><p><strong><a href="https://github.com/sczhou/CodeFormer">CodeFormer</a></strong></p><p><strong><a href="https://github.com/salesforce/BLIP">BLIP</a></strong></p><h3 id="启动时报ImportError：Bad-git-executeable"><a href="#启动时报ImportError：Bad-git-executeable" class="headerlink" title="启动时报ImportError：Bad git executeable"></a>启动时报ImportError：Bad git executeable</h3><p>打开<code>venv\Lib\site-packages\git\cmd.py</code>文件在<code>from git.compat import</code>前一行加入一行<code>os.environ[&#39;GIT_PYTHON_REFRESH&#39;] = &#39;quiet&#39;</code>。</p><h3 id="库的hash值不确定"><a href="#库的hash值不确定" class="headerlink" title="库的hash值不确定"></a>库的hash值不确定</h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-05-19_14-53-52.png"></p><p>这种情况我只在迁移软件的过程中遇到，解决办法就是使用git，按照提示的命令把所有不确定hash值得库都执行一边就可以了，需要注意的是需要在电脑中安装git执行命令才生效，我没安装git的直接使用秋叶整合包里的git文件执行指令没效果。</p><h2 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h2><p>在开了梯子的情况下，UI界面有概率出现与服务器通信中断的问题。</p><h1 id="三、WebUI文件夹功能"><a href="#三、WebUI文件夹功能" class="headerlink" title="三、WebUI文件夹功能"></a>三、WebUI文件夹功能</h1><p>这里只说明一些我们会使用的文件夹的作用，不使用的就略过了。</p><ul><li><p>embeddings：存放美术风格文件的目录，美术风格文件一般以<code>.pt</code>结尾，大小在几十K左右；</p></li><li><p>extensions：存放扩展插件的目录，我们下载的WebUI的插件就放在这个目录里，WebUI启动时会自动读取插件，插件目录都是git库，可以直接通过git更新；</p></li><li><p>extensions-builtin：存放WebUI内置的扩展；</p></li><li><p>models/hypernetworks：存放风格化文件的目录，风格化文件是配合Prompt使用的，以使AI会出对应风格的图片，风格化文件也以<code>.pt</code>结尾，大小在几百MB左右；</p></li><li><p>models/Lora：存放Lora的文件的目录，Lora文件是用来调整模型的，可以重映射模型文件的Prompt映射，使AI在相应的提示词下按照Lora的样式绘制，Lora文件一般以<code>.safetensors</code>结尾，大小在几百MB左右；</p></li><li><p>models/Stable-diffusion：存放模型的文件的目录，AI绘画时的采样基本从这个文件里采，影响图片的整体样式与画风，一般以<code>.ckpt</code>或<code>.safetensors</code>结尾，大小在几个G左右；</p></li><li><p>models/VAE：存放VAE文件的目录，VAE文件会影响图片整体的色调，如在刚开始玩WebUI时画出的图都比较灰，就是因为WebUI默认没有为我们设置VAE导致的，VAE文件一般以<code>.ckpt</code>或<code>.vae.pt</code>结尾，大小在几百MB或几个G不等；</p></li><li><p>outputs/extras-images：AI放大的原图的默认保存路径；</p></li><li><p>outputs/img2img-grids：批量图生图时的缩略图原图的默认保存路径；</p></li><li><p>outputs/img2img-images：图生图的原图的默认保存路径；</p></li><li><p>outputs/txt2img-grids：批量文生图时的缩略图原图的默认保存路径；</p></li><li><p>outputs/txt2img-images：文生图的原图的默认保存路径；</p><p>这些路径我们是可以在WebUI的设置界面修改成自定义路径的。</p></li><li><p>scripts：存放第三方脚本的目录；</p></li><li><p>venv：这个文件夹是WebUI首次运行时配置运行环境自己创建的，出现运行环境的问题时，可以删掉它让WebUI重新生成。</p></li></ul><h1 id="四、WebUI界面说明"><a href="#四、WebUI界面说明" class="headerlink" title="四、WebUI界面说明"></a>四、WebUI界面说明</h1><p>这里以无第三方插件的原版的WebUI界面为例，使用了整合包或安装了第三方插件的界面会有所不同。</p><p>本节参考了：</p><p><a href="https://www.tjsky.net/tutorial/488">AI绘画指南 stable diffusion webui （SD webui）如何设置与使用 — 秋风于渭水</a>；</p><p><a href="https://www.reddit.com/r/StableDiffusion/comments/yz2tbo/noobs_guide_to_using_automatic1111s_webui/">使用Automatic1111的WebUI的菜鸟指南：稳定扩散 </a>；</p><p><a href="https://zhuanlan.zhihu.com/p/574063064">NovelAI模型各参数解析以及对应关系</a></p><h2 id="1-文生图-txt2img"><a href="#1-文生图-txt2img" class="headerlink" title="1.文生图(txt2img)"></a>1.文生图(txt2img)</h2><ul><li><p><strong>Prompt</strong>：正向提示词；</p></li><li><p><strong>Negative prompt</strong>：反向提示词；</p></li><li><p>在Generate(生成)下有一排按钮：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-02-28_18-13-36.png"></p><p>箭头(第一个按钮)：从提示词中提取通用的提示词，一般用于使用别人的提示词时过滤掉一些别人个性化的提示词；</p><p>垃圾篓(第二个按钮)：快速清除提示词；</p><p>图画(第三个按钮)：打开Textual Inversion、Hypernetworks、Checkpoints和Lora的管理界面，点击文件可以往提示词中加入对应的风格化应用；</p><p>文件(第四个按钮)：这个按钮的功能是配合第五个按钮一起使用的，可以选择下方Styles下拉列表中已经保存起来的提示词模板应用到提示词中；</p><p>存储(第五个按钮)：存储当前Prompt和Nagetive prompt的提示词作为提示词模板，存储好的提示词模板命好名后可以在Styles下来列表中看到，提示词模板存储在WebUI根目录的<code>styles.csv</code>文件中，目前WebUI没有提供在UI中删除提示词模板的功能，想要删除不需要的提示词模板，我们需要通过修改<code>styles.csv</code>文件。</p></li><li><p>**Sampling method(采样方法)**：生成图片时的采样算法；</p></li><li><p>**Sampling steps(采样步数)**：生成图片时的采样重复次数；</p></li><li><p>**Restore faces(面部修复)**：主要用于生成真人图片时对人脸进行算法修复，让人脸更接近真实的人脸，当画二次元图人脸崩坏时也可以使用这个选项来修复；</p><p>在Settings(设置)/Face restoration(人脸修复)中可以选择人脸修复的算法，目前WebUI只整合了CodeFormer和GFPGAN两种算法，默认是没有启用任何算法的，需要我们自己手动去启用，Code Former weight parameter参数可以调整算法的权重，注意：0是最大权重效果，1是最小权重效果，和我们常见权重是反过来的。</p></li><li><p>Tiling：是一种优化技术，对于性能比较差的机器可以勾选上来降低显存的占用，提高出图速度，对于性能足够的机器就不用勾选了，勾选了反而会起到反作用；</p></li><li><p>**Hires.fix(高清分辨率修复)**：用于提高分辨率的优化，最大可以将分辨率提升4倍，512x512可以直接提升到4K；</p><p>由于Hires.fix是在AI画完一张图之后再进行优化的，要对细节进行补充，所以会对图片进行一定维度的重绘，所以对原有的图会有一些改动，不过这对文生图来说没有任何影响。Hires.fix也有一些自己参数：</p><p>Upscaler(放大算法)：优化采用的放大算法，其中提供了很多内置的算法，同时我们也可以在Settings(设置)/Upscaling(放大)中添加没有预制出来的ESRGAN算法，里面有一个算法R-ESRGAN 4x+ Anime6B据说对二次元图的放大效果比较好；</p><p>Hires setps(高清修复的步数)：和采样步数的效果一样；</p><p>Denoising strength(重绘幅度)：重绘幅度就是Hires.fix在重绘细节的时候，AI的自由发挥空间，值越大AI就越放飞自我，值越小，AI就越按照原图重绘。</p><p>Resize width to(将宽度调整至)/Resize height to(将高度调整至)：直接将图片放大至指定分辨率，和放大倍率是冲突的。</p></li><li><p>**Width(图片宽度)/Height(图片高度)**：设定图片的分辨率；</p></li><li><p>**Batch count(生成批次)**：批处理次数，设定同时处理多少批图片生成；</p></li><li><p>**Batch size(每批数量)**：每次批处理同时生成的图片数量，最大值为8，需要根据自己电脑的显存大小来调节，如我的12G显存就没办法同时出8张1024x1024分辨率的图，只能同时出4张；</p></li><li><p>**Seed(随机种子)**：用来设置用于AI去噪的噪点图，一个随机数唯一对应一张噪点图，默认值是-1，表示使用随机数，也可以设置一个随机数，来规定AI画同样的图。</p><p>Seed也有两个自己的参数，勾选Seed后面的Extra复选框可以编辑。</p><p>Variation seed(差异随机种子)：组要用于在确定好一个自己比较想要的图片结构之后，设置好随机种子，然后通过设置差异随机种子，让AI在这张图的基础上每次画出有一点点区别的图；</p><p>Variation streenght(差异强度)：控制AI在一张图的基础上出图的差异变化的强弱。</p><p>Resize seed from width/Resize seed from hright：控制AI绘图时在当前分辨率往指定分辨率的图靠近，实际使用过程感觉没什么卵用。</p><p><font color="red">差异随机种子的另一种用法是，在出了一张构图很好的图时，通过图生图锁定随机种子和差异随机种子，然后调整差异强度，使差异随机种子出现一些细微的变化，来细微的调整出图效果，可以随机生成构图类似而又不同的图片。</font></p></li><li><p>**CFG Scale(提示词相关性)**：控制AI是否严格按照提示词来绘图，越小AI绘画越随意，越大AI就越严格的按照提示词出图；</p></li><li><p>**Script(脚本)**：用来启动第三方脚本，WebUI内置了三个脚本。</p><p><strong>X/Y/Z plot</strong>：可以用来批量处理同一提示词在不同维度之间的效果，如不同的采样方法，不同的采样步数或者不同的提示词相关性等，用来测试不同维度的参数变化对出图的影响，以寻找最佳的图片质量的参数配置。</p><p>如不同采样算法在不同采样步数的情况下对图片的影响：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/xyz_grid-0016-1371342886-(masterpiece_1.3)%2C%20(the%20best%20quality_1.2)%2C%20(super%20fine%20illustrations_1.2)%2C%20(Masterpiece)%2C%20high%20quality%2C%20high%20detail%2Cdappled%20sunl.png"></p><p>具体的可以参考这篇博文：</p><p><a href="https://zhuanlan.zhihu.com/p/608443788">Stable Diffusion WebUI 小指南 - X/Y/Z Plot</a>。</p><p>**Prompt matrix(提词矩阵)**：用来分割不同关键词对图片的影响，操作方法就是通过<code>|</code>来分割关键词，如：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(masterpiece:1.3)</span>, <span class="hljs-comment">(the best quality:1.2)</span>, <span class="hljs-comment">(super fine illustrations:1.2)</span>, <span class="hljs-comment">(Masterpiece)</span>|, <span class="hljs-number">1</span>girl,black hair|, Sailor suit,Pleated shirt|,huge breasts,white pa<span class="hljs-symbol">ntyhose</span><br></code></pre></td></tr></table></figure><p>Prompt matrix就会按照分割的关键次一次组合来绘制不同组合的出图效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/prompt_matrix-0006-1371342886-(masterpiece_1.3)%2C%20(the%20best%20quality_1.2)%2C%20(super%20fine%20illustrations_1.2)%2C%20(Masterpiece)_%2C%201girl%2Cblack%20hair_%2C%20Sailor%20suit%2CPleate.png"></p><p>这里参考了这篇博客：</p><p><a href="https://new.qq.com/rain/a/20221022A05FUI00">AI绘画教程（3）基础篇-SDWEBUI的基础功能，你都会用了吗？</a>。</p><p><strong>Prompts from file or textbox</strong>：用于批量出图的工具，我们可以在List of prompt inputs(提示词输入列表)中输入提示词，也可以从文本中输入提示词，脚本会自动将文本的提示词填入提示词输入列表，然后勾选Iterate seed every line(每行使用一个随机种子)或Use same random seed for all lines(每行使用相同的随机种子)，来达成每一行作为一份提示词输入来生成对应的图片。</p></li></ul><h2 id="2-图生图-img2img"><a href="#2-图生图-img2img" class="headerlink" title="2.图生图(img2img)"></a>2.图生图(img2img)</h2><p>图生图界面上半部分、下半部分和文生图基本一样，只有中间部分不一样，上半部分多了两个按钮。</p><ul><li><p>**Interrogate CLIP(CLIP反推提示词)**：使用CLIP模型从图片中反推图片用到的正向提示词；</p></li><li><p>**Interrogate DeepBooru(DeepBooru反推提示词)**：使用DeepBooru模型从图片中反推图片用到的正向提示词；</p></li><li><p>**img2imge(图生图)**：全局图生图，AI会根据重绘幅度和原图进行创作；</p></li><li><p>**Sketch(绘图)**：就是最简单的局部重绘功能，可以通过画面图绘区域，让AI只重绘所图的区域；</p></li><li><p>**Inpaint(局部重绘)**：功能稍微强大一点的局部重绘，可以对蒙版进行操作，蒙版就是我们用画笔图黑的部分；</p></li><li><p>**Inpaint sketch(手涂蒙版)**：手绘蒙版又是一个更强大的局部重绘，可以拾取画面中的像素颜色，以让AI识别要重绘的像素分布，能更精准的进行局部重绘；</p></li><li><p>**Inpaint upload(上传蒙版重绘)**：这个功能主要是解决WebUI在绘制蒙版是的不精确，对想要精确选区的重绘区域使用WebUI的画笔很难精确的图绘，上传蒙版重绘则是通过上传一张与原图大小一致的黑白的蒙版图片来匹配原图，从而对原图进行重绘，这里要注意的是这里的颜色和Sketch、Inpaint的颜色刚好相反，Sketch是黑色区域为蒙版区域，这里这是白色区域为蒙版区域，如：我这里想重绘一下女孩身后的栏杆，我们就可以用PS将栏杆精确的选区出来，然后制作蒙版图，传到WebUI上来进行重绘：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-02-28_22-08-17.png"></p></li><li><p>**Batch(批量重绘)**：指定一个输入文件夹和一个输出文件夹，就可以进行图片的批量重绘，如果指定了蒙版文件夹，还可以批量的使用蒙版图精确的进行局部重绘。</p><p>局部重绘还有一些自有的参数：</p><p>Mask blur(蒙版模糊)：值越大重绘出来的区域越清晰，值越小重绘出来的区域越模糊；</p><p>Mask mode(蒙版模式)：可以选择是重绘蒙版区域还是非蒙版区域；</p><p>Masked content(蒙版蒙住的内容)：可以选择蒙版要蒙什么东西，可以是原图也可以是噪点等；</p><p>Inpaint area(重绘区域)：可以选择要重绘的区域，感觉和蒙版模式的功能是一样的；</p><p>Only masked padding,pixels(仅蒙版边缘的预留像素)：设定蒙版边缘预留多少像素不进行重绘，实际使用中没感觉出有什么作用。</p></li><li><p>**Dinoising strength(重绘幅度)**：控制整个图生图过程中AI重绘过程的自由发挥程度，值越大AI重绘越随意，值越小AI重绘越接近原图。</p></li><li><p>**Script(脚本)**：图生图除了拥有文生图的脚本外，还拥有一些专用的脚本。</p><p>**Lookback(回送)**：可以将这一次的生成图作为图生图的输入进行下一次绘制，这个功能对于线稿上色简直是神助攻。</p><p>启用后会多出几个设置选项：</p><p>Loops：控制回送的次数；</p><p>Final denoising strength：最终重绘强度，是叠加在图生图的重绘强度之上的，第一次回送使用的实际重绘强度=[重绘强度]×[最终重绘强度]，之后每一次回送时使用的[实际重绘强度]=[上一次实际重绘强度]×[最终重绘强度]；</p><p>Denoising strength curve：可以选择脚本重绘强度的变化曲线，脚本为我们内置了三个曲线；</p><p>Append interrogated prompt at each iteration：为每一次回送自动反推图片提示词并应用；</p><p>**Outpainting mk2(向外绘制第二版)**：可以将图片进行一定像素方位内的扩展，实测，发现脚本与<a href="https://github.com/journey-ad/sd-webui-bilingual-localization">双语对照插件</a>存在冲突，启用双语对照插件后，扩展绘制的效果很差，关闭之后，效果就会变得很好；</p><p>**SD upscale(SD 放大)**：这就是一个依赖于图生图的分块放大算法，可以使用更少的显存达到4K图的放大效果，实测放大到最大的4K，只需要5G+显存，放大效果回收重绘强度影响和提示词影响；</p><p>**controlnet m2m(ConteolNet视频转绘)**：视频生成的脚本，转的视频效果比较渣，就不过多累述了，可以参见这个视频：<a href="https://www.bilibili.com/video/BV1YL411R7JH/?spm_id_from=333.337.search-card.all.click&vd_source=e979466844c4915a4200c496efb35cfb">【AI绘画进阶教程】制作跳舞小姐姐 m2m和mov2mov哪家强？</a>。</p></li></ul><h2 id="3-附加功能-Extras"><a href="#3-附加功能-Extras" class="headerlink" title="3.附加功能(Extras)"></a>3.附加功能(Extras)</h2><p>附加功能界面主要是用来做图片放大用的。</p><ul><li><p>**Scale by(等比放大)**：按原图长宽各乘以相同比例来放大图片；</p></li><li><p>**Scale to(按分辨率放大)**：可以将原图放大成任何比例，如正方形图可以被放大成长方形图，勾选Crop to fit，AI会自动为我们裁剪，不勾选则不会按照指定的分辨率放大，会默认用回等比放大；</p></li><li><p>**Upscaler 1(升频器1)/Upscaler 2(升频器2)**：AI做图片放大时会处理两次，两次可以分别采用不同的放大算法，不同的算法放大效果不一样，所以WebUI做两次放大，以便组合不同放大效果达到更好的放大效果。</p></li><li><p>**Upscaler 2 Visibility(升频器2可见度)**：用于设置第二次放大时使用的算法在放大过程中的权重；</p></li><li><p>**GFPGAN visibility(GFPGAN模型可见度)/CodeFormer visibility(CodeFormer模型可见度)/CodeFormer weight(CodeFormer权重)**：这三个选项都是用来调整图片放大时对图片的修复作用的，GFPGAN和CodeFormer模型在前面文生图的Hire.fix中也有用到，主要作用就是用来做图片修复的，调整可见度就可以调整两个模型混合使用的程度，CodeFormer还可以更精细的调整权重，0表示最大权重，1表示最小权重。在我自己的测试中，两个模型对二次原图片的修复效果基本一致，在相对拟真的图片中存在差异，我们可以看一下两个模型的修复效果：</p><p>GFPGAN visibility=1，CodeFormer visibility=0，CodeFormer weight=0：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-03-01_10-25-02.png"></p><p>可以看到GFPGAN对纹理的修复还是可以的，但是对皮肤的纹理修复有点过度磨皮的刚觉了。</p><p>GFPGAN visibility=0，CodeFormer visibility=1，CodeFormer weight=0：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-03-01_10-26-34.png"></p><p>CodeFormer则是对皮肤纹理的修复更真实自然，但对其他的物体的纹理修复就不如GFPGAN，并且对五官有过度修复。</p><p>GFPGAN visibility=0.5，CodeFormer visibility=0.5，CodeFormer weight=0.5：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-03-01_10-27-06.png"></p><p>将二者结合后的效果，要好很多。</p></li><li><p>**Batch Process(批量处理)/Batch from Directory(从目录进行批量处理)**：两个都是对图片放大做批量处理的。</p><p>本节参考了帖子：</p><p><a href="https://www.reddit.com/r/StableDiffusion/comments/xjvh05/gfpgan_and_codeformer_seperately_and_together/">GFPGAN and CodeFormer - seperately and together. : StableDiffusion</a>。</p></li></ul><h2 id="4-PNG图片信息-PNG-Info"><a href="#4-PNG图片信息-PNG-Info" class="headerlink" title="4.PNG图片信息(PNG Info)"></a>4.PNG图片信息(PNG Info)</h2><p>PNG图片信息就是一个更强大的CLIP反推提示词，它可以将没有经过处理的AI生成的原图反推出生成这张图所有的所有参数，包括正反向提示词、采样步数、采样方法、提示词相关性、随机种子、尺寸、所用模型的hash值、Clip跳过的次数还有一个不知道有什么用的ENSD。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-03-01_16-00-16.png"></p><h2 id="5-模型合并-Checkpoint-Merger"><a href="#5-模型合并-Checkpoint-Merger" class="headerlink" title="5.模型合并(Checkpoint Merger)"></a>5.模型合并(Checkpoint Merger)</h2><p>模型合并界面主要使用来合并模型的，具体参数后面在模型合并的章节一起讲。</p><h2 id="6-训练-Train"><a href="#6-训练-Train" class="headerlink" title="6.训练(Train)"></a>6.训练(Train)</h2><p>训练界面是专门用来做模型训练用的，具体参数也在后面模型训练的章节一起讲了。</p><h2 id="7-设置-Settings"><a href="#7-设置-Settings" class="headerlink" title="7.设置(Settings)"></a>7.设置(Settings)</h2><p>设置界面的参数就太多了，建议弄一个汉化，或者用整合了汉化的整合包，大部分参数在汉化之后看一下名字就知道是作用了。</p><p>这里推荐安装这个汉化库：<a href="https://github.com/dtlnor/stable-diffusion-webui-localization-zh_CN">dtlnor/stable-diffusion-webui-localization-zh_CN: Simplified Chinese translation extension for AUTOMATIC1111’s stable diffusion webui </a>。</p><p>然后可以配合这个双译插件一起使用：<a href="https://github.com/journey-ad/sd-webui-bilingual-localization/blob/main/README_ZH.md">sd-webui-bilingual-localization/README_ZH.md at main · journey-ad/sd-webui-bilingual-localization</a>。</p><p>两个插件都安装之后的界面是这样的：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-03-01_16-35-44.png"></p><h2 id="8-扩展-Extensions"><a href="#8-扩展-Extensions" class="headerlink" title="8.扩展(Extensions)"></a>8.扩展(Extensions)</h2><p>用来管理第三方插件的界面，所有安装的扩展，包括WebUI内置的都会在Installed(已安装)栏中显示，并且可以直接管理插件的更新。更新插件的时候需要确保自己的网络能连接得上github库，其实也没什么卵用，就算梯子没毛病，也经常连不上git库。</p><p>Available(可用)：这是直接连接<a href="https://raw.githubusercontent.com/wiki/AUTOMATIC1111/stable-diffusion-webui/Extensions-index.md%E6%89%A9%E5%B1%95%E5%88%97%E8%A1%A8%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E7%82%B9%E5%87%BB(%E5%8A%A0%E8%BD%BD%E8%87%AA)%E6%9D%A5%E5%88%B7%E6%96%B0%E6%89%A9%E5%B1%95%E5%88%97%E8%A1%A8%EF%BC%8C%E7%84%B6%E5%90%8E%E4%BB%8E%E8%BF%99%E9%87%8C%E6%9D%A5%E4%B8%8B%E8%BD%BD%E5%88%97%E8%A1%A8%E9%87%8C%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8F%92%E4%BB%B6%EF%BC%8C%E5%AE%9E%E9%99%85%E6%B5%8B%E8%AF%95%E5%9F%BA%E6%9C%AC%E4%B8%8A%E8%A3%85%E4%B8%8D%E4%BA%86%E3%80%82">https://raw.githubusercontent.com/wiki/AUTOMATIC1111/stable-diffusion-webui/Extensions-index.md扩展列表，我们可以点击(加载自)来刷新扩展列表，然后从这里来下载列表里的第三方插件，实际测试基本上装不了。</a></p><p>Install from URL(从网址安装)：用来安装扩展列表里没有的第三方库，就是用来给不会用git的人使用的。实际上也基本连不上git库，评价是不如直接用git来得舒服。</p><h1 id="五、提示词原理"><a href="#五、提示词原理" class="headerlink" title="五、提示词原理"></a>五、提示词原理</h1><p>提示词不同的绘画程序会有所在区别，这里以webui为主。</p><p>本节参考了这几篇博文：</p><p><a href="https://docs.qq.com/doc/DWFdSTHJtQWRzYk9k">元素同典：确实不完全科学的魔导书 </a></p><p><a href="https://docs.qq.com/doc/DSHBGRmRUUURjVmNM">Tags基本编写逻辑及三段术式入门与解析v3 </a></p><p><a href="https://www.bilibili.com/read/cv19790550">完整tags书写思路，从人工智能理论来了解如何绘画</a></p><h2 id="1-提示词的顺序"><a href="#1-提示词的顺序" class="headerlink" title="1.提示词的顺序"></a>1.提示词的顺序</h2><p>对于提示词对画面的影响，我们首先想到，也是最直观看到的自然就是提示词的顺序，**<font color="red">AI对越靠前的提示词就越重视</font>**，我们可以做个实验来看看效果：</p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-05-31_17-43-55.png"><p>图1作为参考图，</p><p>图2：深林(Forest)被放置在首位，AI绘制的画面开始着重数目，草丛的特征被稀释，同时落叶增加了；</p><p>图3：林间小道(Forest trail)被放置在首位，AI绘制的画面小路的细节被增加；</p><p>图4：落叶(fallen leaves)被放置在首位，AI绘制的画面中落叶的数量被大量增加；</p><p>图5：草丛(Grass)被放置在首位，AI绘制的画面草丛的特征被方法，树下均被绘制了茂密的草丛；</p><p>图6：秋天(Autumn)被放置在首位，AI绘制的画面开始大片的出现秋天的特征，树叶变得更黄了，落叶变得更多了，连女孩也开始套上了围巾，换上了秋季得衣服。</p><h2 id="2-提示词的权重"><a href="#2-提示词的权重" class="headerlink" title="2.提示词的权重"></a>2.提示词的权重</h2><p>在stable diffusion webui中提示词可以被增加权重，以提高AI对某些提示词的重视程度，sd webui支持两种为提示词加权重的方式，其一使用英文小括号<code>()</code>，括号可以无限叠加，如：<code>((Autumn))</code>其二使用英文小括号加权重，括号也可以叠加，如：<code>(Grass,(Autumn:1.3))</code>，一个括号代表为提示词增加1.1倍权重，叠加一个括号表示增加<code>1.1*1.1</code>倍的权重，依次类推，而指定了权重的方式则是直接为提示词增加指定的权重，如在<code>(Grass,(Autumn:1.3))</code>中，Grass被增加了1.1倍的权重，Autumn则被增加了<code>1.1*1.1*1.3</code>被的权重。使用指定式权重时必须使用一个括号括起来。</p><p>我们测试一下提示词权重</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-05-31_18-24-51.png"></p><p>图2给秋天(Autumn)增加了<code>1.1*1.1=1.21</code>倍的权重，秋天的氛围变浓了；</p><p>图3给秋天(Autumn)增加了<code>1.1*1.3=1.43</code>倍的权重，秋天的特征变得更明显，连草地都变黄了。</p><p>需要注意的是在给提示词增加权重时也不是加高越好的，加得太高了反而会适得其反，而是要根据整个提示词组，相对权重来增加，比如图2的提示词组中秋天这个提示词加了两个括号后，相对权重已经是最高的了，就没必要再给秋天这个提示词加七八个括号上去了。</p><p>权重过高反而会使绘制的图崩坏：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-05-31_18-32-11.png"></p><h2 id="3-提示词的形式"><a href="#3-提示词的形式" class="headerlink" title="3.提示词的形式"></a>3.提示词的形式</h2><p>我们在使用提示词描述一个画面的时候，有多种形式，可以用<strong>单个的词语组合</strong>、可以用<strong>一段完整的句子</strong>、也可以用<strong>单词与短句的结合</strong>，不同的提示词形式又有什么影响呢？我们还是通过实验来看看。</p><p>我们来画一个“一个穿着白色运动衫和粉红色运动鞋的黄色短发的站在街上的女孩”，使用文生图的Prompts from file or textbox脚本分别生成三种类型的提示词的图。</p><p>单词组：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-number">1</span>girl,<span class="hljs-keyword">short </span>yellow hair,white <span class="hljs-keyword">sweatshirt,pink </span>sneakers,standing,in street,full <span class="hljs-keyword">body,looking </span><span class="hljs-built_in">at</span> viewer,<br></code></pre></td></tr></table></figure><p>完整长句：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">A girl <span class="hljs-keyword">with</span> <span class="hljs-keyword">short</span> yellow hair <span class="hljs-keyword">in</span> <span class="hljs-keyword">a</span> white sweatshirt <span class="hljs-keyword">and</span> pink sneakers standing <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> street,full body,looking <span class="hljs-keyword">at</span> viewer,<br></code></pre></td></tr></table></figure><p>短语与单词组合：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">short </span>yellow hair,a  girl in a white <span class="hljs-keyword">sweatshirt </span><span class="hljs-keyword">and </span>pink sneakers,standing,in street,full <span class="hljs-keyword">body,looking </span><span class="hljs-built_in">at</span> viewer,<br></code></pre></td></tr></table></figure><p>出图结果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-06-01_17-21-29.png"></p><p>第一列：使用的是单词组提示词，画的四张测试图里面头发颜色都画对了，衣服颜色全部被子鞋子颜色污染没有一张是正确的，鞋子颜色也只有三张是正确的；</p><p>第二列：使用的是完整的长句提示词，画的四张测试图里面头发、衣服、鞋子颜色都正确；</p><p>第三列：使用的短句和单词组合的提示词，画的四张测试图里面头发颜色都正确，衣服杨色全部被鞋子颜色污染，鞋子颜色都正确。</p><p>现在不同类型的提示词的效果就出来了，很明显使用完整长句的提示词能很好的绑定物体的特征，短句与单词组合次之，单词组提示词绑定的最差。</p><p>不过大多数情况一个画面是很难使用一句完整的长句描述出来的，所以三种类型的提示词多数需要根据实际情况来选择使用。</p><h2 id="4-分步描绘"><a href="#4-分步描绘" class="headerlink" title="4.分步描绘"></a>4.分步描绘</h2><p>stable diffusion支持多种分步绘制的语法，如：<code>[a | b]</code>、<code>a | b</code>、<code>[a : b : 0.4]</code>、<code>[a : 10]</code>、<code>[a :: 10]</code>，<code>a:0.5 AND b:0.6</code>。</p><h3 id="对主体的分步描绘"><a href="#对主体的分步描绘" class="headerlink" title="对主体的分步描绘"></a>对主体的分步描绘</h3><p>语法<code>[a:b:0.4]</code>，假设采样步数为20，那么这个语法的意思就是前8步绘制特征a，后12步绘制特征b，分步描绘可以将多个提示词融合到一个主体上；</p><p>语法<code>[a | b]</code>和<code>a | b</code>，表示第一步画特征a，第二步画特征b，第三步画特征a，第四步画特征b，依次类推；</p><p>还是先来看一下实验：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-06-02_14-24-14.png"></p><p>不使用分步的<code>(panda:0.4),(goblin:0.6)</code>已经不知道在画什么了，使用可控分步的<code>[panda:goblin:0.4]</code>和均衡分步的<code>[panda | goblin]</code>的效果和我们先画大熊猫为整体画面定下结构然后往大熊猫身上添加哥布林的特征的预期比较接近，<code>panda:0.4 AND goblin:0.6</code>语法融合的感觉更加深入，有一种大熊猫和哥布林的杂交物种的感觉。</p><h3 id="对修饰词的分布描绘"><a href="#对修饰词的分布描绘" class="headerlink" title="对修饰词的分布描绘"></a>对修饰词的分布描绘</h3><p>用于修饰某一主体的修饰词的混合和主体本身的混合又有一点细微的差别，我们渐变色头发为例，分步描绘渐变发色有两种方式，一种是分步描绘颜色，不分步头发，另一种是颜色和头发都分步描绘：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/%E9%A2%9C%E8%89%B2%E5%88%86%E6%AD%A5%E6%B7%B7%E5%90%88.png"></p><p>可以看到在不使用分步绘制<code>1girl,red and blue hair,</code>和<code>1girl,red hair, blue hair,</code>的情况下ai也能画出相应的颜色混合的头发，但是发色是直接硬拼接起来的，无论是只分步颜色还是颜色和头发都分步，效果是一样的；</p><p> 在使用<code>1girl,[red | blue] hair,</code>和<code>1girl,[red hair | blue hair],</code>均衡分步绘制语法绘制的头发更接近正常的渐变色的染发 ；</p><p>在使用没有中括号的<code>1girl,red | blue hair,</code>和<code>1girl,red hair | blue hair,</code>均衡分步绘制语法绘制的头发 也有那么一点硬接的感觉，但是混合效果还可以，比不使用分步绘制的情况要好；</p><p>对于修饰词的分步描绘使用可控步数的语法<code>1girl,[red:blue:0.5] hair,</code>和<code>1girl,[red hair:blue hair:0.5],</code>则完全不起作用了；</p><p> 使用AND语法的分步描绘<code>1girl,red AND blue hair,</code>和<code>1girl,red hair AND blue hair,</code>在只有分步颜色的情况下，AI直接做了红色和蓝色的混合，用混合后的颜色来作为头发的颜色了，在颜色和头发都分步描绘的情况下， 效果和使用中括号的均衡分步描绘的效果差不多了。</p><p>在我自己的使用过程中，分步描绘的混合效果很大程度上取决于大模型，比如测试发色混合时同一套提示词使用abyssorangemixAOM3模型混合的效果就很差，使用revAnimated模型混合的效果就很好。</p><h3 id="指定开始步数和结束步数的分布描绘"><a href="#指定开始步数和结束步数的分布描绘" class="headerlink" title="指定开始步数和结束步数的分布描绘"></a>指定开始步数和结束步数的分布描绘</h3><p>语法<code>[a : 10]</code>，表示从第10步开始画特征a；</p><p>语法<code>[a :: 10]</code>，表示从第10步开始结束画特征a；</p><p>二者还可以结合<code>[[a :: 16] : 4]</code>，表示从第4步开始，到第16步结束画特征a；</p><p>三者在出图效果上差别不大：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-06-02_15-35-51.png"></p><h2 id="5-占位符"><a href="#5-占位符" class="headerlink" title="5.占位符"></a>5.占位符</h2><p>占位符指的是一些模型无法理解的符号或词语，这些符号或词语在模型中没有明确的特征与它们相关联，所以ai画不出这些符号或词语的特征，但是它们又会占用词元数量，这样的符号或词语对ai来说就是占位符，常见的占位符符号有：<code>\  *  + _</code>等，词语可以是任何模型不理解的自造词。</p><p>占位词的一大作用就是拉开一个词元与另一个词元之间的距离，最常见的用法就是通过拉开词元距离来减少颜色污染，如：画一个<code>一个穿着白色运动衫和粉红色运动鞋的黄色短发的站在街上的女孩</code>，在使用的单词组的情况下颜色污染很严重，我们就可以使用占位词来拉开不用颜色词元之间的距离来避免颜色污染。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-06-01_18-14-23.png"></p><p>可以看到在使用占位符将white sweatshirt和pink sneakers的词元距离拉开之后，颜色污染被有效的避免了。</p><h2 id="6-Emoji表情"><a href="#6-Emoji表情" class="headerlink" title="6.Emoji表情"></a>6.Emoji表情</h2><p>Emoji表情也在stable diffusion webui的支持当中，并且能很精准的识别，比如在想让ai画出一些不太好描述的表情的时候，就可以使用emoji表情来控制。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-punctuation">(</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">(</span>😥<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span><span class="hljs-number">1</span><span class="hljs-variable">girl</span><span class="hljs-operator">,</span><span class="hljs-built_in">Head</span> <span class="hljs-built_in">Close</span><span class="hljs-operator">-</span><span class="hljs-variable">up</span><span class="hljs-operator">,</span><span class="hljs-variable">complete</span> <span class="hljs-variable">face</span><span class="hljs-operator">,</span><br><span class="hljs-punctuation">(</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">(</span>😤<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span><span class="hljs-number">1</span><span class="hljs-variable">girl</span><span class="hljs-operator">,</span><span class="hljs-built_in">Head</span> <span class="hljs-built_in">Close</span><span class="hljs-operator">-</span><span class="hljs-variable">up</span><span class="hljs-operator">,</span><span class="hljs-variable">complete</span> <span class="hljs-variable">face</span><span class="hljs-operator">,</span><br><span class="hljs-punctuation">(</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">(</span>🥺<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span><span class="hljs-number">1</span><span class="hljs-variable">girl</span><span class="hljs-operator">,</span><span class="hljs-built_in">Head</span> <span class="hljs-built_in">Close</span><span class="hljs-operator">-</span><span class="hljs-variable">up</span><span class="hljs-operator">,</span><span class="hljs-variable">complete</span> <span class="hljs-variable">face</span><span class="hljs-operator">,</span><br></code></pre></td></tr></table></figure><p>😥：失望但又如释重负；</p><p>😤：傲慢；</p><p>🥺：恳求；</p><p>出图的结果从左往右一次是😥、😤、🥺：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-06-01_22-42-39.png"></p><p>当然除了描述表情的emoji表情，一些描述节日的也很好用：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">((🎃)),<span class="hljs-number">1</span>girl,full <span class="hljs-keyword">body</span>,standing,<br>((🎄)),<span class="hljs-number">1</span>girl,full <span class="hljs-keyword">body</span>,standing,<br>((🎁)),<span class="hljs-number">1</span>girl,full <span class="hljs-keyword">body</span>,standing,<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-06-01_22-48-57.png"></p><h2 id="7-提示词分类"><a href="#7-提示词分类" class="headerlink" title="7.提示词分类"></a>7.提示词分类</h2><p>提示词也是分很多种类的，比如有专门描述画面质量的、有专门描述画面氛围的、有专门描述光照的、有专门描述渲染的、有专门描述镜头的、绘制画面主体的等等。</p><p>描述词数量巨大，这里就不分类列出来了，提供几个我常用提示词收录网址：</p><p><a href="https://tags.novelai.dev/">Danbooru 标签超市 (novelai.dev)</a></p><p><a href="https://aitag.top/">魔咒百科词典 (aitag.top)</a></p><p><a href="https://aiguidebook.top/index.php/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E9%AD%94%E5%AF%BC%E4%B9%A6-%E5%85%83%E7%B4%A0%E6%B3%95%E5%85%B8/">从零开始的魔导书 元素法典 - AI绘图指南wiki (aiguidebook.top)</a></p><p><a href="https://wolfchen.top/tag/">NovelAI tag在线生成器 (wolfchen.top)</a></p><p><a href="https://safebooru.donmai.us/posts">Danbooru: Anime Image Board (donmai.us)</a></p><h1 id="六、模型文件"><a href="#六、模型文件" class="headerlink" title="六、模型文件"></a>六、模型文件</h1><p>Stable-diffusion支持五种模型文件，Checkpoint、Embedding、Hypernetwork、Lora和VAE。</p><h2 id="1-Checkpoint"><a href="#1-Checkpoint" class="headerlink" title="1.Checkpoint"></a>1.Checkpoint</h2><p>Checkpoint是深度学习领域模型训练中保存模型参数的一种术语，一个模型的训练是循序渐进的，训练到一定的阶段就可以使用Checkpoint来保存当前的训练结果，这个训练结果也就是我们常说的模型。</p><p>Checkpoint模型就是我们在webui的Stable Diffusion checkpoint中选择的模型。Checkpoint模型我把它理解为AI的记忆，它控制着AI能画出什么，画出的东西长什么样。</p><p>Checkpoint模型一般分为两种，一种是Stability.AI官方为Stable Diffusion训练的通用超大型模型，目前已经更新到v2.1版本，这种模型都非常大，基本是4-5G往上。</p><p>官方提供的基础通用模型可以到HuggingFace下载：</p><p>1.5版本：<a href="https://huggingface.co/runwayml">runwayml (Runway) (huggingface.co)</a>；</p><p>2.1版本：<a href="https://huggingface.co/stabilityai?sort_spaces=likes#spaces">stabilityai (Stability AI) (huggingface.co)</a>。</p><p>另一种则是在通用模型的基础上训练的针对某一方面的定制化模型，也是我们最常使用的、在各大模型网站下载的模型，都属于这个种类。Checkpoint在存储训练参数的同时也提供参数的载入，进行再训练，个人训练的Checkpoint模型都是基于官方提供的Checkpoint模型再训练得出的。</p><p>定制化模型可以到C站下载：<a href="https://civitai.com/">Civitai</a>。</p><h3 id="大模型的使用"><a href="#大模型的使用" class="headerlink" title="大模型的使用"></a>大模型的使用</h3><p>大模型的使用就比较简单了，直接点击左上角的Stable Diffusion Model就可以切换大模型，也可以通过点击右上角的show/hide extra networks按钮通过点击预览图切换。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-06-02_15-39-27.png"></p><h2 id="2-Lora"><a href="#2-Lora" class="headerlink" title="2.Lora"></a>2.Lora</h2><p>Lora模型是一种生成对抗网络模型，主要用对Checkpoint模型进行定向的微调。个人理解是用来做Checkpoint模型提示词重映射的。比如，在一个Checkpoint模型中，提示词“猫”对应形象是“加菲猫”，那么Lora就可以将“猫”这个提示词重映射，使其对应的形象变成HelloKitty，那么在加持Lora模型的Checkpoint模型上输入“猫”这个提示词后AI将不再生成加菲猫，而全部生成HelloKitty。</p><p>Lora的使用目前有两种方式，一种是使用直接通过webui的Lora管理界面点击对应的Lora来应用，点击后webui会在正向提示词中添加一个形如：<code>&lt;lora:[lora名称]:[lora权重]&gt;</code>的标签，权重最大为1，最小为0，多个lora可以混合使用。</p><p>另一种是通过<a href="https://github.com/kohya-ss/sd-webui-additional-networks">sd-webui-additional-networks</a>插件来使用，通过这个插件来使用lora就不会像正向提示词中添加标签了，并且插件支持xyz plot脚本，可以很好的对比不同lora文件对画面的影响，尤其是在自己训练lora时对比不同epoches下的lora效果时很好用，但是使用这个插件需要将lora从webui的默认位置移动到插件位置中。</p><h3 id="Lora的使用"><a href="#Lora的使用" class="headerlink" title="Lora的使用"></a>Lora的使用</h3><p>Lora的使用可以通过点击右上角的show/hide extra networks按钮在Lora标签中点击相应的预览图来使用，添加成功后webui会向正向提示词中添加一个类似<code> &lt;lora:lihui-repro-32-1e-4-noflip-re2-nonoise:1&gt;</code>的提示词，这个就表示使用了对应的lora，默认权重为1，Lora的使用权重最小为0最大为1，一般不使用两个极值，权重为0则Lora完全不会生效，权重为1则严重影响到出图效果，甚至可能会直接图lora训练时的原图。在C站上lora作者一般都会给出lora的最佳使用权重，最好根据作者的推荐权重来使用。</p><p>有的lora会有触发词，有的lora没有触发词，触发词一般时lora作者的自创词，使用触发词能够有效的触发lora效果，触发词的具体使用和lora的不同有所差异，有的lora有触发词，但不使用也能触发效果，有的lora则必须使用触发词才能触发效果。</p><p>多个不同的lora可以混合使用，lora和Embedding、Hypernetworks之间也可以混合使用</p><h3 id="Lora的分层控制"><a href="#Lora的分层控制" class="headerlink" title="Lora的分层控制"></a>Lora的分层控制</h3><p><font color="red">后续更新计划</font></p><h2 id="3-Embedding"><a href="#3-Embedding" class="headerlink" title="3.Embedding"></a>3.Embedding</h2><p>Embedding(嵌入层)也是深度学习中的一种模型，主要用来做编码映射，更深入的可以看这篇博文：<a href="https://zhuanlan.zhihu.com/p/164502624">一文读懂Embedding的概念，以及它和深度学习的关系</a>。</p><p>在Stable diffuion中，Embedding模型提供了一种向已有模型嵌入新内容的方式，Embedding模型可以使用很少的图片数据，来生成一个具有新的风格或者人物形象的模型，并且可以使用特定的提示词来映射这些特征。如，某一天有一个新猫猫形象叫git cat被创造出来，而原来的旧模型可能只有加菲猫或者HelloKitty，没有git cat这只猫猫的数据，那么我们想通过原有的模型让AI画出git cat那是做不到的，于是我们可以git cat的数据训练一个Embedding模型，在使用的时候将Embedding模型嵌入到原模型上，这样我们使用原模型就可以让AI画出git cat这只猫了。</p><p>Embedding模型有两种称呼，国内大多就叫Embedding模型，也有叫TextualInversion模型，webui也是用TextualInversion来称呼。</p><p>Embedding技术官网：<a href="https://textual-inversion.github.io/">图像胜过一个词：使用文本反转个性化文本到图像生成 </a>。</p><p>现在embedding模型已经很少使用了，目前最常用embeding模型就是用于配合三视图lora使用的<a href="https://civitai.com/models/3036">CharTurner V2 </a>、用于反向提示词集合的<a href="https://civitai.com/models/7808">EasyNegative</a>和用于美化脸部的<a href="https://civitai.com/models/4514">PureErosFace_v1</a>。</p><h2 id="4-Hypernetworks"><a href="#4-Hypernetworks" class="headerlink" title="4.Hypernetworks"></a>4.Hypernetworks</h2><p>Hypernetworks又叫超网络，Hypernetworks模型是一种风格化文件，可以为AI生成的图像应用指定画风。如，同样是画一个HelloKitty，在没有应用Hypernetworks模型的情况，画出来的HelloKitty就是一只正常的HelloKitty，如果给AI应用一个金享泰画风的Hypernetworks模型，那么AI画出来的HelloKitty就变成一只油腻的HelloKitty。</p><h2 id="5-VAE"><a href="#5-VAE" class="headerlink" title="5.VAE"></a>5.VAE</h2><p>VAE的作用就是在第一章中讲到的将图片从潜空间的压缩数据解码变成一张正常的图片，不同的VAE会影响AI出图的色调，如果当我们不使用VAE时，AI生成的图片均会有一层灰蒙蒙的感觉，使用VAE会使图片的饱和度有所区别。</p><p>目前网络上公开的VAE熟练还是比较少的，主要的来源有三个：</p><p>Stability.AI官方提供的：<a href="https://huggingface.co/stabilityai/sd-vae-ft-mse-original">stabilityai/sd-vae-ft-mse-original </a>；</p><p>NovelAI模型泄露的：这个就没有网址了，可以使用秋叶的启动器下载；</p><p>Reimu Hakurei提供的：<a href="https://gist.github.com/harubaru/8581e780a1cf61352a739f2ec2eef09b">wd1-4-anime-release</a>。</p><h2 id="6-AestheticGradients"><a href="#6-AestheticGradients" class="headerlink" title="6.AestheticGradients"></a>6.AestheticGradients</h2><p>AestheticGradients(美学渐变)是以插件的形式存在一种模型修改技术，AestheticGradients模型需要依赖AestheticGradients插件才能使用，效果和Hypernetworks差不多，但是基于AestheticGradients插件提供了更多的可调节参数，而Hypernetworks的参数是已经定死了不可更改的。</p><p>AestheticGradients模型以<code>.pt</code>最为后缀，一般只有几K的大小。</p><p>stable-diffusion-webui-aesthetic-gradients插件库地址：<a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui-aesthetic-gradients">AUTOMATIC1111/stable-diffusion-webui-aesthetic-gradients: Aesthetic gradients extension for web ui </a>；</p><p>AestheticGradients库：<a href="https://github.com/vicgalle/stable-diffusion-aesthetic-gradients">stable-diffusion-aesthetic-gradients/aivazovsky.pt at main · vicgalle/stable-diffusion-aesthetic-gradients</a>。</p><p>在AestheticGradients库的aesthetic_embeddings文件夹下，作者提供了一些作者预制的AestheticGradients模型。</p><h1 id="七、AI绘图的用法拓展"><a href="#七、AI绘图的用法拓展" class="headerlink" title="七、AI绘图的用法拓展"></a>七、AI绘图的用法拓展</h1><h2 id="1-ControlNet"><a href="#1-ControlNet" class="headerlink" title="1.ControlNet"></a>1.ControlNet</h2><p>ControlNet可以提供AI一个参考图，ControlNet会对参考图先做一次预处理，如识别参考图中人物的骨骼特征点或者物体的边缘线，然后再将检测出来的结果图给AI参考，让AI按照参考的姿势或边缘线来绘制图像。这有点类似图生图，只是二者底层原理不一样，图生图主要是通过噪点采样来学习图片的像素分布，而ControlNet则是通过机器视觉来进行智能识别再给AI学习。</p><p>ControlNet的原理主要是使用OpenCV的一些识别算法，如姿势识别、手势识别、边缘检测、深度检测等，先对参考图做一层机器视觉方面的预处理，生成身体骨骼特征点、手势骨骼特征点、描边图、深度图等中间图，然后再让AI参考这些中间图进行创作。</p><p>想要更细致的了解ControlNet可以看这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MzAxMzMxNDIyOA==&mid=2655548765&idx=1&sn=aaa5601921b8d438b5f3d4b5c91db498&chksm=8018a486b76f2d9005ac88af45c810aaae4fb959b9613a91b739428d95762f5c7b26b4e6b57a&scene=21#wechat_redirect">精确控制 AI 图像生成的破冰方案，ControlNet 和 T2I-Adapter </a>。</p><p>ControlNet的库地址：<a href="https://github.com/Mikubill/sd-webui-controlnet">Mikubill/sd-webui-controlnet: WebUI extension for ControlNet</a>；</p><p>直接用git克隆到插件目录，重启WebUI就安装好了，安装好之后在文生图界面会多出一个ControlNet栏。</p><p>ControlNet有很多自己的参数，参数的作用可以看这位up主的视频，他已经讲的很详细了：<a href="https://www.bilibili.com/video/BV16j411379n/?spm_id_from=333.337.search-card.all.click&vd_source=e979466844c4915a4200c496efb35cfb">【赛博Coser】《超详细》ControlNet拆解教学，让你彻底理解AI绘画的精髓</a>。</p><ul><li><p>**Image(图像)**：用于传入参考图的原图；</p></li><li><p><strong>相机按钮</strong>：在Image下方的相机按钮是用来打开电脑的默认摄像头的；</p></li><li><p>**Enable(启用)**：启用ControlNet；</p></li><li><p>**Invert Input Color(反转输入颜色)**：用于以白色为背景的参考图，需要勾选这个选项，可能是因为不同的算法、模型对蒙版的处理不一样导致的吧，比如前面提到的局部重绘就有出现蒙版颜色不一致的情况，有的用黑色作为蒙版颜色，有的用白色作为蒙版颜色；</p></li><li><p><strong>RGB to BGR</strong>：这个选项大多数情况我们应该用不到，这个选项的主要目的是我们平常的图片使用的RGB通道，但是OpenCV默认使用则是BGR通道；</p></li><li><p>**Low VRAM(低显存模式)**：在显存不够的时候可以勾选上，虽然作者并没有说明使用低显存模式对出图质量会有什么影响，在我自己的测试中，在同一显存条件下，勾选低显存模式会降低出图质量和出图速度，所以在显存够用的情况下，这个选项就不要勾选了；</p></li><li><p><strong>Guess Mode</strong>：这个模式按作者的说法是勾选上以后AI会忽略提示词，在ControlNet的约束范围内自由发挥，但我实际使用的情况是如果我们不手动清空提示词，AI并没有忽略提示词，AI生成的图里依然严格包含提示词的内容，值得注意的是这个模式是不适用于所有预处理器，比如描边用的canny就无法只用这个模式，强行使用会报错；</p></li><li><p>**Preprocessor(预处理器)**：预处理器我个人理解就是用于对参考图做预处理的算法，不同预处理器对应不同的图像处理算法；</p><p>预处理器中用的比较多的住主要是：</p><p>这些预处理器的算法是没有内置在插件里的，当我们使用了一个本地没有的预处理器时，插件会自动为我们下载对应的算法。</p><p><strong>canny</strong>-边缘检测，处理效果是：</p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-03-02_15-48-43.png" style="zoom:50%;"><p><strong>depth</strong>-深度计算，处理效果是：</p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-03-02_15-49-06.png" style="zoom:50%;"><p><strong>depth_leres</strong>-更进精确的深度计算，depth_leres能更准确检测原图的环境，具体可以看：<a href="https://github.com/Mikubill/sd-webui-controlnet/pull/167">Add support for LeReS depth by cmeka · Pull Request #167 · Mikubill/sd-webui-controlnet</a>；处理效果是：</p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-03-02_15-49-23.png" style="zoom:50%;"><p><strong>openpose</strong>-姿势检测，处理效果是：</p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-03-02_15-49-42.png" style="zoom:50%;"><p><strong>Hed</strong>-更柔和边缘检测，处理效果是：</p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-03-02_15-51-00.png" style="zoom:50%;"><p>Hed算法描边更柔和能够记录更多的细节。</p><p><strong>mlsd</strong>-适用于建筑物的边缘检测，处理效果为：</p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-03-02_16-05-02.png" style="zoom:50%;"><p>mlsd算法对棱角的描边处理很优秀。</p><p><strong>normal_map</strong>-法线图检测，处理效果是：</p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-03-02_16-12-25.png" style="zoom:50%;"><p>法线图的优点在于，它即保留了图像一定的深度信息，又能够保留一部分图像的细节信息，对于想要使用深度图控制图片生成，但是又想要保留一些人物细节的时候可以使用。</p><p><strong>pidinet</strong>-更粗糙的边缘检测，处理效果是：</p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-03-02_16-19-42.png" style="zoom:50%;"><p>pidinet描边保留的细节比canny更少，所以对AI出图约束也更小。</p><p><strong>scribble</strong>-分割检测，处理结果是：</p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-03-02_16-22-09.png" style="zoom:50%;"><p>scribble算法是一种图片分割算法，可以使用黑白色块将图片分成不同的部分。</p><p><strong>fake_scribble</strong>-超级粗糙的边缘检测，处理效果是：</p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-03-02_16-27-00.png" style="zoom:50%;"><p>fake_scribble算法基本上就只做了外边缘的检测，内部的边缘线基本就抛弃了，保留的细节比pidinet更少。</p><p><strong>segmentation</strong>-语义分割，处理效果是：</p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-03-02_16-37-29.png" style="zoom:50%;"><p>语义分割可以将像素分类成不同模块，如哪些像素属于人物，哪些像素属于地板，哪些像素属于植物，然后将这些像素连成一个一个的色块，这个算法更适用于场景类的图片生成。</p></li></ul><p>  <font color="green">以下是在撰写Lora训练时WebUI更新的新的预处理器</font></p><p>  <strong>Openpose_hand</strong>-带手势的姿势检测，也使用openpose模型，需要使用人物的脸和手比较清晰的图片才能识别的比较好；</p><p>  <img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-04-04_13-05-29.png"></p><p>  <font color="green">下面三个预处理器是ControlNet融合了T2i-adapter的一些能力，<a href="https://github.com/TencentARC/T2I-Adapter">T2i-adapter</a>是北大和腾讯ARC开源的一个扩散模型引导算法，是和ControlNet齐名的引导算法，所以预处理器使用的模型也由T2i-adapter提供，地址是：<a href="https://huggingface.co/TencentARC/T2I-Adapter/tree/main/models">TencentARC/T2I-Adapter at main</a>，模型下载下来后也放入extensions\sd-webui-controlnet\models文件夹下。</font></p><p>  <strong>clip_vision(风格转移)</strong>-可以传入一张图，使AI学习图片的风格，让AI绘制出风格相近的图片，配个Style模型使用，我自己在使用的过程中webui加载<code>coadapter-style-sd15v1.pth</code>模型时会报错，需要使用t2iadapter_style_sd12v1模型才能正常使用。</p><p>  这里我使用了一张暗调的图给AI进行风格化学习，出图效果如下：</p><p>  <img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-04-04_18-13-20.png"></p><p>  可以看到AI绘制出来的图片基本都是偏暗色调的了，实际测试中发现，AI对风格化的学习很大程度上会受到提示词的影响，当提示词的控制的画面是一个很亮的画面时，AI学习了风格化也不一定能稳定的出暗调的图。</p><p>  <strong>color(色彩)</strong>-可以传入一张图片，生成像素分布，然后让AI根据像素分布来绘制图片，需要配合t2iadapter_color_sd12v1模型使用，就我自己实际使用后的感想是：没什么乱用，看到网上有人用这个模型通过图生图来精细的控制画面中物品的颜色，就我个人的实际使用来看，效果一言难尽。</p><ul><li><p>**Model(模型)**：模型就是作者针对不同的预处理器训练的用于对应机器视觉的神经网络模型，这些模型作者在huggingface上分享了出来：<a href="https://huggingface.co/lllyasviel/ControlNet/tree/main">lllyasviel/ControlNet at main </a>，不过吧，作者分享的模型有点冗余是融合了一下其他的模型在里面的，实际模型没那么大，作者也在Git页面有提供说明和萃取精简模型的方法，我就没有自己去萃取了，已经有大佬为我们萃取好了，这里推荐秋叶大佬萃取的：<a href="https://www.bilibili.com/read/cv21829826">【AI绘画】controlnet安装/使用教程 动作控制 景深 线稿上色</a>；</p><p>(最近发现作者自己也萃取了模型分享了出来，地址是：<a href="https://huggingface.co/webui/ControlNet-modules-safetensors/tree/main">webui/ControlNet-modules-safetensors at main</a>）</p><p>各种类型的算法都有对应的训练模型，这些模型能有优化ControlNet辅助AI出图的效果，我们下载的模型有两种，一种是放在<code>extensions\sd-webui-controlnet\models</code>文件夹下的，这种模型比较大，纯净版都有一G多，原作者给的甚至有五个多G，个人理解这种模型应该是有点类似Lora的感觉，用于辅助出图的；另一种是放在对应的算法文件夹下的，如作者提供的用于openpose的<code>body_pose_model.pth</code>和<code>hand_pose_model.pth</code>，这种比小一般在100多MB，这种模型个人理解是有点类似OpenCV使用的caffemodel模型，用来辅助ControlNet出中间图的。当然也可以不使用模型，我自己实际使用中使不使用模型效果感觉没什么区别；</p></li><li><p>**Weight(权重)**：ControlNet根据生成的中间图给出Difusion生成图片的条件，以使AI创作图片时符合ControlNet的约束，这和Clip给出的图片生成条件就会出现拟合，所以需要一个权重来分配两组条件的占比，Weight就是来控制两组生成条件的权重的。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/xyz_grid-0002-2616072617-(masterpiece_1.3)%2C%20(the%20best%20quality_1.2)%2C%20(super%20fine%20illustrations_1.2)%2C%20(Masterpiece)%2C%20high%20quality%2C%20high%20detail%2Cdappled%20sunl.png"></p></li><li><p>**Guidance Start(T)/Guidance End(T)**：这两个选项是用来控制ControlNet在Smapler重复采样过程中的干预程度的，Guidance Start设置的是从第几次采样开始进行干预，Guidance End设置从第几次采样开始停止干预，如在一个采样步数为20步的绘画过程中，我们设置Guidance Start=0.2，Guidance End=0.8，那么在这20步得采样中，ControlNet的干预从第4步开始到第16步结束。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/xyz_grid-0003-2031027839-(masterpiece_1.3)%2C%20(the%20best%20quality_1.2)%2C%20(super%20fine%20illustrations_1.2)%2C%20(Masterpiece)%2C%20high%20quality%2C%20high%20detail%2Cdappled%20sunl.png"></p></li><li><p>**Resize Mode(缩放模式)**：缩放模式控制的是生成图与参考图之间的适配方式；</p></li><li><p>**Canvas Width(画布宽度)/Canvas Height(画布长度)**：控制的是ControlNet对原图采用多大分辨率来进行图像识别，主要使用来解决当传入的原图很大的时候显存吃不消的问题，我实际测试中，这两个选项的设置对出图几乎没有影响。</p></li><li><p>**Create blank canvas(创建空白画布)**：ControlNet除了可以输入图片作为原图来生成中间图，也可以通过手绘一张原图来生成中间图，这个按钮就是用来创建手绘的空白画布的；</p></li><li><p>**Preview annotator result(预览预处理结果)/Hide annotator result(隐藏预处理结果)**：用来预览和隐藏中间图。</p></li></ul><p>  对于不同预处理器，还有各自的自有参数，这里就挑最常用的三个记录一下：</p><p>  <strong>Canny</strong>：</p><p>  Annotator resolution：控制ControlNet生成中间图的精细度；</p><p>  Canny low threshold(描边最低阈值)/Canny high threshold(描边最高阈值)：影响描边预处理器生成描边图时的边线精确程度。</p><p>  <strong>Depth</strong>：</p><p>  Midas Resolution：这选项没摸明白有什么用。</p><p>  <strong>Openpose</strong>：</p><p>  只有一个Annotator resolution参数。</p><p>有一点需要注意，ControlNet生成的中间图都会存储在<code>C:\Users\[用户名]\AppData\Local\Temp</code>系统临时文件夹下，不仅如此很多webui的插件生成的一些中间文件也都会存储在这个目录下，使用时记得时不时清理一下这个目录，避免C盘爆炸。</p><p>ControlNet功能十分强大，可以做很多骚操作，比如：</p><h3 id="角色改姿势"><a href="#角色改姿势" class="headerlink" title="角色改姿势"></a>角色改姿势</h3><p>有时我们出图时，可能会碰到有的图角色姿势很好，有的图角色设计的很好，ControlNet就可以让我们把二者结合起来，主要就是在图生图中运用ControlNet的深度图来限制角色各个关节的空间位置关系，然后AI根据姿势的约束和原图的约束来生成一张新图。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-03-02_17-05-30.png"></p><p>这里放一张我的参数图：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-03-02_17-26-07.png"></p><p>不过吧，即使随机种子也是一样的，新生成的图和部分元素依然是会有一些差别的，如果这个差异在可接受范围内，这个功能也是一个相当不错的功能了。</p><h3 id="骨骼控制姿势"><a href="#骨骼控制姿势" class="headerlink" title="骨骼控制姿势"></a>骨骼控制姿势</h3><p>骨骼控制需要配合Openpose Editor插件一起使用，插件地址是：<a href="https://github.com/fkunn1326/openpose-editor">fkunn1326/openpose-editor: Openpose Editor for AUTOMATIC1111’s stable-diffusion-webui</a>。</p><p>Openpose Editor提供了我们在WebUI中进行人体骨骼特征点位置的编辑功能，界面操作十分简单，看一眼就会了，这里我就只展示一下效果就可以了，比如我要画一个半鸭子坐的女孩，我们就可以在Openpose Editor中将骨骼编辑成这样：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/pose.png"></p><p>然后我们可以点击Send to txt2img将编辑好的骨骼发送到文生图，然后启用ControlNet，Preprocessor选择none，Model选择control_openpose。</p><p>然后就可以出图了：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/00035-2348180386-(masterpiece_1.3)%2C%20(the%20best%20quality_1.2)%2C%20(super%20fine%20illustrations_1.2)%2C%20(Masterpiece)%2C%20high%20quality%2C%20high%20detail%2Cdappled%20sunl.png"></p><p>不过吧，我个人感觉效果上还是没有想象中那么优秀，大体上能够控制出图的姿势，对于一些比较难画的姿势，如跪姿，鸭子坐，脚还是很容易画崩，要想出好图还得大力出奇迹。</p><h3 id="使用骨骼出三视图"><a href="#使用骨骼出三视图" class="headerlink" title="使用骨骼出三视图"></a>使用骨骼出三视图</h3><p>Openpose Editor支持多骨骼编辑，我们点击Add按钮可以往骨骼编辑视图中添加骨骼，这就给绘制人物三视图提供了条件，如我们制作一个这样的三视图骨骼：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/4PGjFvX.png"></p><p>然后使用ControlNet来根据骨骼绘制，就可以得到这样的图：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/00082-914253025-(masterpiece_1.3)%2C%20(the%20best%20quality_1.2)%2C%20(super%20fine%20illustrations_1.2)%2C%20(Masterpiece)%2C%20high%20quality%2C%20high%20detail%2Cdappled%20sunl.png"></p><p>也就乐乐就好了，效果嘛，是可以画出各个角度的姿势，但是每个人物几乎控制不了让他们都长一样，服装也控制不了。</p><h3 id="使用线稿草图快速出三视图"><a href="#使用线稿草图快速出三视图" class="headerlink" title="使用线稿草图快速出三视图"></a>使用线稿草图快速出三视图</h3><p>使用骨骼出三视图的一个难点是很难使三视图的角色都画的一样，另一种思路是使用线稿草图来约束AI绘制的角色轮廓，使AI绘制我想要想要的角色的三视图，如果再搭配对应的人物Lora效果就可以做到十分完美。</p><p>首先我们需要一张草图，如我要绘制一个角色的头部的45度侧面，正侧面和正面三个视角的三视图，首先我们出一张用于约束AI的草图：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/700939043.jpg"></p><p>这里我是专门训练了这个人物的Lora的，输入我们想要效果的提示词，启用ControlNet，由于草图是白色背景，所以需要勾选反色模式，选择Canny边缘检测，调好权重和画布，然后就可以开始选图了，这是生成的效果图：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/00465-581443563.png"></p><h3 id="手部修复"><a href="#手部修复" class="headerlink" title="手部修复"></a>手部修复</h3><p>AI画手一直是个老大难的问题了，如今ControlNet给出了解决方案。原理也很简单，就是使用ControlNet进行局部控制，如我们生成了一张各方面都挺满意的图，然后AI把手给画崩了，我们就可以使用手部修复来按照我们的想法把手修复成正常的样子，如我们有这样一张图：</p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/3102190305.png" style="zoom:50%;"><p>女孩右手的手指有点画崩了，这里用ControlNet修一下。</p><p>首先我们需要制作一张符合我们要求的手部姿势图，可以使用简单的描边图，也可以使用深度图，手部姿势图分辨率要保证和原图一致，并且手部姿势要放在正确的位置上，如：</p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/%E6%89%8B%E9%83%A8%E5%A7%BF%E5%8A%BF.png" style="zoom:50%;"><p>然后使用图生图的局部重绘以尽可能的保留画面的其他细节，将参数设置的和原图的参数一致，随机种子也设置成一样的，重绘幅度设置在0.5以下，启用ControlNet约束AI的手部绘制，如果手部姿势图是白色背景记得勾选反转输入颜色，预处理器选择none，模型选择适合自己原图的画布，其他的参数可以根据自己的需求微调，然后我们来看一下效果：</p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/%E6%89%8B%E5%8A%BF%E4%BF%AE%E5%A4%8D.png" style="zoom:50%;"><h3 id="Multi-ControlNet"><a href="#Multi-ControlNet" class="headerlink" title="Multi-ControlNet"></a>Multi-ControlNet</h3><p>多层ControlNet是ControlNet最近新出的功能，ControlNet插件默认是只使用一层的，要开启多层我们需要在设置/ControlNet/多重ControlNet的最大模型数量选项设置我们要启动的最大层数，目前最大支持10层。我们启动的层数越多，对图像生成的控制就越细，AI所吃的显存也越高，以我的12G3080ti为例，我启用了两层，一层控制人物骨骼姿势，一层控制背景场景结构，跑512x512，勾选hires.fix倍数2倍就直接爆显存了。</p><p>人物骨骼姿势：<br><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-03-06_14-17-02.png"></p><p>背景构图：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-06-03_20-06-31.png"></p><p>出图效果：</p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/ControlNet%E6%8E%A7%E5%9B%BE.png" style="zoom:50%;"><h3 id="Seg语义分割"><a href="#Seg语义分割" class="headerlink" title="Seg语义分割"></a>Seg语义分割</h3><p>Seg语义分割实际就是使用ControlNet的segmentation算法，通过处理色块拉达到控制图片生成的目的，segmentation算法的语义分割符合ADE20K语义分割数据库的标准分割规则，所以我们可以根据ADE20K标准语义色块来向控制图片生成指定的物体，不过ADE20K的标准色块语义更多的是适合建筑设计和室内设计领域，所以使用segmentation也就更适合用于这两个方面。</p><p>ADE20K色块图可以到这位Up的视频下下载：<a href="https://www.bilibili.com/video/BV1bM411x7nD/?spm_id_from=333.337.search-card.all.click&vd_source=e979466844c4915a4200c496efb35cfb">【AI绘画】强大的构图工具：Seg（ControlNet）语义分割控制网络</a>；</p><p>就我实际的使用效果来说，WebUI的Seg语义分割没有想象中那么强，首先webui内置的segmentation算法识别出来的色块不够精准，对于很平滑的直线，它能识别成破损的曲线，不建议使用内置的识别算法，可以选择使用hanggingface提供的工具：<a href="https://huggingface.co/spaces/shi-labs/OneFormer">OneFormer</a>，Task Token Input选the task is panotic，Model选ADE20K，Backbone随意，这个工具生成出来的Seg图要比webui内置算法的好，对于这样一张原图：</p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Seg%E5%8E%9F%E5%9B%BE.png" style="zoom:33%;"><p>二者的语义分割效果是</p><p>OneFormer：</p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/OneFormer%E7%9A%84Seg%E5%9B%BE.png" style="zoom:50%;"><p>WebUI的Seg图：</p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Webui%E7%9A%84Seg%E5%9B%BE.png" style="zoom: 29%;"><p>能够很明显的看出差距。</p><p>对于使用色块来控制图像生成，也没有想象中的那么强，比较明显的就是AI总是喜欢往墙上绘制一些没有意义的纹理，并且对于一些不符合逻辑的要求，AI基本不会满足我们的述求。如下图，我使用色块在地毯边上放了一个盆花草(ADE20K的RGB值为：#CCFF04)，然后将墙上的代表图片的红色色块换成了代表窗户的灰白色色块(ADE20K的RGB值为：#E6E6E6)，就得到了这样一张Seg图：</p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Seg%E8%89%B2%E5%9D%97%E5%9B%BE.png" style="zoom:50%;"><p>即使我们重点强调了窗户，但AI依然不会绘制窗户。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-03-07_11-05-20.png"></p><h3 id="使用蒙版控制灯光氛围"><a href="#使用蒙版控制灯光氛围" class="headerlink" title="使用蒙版控制灯光氛围"></a>使用蒙版控制灯光氛围</h3><p>ControlNet可以配合图生图使用灯光蒙版可以进行简单的出图灯光氛围的控制，要控制灯光氛围有三个要点需要注意的，其一，我们需要保证图生图的参数与原图出图参数一致，其二，使用ControlNet深度图控制画面，其三，使用灯光蒙版控制灯光氛围。</p><p>首先我们使用文生图来生成一张测试示例：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-04-03_11-24-10.png"></p><p>然后将生成的图片放入PNG Info标签页，识别原图的参数配置，然后点击Send to img2img，这样原图的完整参数配置，包括随机种子，就都发送到图生图标签页了。</p><p>然后启用ControlNet，使用深度图控制画面，这样我们就可以使用图生图生成和原图”整体上一样”的图了，注意这里我用的是”整体上一样”，因为除非我们把重绘幅度设置成0，否则出图或多或少都会有一点细微的差别。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-04-03_11-33-17.png"></p><p>最后在图生图标签页的img2img中放入灯光蒙版图片，调整好灯光范围，然后出图看一下效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-04-03_11-33-31.png"></p><p>可以看到灯光氛围效果已经根据灯光蒙版图改变了，<font color="red">但是这里有一个矛盾，我们想要好一点的效果，重绘幅度至少要在0.6以上，而重绘幅度高了之后，原图就会出现较为明显的变化，如上面的示例中，领结的颜色变了。</font>如果不是很在一细节就无所谓，如果在意细节，就只能去PS里做一些简单修改了，效果图：</p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/%E4%BF%AE%E5%85%89%E6%95%88%E6%9E%9C.png" style="zoom:50%;"><p>不过对于被光影影响到的细节，没有一点美术功底基本就很难修了，如上面示例的“发花”。</p><h2 id="2-制作全景图"><a href="#2-制作全景图" class="headerlink" title="2.制作全景图"></a>2.制作全景图</h2><p>使用WebUI制作全景图需要一个Lora和一个插件，Lora是<a href="https://civitai.com/models/10753/latentlabs360">LatentLabs360</a>，插件是<a href="https://github.com/tjm35/asymmetric-tiling-sd-webui">asymmetric-tiling-sd-webui</a>，安装好插件后在文生图和图生图界面下会出现一个Asymmetric tiling栏，这是用来并接360图片的。</p><p>首先输入关键词：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">&lt;lora:late<span class="hljs-symbol">ntlabs360</span>_v<span class="hljs-number">01</span>:<span class="hljs-number">1</span>&gt;,<span class="hljs-comment">((a 360 equirectangular panorama)</span>) , modelshoot style, <span class="hljs-comment">(extremely detailed CG unity 8k wallpaper)</span>,<br>room,girl<span class="hljs-string">&#x27;s room,Pink princess bed,Tiled floors,walls,Pot picking,Bright sunlight,</span><br></code></pre></td></tr></table></figure><p>第一行是对360图片进行描述的关键词，必填，第二是对内容进行描述的关键词，可以自由发挥，我自己测试使用latentlabs360这个Lora只能用来画场景，画人会出现很奇怪的图。</p><p>反向关键词随意。</p><p>采样算法我测试了全部的算法，只有Euler a的效果还算行，步数也是只有在20左右效果好，太低或太高都会画不出360图。</p><p>然后就是重点，分辨率必须是横纵比2:1的比例，否则画不出360图，然后需要勾选Asymmetric tilling插件的Active和Tile X选项。</p><p>生成的图还需要经过放大，分辨率太低用全景图片查看器看图时效果会很差。</p><p>然后我们可以出图来看一下效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/00035.png"></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/00038.png"></p><p>然后我们用全景图片查看器来看看效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/%E5%85%A8%E6%99%AF%E5%9B%BE%E6%95%88%E6%9E%9C.gif"></p><p>想要制作一张优秀的全景图，需要花很多时间去打磨关键词和局部重绘，没经过处理的全景图，乍一看感觉还可以，但是一细看就全是破绽。</p><h2 id="3-制作视频"><a href="#3-制作视频" class="headerlink" title="3.制作视频"></a>3.制作视频</h2><p>使用ControlNet来使用AI生成视频有两种方式，一种是使用批量图生图配合ControlNet控制姿势来生成视频，另一种就是通过mov2mov插件配合来制作视频。</p><p>这里使用的原视频是：<a href="https://www.bilibili.com/video/BV1i24y1p7iZ/?spm_id_from=333.1007.top_right_bar_window_history.content.click%E3%80%82">https://www.bilibili.com/video/BV1i24y1p7iZ/?spm_id_from=333.1007.top_right_bar_window_history.content.click。</a></p><p>采用了视频的前五秒来作为原视频。</p><h3 id="批量图生图"><a href="#批量图生图" class="headerlink" title="批量图生图"></a>批量图生图</h3><p>先将一段视频使用视频编辑工具导出序列帧，每一帧就是一张png，然后启用ControlNet，Preprocessor选择hed，hed能够尽可能多的记录原图的人物形态和环境要素，model选择对应的模型，然后使用批量图生图的形式让AI更具序列帧一张图一张图的绘制，为了使制作的视频效果尽可能的好，我们应该尽可能使视频中的环境要素尽可能的简单，以使AI绘制的图片的背景尽可能的不变，我们也可以设置蒙版，使AI在绘制时只对人物所在区域进行绘制，同时配上一些尽量匹配原视频的关键词，这样可以将输出的图片之间的差异减到最小，然后我们再将AI绘制过一遍的图片序列作为输入，配合负面关键词来去除在第一遍生成时出现的一些我们不希望在视频中出现的元素，如果配置满足的话，可以配合Multi-ControlNet对人物形态，场景等做进一步约束。</p><p>来看一下效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/ControlNet%E8%A7%86%E9%A2%91.gif"></p><p>AI制作视频最大的难点依然是无法控制每张图尽可能的不变。</p><h3 id="mov2mov插件"><a href="#mov2mov插件" class="headerlink" title="mov2mov插件"></a>mov2mov插件</h3><p>mov2mov插件是一个国人制作的sd-webui插件，插件地址是：<a href="https://github.com/Scholar01/sd-webui-mov2mov">Scholar01/sd-webui-mov2mov: 适用于Automatic1111/stable-diffusion-webui 的 Mov2mov 插件</a>。</p><p>安装好插件后在标签栏会出现一个mov2mov标签页，然后直接将视频拖入mov2mov视图，Width和Height设置为和视频一样的分辨率，Generate Movie Mode选择自己想要的视频输出格式，Noise multiplier设置成0，Movie Frames可以按自己喜好设置，也可以按原视频的帧率设置，Max Frames默认-1就好了，然后ControlNet和批量图生图配置的一样，使用和对应的模型，然后就可以生成了。</p><p>mov2mov插件原理和批量图生图是一样的，只是插件为我们做了将视频导出为序列帧，将序列帧制作成视频这两步，虽然方便了不少，但同时也蒙版精确控制的能力。</p><p>效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Mov2Mov%E8%A7%86%E9%A2%91.gif"></p><p>这也是使用mov2mov生成两遍的效果，效果上感觉不如使用了蒙版控制的批量图生图的方式。</p><h3 id="更稳定的视频输出"><a href="#更稳定的视频输出" class="headerlink" title="更稳定的视频输出"></a>更稳定的视频输出</h3><p>前面的视频制作都会出现跳动的问题，在开始撰写第九章时，一项新的AI视频制作技术出来了，已经可以很好的解决视频跳帧的问题了，不得不说AI的技术进步真是肉眼可见。</p><p>这个方法需要三个插件一个脚本，分别是：</p><p><strong>ControlNet插件</strong>：<a href="https://github.com/Mikubill/sd-webui-controlnet">Mikubill/sd-webui-controlnet: WebUI extension for ControlNet</a>；</p><p><strong>Ebsynth Utility插件</strong>：<a href="https://github.com/s9roll7/ebsynth_utility">s9roll7/ebsynth_utility: AUTOMATIC1111 UI extension for creating videos using img2img and ebsynth</a>；</p><p><strong>WD14-tagger插件</strong>：<a href="https://github.com/toriato/stable-diffusion-webui-wd14-tagger">toriato/stable-diffusion-webui-wd14-tagger：Automatic1111 的 Web UI 的标签扩展 </a>；</p><p><strong>multi_frame_rendering脚本</strong>：<a href="https://github.com/OedoSoldier/enhanced-img2img/tree/main/scripts">enhanced-img2img/scripts at main · OedoSoldier/enhanced-img2img </a>。</p><p>这个脚本可也一使用<a href="https://space.bilibili.com/55123">大江户战士</a>U修改过的脚本：<a href="https://pan.baidu.com/s/1jhameZlsQF5qeWPySc90Zw?pwd=tggh">multi_frame_render.py</a>；</p><p>B站教程地址：<a href="https://www.bilibili.com/video/BV1R54y1M7u5/?spm_id_from=333.999.0.0&vd_source=e979466844c4915a4200c496efb35cfb">【AI动画】多帧渲染法 介绍及使用</a>。</p><p>Ebsynth Utility插件用于提取视频中的关键帧，除此之外这个插件还可以批量为关键帧生成蒙版图片，可以自动提取变化较大的关键帧节点。</p><p>WD14-tagger插件用于批量从关键帧图片中提取提示词，并批量生成对应的提示词文本。</p><p>multi_frame_rendering脚本使用多帧渲染技术就是使AI生成的视频稳定的关键技术，玩AI绘图一段时间后都会发现一个现象就是在同一批次生成的图片中，人物的脸大都是一样的，multi_frame_rendering就是运用了这个原理，在出图时使用三张图并接的方式出图，并且后一张图的出图时会参考前一张图，配合Multi-ControlNet的精确控制，这样就可以使AI出的图趋于稳定。</p><p>但也真是因为进行诸多环节对AI出图的画面进行控制，导致了AI绘制视频帧的速度大大减缓，我生成一批(164帧)的序列帧，使用RTX3080TI-12G绘制也足足需要花费近3个小时，视频时长总共才5秒钟。</p><p>下面使操作步骤：</p><p><strong>安装ControlNet</strong></p><p>首先我们需要安装插件和脚本，ControlNet插件前面已经有提过，就略过了。</p><p><strong>安装Ebsynth Utility</strong></p><p>Ebsynth Utility插件依赖一个视频处理库ffmpeg，这是官网地址：<a href="https://ffmpeg.org/">FFmpeg</a>。</p><p>我们需要下载windows版本，下载下来的库就是一个已经编译好了的库文件夹，库里面主要的文件夹有bin、include和lib，include和lib主要是给编程开发用的，这里插件主要是使用bin文件夹，把bin文件夹添加到系统环境变量中，库就安装好了，然后可以通过cmd键入<code>ffmpeg -version</code>来查看库是否安装完毕：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-03-13_17-36-20.png"></p><p>然后使用git把Ebsynth Utility库克隆到webui的插件目录，Ebsynth Utility插件就安装好了。</p><p><strong>批量提取视频帧</strong></p><p>Ebsynth Utility插件的功能有很多(各个选项的作用，作者已经在ui上注明)，我们这里主要使用的是它的stage 1。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-03-13_17-40-22.png"></p><p>选择stage 1，Project directory输入存放序列帧的目录，Original Movie Path输入视频路径，也可以将视频拖到下方的输入框，拖视频到输入框插件会拷贝一份视频到<code>C:\Users\[用户名]\AppData\Local\Temp</code>系统临时文件夹中。stage 1的configuration的设置是在需要同时提取关键帧的蒙版图片时才需要配置，如果不需要提取蒙版图片的话，直接默认就好了。</p><p>有一点需要注意，Ebsynth Utility插件没有权限向webui的outputs目录输入文件，所以我们设置的输入输出文件夹不能放到webui的outputs目录下。</p><p><strong>安装WD14-tagger</strong></p><p>使用git把WD14-tagger库克隆到webui的插件目录，WD14-tagger插件就安装好了，我更新到最新的2023.3.13的webui发现，安装好插件直接从扩展选项卡重启界面后webui有时并不能识别到新安装的插件，不知道是不是bug，最好直接重启服务器。</p><p><strong>批量生成序列帧提示词</strong></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/QQ%E6%88%AA%E5%9B%BE20230313175718.png"></p><p>这里我们主要使用批量操作，输入目录输入我们生成的序列帧所在的目录，输出目录可以不填，不填默认将识别到提示词文本存储到输入目录。勾选<code>使用空格代替下划线</code>、<code>转移括号</code>和<code>完成后从显存卸载模型</code>，不卸载模型，模型会一只占用部分显存。</p><p>在使用的过程中发现插件有一个bug，即使用批量操作时，单张图片下不能放入图片，否则批量操作不会执行，而只执行单张图片的提示词识别。</p><p>其实这一步也可以通过图生图的提示词反推功能代替。</p><p><strong>安装multi_frame_rendering</strong></p><p>将multi_frame_rendering脚本下载到webui的script目录，multi_frame_rendering脚本是依赖于ControlNet的，所以我们需要在webui的设置中勾选ControlNet下的允许其他脚本对此扩展插件进行控制。</p><p>multi_frame_rendering脚本只适用于图生图界面，所以我们只能在图生图界面中找到这个脚本。</p><p><strong>使用ControlNet进行图像控制</strong></p><p>这里我们使用两层控制网络(如何启用多重ControlNet可以查看第五章第一节Multi-ControlNet)，第一层使用hed边缘检测进行控制，第二层使用发现贴图进行控制，参数可以根据自己的实际需求进行调整。</p><p><strong>使用图生图确定要绘制的风格</strong></p><p>我们可以使用提示词、Lora等风格化模型控制AI对视频的人物，画风等进行定制，对于人物需要专门的人物Lora才能有比较好的效果。这样AI就可以根据提示词和Lora绘制出我们想要的人物和画风的序列帧。</p><p>确定好输出序列的分辨率，步数，采样算法，基础模型后就可以锁定随机种子，进行最后的多帧渲染了。</p><p>因为我们使用了多层控制手段来控制AI出图，所以重绘幅度我们可以调高一点。</p><p><strong>多帧渲染</strong></p><p>启用multi_frame_rendering脚本，输入目录选择Ebsynth Utility插件的序列帧输出目录，输出目录自行设定，Third column(refernce) imge有三个选项FirstGen-使用处理后的第一帧作为参考图，OriginalImg-使用原始的第一帧作为参考图，Historical-使用当前帧之前的倒数第二帧作为参考图，这里我选择使用FirstGen，Loopback source也有三个选项，Previous-从上一帧生成帧，Current-从当前帧生成帧，First-从第一帧生成帧，我这里选择Current，然后勾选Read tags from text files，勾选后脚本会自动从同名的提示词文本中提取提示词来控制图片的生图。</p><p>其实multi_frame_rendering脚本自己也提供了每帧提取提示词并应用的功能，在Append interrogated prompt at each iteration中选择webui内置的文本编码器，脚本就可在渲染时使用对应的编码器提取输入图片的提示词，但这样会增加渲染的时间，所以我们使用WD14-tagger插件来提前将提示词提取出来。</p><p>等待漫长的渲染过程之后，将序列帧转成视频，就可以看到效果了：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/MultiFrameRender.gif"></p><p>效果是相当不错的，只是我在出图的时候忘记添加脸部的描述，AI把脸给画崩了，再画生成一次又要花4个小时，就将就着用着了。</p><p>最近在更新了Controlnet1.1.217之后，发现图生图模式下使用多帧渲染已经不行了，12G的显存不够了，新版本的Controtnet模型更大更加吃显存，所以如果想要多帧渲染视频请确保controlnet版本在1.0之前，并且尽量使用裁剪之后的小模型。</p><h3 id="生成奇特的缩放视频"><a href="#生成奇特的缩放视频" class="headerlink" title="生成奇特的缩放视频"></a>生成奇特的缩放视频</h3><p>先来看一下效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/%E5%8A%A8%E7%94%BB.gif"></p><p>要制作这样的一个视频依赖于<a href="https://github.com/Extraltodeus/infinite-zoom-stable-diffusion">Infinite Zoom</a>插件，安装好插件就可以在标签栏看到Infinite Zoom标签。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-05-17_09-32-49.png"></p><p>整个界面有四个标签页，main，video，outpaint和post proccess。</p><p><strong>Main</strong>标签页是我们主要的操作页面：</p><ul><li><p>Batch Count：要生成的视频批次，一次可以渲染多批视频；</p></li><li><p>Total vido length：生成视频的时长，默认为5秒；</p></li><li><p>Common Prompt Prefix：通用的图像生成前缀，可以放一些对组成视频的所有图片都需要的一些需要放在前面关键词，如一些对画面整体质量、风格的描述；</p></li><li><p>表格：中间的表格就是对每个画面的内容的关键词描述了，</p><p>Start at second：对应画面图像要出现的时刻；</p><p>Prompt(提示词)：画面要表现的内容提示词；</p><p>Clear prompts：清空所有提示词；</p><p>Import prompts：快速导入提示词；</p><p>Export prompts：导出提示词，导出的提示词会以json文件的形式存储；</p><p>New row：新增行；</p></li><li><p>Common Prompt Suffix：所有画面通用的提示词后缀，可以放一些对所有生成图像的氛围描述，如：时间段、光影效果、渲染模式等；</p></li><li><p>Negative Prompt：通用的反向描述词；</p></li><li><p>seed(随机种子)：生成图片时所使用的噪点种子；</p></li><li><p>Sampler(采样方法)：生成图片时所使用的采样方法；</p></li><li><p>Output Width/Output Height：输出图片的长宽；</p></li><li><p>Guidance Scale：提示词相关性；</p></li><li><p>Sampling Steps for each outpaint：每张图片的采样步数；</p></li><li><p>Custom initail image：初始图片，图片可以先在文生图中生成，在zoom-out(缩小)模式下初始图片将作为第一帧的图片，在zoom-in(放大)模式下初始图片将作为最后一帧的图片。</p></li></ul><p><strong>Video</strong>标签页主要是对整个视频的操作设置：<br><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-05-17_10-09-53.png"></p><ul><li>每秒多少帧：设置视频帧数；</li><li>Zoom mode：缩放模式，zoom-out：缩小，zoom-in：放大；</li><li>number of start frame dupe：视频开始时要冻结的帧数；</li><li>number of last frame dupe：视频结束时要冻结的帧数；</li><li>Zoom Speed：缩放速度，单位为秒；</li></ul><p><strong>Outpaint</strong>标签页设置图像的重绘：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-05-17_10-10-12.png"></p><p>内容很少，一般页不用修改。</p><p><strong>Post proccess</strong>标签页设置图像的放大：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-05-17_10-10-20.png"></p><p>这个方法也没啥好说的了，设置都非常直观。</p><p>所有设置都设置好之后，就可以点击Generate video按钮开始生成视频了，生成视频的时间比较长，我4070ti的配置生成一个9秒的视频大概在700秒左右。</p><p>生成的视频可以在右侧预览，和下载，在output/infinite-zoom文件夹下也存有所有的生成的视频。</p><h2 id="4-OutPainting"><a href="#4-OutPainting" class="headerlink" title="4.OutPainting"></a>4.OutPainting</h2><p>outpainting是官方提供的一项AI图像扩展技术，AI可以根据已有的图像来扩展图像之外的画面。</p><p>outpainting需要配合官方提供的inpainting模型使用才能够对图像进行补全，inpainting模型有两个版本，1.5和2.0下载地址分别是：</p><p>sd-v1-5-inpainting：<a href="https://huggingface.co/runwayml/stable-diffusion-inpainting">runwayml/stable-diffusion-inpainting · Hugging Face</a>；</p><p>512-inpainting-ema：<a href="https://huggingface.co/stabilityai/stable-diffusion-2-inpainting">stabilityai/stable-diffusion-2-inpainting · Hugging Face</a>。</p><p>下载好模型之后放入models/Sable-diffusion文件夹中。</p><p>修改webui-user.bat文件，在<code>set COMMANDLINE_ARGS=</code>之后添加<code>--api --cors-allow-origins=https://www.painthua.com</code>参数。</p><p>然后启动webui，进入<a href="https://www.painthua.com网址,网址连的我们本地的stable/">https://www.painthua.com网址，网址连的我们本地的stable</a> diffusionu服务，在网页的Config选项中设置服务器的地址，画布的大小以及选区的最小尺寸，一般我们没有修改过服务器地址和端口的话，默认是127.0.0.1:7860就不需要修改了。</p><p>用法就比较简单了，在Prompt选项我们可以设置正方向提示词，要使用的模型、采样算法、采样步数等，原理和文生图是一样的，然后通过绘制选区来生成指定分辨率的图片，也可以使用Ctr+O上传本地图片来扩展。</p><p>当一个张图片生成好之后，我们就需要切换模型到inpainting模型，然后绘制任意大小的选区进行图片扩展，选区要和图片有重合，一边AI学习原图的风格。</p><p>如：我们可以将这样一张图：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-03-13_11-21-00.png"></p><p>扩展成这样一张图：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-03-13_11-22-50.png"></p><p>其他的功能也很简单，玩个一两分钟基本就会了，在Help选项作者也提供了视频教程。</p><h2 id="5-人物换装"><a href="#5-人物换装" class="headerlink" title="5.人物换装"></a>5.人物换装</h2><p>人物换装说来也比较简单，主要就是运用图生图的局部重绘功能搭配指定服装的提示词来达到换装的效果。</p><p>首先使用文生图出一张示例图：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-04-03_12-18-25.png"></p><p>然后使用图生图的局部重绘，将我们想要换装的区域涂上蒙版。</p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-04-03_14-40-06.png" style="zoom:50%;"><p>然后就改服装的提示词，就可以做到这样的效果，提示词可以直接使用Prompts from file or textbox脚本批量控制，也可以使用<a href="https://github.com/adieyal/sd-dynamic-prompts">动态提示词插件</a>，这个插件bug还挺多，还要安装一堆依赖，我个人还是更倾向于使用内置的脚本，插件教程可以看这个视频：<a href="https://www.bilibili.com/video/BV1kT411z7wR/?spm_id_from=333.999.0.0&vd_source=e979466844c4915a4200c496efb35cfb">Stable Diffusion 自定义提示词组 一键生成分类图像 万用提示词</a>。然后就可以抽卡出图了：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-04-03_14-39-10.png"></p><h2 id="6-基于SadTalker的唇型同步"><a href="#6-基于SadTalker的唇型同步" class="headerlink" title="6.基于SadTalker的唇型同步"></a>6.基于SadTalker的唇型同步</h2><p>SadTalker开源库地址：<a href="https://github.com/OpenTalker/SadTalker">https://github.com/OpenTalker/SadTalker</a></p><p>SadTalker有独立的运行版本，也有Stanble Diffusion Webui的插件，由于SadTalker自身就要吃到5个多G的显存，使用Stable Diffusion Webui插件的话，多显存的要求极高，所以我这里主要使用的是独立运行版本。</p><h3 id="SadTalker运行环境部署"><a href="#SadTalker运行环境部署" class="headerlink" title="SadTalker运行环境部署"></a>SadTalker运行环境部署</h3><p>SadTalker的运行基于Python3.10.6和Stable Deffusion WebUI的依赖版本一致，如果已经安装了SD就可以跳过这一步了。</p><p>安装<code>ffmpeg</code>，这是一个专门用于处理视频的库，我们可以直接使用</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> ffmpeg<br></code></pre></td></tr></table></figure><p>来安装，也可以直接到</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.gyan.dev<span class="hljs-regexp">/ffmpeg/</span>builds/ffmpeg-git-full.<span class="hljs-number">7</span>z<br></code></pre></td></tr></table></figure><p>地址手动安装，我个人建议直接手动下载，解压到SadTalker的根目录中，然后到Path中配置</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">E</span>:\SadTalker\ffmpeg-<span class="hljs-number">2023</span>-<span class="hljs-number">05</span>-<span class="hljs-number">08</span>-git-<span class="hljs-number">2</span>d<span class="hljs-number">43</span>c<span class="hljs-number">23</span>b<span class="hljs-number">81</span>-full_build\bin<br></code></pre></td></tr></table></figure><p>路径到环境变量。</p><h3 id="下载预训练模型"><a href="#下载预训练模型" class="headerlink" title="下载预训练模型"></a>下载预训练模型</h3><p>SadTalker的运行需要用到10个预训练模型，可以到</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/OpenTalker/</span>SadTalker/releases<br></code></pre></td></tr></table></figure><p>地址单独手动下载，官方也提供了百度云地址：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>pan.baidu.com<span class="hljs-regexp">/s/</span><span class="hljs-number">1</span>nXuVNd0exUl37ISwWqbFGA?pwd=sadt<br></code></pre></td></tr></table></figure><p>如果是单独手动下载，则在SadTalker的根目录创建一个<code>checkpoints</code>目录，并将所有文件拷贝到这个目录中，如果是百度云下载，则解压后将目录中的checkpoints目录拷贝到SadTalker根目录，然后解压checkpoints目录中的<code>BFM_Fitting.zip</code>和<code>hub.zip</code>两个压缩到checkpoints目录，解压的时候需要注意一下解压目录，有的解压文件会以文件命创建一个目录，此时可能会出现两个BFM_Fitting或hub目录。</p><h3 id="安装虚拟环境"><a href="#安装虚拟环境" class="headerlink" title="安装虚拟环境"></a>安装虚拟环境</h3><p>前置安装完成之后，就可以双击根目录中的webui.bat运行SadTalker，程序会自行下载所需运行库并生成虚拟环境。</p><p>下载运行库的时候经常会出现连接不上库地址而导致超时错误却不提示是哪个库连不上，这就没有其他办法解决了，只能挂上梯子多试几次了，我大概也是试了五六次才成功把虚拟环境创建好。</p><h3 id="生成唇型动画"><a href="#生成唇型动画" class="headerlink" title="生成唇型动画"></a>生成唇型动画</h3><p>虚拟环境创建好之后，就可以通过webui.bat启动服务，服务器会给出一个本地地址<code>http://127.0.0.1:7860</code>，浏览器打开地址即可进入SadTalker的UI界面，UI界面非常简洁，就两个输入，三个设置，一个输出。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-05-15_10-52-47.png"></p><ul><li><p>Upload image：上传要用于生成动画的图片，建议点击文件夹上传，直接拖过去，程序会将图片先拷贝到c盘临时目录再使用。</p></li><li><p>Upload OR TTS：上传要用于生成动画的语音，建议点击文件夹上传，直接拖过去，程序会将图片先拷贝到c盘临时目录再使用。文字转语音推荐使用这个网址：<a href="https://www.text-to-speech.cn/">Text To Speech - 在线文本转语音 (text-to-speech.cn)</a>，个人用着刚觉效果非常不错，主要是免费无广告。</p></li><li><p>Seetings：</p><p>crop：将图片裁剪成256x256再生成动画；</p><p>resize：</p><p>full：保留原图尺寸生成动画，同时也会生成裁剪成256x256的动画。</p></li><li><p>Still Mode(fewer hand motion,works with preprocess ‘full’)：静滞模型，生成动画时程序会尽量减少对手部的影响，适合再full下使用；</p></li><li><p>GFPGAN as Face enhancer：使用面部增强修复，使用这个选项程序会再去下载一个模型。</p></li></ul><p>生成的动画可以直接在网页端下载到本地，也可以直接到程序根目录的<code>results</code>目录中提取。</p><p>来看一下效果，我这里直接使用官方提供的音频：</p><p><img src="/2023/06/03/%E3%80%90AI%E3%80%91Stable-Diffusion-WebUI%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/../../../OneDrive/Pics/NovelAI/%E5%8A%A8%E7%94%BB2.gif"></p><p>picgo不能上传视频，这里成了gif，没有了声音。</p><h2 id="7-ControlNet-1-1"><a href="#7-ControlNet-1-1" class="headerlink" title="7.ControlNet 1.1"></a>7.ControlNet 1.1</h2><p>文章还没写完，插件又更新了…..</p><p>ControlNet1.1算是ControlNet得一个很大的版本更新，插件变得更强了，也变得更大了，</p><p>ControlNet1.1新增了很多很多的新算法和新模型，新算法与模型的对应关系这里直接从<a href="https://www.bilibili.com/video/BV1uo4y1c78k/?spm_id_from=333.999.0.0&vd_source=e979466844c4915a4200c496efb35cfb">Controlnet 1.1新版本功能详解，14个控制模型+30个预处理器讲解，Stable diffusion AI绘图教程｜Preprocessor使用教程_哔哩哔哩_bilibili</a>这个up的视频中借过来用了：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-05-18_17-41-51.png"></p><h3 id="ControlNet1-1的更新"><a href="#ControlNet1-1的更新" class="headerlink" title="ControlNet1.1的更新"></a>ControlNet1.1的更新</h3><p>更新方式比较简单，直接使用WebUI更新、使用git手动pull或者重新安装插件即可。</p><h3 id="下载新的模型"><a href="#下载新的模型" class="headerlink" title="下载新的模型"></a>下载新的模型</h3><p>ControlNet1.1之后所有的模型都被官方更新了，所以我们需要重新下载模型，模型下载官方网址：<a href="https://huggingface.co/lllyasviel/ControlNet-v1-1/tree/main">lllyasviel/ControlNet-v1-1 at main (huggingface.co)</a>，总共有11个模型，每个模型1.45GB是真的大，然后官方也推出了模型的命名规则：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-05-24_11-01-10.png"></p><p>新版本的模型都搭配一个<code>.yaml</code>配置文件使用，所以下载时需要将模型文件和配置文件一并下载，一并放置到<code>extensions\sd-webui-controlnet\models</code>目录下。</p><p>除此之外再使用的过程中有些第一次使用的算法还需搭配一个额外的模型使用，这个模型会在使用时自动下载，下载后会存放在<code>extensions\sd-webui-controlnet\annotator\downloads</code>目录的对应算法目录下。</p><h3 id="新算法的使用"><a href="#新算法的使用" class="headerlink" title="新算法的使用"></a>新算法的使用</h3><p>新算法多大39种，这里就只调几个功能比较强大，用得比较多的算法来说说了。</p><ul><li><p>depth_leres++：depth_leres++是一个更精确的深度图，这个算法能保留更多的深度细节，可以看一下和之前的深度算法的对比：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-05-24_16-57-18.png"></p><p>可以看到depth_leres++能保留的细节信息更多。</p></li><li><p>inpaint_global_harmonious：inpaint是一个重绘预处理器，需要配合control_v11p_sd15_inpaint模型使用，可以对蒙版区域进行重绘，局部重绘一直是图生图的专属功能，但是图生图无法进行大分辨率绘图，导致很多时候重绘功能很鸡肋，重绘出来的画面细节不够，使用inpaint_global_harmonious就可以在文生图中进行重绘了，并且配合文生图的高清修复，可以直接重绘高分辨率的大图，比如我们将下图的阶梯换成平路：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-05-25_15-19-37.png"></p><p>除此之外，我们通过手动扩充原图尺寸，也可以使用inpaint模型进行图像扩展，功能类似Outpainting，不同的是我们需要将需要重绘的区域涂成黑色，如我们将一个512x1024的图扩展为1024x1024的图：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-05-25_14-39-11.png"></p></li><li><p>lineart_anime：lineart算法是Controlnet推出的专门用于线稿上色的描边算法，lineart_anime算法则是lineart算法家族种更适合于二次元的上色算法，lineart算法除了会进行描边之外，还会基于绘画的手法使用线条对阴影进行绘制，使得线稿更加精致；</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Lineart_anime.png"></p></li><li><p>lineart_realistic：lineart_realistic算法和lineart_anime算法相对，是专门针对真实照片进行描边的算法，lineart_realistic算法对真实照片的描边能绘制更多的细节；</p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Lineart_realisitc.png" style="zoom:50%;"></li><li><p>openpose_full：openpose_full是整合了姿势、手势和表情的算法，可以生成同时控制姿势、手势和表情的控制图，第一次使用时会下载多个模型。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/openpose_full.png"></p></li><li><p>reference_only：reference_only预处理器有点类似腾讯的style预处理器，可以使AI参照指定图片的风格来生成图片，如：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-05-25_15-56-12.png"></p><p>配合inpaint_global_harmonious预处理器，可以使AI根据指定图片的风格对原图进行重绘或扩展，如：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-05-25_16-11-02.png"></p></li><li><p>tile_resample：tile模型算是这次controlnet的重磅更新了，功能十分强大，tile_resample预处理器配和control_v11f1e_sd15_tile模型使用，主要的作用有生成类似的图、为简笔画补充细节纹理、将小图进行高清重绘和用于配合图生图脚本SD upscale图片进行超清重绘。</p><p><strong>生成类似的图</strong>：这个功能在通过photoshopP图之后，使用AI来融合P图中的看起来比较违和的元素时非常有用，有了这个功能我们就可以快速的使用PS往图中加入我们想要的元素，然后使用AI来融合，当然出图的效果还是取决于大模型；</p><p><strong>为简笔画补充细节纹理</strong>：先直接看图</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-05-24_17-51-38.png"></p><p>tile模型甚至为我们修复了简笔画中不合理的结构。</p><p><strong>小图高清重绘</strong>：基于tile模型自动补充细节的能力，可以通过输入一张很模糊的小图，使用tile模型在文生图配合高清修复功能进行高清重绘，如：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-05-25_11-51-32.png"></p><p><strong>超清放大</strong>：图生图有一个SD upsacle脚本可以将输入的图片进行分块放大，但是脚本只会根据使用方法算法补充像素，最终形成色块，配合tile模型使用则可以达到放大的同时西东补充一些合理的细节，从而避免形成色块。</p><p>使用方法就是将要放大的图拖入图生图，然后启动controlnet并使用tile预处理器和tile模型，特别注意controlnet不需要再放入图片，然后重回幅度调到0.2以下，当然如果想要变化大一点也可以调高，然后脚本选择SD Upscale，即可进行超清放大。</p></li><li><p>ip2p：ip2p即control_v11e_sd15_1p2p模型，这是个模型不是算法，这个模型没有对应的算法，使用时预处理器选择none，这个模型可以通过指令修改对图片进行调节，比如左边的原图使用ip2p使用<code>It turns into winter</code>（变成冬天）的指令，生成了右边这样的图：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-05-24_17-23-56.png"></p><p>不过，模型只能生成一些简单的效果，对于比较复杂的修改效果很差，并且生成图的效果非常依赖大模型的出图效果。</p></li></ul><h2 id="8-基于Regional-Prompter的分区域绘制"><a href="#8-基于Regional-Prompter的分区域绘制" class="headerlink" title="8.基于Regional Prompter的分区域绘制"></a>8.基于Regional Prompter的分区域绘制</h2><p>Stable Diffusion WebUI有好几款分区域绘制的插件，其中个人觉得比较好用的就是<a href="https://github.com/hako-mikan/sd-webui-regional-prompte">Regional Prompter</a>插件。</p><p>安装好插件后，会和controlnet一样在文生图和图生图下方出现一个下来选项，展开就是Rgional Prompter插件的设置选项了：</p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/QQ%E6%88%AA%E5%9B%BE20230530172147.png"><p>设置项很多，这里就不单独展开了，在后面讲应用的时候再顺带讲了。</p><h3 id="Regional-Prompter的分割语法"><a href="#Regional-Prompter的分割语法" class="headerlink" title="Regional Prompter的分割语法"></a>Regional Prompter的分割语法</h3><p>Regional Prompter插件支持一维分割和二维分割，插件使用<code>，</code>(英文逗号)进行一维分割，使用<code>，</code>和<code>;</code>(英文逗号和英文分号)进行二维分割。</p><p><strong>一维分割</strong>在水平分割模型下会将画面分割成一根根的柱状：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-05-31_14-52-51.png"></p><p>在垂直分割下会将画面分割成一条条的条状，同时插件也支持使用小数的形式进行画面分割，如1:1:2的分割比例也可以写成<code>0.25,0.25,0.5</code>只要小数之合等于1即可：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-05-31_14-53-25.png"></p><p><strong>二维分割</strong>是先使用<code>;</code>进行垂直模式分割，然后再在条状分割画面的基础上使用<code>,</code>进行水平模式分割，如这样的一个分割语法<code>1,1,1;3,2,1,2</code>分割效果为:</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-05-31_14-57-40.png"></p><p>整个语法可以理解为，先使用<code>;</code>进行垂直模式分割，语法为：<code>1;3</code>，画面将被分割成上下比例为1:3的两部分，然后再在1对应的区域使用<code>,</code>水平分割成对半的两部分，语法为：<code>1,1,1;3</code>，再然后在3对应的区域使用<code>,</code>水平分割成2:1:2的三部分，最终语法为：<code>1,1,1;3,2,1,2</code>。</p><p>需要注意的是二维分割由于是使用<code>;</code>来表示垂直分割的，所以在垂直模型下使用二维分割会识别不到<code>;</code>，所以上面的分割语法<code>1,1,1;3,2,1,2</code>在垂直模型下只能识别成<code>1,1,1,2,1,2</code>，于是分割就变成了这样：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-05-31_15-03-28.png"></p><h3 id="Regional-Prompter的分割词原理"><a href="#Regional-Prompter的分割词原理" class="headerlink" title="Regional Prompter的分割词原理"></a>Regional Prompter的分割词原理</h3><p>Regional Prompter插件将整段提示词分类为Common prompt、Base prompt和Region prompt三类，其中Common prompt和Base prompt是可选的类型，Region prompt则是必须类型，一般Common prompt指的是描述画面质量、渲染方式、光影等提示词，Base prompt指的是不涉及分区域绘制的画面中的其他特征的提示词，如我们上面的例子画一个女孩，那么Base prompt就可以是1girl、姿势、年龄、场景、表情等提示词，Region prompt则是用于分区域绘制的提示词了。</p><ul><li>ADDROW：垂直分割时使用的分割词，垂直分割把画面分割成一行一行条状，每一个分割线对应一个ADDROW分割词，只能在正向提示词中使用；</li><li>ADDCOL：水平分割时使用的分割词，水平分割把画面分割成一列一列的柱状，每一个分割线对应一个ADDCOL分割词，只能在正向提示词中使用；</li><li>ADDCOMM：用于分割Common prompt类型提示词的分割词，需要勾选Use common prompt选项才能生效；ADDCOMM也可以用于反向提示词，用于分割反向提示词中的Common prompt类型的提示词，一般配合BREAK分割词使用，需要在反向提示词中使用ADDCOMM需要勾选Use common negative prompt选项才能生效；</li><li>ADDBASE：用于分割Base prompt类型提示词的分割词，需要勾选Use base prompt选项才能生效，只能在正向提示词中使用；</li><li>BREAK：用于分区域绘制时为不同区域的Region prompt提示词指定反向提示词的分割词，和Region prompt的分割词一一对应，只能在反向提示词中使用；</li></ul><p>各区域的提示词与分割词之间可以使用<code>,</code>也可以不使用，可以换行也可以不换，如</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">masterpiece,the <span class="hljs-keyword">best </span>quality super fine illustrations,high detail <span class="hljs-keyword">ADDCOMM </span><span class="hljs-number">1</span>girl,solo,((Standing)),pov,looking <span class="hljs-built_in">at</span> viewer,Audience <span class="hljs-keyword">oriented,full </span><span class="hljs-keyword">body </span><span class="hljs-keyword">ADDBASE </span><span class="hljs-keyword">short </span>red hair <span class="hljs-keyword">ADDROW </span>((yello wshort sleeves)) <span class="hljs-keyword">ADDROW </span>green Pleated Skirt <span class="hljs-keyword">ADDROW </span><span class="hljs-keyword">black </span>pantyhose  <span class="hljs-keyword">ADDROW </span>pink sports <span class="hljs-keyword">shoes,</span><br></code></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">masterpiece,the <span class="hljs-keyword">best </span>quality super fine illustrations,high detail,<span class="hljs-keyword">ADDCOMM,</span><br><span class="hljs-keyword">1girl,solo,((Standing)),pov,looking </span><span class="hljs-built_in">at</span> viewer,Audience <span class="hljs-keyword">oriented,full </span><span class="hljs-keyword">body,ADDBASE,</span><br><span class="hljs-keyword">short </span>red hair,<span class="hljs-keyword">ADDROW,</span><br><span class="hljs-keyword">((yellow </span><span class="hljs-keyword">short </span>sleeves)),<span class="hljs-keyword">ADDROW,</span><br><span class="hljs-keyword">green </span>Pleated Skirt,<span class="hljs-keyword">ADDROW,</span><br><span class="hljs-keyword">black </span>pantyhose,<span class="hljs-keyword">ADDROW,</span><br><span class="hljs-keyword">pink </span>sports <span class="hljs-keyword">shoes,</span><br></code></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">masterpiece,the <span class="hljs-keyword">best </span>quality super fine illustrations,high detail <span class="hljs-keyword">ADDCOMM</span><br><span class="hljs-keyword">1girl,solo,((Standing)),pov,looking </span><span class="hljs-built_in">at</span> viewer,Audience <span class="hljs-keyword">oriented,full </span><span class="hljs-keyword">body </span><span class="hljs-keyword">ADDBASE</span><br><span class="hljs-keyword">short </span>red hair <span class="hljs-keyword">ADDROW</span><br><span class="hljs-keyword">((yellow </span><span class="hljs-keyword">short </span>sleeves)) <span class="hljs-keyword">ADDROW</span><br><span class="hljs-keyword">green </span>Pleated Skirt <span class="hljs-keyword">ADDROW </span><br><span class="hljs-keyword">black </span>pantyhose <span class="hljs-keyword">ADDROW</span><br><span class="hljs-keyword">pink </span>sports <span class="hljs-keyword">shoes,</span><br></code></pre></td></tr></table></figure><p>这三种形式最终控制效果都是一样的，不过插件有一个问题，就是插件为了在规定区域绘制指定的物体，可能会改变画面的一些特征导致有些特征和提示词的描述不一致，如我上面的提示词描述的是一个站着的女孩，但是插件为了保证指定区域出现指定颜色的物体，可能会改变绘制角色的姿势，同时尽管我们使用了分区域绘制也无法100%的保证每个区域都能按照我们的预想来绘制，如我上面的提示词偶尔会出现黄色短袖绘制成白色短袖，所以我为黄色短袖增加了权重，才能保证出来的图都是穿黄色短袖的女孩，这些都需要我们在实际调控中根据需求调整。</p><h3 id="分区域颜色控制"><a href="#分区域颜色控制" class="headerlink" title="分区域颜色控制"></a>分区域颜色控制</h3><p>很多时候我们在画一个画面颜色比较多的图时，只通过提示词来描述物体颜色通常情况都会出现颜色污染，如我们要画一个这样的女孩：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-05-30_17-36-18.png"></p><p>然后我们的出来的结果是这样的：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-05-30_17-35-36.png"></p><p>可以看到颜色基本上很难和提示词对应上，尤其是黄色的短袖和绿色的百褶裙很难画出来，颜色污染非常严重，然后我们用Rgional Prompter插件进行分区控制一下。</p><p>首先勾选启用(active)启动插件，由于我们画人竖版的，所以分割模式(Divide Mode)选择垂直(Vertical)，然后分割比例(Divide Ratio)按照我们想要的颜色区域分布设定，我这里设定为<code>1,1,1,2,1</code>，这样整个画面就被垂直分割成了1:1:1:2:1的五个部分，除了使用比例式外，插件也支持小数形式，如<code>1,1,1,2,1</code>也可以写成<code>0.2,0.2,0.2,0.4,0.2</code>，然后点击<code>visulize and make template</code>按钮可以生成分割预览，并提供了对应数量的分割词；</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-05-30_18-22-24.png"></p><p>然后在提示词中加入分割词，将不同类型的提示词按区域分割开来。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-05-30_18-28-33.png"></p><p>然后可以看一下控制效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-05-31_10-10-21.png"></p><p>可以看到基本上颜色分布已经正常了。</p><h3 id="分区域多人绘制"><a href="#分区域多人绘制" class="headerlink" title="分区域多人绘制"></a>分区域多人绘制</h3><p>多人绘制一直是AI绘图的弱点，包括C站上绝大部分模型对多人绘制支持的都不是很好，所以尽管使用Regional prompter进行控制，出图效果也极大程度的受到大模型的影响，出图效果十分不稳定。</p><p>这里的测试，我们对图像进行左右的对半分割，左边画一个健美男，右边画一个舞女，进行如下控制：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-05-31_12-20-12.png"></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-05-31_12-20-24.png"></p><p>然后出图效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-05-31_14-35-35.png"></p><p>在我自己的测试中发现<a href="https://civitai.com/models/7371">revAnimated-1.2.2</a>这个大模型对多人绘制效果还可以。</p><h3 id="分区域画面绘制"><a href="#分区域画面绘制" class="headerlink" title="分区域画面绘制"></a>分区域画面绘制</h3><p>这里以上面的<code>1,1,1;3,2,1,2</code>的分割比例为例。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-05-31_16-22-58.png"></p><p>这里我使用了基础比率(Base Ratio)，这个设置可以控制Base prompt和Region prompt之间的控制权重，第一个权重是Base prompt的权重，后面跟着的权重是Region prompt的权重，数量和分割的区域对应。默认值是0.2，表示Base prompt权重为0.2，Region prompt整体权重为0.8</p><p>左上角绘制一个红色的月亮，右上角绘制密布的乌云，左下角绘制一个钟楼教堂，中间绘制一辆红色的汽车，右下角绘制一个白衣女孩。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-05-31_16-20-23.png"></p><p>出图效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-05-31_16-17-52.png"></p><p>尽管对于元素比较多的画面部分特征会被AI忽略，但总体上各个特征绘制的位置还算控制到位。</p><p>除此之外，插件还支持使用蒙版来进行区域分割控制，不过使用起来还挺复杂，并且还只支持HSV的颜色格式，另一个个人感觉功能比较强的是分割模式中的提示词，可以根据提示词来确定分割区域，不过我使用的2023.5.22 commit为673801c3ef9f50fa29406400a4d9c4b5464d73b2版本的插件在stable diffusion webui 1.3.0版本中使用这个模式完全不起作用，估计是插件还没有兼容1.3.0的webui吧，所以这两个功能也不过多累述了，具体可以看这个up的视频：<a href="https://www.bilibili.com/video/BV1Bk4y1x76D/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=e979466844c4915a4200c496efb35cfb">【AI绘画】Stable Diffusion画面分区控制：Regional Prompter，从入门到……_哔哩哔哩_bilibili</a></p><h1 id="八、在PS中使用AI绘图"><a href="#八、在PS中使用AI绘图" class="headerlink" title="八、在PS中使用AI绘图"></a>八、在PS中使用AI绘图</h1><h2 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1.环境配置"></a>1.环境配置</h2><p>想要在PS中使用Stable Diffusion，首先我们电脑本地必须安装了可用的SD-WebUI，然后我们需要安装Photoshop2023，因为stable.art插件只支持Photoshop2023 v23.3.0以上的版本。</p><h2 id="2-安装Photoshop2023"><a href="#2-安装Photoshop2023" class="headerlink" title="2.安装Photoshop2023"></a>2.安装Photoshop2023</h2><p>这里分享一个Photoshop2023 v24.1.0版本的下载地址：<a href="https://www.yutu.cn/softhtml/showsoft_8311.html">Adobe PhotoShop 2023 v24.1.0</a>。</p><p>下载完之后，双击解压文件夹中的setup.exe文件安装，安装完之后拷贝解压文件夹/Crack/Photoshop.exe覆盖Adobe/Adobe Photoshop 2023/Photoshop.exe文件。</p><p>这样Photoshop就安装好了。</p><h2 id="3-安装Stable-art插件"><a href="#3-安装Stable-art插件" class="headerlink" title="3.安装Stable.art插件"></a>3.安装Stable.art插件</h2><p>插件的安装就比较简单了，插件是开源的，插件地址：<a href="https://github.com/isekaidev/stable.art">isekaidev/stable.art：Photoshop插件，用于以Automatic1111作为后端的稳定扩散</a>。</p><p>这个插件就需要像webui的插件一样克隆整个git库了，我们只需要下载ccx文件就好了，在readme文件里，作者已经提供了下载连接，也可以直接点击这个链接下载：<a href="https://github.com/isekaidev/stable.art/releases/download/v0.0.1/stable.art_0.0.1.ccx">CCX</a>，下载下来后将文件名改成<code>.zip</code>，然后解压，将整个文件夹拷贝到Adobe/Adobe Photoshop 2023/Plug-ins文件下。</p><p>这样Stable.art插件就安装好了。</p><h2 id="4-启用插件"><a href="#4-启用插件" class="headerlink" title="4.启用插件"></a>4.启用插件</h2><p>Stable.art插件的运行依赖于sd-webui的api，所以我们需要以api模型启动webui，打开webui-user.bat文件在<code>set COMMANDLINE_ARGS=</code>之后加上<code>--api</code>启动参数，然后再启动webui，这时的webui就是以api模式启动了。</p><p>然后打开ps，在增效工具/stable.art，就可以看到插件了，在Endpoint栏输入webui服务器地址，插件就连接上了webui了，界面的是使用和webui基本是一样的。</p><p>stable.art插件使用的所有的设置都是webui的设置，插件目前支持更换模型、简单的文生图、基于选区的图生图，和基于选区的局部重绘，并且生成的图片会自动转换成图层。</p><p>stable.art还有一个扩展(Explore)，能够提供一些预制的tag关键词，点击之后会自动填充到关键词中。</p><p>stable.art插件目前还处于0.0.1的beta版本，功能还很不完善，如果插件能兼容ControlNet，那么这个插件将变得无比强大。</p><h2 id="5-Auto-Photoshop-SD插件"><a href="#5-Auto-Photoshop-SD插件" class="headerlink" title="5.Auto-Photoshop-SD插件"></a>5.Auto-Photoshop-SD插件</h2><p>这个插件是我在撰写Lora模型训练章节时新发现的一个PS插件，功能要比Stable.art插件强大，而且已经支持了ControlNet，Auto-Photoshop-SD的安装方法和Stable.art一样，并且也只支持2023以上的PS版本，连接Stable Diffusion服务也和Stable.art一样，在设置中设置好地址就可以，然后其他的用法基本就和使用webui一样了。</p><p>插件git库地址：<a href="https://github.com/AbdullahAlfaraj/Auto-Photoshop-StableDiffusion-Plugin#what-photoshop-version-do-i-need-to-run-the-plugin">AbdullahAlfaraj/Auto-Photoshop-StableDiffusion-Plugin：一个用户友好的插件，可以使用Automatic1111-sd-webui作为后端，在Photoshop中轻松生成稳定的扩散图像</a>。</p><h1 id="九、模型融合"><a href="#九、模型融合" class="headerlink" title="九、模型融合"></a>九、模型融合</h1><p><font color="red">后续更新计划</font></p><h1 id="十、模型训练"><a href="#十、模型训练" class="headerlink" title="十、模型训练"></a>十、模型训练</h1><p>本章参考的资料：</p><p><a href="https://www.bilibili.com/read/cv22022392">【AI绘画】LoRA训练全参数讲解</a></p><p><a href="https://www.bilibili.com/video/BV1Mx4y1K7jU/?spm_id_from=333.999.0.0&vd_source=e979466844c4915a4200c496efb35cfb">lora训练进阶教程，不要再瞎填参数了</a></p><p><a href="https://zhuanlan.zhihu.com/p/586667933">零基础 Dreambooth 使用教程 </a></p><h2 id="一些基本术语"><a href="#一些基本术语" class="headerlink" title="一些基本术语"></a>一些基本术语</h2><h3 id="不收敛"><a href="#不收敛" class="headerlink" title="不收敛"></a>不收敛</h3><p>不收敛就是AI在学习图像特征时没有将图像特征学习到模型中。</p><h3 id="泛化性"><a href="#泛化性" class="headerlink" title="泛化性"></a>泛化性</h3><p>泛化性即泛用能力，是一个模型能否适应多种情况的标准，如一个服装模型，在泛化性差的情况，AI绘制出来的服装可能就都是穿在训练集中的人物身上，或者只能画出服装，不能穿到人的身上，泛化性好的情况就是服装可以指定给任意人物穿上。</p><h3 id="欠拟合"><a href="#欠拟合" class="headerlink" title="欠拟合"></a>欠拟合</h3><p>欠拟合就是图像特征和提示词关联的不好，使用特定的触发提示词却不能很好的使AI绘制出指定特征的对象，简单的说就是AI学了，但没怎么学会，一般来说欠拟合很少在模型训练中出现。</p><h3 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h3><p>过拟合则和欠拟合相反，即学会了，但是是死读书，不会变通，就如第六章第二节所说的，使用了HelloKity的Lora之后，模型将很难再画出加菲猫，这种情况就是过拟合，即AI学会了新知识却忘记了旧知识。</p><p>过拟合的好坏视情况而论，如果是功能性模型过拟合，那么模型就缺乏泛用性，致使模型无法适应各种各样的情况，如一个通过其他猫的体态绘制加菲猫的模型，如果过拟合了，如果数据集只有真实的猫，那么模型就只能从真实的猫来绘制加菲猫，换成HelloKity模型就绘制不出来了。</p><p>但是对于人物模型来说，尤其是二次元人物Lora，人物特征就是和服装，发型发色等绑定的，这种情况适当的过拟合又是有好处的，能够很容易的还原人物特征。</p><p>然而如果这个二次元人物又有换装的需要，那么过拟合又会影响到泛用性，此时过拟合又是有坏处的。</p><p>所以过拟合的好坏应该视情况而论。</p><h3 id="训练步数"><a href="#训练步数" class="headerlink" title="训练步数"></a>训练步数</h3><p>训练步数就是在使用powershell训练时这里显示的数字：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-03-29_09-38-14.png"></p><p><code>训练步数 = [epoches] × [图片数] × [图片重复次数] ÷ [batch size]</code></p><p>epoches和batch size是训练脚本中对应参数设置的值，图片重复次数是训练文件夹下划线前的数字，具体可以看第三小节Lora。</p><h2 id="1-Checkpoint-1"><a href="#1-Checkpoint-1" class="headerlink" title="1.Checkpoint"></a>1.Checkpoint</h2><p><font color="red">后续更新计划</font></p><h2 id="2-Lora-1"><a href="#2-Lora-1" class="headerlink" title="2.Lora"></a>2.Lora</h2><p>Lora模型可以说是最好用的微调模型了，C站上大家分享的大都是Lora模型，对于想要AI绘制特定的人物，服装或者画风时，训练自用Lora是一个很不错的方式。</p><p>训练Lora前我们应该充分的了解Lora的工作原理，以便更好的掌控Lora的配置细节。</p><p>Lora模型的训练主要基于<a href="https://github.com/Akegarasu/lora-scripts">Lora-Script</a>。</p><h3 id="安装Lora-Script"><a href="#安装Lora-Script" class="headerlink" title="安装Lora-Script"></a>安装Lora-Script</h3><p>Lora-Script库地址：<a href="https://github.com/Akegarasu/lora-scripts">Akegarasu/lora-scripts: LoRA training scripts use kohya-ss’s trainer, for diffusion model.</a>；</p><p>原生的库是国外大神制作的，里面是全英文，对于一些配置的使用还是会有些不便，这里推荐使用秋叶大佬修改过的版本，大佬对训练脚本的一些配置作了中文注释。</p><p>可以到秋叶大佬的视频地址出下载：<a href="https://www.bilibili.com/video/BV1fs4y1x7p2/?spm_id_from=333.337.search-card.all.click&vd_source=e979466844c4915a4200c496efb35cfb">【AI绘画】最佳人物模型训练！保姆式LoRA模型训练教程 一键包发布</a>。</p><p>然后我们需要知晓几个文件夹和文件的作用：</p><ul><li>output：输出文件夹，训练好的模型和保存的中间模型都存在这；</li><li>sd-models：放置基础模型的地方，基础模型就是训练lora所使用的checkpoint模型；</li><li>train：用于存放训练数据的文件夹，没有这个文件夹的话，要手动创建；</li><li>venv：lora-script的运行环境配件，在配置运行环境时，由lora-script程序自动生成；</li><li>intall.ps1：一键配置运行环境的powershell脚本，如果使使用秋叶的整合，还有一个使用国内镜像源的intall-cn.ps1脚本；</li><li>train.ps1：一键训练模型脚本；</li></ul><h3 id="配置运行环境"><a href="#配置运行环境" class="headerlink" title="配置运行环境"></a>配置运行环境</h3><p>Lora-Script依赖python 3.10.8和git，通过第二章的本地部署，这两个环境应该是已经安装好了的。</p><p>然后右键intall.ps1选择使用PowerShell运行，脚本会自动为我们安装好程序的依赖。</p><p>这个过程中我有碰到<code>xformers-0.0.14.dev0-cp310-cp310-win_amd64.whl</code>安装不上的问题，我是直接从网上去下了一个同版本的whl文件到本地，手动安装解决的。</p><p>文件我也自己上传百度云了：<a href="https://pan.baidu.com/s/1C5tEo-LdS2n_1smYlEIjfg?psw=4unx">https://pan.baidu.com/s/1C5tEo-LdS2n_1smYlEIjfg?psw=4unx</a></p><p>当然还有一种方法，可以拷贝webui的<code>venv\Lib\site-packages\xformers</code>文件夹到<code>lora-scripts\venv\Lib\site-packages</code>目录。</p><h3 id="整理训练数据集"><a href="#整理训练数据集" class="headerlink" title="整理训练数据集"></a>整理训练数据集</h3><p>首先我们需要明确一个要点，训练使用的数据集的图片的质量决定了AI出图时的图片质量上限，所以对于数据集的整理应尽可能的保证完整，如我们要训练一个人物，那么数据集应尽可能包含这个人物各个角度的图片，各种景深的图片(特写，近景，中景，远景等)，各种姿势的图片，对于训练人物还可以包含一些局部特写图片，如脸部特写，服饰特写，腿部特写等，尽量减少重复的或高度相似的图片，以避免过拟合。</p><p>对于数据集中图片的数量没有明确规定数量的上下限，广大网友的经验是20-50左右为宜。</p><p>图片的尺寸也有要求，不是什么分辨率的都可以用的，图片的分辨率必须是64的倍数，并且不宜超过1024，因为Stable Diffusion 1.5的底模基本都是使用512x512尺寸的图片训练的，这使得AI在绘制1024x1024图片时的效果很差，所以当我们的训练图片超过1024x1024之后，不仅不会对训练效果有什么提升反而会成倍的提升训练时长，当然图片也不能过小，最小不要小于512x512，太小的图片包含的特征信息太少，AI将很难学习到图片中的特征。网上总结的比较优质的图片尺寸是512、768和1024，可以证据自己的显卡配置选择不同的尺寸。</p><p>在webui的训练/图像预处理选项卡已经为我们提供了图片的批量裁剪功能，可以批量的修改图片到指定分辨率。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-03-15_16-07-52.png"></p><p>视情况勾选创建镜像副本，程序在处理图片时将为每一张图片创建一个水平翻转过的镜像图片，一般在图片数据较少或缺乏某个角度图片时使用，以增加图片数量，完善数据集；</p><p>勾选自动交点裁剪，程序会自动判断画面主体，以画面主体为中心修改图片分辨率，可以有效的避免在裁剪图片时将画面主体裁碎；</p><p>最后两个自动打标的选项不建议勾选，webui的自动打标识别出来的提示词不是很准确，推荐使用Tagger插件打标，图片打标将在后面的章节介绍。</p><p>图片处理好之后，就可以将图片集放到对应的文件夹下了。</p><p>在train文件夹下新建一个以模型名命名的文件夹，比如我训练的模型我取名为bocai，那么我的文件夹就命名为bocai，这不是必须的，只是为了规范。</p><p>在bocai文件夹下新建若干以<code>[数字]_[概念]</code>格式命名的文件夹，数字代表AI在学习这些图片时的重复次数，概念就是这个文件夹下的图片代表的对象，比如我们想让AI学习唐装的样式，那么文件夹就可以命名为<code>8_tanzhuang</code>，<code>tanzhuang</code>这个词也将会作为我们将来使用训练出来的Lora控制AI绘制唐装时需要使用的触发提示词，对于下划线前的数字网上还没有明确得出设置的标准，一般来说根据文件夹放置图片的数量设置为4~8左右，具体多少图片设置多少的重复次数，目前网上没有明确的标准，根据经验就是根据概念文件夹内放置的图片数量占总图片数量的百分比来设置，最少的设置成4最多的设置成8。AI在学习图片特征时，图片数量很少而重复次数很高的话，AI就会反复学习少量的图片中的特征，使得AI在绘制图片时很难跳出这些图片的约束，而图片数量多设置重复次数高是因为图片数量多时承载的信息量也大，AI要学习图片中的特征就要多学几次，现象上和人的学习有点类似。</p><p>训练时AI会依次学习bocai文件下的若干特征数据集。</p><h3 id="正则化数据"><a href="#正则化数据" class="headerlink" title="正则化数据"></a>正则化数据</h3><p>正则化是一种用来防止数据过拟合的技术，通过对参数进行惩罚来减少模型的复杂度，提高模型的泛化性，正则化是机器学习中监督学习的一种方法。</p><p>正则化数据可以将AI已经学过的旧知识与要学习的新知识分隔开，使之互不影响，这在训练画风Lora、功能性Lora这些对模型泛化性有着极高要求的Lora时是十分必要的，对于训练人物Lora则没有那么必要了。</p><p>在train目录下新建一个reg目录，在reg目录下新建一个和训练概念同名的文件夹，如我们训练一个根据真实猫绘制卡通加菲猫的功能性Lora，那么我们应该在train目录下新建一个加菲猫的概念文件夹，加入命名为<code>8_JiafeiCat</code>，并根据图片数量设定重复次数并放置40张各种体态的加菲猫图片数据到文件夹中，然后再在train目录新建reg文件夹，在reg文件夹下新建一个同名文件夹<code>6_JiafeiCat</code>，设定的重复次数应略少于概念重复次数，并向文件夹中放入大于等于概念文件夹图片数量的正则图片，正则图片是和训练的概念—加菲猫相似但有不同的对象，如HelloKity，真实的猫等，正则图片可以从网上找，也可以直接从基础模型生成。</p><p>如果我们要使用正则化数据进行模型训练，那么在训练参数中我们需要在训练参数中指定正则化路径，如果路径为空则表示不启用，然后我们可以通过<code>--prior_loss_weight</code>参数(训练脚本中的一个参数)来控制正则化数据对概念的影响程度，默认为1表示100%影响。</p><h3 id="提示词打标"><a href="#提示词打标" class="headerlink" title="提示词打标"></a>提示词打标</h3><p>图片数据处理好之后，我们还需要处理提示词数据，每一张数据图片都应该有一个提示词文本，提示词文本描述对应图片包含的具体特征。</p><p>这里推荐使用<a href="https://github.com/toriato/stable-diffusion-webui-wd14-tagger">Tagger</a>插件来打标，Tagger插件从图片反推提示词要比Webui自带的功能要更准确。插件的用法就不累述了，如果装了汉化插件的话，各个选项的功能基本看名字就知道怎么用了。需要留意在附加标签中添加我们需要触发Lora功能的提示词。</p><p>为每张图片生成了tag文本之后，我们需要对文本进行整理，这一步操作主要是删去一些我们需要让AI学习的特征和补全一些插件没有识别上的特征，比如，我们要训练一个明日香这个角色的人物Lora，那么在tag文本中我们需要删除与红色的紧身衣、橘黄色的头发、眼罩这些有着角色明显特征的提示词，这样AI学习的时候才能将这些特征学习到Lora模型中，否则AI就会将这些特征学习到对应的特征提示词中，这种情况我们使用这个Lora时只要输入红色的紧身衣，AI就会绘制明日香的衣服，这样Lora的泛化性就很差，当然如果不重视泛化性也可以不删。如果提示词文本中插件没有识别到图片中的一些表情或姿势特征，我们应该手动补全，不然AI也会把这些表情和姿势特征学习进入模型中，AI在使用模型绘制人物时会有极大的可能出现表情、姿势固定的问题。</p><p>当然对于单概念模型，即一个Lora只训练一个角色的一种形象，触发词就不是必须的了，但对于一个Lora训练了多个角色或一个角色的多种形象时，触发词就很有必要了，触发词可以使在使用Lora时对这些概念的掌控性更强，并且可以使用触发词来控制权重。</p><p>提示词文本中描述特征的提示词越多，AI学习到Lora中的特征就越少，使用Lora还原对象时就需要更多的提示词，模型的泛化性就越高，相对的，提示词文本中描述特征的提示词越少，AI学习到Lora中的特征就越多，使用Lora还原对象时需要的提示词也就越少，模型泛化性就越低。</p><p>对于删除提示词，我们可以直接通过文本手动删除，不过更推荐使用<a href="https://github.com/toshiaki1729/stable-diffusion-webui-dataset-tag-editor">数据集标签编辑器</a>这个插件来批量操作。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-03-28_10-48-19.png"></p><p>在数据集目录输入带有提示词文本的数据集目录路径，点击载入就可以读取所有的提示词到Select Tags栏下，然后到<code>Batch Edit Captions/移除</code>功能框，勾选想要移除的提示词后点击Remove selected tags，然后点击Save all changes保存修改，如果勾选了backup original text file则会在原目录下新增原提示词文本的备份。</p><h3 id="配置训练参数"><a href="#配置训练参数" class="headerlink" title="配置训练参数"></a>配置训练参数</h3><p>训练参数指就是train.ps1脚本中的一些参数，我们一个个看：</p><ul><li><p>pretrained_model：设置我们训练lora所使用的基础模型，可以是官模，也可以是基于官模训练的定制化模型；</p></li><li><p>train_data_dir：设置训练数据集的路径；</p></li><li><p>reg_data_dir：设置正则化数据路径；</p></li><li><p>resolution：设置图片的分辨率；</p></li><li><p>batch_size：设置AI在一次学习过程中同时学习的图片数量，根据自己的显存大小设置，数值越大吃的显存越多；</p></li><li><p>max_train_epoches：epoches是机器学习中的一个重要概念，一次epoches表示AI对整个数据集进行一次完整的训练，如我们设置成10那么AI就会对我们的数据集进行10次完整的训练，一般来说epoches数越大，模型的训练效果越好，训练所需要的时长也越长，但epoches数会影响到训练步数，过大也会导致数据过拟合；</p></li><li><p>save_every_n_epochs：设置每隔多少次epoches保存一次模型，主要用于对比不同epoches下的模型效果。</p></li><li><p>network_dim：设置AI学习的深度，就是AI在一张图片中学习的特征数量，会直接影响输入数据的维度，从而很大程度的影响lora的质量，数值越大，输出的lora模型也就越大。dim数值不宜过大也不宜过小，过大容易照成过拟合，过小则学习的特征不够，效果不佳，有人说32很合适，也有人说128很合适，个人认为应该根据自己的实际情况来调整。</p></li><li><p>network_alpha：这个数值是用来调整正则化程度的，值越大，正则化程度越高，模型复杂度就越小，模型泛化性越强，一般设置成和network_dim一样的数值，或者使用小数来使用百分比的形式，使用小数的话一般设置成0.25~0.5。</p></li><li><p>train_unet_only：是否只训练U-Net；</p></li><li><p>train_text_encoder_only：是否只训练文本编码器；</p><p>train_unet_only和train_text_encoder_only两个选项除非有修改代码或者有预先训练的需求，一般都设置为0，不启用。</p></li><li><p>noise_offset：设置AI在训练是往训练结果中添加的噪声偏移量，用来改良在生成非常暗或非常亮的图片时的生成效果；</p></li><li><p>keep_tokens：是否打乱AI读取提示词文本中提示词的顺序，打乱提示词的读取顺序有利于提高模型的泛化性，设置数值表示在第几个提示词之后开始打乱读取顺序；</p></li><li><p>lr：设置训练lora模型的学习率，学习率是指控制模型在每次迭代中更新权重的步长。学习率的大小对模型的训练和性能都有重要影响。如果学习率设置得太小，模型收敛速度会很慢，训练时间会变长；如果学习率设置得太大，模型可能会在训练过程中出现震荡，甚至无法收敛。默认1e-4是调试过的数值；</p></li><li><p>unet_lr：设置训练U-Net的学习率；</p></li><li><p>text_encoder_lr：设置训练文本编码器的学习率；</p></li><li><p>lr_scheduler：设置学习率调度器，学习率调度器是一种在模型训练的过程中进行动态调节学习率的技术，lora-script已经为我们内置了</p><p>linear-学习率线性下降；</p><p>cosine-余弦退火，使用余弦函数来逐渐降低学习率；</p><p>cosine_with_restarts-余弦退火重启，在cosine的基础上没过几个周期重启一次；</p><p>polynomial-使用多项式函数来调整学习率；</p><p>constant-学习率保持恒定不变；</p><p>constant_with_warmup-恒定预热，在开始时学习率会略微增大，然后逐渐退回学习率恒定不变；</p><p>这六个调度器。</p></li><li><p>lr_warmup_steps：在学习率调度器启用constant_with_warmup时生效，设置恒定预热调度器在开始学习时学习率增大的幅度，一般设置成总步数的1/10或1/20的数值。例如总步数是1000，就设置成50或者100；</p></li><li><p>lr_restart_cycles：在学习率调度器启用cosine_with_restarts启用，设置重启的间隔；</p></li><li><p>output_name：输出模型的名称；</p></li><li><p>save_model_as：输出模型的格式，可以是ckpt，pt和safetensors，建议都使用safetensors安全格式；</p></li><li><p>network_weights：设置是否需要重已有的Lora模型继续训练，需要则设置成Lora模型的路径，不需要则设置成空字符；</p></li><li><p>min_bucket_reso：设置训练数据集中图片的最小分辨率；</p></li><li><p>max_bucket_reso：设置训练数据集中图片的最大分辨率；</p><p>min_bucket_reso和max_bucket_reso需要根据自己整理的数据集的情况设置，设置不对训练时会报错；</p></li><li><p>persistent_data_loader_workers：是否保留加载训练集的worker，减少每次epoch的停顿，显存不高的不建议启用，容易爆显存；</p></li><li><p>clip_skip：设置文本解析时跳过的神经网络的层数，一般训练三次元lora设置成1，训练二次元lora设置成2，具体的作用可以看这里：<a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui/discussions/5674">clip_skip到底是什么？ ·自动1111 稳定扩散 ·</a>；</p></li><li><p>use_8bit_adam：是否启用8bit优化器，可以在不影响模型精度的情况下大幅减少显存的使用量节，默认启用；</p></li><li><p>use_lion：是否启用Lion优化器，可以让模型更快的收敛，具体可以看这里：<a href="https://zhuanlan.zhihu.com/p/610262893">Google新搜出的优化器Lion：效率与效果兼得的“训练狮”</a>；</p></li><li><p>enable_locon_train：启用LoCon训练，LoCon是由Lora演变而来的改进模型，具体可以看这里：<a href="https://zhuanlan.zhihu.com/p/612133434">LoCon相对于LoRA的改进</a>，但是现在Lora模型使用得更广泛，所以一般不启用；</p></li><li><p>conv_dim：设置训练LoCon模型时的学习率；</p></li><li><p>conv_alpha：设置训练LoCon模型时的正则化程度；</p></li><li><p>–prior_loss_weight：设置正则化数据对概念的想象程度。</p></li></ul><p>把参数按照自己的需求设置好，就可以右键<code>train.ps1</code>使用powershell运行，来训练模型了。</p><p>这些参数的设置对于Lora类型，风格强度，使用场景等均有不同设置，目前网上没有明确的设置标准，大都需要根据经验设置，通过不断的测试来确定一组效果比较好的参数组。</p><p><font color="red">后续更新计划</font></p><p><a href="https://www.youtube.com/@JackEllie">杰克艾米立 - YouTube</a></p><h3 id="人物Lora训练"><a href="#人物Lora训练" class="headerlink" title="人物Lora训练"></a>人物Lora训练</h3><p>人物的lora训练和前面的lora训练参数基本基本一致，需要关注的是数据集，如果想要Lora训练出来的人物有较好的泛用性，那么训练集中，人物应尽可能多的多几套服装、多几个角度，多集中动作，多余一些比较重要的配饰应该有特写图片，然后人物图片数据集应该将人物单独扣出来，去除背景，并使用白色背景填充，这样在出图时不会受到数据集背景的影响。</p><h3 id="服装Lora训练"><a href="#服装Lora训练" class="headerlink" title="服装Lora训练"></a>服装Lora训练</h3><h3 id="画风Lora训练"><a href="#画风Lora训练" class="headerlink" title="画风Lora训练"></a>画风Lora训练</h3><h3 id="功能性Lora训练"><a href="#功能性Lora训练" class="headerlink" title="功能性Lora训练"></a>功能性Lora训练</h3><h2 id="3-Embedding-1"><a href="#3-Embedding-1" class="headerlink" title="3.Embedding"></a>3.Embedding</h2><p><a href="https://www.bilibili.com/read/cv20183008/">【AI绘画】Embedding &amp; Hypernetwork使用及训练（Stable Diffusion）（自用） - 哔哩哔哩 (bilibili.com)</a></p><p><a href="https://www.bilibili.com/video/BV16d4y1c7dh/?spm_id_from=333.337.search-card.all.click&vd_source=e979466844c4915a4200c496efb35cfb">stable diffusion训练embedding和hypernetwork详解_哔哩哔哩_bilibili</a></p><h2 id="4-Hypernetworks-1"><a href="#4-Hypernetworks-1" class="headerlink" title="4.Hypernetworks"></a>4.Hypernetworks</h2><h2 id="5-AesthticGradients"><a href="#5-AesthticGradients" class="headerlink" title="5.AesthticGradients"></a>5.AesthticGradients</h2><h1 id="十一、脚本开发"><a href="#十一、脚本开发" class="headerlink" title="十一、脚本开发"></a>十一、脚本开发</h1><h1 id="十二、插件开发"><a href="#十二、插件开发" class="headerlink" title="十二、插件开发"></a>十二、插件开发</h1><h1 id="十三、ComfyUI"><a href="#十三、ComfyUI" class="headerlink" title="十三、ComfyUI"></a>十三、ComfyUI</h1><p>ComfyUI是最近新出的一款stable diffusion操作UI，特点是可以使用节点的形式对出图流程进行精确控制，作者制作这款UI的初衷就是可以使用stable diffusion进行复杂的工作流，目前ComfyUI还在快速的迭代中。</p><p>我实际使用之后的感受是，ComfyUI出图是真的快，我的3080ti显卡使用ComfyUI批量出8张2K图只需要几秒钟，换做WebUI，起码得半分钟。</p><h2 id="1-本地部署"><a href="#1-本地部署" class="headerlink" title="1.本地部署"></a>1.本地部署</h2><h3 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h3><p>直接使用git克隆<a href="https://github.com/comfyanonymous/ComfyUI">ComfyUI</a>库到本地或下载zip包解压到本地，相比于WebUI，ComfyUI就小了很多，到我写这个章节的日期为止，整个ComfyUI库只有6.75MB。</p><p>ComfyUI依赖python3.10环境，作者有在readme中提及，目前ComfyUI不支持python3.10以上环境，这里我们可以直接使用WebUI的虚拟环境中的Python就好了，正好前面部署WebUI时使用的python是3.10.6。</p><p>在ComfyUI目录中在地址栏输入cmd，回车就可以直接在ComfyUI目录启动cmd</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-04-07_15-20-11.png"></p><p>进入WebUI的1<code>venv/Scripts</code>目录找到python.exe拖入cmd，然后运行main.py脚本就可以运行ComfyUI服务了。</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">E:<span class="hljs-symbol">\W</span>ebUI<span class="hljs-symbol">\v</span>env<span class="hljs-symbol">\S</span>cripts<span class="hljs-symbol">\p</span>ython.exe main.py<br></code></pre></td></tr></table></figure><p>在浏览器打开控制台给的地址，就可以进入ComfyUI了。</p><p>为了启动方便，我们可以写一个.bat脚本写入上面这条指令，下次启动就可以直接双击.bat脚本运行。</p><p>不过现在UI还是不能出图的，我们还需要安装一些依赖</p><h3 id="安装依赖项"><a href="#安装依赖项" class="headerlink" title="安装依赖项"></a>安装依赖项</h3><p>ComfyUI需要使用<code>torch</code>、<code>xfirmers</code>工具库，我们已经在WebUI中安装过这些库了，所以可以不用再安装，按照前面的运行方式我们已经使用了WebUI的虚拟环境运行ComfyUI，所以这些库ComfyUI都已经识别上了。</p><p>如果没有安装WebUI的话，通过cmd使用这个命令安装</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">pip install torch torchvision torchaudio --extra-index-url https:<span class="hljs-regexp">//</span>download.pytorch.org<span class="hljs-regexp">/whl/</span>cu118 xformers<br></code></pre></td></tr></table></figure><p>这是英伟达显卡的版本，AMD显卡安装这个版本</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>download.pytorch.org<span class="hljs-regexp">/whl/</span>rocm5.<span class="hljs-number">4.2</span><br></code></pre></td></tr></table></figure><p>运行之后，需要下载2.6G的工具库。</p><p>然后运行</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> -r requirements.txt<br></code></pre></td></tr></table></figure><p>安装ComfyUI的依赖。</p><p>自己安装torch和xformers的话经常会和cuda出现各种版本问题，需要自己去调，所以有安装WebUI的话建议还是直接使用WebUI的虚拟环境无脑运行。</p><h3 id="配置模型"><a href="#配置模型" class="headerlink" title="配置模型"></a>配置模型</h3><p>对于已经安装了WebUI的人可以修改ComfyUI根目录下的<code>extra_model_paths.yaml.example</code>文件，</p><ul><li>base_path：设置WebUI的根目录</li><li>checkpoints：设置WebUI的大模型目录</li><li>vae：设置WebUI的VAE目录</li><li>loras：设置WebUI的lora目录</li><li>upscale_models：设置WebUI的放大算法目录</li><li>controlnet：设置controlnet库目录</li></ul><p>可以参考我的设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#Rename this to extra_model_paths.yaml and ComfyUI will load it</span><br><br><span class="hljs-comment">#config for a1111 ui</span><br><span class="hljs-comment">#all you have to do is change the base_path to where yours is installed</span><br><span class="hljs-attr">a111:</span><br>    <span class="hljs-attr">base_path:</span> <span class="hljs-string">E:/WebUI</span><br><br>    <span class="hljs-attr">checkpoints:</span> <span class="hljs-string">E:/WebUI/models/Stable-diffusion</span><br>    <span class="hljs-attr">configs:</span> <span class="hljs-string">E:/WebUI/models/Stable-diffusion</span><br>    <span class="hljs-attr">vae:</span> <span class="hljs-string">E:/WebUI/models/VAE</span><br>    <span class="hljs-attr">loras:</span> <span class="hljs-string">E:/WebUI/models/Lora</span><br>    <span class="hljs-attr">upscale_models:</span> <span class="hljs-string">|</span><br>                  <span class="hljs-string">E:/WebUI/models/ESRGAN</span><br>                  <span class="hljs-string">E:/WebUI/models/SwinIR</span><br>    <span class="hljs-attr">embeddings:</span> <span class="hljs-string">E:/WebUI/embeddings</span><br>    <span class="hljs-attr">controlnet:</span> <span class="hljs-string">E:/WebUI/extensions/sd-webui-controlnet</span><br><br><span class="hljs-comment">#other_ui:</span><br><span class="hljs-comment">#    base_path: path/to/ui</span><br><span class="hljs-comment">#    checkpoints: models/checkpoints</span><br></code></pre></td></tr></table></figure><p>设置好之后，将文件重命名为<code>extra_model_paths.yaml</code>，在下次启动时ComfyUI会加载配置文件的模型。</p><p>当然我们也可以将模型放到ComfyUI/models目录的对应文件夹下。</p><h2 id="2-操作与界面"><a href="#2-操作与界面" class="headerlink" title="2.操作与界面"></a>2.操作与界面</h2><ul><li><p>长按鼠标左键：移动视图；</p></li><li><p>单击节点：选中指定节点；</p></li><li><p>双击鼠标左键：打开快捷节点搜索；</p></li><li><p>右键空白视图：跳出右键菜单，右键菜单得根目录只有两个选项：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-04-07_16-49-23.png"></p><p>Add Node：添加节点；</p><p>Add Group：添加组，可以为节点打组，这个功能现在还有点鸡肋，可以忽略。</p></li><li><p>按住Ctrl+鼠标左键：框选选区内节点；</p></li><li><p>鼠标放在节点右下角：可以修改节点的大小；</p></li><li><p>右键节点：打开节点菜单，</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-04-07_16-53-57.png"></p><p>Properties：</p><p>Title：修改节点的名称；</p><p>Mode：更改节点的模式，</p><p>Resize：重置节点的尺寸到默认值；</p><p>Collapse：缩略节点；</p><p>Pin：</p><p>Colors：更改节点的颜色；</p><p>Shapes：更改节点的形状；</p></li><li><p>菜单界面：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/Snipaste_2023-04-07_18-11-17.png"></p><p>在左上角长按左键：拖动菜单；</p><p>Queue Prompt：将当前节点的组合任务加入队列；</p><p>Extra options：勾选可以启用批量出图；</p><p>Queue Front：将当前队列的任务再执行一次；</p><p>See Queue：查看队列信息，可以在这里删除指定的任务，以终止图片生成；</p><p>See History：查看历史信息；</p><p>Save：保存当前页面的节点信息到一个Json文件中；</p><p>Load：从Json文件加载页面节点信息；</p><p>Refresh：刷新页面；</p><p>Clear：清空页面；</p><p>Load Default：加载默认页面节点信息；</p></li></ul><h2 id="3-常用节点"><a href="#3-常用节点" class="headerlink" title="3.常用节点"></a>3.常用节点</h2><p>由于ComfyUI还处于快速迭代中，节点可能会有变化，这里以撰写这个章节日期：2023.4.7更新的最新版本为例。</p><p>打开ComfyUI，UI界面已经</p><h1 id="十四、InvokeAI"><a href="#十四、InvokeAI" class="headerlink" title="十四、InvokeAI"></a>十四、InvokeAI</h1><p><a href="https://github.com/invoke-ai/InvokeAI">InvokeAI</a></p><h1 id="十五、扩展阅读"><a href="#十五、扩展阅读" class="headerlink" title="十五、扩展阅读"></a>十五、扩展阅读</h1><p><a href="https://github.com/gabime/spdlog">AI绘画Stable-diffusion扩展最新全面使用指南 - 知乎 (zhihu.com)https://zhuanlan.zhihu.com/p/583677438</a></p><p><a href="https://mp.weixin.qq.com/s/cs04bBQVCz0kNzPrBStGpw">如何使用AI绘画技术生成360度全景图？ (qq.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/574063064">NovelAI模型各参数解析以及对应关系 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/609330474">AI 绘画神器 Stable Diffusion 玩法大测评 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/592347520">【AI绘画模型大全】超全的模型资源汇总！ - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/wpgdream/article/details/129342468">AI绘画第二步，抄作业复现超赞的效果！_托尼不是塔克的博客-CSDN博客</a></p><p><a href="https://github.com/TencentARC/T2I-Adapter">TencentARC/T2I-Adapter: T2I-Adapter (github.com)</a></p><p><a href="https://blog.csdn.net/xiqiao_ce/article/details/129152978">精确控制 AI 图像生成的破冰方案，ControlNet 和 T2I-Adapter_创业者西乔的博客-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/605761756">ControlNet如何为扩散模型添加额外模态的引导信息 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/585938939">扩散模型与受控图像生成-脉络梳理 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/572156692">CLIP, VQGAN, VQGAN-CLIP, Stable-Diffusion - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE5】动画系统</title>
    <link href="/2023/01/31/%E3%80%90UE5%E3%80%91%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/01/31/%E3%80%90UE5%E3%80%91%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>最近接触的项目涉及到动捕和动画，以前接触的范围主要是GamePlay以及C++和蓝图的交互，很少接触动画，借此机会学习一下UE5的动画系统。</p><a id="more"></a><p>首先把整个动画系统的框架了解一下。</p><p>参考博客：<a href="https://zhuanlan.zhihu.com/p/62401630">奶帆</a>、<a href="https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/SkeletalMeshAnimation/Skeleton/">骨架资源</a>、<a href="https://docs.unrealengine.com/4.27/zh-CN/AnimatingObjects/SkeletalMeshAnimation/Persona/SkeletonTree/">骨架树</a>、<a href="https://papalqi.cn/2020/ue4%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">papalqi</a>、<a href="https://zhuanlan.zhihu.com/p/462945444">郭袁</a>、<a href="https://stefanperales.com/blog/dynamic-ik-retargeting-in-ue5/">Stefan Perales</a></p><h1 id="一、动画系统的框架"><a href="#一、动画系统的框架" class="headerlink" title="一、动画系统的框架"></a>一、动画系统的框架</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>D1(AimOffset)--&gt;C2(BlendSpace);<br>D2(AnimationMontage)--&gt;C3(AnimationCompostie);<br>C1(PhysicsAsset)--&gt;B1(SkeletalMesh);<br>C2(BlendSpace)--&gt;B2(AnimationSequence);<br>C3(AnimationCompostie)--&gt;B2(AnimationSequence);<br>B1(SkeletalMesh)--&gt;A1(Skeleton);<br>B2(AnimationSequence)--&gt;A1(Skeleton);<br>D2(AnimationMontage)--&gt;B2(AnimationSequence);<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>A(AnimationBlueprint);<br>D(AnimInstance);<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>A(PoseAsset)<br>B(ControlRig)<br>C(Animation State Machie)<br></code></pre></td></tr></table></figure><p>我们自上而下，从左往右看：</p><h2 id="1-AimOffset"><a href="#1-AimOffset" class="headerlink" title="1.AimOffset"></a>1.AimOffset</h2><p>AimOffset在UE4中的直译是目标偏移，用于对主体动画的混合叠加，多用于射击瞄准，如在吃鸡游戏中人物持枪瞄准时根据视角不同可以向上瞄准和对地瞄准和左右侧身瞄准。Epic不愧是做射击游戏起家的，AimOffset在UE中使用的图标都是一个人持枪的样子。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311954153.png"></p><h2 id="2-AnimationMotage"><a href="#2-AnimationMotage" class="headerlink" title="2.AnimationMotage"></a>2.AnimationMotage</h2><p>AnimationMotage直译为动画蒙太奇，Motage在影视剪辑中是一种剪辑手法，通过将一系列视点不同的镜头组合起来的一种手法，感觉UE也是沿用这种解释，将不同而又有关联的多个动画组合起来构成一个完整的动画，这个完整的动画就是AnimationMotage。如一个攻击技能动画可以由拔刀动画+向上跳起动画+向目标砸下动画+收刀动画组成。这几个动画就可以由一个AnimationMotage组合在一起。AnimationMotage可以便于AnimationBlueprint更好的控制动画。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311954901.png"></p><h2 id="3-PhysicsAsset"><a href="#3-PhysicsAsset" class="headerlink" title="3.PhysicsAsset"></a>3.PhysicsAsset</h2><p>PhysicsAsset—物理资产，官方给的定义是</p><blockquote><p>物理资产用于定义骨架网格体使用的物理和碰撞。它们包含一组刚体和约束，这些构成一个布偶，而布偶并不 局限于人形布偶。它们可以用于任何使用形体和约束的物理模拟。因为一个骨架网格体只允许一个物理资产， 所以可以为许多骨架网格体打开或关闭它们。</p></blockquote><p>我们在打开动画相关的资产的时候一般都能看到物理资产。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311955262.png"></p><h2 id="4-BlendSpace"><a href="#4-BlendSpace" class="headerlink" title="4.BlendSpace"></a>4.BlendSpace</h2><p>BlendSpace—混合空间，BlendSpace是用于根据输入的float值在两个动画进行融合采样然后输出融合后的动画的工具，如两个动画一个是向前走一个是向左走，两个动画就可以通过输入的float值在混合空间进行混合，然后输出从前到左这个扇形方向任何一个方向运行的动画。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311955533.png"></p><h2 id="5-AnimationCompostie"><a href="#5-AnimationCompostie" class="headerlink" title="5.AnimationCompostie"></a>5.AnimationCompostie</h2><p>AnimationCompostie—动画合成，按照<a href="https://docs.unrealengine.com/4.27/zh-CN/AnimatingObjects/SkeletalMeshAnimation/AnimationComposite/">官方的解释</a>就是</p><blockquote><p>动画合成作为一种将多个动画组合在一起将它们作为单个单元进行处理的方法。在某些情况下，你可能会遇到这样的情况：你需要将多个动画序列拼接在一起，这样就可以将它们当作一个序列而不是多个序列来使用。这正是 动画合成 的目的。动画合成是一种动画资产，专门设计用于允许你将多个动画组合在一起以作为单个单元进行处理。但是，请注意合成只是追加动画；它不提供任何混合能力。</p></blockquote><h2 id="6-SkeletalMesh"><a href="#6-SkeletalMesh" class="headerlink" title="6.SkeletalMesh"></a>6.SkeletalMesh</h2><p>SkeletalMesh—骨骼模型，绑定了骨骼之后的网格体，也是角色实际应用mesh。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311955619.png"></p><h2 id="7-AnimationSequence"><a href="#7-AnimationSequence" class="headerlink" title="7.AnimationSequence"></a>7.AnimationSequence</h2><p>AnimationSequence—动画序列，帧动画的一种，官方给的定义是</p><blockquote><p><strong>动画序列（AnimationSequence）</strong> 是一个可以在骨架网格体上播放的独立的动画资源。它们包含了一些关键帧，这些关键帧可以及时地指出某个特定点处的一个骨骼的位置、旋转度及缩放比例。通过回放序列中的这些关键帧，并在将它们互相混合，使得骨架网格体可以产生平滑的动画效果。</p><p>每个 <em>动画序列</em> 资源指向一个特定的骨架，且仅可以在那个骨架上进行播放。这意味着，为了在多个骨架网格物体间共享动画，所有网格物体都必须使用同样的骨架资源。</p></blockquote><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311955370.png"></p><h2 id="8-Skeleton"><a href="#8-Skeleton" class="headerlink" title="8.Skeleton"></a>8.Skeleton</h2><p>Skeleton—骨骼，骨骼是整个动画的系统的基础，任何动画都要在骨骼的基础上进行创作，只要人物应用的骨骼保持一致，同一个动画就可以在不同的人物上应用。</p><p>官方定义是</p><blockquote><p>如果您熟悉数字内容创建，那么对”骨架”的概念应该有所了解。 在多数3D应用程序中，骨架通常是一个数字层级架构，用于定义角色中的骨骼或关节，并以诸多方式模仿真实的生物骨架。 在虚幻引擎4中，一个重要的区别是骨架资源将 <strong>关联动画数据</strong>，而并非只是骨架网格体中的骨骼层级。 在UE4中，骨架资源将把骨骼（关节）数据关联到动画轨迹，从而驱动动画。</p></blockquote><h2 id="9-AnimationBlueprint"><a href="#9-AnimationBlueprint" class="headerlink" title="9.AnimationBlueprint"></a>9.AnimationBlueprint</h2><p>AnimationBlueprint—动画蓝图，动画蓝图是UE专门用来控制动画的专用蓝图，用于将各种动画的混合，叠加，控制，更新以及状态等进行程序化控制，然后输出最终的动画到角色身上。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311955511.png"></p><h2 id="10-各个资产之间的关系"><a href="#10-各个资产之间的关系" class="headerlink" title="10.各个资产之间的关系"></a>10.各个资产之间的关系</h2><p>我们以一个发球动作为例。</p><p>可以把整个骨骼(Skeleton)是整个动画系统的基础，存储着一些最基础的数据，决定了一个角色可以做什么样的动作；</p><p>骨骼模型(SkeletalMesh)是依附于骨骼之上的血肉，决定角色动画的外型形象；物理资产(PhysicsAsset)是依附于骨骼之上的物理碰撞体，是动画之间物理碰撞；</p><p>动画序列(AnimationSequence)是一段一段的动作片段，如起步做东，冲刺动作，抬脚动作、踢出动作；</p><p>混合空间(BlendSpace)和目标偏移(AimOffset)都是为动作片段优化动作的，混合空间为各个动画片段添加变化，如踢出动作可以混合出偏内侧踢和偏外侧踢，目标偏移为指定动画增加优化动作，如起步动作的屈膝优化；</p><p>动画融合(AnimationCompostie)是对整体动作的优化，可以将一个一个的动画片段进行截取组合，组合成一个完整的新动作，如一个个动作片段可能会有一些多余的小动作，动画融合就可以把这些小动作清理掉并把截取出来的动作并接成一个简洁的动作，可以将整个发球动作融合成助跑和射球两个动画融合，也可以直接融合成一整个完整的发球动作；</p><p>动画蒙太奇(AniamtionMotage)则是对整个动画的整合控制，可以直接整合一个个的动画片段，也可以整合组合过的动画融合，让后对整个动画提供参数控制，相当于给骨骼肌肉发送动作指令的神经系统；</p><p>动画蓝图(AnimationBlueprint)为整个动画系统提供程序逻辑控制的能力，是整个动作控制的大脑，控制着动作的一举一动，当然在一个做动作的过程中动画蓝图不是必须，就如我们做一些动作是可以直接通过肌肉记忆做出动作而无需过大脑。</p><h1 id="二、骨骼"><a href="#二、骨骼" class="headerlink" title="二、骨骼"></a>二、骨骼</h1><p>骨骼存储着一些最基础的信息，如：</p><ul><li>骨骼层级信息；</li><li>参考姿势信息；</li><li>骨骼的名称；</li><li>插槽信息；</li><li>曲线信息；</li><li>动画通知信息；</li><li>插槽数据；</li><li>虚拟骨骼信息；</li><li>骨骼映射表；</li><li>重定位信息；</li><li>各个骨骼之间的约束信息。</li></ul><h2 id="1-骨骼的创建"><a href="#1-骨骼的创建" class="headerlink" title="1.骨骼的创建"></a>1.骨骼的创建</h2><p>骨骼的创建一般都发生在导入模型资产到UE的过程中由UE根据导入的骨骼模型和骨骼设置自动创建，同时UE也提供根据已有的骨骼模型来创建一个新的骨骼资产，UE在创建出新的骨骼资产后会把动画资源重新关联到新的骨骼资产上。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311955360.png"></p><h2 id="2-骨骼树"><a href="#2-骨骼树" class="headerlink" title="2.骨骼树"></a>2.骨骼树</h2><p>我们打开骨骼资产编辑器，在左侧就能看到一列密密麻麻的树型骨骼结构，这里我做一些简单的了解。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311955919.png"></p><p>我们可以在骨骼资产编辑器中渲染视图的Character/Bones下勾选Bone Names和All Hierachy将所有骨骼和骨骼名称显示出出来。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311955651.png"></p><ul><li><p>root：整个树结构的根是root节点，按照规范root节点所在的位置就是人物在地面的中心；</p></li><li><p>pelvis：直译为盆骨，是整个躯干骨骼的根节点，动画通过这个节点来控制整个身体的运动，pelvis直接从root节点连接到盆骨位置处；</p></li><li><p>ik_foot_root和ik_hand_root：这两个节点就是上图中从root节点延申到脚和手的骨骼，是用于脚部和手部的IK动画的节点，这里暂时先不讨论；</p></li><li><p>spine_01-spine_03：是三节脊椎骨，从下往上依次嵌套，覆盖腹部、腰部和胸部，动画通过这三个节点来控制上半身的动作；</p></li><li><p>clavicle_l和clavicle_r：左右锁骨，是手部骨骼的根节点，控制着整个手臂的动作；</p></li><li><p>upperarm_l和upperarm_r：左右肩膀的骨骼；</p></li><li><p>lowerarm_l和lowerarm_r：左右臂的骨骼；</p></li><li><p>hand_l和hand_r：手腕的骨骼，手腕再往下就是手指骨骼了；</p></li><li><p>neck_01：颈部骨骼，动画通过这个节点来控制头部的动作；</p></li><li><p>head：头部骨骼，用于继续往上延申出控制眼睛动作的骨骼，控制嘴巴动作的骨骼和头发动作的骨骼；如：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311956284.png"></p></li><li><p>thigh_l和thigh_r：盆骨外下的跨部的骨骼，是整个腿部骨骼的根节点，控制整个腿部的动作。</p></li><li><p>calf_l和calf_r：大腿骨骼；</p></li><li><p>foot_l和foot_r：小腿骨骼；</p></li><li><p>ball_l和ball_r：脚掌的骨骼；</p></li></ul><p>每个根骨骼都有一个根节点，也就是图中骨骼根部的球状部位，骨骼之间通过根节点进行约束，出了root节点，每根骨骼节点都会存储相对于父节点的变换矩阵，通过变化矩阵动画系统就可以从根节点的运动计算出其下所有子节点的相对运动。</p><h2 id="3-骨骼动画驱动骨骼和模型"><a href="#3-骨骼动画驱动骨骼和模型" class="headerlink" title="3.骨骼动画驱动骨骼和模型"></a>3.骨骼动画驱动骨骼和模型</h2><p>所谓骨骼动画其实就是一系列的骨骼移动旋转的关键帧信息，动画系统通过每帧读取这些关键帧信息来控制骨骼做对应移动旋转动作，然后骨骼再驱动绑定在骨骼上的模型的点来控制模型跟随骨骼运动，这个过程是一些列复杂空间坐标转换，最终输出人物在世界坐标中的动画效果。</p><h2 id="4-骨骼插槽"><a href="#4-骨骼插槽" class="headerlink" title="4.骨骼插槽"></a>4.骨骼插槽</h2><p>骨骼插槽就是字面的意思，附着在骨骼上的插槽，可以用于在骨骼的指定位置添加对象，如在手上添加武器，在头上添加帽子等。</p><h3 id="添加插槽"><a href="#添加插槽" class="headerlink" title="添加插槽"></a>添加插槽</h3><p>在骨骼树下右键指定的骨骼选择Add Socket可以在指定骨骼下添加插槽，一个骨骼下可以添加多个插槽。插槽会记录下自己相对与骨骼的Transform信息，当对象绑定到插槽时会将Transform信息应用到对象上。</p><h3 id="在编辑器中绑定插槽"><a href="#在编辑器中绑定插槽" class="headerlink" title="在编辑器中绑定插槽"></a>在编辑器中绑定插槽</h3><p>静态绑定就是直接在编辑器中进行绑定，我们为Character添加一个StaticMesh并给与一个球体模型，然后在Details/Sockets下就可以选择组件要绑定的骨骼插槽了。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311956681.png"></p><p>选了骨骼插槽后StaticMesh就会应用骨骼插槽记录的Transform信息，自动修改相对位置和相对缩放。</p><h3 id="蓝图动态绑定插槽"><a href="#蓝图动态绑定插槽" class="headerlink" title="蓝图动态绑定插槽"></a>蓝图动态绑定插槽</h3><p>我们以一个人物跳起时头顶发生爆炸的效果为例。</p><p>我们在头部骨骼上创建一个插槽，然后使用蓝图动态创建一个ParticleSystemComponent，将ParticleSystemComponent绑定到Mesh上，在AttachComponentToComponent节点上我们就可以直接绑定插槽。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311956813.png"></p><p>然后在跳起时触发特效</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311956118.png"></p><p>运行效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311956197.gif"></p><h3 id="C-动态绑定插槽"><a href="#C-动态绑定插槽" class="headerlink" title="C++动态绑定插槽"></a>C++动态绑定插槽</h3><p>先上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Particles/ParticleSystemComponent.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;GameFramework/Character.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;OCharacter.generated.h&quot;</span></span><br>UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OTHERWORLDLYKINGDOM_API</span> <span class="hljs-title">AOCharacter</span> :</span> <span class="hljs-keyword">public</span> ACharacter<br>&#123;<br>GENERATED_BODY()<br><span class="hljs-keyword">public</span>:<br>UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = <span class="hljs-string">&quot;Component&quot;</span>)<br>UParticleSystemComponent* ParticleSystemComp;<br>UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = <span class="hljs-string">&quot;Component&quot;</span>)<br>USkeletalMeshComponent* SkeletalMeshComp;<br>UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = <span class="hljs-string">&quot;Component&quot;</span>)<br>UParticleSystem* ParticleSystem;<br><span class="hljs-keyword">public</span>:<br>AOCharacter();<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Tick</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime)</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetupPlayerInputComponent</span><span class="hljs-params">(class UInputComponent* PlayerInputComponent)</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OJump</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OStopJumping</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//.cpp</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;OCharacter.h&quot;</span></span><br><span class="hljs-comment">//...</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOCharacter::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br>ParticleSystemComp = NewObject&lt;UParticleSystemComponent&gt;(<span class="hljs-keyword">this</span>, TEXT(<span class="hljs-string">&quot;ParticleSystem&quot;</span>));<br>ParticleSystemComp-&gt;RegisterComponent();<br>ParticleSystemComp-&gt;SetAutoActivate(<span class="hljs-literal">false</span>);<br>TArray&lt;USkeletalMeshComponent*&gt; SComps;<br>GetComponents&lt;USkeletalMeshComponent&gt;(SComps);<br><span class="hljs-keyword">for</span> (TObjectIterator&lt;USkeletalMeshComponent&gt; It; It; ++It)<br>&#123;<br>USkeletalMeshComponent* Comp = *It;<br><span class="hljs-keyword">if</span> (Comp-&gt;ComponentTags.Num() &gt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (Comp-&gt;ComponentTags[<span class="hljs-number">0</span>] == FName(TEXT(<span class="hljs-string">&quot;Main&quot;</span>)))<br>&#123;<br>ParticleSystemComp-&gt;AttachToComponent(SkeletalMeshComp, FAttachmentTransformRules::KeepRelativeTransform, TEXT(<span class="hljs-string">&quot;headSocket&quot;</span>));<br>&#125;<br>&#125;<br>&#125;<br>ParticleSystem = LoadObject&lt;UParticleSystem&gt;(<span class="hljs-literal">nullptr</span>, TEXT(<span class="hljs-string">&quot;ParticleSystem&#x27;/Game/AnimationStudy/StarterContent/Particles/P_Explosion.P_Explosion&#x27;&quot;</span>));<br>ParticleSystemComp-&gt;SetTemplate(ParticleSystem);<br>InputComponent-&gt;BindAction(TEXT(<span class="hljs-string">&quot;Jump&quot;</span>), EInputEvent::IE_Pressed, <span class="hljs-keyword">this</span>, &amp;AOCharacter::Jump);<br>InputComponent-&gt;BindAction(TEXT(<span class="hljs-string">&quot;Jump&quot;</span>), EInputEvent::IE_Released, <span class="hljs-keyword">this</span>, &amp;AOCharacter::StopJumping);<br>&#125;<br><span class="hljs-comment">//...</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOCharacter::OJump</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Jump();<br><span class="hljs-keyword">if</span> (ParticleSystemComp != <span class="hljs-literal">nullptr</span>)<br>&#123;<br>ParticleSystemComp-&gt;SetActive(<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>UE_LOG(LogTemp, Error, TEXT(<span class="hljs-string">&quot;AOCharacter::Jump-ParticleSystemComp is null&quot;</span>));<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOCharacter::OStopJumping</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>StopJumping();<br><span class="hljs-keyword">if</span> (ParticleSystemComp != <span class="hljs-literal">nullptr</span>)<br>&#123;<br>ParticleSystemComp-&gt;SetActive(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>UE_LOG(LogTemp, Error, TEXT(<span class="hljs-string">&quot;AOCharacter::StopJumping-ParticleSystemComp is null&quot;</span>));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我这里是直接在Character中进行插槽绑定的，所以先为<code>ThirdPersonCharacter</code>蓝图创建一个C++父类<code>AOCharacter</code>，然后在父类中进行插槽绑定。</p><p>为了将<code>UParticleSystemComponent</code>组件挂载在指定的<code>USkeletalMeshComponent</code>上这里使用<code>ComponentTag</code>标签来做组件的识别标志。</p><p>最终效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311958808.gif"></p><h2 id="7-骨骼重定向"><a href="#7-骨骼重定向" class="headerlink" title="7.骨骼重定向"></a>7.骨骼重定向</h2><h3 id="骨骼重定向的作用"><a href="#骨骼重定向的作用" class="headerlink" title="骨骼重定向的作用"></a>骨骼重定向的作用</h3><p>首先我们需要明白动画的底层规则是什么，动画序列是依附于骨骼创建出来的若干关键帧的组合，这些关键帧中存储着这套骨骼的一些基本信息，所以这个动画序列只能在对应的骨骼上使用，如果想要将这个动画序列使用在另一套不同的骨骼上，由于动画序列中并没有另一套骨骼的信息，或者说信息不匹配，所以就无法应用。</p><p>骨骼重定向技术就是用来解决这个问题的，重定向有一个基础前提，就是源骨骼与目标骨骼必须在整体层级上保持一直，才能进行重定向。</p><p>什么叫做整体层级上保持一致呢？这里用小白人和一个丧尸的骨骼来举例子。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311958895.png"></p><p>可以看到丧尸Hips骨骼的子层级和小白人的pelvis骨骼的子层级基本一致，动画主要使用盆骨，三根脊椎骨，锁骨，手臂骨，小臂骨手指骨，脖子的骨骼，大腿骨，小腿骨以及脚骨，二者在层级上都保持一致，区别只在于丧尸骨骼的手指骨骼被拉长了，盆骨处多了两个服装动画使用的骨骼BackCloth和FrontCloth，而丧尸骨骼相对于小白人缺少了两个IK骨骼。这种情况，尽管骨骼名称不一样，依然属于整体层级上保持一致，二者就可以做重定向来互相使用动画。</p><p>如果拿小白人和一只小狗的骨骼举例子，那么种情况就是整体层级不一致了。</p><p>如果将小白人的动画重定向后应用到丧尸身上，由于小白人的骨骼在丧尸上基本都有，所以动画可以应用，但是由于小白人没有服装骨骼，所以丧尸的服装将不会有动画，丧尸骨骼没有IK骨骼，所以小白人的IK动画在丧尸身上也不会生效。如果将丧尸的动画重定向到小白人身上，同样的道理，动画也可以应用上，但是也是由于小白人缺少服装骨骼，所以丧尸服装骨骼的动画在小白人身上也不会生效。</p><h3 id="如何进行骨骼重定向"><a href="#如何进行骨骼重定向" class="headerlink" title="如何进行骨骼重定向"></a>如何进行骨骼重定向</h3><p>了解了重定向的基本规则之后，我们该如何重定向呢？</p><p>这里我使用外部动画应用到小白人身上为例子来说明。</p><p>这里我们先去网上下载一个动画素材下来，这里可以去Adabo的<a href="https://www.mixamo.com/#/?page=2&type=Character">Mixamo</a>网址去下载动画素材。下载素材需要先登录账号，注册一个登录进去，在Animations下我选择了一个跳舞的动画Rumba Dacing来做素材。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311958905.png"></p><p>点击右侧的DownLoad进行下载，下载下来的文件是一个fbx文件，我们将文件导入进UE，勾选上导入动画，其他的选项全部默认就可以，然后导入全部。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311959205.png"></p><p>导入进来两个材质，一个骨骼网格体，两个动画序列，一个物理资产和一个骨骼资产。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311959748.png"></p><p>来看看动画序列：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311959191.gif"></p><p>我们双击进入骨骼资产，在菜单栏有一个重定向管理器，打开会弹出骨骼重定向编辑视图。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311959765.png"></p><p>点击选择绑定，选择人形绑定，然后在下方我们需要手动的将新导入的骨骼一一的映射到标准的人形骨骼上。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311959131.png"></p><p>这里映射的是基本的身体骨架，点击显示高级项，可以再进行手指和脚步的骨骼映射，一些没有的骨骼可以不映射，设置完之后可以点击保存将映射信息保存下来。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301311959360.png"></p><p>到这一步外部骨骼重定向到标准人体骨骼就完成了。</p><p>然后我们打开小白人的骨骼，同样使用重定向管理器，在选择绑定处也选择人形绑定，然后点击自动映射，因为小白人的骨骼UE就是按照标准骨骼来创建的，所以自动映射可以映射上。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312000195.png"></p><p>然后右键新导入的跳舞动画，选择重定向动画资产/复制动画资产并重定向。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312000534.png"></p><p>这时我们就可以进入真正的骨骼重定向界面。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312000969.png"></p><p>选择我们需要重定向的小白人骨骼，点击重定向，这是UE会自动为我们创建一个重定向后的动画序列。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312000807.gif"></p><p>可以看到动画已经应用到小白人身上了，UE通过标准人体骨骼将外部骨骼的动画重定向到了小白人的骨骼上，但是骨骼位置似乎出现了偏移，这是因为，从Mixamo下载的动画初始姿势是Maya标准的T-Pos姿势，整体上看起来是一个T字，手臂和身体成90度角。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312000892.png"></p><p>而UE的默认初始姿势则不是标准的T-Pos，手臂和身体成45度角。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312001201.png"></p><p>这就会导致重定向时骨骼的变换出现偏差，有两个中处理方案，一种是外部导入的骨骼按照UE的标准制作初始姿势，另一种就是将UE默认的初始姿势修改成Maya的标准T-Pos姿势。由于我不会maya，所以我只能选择后面的一个方案来处理了。</p><h3 id="修复小白人位姿偏移"><a href="#修复小白人位姿偏移" class="headerlink" title="修复小白人位姿偏移"></a>修复小白人位姿偏移</h3><p>这里我使用Mixamo来将小白人的姿势改为T-Pos。</p><p>首先将小白人的骨骼网格体导出来。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312001041.png"></p><p>兼容格式要选择2013以下，静态网格体中的碰撞不需要导出可以取消勾选。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312001039.png"></p><p>然后我们再次进入<a href="https://www.mixamo.com/#/?page=1&type=Motion%2CMotionPack">Mixamo</a>点击右侧的Upload Character，把我们的导出的网格体上传到Mixamo，上传完成后小白人的模型就可以在Mixamo中浏览了。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312001032.png"></p><p>然后在Animations下搜索T-Pose，点击T-Pose动作，小白人就应用上了T-Pose动作。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312001606.png"></p><p>然后再把小白人下载下来并导入UE中，会直接导入一个名字叫T-Pose的动画序列。右键这个动画序列/创建/创建姿势资产。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312001620.png"></p><p>然后打开小白人的骨骼，在重定向管理器视图选择修改姿势，导入我们刚创建的姿势资产，然后点击查看姿势，我们新的T-Pos姿势就应用到了小白人身上，现在我们再重定向一次，直接右键跳舞动画/重定向动画资产/复制动画资产并重定向，让UE重新创建一个动画序列，然后来看看效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312001914.gif"></p><p>效果还可以。</p><h3 id="重定向链"><a href="#重定向链" class="headerlink" title="重定向链"></a>重定向链</h3><p>这是UE5的新功能，IK Rig和IK Retargeter在做骨骼重定向的时候可以以一条骨骼链的形式来进行链与链的重定向并且通过IK重定向器直接使用名字进行映射，可以省去重定向过程中的很多麻烦操作。</p><p>这里我使用从<a href="https://www.aplaybox.com/details/model/vLy9oQVdjFXj">模之屋</a>下载的看板娘的模型套用到小白人身上作为例子。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312002359.png"></p><p>首先从模之屋下载MMD模型，这里下载的模型是.pmx格式的，不能直接应用到UE中，所以需要先把.pmx格式的文件转换成.fbx，这里使用了一个<a href="http://stereoarts.jp/">日本大佬</a>从一个Unity插件中提取出来的工具(pmx2fbx)进行转换，国内也有很多帮运，如：<a href="https://www.bilibili.com/video/BV11K4y1G7DL/?vd_source=e979466844c4915a4200c496efb35cfb">https://www.bilibili.com/video/BV11K4y1G7DL/?vd_source=e979466844c4915a4200c496efb35cfb</a></p><p>使用方法也很简单，输入指令将下载好的mmd模型转换为UE可识别的fbx文件，然后导入到UE。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312002900.png"></p><p>导入进来的模型会自带很多空白材质，需要我们自己导入模型自带的贴图修复，这里就先使用白模了。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312002959.png"></p><p>首先<code>右键/动画/IK绑定/IK绑定</code>为我们新导入的模型骨骼创建一个IK绑定，选择我们新导入的骨骼网格体perer_41，并命名为IKRing_Per。</p><p>然后在IK编辑器里选择骨骼右键/新建来自选定骨骼的重定向链，在弹出的界面点击确定，这是UE会提示我们为骨骼链添加IK目标，由于现在还没有目标，所以选择无目标，这样一条骨骼链就创建好了。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312002430.png"></p><p>这里我没有重定向手指，只重定向了几个主要的骨骼，下面列出我重定向的骨骼链及其涉及骨骼的名称：</p><table><thead><tr><th>骨骼链名称</th><th>涉及骨骼</th></tr></thead><tbody><tr><td>Root</td><td>263_!Root</td></tr><tr><td>Spine</td><td>12_joint_Torso</td></tr><tr><td></td><td>13_joint_Torso2</td></tr><tr><td>Head</td><td>19_joint_Neck</td></tr><tr><td></td><td>21_joint_Head</td></tr><tr><td>LeftArm</td><td>61_joint_LeftArm</td></tr><tr><td></td><td>66_joint_LeftElbow</td></tr><tr><td></td><td>71_joint_LeftWrist</td></tr><tr><td>RightArm</td><td>25_joint_RightArm</td></tr><tr><td></td><td>30_joint_RightElbow</td></tr><tr><td></td><td>35_joint_RightWrist</td></tr><tr><td>LeftLeg</td><td>115_joint_LeftHipD</td></tr><tr><td></td><td>116_joint_LeftKneeD</td></tr><tr><td></td><td>117_joint_LeftFootD</td></tr><tr><td></td><td>118_!joint_hidariashisakiEX</td></tr><tr><td>RightLeg</td><td>111_joint_RightHipD</td></tr><tr><td></td><td>112_joint_RightKneeD</td></tr><tr><td></td><td>113_joint_RightFootD</td></tr><tr><td></td><td>114_!joint_migiashisakiEX</td></tr><tr><td>LeftClavicle</td><td>59_joint_LeftShoulder</td></tr><tr><td>RightClavicle</td><td>23_joint_RightShoulder</td></tr></tbody></table><p>盆骨(14_joint_HipMaster)比较特殊，不用创建骨骼链，但是要设置为重定向根。</p><p>然后为小白人也创建一个IK绑定，命名为IKRing_SK，按照一样的逻辑创建对应的骨骼链和设定重定向根：</p><table><thead><tr><th>骨骼链名称</th><th>涉及骨骼</th></tr></thead><tbody><tr><td>Root</td><td>root</td></tr><tr><td>Spine</td><td>spine_01</td></tr><tr><td></td><td>spine_02</td></tr><tr><td></td><td>spine_03</td></tr><tr><td></td><td>spine_04</td></tr><tr><td></td><td>spine_05</td></tr><tr><td>Head</td><td>neck_01</td></tr><tr><td></td><td>neck_02</td></tr><tr><td></td><td>head</td></tr><tr><td>LeftArm</td><td>upperarm_l</td></tr><tr><td></td><td>lowerarm_l</td></tr><tr><td></td><td>hand_l</td></tr><tr><td>RightArm</td><td>upperarm_r</td></tr><tr><td></td><td>lowerarm_r</td></tr><tr><td></td><td>hand_r</td></tr><tr><td>LeftLeg</td><td>thigh_l</td></tr><tr><td></td><td>calf_l</td></tr><tr><td></td><td>foot_l</td></tr><tr><td></td><td>ball_l</td></tr><tr><td>RightLeg</td><td>thigh_r</td></tr><tr><td></td><td>calf_r</td></tr><tr><td></td><td>foot_r</td></tr><tr><td></td><td>ball_r</td></tr><tr><td>LeftClavicle</td><td>clavicle_l</td></tr><tr><td>RightClavicle</td><td>clavicle_r</td></tr></tbody></table><p>然后再右键/动画/IK绑定/IK重定向器，在弹出的界面中选择IKRing_Per作为源，然后进入IK重定向器编辑视图。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312002184.png"></p><p>在细节面板设置目标为IKRing_SK，为了重定向效果更好，我们需要将目标骨骼的姿势尽量修改得和源骨骼一致，在左侧点击编辑模式可以直接修改骨骼偏移来对姿势进行编辑，可以修改目标网格体偏移来设置源骨骼与目标骨骼的重合与分离。</p><p>全部设置好之后，我们就可以在资产浏览器中选择一个动画序列来看看重定向之后的效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312002798.gif"></p><p>看起来效果还不错。</p><p>重定向好之后我们要怎么把模型应用到小白人身上呢？</p><p>在应用到小白人之前我们先给人物上一下材质和布料(布料可以查看第三章骨骼网格体第2小节布料系统)，这样好看点，做起来也有动力😍。</p><p>过程就直接省略了，直接看效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312002527.gif"></p><p>首先我们要为新角色创建一个动画蓝图，创建的时候要选择新角色的骨骼，这里命名为Anim_Per：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312003973.png"></p><p>从网格体重定向姿势(Retarget Pose From Mesh)应该是UE5专门为数字人添加的节点，我在UE4.27中搜不到这个节点，Retarget Pose From Mesh可以从一个骨骼网格体复制动画数据到当前骨骼网格体，因为动画序列在不同的骨骼上是不兼容的，Retarget Pose From Mesh可以让一套骨骼便捷的使用另一套骨骼的动画序列，使用上需要在Details/Settings/IKRetarfeterAsset中设置我们配置好的IK重定向器。然后我们拷贝一个第三人模板的角色蓝图，在已有的骨骼网格体Mesh下新建一个骨骼网格体，并设置好我们的角色资产和动画蓝图。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312003589.png"></p><p>然后将两个骨骼网格体的Details/Optimization/Visibility Based Anim Tick Option选项设置为Always Ticj Pose and Refresh Bones，这时我们的新角色就可以跟着第三人称模板的角色做动作了，然后把Mesh隐藏起来，然后跑起来看看效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312003712.gif"></p><p>看起来阴影有点问题，不过这是另一个问题了，这里就不用在意了。</p><h3 id="导出重定向动画"><a href="#导出重定向动画" class="headerlink" title="导出重定向动画"></a>导出重定向动画</h3><p>这个方法是可以不一个个重定向动画序列的方式，当然这也导致我们的角色蓝图离不开父骨骼，如果我们想使用角色自己的独立动画序列资源，则在重定向编辑器中选择我们需要重定向的动画序列，点击资产浏览器下的导出选定动画即可，或者也可直接右键动画序列资产/重定向动画资产/复制和重定向动画资产，然后在重定向视图选择重定向器。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312003258.png"></p><h1 id="三、骨骼网格体"><a href="#三、骨骼网格体" class="headerlink" title="三、骨骼网格体"></a>三、骨骼网格体</h1><h2 id="1-骨骼网格体转静态网格体"><a href="#1-骨骼网格体转静态网格体" class="headerlink" title="1.骨骼网格体转静态网格体"></a>1.骨骼网格体转静态网格体</h2><p>有时我们可能需要一些人物的Pose在做一些宣传图或者在游戏中做一些雕像之类的，骨骼网格体转静态网格体可以方便达成这些功能，其作用是将我们在骨骼编辑器中编辑好的临时姿势保存起来，因为骨骼编辑器可以编辑骨骼转向和偏移，但是都是临时的，我们可以将编辑好的姿势保存为静态网格体，这样以后就可以在任何需要的地方使用了。</p><p>做法也比较简单，在骨骼编辑器中将人物的姿势编辑好，然后直接点击菜单栏的Make Static Mesh即可将姿势保存为静态网格体。</p><h2 id="2-布料系统"><a href="#2-布料系统" class="headerlink" title="2.布料系统"></a>2.布料系统</h2><p>UE是自带了一套布料系统的，虽然效果上不是很优秀，不过也可以应付一些基本需求了。这里之所以把布料系统放在骨骼网格体章节下，是因为UE的布料是基于骨骼网格体的，并且UE的布料系统内容也不多。</p><p>这里说的布料系统基于骨骼网格体的意思是，UE的布料系统只能应用在Skeletal Mesh上，普通的Static Mesh是不能使用UE的布料系统的，这就要求所有要引用布料的模型都需要至少附带一根骨骼。</p><p>这里我们继续使用第二章中的MMD模型Perer来学习布料系统。布料编辑器是和骨骼网格体编辑集成在一起的，对布料的编辑就是直接在骨骼网格体编辑器中进行。</p><h3 id="创建衣服数据"><a href="#创建衣服数据" class="headerlink" title="创建衣服数据"></a>创建衣服数据</h3><p>布料的一些基础信息UE使用了ClothingData资产来存储，直接在骨骼网格体编辑器中选中要创建衣服数据的网格体/右键/Create Clothing Data from Section。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312003097.png"></p><p>AssetName可以修改衣服数据资产的名称，PhyiscsAsset可以选择衣服数据绑定的物理资产。</p><p>然后UE会自动打开Clothing管理窗口，当然我们也可以在Windows下手动打开Clothing窗口然后在ClothingData栏中点击Add Clothing来添加衣服数据。</p><h3 id="应用衣服数据"><a href="#应用衣服数据" class="headerlink" title="应用衣服数据"></a>应用衣服数据</h3><p>ClothingData只是一个存储布料数据的资产，我还需要将资产应用到骨骼网格体上，选中要应用的骨骼网格体/右键/Apply Clothong Data，然后选择想要的资产应用。此时衣服上就有布料数据了，当然现在还没有布料效果，因为我们还没往ClothingData中刷入布料权重信息。</p><h3 id="刷布料权重"><a href="#刷布料权重" class="headerlink" title="刷布料权重"></a>刷布料权重</h3><p>点击菜单栏的Activate Cloth Paint，此时衣服骨骼网格体变成紫红色并显示网格，鼠标上到上边会出现绿色的笔刷，Clothing视图会多出很多配置选项，左上角会多出一个笔刷范围内的顶点的布料权重值Cloth Value。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312003557.png"></p><p>在Clothing视图下我们需要关注一般只有的Tool Settings/Paint Value和Brush/Radius，前者设置的笔刷将赋予骨骼网格体的布料权重，默认值范围为0-100，超出范围的值需要手动输入，值越大代表权重越大，权重越大布料受物理系统影响越大，0就是不受物理系统影响，在骨骼网格体上表现为紫红色，受影响的部分变现为半透明灰色，中间值显示为黑色。</p><p>在刷权重的过程中可以按H键预览布料效果，或则取消激活Activate Cloth Paint也可以看效果。</p><p>有时候布料刷完之后表现起来可能怪怪的，这是因为布料受到物理资产的影响，布料会直接收到物理资产中的碰撞的碰撞影响，如果布料表现怪怪的我们可以调节一下物理资产中碰撞体大小和方位。</p><p>一个好的布料效果需要模型和布料经过大量的微调才行，一般来说网格体的点越多布料效果越好，但是也会越吃性能，具体项目需要在具体实践中找到平衡。</p><p>然后在给裙子也刷上布料就可以达到这个效果了：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312004961.gif"></p><p>UE的布料系统也包含很多内容，由于已经不在动画系统范畴，这里就只看这么多了，更多了留到以后再看。</p><h1 id="四、物理资产"><a href="#四、物理资产" class="headerlink" title="四、物理资产"></a>四、物理资产</h1><p>物理资产是专门用于骨骼网格体和布料系统做物理模拟的资产。</p><p>关于物理资产编辑器的界面的介绍可以看这篇文章：<a href="https://zhuanlan.zhihu.com/p/90983975">UE4物理精粹Part 2：Physics Assets Tool详解 - 知乎 (zhihu.com)</a></p><h2 id="1-创建物理资产"><a href="#1-创建物理资产" class="headerlink" title="1.创建物理资产"></a>1.创建物理资产</h2><p>物理资产可以在导入模型时勾选Create Physics Asset选项然UE根据骨骼创建默认的物理资产，也可以右键/Physics/Physics Asset来手动创建物理资产，手动创建物理资产时会让我们选择绑定骨骼，并且第一次打开时会然我们设置物理资产的约束。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312004044.png"></p><h2 id="2-物理形体"><a href="#2-物理形体" class="headerlink" title="2.物理形体"></a>2.物理形体</h2><p>我们打开物理资产看到的一个个的胶囊体就是物理形体，UE通过这些物理形体来实现骨骼之间的物理碰撞。</p><h3 id="创建物理形体"><a href="#创建物理形体" class="headerlink" title="创建物理形体"></a>创建物理形体</h3><p>一般我们在导入模型或者手动创建物理资产后UE会为物理资产默认生成一套物理形体，一般不需要我们手动创建，当然如果我们角色UE默认创建的不好、物理形体丢失或者想要增加一些形体也是可以手动创建的。</p><p>如果物理形体丢失了，在物理资产编辑器视图的Tools视图中<code>Generate All Bodies</code>按钮，在保证当前没有选择任何形体或骨骼的前提下，点击即可从新生成一套UE默认的物理形体组合。</p><p>如果想要增加物理形体，我们需要在Skeleton Tree视图选中想要添加形体的骨骼，然后点击Tools视图的<code>Add Bodies</code>按钮，这个按钮添加的形体是默认的胶囊体样式，如果想要添加其他样式(如正方体)，则右键骨骼/Add Shape，然后选择想要的样式即可。默认情况下物理资产编辑视图的Skeleton Tree视图好像是只显示形体而不显示骨骼的，我们需要点击Skeleton Tree右侧的设置图标选择Show All Bones才能看到所有的骨骼。</p><h3 id="物理形体的属性"><a href="#物理形体的属性" class="headerlink" title="物理形体的属性"></a>物理形体的属性</h3><p>物理形体的属性相当的多，就不一一列举了，可以直接查看[官方文档](<a href="https://docs.unrealengine.com/5.0/zh-CN/physics-bodies-reference-for-unreal-engine/">虚幻引擎物理形体参考 | 虚幻引擎5.0文档 (unrealengine.com)</a>)。</p><h2 id="3-物理约束"><a href="#3-物理约束" class="headerlink" title="3.物理约束"></a>3.物理约束</h2><p>物理约束本质上一种连接点，利用物理约束可以通过约束应用的限制和力度将多个Actors连接起来，如：绳索、吊桥等。</p><p>UE的物理约束系统是一个独立的系统，动画系统中的骨骼物理约束只是发动画系统对物理约束系统的应用。</p><p>在学习骨骼约束之前我们首先应该对物理约束系统有一个基础的了解。</p><h3 id="物理动画"><a href="#物理动画" class="headerlink" title="物理动画"></a>物理动画</h3><p>有了物理约束自然也就可以实现一些物理动画了，UE预制了一些物理约束Actor可供我们实现一些简单的物理动画。</p><p><strong>PhysicsConstraintActor</strong></p><p>物理约束对象(PhysicsConstraintActor)是一个连接点，可以对连接上连接点头尾的StaticMesh进行物理约束，如我们可以使用PhysicsConstraintActor创建一个具有物理惯性的下垂摆动动画：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312004927.gif"></p><p>使用方法也比较简单，PlaceActor中找到PhysicsConstraintActor拖入场景中，然后在Details/Constraint的Constraint Actor 1和Constraint Actor 2分别选择两个StaticMeshActor，设置需要摆动的方块启用物理模拟，并且Mobility设置为Moveable，运行后这个方块就会因为重力向下坠落，但由于受到PhysicsConstraintActor的物理约束，方块就会在物理约束下摆动，然后随着重力作用慢慢停止运动。</p><p>这里有一点需要注意，PhysicsConstraintActor只能约束StaticMesh，在选择头尾Actor时如果Actor是StaticMesh那么只需要选择约束Actor就可以实现约束了，如果Actor就是普通蓝图Actor则除了选择约束Actor还需要指定约束的StaticMesh组件名称。</p><p><strong>CableActor</strong></p><p>缆索是UE预制的绳子Actor，可以很便捷是制作出绳子的效果，这里还是使用上面的例子，但是两个Cube换成自定义的Actor，在加上CableActor来看看效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312004126.gif"></p><p>CableActor和PhysicsConstraintActor的用法差不多，也是从PlaceActor中找到然后拖入场景，然后在Details/Cable/Attach End To选择缆索末端的Actor，同样CableActor也只能约束StaticMesh，所以使用自定义Actor时需要指定ComponentName，预制的CableActor由一个空的CableActor和一个CableComponent组件组成，CableActor所在的位置为绳子头部，CableComponent所在的位置为绳子尾部。</p><p><strong>PhysicsThruster</strong></p><p>UE预制的在PlaceActor中的物理推进器Actor我没有研究出有什么用，可能有效果只是PhysicsThruster自身不可视我们看不到效果，不过我们可以从PhysicsThrusterComponent中窥见一二。我们只需要向自定义Actor中添加一个PhysicsThrusterComponent组件，然后勾选PhysicsThrusterComponent的Details/Activation/Auto Activate，然后Actor给与一个StaticMesh并启用物理模拟，物理推进器就可以推着Actor运动了，物理推进器组件会给与Actor一个持续的力，可以看一下有趣实践：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312004297.gif"></p><p>上面三种UE预制的物理约束都由组件，另外一些物理约束只以组件的形式出现。</p><p><strong>PhysicsHandleComponent</strong></p><p>物理柄组件是UE预制的专门用于制作物品抓取效果的组件，使用物理柄组件可以很方便快捷的实现任何具备物理效果的物体的抓取。</p><p>先来看一下效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312005442.gif"></p><p>实现上也比较方便，我们自己要实现的就是获取要抓取的Actor，和设置Actor跟随人物视角运动，其他就可以全交给PhysicsHandle组件了。这里我使用了继承自DefaultPawn的自定义Pawn来作为可控角色。全部蓝图如下：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312006964.png"></p><p><strong>PhysicalAnimationComponent</strong></p><p>物理动画组件是用来设置角色在被Controller控制的同时也能被物理系统控制，一般需要配合布娃娃系统使用，如双手或身体的物理下垂，以实现“人类一败涂地”中的角色效果，用法其实也很简单，这里用一个案例来说明。</p><p>这里用第三人称模板来实践，首先为角色蓝图添加物理动画组件，然后在游戏开始时配置组件数据并启用布娃娃系统。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312006961.png"></p><ul><li>Set Skeletal Mesh Component：为物理动画组件指定需要应用物理动画的骨骼网格体；</li><li>Apply Physical Animation Settings Below：使指定骨骼及其所有子骨骼应用指定的物理动画数据；</li><li>Set All Bodies Below Simulate Physics：启动布娃娃系统，需要注意的是Include Self需要取消勾选；</li><li>然后碰撞体组件的Details/Collision/Collision Presets设置为IgnoreOnlyPawn，骨骼网格体的Details/Collision/Collision Presets设置为Pawn。</li></ul><p>然后看看效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312006951.gif"></p><p><strong>DestructibleComponent</strong></p><p>可摧毁组件专门用于制作破碎效果，组件用于存储可摧毁物体的物理数据，当然只有DestructibleMesh才可以制作破碎效果。</p><p><strong>RadialForceComponent</strong></p><p>径向力组件用于发出径向力或脉冲来影响物理对象或可摧毁对象的，径向力组件发出的力是瞬发的，发出后将不再持续。</p><p>DestructibleComponent和RadialForceComponent都涉及到物理破碎的知识，有点扯远了，这里也不多累述了。</p><h2 id="4-布娃娃系统"><a href="#4-布娃娃系统" class="headerlink" title="4.布娃娃系统"></a>4.布娃娃系统</h2><p>要制作一个简单的布娃娃效果其实不难，UE已经为我们制作好了网格体的布娃娃效果，应用布娃娃效果的网格体必须绑定物理资产，然后我们就可以直接通过Set All Bodies Below Simulate Physics节点启用和关闭布娃娃系统了，当我们在控制角色上启用布娃娃系统时SkeletalMesh将直接交由UE的物理系统控制，此时Pawn将失去对SkeletalMesh的控制。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312006662.png"></p><ul><li>Target：要应用布娃娃系统的网格体，可以是静态网格体也可以是骨骼网格体；</li><li>In Bone Name：启用布娃娃系统的骨骼名称，指定名称往下的所有子骨骼都会启用布娃娃系统，如我们指定肩锁骨则整个手臂都会启用布娃娃系统，如果指定root则全身启用布娃娃系统；</li><li>New Simulate：启用或关闭布娃娃系统；</li><li>Include Self：具体是什么作用不清楚，官方文档没有说明，引擎源码也没有说明。</li></ul><p>我们还可以通过Set All Bodies Below Physics Blend Weight节点来设置布娃娃系统与动画系统的控制权重，不设置默认权重为1，即启动后完全由物理系统控制角色动画。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312006612.png"></p><p>然后我们来做一个简单的布娃娃系统。</p><p>首先编辑角色蓝图：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312006864.png"></p><p>当角色掉落到地面时启用布娃娃系统，并设置权重为1。</p><p>然后碰撞体组件的Details/Collision/Collision Presets设置为IgnoreOnlyPawn，骨骼网格体的Details/Collision/Collision Presets设置为Pawn，然年看看效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312006763.gif"></p><h1 id="五、动画序列"><a href="#五、动画序列" class="headerlink" title="五、动画序列"></a>五、动画序列</h1><p>动画序列(AnimationSequence)是依附于骨骼的独立的动画资源，序列中大量的骨骼关键帧。是动画混合、动画合成、姿势资产和IK等的基础资源。</p><h2 id="1-动画曲线"><a href="#1-动画曲线" class="headerlink" title="1.动画曲线"></a>1.动画曲线</h2><p>动画曲线就是以动画序列的帧数为X轴，以其他类型的值为Y轴的二维函数曲线，动画曲线没有什么特殊的意义，只是根据动画序列的帧数变化提供一个变化的值。</p><h3 id="动画曲线的创建与编辑"><a href="#动画曲线的创建与编辑" class="headerlink" title="动画曲线的创建与编辑"></a>动画曲线的创建与编辑</h3><p>动画曲线在动画序列编辑界面创建，单击Curves的下拉三角选择Add Curve/Create Curve。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312007908.png"></p><p>单击曲线的下拉三角选择Edit Curve或者双击曲线可进入曲线的编辑视图。</p><h3 id="动画曲线管理"><a href="#动画曲线管理" class="headerlink" title="动画曲线管理"></a>动画曲线管理</h3><p>在骨骼编辑器、动画序列编辑器和动画蓝图的菜单栏选择Window/Anim Curves可以打开动画曲线管理视图，在动画曲线管理视图可以对曲线进行筛选管理，是否激活材质参数以及编辑曲线的属性。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312007197.png"></p><h3 id="元数据曲线"><a href="#元数据曲线" class="headerlink" title="元数据曲线"></a>元数据曲线</h3><p>在创建曲线时我们能看到一个Add Metadata选项，这个就是用来创建元数据曲线的按钮，元数据曲线就是一个特殊的动画曲线，元素据曲线是一根Y值为常量1的曲线，即Y值永远为1，不随X轴变化而变化，且不可修改。</p><p>按照官方的解释是，在大多情况下动画使用的曲线都是常量值为1的曲线，只有少数情况会用到值变化的曲线，所以才有了元数据曲线。</p><h3 id="动画曲线的使用"><a href="#动画曲线的使用" class="headerlink" title="动画曲线的使用"></a>动画曲线的使用</h3><p>这里以一个人物跳起时脚变大的麒麟腿效果为例子。</p><p>这里使用的是第三人称模板，在ThirdPersonJump_Start动画序列中添加曲线FootCurve，并添加(0.1,1)、(0.2,2)两个关键帧，在ThirdPersonJump_Loop动画序列中添加曲线FootCurve，并添加关键帧(0,2)，在ThirdPersonJump_End动画序列中添加曲线FootCurve，并添加关键帧(0,2)、(0.2,1)。</p><p>这里所有动画序列都使用相同名称的曲线的一个好处是在动画蓝图中可以使用同一个名称来获取不同动画序列中的这个名称的曲线的值。</p><p>动画蓝图在播放到某一个动画序列时，通过名称来获取当前播放的动画序列的曲线的值。</p><p>在动画蓝图的JumpStart状态，JumpLoop状态，JumpEnd状态分别写入如下蓝图逻辑：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312007517.png"></p><p>其中Transform(Modify)Bone节点做如下设置：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312007116.png"></p><p>Transform(Modify)Bone是骨骼变换节点，可以对骨骼做位移，旋转和缩放变换，在Skeletal Control/Bone to Modify绑定骨骼既可对绑定骨骼做变换控制。</p><p>三者的不同在于播放各自的动画序列，JumpStart状态播放ThirdPersonJump_Start动画，JumpLoop播放ThirdPersonJump_Loop动画，JumpEnd播放ThirdPersonJump_End动画。</p><p>运行效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312007878.gif"></p><h3 id="其他曲线节点"><a href="#其他曲线节点" class="headerlink" title="其他曲线节点"></a>其他曲线节点</h3><p>对曲线的获取除了上面用到的GetCurveValue节点，还有GetAllCurveNames和GetActiveCurveNames两个节点。</p><h2 id="2-动画通知"><a href="#2-动画通知" class="headerlink" title="2.动画通知"></a>2.动画通知</h2><p>动画通知(Anim Notify)，是一种动画回调程序逻辑的机制，在动画的序列帧中绑定通知点，当动画播放到指定帧时就会触发函数回调，通知游戏逻辑。</p><h3 id="动画通知的创建"><a href="#动画通知的创建" class="headerlink" title="动画通知的创建"></a>动画通知的创建</h3><p>动画通知的创建比较简单，再动画序列编辑器中的时间轴旁有一个Notifies栏，右键时间轴/Add Notify/New Notify，然后为动画通知命名，就可以在对应的通知栏创建一个动画通知。</p><p>每一个动画序列在被创建时会默认创建一个名称为1的动画通知栏，动画通知栏只是用来分类管理动画通知的，就如同蓝图变量里的Category。</p><p>在同一个通知栏同一帧处可以触发多个动画通知，一般同一栏同一帧处要触发多个动画通知的时候采用分栏管理会比较方便管理，点击Notifies的下拉三角/Add Notify Track可以增加新的分栏。</p><h3 id="动画通知的回调"><a href="#动画通知的回调" class="headerlink" title="动画通知的回调"></a>动画通知的回调</h3><p>动画通知创建好后，编译完就可以直接在与动画序列绑定的动画蓝图中直接搜索到动画通知事件，动画通知被创建好后动画系统会为动画蓝图创建对应的名为<code>AnimNotify_&lt;动画通知名&gt;</code>的蓝图事件，当角色动画播放到动画通知所在的动画序列的关键帧时对应的通知事件会被动画系统触发，然后我们就可以在动画蓝图中处理逻辑，或者通过调度器将通知传递到其他蓝图，或者直接引用其他蓝图的对象将通知传递出去。</p><h3 id="在C-中使用动画通知"><a href="#在C-中使用动画通知" class="headerlink" title="在C++中使用动画通知"></a>在C++中使用动画通知</h3><p>动画通知是依赖于动画实例(AnimInstance)而存在的，所以我们要想在C++中使用动画通知，就得先在C++中创建动画实例，然后再在实例中创建动画通知。</p><p>创建一个继承自UAnimInstance的自定义动画实例，在类中添加一个<code>void AnimNotify_XXX(UAnimNotify* Notify)</code>格式的函数，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//.h</span><br>UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OTHERWORLDLYKINGDOM_API</span> <span class="hljs-title">UOAminInstacne</span> :</span> <span class="hljs-keyword">public</span> UAnimInstance<br>&#123;<br>GENERATED_BODY()<br><span class="hljs-keyword">public</span>:<br>UFUNCTION()<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AnimNotify_Jump</span><span class="hljs-params">(UAnimNotify* Notify)</span></span>;<br>&#125;;<br><span class="hljs-comment">//.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UOAminInstacne::AnimNotify_Jump</span><span class="hljs-params">(UAnimNotify* Notify)</span></span><br><span class="hljs-function"></span>&#123;<br>    UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Jump&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有几点需要注意，函数必须是<code>void AnimNotify_XXX(UAnimNotify* Notify)</code>格式，XXX对应的是动画通知的名字，动画系统会自动将这个函数与名字对应的动画通知相绑定，函数返回值必须是void，否则当动画通知回调时会触发警告：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran">LogAnimNotify: Warning: Anim notifier <span class="hljs-keyword">named</span> AnimNotify_JumpStart, but the <span class="hljs-keyword">parameter</span> <span class="hljs-keyword">number</span> does not match or not of the correct <span class="hljs-keyword">type</span><br></code></pre></td></tr></table></figure><p>并且函数必须使用<code>UFUNCTION()</code>加入反射系统，否则动画系统将找不到函数与对应的动画通知相绑定。</p><p>创建好动画实例后，只需要在ThirdPerson_AnimBP的Class Settings的Details/Class Options/Parent Class下把父类改成我们自己创建的类，第三人称模板的动画蓝图就继承自我们自己创建的AnimInstance了，然后再在动画序列中创建一个与动画回调AnimNotify_Jump对应的动画通知Jump，当动画播放到动画通知所在的动画序列的关键帧处时就会自动触发C++中的动画回调函数，这样动画通知的信号就传递到了C++，当如果我们不想使用C++的AnimInstance我们也可以使用动画通知的蓝图回调事件加C++动态代理来实现这一功能。</p><h3 id="自定义动画通知"><a href="#自定义动画通知" class="headerlink" title="自定义动画通知"></a>自定义动画通知</h3><p>除了使用自定义的动画蓝图外，我们也可以使用自定义的动画通知，我们只需要创建一个继承自UAnimNotify的蓝图类或C++类，动画系统就会将自定义的动画通知注册进系统，我们就可以在动画序列编辑器中看到自定义的动画通知了，如：创建一个名叫AnimNotify_JumpStart的自定义动画通知，然后我们就可以在动画序列里看到这个预定义通知：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312008544.png"></p><p>自定义类中提供了<code>Received_Notify</code>函数的重写，这样我们在接受到动画通知时可以做一些通用的处理逻辑。自定义的动画通知在被回调时直接进入Received_Notify接口，通过这个接口来处理逻辑，因此UE就将自定义动画通知的回调事件从动画蓝图中略去了，所以在动画蓝图中我们搜不到自定义通知的回调事件，因此自定义动画通知无法在动画蓝图中使用。并且自定义动画通知也不会显示在骨骼编辑器的Animation Notifies中显示。</p><h3 id="骨骼通知"><a href="#骨骼通知" class="headerlink" title="骨骼通知"></a>骨骼通知</h3><p>骨骼通知实际上和动画通知是一回事，我们创建一个动画通知时，动画通知是保存在骨骼资产里的，这也是为什么我添加动画通知时，骨骼资产会出现修改后的*号，我们添加的动画通知可以在骨骼编辑器的Animation Notifies视图下看到，如之前添加Jump通知。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312008432.png"></p><p>我们添加骨骼通知时可以检索到骨骼资产里保存的所有的通知。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312008744.png"></p><p>由于通知并不存储在动画序列里而是存储在骨骼资产里，所以我们在动画序列里删除的通知只是删除了通知的引用而并没有删除通知本身，我需要到骨骼资产里删除才是删除通知本身。</p><h3 id="通知状态"><a href="#通知状态" class="headerlink" title="通知状态"></a>通知状态</h3><p>通知状态应该交动画状态通知可能更合理，其实就是一种持续的动画通知，普通的动画通知是在动画运行到指定关键帧时进行一次调用，而通知状态则是可以跨多帧并且在通知所跨的每一帧都会进行通知，UE为我们预制了几个粒子特效播放的通知状态：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312008826.png"></p><p>可以很便捷通过动画来触发一些粒子效果，比如人物走动时的烟尘效果。</p><ul><li>Trail：用来制作有运动轨迹的特效；</li><li>Timed Particle Effect：用来播放老的粒子特效；</li><li>Timed Niagara Effect：用来播放新的粒子特效；</li><li>Advanced Timed Niagara Effect：可定时的粒子播放，只适用于新的粒子特效。</li></ul><p>这里我们来使用Timed Particle Effect制作一个人物跑动时脚底冒火的效果。</p><p>分别在两个脚底骨骼ball_l和ball_r下创建两个插槽ball_lSocket和ball_rSocket，然后创建两个通知状态，并分别设置好触发时间、播放的粒子特效、绑定的插槽名称和插槽的缩放。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312008402.png"></p><p>然后就可以跑起来看效果了：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312008080.gif"></p><h3 id="自定义通知状态"><a href="#自定义通知状态" class="headerlink" title="自定义通知状态"></a>自定义通知状态</h3><p>官方预制的几个通知状态虽然用起来很便捷，但是功能却很单一，大多数时候还是得使用自定义的通知状态。</p><p>自定义的通知状态需要继承AnimNotifyState，我们直接创建一个继承自AnimNotifyState的蓝图类并命名为AnimNotifyState_Jump，自定义通知状态就注册进了动画系统，这时我们就可以在动画序列里看到自定义的动画通知了。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312009478.png"></p><p>AnimNotifyState蓝图类是一个UObject类，并且蓝图编辑视图中没有Graphs视图，这就意味着AnimNotifyState蓝图类不能创建自定义事件，自定义动画通知状态的入口主要就是三个函数重载，<code>Received_NotifyBegin</code>、<code>Received_NOtifyEnd</code>和<code>Received_NotifyTick</code>分别由动画系统在通知状态的开始帧、结束帧和每一帧中调用。在这三个函数接口中我们就可以在动画播放的指定时刻处理自定义的游戏逻辑。</p><h3 id="动画同步标记"><a href="#动画同步标记" class="headerlink" title="动画同步标记"></a>动画同步标记</h3><p>动画同步标记的资料目前我只在<a href="https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/SkeletalMeshAnimation/Sequences/Notifies/">官方文档</a>有找到，看来看去也没看明白怎么用，只知道动画同步标记是用来同步两个动画序列的，自己测试好像也没有看出有什么效果。</p><h1 id="六、姿势资产"><a href="#六、姿势资产" class="headerlink" title="六、姿势资产"></a>六、姿势资产</h1><p>姿势资产(PoseAsset)是UE专门创建出来用于FACS(面部行为编码系统)和视位曲线驱动姿势的面捕动画(也就是我们俗称的面部捕捉)的资产，姿势资产一般配合变形目标一起使用，变形目标提供网格体变形的能力，而姿势资产则可以将这种变形动画混合进入动画蓝图中。</p><h2 id="1-创建姿势"><a href="#1-创建姿势" class="headerlink" title="1.创建姿势"></a>1.创建姿势</h2><p>姿势必须依赖于某一个动画序列而存在，我们可以右键动画序列，在Create/Create PoseAsset下创建与指定动画序列绑定的姿势，或者右键空白处Animation/PoseAsset，然后在姿势创建视图绑定动画序列来创建一个姿势。</p><p>创建好姿势后，在姿势编辑器界面中会附带很多的Pose，动画序列每有一个关键帧，姿势资产便会创建一个Pose，这些Pose就是附加在骨骼数据里的曲线。</p><h2 id="2-变形目标"><a href="#2-变形目标" class="headerlink" title="2.变形目标"></a>2.变形目标</h2><p>变形目标(MorphTargets)实际上是建模中的一种术语，变形目标和骨骼动画有点类似，都是通过FBX导入，并且都自带网格体资产、动画序列资产和骨骼资产，不同的是变形目标还自带动画曲线。变形目标自带的曲线需要在建模时就名好名字，在UE中无法修改曲线名称。</p><p>导入变形目标的FBX是需要勾选<code>网格体/导入变形目标</code>选项，否则导入的FBX将作为普通骨骼网格体导入。</p><p>变形目标导入成功后，我们可以在骨骼网格体编辑器的<code>窗口/变形目标预览器</code>视图中看到变形目标自带的所有曲线，修改曲线值可以更改变形目标的形态。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312009261.png"></p><h2 id="3-使用姿势"><a href="#3-使用姿势" class="headerlink" title="3.使用姿势"></a>3.使用姿势</h2><p>姿势资产和动画序列一样可以直接拖到动画蓝图中以一个节点的形式使用，姿势节点有一个输入引脚一个输出引脚，姿势节点会输入的姿势进行混合然后输出混合好后的姿势。</p><p>姿势节点一般配合<code>ModifyCurve</code>(修改曲线)节点使用，修改曲线节点可以通过曲线名称动态的修改动画系统中所有动画曲线的值，修改曲线节点可以在Details/Modify Curve/Curve Map中绑定一个Map来传递曲线值。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312009161.png"></p><p>这里有一点是需要注意的，变形目标自带曲线，而通过变形目标的动画序列创建的姿势动画系统也会针对每一帧创建曲线，二者之间实际上是有重复的，即变形目标的自带曲线和姿势中的曲线可以控制同一形变，估计是因为变形目标的曲线名称不能在UE中修改，可能会出现美术的命名习惯和程序的命名习惯不一致，所以UE才搞这么一出吧。</p><p>所以对于上面的例子，我也可以不使用姿势资产，而通过修改曲线节点直接修改变形目标的自带曲线，如：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312009619.png"></p><p>知道了原理之后我们就可以把变形目标换成人脸表情，我们就可以通过曲线来驱动表情了。</p><p>只要传入的面捕数据遵循LiveLink协议，UE就可以将数据传入<code>LiveLinkPose</code>节点来驱动输入动画系统中的对应曲线，UE为我们预制好了LiveLinkRemapAsset重定向资源来做表情的重定向，这个资产我们可以在LiveLinkPose节点的细节面板中看到，对于和标准重定向资源不同的表情控制我们可以继承LiveLinkRemapAsset类来创建自定义的重定向资源，具体可以参见<a href="https://docs.unrealengine.com/5.1/zh-CN/live-link-in-unreal-engine/">虚幻引擎Live Link</a>。</p><h1 id="七、混合空间"><a href="#七、混合空间" class="headerlink" title="七、混合空间"></a>七、混合空间</h1><p>混合空间是UE专门用于混合动画的一种资产，相比与动画蓝图的混合节点，混合空间可以更方便的混合多种动画，并请且可以使用float进行状态控制。创建好的混合空间也可以直接在动画系统的资产浏览器找到，可以将混合空间视为一种特殊的动画序列。</p><p>混合空间有两种二维的BlendSpace和一维的BlendSpace1D，二者的用法基本都一样，在混合空间编辑视图里面最重要的就是AssetDetails面板。</p><p>这里就挑一些比较重要的，常用的设置讲解一下，其他的可以看[官方文档](<a href="https://docs.unrealengine.com/5.0/zh-CN/blend-spaces-in-unreal-engine/">虚幻引擎中的混合空间 | 虚幻引擎5.0文档 (unrealengine.com)</a>)</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312009961.png"></p><p>Axis Settings</p><ul><li><p>Name：指定轴的名称，这个名称也是动画蓝图使用混合空间时对应轴的输入引脚的名称；</p></li><li><p>Minimum/Maximum Axis Value：轴的最小值和最大值。</p></li><li><p>Grid Divisions：轴的分段，值越大分的段就越多，分段越多动画混合就会准确。</p></li><li><p>Snap to Grid：勾选后动画系统会自动强制将不在网格顶点的混合点设置到网格顶点上；</p></li><li><p>Wrap Input：勾选后轴的输入值可以超出最大值和最小值的范围，当输入了超出范围的输入值时混合空间会将轴视为一个圆环，自动匹配输入值在环中的位置，并输出对应的姿势。</p></li><li><p>Smoothiing Time：值输入后动画更具输入值混合动画时的延迟，这里设置一个比较大数字看起效果可能会更明显，如：设置成2秒，将值设为0则关闭平滑时间。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312009517.gif"></p></li><li><p>Damping Ratio：平滑时间的缓动函数，有平均(Averaged)、线性(Linear)、立方体(Cubic)、慢入/慢出(Ease In/Out)、指数波(Exponential)和弹簧阻尼系统(Spring Damper)可选。</p></li><li><p>Max Speed：混合点跟随输入值的最大速度，会影响平滑时间，入我们上面设置的2秒的平滑时间，而实际混合点的跟随延迟并没有两秒，就是因为最大跟随速度是3。</p></li><li><p>Analysis：混合空间分析，有很多预制分析函数可选择，混合空间分析内容比较多，而且感觉一般情况也用不上，可以直接参见[官方文档](<a href="https://docs.unrealengine.com/5.0/zh-CN/automatic-blend-space-creation-in-unreal-engine/">虚幻引擎中的自动混合空间创建 | 虚幻引擎5.0文档 (unrealengine.com)</a>)。</p></li><li><p>Weight Speed：权重速度，功能上和平滑时间差不多，相当于是UE预制的平滑时间，权重越小动画混合的越快，0则关闭权重速度。权重速度不可以与平滑时间或平滑类型一起使用。</p></li><li><p>Smoothing：启用权重速度的慢入慢出，和权重速度一样不可以与平滑时间或平滑类型一起使用。</p></li><li><p>Per Bone Overrides：每个骨骼覆盖，可以指定每根骨骼的混合速度。</p></li><li><p>Notify Trigger Mode：动画通知触发模式，可以设置混合空间中混入的动画序列中动画通知以什么模式触发，可以选择所有动画(All Animations)—触发所有动画序列中的动画通知、最高权重动画(Highest Weighted Animation)—只触发权重最高的动画序列中的动画通知、None—不出触发。</p></li></ul><h1 id="八、目标偏移"><a href="#八、目标偏移" class="headerlink" title="八、目标偏移"></a>八、目标偏移</h1><p>目标偏移是一种特殊的混合空间，用于在一个动画上叠加一个动画混合。</p><p>目标偏移从名字就可以看出最初的作用就是用于在持枪动画的基础上叠加瞄准动画用的，当然我们想叠加其他的动画也是可以的。首先我们需要创建一个目标偏移资产，右键内容浏览器空白/Animation/Anim Offset，目标偏移是一种特殊的二维混合空间，所以编辑界面和混合空间是一样的，和混合空间不同的是一般的动画序列是不可以直接拖入目标偏移的混合视图，我们要想在目标偏移中使用某个动画序列，我们必须对这个动画序列做一些设置。</p><p>我们需要设置动画序列的Asset Details/Additive Settings如下：</p><ul><li>Additive Anim Type：Mesh Space；</li><li>Base Pose Type：Selected animation frame；</li><li>Base Pose Animation：被叠加的动画序列；</li><li>Ref Frame Index：0。</li></ul><p>然后这个动画序列就可以被拖入目标偏移的混合视图去了。</p><p>在目标偏移的Asset Details/Additive Setttings/Preview Base Pose也需要设置成被叠加动画序列。</p><p>然后目标偏移资产就可以直接在动画蓝图中使用了。</p><p>目标偏移在动画蓝图中是这样的：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312009877.png"></p><p>X，Y引脚分别为设置的横轴纵轴的名称，Base Pose传入要叠加的姿势，Alpha为混合权重。</p><p>目标偏移对加入叠加和被叠加的动画有一定的要求，如果二者比较重要的骨骼的偏移有偏差就会出现瞬移或者卡帧的问题，如我在Idle的姿势上叠加了一个被攻击的目标偏移：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312010153.gif"></p><h1 id="九、动画合成"><a href="#九、动画合成" class="headerlink" title="九、动画合成"></a>九、动画合成</h1><p>动画合成的功能很简单，就是单纯的将多个动画序列并接到一起作为一个动画资产来使用。</p><p>动画合成资产不具备动画混合能力，但在并接单个动画序列时提供一些简单的处理能力，如：删除动画序列的头尾帧，设置单个序列的播放速率和播放循环次数。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312010807.png"></p><p>Composite即为合成轨道，合成轨道有两个轨道栏，导入的动画序列会由动画系统在两个轨道栏中一次错开，以方便编辑与区分。AssetDetails是这个动画合成资产的属性详情，不过上面的属性也没啥用处，连<a href="https://docs.unrealengine.com/5.1/zh-CN/animation-composites-in-unreal-engine/">官方文档</a>都懒得说明。</p><p>选中一个动画序列会显示这个动画序列在动画合成中属性详情，主要的属性就是开始时间(StartTime)、结束时间(EndTime)、PlayRate(播放速率)和循环次数(LoopCount)，可以对单个动画序列进行简单的编辑。</p><p>动画合成也可以向普通的动画序列一样使用动画通知和动画曲线。</p><h1 id="十、动画蒙太奇"><a href="#十、动画蒙太奇" class="headerlink" title="十、动画蒙太奇"></a>十、动画蒙太奇</h1><p>动画蒙太奇可以算是一个高级版的动画合成，动画蒙太奇的功能也是将多个动画序列并接成一个资产，但相对与动画合成，动画蒙太奇的功能要强大得多，动画蒙太奇提供一种程序精确控制动画的方式。动画蒙太奇的作用是和状态机互补的，尽管状态机的功能很强大，但是也有不足的地方，比如当一个角色有10个技能，每个技能又由一系列的动画序列组成的时候，每个技能又由不能的按键触发，再加上角色基础的移动、跳跃等状态和一些只有在特殊场合才使用的动画，要只通过状态机实现这样的动作组，状态机会变得非常复杂，控制逻辑也会变得非常复杂，动画蒙太奇就可以弥补状态机的这一缺点，我们可以将10个技能和一些额外的动画都做成动画蒙太奇，这些蒙太奇可以使用一个或几个蒙太奇插槽混入状态机中，然后通过程序直接控制播放可以极大的减小状态机的复杂度。</p><p>动画蒙太奇编辑视图和动画合成编辑视图长得基本一样，使用上也大差不差，在编辑一段自己的动画蒙太奇之前我们需要先了解两个概念。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312010982.png"></p><h2 id="1-蒙太奇分段"><a href="#1-蒙太奇分段" class="headerlink" title="1.蒙太奇分段"></a>1.蒙太奇分段</h2><p>可以看到动画蒙太奇编辑视图相对于动画合成编辑视图多了一个Montage轨道，这个轨道就是用来处理蒙太奇分段的，蒙太奇分段就是动画轨道上的一个时间片段，如上图中Montage轨道上就有三个分段，分段所在的帧即为分段的起始帧，分段会将下一个分段的起始帧或动画蒙太奇的结束帧作为分段的结束帧，当一个分段之后还有其他分段则使用下一个分段的其实帧作为这个分段的结束帧，当一个分段之后没有其他的分段了则使用动画蒙太奇的结束帧作为这个分段的结束帧。如上图Pose1的结束帧就是Pose2的起始帧，Pose3的结束帧就是整个轨道的最后一帧。</p><h3 id="创建蒙太奇分段"><a href="#创建蒙太奇分段" class="headerlink" title="创建蒙太奇分段"></a>创建蒙太奇分段</h3><p>右键Montage轨道即可创建一个新的蒙太奇分段，创建的蒙太奇分段都会在Timing轨道带一个序号标签，这个序号标签就是单纯用来标识的，没有其他作用也不能选中，所有的分段都会显示在MontageSections视图中。</p><h3 id="编辑蒙太奇分段"><a href="#编辑蒙太奇分段" class="headerlink" title="编辑蒙太奇分段"></a>编辑蒙太奇分段</h3><p>创建好蒙太奇分段后可以直接拖动分段来设定分段的起始帧位置，在MontageSections中会默认将新创建的分段自动连接在一起，大多数情况下我们是不希望那所有分段都连接在一起的，所以我们可以点击Clear按钮清除所有连接，或者点击箭头/Remove Link来断开指定连接。</p><p>在MontageSections视图中没有连接其他分段的分段的后面会有一个白色正方形按钮，点击即可选择这个分段之后想要连接哪个分段。</p><p>当几个分段连接在一起之后，动画蒙太奇会在播放完第一个分段后按照播放链一次播放后面的片段。</p><h2 id="2-蒙太奇插槽"><a href="#2-蒙太奇插槽" class="headerlink" title="2.蒙太奇插槽"></a>2.蒙太奇插槽</h2><p>蒙太奇插槽指定就是动画蒙太奇编辑视图中的Group轨道，在创建一个新的动画蒙太奇时动画系统会设置这个动画蒙太奇到DefaultGroup.DefaultSlot轨道，即默认分组下的默认插槽。</p><h3 id="创建蒙太奇插槽"><a href="#创建蒙太奇插槽" class="headerlink" title="创建蒙太奇插槽"></a>创建蒙太奇插槽</h3><p>如果我们要创建自己的插槽，需要在Anim Slot Manger视图中操作，分组和文件夹的作用一样，用于管理各个插槽。</p><p>一个动画蒙太奇资产可以包含多个插槽，要添加更多的插槽进入轨道，只需要点击Group的下拉三角选择New Slot，即可添加所有的已被创建的插槽。</p><h3 id="使用蒙太奇插槽"><a href="#使用蒙太奇插槽" class="headerlink" title="使用蒙太奇插槽"></a>使用蒙太奇插槽</h3><p>编辑好的动画蒙太奇是不能向动画合成一样直接拖入动画蓝图中使用的，而是需要通过蒙太奇插槽混合进入动画状态中。</p><p>蒙太奇插槽直接在动画蓝图中是搜索不到的，我们需要使用默认插槽(Slot Defaultslot)来切换，点击默认插槽在Details/Settings/Slot Name可以进行插槽切换。</p><p>蒙太奇插槽在没有播放动画蒙太奇时不会影响动画蓝图其他节点，在播放动画蒙太奇时将直接忽略插槽之前的状态，插槽的输出引脚将只输出动画蒙太奇的状态。</p><h2 id="3-播放动画蒙太奇"><a href="#3-播放动画蒙太奇" class="headerlink" title="3.播放动画蒙太奇"></a>3.播放动画蒙太奇</h2><p>只要把动画蒙太奇分段和插槽理解到位了，动画蒙太奇的精髓也就掌握了，接下来就是使用了。播放动画蒙太奇的方法就一个蓝图节点：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312010505.png"></p><ul><li>In Skeletal Mesh Component：要应用动画蒙太奇的骨骼网格体组件，骨骼网格体组件绑定的骨骼和动画蒙太奇绑定的骨骼必须是一致的；</li><li>Montage to Play：要应用的动画蒙太奇资产；</li><li>Play Rate：整个动画蒙太奇播放的速率；</li><li>Starting Position：播放的起始时间；</li><li>Starting Section：要播放的蒙太奇分段；</li><li>On Completed：蒙太奇播放完后调用；</li><li>On Blend Out：混出时调用，这个混出就是动画蒙太奇资产属性的混合设置下的混出，类似于视频的淡出；</li><li>On Interrupted：在动画蒙太奇播放被中断时调用；</li><li>On Notify Begin：在蒙太奇通知或蒙太奇通知窗口开始激活时调用；</li><li>On Notify End：在蒙太奇通知窗口结束时调用；</li><li>Notify Name：当前活跃的动画通知名称。</li></ul><p>除了Play Montage节点UE还提供了一个更简洁的节点Play Anim Montage：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312011088.png"></p><p>通过上面的这些知识点我们就可以制作一个角色出场动画了，这里使用两断动画来并接出一个出场动画：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312011133.png"></p><p>先再Anim Slot Manager创建一个自定义的插槽StartPose，点击下拉三角在Slot Name选择新创建的插槽，然后拖入两断动画序列进入轨道。</p><p>创建三个分段，Pose1、Pose2、Pose3，我们需要的是Pose1分段和Pose3分段，所以在Montage Sections视图将Pose1连接到Pose3。</p><p>在动画蓝图添加默认的插槽节点并切换到自定义的插槽。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312011709.png"></p><p>然后在角色蓝图的BeginPlay播放动画蒙太奇的Pose1分段：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312011538.png"></p><p>然后来看一下效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312011972.gif"></p><p>可以看到角色在播放蒙太奇的过程中有出现跳帧的情况，这是因为我们使用了带根位移的动画，像这种出场动画我们是希望动画带位移，我们想要使用动画的位移这就涉及到另一个知识点—蒙太奇与根运动。</p><h2 id="4-蒙太奇与根运动"><a href="#4-蒙太奇与根运动" class="headerlink" title="4.蒙太奇与根运动"></a>4.蒙太奇与根运动</h2><p>说起来也简单，要应用动画序列的根位移我们只需要勾选带有根位移的动画序列的Details/RootMotion/EnableRootMotion，这样动画系统就会自动计算动画位移和角色位移，然后我们再来看一下效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312012528.gif"></p><p>效果已经很可以了。</p><h2 id="5-蒙太奇通知"><a href="#5-蒙太奇通知" class="headerlink" title="5.蒙太奇通知"></a>5.蒙太奇通知</h2><p>蒙太奇通知是专门用于动画蒙太奇的动画通知，创建方式上和普通动画通知一样，使用上有些差别，蒙太奇通知不会在动画蓝图中创建对应的事件，而是由PlayMontage节点触发，当我们使用PlayMontage节点播放蒙太奇动画，在动画播放到蒙太奇通知所在帧时就会触发On Notify Begin回调，一个动画蒙太奇中有多少个蒙太奇通知就会回调多少次。</p><p>蒙太奇通知有三类，Montage Notify、Montage Notify Window和Disable Root Motion。</p><ul><li>Montage Notify：蒙太奇通知对应普通的动画通知，激活时会回调PlayMontage节点的On Notify Begin；</li><li>Montage Notify Window：蒙太奇通知窗口对应普通的动画通知状态，开始激活时会回调PlayMontage节点的On Notify Begin，结束激活时会回调PlayMontage节点的On Notify End；</li><li>Disable Root Motion：禁用骨骼运动这个动画通知有点特殊，作用就是在激活期间禁用动画序列的根位移，有时动画蒙太奇会使用动画序列的根位移，比如上面的例子，但使用了根位移我们就没法控制角色的移动了，有时可能在蒙太奇播放的某个时间断里我们想要控制角色移动，Disable Root Motion就可以满足这种精确控制。Disable Root Motion使用上和蒙太奇通知窗口类似，但是Disable Root Motion不会触发PlayMontage的回调，甚至不能修改通知的名称。</li></ul><p>现在我们用蒙太奇通知来为出场动画加一些特效，制作在大剑与地面接触时产生爆炸的效果。</p><p>首先在骨骼上的武器骨骼上加一个骨骼插槽weaponSlot，然后在动画蒙太奇中添加两个蒙太奇通知。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312012520.png"></p><p>然后在角色蓝图中编写特效触发逻辑：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312012737.png"></p><p>然后来看一下效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312013266.gif"></p><h2 id="6-子蒙太奇"><a href="#6-子蒙太奇" class="headerlink" title="6.子蒙太奇"></a>6.子蒙太奇</h2><p>动画蒙太奇还可以创建类似子类的子蒙太奇，子蒙太奇所有属性包括分段、动画通知都和父蒙太奇一样，且不可更改，唯一能更改的就是插槽轨道中的动画序列，子蒙太奇的作用就是相同的动画蒙太奇配置应用不同的动画序列来适应不同的场景。</p><h1 id="十一、动画蓝图"><a href="#十一、动画蓝图" class="headerlink" title="十一、动画蓝图"></a>十一、动画蓝图</h1><p>动画蓝图是整个动画系统的终点，所有的动画序列经过骨骼定向、混合、编译调整、融合之后，都通过动画蓝图整合在一起，给予角色使用。</p><p>动画蓝图均集成自AnimationInstance类，并且创建时需要绑定骨骼，这也印证了UE的动画系统都是基于骨骼的，一切的一切都要在骨骼之上才能应用。</p><h2 id="1-动画蓝图编辑器"><a href="#1-动画蓝图编辑器" class="headerlink" title="1.动画蓝图编辑器"></a>1.动画蓝图编辑器</h2><p>动画蓝图是动画系统专用蓝图，和不普通蓝图编辑器界面有所不同，动画蓝图有两个Graph，Event Graph和Anim Graph，Event Graph就是普通的蓝图编辑视图，普通蓝图能干的事它都能干，提供一个每帧调用的Event Blueorint Update Animation事件。Anim Graph则是专门的动画编辑视图，用于对动画做控制，如姿势混合、曲线控制、动画序列的读取以及状态机等都在这个视图编辑，视图提供一个最终输出OutputPose，动画可以在Anim Grahp中经过各种各样的编辑修改，但最终都只能连接上OutputPose来输出给角色。</p><p>按<a href="https://docs.unrealengine.com/4.27/zh-CN/AnimatingObjects/SkeletalMeshAnimation/AnimBlueprints/">官方</a>的说话，二者是相互配合工作的，Event Graph用于更新Anim Graph所需的数据，而Anim Graph使用这些数据驱动状态机、混合空间等驱动角色运动。</p><h2 id="2-Event-Graph常用节点"><a href="#2-Event-Graph常用节点" class="headerlink" title="2.Event Graph常用节点"></a>2.Event Graph常用节点</h2><p>动画蓝图的Event Graph有一些特殊的预定义事件。</p><h3 id="BlueprintBeginPlay"><a href="#BlueprintBeginPlay" class="headerlink" title="BlueprintBeginPlay"></a>BlueprintBeginPlay</h3><p>效果和常用的BeginPlay事件一样，在游戏开始时调用一次。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312013041.png"></p><h3 id="BlueprintInitializeAnimation"><a href="#BlueprintInitializeAnimation" class="headerlink" title="BlueprintInitializeAnimation"></a>BlueprintInitializeAnimation</h3><p>BlueprintInitializeAnimation的调用有点类似构造函数，应该是在动画蓝图被构造的时候由系统在构造函数里调用的，在编译和实例化动画蓝图时会被调用一次。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312013679.png"></p><h3 id="BlueprintUpdateAnimation"><a href="#BlueprintUpdateAnimation" class="headerlink" title="BlueprintUpdateAnimation"></a>BlueprintUpdateAnimation</h3><p>在PIE和Runtime都会每帧都会调用一次</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312013197.png"></p><h3 id="BlueprintLinkAnimationLayersLayersInitialized"><a href="#BlueprintLinkAnimationLayersLayersInitialized" class="headerlink" title="BlueprintLinkAnimationLayersLayersInitialized"></a>BlueprintLinkAnimationLayersLayersInitialized</h3><p>BlueprintLinkAnimationLayersLayersInitialized节点在链接动画层初始化时会被调用一次，按照官方的说法是：</p><blockquote><p>在所有链接动画层初始化时激活连接的节点。您可以使用此节点运行一次逻辑，一旦所有链接的动画层首次初始化，该逻辑就会被激活。</p></blockquote><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312013350.png"></p><h3 id="BlueprintPostEvaluateAnimation"><a href="#BlueprintPostEvaluateAnimation" class="headerlink" title="BlueprintPostEvaluateAnimation"></a>BlueprintPostEvaluateAnimation</h3><p>BlueprintPostEvaluateAnimation的作用我始终没看懂，按照官方的说法就是：</p><blockquote><p>在评估 AnimBP 后激活顺序节点。使用此节点，您可以激活将在评估 AnimBP 后运行的逻辑</p></blockquote><p>BlueprintPostEvaluateAnimation和BlueprintUpdateAnimation一样在PIE和Runtime都会每帧调用一次</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>出来上面的几个事件外，动画蓝图还可以直接调用InputAction，即在设置界面配置的按键绑定事件。</p><h2 id="3-Anim-Graph常用节点"><a href="#3-Anim-Graph常用节点" class="headerlink" title="3.Anim Graph常用节点"></a>3.Anim Graph常用节点</h2><h3 id="空间转换节点"><a href="#空间转换节点" class="headerlink" title="空间转换节点"></a>空间转换节点</h3><p>空间转换节点有两个，LocalToComponent和ComponentToLocal。</p><p>在UE的动画系统中常规的动画姿势是运行在局部空间中的(这个局部空间个人理解应该就是以根骨骼为参照的局部坐标系)，但是所有的骨骼控制节点和一些混合节点则是运行在组件空间中的(组件空间个人理解应该是以父骨骼为参照的局部坐标系)，当需要对组件空间中的姿势做控制时就需要这两个节点做空间转换，所以两个节点一般成对出现。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312013831.png"></p><p>其中白色代表局部空间数据流，蓝色代表组件空间数据流。</p><h3 id="LayeredBlendPerBone"><a href="#LayeredBlendPerBone" class="headerlink" title="LayeredBlendPerBone"></a><strong>LayeredBlendPerBone</strong></h3><p>这个节点的中文名为<code>每个骨骼的分层混合</code>。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312013628.png"></p><p>节点的作用就是在基础姿势上从骨骼的层级上混合其他姿势到基础姿势中。</p><p>这里以第三人称模板的跑步姿势为基础姿势，然后往这个姿势中混合一个抬剑的姿势作为例子。</p><p>首先从Epic商城中找到<code>Bossy Enemy Animation Pack</code>姿势包，然后导入到我们的项目中来。使用第二章骨骼第7小节骨骼重定向中重定向链的方式让小红人使用小白的动画序列，然后在动画蓝图做动画混合：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312014222.png"></p><p>这里Boss_BattleEntrance_RM就是抬剑姿势。</p><ul><li>Base Pose：需要被混合的基础姿势；</li><li>Blend Poses 0：需要加入混合的0号新姿势；</li><li>Blend Weights 0：0号新姿势混入基础姿势的权重；</li><li>Add pin：添加新的混合姿势；</li></ul><p>到这一步混合还是不能生效的，我们还需要再节点细节面板中对要进入混合的骨骼做过滤。</p><p>在节点的细节面板中对骨骼进行配置：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312014044.png"></p><p>深度混合代表骨骼参与混合的程度，0表示不参与混合，1表示完全取代基础骨骼变化，0-1之间则表示不同程度的混合，-1表示完全不参与混合，骨骼完全不会影响原骨骼。</p><p>然后运行一下看看效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312014092.gif"></p><p>LayeredBlendPerBone节点有两种模式Branch Filter和Blend Mask，在Details/Config/Blend Mode中可以切换两种模式，前面使用的就是Branch Filter–骨骼筛选，Blend Mask–骨骼遮罩可以做到比Branch Filter更精准具体的混合。</p><p>要使用骨骼遮罩我首先需要在骨骼编辑器中创建骨骼遮罩。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312014759.png"></p><p>在BlendMasks栏显示的是已经存在的骨骼遮罩资产，创建好骨骼遮罩后骨骼编辑器会在骨骼树的右侧新增一列骨骼遮罩列，骨骼遮罩会对每一根骨骼都设有权重，权重为0表示这根骨骼上的叠加姿势完全不会应用到这个骨骼上，权重为1表示在这根骨骼上完全应用叠加姿势，权重介于0-1则根据权重值在这根骨骼上做姿势混合。</p><p>鼠标放置在骨骼遮罩列列头上会在列头显示设置菜单，在菜单中可以做切换骨骼遮罩和删除骨骼遮罩等操作。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312014725.png"></p><p>这里我以走路姿势叠加一个被攻击的姿势作为例子。</p><p>这里我们我们把上半身的骨骼的遮罩权重全部设置成1，下半身的骨骼的遮罩权重全部设置成0，这样就可以实现一个在走路的过程中被攻击的动作。</p><p>设置好之后，就可以在LayeredBlendPerBone节点中应用了，在Details/Config/Blend Masks中使用我们新创建的骨骼遮罩BlendMask，然后编译，看一下效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312014901.gif"></p><p>感觉走起路来会飘，这是因为有一些骨骼是两个姿势都会使用且比较重要的，我们不能一刀切将骨骼遮罩权重设置1和0，所以我们在微调一下骨骼遮罩的权重，这里我们把root和pelvis骨骼的设置为0，将spine_01、spine_02、spine_03骨骼设置为0.5，然后再来看看效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312015041.gif"></p><p>可以看到效果就已经好很多了。</p><p>LayeredBlendPerBone节点的骨骼遮罩模式除了可以是使用骨骼遮罩(BlendMask)外还可以使用混合描述，混合描述又分为TimeBlendProfiles和WeightBlendProfiles，这些都是一些比较细微的混合了，感觉属于高端玩法了，一般情况也用不上，所以这里就不列举了，具体用处与功效可以参见<a href="https://docs.unrealengine.com/5.0/zh-CN/blend-masks-and-blend-profiles-in-unreal-engine/">官方文档</a>。</p><h3 id="Blend"><a href="#Blend" class="headerlink" title="Blend"></a><strong>Blend</strong></h3><p>Blend节点功能上和LayeredBlendPerBone一样，只是Blend不能做骨骼过滤，且只能做两个姿势的混合，使用上比LayeredBlendPerBone更方便，Blend不会做骨骼过滤，所以性能上会比LayeredBlendPerBone强，所以在不需要做骨骼过滤的情况下更合适。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312015626.png"></p><h3 id="BlendMulti"><a href="#BlendMulti" class="headerlink" title="BlendMulti"></a><strong>BlendMulti</strong></h3><p>BlendMulti是Blend的多输入版，默认是两个输入引脚，右键节点/Add Blend Pin可以向节点添加新的引脚，选中引脚右键/Remove Blend Pin可以删除引脚，并且BlendMulti没有了基础姿势，所有的姿势都可以设置权重。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312015515.png"></p><h3 id="BlendPosesByBool"><a href="#BlendPosesByBool" class="headerlink" title="BlendPosesByBool"></a><strong>BlendPosesByBool</strong></h3><p>这是一个姿势的切换节点，可以根据输入的Bool值在两个姿势之间进行切换。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312016454.png"></p><h3 id="BlendPosesByInt"><a href="#BlendPosesByInt" class="headerlink" title="BlendPosesByInt"></a><strong>BlendPosesByInt</strong></h3><p>BlendPosesByInt就是BlendPosesByBool的多输入版本，通过Int值来在多个姿势之间做切换，引脚的添加与删除和BlendMulti一样。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312016243.png"></p><h3 id="BlendBoneByChannel"><a href="#BlendBoneByChannel" class="headerlink" title="BlendBoneByChannel"></a>BlendBoneByChannel</h3><p>BlendBoneByChannel节点的功能很强大，除了不能添加更多的输入引脚功能上比LayeredBlendPerBone节点还强大，BlendBoneByChannel不仅可以筛选骨骼，甚至可以筛选骨骼的Translation、Rotation、Scale变换和应用的坐标空间，在节点的Details/Blend/Bone Definitions中可以添加要应用的骨骼和要应用的变换，SourceBone是基础姿势的骨骼，TargetBone是附加姿势的骨骼。在Details/Blend/Transform Space可以选择混合要应用的坐标空间。</p><p>如我们在走路姿势上附加一个被攻击的姿势，但只应用右手手臂的动作。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312016635.png"></p><p>设置骨骼筛选</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312016172.png"></p><p>最终效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312016034.gif"></p><p>可以和下面的ApplyAdditive节点的效果对比看会更明显。</p><h3 id="ApplyAdditive"><a href="#ApplyAdditive" class="headerlink" title="ApplyAdditive"></a>ApplyAdditive</h3><p>ApplyAdditive节点的作用是动画附加，可以将一个动画附加在基础动画之上，要附加的动画序列需要做特殊的处理，即动画序列编辑器中的AssetDeltails视图/Additive Settings/Additive Anim Type设置为Local Space，Base Pose Type 设置为Selected animation frame，然后Base Pose Animation选择一个参考姿势，参考姿势的作用是附加动作和参照动作一样动作的地方在后续附加在其他动作上时会被忽略，不同的就会附加。</p><p>如我们在走路姿势上附加一个被攻击的姿势：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312016350.png"></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312016618.png"></p><p>然后效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312016983.gif"></p><p>混合的还是很好的，效果基本和LayeredBlendPerBone差不多了。</p><p>ApplyAdditive和Blend的区别就是ApplyAdditive是附加动画到基础动画上，由于有一个参照姿势进行动作过滤，所以混合起来效果会更好，而Blend则直接将两个姿势混合，所有的骨骼都会根据权重互相影响，在这种情况下混合起来效果就没那么好，不过Blend很适合做步态的混合。</p><h3 id="BlendPosesByEnum"><a href="#BlendPosesByEnum" class="headerlink" title="BlendPosesByEnum"></a>BlendPosesByEnum</h3><p>这个节点的名字不是固定，是根据需要应用的枚举类型变化的，如我有一个枚举叫BlendEnum，那么我在搜索BlendPosesByEnum节点的时候就不是搜索BlendPosesByEnum而是搜索BlendPosesBlendEnum，直接搜索BlendPosesByEnum会列出系统所有的枚举在BlendPosesByEnum的应用。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312016063.png"></p><p>BlendPosesByEnum节点的作用就是可以根据枚举中值来添加输入引脚，引脚会根据枚举的值来命名，并且使用枚举来做姿势切换，BlendPosesByEnum还提供一个默认姿势，当没有添加任何引脚时就会使用默认姿势。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312016962.png"></p><p>BlendPosesByEnum节点默认是没有添加枚举中定义的引脚的，需要手动右键进行添加。</p><h3 id="ApplyMeshSpaceAdditive"><a href="#ApplyMeshSpaceAdditive" class="headerlink" title="ApplyMeshSpaceAdditive"></a>ApplyMeshSpaceAdditive</h3><p>这个节点在网上的资料实在是找不到，官方文档也没有说明，只在Youtubo上找到了一个<a href="https://www.youtube.com/watch?v=154aGaLIid0">视频案例</a>使用方式和ApplyAdditive基本一样，只是动画序列里的AssetDetails/AdditiveSettings/AdditiveAnimType选择MeshSpace。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312017959.png"></p><h3 id="MakeDynamicAdditive"><a href="#MakeDynamicAdditive" class="headerlink" title="MakeDynamicAdditive"></a>MakeDynamicAdditive</h3><p>MakeDynamicAdditive的作用正好和ApplyAdditive相反，MakeDynamicAdditive是从基础姿势中减去附加姿势。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312017279.png"></p><h3 id="Inertialization"><a href="#Inertialization" class="headerlink" title="Inertialization"></a>Inertialization</h3><p>Inertialization(惯性化)节点按照官方的说法是用来做高性能优化的，一旦启用了惯性化，那么动画系统将不再进行姿势混合计算，而是使用惯性化来输出姿势，可能是我测试的动画根本不吃什么性能，所以我实际使用中没有感觉有什么作用😂。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312017303.png"></p><h3 id="ModifyCurve"><a href="#ModifyCurve" class="headerlink" title="ModifyCurve"></a>ModifyCurve</h3><p>ModifyCurve节点用于在动画蓝图中驱动动画序列里创建的动画曲线。可以右键添加和删除曲线引脚。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312017485.png"></p><h3 id="LiveLinkPose"><a href="#LiveLinkPose" class="headerlink" title="LiveLinkPose"></a>LiveLinkPose</h3><p>LiveLinkPose是UE专门开发用于接收动捕、表捕、手捕设备实时数据的节点，LiveLinkPose可以直接将这些实时数据混合成姿势用于角色动画的姿势混合中，如在播放指定动画序列时混入脸捕数据。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312017621.png"></p><p>LiveLinkPose节点由LiveLink插件提供，需要启用LiveLink插件才能搜索到这个节点，在LiveLinkSubjectName中输入LiveLink视图配置的数据源名称即可实时接收到源传递过来的数据，并与输入姿势混合，并且输出一个带有实时数据的混合姿势。</p><h2 id="4-状态机"><a href="#4-状态机" class="headerlink" title="4.状态机"></a>4.状态机</h2><p>状态机是动画蓝图里面一个非常重要的模块，用于管理复杂的姿势混合。</p><p>一个角色可能会有很多动画，或者各种技能，当这大量的动作姿势在AnimGraph混合的时候会导致视图非常复杂，在普通蓝图中可以使用函数、宏、事件来封装或者使用节点来组合，而动画蓝图则使用状态机来封装。</p><p>一个状态机由若干的状态(State)、导管(Conduit)、状态别名(Alias)、转换规则以及唯一的入口(Entry)组成。</p><h3 id="创建状态机"><a href="#创建状态机" class="headerlink" title="创建状态机"></a>创建状态机</h3><p>直接在AnimGraph视图右键搜索State Machines即可创建一个状态机。状态机在表现上和普通蓝图的节点很相似。状态机没有输入引脚只有输出引脚，并且输出的也是一个姿势。</p><p>创建好状态机后就可以双击进入状态机节点，对状态机进行编辑了。</p><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>State是用来封装姿势混合过程的节点，一个State输出一个最终姿势，State节点可双击进入进行姿势混合编辑。</p><p>每一个状态都可以在Details/AnimationState中定义三个回调事件，分别是进入状态事件(EnteredStateEvent)、离开状态事件(LeftSatateEvent)和完全混合状态事件(FullyBlendedStateEvent)，在CustomBlueprintEvent处填写自定义事件名称，就可以为这个状态创建三个动画通知回调事件，和普通的动画通知效果一样，直接在EventGraph中搜索即可使用。</p><h3 id="Transition-Rule"><a href="#Transition-Rule" class="headerlink" title="Transition Rule"></a>Transition Rule</h3><p>我们从一个State1节点的边缘按住鼠标左键拖动到另一个State2节点的边缘即可创建State1转换到State2的TransitionRule，TransitionRule由一个箭头加一个转换节点组成，转换节点可双击进入，转换节点固定输出一个bool值，只有返回true时才可转换到所指向的State，转换节点中可以编写一些<font color="red">bool表达式逻辑</font>，由于转换规则没有输入引脚，所以在转换规则编辑视图中是不可以直接调用带输入输出流程引脚的函数的，不过可以使用纯函数，所以一些比较复杂的bool表达式可以使用纯函数封装。</p><p>在转换规则中UE定制了几个转换专用的纯函数蓝图节点，不过个人感觉一般也不怎么用得上，所以就直接上官方文档链接了—[虚幻引擎中的转换规则](<a href="https://docs.unrealengine.com/5.0/zh-CN/transition-rules-in-unreal-engine/">虚幻引擎中的转换规则 | 虚幻引擎5.0文档 (unrealengine.com)</a>)。</p><p>除了纯函数函数蓝图节点外，UE也为转换规则定制了几个动画通知函数。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312017137.png"></p><p>这些动画通知函数除了<code>WasAnim Notify State Active in Any State</code>外，其他的都只能在转换规则中使用。这些通知主要分为三类：</p><ul><li>Was Anim Notify Name Triggered In Any State：在转换规则之前的<font color="red">任何状态</font>中如果指定名称的动画通知被触发则返回true；</li><li>Was Anim Notify State Active In Any State：在转换规则之前<font color="red">任何状态</font>中如果指定类型的动画通知状态被激活了则返回true；</li><li>Was Anim Notify Triggered In Any State：在转换规则之前<font color="red">任何状态</font>中如果指定类型的动画通知被触发了则返回true；</li><li>Was Anim Notify Name Triggered In Source：在转换规则之前的<font color="red">活动状态</font>中如果指定名称的动画通知被触发则返回true；</li><li>Was Anim Notify State Active  In Source：在转换规则之前<font color="red">活动状态</font>中如果指定类型的动画通知状态被激活了则返回true；</li><li>Was Anim Notify Triggered  In Source：在转换规则之前<font color="red">活动状态</font>中如果指定类型的动画通知被触发了则返回true；</li><li>Was Anim Notify Name Triggered In State Machine：在转换规则之前的<font color="red">指定状态</font>中如果指定名称的动画通知被触发则返回true；</li><li>Was Anim Notify State Active  In State Machine：在转换规则之前<font color="red">指定状态</font>中如果指定类型的动画通知状态被激活了则返回true；</li><li>Was Anim Notify Triggered  In State Machine：在转换规则之前<font color="red">指定状态</font>中如果指定类型的动画通知被触发了则返回true；</li></ul><p>除了上面的几个通知外，转换规则也和状态也样Details/Notifications下提供了三个自定义动画通知，开始过渡事件(Start Transition Event)、终止过渡事件(End Transition Event)和中断过渡事件(Interrupt Transition Event)。</p><p>而对于中断过渡事件UE提供了更高端的设置，在Details/Events/TransitionInterrupt下可以设置更详细的中断配置。</p><p><strong>Transition Rule Details</strong></p><ul><li><p>Priority Order：转换规则的优先级，当同一时刻有多个转换规则满足转换要求时，动画系统将选择优先级数字最小的优先转换。</p></li><li><p>Bidirectional：这个设置官方已经放弃使用了。</p></li><li><p>Transiton/Blend Logic：选择当前转换规则所使用的从前一个状态转换到下一个状态的混合模式，提供标准混合(Standard Blend)、惯性化混合(Interialization)和自定义(Custom)三种，选择不同的模式在Blend Settings下就可以设置不同选项。选择自定义模式在Blend Logic下拉列表后面会多出一个按钮Edit Blend Graph，点击按钮能进入自定义混合模式编辑界面，即可编辑自己的转换规则混合模式。</p><p>UE为转换规则自定义混合视图也定制了四个专用的蓝图纯函数节点：</p><p>SateWeight：获取上一个状态的混合权重。该数字在转换时长内逐渐从 1 减小到 0。</p><p>GetTransitoinTimeElapsed： 获取指定转换的耗时（以秒为单位）。</p><p>GetTransitionTimeElapsed(Ratio)：获取指定转换的耗时（以交叉转换时长的比例表示）。换句话说，该数字在转换时长内逐渐从 0增大到 1。</p><p>GetTransitionCrossfadeDuration：获取指定转换的交叉转换时长。这是 混合设置（Blend Settings）&gt; 时长（Duration）属性中使用的数字。</p></li><li><p>Transition Rule Sharing：设置共享转换图表，在编辑状态机的时候有些转换规则的转换逻辑可能都是一样的，此时我们无需去编辑每一个转换规则，我们只需要编辑其中一个，然后点击Transition Rule Sharing栏后面的(Promote to Shared)按钮输入共享视图的名称，将这个转换规则的视图提升为共享视图，编译后我们在其他的转换规则的Transition Rule Sharing的下拉列表就可以看到新创建的共享视图了，选择即可应用共享视图，应用了共享视图的转换规则节点UE会自动为节点配色，以便区分。</p></li><li><p>Automatic Rule Based on Sequence Player in State：启动后转换规则会在上一个状态中最相关的动画结束时自动混入下一个状态，而不用编写转换逻辑。</p></li><li><p>Sync Group Name to Require Valid Markers Rule：和同步组配合使用，使用了同步组后只有在上一个状态包含了同步组标识的动画序列时这个转换规则才生效。</p></li><li><p>Transition Crossfade Sharing：应用共享Blend Settings，点击后面的Promote To Shared按钮可以将当前设置提升为共享设置，编译后即可在其他的转换规则节点中使用这个设置，修改设置时会同步所有转换规则。</p></li><li><p>Dureation：转换所需要的时间长度。</p></li><li><p>Mode：转换混合时使用的曲线类型，按住Ctrl+Alt可以查看曲线预览。</p></li><li><p>Custom Blend Curve：设置自定义曲线。</p></li><li><p>Blend Profile：设置转换规则要应用的混合描述。</p></li></ul><p>共享转换规则作用域只在单个状态机中，在其他的状态机中读取不到，并且状态到导管，和状态到状态的共享转换规则也不通用。</p><h3 id="Conduit"><a href="#Conduit" class="headerlink" title="Conduit"></a>Conduit</h3><p>导管(Conduit)是用来给状态梳理转换流程的，导管可以看作是一种特殊的转换规则，普通转换规则只能在状态之间进行一对一转换，导管则可以实现一对一、一对多、多对一和多对多的转换。双击导管节点可进入导管编辑视图，导管编辑视图和转换规则一样也只返回一个bool值。导管的Details视图只有一个名称属性，没有其他任何属性。</p><p>如这样的一个状态机：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312017654.png"></p><p>我就可以用导管疏导成这样：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312017435.png"></p><p>这在一些极为复杂的状态机中很有用。</p><p>如果想要从Entry直接连接到导管，则需要勾选状态机的Details/Settings/Allow Conduit Entry States选项。</p><h3 id="Alias"><a href="#Alias" class="headerlink" title="Alias"></a>Alias</h3><p>状态别名(Alias)的作用和导管一样也是对复杂的状态转换进行疏导，状态别名可以看成若干个状态节点的集合的别名，这里的别名可以直接理解为编程语言中的别名，我们可以在状态别名的Details/State Alias下勾选状态机中哪些状态属于集合，当集合中的任一状态激活时，别名也同时会被激活。</p><p>如上面的状态机，我们可以使用别名来疏导成这样：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312017749.png"></p><h3 id="状态机属性"><a href="#状态机属性" class="headerlink" title="状态机属性"></a>状态机属性</h3><ul><li>Max Transitions Per Frame：设置在整个状态机中一帧内可以同时发生的转换的数量，默认值是3，表示在一帧内如果满足转换条件则可以同时触发三个转换，三个转换会在系统的配置下或根据优先级或根据默认规则彼此竞争最终使用一个转换，如果设置成1，则一帧内只能做出一个转换决策，从而避免多个转换之间互相竞争。</li><li>Max Transitions Requests：这个属性应该UE5.1新加的，我在UE5.0的官方文档中没有找到这个属性的介绍，直接机翻的意思是”可以随时取消的最大转换请求数。删除最早的转换请求以适应新创建的请求”，应该也是和转换相关的。</li><li>Skip First Update Transition：勾选此选项，当状态机初始化时如果转换规则满足则直接进入对应的状态，不勾选则初始化时及时满足转换规则也不会进入对应状态而是依旧处于默认状态。实际使用中似乎感觉这个选项没什么乱用，效果只会在状态机初始化时执行一次，之后要想效果再生效就只能重启引擎让状态机再初始化一次，并且不会影响运行时的效果。</li><li>Reinitialize on Becominig Relevant：当状态机变得相关时重新初始化，即当多个状态机混合时，每次进入这个状态机时，状态机都进行一次初始化，但是只会进入到默认状态，即使满足转换规则也不会进入对应的状态。</li><li>Create Notify Meta Data：启用转换规则的动画通知，如果不勾选，则状态机内所有的动画通知都不可用。不知道是不是bug，我实际测试时并没有实现官方文档说的这个效果，动画通知始终有效。</li><li>Allow Conduit Entry States：启用该属性将允许<a href="https://docs.unrealengine.com/5.0/zh-CN/state-machines-in-unreal-engine#%E5%AF%BC%E7%AE%A1">导管</a>用作进入状态，从而允许不同的默认状态，具体取决于导管的转换规则。</li></ul><h1 id="十二、ControlRig"><a href="#十二、ControlRig" class="headerlink" title="十二、ControlRig"></a>十二、ControlRig</h1><p>控制绑定(ControlRig)是UE为了虚拟制片引入一个插件模块，使用ControlRig可以在Sequence中很便捷的控制骨骼动画，除此之外也给程序提供了一个便捷的控制骨骼运动的接口，发展到现在ControlRig主要应用已经有虚拟制片、动画IK以及动捕，面捕，手捕等的骨骼控制等。</p><p>ControlRig在UE5中默认是不启动的，所以如果我们想要使用ControlRig资产就必须启用ControlRig插件。</p><h2 id="1-ControlRig资产"><a href="#1-ControlRig资产" class="headerlink" title="1.ControlRig资产"></a>1.ControlRig资产</h2><p>我们可以动过右键内容浏览器/Animation/ControlRig/ControlRig或直接右键对应的骨骼网格体/Create/ControlRig来创建一个ControlRig资产(UE5.0和UE5.1可能会有点不一样)。创建ControlRig资产时会让我们选择ControlRig的父类，如果没有自定义的ControlRig父类则直接选择ControlRig类，我们可以通过继承ControlRig类来自定义ControlRig资产的父类，以实现一些通用功能的封装。</p><p>ControlRig有专门的编辑器界面，通过骨骼网格体创建的ControlRig是已经绑定好骨骼的，而直接创建的ControlRig里面没有任何东西，我们需要自己手动绑定骨骼，双击进入编辑器界面在RigHierachy视图下有一个ImportHierarchy按钮，点击在弹出的界面中选择我们要应用的骨骼网格体即可为资产手动绑定骨骼或则右键RigHierachy视图的空白处/Import来选择导入的谷骨骼网格体。</p><h2 id="2-ControlRig编辑器"><a href="#2-ControlRig编辑器" class="headerlink" title="2.ControlRig编辑器"></a>2.ControlRig编辑器</h2><p>ControlRig编辑器中有很多的视图都是比较重要的，我们需要了解一下他们的作用。</p><h3 id="菜单栏"><a href="#菜单栏" class="headerlink" title="菜单栏"></a>菜单栏</h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312017163.png"></p><ul><li>Forwards Solve：解算器预览，解算器决定ControlRig的计算方式，不同的解算器对应不同的ControlRig入口，ControlRig默认使用Forwards Solve解算器，对应Forwards Solve事件入口，我们可以点击解算器预览按钮后面的设置按钮选择不同的解算器预览，解算器往后连接的一系列节点组成的一条长链被称为解算链，解算器预览提供四种预览，Forwards Solve、Backwards Solve、Backwards and Forwards、Contruction Event，选择Forwards Solve，ControlRig编辑器将激活向前解算器，选择Backwawrds Solve，ControlRig编辑器将激活向后解算器，选择Backwards and Forwards，ControlRig将同时激活向前向后解算器，先执行向后解算器，再执行向前解算器，Construction Event好像没什么卵用。</li><li>Auto Compile：自动编译，选中后ControlRig编辑器将在我们做了任何修改之后自动编译，而无需我们手动编译。</li><li>Control Rig Editor Preview：这个选项官方文档中也没有说明，自己在摸索之后感觉是和后面的调试模式功能配合使用的，这个选项可以选择使用Control Rig Editor Preview或资产本身。</li><li>ReleaseMode：ControlRig的运行模式，切换到DebugMode配合Control Rig Editor Preview可以在ControlRig编辑器中进行解算链的调试，在DebugMode模式下后面的运行按钮会变亮，我们在解算链中添加断点，然后运行解算链，运行会在断点节点处中断，然后可以使用后面的几个工具进行断点调试。</li><li>Diff：这个选项使用来做版本控制的，一般没有直接使用UE连接版本控制软件都用不上。</li><li>Hide Unrelated：解释是说隐藏与选中节点无关的节点，但是没搞明白怎么用。</li></ul><h3 id="RigHierachy"><a href="#RigHierachy" class="headerlink" title="RigHierachy"></a>RigHierachy</h3><p>绑定层级视图显示了整个骨骼层级，我们可以选中对应的骨骼打开右键菜单来对骨骼进行操作，其中比较重要的就是New菜单下的控制点，创建好的控制点会依附在对应的骨骼层级下。</p><h3 id="Execution-Stack"><a href="#Execution-Stack" class="headerlink" title="Execution Stack"></a>Execution Stack</h3><p>执行堆栈视图显示了整个解算链的执行流程，在执行堆栈视图可以清晰的看到执行流程并点击可以快速定位到对应的节点。</p><h3 id="Curve-Container"><a href="#Curve-Container" class="headerlink" title="Curve Container"></a>Curve Container</h3><p>曲线容器视图列出了ControlRig绑定骨骼可以使用的所有动画曲线，我们可以使用<code>GetCurveValue</code>和<code>SetCurveValue</code>节点来获取与操作这些曲线。</p><h2 id="3-Control"><a href="#3-Control" class="headerlink" title="3.Control"></a>3.Control</h2><p>ControlRig中最重要的内容就是控制点，我们对骨骼的控制都通过Control控制点来操作，我们通过选中对应的骨骼在右键菜单的New栏中选择New Control来创建新的Control控制点，创建出来的控制点会依附在对应的骨骼层级中，以红色的图标表示。同时也可以选择多个骨骼在右键菜单的New栏中选择Add Controls For Selected选项来批量创建，批量创建的控制点不会依附在对应的骨骼层级中而是会单独的创建一个层级。</p><p>控制点的细节面板(这里就挑一些重要的看了)：</p><ul><li><p>Control/Animation Type：动画类型，官方文档也没有说明具体由什么用，网上也几乎搜不到资料，只能自己摸索了。</p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>Animation Control</td><td>有具体形体，可以控制动画的控制点</td></tr><tr><td>Animation Channel</td><td>具有动画通道的没有具体形体的控制点</td></tr><tr><td>Proxy Control</td><td>代理控制点，看说明是可以代替多个控制点的移动控制，并且Driven Controls下也可以添加驱动控制点，就是不知道怎么用</td></tr><tr><td>Visual Cue</td><td>不可选中也不可控制动画，但有具体形体的控制点，主要用于标识作用</td></tr></tbody></table></li><li><p>Control/Value Type：控制点值的类型，不同类型的值可以进行不同形式的骨骼控制。</p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>Bool</td><td>布尔型值的控制点可以在操作蓝图节点中设置布尔值，只是没弄明白设置设个布尔值对骨骼控制有什么作用</td></tr><tr><td>Float</td><td>浮点型值得控制点可以在PrimaryAxis中选择一个轴，控制点将只能在这跟轴上移动，不可以在其他轴上移动</td></tr><tr><td>Int</td><td>整型值控制点作用上和浮点型类似，除此之外整型值控制点可以在ControlEnum中绑定枚举类型，将整型转换成枚举类型，以便程序控制时更方便</td></tr><tr><td>Vector2D</td><td>Vector2D值控制点可以限制控制点在一个平面内移动，在PrimaryAxis可以选定一个轴，选定的轴将被排除在平面外，即控制点只能在剩下的两个轴组成的平面内移动</td></tr><tr><td>Position</td><td>Position值类型控制点可以限制控制点只能修改位移</td></tr><tr><td>Scale</td><td>Scale值类型控制点可以限制控制点只能修改大小变换</td></tr><tr><td>Rotator</td><td>Rotator值类型控制点可以限制控制点只能修改旋转量</td></tr><tr><td>Euler Transform</td><td>EulerTransform值类型控制点对控制点没限制，控制点可以修改整个Transform值</td></tr></tbody></table></li><li><p>Transform/Min/Max：我们选择一些值类型的控制点时在Transform栏中可能会出现Min和Max的控制栏，我们勾选上指定的轴就可以对应用在这个轴上的输入值控制接收最小值和最大值。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312018338.png"></p></li><li><p>Shape/Shape Properties/Shape：选择控制点形体的样式，对于不同值类型的控制点选择适合的样式可以很直观的看出控制点的值类型和控制方式。</p></li></ul><h3 id="控制点的变换应用"><a href="#控制点的变换应用" class="headerlink" title="控制点的变换应用"></a>控制点的变换应用</h3><p>我们单单只创建控制点是不能直接使用控制点控制骨骼的，我们需要使用两个节点来传递变换值，获取控制点变化的<code>Get Transform - Control</code>节点和设置骨骼变换的<code>Set Transform - Bone</code>节点，我们将节点连接到解算器，编译后就可以在预览视图中通过控制点实时预览控制点对骨骼的控制了。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312018953.png"></p><p>我们这里做一个使用控制点来实现一个简单捏脸的例子实践一下。</p><h3 id="使用控制点实现捏脸效果"><a href="#使用控制点实现捏脸效果" class="headerlink" title="使用控制点实现捏脸效果"></a>使用控制点实现捏脸效果</h3><p>这里使用官方提供一个<a href="https://www.unrealengine.com/marketplace/zh-CN/product/paragon-shinbi">免费角色</a>作为素材。</p><p>首先为角色创建一个ControlRig资产—Shinbi_CtrRig，并在角色脸部的指定骨骼上都创建对应控制点：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312018075.png"></p><p>然后配置解算链：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312018737.png"></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312018213.png"></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312018437.png"></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312018738.png"></p><p>这里节点比较多就做了封装。</p><p>到这里骨骼的控制就实现了，然后我们需要将控制应用到动画中，我们为角色创建一个新的动画蓝图Anim_Shinbi，实现如下：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312018144.png"></p><p>ControlRig节点需要在<code>Details/ControlRig/ControlRigClass</code>中选择我们创建的ControlRig资产—Shinbi_CtrRig，然后在ControlRig节点的Details/Input下就可以看到在ControlRig资产中配置到结算链上的骨骼控制引脚了：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312018937.png"></p><p>勾选上这些引脚用来接收输入，在动画蓝图中创建对应的变量来传递输入值。</p><p>然后我们创建一个UI把值传递到动画蓝图中，并对值做一些大小限制以实现比较好一点的效果，然后就可以实现简单的捏脸效果了，来看一下效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312018729.gif"></p><h2 id="4-Bone"><a href="#4-Bone" class="headerlink" title="4.Bone"></a>4.Bone</h2><p>Bone是一种虚拟骨骼，创建出来后使用空心的骨骼图标表示，与实心的真实骨骼图标做区分，虚拟骨骼没有网格权重，不会影响网格交换，一般用来做辅助骨骼。</p><h2 id="5-Null"><a href="#5-Null" class="headerlink" title="5.Null"></a>5.Null</h2><p>空项(Null)是一种容器，用于管理控制器和虚拟骨骼，类似文件夹。</p><h2 id="6-FullBodyIK"><a href="#6-FullBodyIK" class="headerlink" title="6.FullBodyIK"></a>6.FullBodyIK</h2><p>FBIK(FullBodyIK)是UE5在ControlRig框架下实现的一种IK方式，首先我们应该清楚什么是IK，IK即Inverse Kinematic—逆向动力学，与FK(Forward Kinematic)—正向动力学相对，我们知道人体骨骼动画中的骨骼是一种树型结构，父骨骼的移动会影响到子骨骼的移动，而子骨骼的移动也能反作用于父骨骼，通过父骨骼的移动正向计算其下所有子骨骼的移动的过程就是FK，反之，已知某一子骨骼的移动，反向计算其上层级骨骼的移动的过程就是IK，如我们常见的足部IK，就是通过控制足部骨骼的位置和旋转来适应不同的地形，然后通过IK来计算小腿、大腿、盆骨等上层层级骨骼的位置旋转来协调不同地形上的绳梯姿态。</p><p>UE自身提供了4中IK方法，TwoBoneIK、FABRIK、CCDIK和FBIK，每种IK方式各有优劣，具体可以看这篇博客<a href="https://zhuanlan.zhihu.com/p/446995093">【骨骼动画】UE的IK解决方案 - 知乎 (zhihu.com)</a>。</p><p>看UE5的趋势官方应该是更倾向与使用FBIK的，因为在UE5的第三人称模板中官方已经使用FBIK为我们制作好了一个效果还行的足部IK了，ControlRig叫CR_Mannequin_BasicFookIK，并且直接应用了第三人称动画蓝图中了。</p><p>FBIK的核心就三个东西，首先使用射线检测确定骨骼的落点变换，然后使用ControlRig解算器控制骨骼变换，最后使用<code>FullBodyIK</code>计算其他骨骼的变换，这样一个IK动画就完成了。</p><p>这其中的最重要的自然是FullBodyIK节点，节点功能很强大，输入引脚也是极其的多，我们一个个看。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312019568.png"></p><ul><li><p>Root：设置IK计算的根骨骼，即IK计算的最上层骨骼，再往上就不计算了，在人形骨骼上一般都设置为盆骨；</p></li><li><p>Effectors：官方文档成Effectors为执行器，用来设置IK计算的起始骨骼，这是一个数组可以设置多个起始骨骼。</p><p>Bone：应用的Effector设置的起始骨骼名称；</p><p>Transform：IK起点的变换，注意这里不是IK起始骨骼的变换，而是通过射线检测计算出来的骨骼落点的变换。</p><p>Position Alpha/Rotation Alpha：效果类似动画蓝图Blend节点的Alpha，用于控制骨骼变换的应用程度，1表示完全应用IK计算后的骨骼变换，0则是完全不应用。这里UE5.0和UE5.1有点出入，5.0二者合并成了一个Offset Alpha；</p><p>Strength Alpha：Effectors对骨骼链的影响程度；</p><p>Pull Chain Alpha：这个也是5.1新出的配置，官方文档上也没有更新这个设置的说明，按照编辑器的中文解释，这个设置使用来针对不同密集程度的骨骼链做IK解算时改善计算结果的；</p><p>Pin Rotation：这个设置也是5.1新出的，官方文档上也没有更新这个设置的说明，按照编辑器的中文解释，这个设置也是用来在移动输入的骨骼变换和执行器输入的骨骼变换之间做混合的，1表示使用执行器的骨骼变换，0表示使用移动输入的骨骼变换。感觉和Rotation Alpha的效果差不多，实际实践中感觉Pin Rotation的影响程度更高一点。</p></li><li><p>Bone Settings：骨骼设置用于针对单个骨骼进行解算属性设置，由于IK解算有时解算出来的结果有些骨骼可能不是很理想，所以骨骼设置是很有必要的。</p><p>Bone：需要应用设置的骨骼名称；</p><p>Rotation Stiffness/Position Stiffness：旋转刚度/位置刚度设置IK计算时对应用骨骼的影响程度，0表示骨骼可以自由移动，即完全影响，1表示骨骼完全锁定。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               </p><p>X/Y/Z：这些设置就是和Control控制器的Min/Max设置的效果是一样的，限制应用骨骼的在轴向上的变换范围，有三种模式，Free—骨骼的变换不受限制，此时Min/Max值不会生效，Limited—骨骼的变换将限制在Min到Max值之间，Locked—骨骼会被锁定，无法进行任何变换；</p><p>Use Preferred Angles：是否启用偏好角度，启用偏好角度会导致更多解算迭代，所以会消耗更多的计算；</p><p>Preferred Angles：用来强制使应用骨骼在解算时只在解剖学上的正确方向弯曲，不过我始终没有玩明白怎么用。</p></li><li><p>Excluded Bones：排除骨骼就是用来指定某根骨骼排除在解算链之外，不参与解算，主要用于来矫正姿势。</p></li><li><p>Settings：Setting是全局解算器设置；</p><p>Iterations：迭代次数，设置解算器的全局迭代次数，迭代次数越高，解算效果越好，同时也会越吃性能；</p><p>Mass Multiplier：质量倍乘器，值越大解算应用时全身骨骼看起来就会越僵硬，值越小看起来就会越软爬爬的；</p><p>Min Mass Multiplier：控制质量倍乘器的最小值；</p><p>Allow Stretch：这个设置没能摸索出有啥用；</p><p>Root Behavior：设置解算器的行为模式；</p><p>Start Solve from Input Pose：如果设置为true，解算器将在每一Tick重设，解算将从当前姿势开始，如果设置为false，解算器将从上一次解算的结果开始解算，输入的动画将倍忽略，一没弄明白有什么作用，默认都是勾选的，一般也不会动它。</p></li></ul><h2 id="7-解算器"><a href="#7-解算器" class="headerlink" title="7.解算器"></a>7.解算器</h2><p>在UE5.1中ControlRig提供了四种解算模式，Forwards Solve(向前解算)、Backwards Solve(向后解算)。</p><p><strong>向前解算</strong>即Control控制器驱动骨骼，是应用范围最广的解算，是ControlRig的默认解算方式。</p><p><strong>向后解算</strong>即使用骨骼驱动Control控制器，向后解算一般用于将动画序列烘培到Sequencer中的ControlRig上。</p><h2 id="8-构造事件"><a href="#8-构造事件" class="headerlink" title="8.构造事件"></a>8.构造事件</h2><p>ControlRig没有公开构造函数，但是为我们提供了一个构造事件—ConstructionEvent，需要我们手动创建节点。</p><h2 id="9-样条线控制"><a href="#9-样条线控制" class="headerlink" title="9.样条线控制"></a>9.样条线控制</h2><p> 样条线控制可以将一整条骨骼链作为一个整体进行控制，尤其是应用在触手，蛇、马尾辫等长条状的网格体上会很便捷。</p><h3 id="创建样条线控制"><a href="#创建样条线控制" class="headerlink" title="创建样条线控制"></a>创建样条线控制</h3><p>创建样条线控制我们需要为一整条骨骼链的没一根骨骼创建Control控制器，然后将控制器的Translation添加进<code>Spline From Points</code>节点的Points数组中：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312019951.png"></p><p>Spline From Points节点的输入引脚说明参考<a href="https://docs.unrealengine.com/5.1/zh-CN/control-rig-spline-rigging-in-unreal-engine/">虚幻引擎中的Control Rig样条线操控</a>。</p><p>然后将样条线绘制出来：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312019329.png"></p><p>编译之后就可以在预览视图看到绘制出来的样条线了。</p><p>需要注意的是Points必须传入四个以上的元素才能生成样条线。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312019962.png"></p><h3 id="应用样条线控制"><a href="#应用样条线控制" class="headerlink" title="应用样条线控制"></a>应用样条线控制</h3><p>绘制出的样条线还不能控制骨骼，还需要将样条线的控制应用到骨骼上。</p><p>使用Fit Chain Spline Curve节点可以将样条线控制应用到骨骼上，多选骨骼拖到蓝图中，在弹出菜单中选择Create Item Array，可以创建一个Rig Elemeny Key Array骨骼数据节点，传给Fit Chain Spline Curve节点的Items上，Spline连Spline From Points返回值，然后就可以使用样条线控制骨骼链了。</p><h2 id="10-姿势缓存"><a href="#10-姿势缓存" class="headerlink" title="10.姿势缓存"></a>10.姿势缓存</h2><p>姿势缓存是ControlRig提供的一个功能，可以将ControlRig中的动画的某一帧的姿势存储为一个姿势缓存变量，其实ControlRig的姿势缓存在功能效果上和姿势资产区别不大，但是姿势缓存有一个强大的能力，就是基于ControlRig强大的骨骼控制能力和程序控制能力，姿势缓存可以只单独缓存指定骨骼的姿势变换，应用姿势时也只应用这些骨骼的姿势变换，并且可以通过程序控制在运行时存储动画的任意时刻的姿势。</p><p>ControlRig框架专门提供了一个<code>RigPose</code>类型来存储姿势缓存，并且提供<code>GetPoseCache</code>节点来获取ControlRig控制下的动画姿势，最后通过<code>ApplyPoseCache</code>节点来应用姿势缓存，甚至在调试时提供了<code>DrawPoseCache</code>节点来绘制姿势缓存：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312019755.png"></p><p>我们可以将控制变量StartCachePose和ApplyCachePose通过动画蓝图的ControlRig节点传递出去，我们就可以通过程序实时的缓存姿势并应用姿势了。</p><p>可以看看一个简单的效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202301312019469.gif"></p><h2 id="11-ControlRig函数库"><a href="#11-ControlRig函数库" class="headerlink" title="11.ControlRig函数库"></a>11.ControlRig函数库</h2><p>ControlRig函数库和蓝图函数库的功能是一样的，用来共享ControlRig的公共逻辑，和蓝图函数库不同的是，ControlRig的每一个资产都可以是一个函数库，我们只需要将函数设为Public就可以使这个函数在所有的ControlRig资产里使用了，但是为了方便管理一般都单独使用一个不绑定骨骼网格体的ControlRig资产来专门管理公共函数。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE5】使用快捷键切换编辑器语言</title>
    <link href="/2022/12/07/%E3%80%90UE5%E3%80%91%E4%BD%BF%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%88%87%E6%8D%A2%E7%BC%96%E8%BE%91%E5%99%A8%E8%AF%AD%E8%A8%80/"/>
    <url>/2022/12/07/%E3%80%90UE5%E3%80%91%E4%BD%BF%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%88%87%E6%8D%A2%E7%BC%96%E8%BE%91%E5%99%A8%E8%AF%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>最近在项目上和美术配合，由于在编辑器上美术习惯使用中文而我习惯使用英文，配合的时候对中英文要切来切去很麻烦，于是就向弄一个快捷键来切换编辑器的中英文，然后在网上找到一个大佬—[opda](<a href="https://zhuanlan.zhihu.com/p/481496858">UE4自定义快捷键实现中英文切换 - 知乎 (zhihu.com)</a>)的实现，并且大佬还直接将功能插件化了。</p><a id="more"></a><p>不过大佬是在UE4中做的插件，而我要在UE5.1中使用，直接将插件放入引擎编译过不了，会报这个错误：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">没有将“WITH_PYTHON”定义为预处理器宏，用“<span class="hljs-number">0</span>”替换“<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span>/#<span class="hljs-meta-keyword">elif</span>”</span><br></code></pre></td></tr></table></figure><p>这里直接在插件的.biuld.cs文件中加一行：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">bEnableUndefinedIdentifierWarnings</span> = <span class="hljs-literal">false</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>再编译就好了，然后进入编辑器就可以直接使用F6快捷键进行中英文切换了。</p><p>大佬是一python脚本的形式做快捷键监听的，如果想要更换快捷键可以更改插件的key_listener.py这个python脚本。</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE5】多用户协同编辑</title>
    <link href="/2022/12/07/%E3%80%90UE5%E3%80%91%E5%A4%9A%E7%94%A8%E6%88%B7%E5%8D%8F%E5%90%8C%E7%BC%96%E8%BE%91/"/>
    <url>/2022/12/07/%E3%80%90UE5%E3%80%91%E5%A4%9A%E7%94%A8%E6%88%B7%E5%8D%8F%E5%90%8C%E7%BC%96%E8%BE%91/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>UE5新出了一个多用户协同功能所以想搭一个来玩玩。</p><p>Epic已经将流程极度的简化了，在B站虚幻官方也放出了<a href="%5B%5B%E7%BD%91%E7%BB%9C%E7%A0%94%E8%AE%A8%E4%BC%9A%5D%E5%9C%A8%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E4%B8%AD%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%EF%BC%9A%E5%A4%9A%E7%94%A8%E6%88%B7%E7%BC%96%E8%BE%91%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B(%E5%AE%98%E6%96%B9%E6%B1%89%E5%8C%96)_%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9_bilibili%5D(https://www.bilibili.com/video/BV1fK411W7Hn/?vd_source=e979466844c4915a4200c496efb35cfb)">教程视频</a>，[官方文档](<a href="https://docs.unrealengine.com/4.27/zh-CN/ProductionPipelines/MultiUserEditing/QuickStart/">多用户编辑入门 | 虚幻引擎文档 (unrealengine.com)</a>)也有教程。</p><p>这里做一下简要记录。</p><a id="more"></a><h2 id="1-启用插件"><a href="#1-启用插件" class="headerlink" title="1.启用插件"></a>1.启用插件</h2><p>首先打开Multi-User Editing插件，插件会要求重启，重启之后，在Project Settings/Plugins下会多出一个Multi-User Editing选项。</p><h2 id="2-多用户协同配置"><a href="#2-多用户协同配置" class="headerlink" title="2.多用户协同配置"></a>2.多用户协同配置</h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202212072238897.png"></p><ul><li><p>Enable Multi-User Toolbar Button：勾选之后需要重启编辑器，在编辑器的菜单栏会多出一个多用户协同的按钮。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202212072238240.png"></p><p>点击按钮会打开Multi-User Browser视图。</p></li><li><p>Auto Connect、Default Server URL和Default Session Name：这三个是配合使用的，勾选Auto Connect(实际使用勾不勾选好像都一样)，Default Server URL设置默认的服务器地址，Default Session Name设置连上服务器后默认加入的会话。</p><p>设置好这些后，多用户协同的按钮会发生变化，单击之后不会在打开Multi-User Browser视图，而是直接去连接服务器并直接加入会话。</p></li><li><p>Display Name：在多人协同中显示的名字，不设置就会使用Windows登录用户的名称。</p></li><li><p>Avatar Color：用户连上服务器是显示的标识颜色，再会话和修改历时中都会显示。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202212072238807.png"></p></li></ul><h2 id="3-配置UDP消息"><a href="#3-配置UDP消息" class="headerlink" title="3.配置UDP消息"></a>3.配置UDP消息</h2><p>在Project Settings/UDP Messaging下还需要设置Transport/Unicast Endpoint为本机IP地址，端口固定设置为0，在Static EndPoints下新增一个元素，填入服务器的IP地址，端口固定为6666，如：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202212072238554.png"></p><h2 id="4-创建服务器"><a href="#4-创建服务器" class="headerlink" title="4.创建服务器"></a>4.创建服务器</h2><p>UE的多人协同服务器可以支持局域网和公网，公网需要使用公网IP启动服务器，我这里没有条件，就使用局域网了。</p><p>打开Multi-User Browser视图，点击Launch a Server或左上角第一个图标可以启动多人协同服务器，UE会启动一个命令行窗口。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202212072238533.png"></p><h2 id="5-创建会话"><a href="#5-创建会话" class="headerlink" title="5.创建会话"></a>5.创建会话</h2><p>点击Multi-User Browser视图左上角第二个按钮，可以创建一个会话，双击或者右键可以加入会话，加入同一个会话的多个用户就可以在同一个场景中进行协同编辑了。</p><p>加入会话之后在History栏会显示操作历时。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202212072238080.png"></p><h2 id="6-其他UE加入会话"><a href="#6-其他UE加入会话" class="headerlink" title="6.其他UE加入会话"></a>6.其他UE加入会话</h2><p>在其他的电脑上，配置也基本一样，只要两个电脑是互通的，配置好后打开Multi-User Browser视图UE会自动搜索可用的服务器，连上服务器之后就可以加入会话，开启实时协同编辑了。</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE5】解决UE5无法播放mp4视频</title>
    <link href="/2022/11/14/%E3%80%90UE5%E3%80%91%E8%A7%A3%E5%86%B3UE5%E6%97%A0%E6%B3%95%E6%92%AD%E6%94%BEmp4%E8%A7%86%E9%A2%91/"/>
    <url>/2022/11/14/%E3%80%90UE5%E3%80%91%E8%A7%A3%E5%86%B3UE5%E6%97%A0%E6%B3%95%E6%92%AD%E6%94%BEmp4%E8%A7%86%E9%A2%91/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>最近接手的项目需要把项目从UE4中迁移至UE5，其中遇到了一个mp4视频无法播放的bug，这里做一下记录。</p><a id="more"></a><p>在官方论中有提到过这个bug，<a href="https://forums.unrealengine.com/t/media-textures-wont-display-video-in-ue5-preview-1-while-using-directx-12/503980/2">https://forums.unrealengine.com/t/media-textures-wont-display-video-in-ue5-preview-1-while-using-directx-12/503980/2</a></p><p>按照常规的方法播放视频在MediaPlay的Play节点会返回false，并在会会在日志中打印：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">LogWmfMedia</span>:Error:Tracks <span class="hljs-number">000084</span>F<span class="hljs-number">14025</span>C<span class="hljs-number">90</span>:Format is not supported in D<span class="hljs-number">3</span>D<span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p>意思是在最新的DX12图形库下UE5默认使用的WMF解码器目前不支持mp4的视频解码。</p><p>解决方案有两个，其一更换图形库，其二更换解码器。</p><h2 id="更换图形库"><a href="#更换图形库" class="headerlink" title="更换图形库"></a>更换图形库</h2><p>WMF解码器只是在DX12下会有解码出错的bug，在DX11或者Vulkan下没有这个bug，所以我们可以把UE使用的图形库换成DX11或者Vulkan。</p><p>在Edit/ProjectSettings/Platforms/Windows/Targeted RHIs/Default RHI中切换图形库，UE5支持DX11，DX12和Vulkan。</p><p>但是由于我的项目中使用了Groom毛发系统，Groom在DX11和Vulkan中支持的不是很好，所以方案一只能pass掉了。</p><h2 id="更换解码器"><a href="#更换解码器" class="headerlink" title="更换解码器"></a>更换解码器</h2><p>WMF是UE默认使用的视频解码器，除此之外UE在插件里还集成了一个功能更强大的视频解码器—<a href="https://docs.unrealengine.com/4.27/zh-CN/WorkingWithMedia/IntegratingMedia/MediaFramework/ElectraPlayer/">Electra Play</a>。</p><p>启用插件，重启后我们就可以在MediaPlay试图中的PlaybackOptions下看到ElectraPlay解码器，只需要将MediaPlay切换到ElectraPlay解码器即可，当然每一个MediaPlay都要进行切换解码器操作。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/202211142240667.png"></p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE4】C++编程</title>
    <link href="/2022/10/16/%E3%80%90UE4%E3%80%91C++%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/10/16/%E3%80%90UE4%E3%80%91C++%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><a id="more"></a><h1 id="一、工程目录"><a href="#一、工程目录" class="headerlink" title="一、工程目录"></a>一、工程目录</h1><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016001916.png"></p><ul><li>.vs：VS的缓存文件夹；</li><li>Binaries：存放UE的工程的可执行文件，以及编译的中间文件；</li><li>Biuld：存放一些编辑器相关的日志；</li><li>Config：存放游戏的默认配置文件；</li><li>Content：存放项目资产；</li><li>DerivedDataCache：主要存放DivX Descriptor File文件，应该是UE为制作影视视频准备的；</li><li>Plugins：存放项目中使用的插件；</li><li>Intermediate：存放UBT生成的文件，如：.generated.h文件；</li><li>Saved：缓存一些临时配置文件，在PIE模式下运行项目产生的日志以及Cook产生的数据文件；</li><li>Script：用来存放脚本语言，如python脚本等；</li><li>Source：存放项目的C++文件。</li></ul><h2 id="uproject"><a href="#uproject" class="headerlink" title=".uproject"></a>.uproject</h2><p>右键.uproject会出现几个选项：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016001947.png"></p><ul><li>Open：使用默认的UE编辑器打开.uproject文件；</li><li>Launch game：以打包后的exe的形式直接运行项目；</li><li>Generate Visual Studio project files：生成VS相关文件；</li><li>Switch Unreal Engine version：选择默认的UE版本用以打开.uproject文件。</li></ul><p>.uproject是UE的项目描述文件，采用json的格式来描述一个项目的版本信息、模块信息、插件信息等。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br><span class="hljs-attr">&quot;FileVersion&quot;</span>: <span class="hljs-number">3</span>,<br><span class="hljs-attr">&quot;EngineAssociation&quot;</span>: <span class="hljs-string">&quot;4.26&quot;</span>,<br><span class="hljs-attr">&quot;Category&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br><span class="hljs-attr">&quot;Description&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br><span class="hljs-attr">&quot;Modules&quot;</span>: [<br>&#123;<br><span class="hljs-attr">&quot;Name&quot;</span>: <span class="hljs-string">&quot;MyProject&quot;</span>,<br><span class="hljs-attr">&quot;Type&quot;</span>: <span class="hljs-string">&quot;Runtime&quot;</span>,<br><span class="hljs-attr">&quot;LoadingPhase&quot;</span>: <span class="hljs-string">&quot;Default&quot;</span>,<br><span class="hljs-attr">&quot;AdditionalDependencies&quot;</span>: [<br><span class="hljs-string">&quot;Engine&quot;</span><br>]<br>&#125;<br>],<br><span class="hljs-attr">&quot;Plugins&quot;</span>: [<br>&#123;<br><span class="hljs-attr">&quot;Name&quot;</span>: <span class="hljs-string">&quot;WebBrowserWidget&quot;</span>,<br><span class="hljs-attr">&quot;Enabled&quot;</span>: <span class="hljs-literal">true</span><br>&#125;<br>]<br>&#125;<br></code></pre></td></tr></table></figure><p>.uproject参数描述文件—<code>ProjectDescriptor.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PROJECTS_API</span> <span class="hljs-title">FProjectDescriptor</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-comment">/** Descriptor version number. */</span><br>EProjectDescriptorVersion::Type FileVersion;<br><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * The engine to open this project with. Set this value using IDesktopPlatform::SetEngineIdentifierForProject to ensure that</span><br><span class="hljs-comment"> * the most portable value for this field is used.</span><br><span class="hljs-comment"> * This field allows us to open the right version of the engine when you double-click on a .uproject file, and to detect when you </span><br><span class="hljs-comment"> * open a project with a different version of the editor and need the upgrade/downgrade UI flow. The normal engine </span><br><span class="hljs-comment"> * version doesn&#x27;t work for those purposes, because you can have multiple 4.x branches in various states on one machine.</span><br><span class="hljs-comment"> * For Launcher users, this field gets set to something stable like &quot;4.7&quot; or &quot;4.8&quot;, so you can swap projects and game binaries </span><br><span class="hljs-comment"> * between users, and it&#x27;ll automatically work on any platform or machine regardless of where the engine is installed. You </span><br><span class="hljs-comment"> * can only have one binary release of each major engine version installed at once.</span><br><span class="hljs-comment"> * For Perforce or Git users that branch the engine along with their games, this field is left blank. You can sync the repository </span><br><span class="hljs-comment"> * down on any platform and machine, and it can figure out which engine a project should use by looking up the directory </span><br><span class="hljs-comment"> * hierarchy until it finds one.</span><br><span class="hljs-comment"> * For other cases, where you have a source build of the engine but are working with a foreign project, we use a random identifier </span><br><span class="hljs-comment"> * for each local engine installation and use the registry to map it back to the engine directory. All bets are off as to which</span><br><span class="hljs-comment"> * engine you should use to open it on a different machine, and using a random GUID ensures that every new machine triggers the</span><br><span class="hljs-comment"> * engine selection UI when you open or attempt to generate project files for it. </span><br><span class="hljs-comment"> * For users which mount the engine through a Git submodule (where the engine is in a subdirectory of the project), this field </span><br><span class="hljs-comment"> * can be manually edited to be a relative path.</span><br><span class="hljs-comment"> * @see IDesktopPlatform::GetEngineIdentifierForProject</span><br><span class="hljs-comment"> * @see IDesktopPlatform::SetEngineIdentifierForProject</span><br><span class="hljs-comment"> * @see IDesktopPlatform::GetEngineRootDirFromIdentifier</span><br><span class="hljs-comment"> * @see IDesktopPlatform::GetEngineIdentifierFromRootDir</span><br><span class="hljs-comment"> */</span><br>FString EngineAssociation;<br><span class="hljs-comment">/** Category to show under the project browser */</span><br>FString Category;<br><span class="hljs-comment">/** Description to show in the project browser */</span><br>FString Description;<br><span class="hljs-comment">/** List of all modules associated with this project */</span><br>TArray&lt;FModuleDescriptor&gt; Modules;<br><span class="hljs-comment">/** List of plugins for this project (may be enabled/disabled) */</span><br>TArray&lt;FPluginReferenceDescriptor&gt; Plugins;<br><span class="hljs-comment">/** Array of platforms that this project is targeting */</span><br>TArray&lt;FName&gt; TargetPlatforms;<br><span class="hljs-comment">/** A hash that is used to determine if the project was forked from a sample */</span><br>uint32 EpicSampleNameHash;<br><span class="hljs-comment">/** Custom steps to execute before building targets in this project */</span><br>FCustomBuildSteps PreBuildSteps;<br><span class="hljs-comment">/** Custom steps to execute after building targets in this project */</span><br>FCustomBuildSteps PostBuildSteps;<br><span class="hljs-comment">/** Indicates if this project is an Enterprise project */</span><br><span class="hljs-keyword">bool</span> bIsEnterpriseProject;<br><span class="hljs-comment">/** Indicates that enabled by default engine plugins should not be enabled unless explicitly enabled by the project or target files. */</span><br><span class="hljs-keyword">bool</span> bDisableEnginePluginsByDefault;  <br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>FileVersion：描述项目版本；</p></li><li><p>EngineAssociation：引擎版本；</p></li><li><p>Category：这个分类着实是不知道有什么卵用；</p></li><li><p>Description：项目描述；</p></li><li><p>Modules：模块信息，是一个<code>FModuleDescriptor</code>类型的数组，数组中一个元素代表一个模块，<code>FModuleDescriptor</code>的具体描述在ModuleDescriptor.h</p><p>里面涉及很多模块的描述，最常使用的基本只有三个：</p><p>Name：模块名称；</p><p>Type：模块的使用类型，描述模块在什么时候能够使用；</p><p>Type是一个EHostType::Type类型，描述文件也在ModuleDescriptor.h中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> EHostType<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Type</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-comment">// Loads on all targets, except programs.</span><br>Runtime,<br><span class="hljs-comment">// Loads on all targets, except programs and the editor running commandlets.</span><br>RuntimeNoCommandlet,<br><span class="hljs-comment">// Loads on all targets, including supported programs.</span><br>RuntimeAndProgram,<br><span class="hljs-comment">// Loads only in cooked games.</span><br>CookedOnly,<br><span class="hljs-comment">// Only loads in uncooked games.</span><br>UncookedOnly,<br><span class="hljs-comment">// Deprecated due to ambiguities. Only loads in editor and program targets, but loads in any editor mode (eg. -game, -server).</span><br><span class="hljs-comment">// Use UncookedOnly for the same behavior (eg. for editor blueprint nodes needed in uncooked games), or DeveloperTool for modules</span><br><span class="hljs-comment">// that can also be loaded in cooked games but should not be shipped (eg. debugging utilities).</span><br>Developer,<br><span class="hljs-comment">// Loads on any targets where bBuildDeveloperTools is enabled.</span><br>DeveloperTool,<br><span class="hljs-comment">// Loads only when the editor is starting up.</span><br>Editor,<br><span class="hljs-comment">// Loads only when the editor is starting up, but not in commandlet mode.</span><br>EditorNoCommandlet,<br><span class="hljs-comment">// Loads only on editor and program targets</span><br>EditorAndProgram,<br><span class="hljs-comment">// Only loads on program targets.</span><br>Program,<br><span class="hljs-comment">// Loads on all targets except dedicated clients.</span><br>ServerOnly,<br><span class="hljs-comment">// Loads on all targets except dedicated servers.</span><br>ClientOnly,<br><span class="hljs-comment">// Loads in editor and client but not in commandlets.</span><br>ClientOnlyNoCommandlet,<br><span class="hljs-comment">//~ <span class="hljs-doctag">NOTE:</span> If you add a new value, make sure to update the ToString() method below!</span><br>Max<br>&#125;;<br></code></pre></td></tr></table></figure><p>LoadingPhase：模块的加载策略，控制模块的加载时机；</p><p>LoadingPhase是一个ELoadingPhase::Type类型，描述文件也在ModuleDescriptor.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> ELoadingPhase<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Type</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-comment">/** As soon as possible - in other words, uplugin files are loadable from a pak file (as well as right after PlatformFile is set up in case pak files aren&#x27;t used) Used for plugins needed to read files (compression formats, etc) */</span><br>EarliestPossible,<br><span class="hljs-comment">/** Loaded before the engine is fully initialized, immediately after the config system has been initialized.  Necessary only for very low-level hooks */</span><br>PostConfigInit,<br><span class="hljs-comment">/** The first screen to be rendered after system splash screen */</span><br>PostSplashScreen,<br><span class="hljs-comment">/** Loaded before coreUObject for setting up manual loading screens, used for our chunk patching system */</span><br>PreEarlyLoadingScreen,<br><span class="hljs-comment">/** Loaded before the engine is fully initialized for modules that need to hook into the loading screen before it triggers */</span><br>PreLoadingScreen,<br><span class="hljs-comment">/** Right before the default phase */</span><br>PreDefault,<br><span class="hljs-comment">/** Loaded at the default loading point during startup (during engine init, after game modules are loaded.) */</span><br>Default,<br><span class="hljs-comment">/** Right after the default phase */</span><br>PostDefault,<br><span class="hljs-comment">/** After the engine has been initialized */</span><br>PostEngineInit,<br><span class="hljs-comment">/** Do not automatically load this module */</span><br>None,<br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> If you add a new value, make sure to update the ToString() method below!</span><br>Max<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>Plugins：插件信息，是一个FPluginReferenceDescriptor数组，数组中一个元素代表一个插件，描述文件在PluginDescriptor.h和PluginReferenceDescriptor.h文件中</p><p>其中也包含大量的描述参数，最常用的基本也只有Name：插件名称，Enabled：是否启用插件。</p></li><li><p>TargetPlatforms：描述项目的目标平台；</p></li><li><p>EpicSampleNameHash：也没有研究出是干什么用的；</p></li><li><p>PreBuildSteps和PostBuildSteps：根据源码描述是用来在当前项目构建的前后执行一些自定义操作用的，具体怎么使用着实是找不到案例，查看了FCustomBuildSteps是一个很简单的结构体，里面只有一个叫HostPlatformToCommands的与命令行相关的TMap，和几个简单函数。</p></li><li><p>bIsEnterpriseProject：描述当前项目是否为企业项目；</p></li><li><p>bDisableEnginePluginsByDefault：是否启用引擎默认启用的插件，这是在FProjectDescriptor结构体中的变量，所以默认值为0。</p></li></ul><h1 id="二、类"><a href="#二、类" class="headerlink" title="二、类"></a>二、类</h1><h2 id="1-UE4中的预定义类"><a href="#1-UE4中的预定义类" class="headerlink" title="1.UE4中的预定义类"></a>1.UE4中的预定义类</h2><p>UE的预定义类，祥见<a href="https://goulandis.github.io/2022/01/27/%E3%80%90UE4%E3%80%91UE4%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">GamePlay架构</a>。</p><h2 id="2-C-类的创建"><a href="#2-C-类的创建" class="headerlink" title="2.C++类的创建"></a>2.C++类的创建</h2><h3 id="使用Unreal-Editor创建C-类"><a href="#使用Unreal-Editor创建C-类" class="headerlink" title="使用Unreal Editor创建C++类"></a>使用Unreal Editor创建C++类</h3><p>当我们创建一个C++编程模板时，在内容浏览器中会生成一个C++类文件夹，同时目录下还会生成一个项目名称文件夹，我们可以在对应的文件夹下右键创建一个C++类，选择新类需要继承的父类和存储位置后确定，UE4会自动打开VS，并生成一个<code>.cpp</code>文件和一个<code>.h文件</code>。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016001959.png"></p><p>勾选Show All Classes可以看到引擎支持的所有可继承的类。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002005.png"></p><p>在Path处可以直接添加新的文件夹名称，UE会自动创建新的文件夹来存放新建的类。</p><p>我们在创建类时可以选择后面的公有与私有，或者都不选</p><ul><li>选择公有，UE4会在C++Class/ProjectName文件夹下创建一个Public文件夹存放我们创建的类，而在VS中则会创建一个public文件夹存放.h文件，创建一个private文件夹存放.cpp文件；</li><li>选择私有，UE4会在C++Class/ProjectName文件夹下创建一个Public文件夹存放我们创建的类，而在VS中则将.h和.cpp都存放在private文件下；</li><li>如果都不选，则我们创建的类直接存放在C++Class/ProjectName文件夹下，而VS中.cpp和.h文件都存放在Source文件夹下。</li><li>如下图Unkown处是一个用于选择模块的下拉列表，可以选择当前创建的类应该放在哪个模块下，这个一般涉及到多模块时才使用，一般情况下都是直接选择当前项目，在UE的视角当前项目也是一个模块。</li></ul><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002010.png"></p><p>创建的C++类的<code>.h</code>文件的结构，以一个UObject为例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Fill out your copyright notice in the Description page of Project Settings.</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;UObject/NoExportTypes.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;PakExpand.generated.h&quot;</span></span><br><br>UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UNKOWN_API</span> <span class="hljs-title">UPakExpand</span> :</span> <span class="hljs-keyword">public</span> UObject<br>&#123;<br>GENERATED_BODY()<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>CoreMinimal.h头文件中包含了一些UE预定义需要包含的头文件；</p></li><li><p>NoExportTypes.h头文件中包含了大量的引擎需要的状态量；</p></li><li><p>.generated.h文件则是由UBT生成的用于反射的代码；</p></li><li><p>UCLASS()表示这个类加入UE4的反射系统，使用UCLASS()就必须包含.generated.h头文件；</p></li><li><p>XXX_API这个宏由UBT生成，XXX会被模块名代替，如我当前的项目名为Unkown，则生成UNKOWN_API，对于引擎来说，整个项目就是一个模块，UNKOWN_API标识这个类属于UNKOWN模块。、；</p></li><li><p>GENERATED_BODY()：</p><p><font color="red">这里GENERATED_BODY()宏处有两种情况，我们可以使用GENERATED_UCLASS_BODY()宏和GENERATED_BODY()宏，二者的区别是:</font></p><p><font color="red"> 使用了GENERATED_BODY()宏，我们的类中就不能直接使用父类中的声明，如果我们要去实现，我就必须在本类中声明。使用GENERATED_BODY()宏，我们必须手动实现一个无参构造函数。</font></p><p><font color="red">使用GENERATED_UCLASS_BODY()宏，我们就可以使用父类声明的构造函数，在本类中不需要再声明，而可以直接实现即可，且实现的构造函数必须带const FObjectInitializer&amp;参数。</font></p></li></ul><h3 id="在VS中手动创建类"><a href="#在VS中手动创建类" class="headerlink" title="在VS中手动创建类"></a>在VS中手动创建类</h3><p>VS中的工程目录的Source目录下的目录结构有两种：</p><ul><li>一堆的.cpp、.h和.build.cs文件。</li><li>.h文件在public目录下，.cpp文件在private目录下，.biuld.cs文件在Source目录下.。</li></ul><p>对于第一种目录结构，直接在Source文件夹下使用VS添加.cpp和.h文件即可。</p><p>对于第二种目录结构，我们需要在public下添加.h文件，在private下添加.cpp文件。</p><p>在VS中手动创建的类如果继承UObject，我们需要手动添加UCLASS()宏和GENERATED_BODY()或GENERATED_UCLASS_BODY()宏。</p><p><font color="red"> 但是要注意的是手动创建的类系统不会自动为类名加前缀，所以手动创建的类定义类名时应该合乎UE4C++类的命名规范。</font></p><h2 id="2-C-类的删除"><a href="#2-C-类的删除" class="headerlink" title="2.C++类的删除"></a>2.C++类的删除</h2><p>UE4引擎自身不提供C++的删除功能，但是有时候我们需要删除一些类的时候怎么办呢？</p><p>唯一的办法就是建立在文件操作上了，步骤如下：</p><ul><li>删除项目目录下Source文件夹下需要删除类的<code>.cpp</code>和<code>.h</code>文件；</li><li>重新Generate Visual Studio project files，生成sln文件；</li><li>双击.uproject文件，启动项目让引擎重新加载配置。</li></ul><h2 id="3-UE4类的命名规则"><a href="#3-UE4类的命名规则" class="headerlink" title="3.UE4类的命名规则"></a>3.UE4类的命名规则</h2><p>UE4为一些常用类的命名添加了一些命名前缀，<font color="red"> 如果我们不写这些前缀，UE4会编译错误</font>。</p><table><thead><tr><th>前缀</th><th>说明</th></tr></thead><tbody><tr><td>F</td><td>纯c++类</td></tr><tr><td>U</td><td>继承自UObject，但不继承自Actor的类</td></tr><tr><td>A</td><td>继承自Actor的类</td></tr><tr><td>S</td><td>Slate控件相关类</td></tr><tr><td>H</td><td>HitResult相关类</td></tr></tbody></table><h2 id="4-C-类的实例化"><a href="#4-C-类的实例化" class="headerlink" title="4.C++类的实例化"></a>4.C++类的实例化</h2><p>在UE4中实例化C++类稍显复杂，分为如下几种情况：</p><ul><li><p>如果是一个纯C++类型的类，即按UE4的命名规则F开头的类，符合C++的实例化条件，可以直接使用new运算符来实例化，或者直接使用构造函数在栈区中实例化；</p></li><li><p>如果是一个继承自UObject的类，那么我们需要使用<font color="red"><code>NewObject&lt;T&gt;()</code></font>函数来实例化类对象；</p></li><li><p>如果是一个继承自Actor的类，那么我们需要使用UWorld对象中的SpawnActor函数来实例化，调用方式为：<font color="red"> <code>GetWorld()-&gt;SpawnActor&lt;T&gt;()</code>， <code>GetWorld()-&gt;SpawnActor&lt;T&gt;()</code>不可以在构造函数中使用，如果直接在构造函数中使用UE4在编译时会直接崩溃。</font>；</p></li><li><p>如果我们需要产出一个Slate类，那么我们需要使用<font color="red"> SNew()</font>函数来实例化。</p></li></ul><h2 id="5-类的使用"><a href="#5-类的使用" class="headerlink" title="5.类的使用"></a>5.类的使用</h2><h3 id="继承自UObject类的C-类"><a href="#继承自UObject类的C-类" class="headerlink" title="继承自UObject类的C++类"></a>继承自UObject类的C++类</h3><p>UE中UObject类可以直接在C++中使用但是不能直接在蓝图中使用，如果想要在蓝图中使用一个继承自UObject的类，那么我们就可以使用UCLASS(Blueprintable)在类前说明，编译后就可以直接在蓝图中使用这个C++类，同时可以创建继承这个类的蓝图类，也可以在对应的类对象上右键创建蓝图类，否则创建蓝图类的按钮是非激活状态。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002017.png"></p><p>当然如果我们只需要在蓝图中使用，而不需要创建对应的蓝图类，我们可以使用UCLASS(BlueprintType)来描述。</p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">UCLASS(BlueprintType)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ARP_04_API</span> <span class="hljs-title">UTest</span> :</span> <span class="hljs-keyword">public</span> UObject<br>&#123;<br>GENERATED_BODY()<br><br>&#125;;<br></code></pre></td></tr></table></figure><p>除此之外，我们若想要让类里面的变量和函数也能被蓝图类使用，我同时还需要在变量前指定<code>UPROPERTY(BlueprintReadWrite)</code>，在函数前指定<code>UFUNCTION(BlueprintCallable)</code>，就如上面的实例代码一样。</p><p>UPROPERTY(BlueprintReadWrite)里的参数不是唯一的，<font color="red"> BlueprintReadWrite表示成员变量在蓝图类里可读写，BlueprintReadOnly表示成员变量在蓝图类里只读，BlueprintWriteOnly表示成员变量在蓝图类里只写</font>。</p><p>经过以上步骤我们的继承自UObject类的类便可以通过对应的蓝图类在关卡蓝图中使用了，使用BeginPlay节点开始程序，使用Construct节点来实例化我们的蓝图类，通过实例化出来的对象便可调用类中的资源了。</p><h3 id="继承自AActor类的C-类"><a href="#继承自AActor类的C-类" class="headerlink" title="继承自AActor类的C++类"></a>继承自AActor类的C++类</h3><p>由于AActor在UE中就是一个场景中的基本实体，所以继承自AActor类的C++类默认是可以直接被蓝图使用的。</p><h3 id="纯C-类"><a href="#纯C-类" class="headerlink" title="纯C++类"></a>纯C++类</h3><p>纯C++类完全脱离UE的反射系统，无法被UCLASS，UPROPERTY等宏修饰，所以无法被蓝图使用。由于纯C++类无法使用UE的反射系统，所以也就不支持UE的GC系统，所以UE提供了共享指针来管理纯C++类。</p><h2 id="6-抽象类"><a href="#6-抽象类" class="headerlink" title="6.抽象类"></a>6.抽象类</h2><p>UE对C++的抽象类也进行了魔改，UE使用UCLASS(abstract)宏来标识一个类是抽象类，对于UObject类和AActor类的抽象类在实例化上又有所区别。</p><h3 id="继承自UObject的抽象类"><a href="#继承自UObject的抽象类" class="headerlink" title="继承自UObject的抽象类"></a>继承自UObject的抽象类</h3><p>使用UCLASS(abstract)宏标识一个UObject类，那么这个UObject类就是一个于C++抽象类基本一致的抽象类了，由于在C++中抽象类是不可以实例化的，所以如果代码中去实例化了一个抽象类，编译阶段就会报错，但是由于编译器不完全支持UE魔改后的C++标准，所以即使我们在代码里去实例化了一个抽象类，编译也不会报错，只有在编辑器运行时，真正跑到这行代码时才会报错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">UCLASS(abstract)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROJECT_API</span> <span class="hljs-title">UAbstractObject</span> :</span> <span class="hljs-keyword">public</span> UObject<br>&#123;<br>GENERATED_BODY()<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Log</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>之所以编译阶段不会报错是因为，UE是通过UCLASS(abstract)宏来标识抽象类的，所以即使一个类没有纯虚函数UE也可以识别它为抽象类，但这个类在C++层面其实不是抽象类，所以编译阶段不会出现错误，当然我们也可以给这个类创建一个纯虚函数，是这类成为一个真正意义上的抽象类。</p><h3 id="继承自AActor的抽象类"><a href="#继承自AActor的抽象类" class="headerlink" title="继承自AActor的抽象类"></a>继承自AActor的抽象类</h3><p>继承自AActor的抽象类在实例化上和UObject有一些区别，一个不包含纯虚函数的AActor抽象类在运行时是可以被实例化的，UE编辑器仅仅是报出一个警告，标识为抽象类的Actor不可以被放入场景中，但是却可以在C++中使用SapwnActor函数实例化，并且实例是有效的，只是Actor不会被spawn到场景中，只能像UObject一样驻留在内存中。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">UCLASS(abstract)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROJECT_API</span> <span class="hljs-title">AAbstractBase</span> :</span> <span class="hljs-keyword">public</span> AActor<br>&#123;<br>GENERATED_BODY()<br><span class="hljs-keyword">public</span>:<br>AAbstractBase();<br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Tick</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Log</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>    UE_LOG(LogTemp, Error, TEXT(<span class="hljs-string">&quot;AAbstractBase::Log()&quot;</span>));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后在另一个Actor—AAbstractOpreater的BeginPlay中去实例化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AAbstractOpreater::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br>    AAbstractBase* AbstractBase = GWorld-&gt;SpawnActor&lt;AAbstractBase&gt;();    <br>    AbstractBase-&gt;Log();<br>&#125;<br></code></pre></td></tr></table></figure><p>然后将AAbstractOpreater丢进场景中运行，看看结果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002024.png"></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002026.png"></p><p>可以看到AAbstractBase虽然被实例化了，并且Log函数也调用成功了，但是场景中并没有AAbstractBase这个Actor。</p><p>这估计是UE的bug吧，在使用时抽象类最好还是创建一个纯虚函数，以符合C++的标准。</p><h2 id="7-接口"><a href="#7-接口" class="headerlink" title="7.接口"></a>7.接口</h2><p>与C++的接口不同，UE对C++的接口进行了魔改，我们先创建一个UE接口来看一下，UE的接口长什么样。</p><p>我们要创建一个UE的接口，那么我们就需要使自己的接口继承自UInterface，在编辑器里则是选择：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002030.png"></p><p>创建出来的接口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;UObject/Interface.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;UnkInterface.generated.h&quot;</span></span><br><br><span class="hljs-comment">// This class does not need to be modified.</span><br>UINTERFACE(MinimalAPI)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UUnkInterface</span> :</span> <span class="hljs-keyword">public</span> UInterface<br>&#123;<br>GENERATED_BODY()<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROJECT_API</span> <span class="hljs-title">IUnkInterface</span></span><br><span class="hljs-class">&#123;</span><br>GENERATED_BODY()<br><span class="hljs-comment">// Add interface functions to this class. This is the class that will be inherited to implement this interface.</span><br><span class="hljs-keyword">public</span>:<br><br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到.h文件里面有两个类，一个是继承自UInterface，一个为纯C++类，UE这样做的目的就是为了使接口也接入UE的对象系统，因为UInterface的顶层基类也是UObject，但是这就出现了另一个问题，即继承自UObject的其他类如果想要使用UE接口，就会出现菱形继承，为了使开发者避免自己使用虚继承来避开菱形继承问题，UE就直接魔改了C++的接口。</p><p>其中两部分 UInterface负责对象系统，即接口也能使用UE的反射系统和GC系统，而纯C++类部分则负责具体的接口内容，使用方式完全和C++一样，同时由于接口接入UE的反射系统，所以接口行数可以使用UFUNCTION来暴漏给蓝图。</p><h3 id="C-使用接口"><a href="#C-使用接口" class="headerlink" title="C++使用接口"></a>C++使用接口</h3><p>C++使用接口，和普通C++一样，直接继承并实现所有接口的纯虚函数，然后使用即可。</p><h3 id="蓝图使用接口"><a href="#蓝图使用接口" class="headerlink" title="蓝图使用接口"></a>蓝图使用接口</h3><p>虽然UE提供了纯蓝图的接口，但是纯蓝图接口限制比较多，不能设置成员变量，也不能在接口中对函数进行实现，所以很多时候还是会需要用到C++接口，比如要写一些通用接口的时候，但是C++接口可以声明成员变量却不能暴漏给蓝图，估计是UE接口的特殊实现方式决定的。</p><p>C++接口默认暴漏给蓝图，所以不需要再使用UCLASS(BlueprintCallable)或UCLASS(BlueprintType)去暴漏，但是蓝图只能看到接口暴漏给蓝图的函数和变量，<font color="red">蓝图类继承一个包含纯虚函数的接口，可以不实现，因为在UE中纯虚函数是不能暴漏给蓝图的。</font></p><p>所以如果蓝图要继承一个C++接口，那么C++接口中的函数就需要暴漏给蓝图，函数需要使用UFUNCTION(BlueprintNativeEvent)和UFUNCTION(BlueprintNativeEvent)暴漏给蓝图。</p><ul><li><p>BlueprintNativeEvent：BlueprintNativeEvent可以使一个函数在C++中声明并在C++中实现，然后提供给蓝图可重写的能力，如果蓝图不重写，那么蓝图调用时就使用C++的实现，如果蓝图重写了，那么蓝图调用时就是用蓝图重写的实现。<font color="red">在UE C++接口中被BlueprintNativeEvent标识函数需要在C++中实现一个<code>[FunctionName]_Implementation</code>的函数体，并且必须要配合一个<code>virtual [FunctionName]_Implementation</code>函数声明，二者缺一都会导致程序编译不过</font>，如：</p><p>.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;UObject/Interface.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;UnkInterface.generated.h&quot;</span></span><br><br>UINTERFACE(MinimalAPI)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UUnkInterface</span> :</span> <span class="hljs-keyword">public</span> UInterface<br>&#123;<br>GENERATED_BODY()<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROJECT_API</span> <span class="hljs-title">IUnkInterface</span></span><br><span class="hljs-class">&#123;</span><br>GENERATED_BODY()<br><span class="hljs-keyword">public</span>:<br>    UFUNCTION(BlueprintNativeEvent)<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Log</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString&amp; msg)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Log_Implementation</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString&amp; msg)</span></span>;<br>    UFUNCTION(BlueprintImplementableEvent)<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Log2</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString&amp; msg)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;UnkInterface.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">IUnkInterface::Log_Implementation</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString&amp; msg)</span></span><br><span class="hljs-function"></span>&#123;<br>    UE_LOG(LogTemp, Error, TEXT(<span class="hljs-string">&quot;IUnkInterface::Log_Implementation(%s)&quot;</span>), *msg);<br>&#125;<br></code></pre></td></tr></table></figure><p>当然如果BlueprintNativeEvent标识的函数去掉<code>virtual [FunctionName]_Implementation</code>函数体声明和<code>[FunctionName]_Implementation</code>函数体定义也是可以编译过的，只是这样就失去了BlueprintNativeEvent的意义。如：</p><p>.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;UObject/Interface.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;UnkInterface.generated.h&quot;</span></span><br><br>UINTERFACE(MinimalAPI)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UUnkInterface</span> :</span> <span class="hljs-keyword">public</span> UInterface<br>&#123;<br>GENERATED_BODY()<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROJECT_API</span> <span class="hljs-title">IUnkInterface</span></span><br><span class="hljs-class">&#123;</span><br>GENERATED_BODY()<br><span class="hljs-keyword">public</span>:<br>    UFUNCTION(BlueprintNativeEvent)<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Log</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString&amp; msg)</span></span>;<br>    UFUNCTION(BlueprintImplementableEvent)<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Log2</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString&amp; msg)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;UnkInterface.h&quot;</span></span><br></code></pre></td></tr></table></figure><p><font color="red">这里有一点是需要注意的，C++接口中使用BlueprintNativeEvent和在普通的类中使用BlueprintNativeEvent是有所不同的，如前面所说，接口中使用BlueprintNativeEvent必须配合一个<code>virtual [FunctionName]_Implementation</code>声明并且必须实现<code>[FunctionName]_Implementation</code>函数体，而在普通的UE类中使用BlueprintNativeEvent则不需要带<code>virtual [FunctionName]_Implementation</code>声明，只需要实现<code>[FunctionName]_Implementation</code>函数体即可。</font></p><p>这可能是因为C++接口既要考虑蓝图实现，又要考虑C++实现的原因，<code>virtual [FunctionName]_Implementation</code>声明就是为了给C++实现这个函数留接口。</p></li><li><p>BlueprintImplementableEvent：BlueprintImplementableEvent标识的函数不能有C++实现，必须由蓝图来重写，BlueprintImplementableEvent标识的函数可以看成是相对于蓝图的纯虚函数。如上面代码中Log2函数，C++中是没有函数体实现的。</p></li></ul><h3 id="BlueprintNativeEvent和BlueprintImplementableEvent函数的蓝图实现"><a href="#BlueprintNativeEvent和BlueprintImplementableEvent函数的蓝图实现" class="headerlink" title="BlueprintNativeEvent和BlueprintImplementableEvent函数的蓝图实现"></a>BlueprintNativeEvent和BlueprintImplementableEvent函数的蓝图实现</h3><ul><li><p><font color="red">参数中使用了FString类的时候有一个坑，即所有的FString参数都必须使用引用—FString&amp;，否则编译时会报没有找到重载的成员函数，但是使用引用又会引出另一个问题，就是引用类型参数暴漏给蓝图是作为蓝图函数返回值来使用的，如果想要FString&amp;作为输入参数，那么就必须使用const FString&amp;。</font></p></li><li><p>BlueprintNativeEvent和BlueprintImplementableEvent标识的函数暴漏给蓝图，根据是否有返回值在蓝图中的表现是不一样的，不带返回值的函数在蓝图中以事件的形式存在，需要通过右键菜单调出重写，在接口栏表现为一个黄色的函数标识；带返回值的函数在蓝图中表现为普通的函数，可以直接双击接口栏的函数名重写，在接口栏表现为一个蓝色的函数标识。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002037.png"></p></li></ul><h3 id="C-调用蓝图的接口实现"><a href="#C-调用蓝图的接口实现" class="headerlink" title="C++调用蓝图的接口实现"></a>C++调用蓝图的接口实现</h3><p>UE接口的实现原理使得同一个UE接口既可以被C++继承也可以被蓝图继承，于是就会涉及到C++来调用蓝图的接口实现的情况，事实上C++调用蓝图的接口实现依旧是通过蓝图子类重写父类函数的方式实现的，只是说通过接口的方式调用可以做到比重写子类的方式更加灵活的多态。</p><p>比如我们现在创建6个类，分别是动物：Animal，狗狗：Dog，飞禽：Bird，母鸡：Chicken，动物园：Zoo以及接口IMove</p><p>Animal.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROJECT_API</span> <span class="hljs-title">AAnimal</span> :</span> <span class="hljs-keyword">public</span> AActor,<span class="hljs-keyword">public</span> IMove<br>&#123;<br>GENERATED_BODY()<br><span class="hljs-keyword">public</span>:<br>AAnimal();<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Tick</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime)</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Dog.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROJECT_API</span> <span class="hljs-title">ADog</span> :</span> <span class="hljs-keyword">public</span> AAnimal<br>&#123;<br>GENERATED_BODY()<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Move_Implementation</span><span class="hljs-params">()</span></span>;<br>    &#123;<br>        UE_LOG(LogTemp, Error, TEXT(<span class="hljs-string">&quot;Dog can creep&quot;</span>));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Bird.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROJECT_API</span> <span class="hljs-title">ABird</span> :</span> <span class="hljs-keyword">public</span> AAnimal<br>&#123;<br>GENERATED_BODY()<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Move_Implementation</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>    UE_LOG(LogTemp, Error, TEXT(<span class="hljs-string">&quot;Bird can fly&quot;</span>));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Move.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++">UINTERFACE(MinimalAPI)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UMove</span> :</span> <span class="hljs-keyword">public</span> UInterface<br>&#123;<br>GENERATED_BODY()<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROJECT_API</span> <span class="hljs-title">IMove</span></span><br><span class="hljs-class">&#123;</span><br>GENERATED_BODY()<br><span class="hljs-keyword">public</span>:<br>    UFUNCTION(BlueprintNativeEvent,Category=<span class="hljs-string">&quot;IMove&quot;</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Move</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Move_Implementation</span><span class="hljs-params">()</span></span>;<br>    UFUNCTION(BlueprintImplementableEvent, Category = <span class="hljs-string">&quot;IMove&quot;</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Shout</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString&amp; Cry)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Move.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Interface/Move.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">IMove::Move_Implementation</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    UE_LOG(LogTemp, Error, TEXT(<span class="hljs-string">&quot;Animal can move&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>Zoo.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROJECT_API</span> <span class="hljs-title">AZoo</span> :</span> <span class="hljs-keyword">public</span> AActor<br>&#123;<br>GENERATED_BODY()<br><span class="hljs-keyword">public</span>:<br>AZoo();<br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Tick</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AnimalObservationDiary</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AnimalAction</span><span class="hljs-params">(AAnimal* Animal)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Zoo.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Interface/Zoo.h&quot;</span></span><br><span class="hljs-comment">//...</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AZoo::AnimalObservationDiary</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    AAnimal* Animal;<br>    UE_LOG(LogTemp, Error, TEXT(<span class="hljs-string">&quot;Animal Action:&quot;</span>));<br>    Animal = GWorld-&gt;SpawnActor&lt;AAnimal&gt;();<br>    AnimalAction(Animal);<br>    UE_LOG(LogTemp, Error, TEXT(<span class="hljs-string">&quot;Dog Action:&quot;</span>));<br>    Animal = GWorld-&gt;SpawnActor&lt;ADog&gt;();<br>    AnimalAction(Animal);<br>    UE_LOG(LogTemp, Error, TEXT(<span class="hljs-string">&quot;Bird Action:&quot;</span>));<br>    Animal = GWorld-&gt;SpawnActor&lt;ABird&gt;();<br>    AnimalAction(Animal);<br>    UE_LOG(LogTemp, Error, TEXT(<span class="hljs-string">&quot;Bird Action:&quot;</span>));<br>    UClass* ChickenClass = StaticLoadClass(ABird::StaticClass(), <span class="hljs-literal">nullptr</span>, TEXT(<span class="hljs-string">&quot;Blueprint&#x27;/Game/CPlus/Chicken.Chicken_C&#x27;&quot;</span>));<br>    <span class="hljs-keyword">if</span> (ChickenClass != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        Animal = GWorld-&gt;SpawnActor &lt;ABird&gt;(ChickenClass);<br>        AnimalAction(Animal);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AZoo::AnimalAction</span><span class="hljs-params">(AAnimal* Animal)</span></span><br><span class="hljs-function"></span>&#123;<br>    UClass* AnimalClass = Animal-&gt;GetClass();<br>    <span class="hljs-keyword">if</span> (AnimalClass-&gt;ImplementsInterface(UMove::StaticClass()))<br>    &#123;<br>        IMove* Move = CastChecked&lt;IMove&gt;(Animal);<br>        IMove::Execute_Move(Animal);<br>        IMove::Execute_Shout(Animal, <span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以及继承自Bird的蓝图类Chicken</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002043.png"></p><ul><li>ImplementsInterface：检测一个类是否实现了接口；</li><li><code>IMove* Move = CastChecked&lt;IMove&gt;(Animal)</code>：通过接口指针指向子类，实现多态；</li><li>IMove::Execute_Shout(Animal, “ “)：UE4C++调用蓝图的接口实现，由于蓝图属于C++的上层，所以UE使用了Execute_XX的反射调用方式，第一个参数必须为要调用的对象，后面用空格隔开要传入的参数。</li></ul><p>全部实现之后我们把Zoo类丢进场景里，运行下看看：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002047.png"></p><p>可以看到C++通过接口调用到了蓝图函数。</p><p><font color="red">这里面有一个坑，就是如果蓝图类是一个纯蓝图类直接去继承IMove接口，而不是像上面一样通过一个Animal父类去继承IMove接口，那么Zoo::AnimalAction在调用蓝图的接口实现的时候将会产生断言。</font></p><h1 id="三、字符串"><a href="#三、字符串" class="headerlink" title="三、字符串"></a>三、字符串</h1><h2 id="1-FString"><a href="#1-FString" class="headerlink" title="1.FString"></a>1.FString</h2><p>FString是UE4C++编程中极其常用的一个UE4字符串封装类型，是UE4自带字符串类型中唯一可以进行各种字符串操作的字符串类型，同时FString的资源消耗也是最大的。FString的底层事实上是一个TCHAR的数组。</p><h3 id="FString初始化"><a href="#FString初始化" class="headerlink" title="FString初始化"></a>FString初始化</h3><ul><li>方法1：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">FString fStr = FString(TEXT(<span class="hljs-string">&quot;str&quot;</span>)); <br></code></pre></td></tr></table></figure><ul><li>方法2：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">FString fStr = FString(<span class="hljs-string">&quot;str&quot;</span>); <br></code></pre></td></tr></table></figure><ul><li>方法3：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">FString fStr = <span class="hljs-string">&quot;str&quot;</span>; <br></code></pre></td></tr></table></figure><ul><li>方法4：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">FString fStr = TEXT(<span class="hljs-string">&quot;str&quot;</span>); <br></code></pre></td></tr></table></figure><h3 id="FString的中文乱码"><a href="#FString的中文乱码" class="headerlink" title="FString的中文乱码"></a>FString的中文乱码</h3><p>默认情况下我们用FString存储一个中文字符串，在UE里使用，如使用UE_LOG打印是会出现乱码的情况的，这是因为VS在国区默认使用的文件编码为GB2313和UE使用的UTF-8编码不一致导的，我们需要把cpp文件的编码格式换成UTF-8即可。</p><p>默认情况下VS把设置文件编码的入口隐藏了起来，所以要想设置文件编码我们还需要把设置入口给显示出来。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002100.png"></p><p>然后高级保存选项就出来了，然后设置文件编码格式。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002104.png"></p><p>然后我们来测试一下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AAbstractOpreater::FStringConvert</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    FString fStr = TEXT(<span class="hljs-string">&quot;中文&quot;</span>);<br>    UE_LOG(LogTemp, Error, TEXT(<span class="hljs-string">&quot;fStr:%s&quot;</span>),*fStr);<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002108.png"></p><h2 id="2-FName"><a href="#2-FName" class="headerlink" title="2.FName"></a>2.FName</h2><p>FName也是UE4自带的字符串类型，FName是不区分大小写的，赋予FName的字符串会被存放到UE4的数据表中，多个FName赋予相同的字符串时都会指向同一个数据表地址。FName被赋值之后不可改变也不能被操作，FName的不可改变的性质和C++的string类很相似，std::string在修改时事实上是创建了一个新的字符串，而不是修改原字符串，因为FName的这些性质使得FName的查找和访问非常快。</p><ul><li>FName的初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">FName fn1 = FName(TEXT(<span class="hljs-string">&quot;str&quot;</span>));<br>FName fn2 = FName(<span class="hljs-string">&quot;str&quot;</span>);<br>FName fn3 = <span class="hljs-string">&quot;str&quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="3-FText"><a href="#3-FText" class="headerlink" title="3.FText"></a>3.FText</h2><p>FText是一个FString的升级版字符串，存储容量比FString要大很多，主要用于UE4的文本存储与处理。FText主要涉及UE的文本本地化处理。</p><p>FText不可以像FString和FName一样从构造函数通过TCHAR构建，FText从构造函数只能构建一个空FText，要想构建一个有内容的FText，则需要使用FText::FromString，FText::FromName，FText::AsCultureInvariant。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">FString fStr = TEXT(<span class="hljs-string">&quot;fStr&quot;</span>);<br>FName fn = FName(TEXT(<span class="hljs-string">&quot;fn&quot;</span>));<br>FText ft1 = FText();<br>FText ft2 = FText::FromString(fStr);<br>FText ft3 = FText::AsCultureInvariant(fStr);<br></code></pre></td></tr></table></figure><h2 id="4-TCHAR"><a href="#4-TCHAR" class="headerlink" title="4.TCHAR"></a>4.TCHAR</h2><p>TCHAR就是UE层面的char类型了，TCHAR是UE对C++的char和wchar_t的封装，C++的char和wchar_t适用于不同的平台，而TCHAR则将二者的操作进行了统一，使得TCHAR具备可以移植性。</p><p>事实上TCHAR不是对char和wchar_t的直接封装，UE将char封装成了ANSICHAR，将wchar_t封装成了WIDECHAR，而TCHAR则是对ANSICHAR和WIDECHAR的再封装。</p><p>UE对C++类型的封装都在GenericPlatform.h文件里。</p><h2 id="7-TChar"><a href="#7-TChar" class="headerlink" title="7.TChar"></a>7.TChar</h2><p>TChar是一个针对ASCII编码的字符串操作的封装泛型结构体，提供一系列方法操作字符串。</p><p>其中UE还对专门将<code>TChar&lt;TCHAR&gt;</code>封装成了<code>FChar</code>，将<code>TChar&lt;WIDECHAR&gt;</code>封装成了<code>FCharWide</code>，将<code>TChar&lt;ANSICHAR&gt;</code>封装成了<code>FCharAnsi</code></p><h2 id="8-TCString"><a href="#8-TCString" class="headerlink" title="8.TCString"></a>8.TCString</h2><p>TCString和TChar类似，是UE专门封装的用于处理C字符串的泛型结构体，其中对ANSICHAR和WIDECHAR字符做了专门实现，提供一系列方法操作C字符串。</p><p>和TChar一样，TCString也对一些常用的类型做了封装，<code>TCString&lt;TCHAR&gt;</code>封装成<code>FCString</code>，<code>TCString&lt;ANSICHAR&gt;</code>封装成<code>FCStringAnsi</code>，<code>TCString&lt;WIDECHAR&gt;</code>封装成<code>FCStringWide</code>。</p><h2 id="9-TStringView"><a href="#9-TStringView" class="headerlink" title="9.TStringView"></a>9.TStringView</h2><p>TStringView和FString用法基本上是一样的，底层也是对TCHAR的封装，只是TStringView有着自己的特殊的使用场景，按照源码的说明就是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * String View</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * A string view is implicitly constructible from const char* style strings and from compatible character ranges such as FString and TStringBuilderBase.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * A string view does not own any data nor does it attempt to control any lifetimes, it merely points at a subrange of characters in some other string. It&#x27;s up to the user to ensure the underlying string stays valid for the lifetime of the string view.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * A string view is cheap to copy and is intended to be passed by value.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * A string view does not represent a NUL terminated string and therefore you should never pass in the pointer returned by GetData() into a C-string API accepting only a pointer. You must either use a string builder to make a properly terminated string, or use an API that accepts a length argument in addition to the C-string.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * String views are a good fit for arguments to functions which don&#x27;t wish to care which style of string construction is used by the caller. If you accept strings via string views then the caller is free to use FString, FStringBuilder, raw C strings, or any other type which can be converted into a string view.</span><br><span class="hljs-comment"> **/</span><br></code></pre></td></tr></table></figure><p>谷歌翻译过来就是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 字符串视图</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 字符串视图可以从 const char* 样式字符串和兼容的字符范围（例如 FString 和 TStringBuilderBase）隐式构造。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 字符串视图不拥有任何数据，也不尝试控制任何生命周期，它仅指向其他字符串中的字符子范围。由用户确保底层字符串在字符串视图的生命周期内保持有效。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 字符串视图复制起来很便宜，并且旨在按值传递。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 字符串视图不代表 NUL 终止的字符串，因此您永远不应将 GetData() 返回的指针传递给仅接受指针的 C 字符串 API。您必须使用字符串生成器来生成正确终止的字符串，或者使用除了 C 字符串之外还接受长度参数的 API。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 字符串视图非常适合不希望关心调用者使用哪种字符串构造方式的函数的参数。如果您通过字符串视图接受字符串，则调用者可以自由使用 FString、FStringBuilder、原始 C 字符串或任何其他可以转换为字符串视图的类型。</span><br><span class="hljs-comment"> **/</span><br></code></pre></td></tr></table></figure><p>和TChar，TCString一样，TStringView也将<code>TStringView&lt;TCHAR&gt;</code>封装成了<code>FStringView</code>，<code>TStringView&lt;ANSICHAR&gt;</code>封装成了<code>FAnsiStringView</code>，<code>TStringView&lt;WIDECHAR&gt;</code>封装成了<code>FWideStringView</code>。</p><p>不过TStringView实际使用过程中好像也没什么用😂。</p><h2 id="10-TEXT"><a href="#10-TEXT" class="headerlink" title="10.TEXT()"></a>10.TEXT()</h2><p>TEXT宏又是对TCHAR的一层封装，使得TCHAR更易于使用，TEXT宏可以使其包裹的字符串根据设备自行选择最适合的编码格式，所以在UE里使用字符串时最好使用TEXT宏包裹，使代码的兼容性更好。</p><p><font color="red"> 需要注意的是TEXT()宏不支持中文，如果转码中文UE4在打印时会变成乱码。</font></p><h2 id="11-各字符串之间的转换"><a href="#11-各字符串之间的转换" class="headerlink" title="11.各字符串之间的转换"></a>11.各字符串之间的转换</h2><h3 id="FString-gt-FName"><a href="#FString-gt-FName" class="headerlink" title="FString-&gt;FName"></a>FString-&gt;FName</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">FString fStr = TEXT(<span class="hljs-string">&quot;fStr&quot;</span>);<br>FName fn = FName(*fStr);<br></code></pre></td></tr></table></figure><h3 id="FString-gt-FText"><a href="#FString-gt-FText" class="headerlink" title="FString-&gt;FText"></a>FString-&gt;FText</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">FString fStr = TEXT(<span class="hljs-string">&quot;fStr&quot;</span>);<br>FText ft = FText::FromString(fStr)<br></code></pre></td></tr></table></figure><h3 id="FString-gt-bool"><a href="#FString-gt-bool" class="headerlink" title="FString-&gt;bool"></a>FString-&gt;bool</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">FString fStr = TEXT(<span class="hljs-string">&quot;fStr&quot;</span>);<br><span class="hljs-keyword">bool</span> b = fStr.ToBool();<br></code></pre></td></tr></table></figure><h3 id="FString-gt-int"><a href="#FString-gt-int" class="headerlink" title="FString-&gt;int"></a>FString-&gt;int</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">FString fStr = TEXT(<span class="hljs-string">&quot;fStr&quot;</span>);<br><span class="hljs-keyword">int</span> i = FCString::Atoi(*fStr);<br></code></pre></td></tr></table></figure><h3 id="FString-gt-float"><a href="#FString-gt-float" class="headerlink" title="FString-&gt;float"></a>FString-&gt;float</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">FString fStr = TEXT(<span class="hljs-string">&quot;fStr&quot;</span>);<br><span class="hljs-keyword">float</span> f = FCString::Atof(*fStr);<br></code></pre></td></tr></table></figure><h3 id="FString-gt-char"><a href="#FString-gt-char" class="headerlink" title="FString-&gt;char*"></a>FString-&gt;char*</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">FString fStr = TEXT(<span class="hljs-string">&quot;fStr&quot;</span>);<br><span class="hljs-keyword">char</span>* chr = TCHAR_TO_ANSI(*fStr);<br></code></pre></td></tr></table></figure><h3 id="FString-gt-std-string"><a href="#FString-gt-std-string" class="headerlink" title="FString-&gt;std::string"></a>FString-&gt;std::string</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">FString fStr = TEXT(<span class="hljs-string">&quot;fStr&quot;</span>);<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> str = TCHAR_TO_UTF8(*fStr);<br></code></pre></td></tr></table></figure><h3 id="char-gt-FString"><a href="#char-gt-FString" class="headerlink" title="char* -&gt;FString"></a>char* -&gt;FString</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">char</span>* chr = <span class="hljs-string">&quot;chr&quot;</span>;<br>FString fStr = ANSI_TO_TCHAR(chr)<br></code></pre></td></tr></table></figure><h3 id="std-string-gt-FString"><a href="#std-string-gt-FString" class="headerlink" title="std::string-&gt;FString"></a>std::string-&gt;FString</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;str&quot;</span><br>FString fStr = FString(str.c_str());<br></code></pre></td></tr></table></figure><h3 id="FName-gt-FStirng"><a href="#FName-gt-FStirng" class="headerlink" title="FName-&gt;FStirng"></a>FName-&gt;FStirng</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">FName fn = FName(<span class="hljs-string">&quot;fn&quot;</span>);<br>FString fstr = fn.ToString();<br></code></pre></td></tr></table></figure><h3 id="FText-gt-FString"><a href="#FText-gt-FString" class="headerlink" title="FText-&gt;FString"></a>FText-&gt;FString</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">FText ft = FText(<span class="hljs-string">&quot;ft&quot;</span>);<br>FString fstr = ft.ToString();<br></code></pre></td></tr></table></figure><h3 id="float-gt-FString"><a href="#float-gt-FString" class="headerlink" title="float-&gt;FString"></a>float-&gt;FString</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">float</span> FloatValue = <span class="hljs-number">0.1f</span>;<br>FString fstr = FString::SanitizeFloat(FloatValue);<br></code></pre></td></tr></table></figure><h3 id="int-gt-FString"><a href="#int-gt-FString" class="headerlink" title="int-&gt;FString"></a>int-&gt;FString</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> IntValue = <span class="hljs-number">1</span>;<br>FString fstr = FString::FromInt(IntValue);<br></code></pre></td></tr></table></figure><h3 id="bool-gt-FString"><a href="#bool-gt-FString" class="headerlink" title="bool-&gt;FString"></a>bool-&gt;FString</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">bool</span> InBool = <span class="hljs-literal">true</span><br>FString fstr = InBool?TEXT(<span class="hljs-string">&quot;true&quot;</span>):TEXT(<span class="hljs-string">&quot;false&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="FVector-gt-FString"><a href="#FVector-gt-FString" class="headerlink" title="FVector-&gt;FString"></a>FVector-&gt;FString</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">FVector Vec = FVector(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>FString fstr = Vec.ToString();<br></code></pre></td></tr></table></figure><h3 id="FVector2D-gt-FString"><a href="#FVector2D-gt-FString" class="headerlink" title="FVector2D-&gt;FString"></a>FVector2D-&gt;FString</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">FVector2D Vec2D = FVector2D(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>FString fstr = Vec2D.ToString();<br></code></pre></td></tr></table></figure><h3 id="FRotator-gt-FString"><a href="#FRotator-gt-FString" class="headerlink" title="FRotator-&gt;FString"></a>FRotator-&gt;FString</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">FRotator Rot = FRotator(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>FString fstr = Rot.ToString();<br></code></pre></td></tr></table></figure><h3 id="UObject-gt-FString"><a href="#UObject-gt-FString" class="headerlink" title="UObject-&gt;FString"></a>UObject-&gt;FString</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">UObject* InObj = NewObject&lt;UObject&gt;();<br>FString fstr = (InObj != <span class="hljs-literal">NULL</span>)?InObj-&gt;GetName():FString(TEXT(<span class="hljs-string">&quot;None&quot;</span>));<br></code></pre></td></tr></table></figure><h2 id="12-TCHAR与char，wchar-t的转换"><a href="#12-TCHAR与char，wchar-t的转换" class="headerlink" title="12.TCHAR与char，wchar_t的转换"></a>12.TCHAR与char，wchar_t的转换</h2><p>C++支持两种字符集：ANSI和Unicode，ANSI字符集对应char，Unicode字符集对应wchar_t，其中Unicode字符集又分为三种编码：UTF-8，UTF-16，UTF-32，不同的字符集适应不用的平台，而TCHAR是UE对C++的char和wchat_t的封装，统一了char和wchar_t的操作，是UE的字符具有可移植性。</p><ul><li><p>TCHAR_TO_ANSI：使用ANSI字符集将<code>TCHAR*</code>转换成<code>char*</code>；</p></li><li><p>ANSI_TO_TCAHR：将ANSI字符集的<code>char*</code>转换成<code>TCHAR*</code>；</p></li><li><p>TCHAR_TO_UTF8：使用Unicode字符集UTF-8编码将<code>TCHAR*</code>转换成<code>char*</code>；</p></li><li><p>UTF8_TO_TCAHR：将Unicode字符集UTF-8编码的<code>char*</code>转换成<code>TCHAR*</code>。</p><p>同理还有TCAHR_TO_UTF16，UFT16_TO_TCAHR，TCHAR_TO_UTF32，UTF32_TO_TCHAR。</p></li><li><p>TCHAR_TO_WCHAR：将<code>TCAHR*</code>转换成<code>wchar_t*</code>；</p></li><li><p>WCHAR_TO_TCAHR：将<code>wchat_t*</code>转换成<code>TCAHR*</code>，或者使用强转，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">wchar_t</span> str = <span class="hljs-string">L&quot;str&quot;</span>;<br>TCAHR* tchr = (TCAHR*)str;<br></code></pre></td></tr></table></figure><h1 id="四、枚举与结构体"><a href="#四、枚举与结构体" class="headerlink" title="四、枚举与结构体"></a>四、枚举与结构体</h1></li></ul><h2 id="1-枚举"><a href="#1-枚举" class="headerlink" title="1.枚举"></a>1.枚举</h2><p>UE遵循C++11标准，所以枚举的构造有两种形式：</p><p>C++11以前的标准形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">UENUM()<br><span class="hljs-keyword">namespace</span> EnumSpace<br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">NEnum</span></span><br><span class="hljs-class">    &#123;</span><br>        NE_A,<br>        NE_B<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种形式的枚举不能通过<code>:</code>去指定枚举使用的索引类型，也不能使用UENUM(BlueprintType)宏暴露给蓝图，尽管加了这个宏编译不会报错，但是蓝图里面识别不到这个枚举，所以也没法使用UMETA()宏去设置枚举成员，同时也不支持反射。</p><p>C++11的标准形式</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">UENUM(BlueprintType)<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MEnum</span> :</span> uint8<br>&#123;<br>    ME_A     UMETA(DisplayName=&quot;MEnumA&quot;),<br>    <span class="hljs-function">ME_B     <span class="hljs-title">UMETA</span><span class="hljs-params">(DisplayName=<span class="hljs-string">&quot;MEnumB&quot;</span>)</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这种形式可以暴露给蓝图，也可以使用<code>:</code>指定枚举的索引类型，还可以使用UMETA宏描述枚举成员，同时可以使用UE提供的枚举反射函数。如：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002120.png"></p><h2 id="2-UMETA"><a href="#2-UMETA" class="headerlink" title="2.UMETA"></a>2.UMETA</h2><p>UMETA宏是枚举成员专用的元数据说明宏，和UFUNCTION，UCALSS，UPROPERTY以及UINTERFACE中使用的meta效果上是一样的，注意这里说的是枚举成员而不是枚举类型，枚举类型的元数据也使用meta。</p><p>UMETA可以使用的元数据说明符详情参见<a href="#meta">第八章宏第4节meta</a>。</p><h2 id="3-结构体"><a href="#3-结构体" class="headerlink" title="3.结构体"></a>3.结构体</h2><p>根据<a href="https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/GameplayArchitecture/Structs/">官方文档</a>的说法，UE结构体通过USTRUCT宏支持了UE的反射系统，支持UPROPERTY属性反射，但是由于结构体不继承自UObject所以不支持GC，也不支持UFUNCTION，所以结构体中的函数无法暴露给蓝图。</p><p>通过UPROPERTY(BlueprintReadWrite)可以将结构体的属性暴露给蓝图，如果不暴露的话，蓝图将无法识别到结构体中的属性。</p><p><font color="red">结构体的命名必须以F开头，否则编译不通过。</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">USTRUCT(BlueprintType)<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FStru</span></span><br><span class="hljs-class">&#123;</span><br>    GENERATED_BODY()<br>        <br>    UPROPERTY()<br>    FString tchr = TEXT(<span class="hljs-string">&quot;tchr&quot;</span>);<br>    <span class="hljs-function">FString <span class="hljs-title">GetTCHR</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> tchr;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>结构体有两种写法，上面是一种，另种是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">USTRUCT(BlueprintType)<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FStru</span></span><br><span class="hljs-class">&#123;</span><br>    GENERATED_USTRUCT_BODY()<br>        <br>    UPROPERTY()<br>    FString tchr = TEXT(<span class="hljs-string">&quot;tchr&quot;</span>);<br>    <span class="hljs-function">FString <span class="hljs-title">GetTCHR</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> tchr;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>GENERATED_BODY和GENERARED_USTRUCT_BODY没有什么区别，在结构体中GENERATED_BODY就是GENERARED_USTRUCT_BODY，这是因为结构体不存在父类构造函数这一说，UE在ObjectMacros.h中做了预定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GENERATED_USTRUCT_BODY(...) GENERATED_BODY()</span><br></code></pre></td></tr></table></figure><h1 id="五、蓝图函数库"><a href="#五、蓝图函数库" class="headerlink" title="五、蓝图函数库"></a>五、蓝图函数库</h1><p>C++蓝图函数库是一个UBlueprintFunctionLibrary的派生类，C++蓝图函数库存在的目的就是把C++的函数暴露给蓝图使用，所以函数库里的函数均需要使用static标识，且使用UFUNCTION(BlueprintCallable)暴露给蓝图，二者缺一，蓝图都无法识别到函数库里的函数。</p><p>由于静态函数是属于类的，所以无论函数是private、protected还是public都可以被蓝图识别到，但是函数库里的属性无论是否暴露给蓝图，蓝图都识别不到。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROJECT_API</span> <span class="hljs-title">UFunLib</span> :</span> <span class="hljs-keyword">public</span> UBlueprintFunctionLibrary<br>&#123;<br>    GENERATED_BODY()<br><br><span class="hljs-keyword">public</span>:<br>    UPROPERTY(BlueprintReadWrite, Category=<span class="hljs-string">&quot;FunLib&quot;</span>)<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span>:<br>    UFUNCTION(BlueprintCallable, Category = <span class="hljs-string">&quot;FunLib&quot;</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Log</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002126.png"></p><h1 id="六、代理"><a href="#六、代理" class="headerlink" title="六、代理"></a>六、代理</h1><p>C++自身不支持委托，所以UE自己用宏实现了委托，在UE里又叫代理。由于UE的代理是用宏来实现声明的，所以UE的代理没有办法像C#一样声明任意数量任意类型参数的代理，所以UE的代理就出现了一个很诡异的现象，即不同参数个数的代理需要使用不同的宏来声明，虽然很二，但是UE没法像底层语言一样自己去创建一个关键字来标识代理，这也许是在限制条件下的最优解了。</p><h2 id="1-代理的分类"><a href="#1-代理的分类" class="headerlink" title="1.代理的分类"></a>1.代理的分类</h2><h3 id="根据可绑定的响应函数的数量分"><a href="#根据可绑定的响应函数的数量分" class="headerlink" title="根据可绑定的响应函数的数量分"></a>根据可绑定的响应函数的数量分</h3><p><strong>单播代理</strong></p><p>单播代理只能绑定一个响应函数，形式如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//无返回值，无参数</span><br>DECLARE_DELEGATE(FDelegateOne);<br><span class="hljs-comment">//无返回值，两个参数</span><br>DECLARE_DELEGATE_TwoParams(FDelegateTwo, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">bool</span>);<br><span class="hljs-comment">//以此类推到</span><br>DECLARE_DELEGATE_NineParams(FDelegateNine,<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>);<br><span class="hljs-comment">//返回bool类型，两个参数</span><br>DECLARE_DELEGATE_RetVal_TwoParams(<span class="hljs-keyword">bool</span>, FDelegateTwo, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>);<br></code></pre></td></tr></table></figure><p><strong>多播代理</strong></p><p>多播代理可以绑定多个响应函数，形式如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//无返回值，无参数</span><br>DECLARE_MULTICAST_DELEGATE(FMulticastDelegateNone);<br><span class="hljs-comment">//无返回值，一个参数</span><br>DECLARE_MULTICAST_DELEGATE_OneParam(FMulticastDelegateOne, FString);<br><span class="hljs-comment">//同理类推到九个参数</span><br></code></pre></td></tr></table></figure><p><font color="red">需要注意，所有的多播代理都没有返回值。</font></p><h3 id="根据是否可蓝图调用分"><a href="#根据是否可蓝图调用分" class="headerlink" title="根据是否可蓝图调用分"></a>根据是否可蓝图调用分</h3><p>静态/动态，单播/多播，有/无返回值，参数个数，四个维度<font color="red">除了动态多播不能有返回值外</font>其他的可以自由的互相组合。</p><p><strong>静态代理</strong></p><p>静态代理只能在C++中使用，前面单播代理和多播代理的例子都属于静态代理。</p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">DECLARE_DELEGATE_RetVal_OneParam(<span class="hljs-keyword">bool</span>,FDynamicDelegateOne, FString,Str);<br></code></pre></td></tr></table></figure><p><strong>动态代理</strong></p><p>动态代理支持序列化，可以直接使用函数名字符串来创建委托，而无需传递函数入口地址，只有动态多播可以暴露给蓝图使用，使用UPROPERTY(BlueprintAssignable)标识即可暴露。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">error : &#x27;BlueprintAssignable&#x27; is only allowed on multicast delegate properties<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParam(FDynamicMulticastDelegateOne, FString,param1,<span class="hljs-keyword">int</span>,param2);<br></code></pre></td></tr></table></figure><p><font color="red">动态代理在声明的时候和其他代理有所不同，不像其他代理声明含参代理时只需要注明参数类型，动态代理声明含参代理的时候必须注明参数类型和参数名，并且用<code>,</code>隔开。动态多播不能有返回值。</font></p><p><font color="red">需要注意的时，代理的名称必须以F开头。</font></p><h2 id="2-代理的声明"><a href="#2-代理的声明" class="headerlink" title="2.代理的声明"></a>2.代理的声明</h2><p>代理可以声明在类内也可以声明在类外，声明在类的内外在实际效果上没有区别，只是在声明代理对象时有所区别，如：</p><h3 id="在类内声明代理对象"><a href="#在类内声明代理对象" class="headerlink" title="在类内声明代理对象"></a>在类内声明代理对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;GameFramework/Actor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Announcer.generated.h&quot;</span></span><br><span class="hljs-comment">//在类外声明代理</span><br>DECLARE_DELEGATE_RetVal_OneParam(FString, FMagazineNumberFive, <span class="hljs-keyword">int</span>);<br>DECLARE_MULTICAST_DELEGATE_OneParam(FMagazineNumberSix, <span class="hljs-keyword">int</span>);<br>DECLARE_DYNAMIC_DELEGATE_RetVal_OneParam(FString, FMagazineNumberSeven, <span class="hljs-keyword">int</span>, ReleaseNumber);<br>DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FMagazineNumberEight, <span class="hljs-keyword">int</span>, ReleaseNumber);<br><br>UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROJECT_API</span> <span class="hljs-title">AAnnouncer</span> :</span> <span class="hljs-keyword">public</span> AActor<br>&#123;<br>GENERATED_BODY()<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//在类内声明代理</span><br>    DECLARE_DELEGATE_RetVal_OneParam(FString, FMagazineNumberOne, <span class="hljs-keyword">int</span>);<br>    DECLARE_MULTICAST_DELEGATE_OneParam(FMagazineNumberTwo, <span class="hljs-keyword">int</span>);<br>    DECLARE_DYNAMIC_DELEGATE_RetVal_OneParam(FString, FMagazineNumberThree, <span class="hljs-keyword">int</span>, ReleaseNumber);<br>    DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FMagazineNumberFour, <span class="hljs-keyword">int</span>, ReleaseNumber);<br><br>    <span class="hljs-comment">//声明代理对象</span><br>    FMagazineNumberOne MagazineNumberOne;<br>    FMagazineNumberTwo MagazineNumberTwo;<br>    FMagazineNumberThree MagazineNumberThree;<br>    FMagazineNumberFour MagazineNumberFour;<br><br>    FMagazineNumberFive MagazineNumberFive;<br>    FMagazineNumberSix MagazineNumberSix;<br>    FMagazineNumberSeven MagazineNumberSeven;<br>    FMagazineNumberEight MagazineNumberEight;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> AAnnouncer* Announcer;<br><span class="hljs-keyword">public</span>:<br>AAnnouncer();<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> AAnnouncer* <span class="hljs-title">GetAnnouncerInstance</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnPublicate</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Tick</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime)</span> <span class="hljs-keyword">override</span></span>;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="在类外声明代理对象"><a href="#在类外声明代理对象" class="headerlink" title="在类外声明代理对象"></a>在类外声明代理对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Delegate/Announcer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;GameFramework/Actor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;SubscripterNumberOne.generated.h&quot;</span></span><br><br>UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROJECT_API</span> <span class="hljs-title">ASubscripterNumberOne</span> :</span> <span class="hljs-keyword">public</span> AActor<br>&#123;<br>GENERATED_BODY()<br><span class="hljs-keyword">public</span>:<br>ASubscripterNumberOne();<br>    <span class="hljs-comment">//声明在类内的代理声明代理对象</span><br>    AAnnouncer::FMagazineNumberOne MagazineNumberOne;<br>    <span class="hljs-comment">//声明在类外的代理声明代理对象</span><br>    FMagazineNumberFive MagazineNumberFive;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Tick</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime)</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="3-代理的绑定"><a href="#3-代理的绑定" class="headerlink" title="3.代理的绑定"></a>3.代理的绑定</h2><p>声明了代理对象之后就可以往对象身上绑定执行函数了，根据代理和执行函数的不同，绑定的方式也有所不同。</p><h3 id="静态单播"><a href="#静态单播" class="headerlink" title="静态单播"></a>静态单播</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ASubscripterNumberOne::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br><span class="hljs-comment">//BindUObject-绑定UObject类的函数到单播代理,可以是UFUNCTION函数也可以不是</span><br>    <span class="hljs-comment">//AAnnouncer::GetAnnouncerInstance()-&gt;MagazineNumberOne.BindUObject(this, &amp;ASubscripterNumberOne::SubscriptMagazineOne);</span><br><br>    <span class="hljs-comment">//BindUFunction-通过名字绑定UObject类的UFUNCTION函数到单播代理</span><br>    <span class="hljs-comment">//AAnnouncer::GetAnnouncerInstance()-&gt;MagazineNumberOne.BindUFunction(this, &quot;SubscriptMagazineOne&quot;);</span><br><br>    <span class="hljs-comment">//BindUFunction-通过名字绑定UObject类的静态UFUNCTION函数</span><br>    <span class="hljs-comment">//AAnnouncer::GetAnnouncerInstance()-&gt;MagazineNumberOne.BindUFunction(this, STATIC_FUNCTION_FNAME(TEXT(&quot;ASubscripterNumberOne::SubscriptMagazineOneStatic&quot;)));</span><br><br>    <span class="hljs-comment">//BindRaw-绑定指向的C++类的函数的共享指针到单播代理</span><br>    <span class="hljs-comment">//TSharedPtr&lt;FSubscripterNumberThree&gt; SubscripterNumberThree = MakeShareable(new FSubscripterNumberThree());</span><br>    <span class="hljs-comment">//MagazineNumberOne.BindRaw(SubscripterNumberThree.Get(), &amp;FSubscripterNumberThree::SubscriptMagazineOne);</span><br><br>    <span class="hljs-comment">//BindSP-绑定指向的C++类的函数的共享引用到单播代理</span><br>    <span class="hljs-comment">//TSharedRef&lt;FSubscripterNumberThree&gt;  SubscripterNumberThree  = MakeShareable(new FSubscripterNumberThree());</span><br>    <span class="hljs-comment">//AAnnouncer::GetAnnouncerInstance()-&gt;MagazineNumberOne.BindSP(SubscripterNumberThree, &amp;FSubscripterNumberThree::SubscriptMagazineOne);</span><br><br>    <span class="hljs-comment">//BindThreadSafeSP-绑定指向的C++类的函数的线程安全的共享引用到单播代理</span><br>    <span class="hljs-comment">//TSharedRef&lt;FSubscripterNumberThree,ESPMode::ThreadSafe&gt; SubscripterNumberThree = MakeShareable(new FSubscripterNumberThree());</span><br>    <span class="hljs-comment">//AAnnouncer::GetAnnouncerInstance()-&gt;MagazineNumberOne.BindThreadSafeSP(SubscripterNumberThree, &amp;FSubscripterNumberThree::SubscriptMagazineOne);</span><br><br>    <span class="hljs-comment">//BindLambda-绑定Lambda表达式到单播代理</span><br>    <span class="hljs-comment">//MagazineNumberOne.BindLambda([](int ReleaseNumber)-&gt;FString &#123;</span><br>    <span class="hljs-comment">//    TArray&lt;FStringFormatArg&gt; Arguments;</span><br>    <span class="hljs-comment">//    Arguments.Add(FStringFormatArg((int32)ReleaseNumber));</span><br>    <span class="hljs-comment">//    Arguments.Add(FStringFormatArg((int32)ReleaseNumber));</span><br>    <span class="hljs-comment">//    FString PublicateContentOne = FString::Format(TEXT(&quot;发布者发布了&#123;0&#125;号杂志给订阅者3号，发布号:&#123;1&#125;&quot;), Arguments);</span><br>    <span class="hljs-comment">//    UE_LOG(LogTemp, Error, TEXT(&quot;%s&quot;), *PublicateContentOne);</span><br>    <span class="hljs-comment">//    return PublicateContentOne;</span><br>    <span class="hljs-comment">//    &#125;);</span><br><br>    <span class="hljs-comment">//BindWeakLambda-将Lambda表达式与指定对象进行弱关联，再绑定这个对象关联的Lambda表达式到单播代理</span><br>    <span class="hljs-comment">//AAnnouncer::GetAnnouncerInstance()-&gt;MagazineNumberOne.BindWeakLambda(this, [](int ReleaseNumber) &#123;</span><br>    <span class="hljs-comment">//    TArray&lt;FStringFormatArg&gt; Arguments;</span><br>    <span class="hljs-comment">//    Arguments.Add(FStringFormatArg((int32)ReleaseNumber));</span><br>    <span class="hljs-comment">//    Arguments.Add(FStringFormatArg((int32)ReleaseNumber));</span><br>    <span class="hljs-comment">//    FString PublicateContentOne = FString::Format(TEXT(&quot;发布者发布了&#123;0&#125;号杂志给订阅者1号，发布号:&#123;1&#125;&quot;), Arguments);</span><br>    <span class="hljs-comment">//    UE_LOG(LogTemp, Error, TEXT(&quot;%s&quot;), *PublicateContentOne);</span><br>    <span class="hljs-comment">//    return PublicateContentOne;</span><br>    <span class="hljs-comment">//   &#125;);</span><br><br>    <span class="hljs-comment">//BindStatic-绑定静态函数到单播代理，在类内外都可以使用，函数可以UFUNCTION函数也可以不是</span><br>    <span class="hljs-comment">//AAnnouncer::GetAnnouncerInstance()-&gt;MagazineNumberOne.BindStatic(ASubscripterNumberOne::SubscriptMagazineOneStatic);</span><br><br>    <span class="hljs-comment">//BindStatic-绑定静态函数到单播代理，只能在类内使用，函数可以UFUNCTION函数也可以不是</span><br>    AAnnouncer::GetAnnouncerInstance()-&gt;MagazineNumberOne.BindStatic(SubscriptMagazineOneStatic);<br>&#125;<br></code></pre></td></tr></table></figure><p>单播对象被销毁时会自动在析构函数中调用UnBind解绑</p><h3 id="静态多播"><a href="#静态多播" class="headerlink" title="静态多播"></a>静态多播</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ASubscripterNumberOne::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br>    <span class="hljs-comment">//AddUObject-添加一个UObject类的函数到多播代理</span><br>    AAnnouncer::GetAnnouncerInstance()-&gt;MagazineNumberTwo.AddUObject(<span class="hljs-keyword">this</span>, &amp;ASubscripterNumberOne::SubscriptMagazineTwo);<br>    <span class="hljs-comment">//AddUFunction-通过名字添加UObject类的UFUNCTION函数到多播代理</span><br>    AAnnouncer::GetAnnouncerInstance()-&gt;MagazineNumberTwo.AddUFunction(<span class="hljs-keyword">this</span>, TEXT(<span class="hljs-string">&quot;SubscriptMagazineTwo&quot;</span>));<br>    <span class="hljs-comment">//Add-添加一个指向UObject类的函数的FDelegate进入多播代理，FDelegate是代理的内部类</span><br>    DelegateTwo = AAnnouncer::FMagazineNumberTwo::FDelegate::CreateUObject(<span class="hljs-keyword">this</span>, &amp;ASubscripterNumberOne::SubscriptMagazineTwo);<br>    AAnnouncer::GetAnnouncerInstance()-&gt;MagazineNumberTwo.Add(DelegateTwo);<br><br>    <span class="hljs-comment">//AddLambda-添加一个Lambda表达式到多播代理</span><br>    AAnnouncer::GetAnnouncerInstance()-&gt;MagazineNumberTwo.AddLambda([](<span class="hljs-keyword">int</span> ReleaseNumber)-&gt;<span class="hljs-keyword">void</span> &#123;<br>            TArray&lt;FStringFormatArg&gt; Arguments;<br>            Arguments.Add(FStringFormatArg((int32)ReleaseNumber));<br>            Arguments.Add(FStringFormatArg((int32)ReleaseNumber));<br>            FString PublicateContentOne = FString::Format(TEXT(<span class="hljs-string">&quot;发布者发布了&#123;0&#125;号杂志给订阅者2号，发布号:&#123;1&#125;,Lambda&quot;</span>), Arguments);<br>            UE_LOG(LogTemp, Error, TEXT(<span class="hljs-string">&quot;%s&quot;</span>), *PublicateContentOne);<br>            &#125;);<br>    <span class="hljs-comment">//AddWeakLambda-将Lambda表达式与指定对象进行弱关联，再添加这个对象关联的Lambda表达式到多播代理</span><br>    AAnnouncer::GetAnnouncerInstance()-&gt;MagazineNumberTwo.AddWeakLambda(<span class="hljs-keyword">this</span>, [](<span class="hljs-keyword">int</span> ReleaseNumber)-&gt;<span class="hljs-keyword">void</span> &#123;<br>            TArray&lt;FStringFormatArg&gt; Arguments;<br>            Arguments.Add(FStringFormatArg((int32)ReleaseNumber));<br>            Arguments.Add(FStringFormatArg((int32)ReleaseNumber));<br>            FString PublicateContentOne = FString::Format(TEXT(<span class="hljs-string">&quot;发布者发布了&#123;0&#125;号杂志给订阅者2号，发布号:&#123;1&#125;,WeakLambda&quot;</span>), Arguments);<br>            UE_LOG(LogTemp, Error, TEXT(<span class="hljs-string">&quot;%s&quot;</span>), *PublicateContentOne);<br>           &#125;);<br><br>    <span class="hljs-comment">//AddRaw-添加指向的C++类的函数的共享指针到多播代理</span><br>    TSharedPtr&lt;FSubscripterNumberThree&gt; SubscripterNumberThree = MakeShareable(<span class="hljs-keyword">new</span> FSubscripterNumberThree());<br>    AAnnouncer::GetAnnouncerInstance()-&gt;MagazineNumberTwo.AddRaw(SubscripterNumberThree.Get(), &amp;FSubscripterNumberThree::SubscriptMagazineTwo);<br>    <span class="hljs-comment">//AddSP-添加指向的C++类的函数的共享引用到多播代理</span><br>    TSharedRef&lt;FSubscripterNumberThree&gt; SubscripterNumberThree2 = MakeShareable(<span class="hljs-keyword">new</span> FSubscripterNumberThree());<br>    AAnnouncer::GetAnnouncerInstance()-&gt;MagazineNumberTwo.AddSP(SubscripterNumberThree2, &amp;FSubscripterNumberThree::SubscriptMagazineTwo);<br>    <span class="hljs-comment">//AddThreadSafeSP-添加指向的C++类的函数的线程安全的共享引用到多播代理</span><br>    TSharedRef&lt;FSubscripterNumberThree,ESPMode::ThreadSafe&gt; SubscripterNumberThree3 = MakeShareable(<span class="hljs-keyword">new</span> FSubscripterNumberThree());<br>    AAnnouncer::GetAnnouncerInstance()-&gt;MagazineNumberTwo.AddThreadSafeSP(SubscripterNumberThree3, &amp;FSubscripterNumberThree::SubscriptMagazineTwo);<br><br>    <span class="hljs-comment">//AddStatic-添加静态函数到多播代理，在类内外都可以使用，函数可以UFUNCTION函数也可以不是</span><br>    AAnnouncer::GetAnnouncerInstance()-&gt;MagazineNumberTwo.AddStatic(ASubscripterNumberOne::SubscriptMagazineTwoStatic);<br>    <span class="hljs-comment">//AddStatic-添加静态函数到多播代理，只能在类内使用，函数可以UFUNCTION函数也可以不是</span><br>    AAnnouncer::GetAnnouncerInstance()-&gt;MagazineNumberTwo.AddStatic(SubscriptMagazineTwoStatic);<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="red">AddSP和AddThreadSafeSP有一个坑，就是像上面的代码一样在一个函数里面去创建一个共享引用，并往多播代理添加这个共享引用，到代理触发执行函数时，函数不会执行，可能时因为共享引用在函数栈退出时就已经置空了，所以才无法触发，这里还没看到共享引用，暂时先当一个坑。</font></p><h3 id="动态单播"><a href="#动态单播" class="headerlink" title="动态单播"></a>动态单播</h3><p>动态代理就没那么多花里胡哨了，动态单播只有一个BindUFunction函数来绑定UFUNCTION函数，即动态单播代理只能用于绑定UObject类的UFUNCTION函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ASubscripterNumberOne::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br>    AAnnouncer::GetAnnouncerInstance()-&gt;MagazineNumberThree.BindUFunction(<span class="hljs-keyword">this</span>, TEXT(<span class="hljs-string">&quot;SubscriptMagazineThree&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态多播"><a href="#动态多播" class="headerlink" title="动态多播"></a>动态多播</h3><p>动态多播也相当简洁，只有Add和AddUnique函数，只能用来添加FScriptDelegate指向的函数，而TScriptDelegate也只提供一个BindUFunction函数来绑定UObject类的UFUNCTION函数，所以动态多播只能添加UObject的UFUNCTION函数，其中AddUnique会对已添加到多播的委托做检查，如果该函数已经存在在多播中了，就不在添加重复的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ASubscripterNumberOne::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br>TScriptDelegate&lt;FWeakObjectPtr&gt; SubscriptMagazineFourDelegate;<br>    SubscriptMagazineFourDelegate.BindUFunction(<span class="hljs-keyword">this</span>, TEXT(<span class="hljs-string">&quot;SubscriptMagazineFour&quot;</span>));<br>    AAnnouncer::GetAnnouncerInstance()-&gt;MagazineNumberFour.Add(SubscriptMagazineFourDelegate);<br>    <br>    AAnnouncer::GetAnnouncerInstance()-&gt;MagazineNumberFour.AddUnique(SubscriptMagazineFourDelegate);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><p>AddRaw和BindRaw使用于C++函数，如果在代理执行之前C++对象已经被销毁，则会导致内存操作违规引起的崩溃。</p></li><li><p>AddLambda和BindLamb如果Lambda表达式有捕获外部变量，且在代理执行之前外部变量已经被销毁，则会导致内存操作违规引起的崩溃。</p></li><li><p>AddWeakLambda/BindWeakLambda、AddUObject/BindUObject、AddUFunction/BindUFunction、AddSP/BindSP、AddThreadSafeSP/BindThreadSafeSP，如果相关对象在代理执行之前被GC回收了，而在执行Execute函数时没有做有效性判断，则会导致内存操作违规引起的崩溃。建议在执行Execute函数之前使用IsBound做有效性判断或直接使用ExecuteIfBound函数。</p></li></ul><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a><font color="green">疑问</font></h3><p><font color="green">在网上看别人的博客和官方的4.27的文档动态多播的绑定都是使用的AddDybamic和AddUniquueDynamic，而我自己在4.26中使用时并没有这两个函数，取而代之的是<code>__Internal_AddDynamic</code>和<code>__Internal_AddUniqueDymanic</code>，不知道是引擎代码已经改了，而官方文档没更新还是怎么着。</font></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002137.png"></p><p><font color="green">在查询资料的过程还发现了一个宏<code>FUNC_DECLARE_DYNAMIC_MULTICAST_DELEGATE</code>，看起来像是一个委托，但是实在是查不到资料，只能有事件自己再去摸索了。</font></p><h2 id="4-代理的执行"><a href="#4-代理的执行" class="headerlink" title="4.代理的执行"></a>4.代理的执行</h2><h3 id="单播代理"><a href="#单播代理" class="headerlink" title="单播代理"></a>单播代理</h3><p>UE提供Execute函数和ExectueIfBound两个函数供单播代理触发执行函数，其中Execute支持有返回值函数和无返回值函数，但不会做执行函数所属对象的有效性检查，需要手动使用IsBound函数做有效性检查；而ExecuteIfBound只支持无返回值的函数，会在触发执行函数时自动检查执行函数所属对象的有效性，有效的才执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">MagazineNumberOne.Execute(<span class="hljs-number">1</span>); <br></code></pre></td></tr></table></figure><h3 id="多播代理"><a href="#多播代理" class="headerlink" title="多播代理"></a>多播代理</h3><p>多播代理只有一个Broadcast函数用于触发执行函数，且不会进行一执行函数所属对象的有效性检查，也需要使用IsBound函数手动进行检查。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">MagazineNumberTwo.Broadcast(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h2 id="5-代理的解绑"><a href="#5-代理的解绑" class="headerlink" title="5.代理的解绑"></a>5.代理的解绑</h2><h3 id="单播代理-1"><a href="#单播代理-1" class="headerlink" title="单播代理"></a>单播代理</h3><p>单播代理在对象被析构时会自动调用UnBind函数进行解绑，或者重新绑定新的函数会自动解绑当前绑定函数，所以UE4.26可能就没有再暴露Unbind函数供外部调用了(看网上的<a href="https://www.cnblogs.com/kekec/p/10678905.html">博客</a>是可以直接调用Unbind函数的，我在4.26中已经不能调用了，不知道作者用的是那个版本的引擎)。</p><p>不过对于动态单播还是可以使用Unbind和Clear函数来进行函数解绑。</p><h3 id="多播代理-1"><a href="#多播代理-1" class="headerlink" title="多播代理"></a>多播代理</h3><p>多播代理无论是静态多播还是动态多播均提供Clear、Remove和RemoveAll三个函数来做函数解绑，其中Clear是解绑多播中的所有函数；Remove则是解绑FDelegateHandle指定的函数，FDelegateHandle是代理绑定行数的返回值类型；RemoveAll是解绑指定对象的所有函数，不影响已经绑定的其他对象的函数。</p><h2 id="6-代理的创建"><a href="#6-代理的创建" class="headerlink" title="6.代理的创建"></a>6.代理的创建</h2><p>一个代理的使用流程就是声明代理、声明代理对象、代理对象绑定函数、执行代理、代理解绑。除此之外对于静态单播UE还提供CreateRaw、CreateLambda、CreateWeakLambda、CreateUObject、CreateUFunction、CreateSP、CreateThreadSafeSP等来直接创建一个已经已经绑定了对应函数的静态单播，虽然感觉也没什么用😂。</p><h2 id="7-事件"><a href="#7-事件" class="headerlink" title="7.事件"></a>7.事件</h2><p>UE的事件效果上几乎和C#的事件一模一样，理解C#的事件对UE的事件就是秒懂，来一张C#的事件说明：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002143.png"></p><p>事件就是一个被再次封装的静态多播，声明上，关键字只是把DELEGATE关键字改为EVENT，参数则需要指定一个类名，以便UE在生成反射代码是保证这个事件只能在指定类的内部使用，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">DECLARE_EVENT_OneParam(AAnnouncer，FMagazineEvent, <span class="hljs-keyword">int</span>);<br></code></pre></td></tr></table></figure><p>事件的绑定、使用、解绑基本和静态多播一样，可以直接参考静态多播。</p><h2 id="8-预制代理"><a href="#8-预制代理" class="headerlink" title="8.预制代理"></a>8.预制代理</h2><p>UE预制了大量的代理给我使用，由于量实在是巨大，这里就只列出所在文件了，需要用的时候再直接进源码去看吧。</p><ul><li>系统与引擎下相关的预制代理：FCoreDelegates 、FCoreUObjectDelegates，同时UEngine中也几个相关代理；</li><li>编辑器相关预制代理：FEditorDelegates、FGameDelegates，同时UWorld中也有几个相关代理；</li><li>World相关预制代理：FWorldDelegates</li><li>引擎子系统相关预制代理：FNetDelegates，子系统的代理基本都分布在各个子系统的类中了；</li><li>GamePlay相关预制代理：FGameModeEvents及各个GamePlay的类中；</li></ul><p>网上有以为大佬<a href="https://www.cnblogs.com/kekec/p/10678905.html">可可西</a>整理一篇挺全的博客。</p><h1 id="七、指针与引用"><a href="#七、指针与引用" class="headerlink" title="七、指针与引用"></a>七、指针与引用</h1><p>UE4的共享指针和C++的智能指针原理和作用基本一致，UE4的共享指针存在的主要目的就是作用于UE4的跨平台。</p><p>UE4共享指针的特性：</p><ul><li>防止内存溢出；</li><li>有线程安全机制；</li><li>可虚拟化任何对象；</li><li>负载大，内存占用为原生C++指针的两倍。</li></ul><p>UE4共享指针共有TSharedPtr、TSharedRef、TWeakPtr、TAutoPtr四种。</p><p>在UE中共享指针的作用主要是用来管理C++类对象，由于C++类不在UObject体系中，所以如果C++对象管理不善用于出现内存泄漏、野指针和程序崩溃等问题，共享指针就是为了解决这些问题而存在的。</p><p>除了共享指针外UE还提供了很多其他类型的引用。</p><h2 id="1-TSharedPtr"><a href="#1-TSharedPtr" class="headerlink" title="1.TSharedPtr"></a>1.TSharedPtr</h2><ul><li><font color="red"> TSharedPtr不能指向UObject类，因为UObject类有自己的一套垃圾回收机制，而TSharedPtr也有自己的一套垃圾回收机制，如果使用TSharedPtr指向一个UObject类，当UObject自己回收后，会出现指针不为空，但是对象却被销毁了，所以在指针销毁对象的时候就会出现销毁不存在对象，而导致引擎崩溃。</font></li></ul><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">TSharedPtr&lt;FMyClass&gt; emptyPtr;<span class="hljs-comment">//单独声明出来的共享指针为空指针</span><br></code></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">TSharedPtr&lt;FMyClass&gt; <span class="hljs-title">onePtr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> FMyClass())</span></span>;<br>TSharedPtr&lt;FMyClass&gt; twoPtr = MakeShareable&lt;FMyClass&gt;(<span class="hljs-keyword">new</span> FMyClass());<br><span class="hljs-comment">//TSharedPtr不支持直接赋值的初始化，如：</span><br><span class="hljs-comment">//TharedPtr&lt;MyClass&gt; onePtr;</span><br><span class="hljs-comment">//onePtr = new Class();</span><br><span class="hljs-comment">//这样的初始化是错误的</span><br></code></pre></td></tr></table></figure><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">TSahredPtr&lt;FMyClass&gt; twoPtr = onePtr;<span class="hljs-comment">//指针复制，引用计数器+1</span><br></code></pre></td></tr></table></figure><h3 id="查看一块内存的引用计数"><a href="#查看一块内存的引用计数" class="headerlink" title="查看一块内存的引用计数"></a>查看一块内存的引用计数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">TSharedPtr&lt;T&gt;::GetSharedReferenceCount()<br></code></pre></td></tr></table></figure><p><font color="red"> 一块内存只能被一个TSharedPtr指针初始化，如果一块内存被多个SharedPtr引用，UE4会在编译时直接崩溃，比如下面代码：</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">UMyObject *obj = NewObject&lt;UMyObject&gt;();<br><span class="hljs-function">TSharedPtr&lt;UMyObject&gt; <span class="hljs-title">onePtr</span><span class="hljs-params">(obj)</span></span>;<br><span class="hljs-function">TSharedPtr&lt;UMyObject&gt; <span class="hljs-title">twoPtr</span><span class="hljs-params">(obj)</span></span>;<br></code></pre></td></tr></table></figure><p><font color="red"> 如果想要多个TSharedPtr指针指向一块内存地址，则需要使用TSharedPtr复制。</font></p><h3 id="获取原始指针"><a href="#获取原始指针" class="headerlink" title="获取原始指针"></a>获取原始指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">TSharedPtr&lt;FMyClass&gt; twoPtr;<br>twoPtr = MakeShareable&lt;FMyClass&gt;(<span class="hljs-keyword">new</span> FMyClass());<br>twoPtr.Get();<br></code></pre></td></tr></table></figure><h2 id="2-TSharedRef"><a href="#2-TSharedRef" class="headerlink" title="2.TSharedRef"></a>2.TSharedRef</h2><p>TSharedRef又称共享引用，相对于共享指针，共享引用由于不能为空，也无法置空，所以使用上比共享指针更安全，和引用一样，共享引用的初始化不能和声明分开，即声明的时候就必须做初始化了，共享引用的初始化可以使用MakeShareable函数或使用共享指针转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">TSharedRef&lt;FMyClass&gt; oneRef = MakeShareable&lt;FMyClass&gt;(<span class="hljs-keyword">new</span> FClass());<br>TSharedPtr&lt;FMyClass&gt; Ptr = MakeShareable&lt;FMyClass&gt;(<span class="hljs-keyword">new</span> FClass());<br>TSharedRef&lt;FMyClass&gt; twoRef = Ptr.toSharedRef();<br></code></pre></td></tr></table></figure><h3 id="TSharedPtr和TSharedRef的互相转换"><a href="#TSharedPtr和TSharedRef的互相转换" class="headerlink" title="TSharedPtr和TSharedRef的互相转换"></a>TSharedPtr和TSharedRef的互相转换</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">TSharedRef&lt;FMyClass&gt; oneRef = MakeShareable&lt;FMyClass&gt;(<span class="hljs-keyword">new</span> FClass());<br>TSharedPtr&lt;FMyClass&gt; onePtr = MakeShareable&lt;FMyClass&gt;(<span class="hljs-keyword">new</span> FClass());<br><span class="hljs-comment">//共享指针转共享引用</span><br>TSharedRef&lt;FMyClass&gt; twoRef = onePtr.toSharedRef();<br><span class="hljs-comment">//共享引用转共享指针</span><br>TSharedPtr&lt;FMyClass&gt; twoPtr = oneRef<br></code></pre></td></tr></table></figure><h2 id="3-TWeakPtr"><a href="#3-TWeakPtr" class="headerlink" title="3.TWeakPtr"></a>3.TWeakPtr</h2><p>TWeakPtr是对标的STL的weak_ptr的，TweakPtr不对增加对象的引用计数，所以不会影响对象的释放，也就避免了互相引用的死锁而导致的内存溢出，但这也导致了TWeakPtr随时可能被置空的问题，所在使用都需要做有效性判断。</p><p>TWeakPtr只能通过TSharedPtr或TSharedRef来初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">TSharedRef&lt;FCpp&gt; SharedRef = MakeShareable&lt;FCpp&gt;(<span class="hljs-keyword">new</span> FCpp());<br>TSharedPtr&lt;FCpp&gt; SharedPtr = MakeShareable&lt;FCpp&gt;(<span class="hljs-keyword">new</span> FCpp());<br>WeakPtr = SharedPtr;<br>WeakPtr = SharedRef;<br></code></pre></td></tr></table></figure><p><font color="red">需要注意的是，TWeakPtr并没有重写-&gt;，所以TWeakPtr不能直接使用指向对象的成员，要想要使用指向对象的成员，则需要先通过Pin()函数将TWeakPtr转换成TSharedPtr再使用。</font></p><h2 id="4-TUniquePtr"><a href="#4-TUniquePtr" class="headerlink" title="4.TUniquePtr"></a>4.TUniquePtr</h2><p>TUniquePtr可以保证指向一个对象只能被一个唯一的TUniquePtr指针指向，TUniquePtr不能赋值给其他的指针。</p><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">TUniquePtr&lt;FCpp&gt; UniquePtr = MakeUnique&lt;FCpp&gt;(<span class="hljs-keyword">new</span> FCpp());<br></code></pre></td></tr></table></figure><p>TUniquePtr使用专门的MakeUnique函数进行初始化。</p><p>在使用的过程想到一个疑问，如果使用TUniquePtr指针指向一个对象，然后用另一个TSharedPtr也指向这个对象，直接绕开TUniquePtr而不是使用TUniquePtr赋值TSharedPtr，这样指向这个对象的指针就不止一个了。</p><p>事实证明这样子是行不通的，因为共享指针不能直接使用C++指针初始化，也不能指向C++指针。</p><h2 id="5-TAutoPtr-TScopedPointer"><a href="#5-TAutoPtr-TScopedPointer" class="headerlink" title="5.TAutoPtr,TScopedPointer"></a>5.TAutoPtr,TScopedPointer</h2><p>这两个指针在网上的很多文章里都有出现，然后我自己使用的时候发现根本没有这两个指针，然后查阅官方文档才发向这两个指针在4.15就已经废弃了删掉了。</p><h2 id="6-TWeakObjectPtr"><a href="#6-TWeakObjectPtr" class="headerlink" title="6.TWeakObjectPtr"></a>6.TWeakObjectPtr</h2><p>TWeakObjectPtr是UE专门用来指向UObject的指针，由于UObject的GC与共享指针的GC是两套系统，我们使用TSharedPtr来指向一个UObject可能会导致一个UObject已经被系统GC了，而TSharedPtr依旧是有效的，所指向的内容却已经没了，而引起的系统崩溃。但有的时候又有需要使用一个指针来引用UObject而又要不影响UObject的正常GC，于是TWeakObjectPtr就运行而生了，当UObject被GC后TWeakObjectPtr也会被自动置为nullptr。</p><p>TWeakObjectPtr可以直接指向一个UObject对象，也可以指向一个UObject指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">TWeakObjectPtr&lt;AAnnouncer&gt; WeakObjectPtr = GWorld-&gt;SpawnActor&lt;AAnnouncer&gt;();<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">AAnnouncer* Announcer = GWorld-&gt;SpawnActor&lt;AAnnouncer&gt;();<br>TWeakObjectPtr&lt;AAnnouncer&gt; WeakObjectPtr = Announcer;<br></code></pre></td></tr></table></figure><h2 id="7-TAutoWeakObjectPtr"><a href="#7-TAutoWeakObjectPtr" class="headerlink" title="7.TAutoWeakObjectPtr"></a>7.TAutoWeakObjectPtr</h2><p>TAutoWeakObjectPtr是TWeakObjectPtr的TAutoPtr版本，在对象声明周期结束后，指针会自动释放其引用对象。使用方式和TWeakObjectPtr一致。</p><h2 id="8-TSharedFromThis"><a href="#8-TSharedFromThis" class="headerlink" title="8.TSharedFromThis"></a>8.TSharedFromThis</h2><p>TSharedFromThis不是一个指针而是一个模板类，可供我们使用C++类去继承来创建一个自定义的共享指针。</p><p>TSharedFromThis类提供Get方法将共享指针转换成普通指针，提供AsShred方法将普通指针转成共享指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Templates/SharedPointer.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROJECT_API</span> <span class="hljs-title">FCppPtr</span> :</span> <span class="hljs-keyword">public</span> TSharedFromThis&lt;FCppPtr&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>FCppPtr();<br>~FCppPtr();<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="9-FSoftObjectPath"><a href="#9-FSoftObjectPath" class="headerlink" title="9.FSoftObjectPath"></a>9.FSoftObjectPath</h2><p>FSoftObjectPath是一个记录资源路径的结构体，用于C++暴露给编辑器，然后可以在编辑器中方便快捷的设置C++类需要使用的资源，C++加载蓝图资源需要使用UE给定的路径格式，FSoftObjectPath就可以通过直接选择的方式来提供C++所需要的资源路径。</p><p>这里直接使用一个例子来说明可能会更具象点。</p><p>创建一个C++类的Actor</p><p>.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;GameFramework/Actor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;OpreateActor.generated.h&quot;</span></span><br><br>UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROJECT_API</span> <span class="hljs-title">AOpreateActor</span> :</span> <span class="hljs-keyword">public</span> AActor<br>&#123;<br>GENERATED_BODY()<br><span class="hljs-keyword">public</span>:<br>AOpreateActor();<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Do</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">public</span>:<br>    UStaticMeshComponent* StaticMeshComponent;<br>    UPROPERTY(EditAnywhere,meta=(AllowedClasses=<span class="hljs-string">&quot;Material&quot;</span>))<br>    TArray&lt;FSoftObjectPath&gt; MatArr;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Tick</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime)</span> <span class="hljs-keyword">override</span></span>;<br><br>&#125;;<br></code></pre></td></tr></table></figure><p>.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;TSharedPtr/OpreateActor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Runtime/Engine/Classes/Kismet/GameplayStatics.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Delegate/Announcer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Templates/SharedPointerInternals.h&quot;</span></span><br>AOpreateActor::AOpreateActor()<br>&#123;<br>PrimaryActorTick.bCanEverTick = <span class="hljs-literal">true</span>;<br>    <span class="hljs-function">ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt; <span class="hljs-title">StaticMesh</span><span class="hljs-params">(TEXT(<span class="hljs-string">&quot;StaticMesh&#x27;/Game/StarterContent/Shapes/Shape_Sphere.Shape_Sphere&#x27;&quot;</span>))</span></span>;<br>    StaticMeshComponent = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT(<span class="hljs-string">&quot;MeshComponent&quot;</span>));<br>    StaticMeshComponent-&gt;SetupAttachment(GetRootComponent());<br>    StaticMeshComponent-&gt;SetStaticMesh(StaticMesh.Object);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOpreateActor::Do</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> index = FMath::RandHelper(MatArr.Num());<br>    FString MatPath = TEXT(<span class="hljs-string">&quot;Material&#x27;&quot;</span>) + MatArr[index].GetAssetPathString() + TEXT(<span class="hljs-string">&quot;&#x27;&quot;</span>);<br>    UMaterial* Mat = LoadObject&lt;UMaterial&gt;(<span class="hljs-literal">nullptr</span>, *MatPath);<br>    UMaterialInstanceDynamic* MatIns = UMaterialInstanceDynamic::Create(Mat, StaticMeshComponent);<br>    StaticMeshComponent-&gt;SetMaterial(<span class="hljs-number">0</span>,MatIns);  <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOpreateActor::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br>    EnableInput(UGameplayStatics::GetPlayerController(GWorld, <span class="hljs-number">0</span>));<br>    InputComponent-&gt;BindAction(<span class="hljs-string">&quot;ActorInputP&quot;</span>, EInputEvent::IE_Pressed, <span class="hljs-keyword">this</span>, &amp;AOpreateActor::Do);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOpreateActor::Tick</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime)</span></span><br><span class="hljs-function"></span>&#123;<br>Super::Tick(DeltaTime);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>创建一个FSoftObjectPath数组用于存储设置的材质路径，使用meta限定选择时只显示材质对象；</li><li>在构造对象时为这个Actor附加一个SceneComponent和StaticMeshComponent，材质需要附着在mesh组件上；</li><li>在BeginPlay函数中启动Actor接收输入，并为输入按键绑定执行函数Do()；</li><li>在Do函数中为Actor设置随机Material。</li><li>然后把Actor放入场景。</li></ul><p>来看一下效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002159.gif"></p><h2 id="10-TSoftObjectPtr"><a href="#10-TSoftObjectPtr" class="headerlink" title="10.TSoftObjectPtr"></a>10.TSoftObjectPtr</h2><p>TSoftObjectPtr是FSoftObjectPath和TWeakObjectPtr的模板类封装，非模板的封装则是FSoftObjectPtr，这两个指针功能上基本一致。按照<a href="https://docs.unrealengine.com/5.0/zh-CN/asynchronous-asset-loading/">官方文档</a>的描述，TSoftObjectPtr可以在其保存的弱引用指向的对象不存在时快速的通过FSoftObjectPath保存的路径加载对象到内存中，效果上和tSoftObjectPath差不多，只是省去了我们手动加载资源的步骤。</p><p>这里写个例子：</p><p>这里通过TSoftObjectPtr来加载两个内存中不存在Actor蓝图类对象Truck和Motorcycle，他们分别继承自C++Actor类ACar，ACar继承自接口IBPInterface，IBPInterface提供一个由蓝图实现的函数接口Log，然后在AOpreateActor的Do函数中来进行这些操作。</p><p>关于C++通过接口调用蓝图函数，请移步置<a href="#7.%E6%8E%A5%E5%8F%A3">接口</a>。</p><p>使用C++加载蓝图类并调用蓝图类中函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;GameFramework/Actor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;OpreateActor.generated.h&quot;</span></span><br><br>UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROJECT_API</span> <span class="hljs-title">AOpreateActor</span> :</span> <span class="hljs-keyword">public</span> AActor<br>&#123;<br>GENERATED_BODY()<br><span class="hljs-keyword">public</span>:<br>AOpreateActor();<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Do</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">public</span>:<br>    UPROPERTY(EditAnywhere)<br>    TArray&lt;TSoftObjectPtr&lt;UObject&gt;&gt; SoftObjectPtrArr;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Tick</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime)</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOpreateActor::Do</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (TSoftObjectPtr&lt;UObject&gt; ObjPtr : SoftObjectPtrArr)<br>    &#123;<br>        FString ActorPath = TEXT(<span class="hljs-string">&quot;Blueprint&#x27;&quot;</span>) + ObjPtr.ToSoftObjectPath().GetAssetPathString() + TEXT(<span class="hljs-string">&quot;&#x27;&quot;</span>);<br>        UObject* LoadObj = StaticLoadObject(UBlueprint::StaticClass(), <span class="hljs-literal">NULL</span>, *ActorPath);<br>        <span class="hljs-keyword">if</span> (LoadObj)<br>        &#123;<br>            UBlueprint* Blueprint = CastChecked&lt;UBlueprint&gt;(LoadObj);<br>            FActorSpawnParameters SpawnParams;<br>            ACar* ActorBase = GWorld-&gt;SpawnActor&lt;ACar&gt;(Blueprint-&gt;GeneratedClass, FVector(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), FRotator(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), SpawnParams);<br>            UClass* ActorClass = ActorBase-&gt;GetClass();<br>            <span class="hljs-keyword">if</span> (ActorClass-&gt;ImplementsInterface(UBPInterface::StaticClass()))<br>            &#123;<br>                IBPInterface* BPInterface = CastChecked&lt;IBPInterface&gt;(ActorBase);<br>                IBPInterface::Execute_Log(ActorBase);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Truck的Log接口实现：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002212.png"></p><p>Motorcycle的Log接口实现：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002223.png"></p><p>将AOpreateActor放入Level并配置TSoftObjectPtr数组</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002229.png"></p><p>运行效果：</p><p>开始时Level中没有Truck和Motorcycle；</p><p>运行后：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002233.png"></p><h2 id="11-FSoftClassPath"><a href="#11-FSoftClassPath" class="headerlink" title="11.FSoftClassPath"></a>11.FSoftClassPath</h2><p>FSoftClassPath是FSoftObjectPath的子类，使用方式于效果和FSoftObjectPath一模一样，FSoftClassPath解决的是FSoftObjectPath只能引用资产而不能引用蓝图类的问题。FSoftObjectPath如果引用蓝图类会导致编辑器发生中断，而FSoftClassPath引用资产也会造成编辑器中断，并且二者对类型的筛选也是不一样的，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;GameFramework/Actor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;OpreateActor.generated.h&quot;</span></span><br>UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROJECT_API</span> <span class="hljs-title">AOpreateActor</span> :</span> <span class="hljs-keyword">public</span> AActor<br>&#123;<br>GENERATED_BODY()<br><span class="hljs-keyword">public</span>:<br>AOpreateActor();<br><span class="hljs-keyword">public</span>:<br>    UPROPERTY(EditAnywhere,meta=(AllowedClasses=<span class="hljs-string">&quot;Material&quot;</span>))<br>    FSoftObjectPath SoftObjectPath;<br>    UPROPERTY(EditAnywhere,meta=(MetaClass = <span class="hljs-string">&quot;Car&quot;</span>))<br>    FSoftClassPath SoftClassPath;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Tick</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime)</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>SoftClassPath就可以引用所有继承自ACar的蓝图类了。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002241.png"></p><h2 id="12-TSoftClassPtr"><a href="#12-TSoftClassPtr" class="headerlink" title="12.TSoftClassPtr"></a>12.TSoftClassPtr</h2><p>TSoftClassPtr就是TSoftObjectPtr的减配版，只能提供FSoftObjectPath不能提供TWeakObjectPtr，除此之外使用和功能都和TSoftObjectPtr一样。</p><h2 id="13-TSubclassOf"><a href="#13-TSubclassOf" class="headerlink" title="13.TSubclassOf"></a>13.TSubclassOf</h2><p>TSubClassOf基本等于UClass，只是增加了类型安全和类型筛选。</p><h2 id="14-TAssestPtr"><a href="#14-TAssestPtr" class="headerlink" title="14.TAssestPtr"></a>14.TAssestPtr</h2><p>TAssestPtr是一个配合FStreamableManager进行资产异步加载使用的指向资产的指针，是一个弱指针，指向的资产可以已经被加载了也可以还未被加载。</p><h1 id="八、容器"><a href="#八、容器" class="headerlink" title="八、容器"></a>八、容器</h1><p>UE的容器主要有TArray，TMap，TSet，TQueue基本上和其他语言里的Array，Map，Set，Queue都没多大区别。</p><h2 id="1-TArray"><a href="#1-TArray" class="headerlink" title="1.TArray"></a>1.TArray</h2><p>TArray是UE中使用最广泛的容器，一个可扩容动态数组，TArray的定义在<code>Engine\Source\Runtime\Core\Public\Containers\Array.h</code>，是一个模板类，纵观TArray类的代码近3000行，但是变量却只有3个；</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002249.png"></p><ul><li>AllocatorInstance是数组的内存分配器；</li><li>ArrayNum是数组元素的实际个数；</li><li>ArrayMax是数组最大可容纳的元素数量；</li></ul><p>所以一个空数组的大小就是这三个成员变量的大小，由于分配器也是一个模板类，所以根据分配器的类型不同，空数组的大小也会有所变化，最小是一个指针加两个整型，即16字节。</p><p>而一个数组的内存大小就是ArrayMax*sizeof(ElementType)+AllocatorInstance所占用的大小。</p><h3 id="TArray的扩容原理"><a href="#TArray的扩容原理" class="headerlink" title="TArray的扩容原理"></a>TArray的扩容原理</h3><p>TArray的扩容原理和C++ STL的vector差不多，当数组容量满了之后就会再分配一个更大的内存空间，和vector一样TArray也是分配的一个连续的内存空间，所以在重新分配了内存之后TArray会把旧地址上的内容拷贝到新的内存地址中并释放掉旧内存；在网上没有查到TArray的扩容机制，既然TArray在原理和vctor差不多，那么我想TArray的扩容机制应该也是两倍扩容。</p><h3 id="TArray的移动构造函数"><a href="#TArray的移动构造函数" class="headerlink" title="TArray的移动构造函数"></a>TArray的移动构造函数</h3><p>与vector不同的是TArray使用了C++11提供的新特性—移动构造函数，我们知道在使用一个数组来初始化另一个数组时会执行TArray的拷贝构造函数，如果数组元素中存在指针引用，那么此时的执行的拷贝构造函数就是深拷贝，即不仅要拷贝指针还要把指针指向的内容也一并拷贝一份，TArray在提供了普通的拷贝构造函数的同时还提供给了移动构造函数，在使用一个数组初始化另一个数组时，移动构造函数只会拷贝旧数组的分配器和数组容量，数组的内容则是直接从旧数组移交给新数组，然后把旧数组恢复到无份配的初始状态，这样旧数组就成了一个空数组。</p><p>我们写一段代码来测试一下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">TArray&lt;<span class="hljs-keyword">int</span>&gt; arr1 = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span> &#125;;<br>TArray&lt;<span class="hljs-keyword">int</span>&gt; arr2;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Arr1:%d,Arr2:%d&quot;</span>), arr1.Num(), arr2.Num());<br>arr2 = MoveTemp(arr1);<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Arr1:%d,Arr2:%d&quot;</span>), arr1.Num(), arr2.Num());<br><span class="hljs-function">TArray&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">arr3</span><span class="hljs-params">(arr2)</span></span>;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Arr2:%d,Arr3:%d&quot;</span>), arr2.Num(), arr3.Num());<br></code></pre></td></tr></table></figure><p>输出：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002254.png"></p><p>这里有一个一点是需要注意的，就是使用移动构造的时候必须使用MoveTemp显示调用，否则调用不成功，反而去执行了拷贝构造函数，用例对比就是arr1初始化arr2和arr2初始化arr3。</p><h2 id="2-TMap"><a href="#2-TMap" class="headerlink" title="2.TMap"></a>2.TMap</h2><p>TMap也是一个经常使用的UE4容器，和TArray不同的是TMap是一个散列结构，TMap的存储空间可能不是一个连续的内存片段，而是通过hash映射来存储的，所以相对于TArray来说TMap的元素查找非常快速。</p><p>TMap是通过TSet来实现的，TMap的底层实现原理就是HashTable–哈希表，这与C++STL的Map不一样，STL的Map底层实现原理选择的是Red-Black Tree–红黑树，哈希表于红黑树在数据结构上又有区别，哈希表是基于数组的数据结构，而红黑树则是基于链表的数据结构，这是由TMap在UE4中主要面向的是渲染系统决定的，在渲染系统中高平率的数据操作是查找，在这方面数组相较于链表是有优势的。</p><p>TMap的元素都是以<code>TPair&lt;KeyType,ValueType&gt;</code>的形式存储，其中KeyType和ValueType是任意TMap可支持的类型，之所以说是可支持的，是因为不是所有的类型都是可以作为TMap的键的，按照<a href="https://docs.unrealengine.com/4.26/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/TMap/">官方文档</a>的说法，只有支持GetTypeHash函数并提供<code>==</code>运算符重载来比较键值是否相等的类型才能作为TMap的键类型，而值就可以是任意类型了。</p><h3 id="TMap的内存分配原理"><a href="#TMap的内存分配原理" class="headerlink" title="TMap的内存分配原理"></a>TMap的内存分配原理</h3><p>TMap是支持自选内存分配器来控制内存分配行为的，当然一般情况下我们都是使用默认的内存分配器—FDefaultSetAllocator ，这里TMap和TSet是一致的，顺带一提，TArray使用默认内存分配器是FDefaultAllocator ，UE4的内存分配器的篇幅也挺长的，详情可查看：<a href="https://www.cnblogs.com/kekec/p/12012537.html%E3%80%82">https://www.cnblogs.com/kekec/p/12012537.html。</a></p><p>当我们创建一个TMap时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">TMap&lt;<span class="hljs-keyword">int</span> FString&gt; StrMap<br></code></pre></td></tr></table></figure><p>此时StrMap是一个空Map，没有被分别任何内存。</p><p>和TArray一样，当我们往TMap中添加第一个元素时，TMap会使用配置的内存分配来申请一块内存空间，当这块内存空间被使用完之后，也会根据内存分配器的算法来进行扩容。</p><h3 id="自定义TMap键值"><a href="#自定义TMap键值" class="headerlink" title="自定义TMap键值"></a>自定义TMap键值</h3><p>前面有提到过，一个类型无论是结构体或是自定义类，只要满足重载<code>==</code>的自身类型比较和提供Hash值的GetTypeHash函数，则这个类型就可以作为TMap的键，所以自定键值的方式就很明确了。</p><p><strong>结构体</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">USTRUCT()<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FCusKey</span></span><br><span class="hljs-class">&#123;</span><br>GENERATED_BODY()<br>UObject* Obj;<br><span class="hljs-keyword">friend</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> FCusKey&amp; A, <span class="hljs-keyword">const</span> FCusKey&amp; B)<br>&#123;<br><span class="hljs-keyword">return</span> A.Obj == B.Obj;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">inline</span> uint32 <span class="hljs-title">GetTypeHash</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FCusKey&amp; Key)</span></span><br><span class="hljs-function"></span>&#123;<br>uint32 Hash = <span class="hljs-number">0</span>;<br>Hash = HashCombine(Hash, GetTypeHash(Key.Obj));<br><span class="hljs-keyword">return</span> Hash;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>应用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AContainerctor::CusTMapFun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>TMap&lt;FCusKey, FString&gt; CusMap;<br>FCusKey CusKey;<br>CusKey.Obj = NewObject&lt;UObject&gt;();<br>CusMap.Add(CusKey, TEXT(<span class="hljs-string">&quot;FirstObj&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>自定义类</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UE4CPP_API</span> <span class="hljs-title">FCusClassKey</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>FCusClassKey();<br>~FCusClassKey();<br><br><span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(FCusClassKey&amp; A,FCusClassKey&amp; B)<br>&#123;<br><span class="hljs-keyword">return</span> A == B;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">int</span> <span class="hljs-title">GetTypeHash</span><span class="hljs-params">(FCusClassKey&amp; Key)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> Hash = <span class="hljs-number">0</span>;<br>Hash = HashCombine(Hash, GetTypeHash(Key));<br><span class="hljs-keyword">return</span> Hash;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>应用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AContainerctor::CusTMapFun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>TMap&lt;FCusClassKey*, <span class="hljs-keyword">int</span>&gt; CusClassMap;<br>CusClassMap.Add(<span class="hljs-keyword">new</span> FCusClassKey(), <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>需要一提的是，两个函数中<code>friend</code>关键字是必须的否则编译就会报错，而<code>inline</code>和<code>const</code>都不是必须的，甚至GetTypeHash的返回值也不一定必须是uint32。</p><h2 id="3-TSet"><a href="#3-TSet" class="headerlink" title="3.TSet"></a>3.TSet</h2><p>UE4的TSet是通过TSparseArray实现的，本质上是一个特殊的数组，特殊之处在于TSet虽然是一个数组，但是TSet是散列的，内部存储元素不是连续的，并且TSet使用Hash值来映射index。</p><p>TSet和TMap极其相似，毕竟TMap就是使用TSet实现的，TSet也通过键值来操作元素，只不过TSet的键值和元素是同一个，同时TSet也能像TMap一样通过配置内存分配器来控制内存分配行为，也可以通过实现 重载<code>==</code>和GetTypeHash函数来自定义键值。</p><p>TSet与其他容器不同的是，TSet是一个自排序容器，添加进入TSet的元素，会按照TSet的默认排序规则自动排序，因为这个特性是的TSet对于元素的查找，删除，添加等操作都极为迅速，时间复杂度都是常数级的。</p><h2 id="4-TTuple"><a href="#4-TTuple" class="headerlink" title="4.TTuple"></a>4.TTuple</h2><p>看到TTuple时我是吃惊的，因为我一直以为元组是脚本类语言特有的容器，没想到UE4也实现了，更深入了解后才发现，原来C++中也有实现std::tuple。</p><p>不过UE4中元组的创建就不像脚本语言那样可以直接使用<code>[]</code>来得方便了，而是使用了专门的创建函数MakeTuple，这一点和智能指针有点类似。</p><p>另外UE4元组的元素数量和类型在声明元组时就已经确定了，不可以在运行时额外添加，如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">TTuple&lt;int, bool, float, FString&gt; tuple1(1, false, 1.0f, TEXT(&quot;aaa&quot;));<br></code></pre></td></tr></table></figure><p>即使我们使用auto类型，也必须配合static使用，而静态类型又要求设置初始值，所以实际上，元组的类型依然是在声明时就定死的，无法在运行时添加声明以外的元素类型和数量。</p><p><font color="red"> 另外UE4的代理就是使用元组来实现的。</font> </p><h2 id="5-UE4容器的注意事项"><a href="#5-UE4容器的注意事项" class="headerlink" title="5.UE4容器的注意事项"></a>5.UE4容器的注意事项</h2><p>理论上说，由于TArray的扩容机制，在数组存储空间用完时UE4会重新分配一个更大的存储空间并把数组迁移到新的空间去，这就会导致在扩容前保存的数组元素的引用出现引用失效的可能，而TSet，TMap的底层都是TArray所以都会有这样的问题。但是在我的实际测试中，把我笔记本16G内存榨干了似乎也没有出现引用失效的情况。</p><h1 id="九、宏"><a href="#九、宏" class="headerlink" title="九、宏"></a>九、宏</h1><p>UE4中提供大量的宏于开发者使用，这些宏的作用就类似库函数一般。只是需要注意的是，有的宏末尾没有“；”而有的宏末尾需要加“；”，在下面的书写中需要“；”的宏我就直接在末尾加“；”，不需要的则不加。UE4不人性化的一点是很多宏里面的参数在VS中没有提示，也没有颜色变化，更不会提示错误，所以在给宏添加参数时尤其要注意书写正确。</p><h2 id="1-UE-LOG-；"><a href="#1-UE-LOG-；" class="headerlink" title="1.UE_LOG()；"></a>1.UE_LOG()；</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h3><p>UE_LOG();宏用于向UE4控制台输出内容。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h3><p>UE4提供三个级别的UE_LOG;宏，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Hello World!&quot;</span>));<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Hello World!&quot;</span>));<br>UE_LOG(LogTemp, Error, TEXT(<span class="hljs-string">&quot;Hello World!&quot;</span>));<br></code></pre></td></tr></table></figure><ul><li><strong>LogTemp</strong>：是UE4提供给我们的一个临时UE_LOG();宏标签，这个标签是可以自定义的，如此我们便可以在不同的模块中使用不同标签的UE_LOG();宏，极大的便利了调试，这也是UE_LOG();宏的强大之处。</li><li><strong>Log/Warning/Error</strong>：这是UE_LOG();宏的三个级别，分别是日志级别–在控制台中输出白色字体；警告级别–在控制台中输出黄色字体，并有Warning提示；错误级别–在控制台中输出红色字体，并有Error提示。</li><li>**TEXT()**：TEXT()也是一个宏用于将我们自定义的额字符串输出到控制台。</li></ul><p><strong>输出变量</strong></p><p>UE_LOG()宏可以输出FString字符串，且字符串类型中只能输出FString。</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">UE<span class="hljs-meta">_LOG(</span>LogTemp, <span class="hljs-meta">Error</span>, TEXT(<span class="hljs-string">&quot;%s&quot;</span>),<span class="hljs-comment">*str);</span><br></code></pre></td></tr></table></figure><p><font color="red"> 使用*str是因为FString是UE4的封装类，定义的FString对象都是指针。</font></p><h3 id="日志等级"><a href="#日志等级" class="headerlink" title="日志等级"></a>日志等级</h3><p>UE对日志的打印分了很多个级别，不同的级别打印的内容有所差异，这里就直接摘抄一段<a href="https://www.jianshu.com/p/c550c3223a95">狼图腾_094d</a>的内容了。</p><ul><li>Fatal</li></ul><p>Fatal等级日志总是会打印到控制台和日志文件以及crash文件中，甚至logging功能被禁用。</p><p>使用Fatal等级的日志时，当代码运行到这个日志出会直接触发代码中断，是严重等级最高的日志等级。</p><ul><li>Error</li></ul><p>Error等级日志被打印到控制台和日志文件中，默认以红色显示。</p><ul><li>Warning</li></ul><p>Warning等级日志被打印到控制台和日志文件中，默认以黄色显示。</p><ul><li>Display</li></ul><p>Display等级日志被打印到控制台和日志文件中。</p><ul><li>Log</li></ul><p>Log等级日志打印到日志文件中但是不出现在game模式的控制台中，但是通过编辑器的日志输出窗口还是能够被看到。</p><ul><li>Verbose</li></ul><p>Verbose等级日志打印到日志文件中但是不出现在game模式的控制台中，这个通常被用来作为详细日志和调试使用。</p><ul><li>VeryVerbose</li></ul><p>VeryVerbose等级日志被打印到日志文件中但是不出现在game模式的控制台中，这通常用来打印非常详细的日志记录否则会产生很多不必要的垃圾输出。</p><p>严重级别从上往下一次递减，详细程度从上往下一次递增，日志类别的详细定义在LogVerbosity.h这个头文件中。</p><h3 id="自定义UE-LOG输出标签"><a href="#自定义UE-LOG输出标签" class="headerlink" title="自定义UE_LOG输出标签"></a>自定义UE_LOG输出标签</h3><p>UE提供<code>DECLARE_LOG_CATEGORY_EXTERN(CategoryName, DefaultVerbosity, CompileTimeVerbosity)</code>宏来让开发者自定日志标签，其中：</p><ul><li>CategoryName：日志类别的名称；</li><li>DefaultVerbosity：这个类别的日志等级，主要用于在控制台或ini文件里进行等级覆盖。</li><li>CompileTimeVerbosity：这个类别的日志可用的最大等级，如，设置成Warning，那么这个类别的日志就只能使用Warning、Error、Fatal三个等级，如果设置成All，那么这个类别就可以使用所有的日志等级，如果使用时传入的等级大于CompileTimeVerbosity规定的等级，那么这个日志行将不会被编译进程序里，运行时这一行代码不运行，这可以很好地进行批量地日志屏蔽。</li></ul><p>在.h文件中声明</p><h3 id="日志等级的覆盖"><a href="#日志等级的覆盖" class="headerlink" title="日志等级的覆盖"></a>日志等级的覆盖</h3><p>在代码里写好了的日志如果想要修改打印等级，除了直接修改代码外，UE还提供了更方便的方法，通过修改DefaultEngine.ini文件或输入命令行来修改日志等级。</p><ul><li><p>通过运行时命令行来动态地修改日志等级</p><p>运行通过按<code>~</code>键通过控制台输入<code>Log [CategoryName] [Level]</code>，（CategoryName：日志类别的名称，Level：等级）可以达到临时的动态的修改日志等级</p></li><li><p>通过修改Engine.ini来修改日志等级：我们在Engine.ini中添加一个</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Core.Log]</span><br><span class="hljs-attr">global</span>=Log<br><span class="hljs-attr">CategoryName</span>=Error<br></code></pre></td></tr></table></figure><p>global：对全局生效，覆盖所有日志的等级；CategoryName：日志类别的名称。</p></li><li><p>通过在Cmd启动exe在命令行后面接入指令或在exe快捷方式后面接入指令的方式修改日志等级</p><p>这里以快捷方式为例(cmd的效果是一样的)，首先打包一个windwos包，为exe创建一个快捷方式，打开快捷方式的属性，在快捷方式后面接入<code>-LogCmds=&quot;CategoryName Error,bar off&quot;</code>(CategoryName ：日志类别的名称)，启动游戏后就会按CompileTimeVerbosity的规则屏蔽或显示日志。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002306.png"></p></li></ul><h2 id="3-UCLASS-UPROPERTY-UFUNCTION"><a href="#3-UCLASS-UPROPERTY-UFUNCTION" class="headerlink" title="3.UCLASS()/UPROPERTY()/UFUNCTION()"></a>3.UCLASS()/UPROPERTY()/UFUNCTION()</h2><p><strong>作用</strong></p><p>这三个宏主要用于为类(UCLASS())，成员变量(UPROPERTY())和成员函数(UFUNCTION())指定一些特性， <strong>他们用来指定被修饰对象可以被复制、被序列化，并可从蓝图中进行访问。垃圾回收器还使用它们来追踪对 UObject 的引用数。</strong> </p><h3 id="UCLASS-宏的参数"><a href="#UCLASS-宏的参数" class="headerlink" title="UCLASS()宏的参数"></a>UCLASS()宏的参数</h3><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td><strong>Abstract</strong></td><td>抽象类说明符将类声明为 “抽象基类”, 防止用户在虚幻编辑器中向世界添加此类的参与者, 或在游戏中创建此类的实例。这对于那些本身没有意义的类很有用。例如, ATriggerBase 基类是抽象的, 而 ATriggerBox 子类别不是抽象的, 您可以在世界上放置一个 ATriggerBox 类的实例, 并且它是有用的, 而 ATriggerBase 的实例本身并不有用</td></tr><tr><td><strong>AdvancedClassDisplay</strong></td><td>AdvancedClassDisplay 类说明符强制类的所有属性只显示在 “详细信息” 面板的 “高级” 部分中, 默认情况下隐藏在 “视图” 中。若要在单个属性上重写此项, 请在该属性上使用 SimpleDisplay 说明符</td></tr><tr><td><strong>AutoCollapseCategories</strong>=(Category1, Category2, …)</td><td>类说明符取消对父类AutoExpandCategories说明符的列出类别的影响</td></tr><tr><td><strong>DontAutoCollapseCategories</strong>=(Category, Category, …)</td><td>否定从父类继承的列出类别的AutoCollapseCategories说明符</td></tr><tr><td><strong>AutoExpandCategories</strong>=(Category1, Category2, …)</td><td>指定应在该类的对象的 “虚幻编辑器” 属性窗口中自动展开的一个或多个类别。若要自动声明为无类别的变量, 请使用声明变量的类的名称</td></tr><tr><td><strong>Blueprintable / NotBlueprintable</strong></td><td>将此类公开为创建蓝图的可接受基类。默认是NotBlueprintable，除非继承，否则该说明符由子类继承</td></tr><tr><td><strong>BlueprintType</strong></td><td>将此类公开为可用于蓝图中的变量的类型</td></tr><tr><td><strong>ClassGroup</strong>=GroupName</td><td>表示在Actor浏览器中启用Group View后，虚幻编辑器的Actor浏览器应该在指定的GroupName中包含此类以及此类的任何子类 <strong>CollapseCategories / DontCollapseCategories</strong></td></tr><tr><td><strong>CollapseCategories / DontCollapseCategories</strong></td><td>表示不应将此类的属性分组到虚幻编辑器属性窗口中的类别中。这个说明符被传播给子类；但是，子类可以使用DontCollapseCategories说明符来覆盖它</td></tr><tr><td><strong>Config</strong>=ConfigName</td><td>表示允许此类在配置文件 (. ini) 中存储数据。如果有使用 config 或 globalconfig 说明符声明的任何类属性, 则此指定符将导致这些属性存储在命名的配置文件中。此说明符被传播到所有子类, 不能被否定, 但是子类可以通过 re-declaring 配置说明符并提供不同的 ConfigName 来更改配置文件。常见的 ConfigName 值是 “Engine”、”Editor”、”Input” 和 “Game”</td></tr><tr><td><strong>Const</strong></td><td>该类中的所有属性和函数都是const的，并以const的形式导出。该说明符由子类继承</td></tr><tr><td><strong>ConversionRoot</strong></td><td>Root转换将一个子类限制为仅能够转换为第一个Root类的子类，并上升到层次结构</td></tr><tr><td><strong>CustomConstructor</strong></td><td>阻止自动生成构造函数声明</td></tr><tr><td><strong>DefaultToInstanced</strong></td><td>这个类的所有实例都被认为是“实例化”的。实例化的类（组件）在构建时被复制。该说明符由子类继承</td></tr><tr><td><strong>DependsOn</strong>=(ClassName1, ClassName2, …)</td><td>列出的所有类将在该类之前编译。类必须在同一个 (或上一个) 包中指定一个类。可以使用由逗号分隔的单个取决于行指定多个依赖项类, 也可以为每个类使用单独的取决于行指定。当类使用在另一个类中声明的结构或枚举时, 这一点很重要, 因为编译器只知道它已编译的类中的内容</td></tr><tr><td><strong>Deprecated</strong></td><td>这个类不推荐使用，而且这个类的对象在序列化的时候不会被保存。该说明符由子类继承</td></tr><tr><td><strong>EditInlineNew / NotEditInlineNew</strong></td><td>表示可以从 “虚幻编辑器” 属性窗口创建此类的对象, 而不是从现有资产引用。默认行为是只有对现有对象的引用才可以通过属性窗口分配。此说明符被传播到所有子类；子类可以使用 NotEditInlineNew 说明符来重写此说明符</td></tr><tr><td><strong>HideCategories</strong>=(Category1, Category2, …)</td><td>列出应隐藏在此类对象的 “虚幻编辑器” 属性窗口中的一个或多个类别。若要隐藏声明为 “no” 类别的属性, 请使用声明该变量的类的名称。此说明符被传播到子类</td></tr><tr><td><strong>ShowCategories</strong>=(Category1, Category2, …)</td><td>为所列出的类别取消一个HideCategories说明符（从基类继承）</td></tr><tr><td><strong>HideDropdown</strong></td><td>防止在虚幻编辑器属性窗口组合框中显示此类</td></tr><tr><td><strong>HideFunctions</strong>=(Category1, Category2, …)</td><td>从属性查看器隐藏指定类别中的所有函数</td></tr><tr><td><strong>ShowFunctions</strong>=(Category1, Category2, …)</td><td>在属性查看器中显示列出的类别中的所有功能</td></tr><tr><td><strong>HideFunctions</strong>=FunctionName</td><td>隐藏属性查看器中的指定名称的函数</td></tr><tr><td><strong>ShowFunctions</strong>=FunctionName</td><td>显示属性查看器中的指定名称的函数</td></tr><tr><td><strong>Intrinsic</strong></td><td>这表明这个类是直接用C ++声明的，并且没有虚幻头文件工具生成的样板文件。不要在新类上使用这个说明符</td></tr><tr><td><strong>MinimalAPI</strong></td><td>仅导致要导出的类的类型信息供其他模块使用。类可以被强制转换, 但不能调用类的函数 (内联方法除外)。这提高了编译时间, 因为不为不需要在其他模块中访问所有函数的类导出所有内容</td></tr><tr><td><strong>NoExport</strong></td><td>表示此类的声明不应包含在由标头生成器自动生成的 c++ 头文件中。必须在单独的头文件中手动定义 c++ 类声明。仅对本机类有效。不要将此用于新类</td></tr><tr><td><strong>Placeable</strong>/<strong>NotPlaceable</strong></td><td>表示可以在编辑器中创建此类, 并将其置于关卡、UI 场景或蓝图中 (具体取决于类类型)。此标志将传播到所有子类；子类可以使用 NotPlaceable 说明符来重写此标志</td></tr><tr><td><strong>Transient</strong>/<strong>NonTransient</strong></td><td>属于此类的对象将永远不会保存到磁盘。这与某些非永久性的自然类 (如播放器或窗口) 结合使用非常有用。此说明符被传播到子类, 但可以由 NonTransient 说明符重写</td></tr><tr><td><strong>Within</strong>=OuterClassName</td><td>这个类的对象不能存在于一个OuterClassName对象的实例之外。这意味着创建这个类的Object需要提供一个OuterClassName的实例作为其外部对象</td></tr></tbody></table><p>参考博客： <a href="https://blog.csdn.net/u012793104/article/details/78547655">https://blog.csdn.net/u012793104/article/details/78547655</a> </p><h3 id="UPROPERTY-宏的参数"><a href="#UPROPERTY-宏的参数" class="headerlink" title="UPROPERTY()宏的参数"></a>UPROPERTY()宏的参数</h3><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td><strong>AdvancedDisplay</strong></td><td>属性在“详细信息”面板的高级下拉列表中</td></tr><tr><td><strong>AssetRegistrySearchable</strong></td><td>表明此属性及其值将会为任意将其作为成员变量而包含的资源类示例被自动添加到资源注册中。不可用于结构体属性或参数</td></tr><tr><td><strong>BlueprintAssignable</strong></td><td>仅能用于Multicast代理。应显示该属性，以供在蓝图中分配</td></tr><tr><td><strong>BlueprintCallable</strong></td><td>仅能用于Multicast代理。应显示该属性，以在蓝图代码中调用</td></tr><tr><td><strong>BlueprintReadOnly</strong></td><td>设置属性为蓝图只读。会在蓝图脚本中为被修饰的变量提供 Get 方法，没有 Set 方法</td></tr><tr><td><strong>BlueprintReadWrite</strong></td><td>设置属性为蓝图读写。会在蓝图脚本中为被修饰的变量提供 Get 和 Set 方法</td></tr><tr><td><strong>BlueprintGetter</strong></td><td>指定一个自定义存取器函数。如果这个属性没有被标记为BlueprintSetter或者BlueprintReadWrite，那么它就是隐式的BlueprintReadOnly。用法：<code>BlueprintGetter = GetterFunctionName()</code></td></tr><tr><td><strong>BlueprintSetter</strong></td><td>BlueprintSetter属性有一个自定义的mutator函数，并用BlueprintReadWrite隐式标记。注意，必须指定mutator函数，用法<code>BlueprintSetter = SetterFunctionName</code></td></tr><tr><td><strong>Category</strong> = “TopCategory`</td><td><code>SubCategory</code></td></tr><tr><td><strong>Config</strong></td><td>这个变量将被配置。当前值可以保存到与类关联的.ini文件中，并在创建时加载。无法在默认属性中给出值。意味着ReadOnly</td></tr><tr><td><strong>Const</strong></td><td>这个变量是常量,应该导出为常量。在编辑器中const属性将是不可修改的</td></tr><tr><td><strong>DuplicateTransient</strong></td><td>表示变量值应在任意类型的重复过程中(复制/粘贴， 二进制文件复制等)被重置为类默认值</td></tr><tr><td><strong>EditAnywhere</strong></td><td>此属性可以通过属性窗口，原型和实例进行编辑（原型指的是类模板，实例指的是具体的对象实例），这里要注意，不要把指针变量设置成EditAnywhere</td></tr><tr><td><strong>VisibleAnywhere</strong></td><td>此属性在所有属性窗口中都可见，但无法编辑。这个标签与“Edit”标签不兼容</td></tr><tr><td><strong>EditDefaultsOnly</strong></td><td>该属性可以由属性窗口编辑，但只能在原型上编辑。该操作符与“Visible”标签不兼容</td></tr><tr><td><strong>VisibleDefaultOnly</strong></td><td>此属性仅在原型的属性窗口中可见，并且不能被编辑。这个标签与“Edit”标签不兼容</td></tr><tr><td><strong>EditInstanceOnly</strong></td><td>这个属性可以被属性窗口编辑，但只能在实例上编辑，而不能在原型上编辑。该操作符与“Visible”标签不兼容</td></tr><tr><td><strong>VisibleInstanceOnly</strong></td><td>此属性仅在实例的属性窗口中可见，而不在原型中显示，且无法编辑。这个标签与“编辑”标签不兼容</td></tr><tr><td><strong>EditFixedSize</strong></td><td>只对动态数组有用。这将防止用户通过虚幻编辑器属性窗口更改数组的长度</td></tr><tr><td><strong>EditInline</strong></td><td>允许用户编辑虚幻编辑器属性检查器中由该变量引用的对象的属性（仅用于对象引用，包括Object引用数组）</td></tr><tr><td><strong>Export</strong></td><td>仅适用于对象属性 (或对象数组)。指示在复制对象 (用于复制/粘贴) 或导出到 T3D 时, 应将分配给此属性的对象整体导出为对象块, 而不是仅输出对象引用本身</td></tr><tr><td><strong>GlobleConfig</strong></td><td>像Config一样工作，只是你不能在子类中覆盖它。无法在默认属性中给出值。意味着ReadOnly</td></tr><tr><td><strong>Instanced</strong></td><td>对象 (UCLASS) 属性。创建此类的实例时, 将为默认情况下分配给该变量的对象提供一个唯一的副本。用于在类默认属性中定义的实例子。类似 EditInline 和 Export 修饰符</td></tr><tr><td><strong>Interp</strong></td><td>表示该值可由Matinee的浮点或向量属性轨迹来随时间驱动</td></tr><tr><td><strong>Localized</strong></td><td>此变量的值将定义本地值。最常用于字符串。ReadOnly</td></tr><tr><td><strong>Native</strong></td><td>C++代码负责对其序列化并显示给GC</td></tr><tr><td><strong>NoClear</strong></td><td>防止该对象引用在编辑器中被设置为None.隐藏编辑器的清除（以及浏览）按钮</td></tr><tr><td><strong>NoExport</strong></td><td>仅对native类有效。此变量不应被包含在自动生成的类声明中</td></tr><tr><td><strong>NonPIEDuplicateTeansient</strong></td><td>在复制过程中，该属性将被重置为默认值，除非复制PIE会话</td></tr><tr><td><strong>NonTransactional</strong></td><td>表示对此变量值所做的更改将不会包含在编辑器的撤销/重做历史记录中</td></tr><tr><td><strong>NotReplicated</strong></td><td>跳过复制。这只适用于服务请求函数中的结构成员和参数</td></tr><tr><td><strong>Ref</strong></td><td>该值在函数调用后被复制出来。仅在函数参数声明中有效</td></tr><tr><td><strong>Replicated</strong></td><td>变量应通过网络进行复制</td></tr><tr><td><strong>ReplicatedUsing</strong> = FunctionName</td><td>ReplicatedUsing标签指定了一个回调函数，当通过网络更新变量时执行回调函数</td></tr><tr><td><strong>RepRetry</strong></td><td>仅用于结构体属性。如无法被完全发送，请重试复制此属性（例如，对象引用尚无法通过节点网络来进行序列化）。对于简单引用来说，这是一个默认值，但对结构体来说，由于带宽消耗，很多情况下我们不需要。所以除非此标识被定义，否则其会被禁用</td></tr><tr><td><strong>SaveGame</strong></td><td>此说明符是一种简单的方法，可以在属性级别为检查点/保存系统显式包含字段。该标志应设置在所有意图成为已保存游戏一部分的字段上，然后可使用代理归档程序对其进行读取/写入</td></tr><tr><td><strong>SerializeText</strong></td><td>应将Native属性序列化为文本（ImportText，ExportText）</td></tr><tr><td><strong>SkipSerialization</strong></td><td>该属性不会被序列化，但仍然可以导出为文本格式（例如复制/粘贴）</td></tr><tr><td><strong>SimpleDisplay</strong></td><td>“Visible”或“Edit”属性显示在“详细信息”面板中，不显示“高级”部分即可见</td></tr><tr><td><strong>TextExportTransient</strong></td><td>此属性不会被导出为文本格式（例如复制/粘贴）</td></tr><tr><td><strong>Transient</strong></td><td>属性是暂时的，这意味着它不会被保存或加载。以这种方式标记的属性在加载时将被填满</td></tr></tbody></table><p>参考博客： <a href="https://blog.csdn.net/u012793104/article/details/78480085">https://blog.csdn.net/u012793104/article/details/78480085</a> </p><p>UPROPERTY()宏提供了一些元数据说明符，元数据说明符可以对变量做一些限制，比如输入值的大小限定在某一个范围内，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">UPROPRETY(meta=(ClampMin=<span class="hljs-number">-5.0f</span>,ClampMax=<span class="hljs-number">5.0f</span>,UIMin=<span class="hljs-number">-5.0f</span>,UIMax=<span class="hljs-number">5.0f</span>))<br></code></pre></td></tr></table></figure><p>详细的说明参官方文档： <a href="https://docs.unrealengine.com/zh-CN/Programming/UnrealArchitecture/Reference/Metadata/index.html">https://docs.unrealengine.com/zh-CN/Programming/UnrealArchitecture/Reference/Metadata/index.html</a> </p><h3 id="UFUNCTION-宏的参数"><a href="#UFUNCTION-宏的参数" class="headerlink" title="UFUNCTION()宏的参数"></a>UFUNCTION()宏的参数</h3><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td><strong>BlueprintAuthorityOnly</strong></td><td>如果在具有网络权限的计算机（服务器，专用服务器或单人游戏）上运行，此功能只能从Blueprint代码执行,如无网络权限，则该函数将不会从蓝图代码中执行</td></tr><tr><td><strong>BlueprintCallable</strong></td><td>该函数可以在蓝图或关卡蓝图图表中执行</td></tr><tr><td><strong>BlueprintCosmetic</strong></td><td>此函数为修饰函数而且无法运行在专属服务器上</td></tr><tr><td><strong>BlueprintGetter</strong></td><td>修饰自定义的Getter函数专用，该函数将用作Blueprint暴露属性的访问器。这个说明符意味着BlueprintPure和BlueprintCallable。参考：<a href="https://blog.csdn.net/u012793104/article/details/78480085">https://blog.csdn.net/u012793104/article/details/78480085</a></td></tr><tr><td><strong>BlueprintSetter</strong></td><td>修饰自定义的Setter函数专用，此函数将用作Blueprint暴露属性的增变器。这个说明符意味着BlueprintCallable。参考：<a href="https://blog.csdn.net/u012793104/article/details/78480085">https://blog.csdn.net/u012793104/article/details/78480085</a></td></tr><tr><td><strong><font color="red">BlueprintImplementableEvent</font></strong></td><td>此函数可以在蓝图或关卡蓝图图表内进行重载<em>不能修饰private级别的函数，函数在C++代码中不需要实现定义</em></td></tr><tr><td><strong>BlueprintInternalUseOnly</strong></td><td>表示该函数不应该暴露给最终用户</td></tr><tr><td><strong>BlueprintNativeEvent</strong></td><td>此函数将由蓝图进行重载，但同时也包含native类的执行。提供一个名称为[FunctionName]_Implementation的函数本体而非[FunctionName];自动生成的代码将包含转换程序,此程序在需要时会调用实施方式</td></tr><tr><td><strong>BlueprintPure</strong></td><td>该函数不会以任何方式影响拥有对象，并且可以在蓝图或级别蓝图图表中执行</td></tr><tr><td><strong>CallInEditor</strong></td><td>该函数可以在编辑器中通过详细信息面板中的按钮在选定实例中调用</td></tr><tr><td><strong>Category</strong> = “TopCategory`</td><td>`SubCategory|…”</td></tr><tr><td><strong>Client</strong></td><td>此函数仅在该函数从属对象所从属的客户端上执行。提供一个名称为[FunctionName]_Implementation的函数主体，而不是[FunctionName]; 自动生成的代码将包含一个转换程序来在需要时调用实现方法</td></tr><tr><td><strong>CustomThunk</strong></td><td>UnrealHeaderTool（虚幻头文件工具）的代码生成器将不会为此函数生成execFoo转换程序; 可由用户来提供</td></tr><tr><td><strong>Exec</strong></td><td>此函数可从游戏中的控制台中执行。Exec命令仅在特定类中声明时才产生作用,此标记修饰的函数应在可以接受输入的类中，才能正常接受命令</td></tr><tr><td><strong>NetMilticast</strong></td><td>无论角色的NetOwner如何，该函数都在服务器上本地执行并复制到所有客户端</td></tr><tr><td><strong>Reliable</strong></td><td>Reliable函数在网络间进行复制，并会忽略带宽或网络错误而被确保送达。仅在与客户端或服务器共同使用时可用</td></tr><tr><td><strong>UnReliable</strong></td><td>UnReliable函数在网络间复制，但可能会由于带宽限制或网络错误而传送失败。仅在与客户端或服务器一起使用时有效</td></tr><tr><td><strong>SealeEvent</strong></td><td>这个函数不能在子类中重写。 SealedEvent关键字只能用于事件。对于非事件函数，声明它们是static的还是final的来封闭它们</td></tr><tr><td><strong>ServiceRequest</strong></td><td>ServiceRequest函数是一个RPC服务请求</td></tr><tr><td><strong>ServiceResponse</strong></td><td>ServiceResponse函数是一个RPC服务响应</td></tr><tr><td><strong>Server</strong></td><td>此函数仅在服务器上执行。提供一个名称为[FunctionName]_Implementation的函数主体，而不是[FunctionName]; 自动生成的代码将包含一个转换程序来在需要时调用实现方法</td></tr><tr><td><strong>WithValidation</strong></td><td>声明一个名为与main函数相同的附加函数，但将_Validation添加到最后。该函数采用相同的参数，并返回一个布尔值来指示是否应该继续调用主函数</td></tr></tbody></table><p>UFUNCTION()宏也提供了元数据说明符，元数据说明符可以对参数做一些限制，这里不再列出，详细的说明参官方文档： <a href="https://docs.unrealengine.com/zh-CN/Programming/UnrealArchitecture/Reference/Metadata/index.html">https://docs.unrealengine.com/zh-CN/Programming/UnrealArchitecture/Reference/Metadata/index.html</a> </p><h2 id="4-meta"><a href="#4-meta" class="headerlink" title="4.meta"></a><span id="meta">4.meta</span></h2><p>meta是UCLASS、UPROPERTY、UFUNCTION、UINTERFACE、USTRUCT、UENUM宏使用的元数据说明，用以描述类、属性、函数、接口、结构体和枚举，对于不同的类型meta有不同的元数据说明符。</p><p>这里就直接摘抄<a href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/GameplayArchitecture/Metadata/">UE官网</a>的内容了。</p><h3 id="类元数据说明符"><a href="#类元数据说明符" class="headerlink" title="类元数据说明符"></a>类元数据说明符</h3><table><thead><tr><th align="left">说明符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>BlueprintSpawnableComponent</code></td><td align="left">如果存在，组件类可以由蓝图生成。</td></tr><tr><td align="left"><code>BlueprintThreadSafe</code></td><td align="left">仅对蓝图函数库有效。该说明符将此类中的函数标记为可在动画蓝图中的非游戏线程上调用。</td></tr><tr><td align="left"><code>ChildCannotTick</code></td><td align="left">用于 Actor 和 Component 类。如果原生类无法勾选，则基于此 Actor 或组件的蓝图生成的类将永远无法勾选，即使<code>bCanBlueprintsTickByDefault</code>为真。</td></tr><tr><td align="left"><code>ChildCanTick</code></td><td align="left">用于 Actor 和 Component 类。如果原生类无法勾选，则基于此 Actor 或组件的蓝图生成的类可以<code>bCanEverTick</code>覆盖该标志，即使该标志<code>bCanBlueprintsTickByDefault</code>为 false。</td></tr><tr><td align="left"><code>DeprecatedNode</code></td><td align="left">对于行为树节点，表示该类已弃用，编译时将显示警告。</td></tr><tr><td align="left"><code>DeprecationMessage=&quot;Message Text&quot;</code></td><td align="left">具有此元数据的已弃用类将包含此文本以及蓝图脚本在编译期间生成的标准弃用警告。</td></tr><tr><td align="left"><code>DisplayName=&quot;Blueprint Node Name&quot;</code></td><td align="left">蓝图脚本中此节点的名称将替换为此处提供的值，而不是代码生成的名称。</td></tr><tr><td align="left"><code>DontUseGenericSpawnObject</code></td><td align="left">不要使用蓝图脚本中的通用创建对象节点生成类的对象；此说明符仅适用于既不是 Actor 也不是 Actor 组件的蓝图类型类。</td></tr><tr><td align="left"><code>ExposedAsyncProxy</code></td><td align="left">在异步任务节点中公开此类的代理对象。</td></tr><tr><td align="left"><code>IgnoreCategoryKeywordsInSubclasses</code></td><td align="left">用于使类的第一个子类忽略所有继承的<code>ShowCategories</code>和说明<code>HideCategories</code>符。</td></tr><tr><td align="left"><code>IsBlueprintBase=&quot;true/false&quot;</code></td><td align="left">说明此类是（或不是）可接受的用于创建蓝图的基类，类似于<code>Blueprintable</code>或“NotBlueprintable”说明符。</td></tr><tr><td align="left"><code>KismetHideOverrides=&quot;Event1, Event2, ..&quot;</code></td><td align="left">不允许被覆盖的蓝图事件列表。</td></tr><tr><td align="left"><code>ProhibitedInterfaces=&quot;Interface1, Interface2, ..&quot;</code></td><td align="left">列出与类不兼容的接口。</td></tr><tr><td align="left"><code>RestrictedToClasses=&quot;Class1, Class2, ..&quot;</code></td><td align="left">蓝图函数库类可以使用它来限制对列表中命名的类的使用。</td></tr><tr><td align="left"><code>ShortToolTip=&quot;Short tooltip&quot;</code></td><td align="left">一个简短的工具提示，在某些情况下使用完整的工具提示可能会让人不知所措，例如父类选择器对话框。</td></tr><tr><td align="left"><code>ShowWorldContextPin</code></td><td align="left">指示放置在此类拥有的图表中的蓝图节点必须显示其世界上下文引脚，即使它们通常是隐藏的，因为此类的对象不能用作世界上下文。</td></tr><tr><td align="left"><code>UsesHierarchy</code></td><td align="left">指示类使用分层数据。用于实例化详细信息面板中的分层编辑功能。</td></tr><tr><td align="left"><code>ToolTip=&quot;Hand-written tooltip&quot;</code></td><td align="left">覆盖从代码注释自动生成的工具提示。</td></tr></tbody></table><h3 id="属性元数据说明符"><a href="#属性元数据说明符" class="headerlink" title="属性元数据说明符"></a>属性元数据说明符</h3><table><thead><tr><th align="left">说明符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>AllowAbstract=&quot;true/false&quot;</code></td><td align="left">用于<code>Subclass</code>和<code>SoftClass</code>属性。指示抽象类类型是否应显示在类选择器中。</td></tr><tr><td align="left"><code>AllowedClasses=&quot;Class1, Class2, ..&quot;</code></td><td align="left">用于<code>FSoftObjectPath</code>属性。逗号分隔列表，指示要在资产选择器中显示的资产的类类型。</td></tr><tr><td align="left"><code>AllowPreserveRatio</code></td><td align="left">用于<code>FVector</code>属性。在详细信息面板中显示此属性时，它会导致添加比率锁定。</td></tr><tr><td align="left"><code>ArrayClamp=&quot;ArrayProperty&quot;</code></td><td align="left">用于整数属性。将可在 UI 中输入的有效值限制在 0 和命名数组属性的长度之间。</td></tr><tr><td align="left"><code>AssetBundles</code></td><td align="left">用于<code>SoftObjectPtr</code>或<code>SoftObjectPath</code>属性。主数据资产中使用的 Bundle 名称列表，用于指定此引用属于哪些 Bundle。</td></tr><tr><td align="left"><code>BlueprintBaseOnly</code></td><td align="left">用于<code>Subclass</code>和<code>SoftClass</code>属性。指示类选择器中是否应仅显示蓝图类。</td></tr><tr><td align="left"><code>BlueprintCompilerGeneratedDefaults</code></td><td align="left"><code>CopyPropertiesForUnrelatedObjects</code>属性默认值由蓝图编译器生成，在编译后调用函数时不会被复制。</td></tr><tr><td align="left"><code>ClampMin=&quot;N&quot;</code></td><td align="left">用于浮点和整数属性。<code>N</code>指定可以为属性输入的最小值。</td></tr><tr><td align="left"><code>ClampMax=&quot;N&quot;</code></td><td align="left">用于浮点和整数属性。<code>N</code>指定可以为属性输入的最大值。</td></tr><tr><td align="left"><code>ConfigHierarchyEditable</code></td><td align="left">此属性被序列化为 config ( <code>.ini</code>) 文件，并且可以在配置层次结构中的任何位置设置。</td></tr><tr><td align="left"><code>ContentDir</code></td><td align="left">由<code>FDirectoryPath</code>属性使用。表示将使用<code>Content</code>文件夹内的 Slate 样式目录选择器选择路径。</td></tr><tr><td align="left"><code>DisplayAfter=&quot;PropertyName&quot;</code></td><td align="left"><code>PropertyName</code>只要两个属性属于同一类别，该属性就会在名为 的属性之后立即显示在蓝图编辑器中，无论其在源代码中的顺序如何。如果多个属性具有相同的<code>DisplayAfter</code>值和相同的<code>DisplayPriority</code>值，它们将按照在头文件中声明的顺序出现在命名属性之后。</td></tr><tr><td align="left"><code>DisplayName=&quot;Property Name&quot;</code></td><td align="left">为此属性显示的名称，而不是代码生成的名称。</td></tr><tr><td align="left"><code>DisplayPriority=&quot;N&quot;</code></td><td align="left">如果两个属性具有相同的<code>DisplayAfter</code>值，或者属于同一类别且没有<code>DisplayAfter</code>元标记，则此属性将确定它们的排序顺序。最高优先级值为 1，表示<code>DisplayPriority</code>值为 1 的属性将出现在<code>DisplayProirity</code>值为 2 的属性之上。如果多个属性具有相同的<code>DisplayAfter</code>值，它们将按照它们在标题中声明的顺序出现文件。</td></tr><tr><td align="left"><code>DisplayThumbnail=&quot;true&quot;</code></td><td align="left">表示该属性是一个资产类型，它应该显示所选资产的缩略图。</td></tr><tr><td align="left"><code>EditCondition=&quot;BooleanPropertyName&quot;</code></td><td align="left">命名一个布尔属性，用于指示是否禁用编辑此属性。放“！” 在属性名称反转测试之前。EditCondition 元标记不再局限于单个布尔属性。它现在使用成熟的表达式解析器进行评估，这意味着您可以包含完整的 C++ 表达式。</td></tr><tr><td align="left"><code>EditFixedOrder</code></td><td align="left">防止通过拖动对数组元素进行重新排序。</td></tr><tr><td align="left"><code>ExactClass=&quot;true&quot;</code></td><td align="left">用于<code>FSoftObjectPath</code>与 结合使用的属性<code>AllowedClasses</code>。指示是否只能使用中指定的确切类<code>AllowedClasses</code>，或者子类是否也有效。</td></tr><tr><td align="left"><code>ExposeFunctionCategories=&quot;Category1, Category2, ..&quot;</code></td><td align="left">指定在蓝图编辑器中构建功能列表时应公开其功能的类别列表。</td></tr><tr><td align="left"><code>ExposeOnSpawn=&quot;true&quot;</code></td><td align="left">指定该属性是否应在此 Class 类型的 Spawn Actor 节点上公开。</td></tr><tr><td align="left"><code>FilePathFilter=&quot;FileType&quot;</code></td><td align="left">由<code>FFilePath</code>属性使用。指示要在文件选择器中显示的路径过滤器。常用值包括“uasset”和“umap”，但这些不是唯一可能的值。</td></tr><tr><td align="left"><code>GetByRef</code></td><td align="left">使该属性的“获取”蓝图节点返回对该属性的 const 引用，而不是其值的副本。仅可用于稀疏类数据，并且仅在<code>NoGetter</code>不存在时使用。</td></tr><tr><td align="left"><code>HideAlphaChannel</code></td><td align="left">用于<code>FColor</code>和<code>FLinearColor</code>属性。指示<code>Alpha</code>在详细信息中显示属性小部件时应隐藏该属性。</td></tr><tr><td align="left"><code>HideViewOptions</code></td><td align="left">用于<code>Subclass</code>和<code>SoftClass</code>属性。隐藏在类选择器中更改视图选项的能力。</td></tr><tr><td align="left"><code>InlineEditConditionToggle</code></td><td align="left">表示布尔属性仅在其他属性中作为编辑条件切换内联显示，不应显示在其自己的行上。</td></tr><tr><td align="left"><code>LongPackageName</code></td><td align="left">由<code>FDirectoryPath</code>属性使用。将路径转换为长包名。</td></tr><tr><td align="left"><code>MakeEditWidget</code></td><td align="left">用于变换或旋转器属性，或变换或旋转器数组。指示该属性应在视口中作为可移动小部件公开。</td></tr><tr><td align="left"><code>NoGetter</code></td><td align="left">导致蓝图生成不为此属性生成“获取”节点。仅可用于稀疏类数据。</td></tr></tbody></table><h3 id="函数元数据说明符"><a href="#函数元数据说明符" class="headerlink" title="函数元数据说明符"></a>函数元数据说明符</h3><table><thead><tr><th align="left">说明符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>AdvancedDisplay=&quot;Parameter1, Parameter2, ..&quot;</code></td><td align="left">逗号分隔的参数列表将显示为高级引脚（需要 UI 扩展）。</td></tr><tr><td align="left"><code>AdvancedDisplay=N</code></td><td align="left">替换<code>N</code>为数字，第N个之后的所有参数都会显示为高级引脚（需要UI扩展）。例如，“AdvancedDisplay=2”会将除前两个参数之外的所有参数都标记为高级）。</td></tr><tr><td align="left"><code>ArrayParm=&quot;Parameter1, Parameter2, ..&quot;</code></td><td align="left">指示<code>BlueprintCallable</code>函数应使用调用数组函数节点，并且列出的参数应视为通配符数组属性。</td></tr><tr><td align="left"><code>ArrayTypeDependentParams=&quot;Parameter&quot;</code></td><td align="left">使用时<code>ArrayParm</code>，该说明符表示一个参数，它将确定<code>ArrayParm</code>列表中所有参数的类型。</td></tr><tr><td align="left"><code>AutoCreateRefTerm=&quot;Parameter1, Parameter2, ..&quot;</code></td><td align="left">列出的参数虽然通过引用传递，但如果它们的引脚断开连接，将具有自动创建的默认值。这是蓝图的一项便利功能，通常用于阵列引脚。</td></tr><tr><td align="left"><code>BlueprintAutocast</code></td><td align="left"><code>BlueprintPure</code>仅由蓝图函数库中的静态函数使用。将自动为函数的返回类型和第一个参数的类型添加一个强制转换节点。</td></tr><tr><td align="left"><code>BlueprintInternalUseOnly</code></td><td align="left">该函数是一个内部实现细节，用于实现另一个函数或节点。它永远不会直接暴露在蓝图图表中。</td></tr><tr><td align="left"><code>BlueprintProtected</code></td><td align="left">此函数只能在蓝图中的所属对象上调用。它不能在另一个实例上调用。</td></tr><tr><td align="left"><code>CallableWithoutWorldContext</code></td><td align="left">用于<code>BlueprintCallable</code>具有<code>WorldContext</code>pin 的函数，以指示即使其 Class 未实现该函数也可以调用该<code>GetWorld</code>函数。</td></tr><tr><td align="left"><code>CommutativeAssociativeBinaryOperator</code></td><td align="left">指示<code>BlueprintCallable</code>函数应使用 Commutative Associative Binary 节点。该节点没有引脚名称，但有一个<strong>添加引脚</strong>按钮，可以创建额外的输入引脚。</td></tr><tr><td align="left"><code>CompactNodeTitle=&quot;Name&quot;</code></td><td align="left">指示<code>BlueprintCallable</code>函数应以紧凑显示模式显示，并提供在该模式下显示的名称。</td></tr><tr><td align="left"><code>CustomStructureParam=&quot;Parameter1, Parameter2, ..&quot;</code></td><td align="left">列出的参数都被视为通配符。此说明符需要<code>UFUNCTION</code>-level 说明符<code>CustomThunk</code>，这将要求用户提供自定义<code>exec</code>函数。在这个函数中，可以检查参数类型，并根据这些参数类型进行适当的函数调用。<code>UFUNCTION</code>永远不应该调用 基础，如果是，则应该断言或记录错误。要声明自定义函数，请使用原始函数名称的<code>exec</code>语法。<code>DECLARE_FUNCTION(execMyFunctionName)``MyFunctionName</code></td></tr><tr><td align="left"><code>DefaultToSelf</code></td><td align="left">对于<code>BlueprintCallable</code>函数，这表明 Object 属性的命名默认值应该是节点的自身上下文。</td></tr><tr><td align="left"><code>DeprecatedFunction</code></td><td align="left">对该函数的任何蓝图引用都会导致编译警告，告知用户该函数已被弃用。您可以使用元数据说明符添加到弃用警告消息（例如，提供有关替换弃用函数的说明）<code>DeprecationMessage</code>。</td></tr><tr><td align="left"><code>DeprecationMessage</code>=”消息文本”</td><td align="left">如果该函数已弃用，则在尝试编译使用它的蓝图时，此消息将添加到标准弃用警告中。</td></tr><tr><td align="left"><code>DeterminesOutputType=&quot;Parameter&quot;</code></td><td align="left">函数的返回类型将动态更改以匹配连接到命名参数引脚的输入。参数应该是模板类型，例如<code>TSubClassOf&lt;X&gt;</code>or <code>TSoftObjectPtr&lt;X&gt;</code>，其中函数的原始返回类型是<code>X*</code>或具有值类型的容器<code>X*</code>，例如<code>TArray&lt;X*&gt;</code>.</td></tr><tr><td align="left"><code>DevelopmentOnly</code></td><td align="left">标记为的函数<code>DevelopmentOnly</code>只会在开发模式下运行。这对于调试输出等功能很有用，预计交付的产品中不存在该功能。</td></tr><tr><td align="left"><code>DisplayName=&quot;Blueprint Node Name&quot;</code></td><td align="left">蓝图中此节点的名称将替换为此处提供的值，而不是代码生成的名称。</td></tr><tr><td align="left"><code>ExpandEnumAsExecs=&quot;Parameter&quot;</code></td><td align="left">对于<code>BlueprintCallable</code>函数，这表示应该为<code>enum</code>参数使用的每个条目创建一个输入执行引脚。参数必须是具有<code>UENUM</code>标记的枚举类型。</td></tr><tr><td align="left"><code>HidePin=&quot;Parameter&quot;</code></td><td align="left">对于<code>BlueprintCallable</code>函数，这表明参数引脚应该从用户的视图中隐藏。以这种方式，每个功能只能隐藏一个引脚。</td></tr><tr><td align="left"><code>HideSelfPin</code></td><td align="left">隐藏“self”引脚，它指示正在调用函数的对象。“self”引脚在<code>BlueprintPure</code>与调用蓝图的类兼容的函数上自动隐藏。<code>HideSelfPin</code>经常使用元标记的函数也使用说明<code>DefaultToSelf</code>符。</td></tr><tr><td align="left"><code>InternalUseParam=&quot;Parameter&quot;</code></td><td align="left">与 类似<code>HidePin</code>，这从用户的视图中隐藏了命名参数的引脚，并且每个函数只能用于一个参数。</td></tr><tr><td align="left"><code>KeyWords=&quot;Set Of Keywords&quot;</code></td><td align="left">指定搜索此函数时可以使用的一组关键字，例如在蓝图图表中放置节点以调用函数时。</td></tr><tr><td align="left"><code>Latent</code></td><td align="left">表示潜在动作。潜在动作有一个类型参数<code>FLatentActionInfo</code>，该参数由说明<code>LatentInfo</code>符命名。</td></tr><tr><td align="left"><code>LatentInfo=&quot;Parameter&quot;</code></td><td align="left">对于 Latent<code>BlueprintCallable</code>函数，指示哪个参数是 LatentInfo 参数。</td></tr><tr><td align="left"><code>MaterialParameterCollectionFunction</code></td><td align="left">对于<code>BlueprintCallable</code>函数，指示应使用材质覆盖节点。</td></tr><tr><td align="left"><code>NativeBreakFunc</code></td><td align="left">对于<code>BlueprintCallable</code>函数，表示该函数应以与标准 Break Struct 节点相同的方式显示。</td></tr><tr><td align="left"><code>NotBlueprintThreadSafe</code></td><td align="left">仅在蓝图函数库中有效。此函数将被视为拥有类的一般<code>BlueprintThreadSafe</code>元数据的异常。</td></tr><tr><td align="left"><code>ShortToolTip=&quot;Short tooltip&quot;</code></td><td align="left">一个简短的工具提示，在某些情况下使用完整的工具提示可能会让人不知所措，例如父类选择器对话框。</td></tr><tr><td align="left"><code>ToolTip=&quot;Hand-written tooltip&quot;</code></td><td align="left">覆盖从代码注释自动生成的工具提示。</td></tr><tr><td align="left"><code>UnsafeDuringActorConstruction</code></td><td align="left">在 Actor 构造期间调用此函数是不安全的。</td></tr><tr><td align="left"><code>WorldContext=&quot;Parameter&quot;</code></td><td align="left">由<code>BlueprintCallable</code>函数用来指示哪个参数确定操作发生的世界。</td></tr></tbody></table><h3 id="接口元数据说明符"><a href="#接口元数据说明符" class="headerlink" title="接口元数据说明符"></a>接口元数据说明符</h3><table><thead><tr><th align="left">说明符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>CannotImplementInterfaceInBlueprint</code></td><td align="left">此接口可能不包含<a href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/GameplayArchitecture/Functions/Specifiers"><code>BlueprintImplementableEvent</code>或<code>BlueprintNativeEvent</code></a>函数，除了内部函数。如果它包含未定义蓝图的蓝图可调用函数，则必须在本机代码中实现这些函数。</td></tr></tbody></table><h3 id="结构体元数据说明符"><a href="#结构体元数据说明符" class="headerlink" title="结构体元数据说明符"></a>结构体元数据说明符</h3><table><thead><tr><th align="left">说明符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>HasNativeBreak=&quot;Module.Class.Function&quot;</code></td><td align="left">指示此结构具有自定义 Break Struct 节点。必须提供模块、类和函数名称。</td></tr><tr><td align="left"><code>HasNativeMake=&quot;Module.Class.Function&quot;</code></td><td align="left">指示此结构具有自定义 Make Struct 节点。必须提供模块、类和函数名称。</td></tr><tr><td align="left"><code>HiddenByDefault</code></td><td align="left">Make Struct 和 Break Struct 节点中的引脚默认隐藏。</td></tr><tr><td align="left"><code>ShortToolTip=&quot;Short tooltip&quot;</code></td><td align="left">一个简短的工具提示，在某些情况下使用完整的工具提示可能会让人不知所措，例如父类选择器对话框。</td></tr><tr><td align="left"><code>ToolTip=&quot;Hand-written tooltip</code></td><td align="left">覆盖从代码注释自动生成的工具提示。</td></tr></tbody></table><h3 id="枚举元数据说明符"><a href="#枚举元数据说明符" class="headerlink" title="枚举元数据说明符"></a>枚举元数据说明符</h3><table><thead><tr><th align="left">说明符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>Bitflags</code></td><td align="left">指示此枚举类型可以用作使用元数据说明符<code>UPROPERTY</code>设置的整数变量的标志。<code>Bitmask</code>，关于位掩码的使用参见<a href="https://blog.csdn.net/weixin_43844254/article/details/109208456">张悟基大佬的文章</a></td></tr><tr><td align="left"><code>Experimental</code></td><td align="left">将此类型标记为实验性且不受支持。</td></tr><tr><td align="left"><code>ScriptName=&quot;Display Name&quot;</code></td><td align="left">带引号的字符串将在编辑器中用作此枚举类型的名称，而不是 Unreal Header Tool 生成的默认名称。</td></tr><tr><td align="left"><code>ToolTip=&quot;Hand-written tooltip&quot;</code></td><td align="left">覆盖从代码注释自动生成的工具提示。</td></tr></tbody></table><h3 id="UMATE"><a href="#UMATE" class="headerlink" title="UMATE"></a>UMATE</h3><p>UMATE是枚举成员专用的元数据说明宏，可以使用如下说明符：</p><table><thead><tr><th>元数据说明符</th><th>描述</th></tr></thead><tbody><tr><td>DisplayName=”Enumerated Value Name”</td><td>该值的名称将是此处提供的文本，而不是代码生成的名称。</td></tr><tr><td>Hidden</td><td>该值不会出现在编辑器中。</td></tr><tr><td>ToolTip=”Hand-written tooltip.”</td><td>覆盖从代码注释自动生成的工具提示。</td></tr></tbody></table><h2 id="5-GENERATED-BODY"><a href="#5-GENERATED-BODY" class="headerlink" title="5.GENERATED_BODY()"></a>5.GENERATED_BODY()</h2><p>GENERATED_BODY()宏标识的类表示，此类不可以使用父类的声明，最常见的就是GENERATED_BODY标识的类必须要自己声明和实现无参构造函数，否则编译将无法通过。</p><h2 id="6-GENERATED-UCLASS-BODY"><a href="#6-GENERATED-UCLASS-BODY" class="headerlink" title="6.GENERATED_UCLASS_BODY()"></a>6.GENERATED_UCLASS_BODY()</h2><p>GENERATED_UCLASS_BODY()宏标识的类表示此类继承父类的声明，最常见的就是GENERATED_UCLASS_BODY()标识的类不需要声明构造函数，如果需要重写构造函数，则必须为构造函数传递FObjectInitializer类的常量引用，这也是为什么我们经常在UE4编程中看见如下代码的缘故</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">UMySQLDatabase::UMySQLDatabase(<span class="hljs-keyword">const</span> FObjectInitializer&amp; ObjectInitializer)<br>: Super(ObjectInitializer)<br>&#123;<br>        <span class="hljs-comment">//重写块</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中Super()用于给父类传递参数</p><p><font color="red"> GENERATED_BODY()和GENERATED_UCLASS_BODY()宏都会为其标识的类生成一些成员函数，只是二者在使用权限上有一些区别，具体生成了什么成员函数及其区别由于目前自己搜索到的资料过少，暂时无法弄明白，需要以后慢慢研究</font>。</p><h1 id="十、C-加载蓝图资源"><a href="#十、C-加载蓝图资源" class="headerlink" title="十、C++加载蓝图资源"></a>十、C++加载蓝图资源</h1><p>C++加载蓝图资源分两类，普通文件资源(如：mesh，material等)和蓝图类资源。</p><h2 id="1-加载文件资源"><a href="#1-加载文件资源" class="headerlink" title="1.加载文件资源"></a>1.加载文件资源</h2><p>UE4的文件资源一般都是继承自UObject，如：UStaticMesh、UMaterial、UUserWidget、UComponent等，这些继承自UObject的资源都可以通过<code>LoadObject</code>函数加载，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AContainerctor::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br>UStaticMesh* Mesh = LoadObject&lt;UStaticMesh&gt;(<span class="hljs-literal">nullptr</span>, TEXT(<span class="hljs-string">&quot;StaticMesh&#x27;/Game/Cube.Cube&#x27;&quot;</span>));<br>UStaticMeshComponent* MeshComp = NewObject&lt;UStaticMeshComponent&gt;(<span class="hljs-keyword">this</span>, TEXT(<span class="hljs-string">&quot;Cube&quot;</span>));<br>MeshComp-&gt;RegisterComponent();<br>MeshComp-&gt;SetStaticMesh(Mesh);<br>&#125;<br></code></pre></td></tr></table></figure><p>除此之外UE4还提供一个<code>StaticLoadObject</code>函数，效果上和LoadObject函数一致，区别在于LoadObject是对StaticLOadObject的封装，LoadObject会自动转换UObject类型，而StaticLoadObject需要自己手动转换。</p><p>虽然LoadObject在构造函数内外都可以使用，不过UE4还是提供了一个专门给构造函数使用的资源加载函数<code>ConstructorHelpers::FObjectFinder</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">AContainerctor::AContainerctor()<br>&#123;<br>PrimaryActorTick.bCanEverTick = <span class="hljs-literal">true</span>;<br><span class="hljs-function">ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt; <span class="hljs-title">Mesh</span><span class="hljs-params">(TEXT(<span class="hljs-string">&quot;StaticMesh&#x27;/Game/Cube.Cube&#x27;&quot;</span>))</span></span>;<br>UStaticMeshComponent* MeshComp = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(<span class="hljs-string">&quot;Cube&quot;</span>);<br>MeshComp-&gt;SetupAttachment(GetRootComponent());<br>MeshComp-&gt;SetStaticMesh(Mesh.Object);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们注意到直接通过编辑器拷贝的资源路径都有一个对应资源的前缀，在这里是StaticMesh，实际上这个前缀要不要效果是一样的。</p><p>上面的加载方式想要把资源路径做得更灵活，可以把资源路径以FString变量的形式传递，并可以把变量公开到蓝图，但是在输入上我们依然要输入一个资源路径，UE4封装了一个更便捷的封装方式—<code>FSoftObjectPath</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UE4CPP_API</span> <span class="hljs-title">AContainerctor</span> :</span> <span class="hljs-keyword">public</span> AActor<br>&#123;<br>GENERATED_BODY()<br><span class="hljs-keyword">public</span>:<br>UPROPERTY(EditAnywhere)<br>FSoftObjectPath softObj;<br>AContainerctor();<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Tick</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime)</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AContainerctor::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br>UStaticMesh* Mesh = CastChecked&lt;UStaticMesh&gt;(softObj.TryLoad());<br>UStaticMeshComponent* MeshComp = NewObject&lt;UStaticMeshComponent&gt;(<span class="hljs-keyword">this</span>, TEXT(<span class="hljs-string">&quot;Cube&quot;</span>));<br>MeshComp-&gt;RegisterComponent();<br>MeshComp-&gt;SetStaticMesh(Mesh);<br>&#125;<br></code></pre></td></tr></table></figure><p>这一顿操作下来就可以形成这样的资源的路径选择。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002325.png"></p><h2 id="2-加载蓝图资源"><a href="#2-加载蓝图资源" class="headerlink" title="2.加载蓝图资源"></a>2.加载蓝图资源</h2><p>加载蓝图类使用的是<code>LoadClass</code>，相对的也存在一个<code>StaticLoadClass</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AContainerctor::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br>UClass* uclass = LoadClass&lt;AActor&gt;(<span class="hljs-literal">nullptr</span>,TEXT(<span class="hljs-string">&quot;Blueprint&#x27;/Game/Act.Act_C&#x27;&quot;</span>));<br>AActor* Act = GetWorld()-&gt;SpawnActor&lt;AActor&gt;(uclass);<br>&#125;<br></code></pre></td></tr></table></figure><p>与加载资源不同的是，加载蓝图类的路径需要手动加载<code>_C</code>后缀，否则UE4会找不到对应的蓝图类。</p><p>同上，在构造函数中加载，UE4也提供了<code>ConstructorHelpers::FClassFinder</code>函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ConstructorHelpers::FClassFinder&lt;AActor&gt; <span class="hljs-title">Act</span><span class="hljs-params">(TEXT(<span class="hljs-string">&quot;Blueprint&#x27;/Game/Act.Act_C&#x27;&quot;</span>))</span></span>;<br></code></pre></td></tr></table></figure><p>但是由于UE4是不允许在构造函数中SpawnActor的，所以即使我们在构造函数中加载了类资源，也必须在构造函数外加载蓝图类。</p><p>同FSoftObjectPath一样，UE4提供FSoftClassPath。</p><p>最终的效果就是这样的：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002330.png"></p><h1 id="十一、反射和垃圾回收"><a href="#十一、反射和垃圾回收" class="headerlink" title="十一、反射和垃圾回收"></a>十一、反射和垃圾回收</h1><p>UE4使用C++语言进行开发，但是C++并不支持反射和垃圾回收机制，所以UE4便自己实现了反射和垃圾回收。</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>UE4使用一系列的宏来实现反射，在反射中用的宏主要有</p><table><thead><tr><th>宏</th><th>对应的反射对象</th></tr></thead><tbody><tr><td>UCLASS</td><td>C++类</td></tr><tr><td>UFUNCTION</td><td>函数</td></tr><tr><td>UPROPERTY</td><td>成员变量</td></tr><tr><td>USTRUCT</td><td>结构体</td></tr></tbody></table><p><font color="red">要使用这些宏，必须包含头文件<code>#include &quot;MyActor.generated.h&quot;</code>，并且这个头文件还必须放在左后一位</font>。</p><h3 id="UE4是如何实现反射的呢？"><a href="#UE4是如何实现反射的呢？" class="headerlink" title="UE4是如何实现反射的呢？"></a>UE4是如何实现反射的呢？</h3><p>我们要想要让某一块代码块可以被反射，我们就必须在这个代码块中使用上面的宏，如：我们想要某个类可以被反射，那么就必须在类前添加宏<code>UCLASS()</code>，并且面的函数，成员变量，结构体前也必须添加相应的宏。当我们添加了宏后，UE4在编译时会调用中头文件<code>.generate.h</code>中相应宏定义有关反射的方法，并通过Unreal Build Tool(UBT)和Unreal Header Tool(UHT)两个工具生成一个<code>.generate.cpp</code>文件，<code>.generate.h</code>文件则是一个包含了反射数据的C++代码。如此UE4便可以通过<code>.generate.cpp</code>来获取元数据。</p><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>UE4的垃圾回收的使用有如下几种方式：</p><p><strong>继承自UObject类的类对象</strong></p><p>我们可以直接在成员变量前引入宏<font color="red">UPROPERTY()</font>，这个宏不仅可以标记反射还可以为垃圾回收做标记。</p><p>我们也可以是使用<font color="red">TWeakObjectPtr</font>指针，TWeakObjectPtr是一个弱指针，通常定义在类的内部用来操纵堆区中的对象。TWeakObjectPtr是一个泛型指针，使用时需要指定类型参数，如：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">TWeakObjectPtr&lt;ClassName&gt; tw<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>局部的UObject类对象</strong></p><p>有时我们可能在函数中定义一个局部的UObject对象，为了防止对象被UObject的回收机制回收，我们应当使用<font color="red">AddToRoot()</font>来锁定对象，用完后使用<font color="red">RemoveFromRoot()</font>来移除锁定。</p><p><strong>不继承自UObject和UStruct的结构体和类</strong></p><p>这种结构体我们使用<font color="red">TSharedPtr</font>指针来引用堆区的对象，TSharedPtr也是一个泛型指针，使用时也需要指定类型参数。</p><p>如果我们想要使用引用而不是指针则使用TSharedRef，如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">TSharedRef<span class="hljs-tag">&lt;<span class="hljs-name">FMyCustom</span>&gt;</span> MyCustom = MakeShared<span class="hljs-tag">&lt;<span class="hljs-name">FMyCustom</span>&gt;</span>(); <br></code></pre></td></tr></table></figure><p>此时M有Custom就是<code>MakeShared&lt;FMyCustom&gt;()</code>返回对象的引用。</p><p>我们也可以使用<font color="red">TWeakPtr</font>指针，TWeakPtr指针的效果和TWeakObjectPtr指针的效果是一致的，只是TweakPtr用于非UObject类对象。</p><p><strong>当一个不继承自UObject的结构体中出现了UObject对象时</strong></p><p>这种情况下，结构体可以正常访问，但是结构体里的UObject对象会由于UObject的回收机制，在过一段时间后被销毁，从而导致这个对象无法访问和出现野指针的情况，UE4则使用<font color="red">FGCObject</font>类来解决这种情况，我们只需让这种情况下的结构体继承自FGCObject类积即可。</p><h1 id="十二、线程"><a href="#十二、线程" class="headerlink" title="十二、线程"></a>十二、线程</h1><p>由于不同的平台线程的调度有所差异，所以和UE4的其他模块一样，为了实现跨平台的特性，UE4为线程封装了<code>FRunnable</code>框架，并把线程封装进了<code>FRunnableThread</code>类，FRunnableThread类也提供一系列我们对线程的常规操作，所以我们要开启一个自己的线程就需要一个继承FRunnable类并重载相应的函数，然后通过FRunnableThread::Create在FRunnable的框架内完成线程的创建。</p><p>FRunnable和FRunnableThread的关系，这里盗用一张<a href="https://zhuanlan.zhihu.com/p/38881269">Jerish</a>大佬的图来说明：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002336.jpg"></p><h2 id="1-FRunnable和FRunnableThread"><a href="#1-FRunnable和FRunnableThread" class="headerlink" title="1.FRunnable和FRunnableThread"></a>1.FRunnable和FRunnableThread</h2><p>FRunnbale是不对编辑器暴露的，所以我们无法直接从编辑器创建一个继承自FRunnable的类，因为我们需要自己创建一个C++类然后手动继承FRunnable类。</p><p>FRunnable是一个抽象类，其中FRunnable::Run()函数是一个纯虚函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;HAL/Runnable.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UE4CPP_API</span> <span class="hljs-title">FMyRunnable</span> :</span> <span class="hljs-keyword">public</span> FRunnable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>FMyRunnable(<span class="hljs-keyword">int</span> InCount);<br>~FMyRunnable();<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> uint32 <span class="hljs-title">Run</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Stop</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Exit</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Create</span><span class="hljs-params">(FString Name)</span></span>;<br><span class="hljs-keyword">public</span>:<br>FRunnableThread* RunnableThread;<br><span class="hljs-keyword">int</span> Count;<br>FString ThreadName;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>这里要使用FRunnable需要包含<code>HAL/Runnable.h</code>头文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;FMyRunnable.h&quot;</span></span><br>FMyRunnable::FMyRunnable(<span class="hljs-keyword">int</span> InCount):Count(InCount)<br>&#123;<br>&#125;<br>FMyRunnable::~FMyRunnable()<br>&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FMyRunnable::Init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Thread %s inited successfully&quot;</span>),*ThreadName);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">uint32 <span class="hljs-title">FMyRunnable::Run</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Count; i++)<br>    &#123;<br>        UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;i=%d&quot;</span>),i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FMyRunnable::Stop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Stoped thread %s&quot;</span>),*ThreadName);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FMyRunnable::Exit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Exit thread %s&quot;</span>), *ThreadName);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FMyRunnable::Create</span><span class="hljs-params">(FString Name)</span></span><br><span class="hljs-function"></span>&#123;<br>    ThreadName = Name;<br>    RunnableThread = FRunnableThread::Create(<span class="hljs-keyword">this</span>, *Name);<br>    <span class="hljs-keyword">if</span> (RunnableThread)<br>    &#123;<br>        UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Created a thread %s&quot;</span>), *RunnableThread-&gt;GetThreadName());<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Failed to create a thread %s&quot;</span>), *RunnableThread-&gt;GetThreadName());<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后就可以在外部使用这个线程了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AContainerctor::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br>FMyRunnable* MyRunnable = <span class="hljs-keyword">new</span> FMyRunnable(Count);<br>MyRunnable-&gt;Create(TEXT(<span class="hljs-string">&quot;MyFirstThread&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>我这里是直接把线程的操作FRunnableThread也一并封装到FMyRunnbale中了，以方便管理。如果不封装在一起就是这么使用的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AContainerctor::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br>FMyRunnable* MyRunnable = <span class="hljs-keyword">new</span> FMyRunnable(Count);<br>FRunnableThread* RunnableThread = FRunnableThread::Create(MyRunnable,TEXT(<span class="hljs-string">&quot;MyFirstThread&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的化就要管理两个对象，MyRunnable和RunnableThread。</p><ul><li>Init()：在线程被创建后自动调用，会初始化线程的一些数据，比如名字与ID，此时是不可以直接通过FRunnableThread对象去获取线程名字和ID的，否则会导致程序中断；</li><li>Run()：在线程初始化成功后自动调用，我们需要线程干的事情就写在这个函数里；</li><li>Stop()：主动结束线程；</li><li>Exit()：在Run()函数跑完之后自动调用，退出线程。</li></ul><p>FRunnable没有提供挂起线程的函数重写，如果需要挂起线程的操作，则需要我们主动调用<code>FRunnableThread::Suspend( bool bShouldPause = true )</code>函数，bShouldPause=true表示挂起，bShouldPause=false表示恢复。</p><p>这里在测试时碰到一个坑，即按照源码的说明Run函数是只在Init函数初始化成功之后才会调用，而事实情况则是Run函数与Init函数存在并行的情况，我在Run函数中调用线程挂起时，如果不做延迟处理会出现线程不可用的情况而导致程序中断，这说明Run函数运行初期，Init函数还未完成。</p><p><strong>正常情况：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">uint32 <span class="hljs-title">FMyRunnable::Run</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Count; i++)<br>    &#123;<br>        UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;i=%d&quot;</span>),i);<br>        FPlatformProcess::Sleep(<span class="hljs-number">1.0f</span>);<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">5</span>)<br>        &#123;<br>            RunnableThread-&gt;Suspend(<span class="hljs-literal">true</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>中断情况：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">uint32 <span class="hljs-title">FMyRunnable::Run</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Count; i++)<br>    &#123;<br>        UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;i=%d&quot;</span>),i);<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">5</span>)<br>        &#123;<br>            RunnableThread-&gt;Suspend(<span class="hljs-literal">true</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-FAsyncTask和FAutoDeleteAsyncTask"><a href="#2-FAsyncTask和FAutoDeleteAsyncTask" class="headerlink" title="2.FAsyncTask和FAutoDeleteAsyncTask"></a>2.FAsyncTask和FAutoDeleteAsyncTask</h2><p>FAsyncTask是UE使用FRunnable实现的，基于线程池的一套异步任务处理系统，经过封装的FAsyncTask在使用上就比FRunnable要方便得多了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Async/AsyncWork.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CoreMinimal.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UE4CPP_API</span> <span class="hljs-title">FMyAsyncTask</span> :</span> <span class="hljs-keyword">public</span> FNonAbandonableTask<br>&#123;<br><span class="hljs-keyword">public</span>:<br>FMyAsyncTask()&#123;&#125;;<br>~FMyAsyncTask()&#123;&#125;;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FAsyncTask</span>&lt;</span>FMyAsyncTask&gt;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoWork</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)<br>    &#123;<br>        UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Doing work,i=%d&quot;</span>), i);<br>        FPlatformProcess::Sleep(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><span class="hljs-function">FORCEINLINE TStatId <span class="hljs-title">GetStatId</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function"></span>&#123;<br>    RETURN_QUICK_DECLARE_CYCLE_STAT(FMyAsyncTask, STATGROUP_ThreadPoolAsyncTasks);<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里声明的友元类<code>friend class FAsyncTask&lt;FMyAsyncTask&gt;</code>，目的就是让我们的自定义类可以访问FAsyncTask类的成员。</p><p><code>DoWork</code>和<code>TStatId</code>是两个必须实现的函数，DoWork负责任务要实现的逻辑，GetStatId是给UE底层使用的，用于统计任务用时，所以实现上基本是固定的。</p><p><code>FNonAbandonableTask</code>是一个空类，应该是UE为了实现多态而使用的，而要继承这个类则需要包含头文件<code>#include &quot;Async/AsyncWork.h&quot;</code>。</p><p>创建好类之后就可以使用了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//.h</span><br>FAsyncTask&lt;FMyAsyncTask&gt;* MyTask;<br><span class="hljs-comment">//...</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AContainerctor::CreateThread</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>MyTask = <span class="hljs-keyword">new</span> FAsyncTask&lt;FMyAsyncTask&gt;();<br>UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Created MyTask&quot;</span>));<br>MyTask-&gt;StartBackgroundTask();<br>    <span class="hljs-comment">//MyTask-&gt;EnsureCompletion();</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AContainerctor::Tick</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (MyTask &amp;&amp; MyTask-&gt;IsDone())<br>&#123;<br><span class="hljs-keyword">delete</span> MyTask;<br>MyTask = <span class="hljs-literal">nullptr</span>;<br>UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Completed MyTask&quot;</span>));<br>&#125;<br>Super::Tick(DeltaTime);<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是我们自定的FMyAsyncTask类必须以<code>FAsyncTask&lt;FMyAsyncTask&gt;</code>类型来接收和创建，如上面的代码所示，否则我们的FMyAsyncTask类对象就不能访问FAsyncTask类的成员了。</p><p>还有一点因为FAsyncTask是需要手动销毁的，所以我们需要自行判断任务是否完成，UE提供了<code>FAsyncTask::EnsureCompletion</code>函数等待任务完成后再执行后续代码，但这会阻塞当前执行的线程，所以我上面使用了在Tick函数中判断的方式来销毁MyTask。</p><p>正式因为这样，UE又提供了<code>FAutoDeleteAsyncTask</code>类，FAutoDeleteAsyncTask提供任务完成后自动销毁的能力，DoWork函数退出后会自动调用析构函数析构对象。</p><p>实现上FAutoDeleteAsyncTask和FAsyncTask基本没什么区别，只是将友元类从FAsyncTask换成了FAutoDeleteAsyncTask。</p><p>FAsyncTask和FAutoDeleteAsyncTask有两种启动任务的方式即<code>StartSynchronousTask</code>和<code>StartBackgroundTask</code>，前者是在当前线程启动任务，这会导致当前线程阻塞，后者是将任务丢入UE预制的线程池，从线程池中获取线程执行任务。</p><h2 id="3-线程池"><a href="#3-线程池" class="headerlink" title="3.线程池"></a>3.线程池</h2><p>前面一节我们有提到过UE的预制线程池，这个线程池是在引擎与初始化时的<code>FEngineLoop::PreInit</code>函数中的<code>PreInitPreStartupScreen</code>函数创建的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">int32 <span class="hljs-title">FEngineLoop::PreInit</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* CmdLine)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">const</span> int32 rv1 = PreInitPreStartupScreen(CmdLine);<br><span class="hljs-keyword">if</span> (rv1 != <span class="hljs-number">0</span>)<br>&#123;<br>PreInitContext.Cleanup();<br><span class="hljs-keyword">return</span> rv1;<br>&#125;<br><br><span class="hljs-keyword">const</span> int32 rv2 = PreInitPostStartupScreen(CmdLine);<br><span class="hljs-keyword">if</span> (rv2 != <span class="hljs-number">0</span>)<br>&#123;<br>PreInitContext.Cleanup();<br><span class="hljs-keyword">return</span> rv2;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//FEngineLoop::PreInitPostStartupScreen</span><br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">if</span> (FPlatformProcess::SupportsMultithreading())<br>&#123;<br>&#123;<br>SCOPED_BOOT_TIMING(<span class="hljs-string">&quot;GIOThreadPool-&gt;Create&quot;</span>);<br>GIOThreadPool = FQueuedThreadPool::Allocate();<br>int32 NumThreadsInThreadPool = FPlatformMisc::NumberOfIOWorkerThreadsToSpawn();<br><span class="hljs-keyword">if</span> (FPlatformProperties::IsServerOnly())<br>&#123;<br>NumThreadsInThreadPool = <span class="hljs-number">2</span>;<br>&#125;<br>verify(GIOThreadPool-&gt;Create(NumThreadsInThreadPool, <span class="hljs-number">96</span> * <span class="hljs-number">1024</span>, TPri_AboveNormal, TEXT(<span class="hljs-string">&quot;IOThreadPool&quot;</span>)));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>UE预制的线程是FQueuedThread类型的线程对象，FQueuedThread也是继承自FRunnable的子类，而FQueuedThread被存储在一个FQueuedThreadPool维护的队列里，说是队列其实在源码里就是一个FQueuedThread类型的TArray。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FQueuedThreadPoolBase</span> :</span> <span class="hljs-keyword">public</span> FQueuedThreadPool<br>&#123;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-comment">//...</span><br><span class="hljs-comment">/** The thread pool to dole work out to. */</span><br>TArray&lt;FQueuedThread*&gt; QueuedThreads;<br><span class="hljs-comment">//...</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>FQueuedThread里面会维护一个FEvent事件，用于任务的事件触发和线程控制。</p><p><font color="red">预制的线程池被UE保存在一个GThreadPool指针中，和GEngine一样GThreadPool也是一个全局指针。</font></p><p>FAysncTask和FAutoDeleteAsyncTask的StartBackgroundTask函数默认情况下就是使用的线程池里的线程，当然我们也可以传自定义的线程进去，让任务使用自定义线程执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//AsyncWork.h</span><br><span class="hljs-comment">/** </span><br><span class="hljs-comment">* Run this task on the lo priority thread pool. It is not safe to use this object after this call.</span><br><span class="hljs-comment">**/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StartBackgroundTask</span><span class="hljs-params">(FQueuedThreadPool* InQueuedPool = GThreadPool)</span></span><br><span class="hljs-function"></span>&#123;<br>Start(<span class="hljs-literal">false</span>, InQueuedPool);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="创建自定义线程池"><a href="#创建自定义线程池" class="headerlink" title="创建自定义线程池"></a>创建自定义线程池</h3><p>创建自定的线程池其实也比较简单，使用的方式就是和UE预制线程池是一样的。</p><p>首先我们需要创建自己的任务对象—一个实现了IQueuedWork的类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Misc/IQueuedWork.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UE4CPP_API</span> <span class="hljs-title">FMyWorker</span> :</span> <span class="hljs-keyword">public</span> IQueuedWork<br>&#123;<br><span class="hljs-keyword">public</span>:<br>FMyWorker(FString Name):WorkName(Name)&#123;&#125;<br>~FMyWorker()&#123;&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoThreadedWork</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>    UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Doing work %s&quot;</span>), *WorkName);<br>    FPlatformProcess::Sleep(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Abandon</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">        </span>&#123;<br>    UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Abandoned work %s&quot;</span>), *WorkName);<br>    <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>FString WorkName;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里有两个函数是必须重写的，<code>DoThreadedWork</code>和<code>Abandon</code>，DoThreadedWork会在任务对象加入线程池之后自动调用，用于处理自己的任务逻辑；Abandon则是放弃当前任务。</p><p>创建好了任务我们就可以创建线程池了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AContainerctor::CreateThread</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>FQueuedThreadPool* Pool = FQueuedThreadPool::Allocate();<br>Pool-&gt;Create(<span class="hljs-number">5</span>, <span class="hljs-number">12</span> * <span class="hljs-number">1024</span>, TPri_Normal, TEXT(<span class="hljs-string">&quot;MyThreadPool&quot;</span>));<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)<br>&#123;<br>FString WorkName = TEXT(<span class="hljs-string">&quot;MyWork&quot;</span>) + FString::FromInt(i);<br>Pool-&gt;AddQueuedWork(<span class="hljs-keyword">new</span> FMyWorker(WorkName));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>FQueuedThreadPool::Allocate()</code>创建线程池对象，<code>Create</code>函数往线程池中加入线程，5为线程数量，12*1024为线程大小，TPri_Normal为线程类型，最后的字符串为线程名字。<code>AddQueuedWork</code>将任务对象加入线程池，任务即可开始执行。</p><h2 id="4-线程锁"><a href="#4-线程锁" class="headerlink" title="4.线程锁"></a>4.线程锁</h2><p>提到线程就一定逃避不了锁，为了保证线程安全锁是必要的，UE也提供了自己的一套锁机制，UE提供四种线程锁：</p><ul><li>FScopeLock：区域锁；</li><li>FCriticalSection：临界区；</li><li>FScopeRWLock：读写锁。</li><li>FSystemWideCriticalSection</li></ul><p>我们一个个来看。</p><h3 id="FScopeLock"><a href="#FScopeLock" class="headerlink" title="FScopeLock"></a>FScopeLock</h3><p>我们先来看看没有锁的情况以便和有锁的情况做对比。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UE4CPP_API</span> <span class="hljs-title">FMyRunnable</span> :</span> <span class="hljs-keyword">public</span> FRunnable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>FMyRunnable(<span class="hljs-keyword">int</span> InCount);<br>~FMyRunnable();<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> uint32 <span class="hljs-title">Run</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Stop</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Exit</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Create</span><span class="hljs-params">(FString Name)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ChangeCount</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//供外部修改Count值</span><br><span class="hljs-keyword">public</span>:<br>FRunnableThread* RunnableThread;<br><span class="hljs-keyword">int</span> Count;<span class="hljs-comment">//Count值在Run运行时不应该被修改</span><br>FString ThreadName;<br>FCriticalSection CountLock;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">uint32 <span class="hljs-title">FMyRunnable::Run</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Count; i++)<br>    &#123;<br>        UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;i=%d&quot;</span>), i);<br>        FPlatformProcess::Sleep(<span class="hljs-number">0.001f</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FMyRunnable::ChangeCount</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Count += <span class="hljs-number">5</span>;<br>    UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Set Count=%d&quot;</span>), Count);<br>&#125;<br></code></pre></td></tr></table></figure><p>线程外部：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AContainerctor::CreateThread</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>MyRunnable = <span class="hljs-keyword">new</span> FMyRunnable(<span class="hljs-number">1000</span>);<br>MyRunnable-&gt;Create(TEXT(<span class="hljs-string">&quot;MyRunnable&quot;</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AContainerctor::ChangeValue</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>MyRunnable-&gt;ChangeCount();<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在蓝图中通过按键触发CreateThread和ChangeCount函数，然后跑一下看看</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002351.png"></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002354.png"></p><p>可以看到在Run运行的过程中我们修改了Count的值到505，而线程结束时Count的值确实被修改了，这个结果明显不是我们先要的。</p><p>下面来使用锁对比效果。</p><p>FScopeLock和FCriticalSection是一起使用的，ScopeLock的使用方法有两种：</p><p><strong>方法一</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//.h</span><br>FCriticalSection CountLock;<br><span class="hljs-comment">//.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FMyRunnable::Run</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>&#123;<br>        <span class="hljs-function">FScopeLock <span class="hljs-title">ScopeLock</span><span class="hljs-params">(&amp;CountLock)</span></span>;<span class="hljs-comment">//对ScopeLock所在的作用域中的变量上锁</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Count; i++)<br>    &#123;<br>        UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;i=%d&quot;</span>), i);<br>        FPlatformProcess::Sleep(<span class="hljs-number">0.001f</span>);<br>    &#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FMyRunnable::ChangeCount</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">FScopeLock <span class="hljs-title">ScopeLock</span><span class="hljs-params">(&amp;CountLock)</span></span>;<br>    Count += <span class="hljs-number">5</span>;<br>    UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Set Count=%d&quot;</span>), Count);<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="red">需要注意的是这种方法需要在读和写的地方都要上锁，ScopeLock会把作用域中使用的外部变量都锁住，即使有的变量没有在写的时候上锁</font>，我们把上面的例子改一下，上个锁再看一下。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002357.png"></p><p>可以看到，Count的值是在线程退出之后才被设置到505</p><p><strong>方法二</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FMyRunnable::Run</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>FScopeLock* ScopeLock = <span class="hljs-keyword">new</span> FScopeLock(&amp;CountLock);<span class="hljs-comment">//上锁</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Count; i++)<br>    &#123;<br>        UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;i=%d&quot;</span>), i);<br>        FPlatformProcess::Sleep(<span class="hljs-number">0.001f</span>);<br>    &#125;<br><span class="hljs-keyword">delete</span> ScopeLock;<span class="hljs-comment">//解锁</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FMyRunnable::ChangeCount</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    FScopeLock* ScopeLock = <span class="hljs-keyword">new</span> FScopeLock(&amp;CountLock);<span class="hljs-comment">//上锁</span><br>    Count += <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">delete</span> ScopeLock;<span class="hljs-comment">//解锁</span><br>&#125;<br></code></pre></td></tr></table></figure><p>和方法一一样，方法二也需要在读写的地方都要上锁。</p><p>在实际测试中发现ScopeLock似乎有一个bug，即当在ScopeLock的作用域中存在多个变量，有的需要上锁而有的不需要上锁时，会因为修改的时序导致结果有所差异，举个例子：</p><p>我们在上面的例子中在增加一个变量Num。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UE4CPP_API</span> <span class="hljs-title">FMyRunnable</span> :</span> <span class="hljs-keyword">public</span> FRunnable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>FMyRunnable(<span class="hljs-keyword">int</span> InCount);<br>~FMyRunnable();<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> uint32 <span class="hljs-title">Run</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Stop</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Exit</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Create</span><span class="hljs-params">(FString Name)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ChangeCount</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ChangeNum</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">public</span>:<br>FRunnableThread* RunnableThread;<br><span class="hljs-keyword">int</span> Count;<br><span class="hljs-keyword">int</span> Num = <span class="hljs-number">10</span>;<br>FString ThreadName;<br>FCriticalSection CountLock;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">uint32 <span class="hljs-title">FMyRunnable::Run</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    FScopeLock* ScopeLock = <span class="hljs-keyword">new</span> FScopeLock(&amp;CountLock);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Count; i++)<br>    &#123;<br>        UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;i=%d&quot;</span>), i);<br>        FPlatformProcess::Sleep(<span class="hljs-number">0.001f</span>);<br>    &#125;<br>    UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Num=%d&quot;</span>), Num);<br>    <span class="hljs-keyword">delete</span> ScopeLock;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FMyRunnable::ChangeCount</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    FScopeLock* ScopeLock = <span class="hljs-keyword">new</span> FScopeLock(&amp;CountLock);<br>    Count += <span class="hljs-number">5</span>;<br>    UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Set Count=%d&quot;</span>), Count);<br>    <span class="hljs-keyword">delete</span> ScopeLock;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FMyRunnable::ChangeNum</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Num += <span class="hljs-number">10</span>;<br>    UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Set Num=%d&quot;</span>), Num);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果ChangeNum在ChangeCount之前调用那么在Run的运行期间，Num值会被修改，如果ChangeNum在ChangeCount之后调用，那么Num值会被锁住只能在线程结束后才会被修改。</p><p>还是一样我们来运行下看看。</p><p>情况一ChangeNum在ChangeCount之前运行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AContainerctor::CreateThread</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>MyRunnable = <span class="hljs-keyword">new</span> FMyRunnable(Count);<br>MyRunnable-&gt;Create(TEXT(<span class="hljs-string">&quot;MyRunnable&quot;</span>));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AContainerctor::ChangeValue</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    MyRunnable-&gt;ChangeNum();<br>MyRunnable-&gt;ChangeCount();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002403.png"></p><p>可以看到Num的值在线程结束前已经被修改了。</p><p>情况二ChangeNum在ChangeCount之后运行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AContainerctor::CreateThread</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>MyRunnable = <span class="hljs-keyword">new</span> FMyRunnable(Count);<br>MyRunnable-&gt;Create(TEXT(<span class="hljs-string">&quot;MyRunnable&quot;</span>));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AContainerctor::ChangeValue</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>MyRunnable-&gt;ChangeCount();<br>MyRunnable-&gt;ChangeNum();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002408.png"></p><p>可以看到Num值被锁住了，在线程结束之后才被设置到20。</p><h3 id="FCriticalSection"><a href="#FCriticalSection" class="headerlink" title="FCriticalSection"></a>FCriticalSection</h3><p>FCriticalSection除了配合FScopeLock使用，自己单独也可以当作锁来用，用法上和FScopeLock的方法二类似。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++">FCriticalSection CountLock;<br><br><span class="hljs-function">uint32 <span class="hljs-title">FMyRunnable::Run</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    CountLock.Lock();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Count; i++)<br>    &#123;<br>        UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;i=%d&quot;</span>), i);<br>        FPlatformProcess::Sleep(<span class="hljs-number">0.001f</span>);<br>    &#125;<br>    CountLock.Unlock();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FMyRunnable::ChangeCount</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    CountLock.Lock();<br>    Count += <span class="hljs-number">5</span>;<br>    UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Set Count=%d&quot;</span>), Count);<br>    CountLock.Unlock();<br>&#125;<br></code></pre></td></tr></table></figure><p>和FScopeLock一样，当锁的代码段出现了多个变量有的值需要保持不变而有的值需要改变时，FCriticalSection会出现和FScopeLock一样的问题。</p><h3 id="FScopeRWLock"><a href="#FScopeRWLock" class="headerlink" title="FScopeRWLock"></a>FScopeRWLock</h3><p>关于FScopeRWLock我在内外网几乎没有找到任何代码示例，官方文档的描述甚至只有短短的一句话，在内网中几乎找不到FScopeRWLock相关的关键字，只在一些博客里有看到FRWLock，而这个类我在引擎源码里搜索发现这只是一个类别名，写在各个平台相关的文件里，在源码里只找到了一个FScopeRWLock类，类也比较简单，具体怎么用只能等日后有时间再自己摸索了。</p><h3 id="FSystemWideCriticalSection"><a href="#FSystemWideCriticalSection" class="headerlink" title="FSystemWideCriticalSection"></a>FSystemWideCriticalSection</h3><p>FSystemWideCriticalSection和FCriticalSection的用法是一样的，他们的区别只在于FCriticalSection是用户模式下的临界区，线程进入临界区时不需要从用户态切换到内核态，所以效率上比FSystemWideCriticalSection高，但是也是由于没有进入内核态所以无法进行进程之间的同步，只能用于线程；FSystemWideCriticalSection则是基于内核对象Mutex实现的，线程进入临界区是会从用户态切换进入内核态，所以效率上不如FCriticalSection，但是可以进行线程进程的同步。</p><h2 id="5-TGraphTask"><a href="#5-TGraphTask" class="headerlink" title="5.TGraphTask"></a>5.TGraphTask</h2><p>TGraphTask是UE4基于多线程抽象出来的一个异步任务处理系统，一整个任务由一个个任务节点组成，个节点之间可以进行单向的依赖，用一张图来说明可能会更形象。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002413.png"></p><p>我们以这个流程来做一个计算加速度的例子<code>(v2-v1)/t</code>来说明TaskGraph的用法。用任务1计算v1，任务2计算v2，用任务3来计算v2-v1，用任务4来计算加速度。</p><h3 id="创建自定义FGraphTask"><a href="#创建自定义FGraphTask" class="headerlink" title="创建自定义FGraphTask"></a>创建自定义FGraphTask</h3><p>和FRunnable一样，我们也需要创建一个C++类来实现自己的TGraphTask，这里我创建四个任务节点，FGraphTask1、FGraphTask2、FGraphTask3、FGraphTask4，和一个UObject—UDataObj用于在各个任务节点间传递数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;../Common/DataObj.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UE4CPP_API</span> <span class="hljs-title">FGraphTask1</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>FGraphTask1(FString Name,UDataObj* Obj) : TaskName(Name),DataObj(Obj) &#123;&#125;<br>~FGraphTask1() &#123;&#125;;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">FORCEINLINE TStatId <span class="hljs-title">GetStatId</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function"></span>&#123;<br>RETURN_QUICK_DECLARE_CYCLE_STAT(FMyTaskGraph, STATGROUP_TaskGraphTasks);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> ENamedThreads::Type <span class="hljs-title">GetDesiredThread</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> ENamedThreads::AnyThread;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> ESubsequentsMode::Type <span class="hljs-title">GetSubsequentsMode</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> ESubsequentsMode::TrackSubsequents;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoTask</span><span class="hljs-params">(ENamedThreads::Type CurrentThread, <span class="hljs-keyword">const</span> FGraphEventRef&amp; MyCompletionGraphEvent)</span></span><br><span class="hljs-function"></span>&#123;<br>UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Doing %s&quot;</span>), *TaskName);<br>FPlatformProcess::Sleep(<span class="hljs-number">3</span>);<br>DataObj-&gt;V1 = <span class="hljs-number">15</span>;<br>UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Done %s and setted V1=%f&quot;</span>), *TaskName,DataObj-&gt;V1);<br>&#125;<br><span class="hljs-keyword">private</span>:<br>FString TaskName;<br>UDataObj* DataObj;<br>&#125;;<br></code></pre></td></tr></table></figure><p>剩下的三个任务节点实现方式都一样样，只是DoTask函数体有所区别。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FGraphTask2::DoTask</span><span class="hljs-params">(ENamedThreads::Type CurrentThread, <span class="hljs-keyword">const</span> FGraphEventRef&amp; MyCompletionGraphEvent)</span></span><br><span class="hljs-function"></span>&#123;<br>UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Doing %s&quot;</span>), *TaskName);<br>FPlatformProcess::Sleep(<span class="hljs-number">3</span>);<br>DataObj-&gt;V2 = <span class="hljs-number">25</span>;<br>UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Done %s and setted V2=%f&quot;</span>), *TaskName, DataObj-&gt;V2);<br>&#125;<br><span class="hljs-comment">//------------------------</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FGraphTask3::DoTask</span><span class="hljs-params">(ENamedThreads::Type CurrentThread, <span class="hljs-keyword">const</span> FGraphEventRef&amp; MyCompletionGraphEvent)</span></span><br><span class="hljs-function"></span>&#123;<br>UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Doing %s&quot;</span>), *TaskName);<br>FPlatformProcess::Sleep(<span class="hljs-number">3</span>);<br>DataObj-&gt;Difference = DataObj-&gt;V2 - DataObj-&gt;V1;<br>UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Done %s and setted Difference=%f&quot;</span>), *TaskName, DataObj-&gt;Difference);<br>&#125;<br><span class="hljs-comment">//------------------------</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FGraphTask4::DoTask</span><span class="hljs-params">(ENamedThreads::Type CurrentThread, <span class="hljs-keyword">const</span> FGraphEventRef&amp; MyCompletionGraphEvent)</span></span><br><span class="hljs-function"></span>&#123;<br>UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Doing %s&quot;</span>), *TaskName);<br>FPlatformProcess::Sleep(<span class="hljs-number">3</span>);<br>DataObj-&gt;A = DataObj-&gt;Difference/DataObj-&gt;T;<br>UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Done %s and setted A=%f&quot;</span>), *TaskName, DataObj-&gt;A);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>GetStatId</code>，<code>GetDesiredThread</code>，<code>GetSubsequentsMode</code>，<code>DoTask</code>这四个函数是必须要实现的。</p><ul><li>GetStatId用于统计任务用时；</li><li>GetDesiredThread函数用于告诉系统这个任务使用什么类型的线程执行，有4种类型可选，ENamedThreads::AnyThread，ENamedThreads::GameThread，ENamedThreads::RHIThread，ENamedThreads::AudioThread，一般我们都使用AnyThread表示使用UE4专门为TGraphTask系统预制的线程；</li><li>GetSubsequentsMode函数用于告诉系统当前任务完成后的后续执行模式，因为一个任务节点完成后可以接下一个任务节点，有两种模式ESubsequentsMode::TrackSubsequents后续有任务，ESubsequentsMode::FireAndForget后续无任务，我这里的例子中只有任务4没有后续任务。</li><li>DoTask函数用于处理自己的任务逻辑。</li></ul><p>UDataObj就只用来传递数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UE4CPP_API</span> <span class="hljs-title">UDataObj</span> :</span> <span class="hljs-keyword">public</span> UObject<br>&#123;<br>GENERATED_BODY()<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">float</span> V1;<br><span class="hljs-keyword">float</span> V2;<br><span class="hljs-keyword">float</span> A;<br><span class="hljs-keyword">float</span> T = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">float</span> Difference;<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后创建任务节点并处理各个任务节点之间的依赖关系：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AContainerctor::CreateTask</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>FGraphEventRef Task1, Task2, Task3, Task4;<br>UDataObj* DataObj = NewObject&lt;UDataObj&gt;();<br>Task1 = TGraphTask&lt;FGraphTask1&gt;::CreateTask().ConstructAndDispatchWhenReady(TEXT(<span class="hljs-string">&quot;Task1&quot;</span>), DataObj);<br>Task2 = TGraphTask&lt;FGraphTask2&gt;::CreateTask().ConstructAndDispatchWhenReady(TEXT(<span class="hljs-string">&quot;Task2&quot;</span>), DataObj);<br>FGraphEventArray Prerequistites3;<br>Prerequistites3.Add(Task1);<br>Prerequistites3.Add(Task2);<br>Task3 = TGraphTask&lt;FGraphTask3&gt;::CreateTask(&amp;Prerequistites3).ConstructAndDispatchWhenReady(TEXT(<span class="hljs-string">&quot;Task3&quot;</span>), DataObj);<br>FGraphEventArray Prerequistites4;<br>Prerequistites4.Add(Task3);<br>Task4 = TGraphTask&lt;FGraphTask4&gt;::CreateTask(&amp;Prerequistites4).ConstructAndDispatchWhenReady(TEXT(<span class="hljs-string">&quot;Task4&quot;</span>), DataObj);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>CreateTask函数有两个参数<code>CreateTask(const FGraphEventArray* Prerequisites = NULL, ENamedThreads::Type CurrentThreadIfKnown = ENamedThreads::AnyThread)</code>，第一个参数传入这个任务要依赖的其他任务的数组，第二个参数指定这个任务跑在什么类型的线程里。</li><li>ConstructAndDispatchWhenReady函数在创建任务后会立刻执行任务里的DoTask函数，并且使用C++11的构造函数传参的特性，可以将参数传递给对应的类的构造函数中。</li><li>FGraphEventArray类是UE封装的专门用于装载依赖任务的数组。</li></ul><p>然后我们执行一下看看结果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002420.png"></p><h3 id="不使用自定义FGraphTask的TGraphTask任务"><a href="#不使用自定义FGraphTask的TGraphTask任务" class="headerlink" title="不使用自定义FGraphTask的TGraphTask任务"></a>不使用自定义FGraphTask的TGraphTask任务</h3><p>UE除了使用自定义的FGraphTask来执行任务外还提供一个使用Lambda表达式来执行任务的方式，我们直接先看一个例子，把上面的任务流程用新的方式在处理一遍：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AContainerctor::CreateTask</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>FGraphEventRef Task1, Task2, Task3, Task4;<br>Task1 = FFunctionGraphTask::CreateAndDispatchWhenReady([]()-&gt;<span class="hljs-keyword">void</span> &#123;<br>UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Doing Task1&quot;</span>));<br>FPlatformProcess::Sleep(<span class="hljs-number">3</span>);<br>&#125;);<br>Task2 = FFunctionGraphTask::CreateAndDispatchWhenReady([]()-&gt;<span class="hljs-keyword">void</span> &#123;<br>UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Doing Task2&quot;</span>));<br>FPlatformProcess::Sleep(<span class="hljs-number">3</span>);<br>&#125;);<br>FGraphEventArray Prerequistites3;<br>Prerequistites3.Add(Task1);<br>Prerequistites3.Add(Task2);<br>Task3 = FFunctionGraphTask::CreateAndDispatchWhenReady([]()-&gt;<span class="hljs-keyword">void</span> &#123;<br>UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Doing Task3&quot;</span>));<br>FPlatformProcess::Sleep(<span class="hljs-number">3</span>);<br>&#125;, TStatId&#123;&#125;, &amp; Prerequistites3);<br>FGraphEventArray Prerequistites4;<br>Prerequistites4.Add(Task3);<br>Task3 = FFunctionGraphTask::CreateAndDispatchWhenReady([]()-&gt;<span class="hljs-keyword">void</span> &#123;<br>UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Doing Task4&quot;</span>));<br>FPlatformProcess::Sleep(<span class="hljs-number">3</span>);<br>&#125;, TStatId&#123;&#125;, &amp; Prerequistites4);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>DoTask的逻辑就写在了Lambda表达式里了；</li><li>按照源码的注释说明，CreateAndDispatchWhenReady接收的Lambda表达式必须是<code>void()</code> 或者 <code>void(ENamedThreads::Type, const FGraphEventRef&amp;)</code>类型的，所以不可以传外部参数进入Lambda表达式，所以这种方式创建的任务流只能处理一些不依赖外部数据的简单任务。</li></ul><h2 id="6-游戏线程"><a href="#6-游戏线程" class="headerlink" title="6.游戏线程"></a>6.游戏线程</h2><p>前面有提到UE中的一些预制线程，包括线程池中的线程，TGraphTask中的线程，还有GameThread、RenderThread、RHIThread、AudioThread等，这里面用的最多就是GameThread了，所以我们主要讨论一下GameThread。</p><p>GameThread顾名思义就是用于承载游戏逻辑的线程，UE在创建了GameThread后会把线程ID存储到GGameThreadId这个全局变量中。</p><p>有一些事情是只能在GameThread中做的，比如创建UObject，AActor，Widget等，所有的BeginPlay函数，Tick函数都跑在GameThread中，所有的蓝图函数也都跑在GameThread中。</p><h1 id="十三、模块"><a href="#十三、模块" class="headerlink" title="十三、模块"></a>十三、模块</h1><p>模块可以说是贯穿了整个引擎，整个UE引擎就是又一个个模块组合而成的，我们打开引擎源码的Source文件夹就可以看到如下文件夹：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002425.png"></p><ul><li>Developer：存放跨平台工具以及一些引擎底层工具；</li><li>Editor：存放编辑器代码；</li><li>Programs：存放依赖于引擎的工具，如：UBT等；</li><li>Runtime：存放GamePlay相关的代码；</li><li>ThirdParty：存放第三方库和插件。</li></ul><h2 id="1-模块的描述"><a href="#1-模块的描述" class="headerlink" title="1.模块的描述"></a>1.模块的描述</h2><p>一个模块可以只由一个模块组成，也可也由多个模块组成，我们使用UE创建一个新项目的时候，这整个项目就是一个独立的模块，UE会默认为我们添加一些基础模块的引用，操作代码在.biuld.cs中，模块与模块之间可以互相引用，但是不可以出现循环引用。</p><p>模块的描述在.uproject文件中，如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br><span class="hljs-attr">&quot;FileVersion&quot;</span>: <span class="hljs-number">3</span>,<br><span class="hljs-attr">&quot;EngineAssociation&quot;</span>: <span class="hljs-string">&quot;4.27&quot;</span>,<br><span class="hljs-attr">&quot;Category&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br><span class="hljs-attr">&quot;Description&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br><span class="hljs-attr">&quot;Modules&quot;</span>: [<br>&#123;<br><span class="hljs-attr">&quot;Name&quot;</span>: <span class="hljs-string">&quot;UE4Cpp&quot;</span>,<br><span class="hljs-attr">&quot;Type&quot;</span>: <span class="hljs-string">&quot;Runtime&quot;</span>,<br><span class="hljs-attr">&quot;LoadingPhase&quot;</span>: <span class="hljs-string">&quot;Default&quot;</span>,<br><span class="hljs-attr">&quot;AdditionalDependencies&quot;</span>: [<br><span class="hljs-string">&quot;Engine&quot;</span>,<br><span class="hljs-string">&quot;CoreUObject&quot;</span><br>]<br>&#125;<br>]<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个Json格式的文件，我们主要关注Modules数组里面的元素，一个元素就是一个模块，由于我的项目没有添加其他模块，所以只有一个元素。</p><ul><li><p>Name：模块名；</p></li><li><p>Type：加载模块的场景，是一个EHostType::Type类型，在ModuleDescriptor.h中，主要有以下类型：</p><p>Runtime：除了独立程序以外都加载；</p><p>RuntimeNoCommandlet：除了独立程序和运行命令行模式的编辑器模式以外都加载；</p><p>RuntimeAndProgram：任何情况下都加载；</p><p>CookedOnly：只有被烘焙过的程序才加载；</p><p>Developer：只有在Development运行模式下才加载；这个Development是游戏和编辑器的一种运行模式，除了Development还有GameDebug，打包的时候还有Shipping，编辑器的运行模式我们可以在VS编译的时候选择：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002429.png"></p></li></ul><p>  Editor：只在编辑器启动的时候加载；</p><p>  EditorNoCommandlet：只在编辑器启动的时候加载，但不包括使用命令行启动的编辑器；</p><p>  Program：只在独立程序中加载；</p><p>  ServerOnly：除了专用客户端，其他情况都加载；</p><p>  ClientOnly：除了专用服务器，其他情况都加载；</p><ul><li><p>LoadingPhase：标注模块应该被加载的时机，是一个ELoadingPhase::Type的类型，也在在ModuleDescriptor.h中，主要有如下类型：</p><p>EarliestPossible：尽早的被加载，一般用于Pak文件中有模块的情况，可以是模块从Pak文件中加载；</p><p>PostConfigInit：在引擎被完全初始化之前，在配置文件系统被初始化之后加载，一般用于拦截底层消息是使用；</p><p>PreEarlyLoadingScreen：在加载CoreUObject之前加载，可以设置手动加载屏幕，一般用于程序补丁；</p><p>PreLoadingScreen：在引擎完全初始化之前加载，一般用于需要触发之前挂接到加载屏幕的模块；</p><p>PreDefault：在默认阶段之前加载；</p><p>Default：在引擎初始化之前，在游戏 模块被加载之后加载，创建项目是引擎给的默认值，也是我们用的最多的加载时机。</p><p>PostDefault：在默认阶段之后加载；</p><p>PostEngineInit：在引擎被初始化之后加载；</p><p>None：不自动加载模块，引擎不会自动加载模块，需要我们自己手动的在程序里加载模块。</p></li><li><p>AdditionalDependencies：描述用于构建此模块的其他依赖项的列表。</p></li></ul><h2 id="2-创建自定义模块"><a href="#2-创建自定义模块" class="headerlink" title="2.创建自定义模块"></a>2.创建自定义模块</h2><p>创建自定义模块需要三个基础文件，并且需要单独的放在项目Source目录下的一个文件夹下。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002434.png"></p><p>这三个基础文件引擎不会自动为我们生成，我们需要手动添加进去，并且需要手动实现里面的内容。</p><p><strong>.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CoreMinimal.h&quot;</span></span><br></code></pre></td></tr></table></figure><p><strong>.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;MyModule.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Modules/ModuleManager.h&quot;</span></span><br><br>IMPLEMENT_PRIMARY_GAME_MODULE(FDefaultGameModuleImpl, MyModule, <span class="hljs-string">&quot;MyModule&quot;</span>);<br></code></pre></td></tr></table></figure><p>这是最简单的.h和.cpp文件。</p><p><strong>.Build.cs</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnrealBuildTool;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyModule</span> : <span class="hljs-title">ModuleRules</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyModule</span>(<span class="hljs-params">ReadOnlyTargetRules Target</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">Target</span>)</span><br><span class="hljs-function"></span>&#123;<br>PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;<br>PublicDependencyModuleNames.AddRange(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123; <span class="hljs-string">&quot;Core&quot;</span>, <span class="hljs-string">&quot;CoreUObject&quot;</span>, <span class="hljs-string">&quot;Engine&quot;</span>, <span class="hljs-string">&quot;InputCore&quot;</span> &#125;);<br>PrivateDependencyModuleNames.AddRange(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123; &#125;);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后右键.uproject文件，重新Generate Visual Studio project file，这样VS就可以识别到我们新添加的文件夹和文件了。</p><p>到这一步我们的空的自定义模块就创建完成了。</p><h2 id="3-加载自定义模块"><a href="#3-加载自定义模块" class="headerlink" title="3.加载自定义模块"></a>3.加载自定义模块</h2><h3 id="引擎自动加载"><a href="#引擎自动加载" class="headerlink" title="引擎自动加载"></a>引擎自动加载</h3><p>修改项目的XX.Target.cs、XXEditor.Target.cs和.uproject文件，将我们新建的模块添加到项目中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//XX.Target.cs</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UE4CppTarget</span> :</span> TargetRules<br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UE4CppTarget</span><span class="hljs-params">(TargetInfo Target)</span> : <span class="hljs-title">base</span><span class="hljs-params">(Target)</span></span><br><span class="hljs-function"></span>&#123;<br>Type = TargetType.Game;<br>DefaultBuildSettings = BuildSettingsVersion.V2;<br><br>ExtraModuleNames.AddRange( <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123; <span class="hljs-string">&quot;UE4Cpp&quot;</span>, <span class="hljs-string">&quot;MyModule&quot;</span> &#125; );<br>&#125;<br>&#125;<br><span class="hljs-comment">//XXEditor.Target.cs</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UE4CppEditorTarget</span> :</span> TargetRules<br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UE4CppEditorTarget</span><span class="hljs-params">(TargetInfo Target)</span> : <span class="hljs-title">base</span><span class="hljs-params">(Target)</span></span><br><span class="hljs-function"></span>&#123;<br>Type = TargetType.Editor;<br>DefaultBuildSettings = BuildSettingsVersion.V2;<br><br>ExtraModuleNames.AddRange( <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123; <span class="hljs-string">&quot;UE4Cpp&quot;</span>,<span class="hljs-string">&quot;MyModule&quot;</span>&#125; );<br>&#125;<br>&#125;<br><span class="hljs-comment">//.uproject</span><br>&#123;<br><span class="hljs-string">&quot;FileVersion&quot;</span>: <span class="hljs-number">3</span>,<br><span class="hljs-string">&quot;EngineAssociation&quot;</span>: <span class="hljs-string">&quot;4.27&quot;</span>,<br><span class="hljs-string">&quot;Category&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br><span class="hljs-string">&quot;Description&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br><span class="hljs-string">&quot;Modules&quot;</span>: [<br>&#123;<br><span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;UE4Cpp&quot;</span>,<br><span class="hljs-string">&quot;Type&quot;</span>: <span class="hljs-string">&quot;Runtime&quot;</span>,<br><span class="hljs-string">&quot;LoadingPhase&quot;</span>: <span class="hljs-string">&quot;Default&quot;</span>,<br><span class="hljs-string">&quot;AdditionalDependencies&quot;</span>: [<br><span class="hljs-string">&quot;Engine&quot;</span>,<br><span class="hljs-string">&quot;CoreUObject&quot;</span><br>]<br>&#125;,<br>&#123;<br><span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;MyModule&quot;</span>,<br><span class="hljs-string">&quot;Type&quot;</span>: <span class="hljs-string">&quot;Runtime&quot;</span>,<br><span class="hljs-string">&quot;LoadingPhase&quot;</span>: <span class="hljs-string">&quot;Default&quot;</span>,<br><span class="hljs-string">&quot;AdditionalDependencies&quot;</span>: [<br><span class="hljs-string">&quot;Engine&quot;</span>,<br><span class="hljs-string">&quot;CoreUObject&quot;</span><br>]<br>&#125;<br>]<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们重新编译下项目，模块就会按照.uproject中的配置进行加载。</p><p>如何查看引擎有没有识别到模块呢？</p><p>打开引擎新建C++类的界面，如果下拉列表中出现了我们的自定义模块名称，就说明自定义模块被引擎识别了。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002440.png"></p><p>注意我这里用的是识别而不是加载，因为引擎识别到模块和引擎加载模块是两个不同的概念，引擎识别到模块，我就可以在引擎中往模块里添加新的类，但此时模块不一定已经加载了；而引擎加载模块即引擎识别到了模块并将模块初始化完成了。</p><p>那么如何查看模块有没有被引擎自动加载了呢？</p><p>这里我们就需要在模块的.h文件中实现一个<code>IModuleInterface</code>接口了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Modules/ModuleManager.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FMyModule</span> :</span> <span class="hljs-keyword">public</span> IModuleInterface<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StartupModule</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ShutdownModule</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br><span class="hljs-comment">//.cpp</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;MyModule.h&quot;</span></span><br>IMPLEMENT_PRIMARY_GAME_MODULE(FMyModule, MyModule, <span class="hljs-string">&quot;MyModule&quot;</span>);<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FMyModule::StartupModule</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    UE_LOG(LogTemp, Error, TEXT(<span class="hljs-string">&quot;Loaded MyModule&quot;</span>));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FMyModule::ShutdownModule</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>IModuleInterface在ModuleManager.h中，IModuleInterface提供如下接口：</p><ul><li>StartupModule：在模块被加载后调用；</li><li>ShutdownModule：在模块被卸载之前调用；</li><li>PreUnloadCallback：在模块被卸载之前调用，调用时机在ShutdownModule之前；</li><li>PostLoadCallback：在模块被重新加载后调用；</li><li>SupportsDynamicReloading：设置模块是否允许动态卸载，默认为允许；</li><li>SupportsAutomaticShutdown：设置模块是否允许在程序关闭时自动卸载清理，默认为允许；</li><li>IsGameModule：表示模块是否属于GamePlay，默认为false，如果模块要实现游戏逻辑，那么需要重写这个函数放回true；</li></ul><p>同时IMPLEMENT_PRIMARY_GAME_MODULE宏就不能使用默认的<code>FDefaultGameModuleImpl</code>类了，需要使用自己实现的<code>FMyModule</code>类了，FDefaultGameModuleImpl类是一个UE预制的继承自IModuleInterface的空类，IModuleInterface接口就是模块暴露给外部使用的指针，外部要获取模块的引用可以通过FModuleManager.Get().GetModule或者在动态加载时直接保存引用。</p><p>实现了上面的操作后，在模块加载时即可在日志文件中找到对应的日志打印了。</p><h3 id="代码手动加载"><a href="#代码手动加载" class="headerlink" title="代码手动加载"></a>代码手动加载</h3><p>前有提到模块可以被引擎自动加载，也可以通过代码手动加载，UE提供一下四种方式来动态加载模块：</p><ul><li>FModuleManager::Get().LoadModule：加载指定模块，返回操作模块的IModuleInterface指针；</li><li>FModuleManager::Get().LoadModuleChecked：加载指定模块，在加载前会检查模块是否可用，返回操作模块的IModuleInterface指针；</li><li>FModuleManager::Get().LoadModuleWithCallback：加载指定模块，可以使用FOutputDevice接收加载失败的错误信息，如果加载成功则会调用模块的PostLoadCallback函数；</li><li>FModuleManager::Get().LoadModuleWithFailureReason：加载指定模块，并且可以使用EModuleLoadResult对象接收加载信息。</li></ul><h2 id="4-引用模块的资源"><a href="#4-引用模块的资源" class="headerlink" title="4.引用模块的资源"></a>4.引用模块的资源</h2><p>前面有提到一个模块可以引用另一个模块里的资源，其实引用的方式也比较简单，对于模块资源的引用是无论模块有没有加载都是可以引用的，加载不过是为模块做一些初始化操作。</p><p>这里我在主模块中引用自定义模块的类资源。</p><p>往前面定义的MyModule模块中添加一个AMyModuleActor类，然后在主模块UE4Cpp中引用这个类的头文件并实力化Actor。</p><p>首先需要通过.Build.cs添加MyModule模块的引用：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">PublicDependencyModuleNames.AddRange(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123; <span class="hljs-string">&quot;Core&quot;</span>, <span class="hljs-string">&quot;CoreUObject&quot;</span>, <span class="hljs-string">&quot;Engine&quot;</span>, <span class="hljs-string">&quot;InputCore&quot;</span>,<span class="hljs-string">&quot;MyModule&quot;</span>&#125;);<br></code></pre></td></tr></table></figure><p>然后就可以在想要引用资源的地方添加头文件使用类资源了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;../MyModule/MyModuleActor.h&quot;</span></span><br><span class="hljs-comment">//...</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AContainerctor::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br>AMyModuleActor* Actor = GWorld-&gt;SpawnActor&lt;AMyModuleActor&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><p>运行下看看结果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002447.png"></p><p>可以看到AMyModuleActor已经被实例化出来了。</p><h2 id="5-模块的构建"><a href="#5-模块的构建" class="headerlink" title="5.模块的构建"></a>5.模块的构建</h2><p>在模块的构建过程中有下面三个宏是需要注意的：</p><ul><li>IMPLEMENT_MODULE(FModuleClass, ModuleName)：一般没有什么特殊的模块都使用这个宏；</li><li>IMPLEMENT_GAME_MODULE(FModuleClass, ModuleName)：如果模块有包含游戏逻辑，那么就使用这个宏，看了源码这个宏就是对IMPLEMENT_MODULE宏的调用，二者没有任何区别，应该是UE预留的宏；</li><li>IMPLEMENT_PRIMARY_GAME_MODULE(FModuleClass, ModuleName,”GameName”)：如果模块是项目的主模块就是用这个宏，一个项目中必须要至少有一个主模块。</li></ul><p>这三个宏做的事情就是向外部提供模块的IModuleInterface接口，并将模块构成静态库或者动态库，默认情况下都构建成动态库，存放在Binaries目录对应平台名目录下。</p><h2 id="6-模块打包的问题"><a href="#6-模块打包的问题" class="headerlink" title="6.模块打包的问题"></a>6.模块打包的问题</h2><p>由于要验证第五小节模块的构建，所以需要将引用了自定义模块的项目打包，但是打包的出现了很严重的问题，即引用了自定义模块资源的项目打包始终无法通过，无论使用原有的项目还是新建项目，无论是使用原有的模块还是新建新的模块，只要主项目使用了模块的资源，打包的时候都会报错：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">UATHelper: Packaging (Windows (<span class="hljs-number">64</span>-bit)):     <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AModule</span>.</span></span>cpp.obj : error LNK2005: <span class="hljs-string">&quot;wchar_t const * const GLiveCodingEngineDir&quot;</span> (?GLiveCodingEngineDir@@<span class="hljs-number">3</span>PEB_WEB) �Ѿ��� <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ModulePackage</span>.</span></span>cpp.obj �ж���<br>UATHelper: Packaging (Windows (<span class="hljs-number">64</span>-bit)):     <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AModule</span>.</span></span>cpp.obj : error LNK2005: <span class="hljs-string">&quot;wchar_t const * const GLiveCodingProject&quot;</span> (?GLiveCodingProject@@<span class="hljs-number">3</span>PEB_WEB) �Ѿ��� <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ModulePackage</span>.</span></span>cpp.obj �ж���<br>UATHelper: Packaging (Windows (<span class="hljs-number">64</span>-bit)):     <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AModule</span>.</span></span>cpp.obj : error LNK2005: <span class="hljs-string">&quot;class FChunkedFixedUObjectArray * &amp; GObjectArrayForDebugVisualizers&quot;</span> (?GObjectArrayForDebugVisualizers@@<span class="hljs-number">3</span>AEAPEAVFChunkedFixedUObjectArray@@EA) �Ѿ��� <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ModulePackage</span>.</span></span>cpp.obj �ж���<br>UATHelper: Packaging (Windows (<span class="hljs-number">64</span>-bit)):     <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AModule</span>.</span></span>cpp.obj : error LNK2005: <span class="hljs-string">&quot;wchar_t * GInternalProjectName&quot;</span> (?GInternalProjectName@@<span class="hljs-number">3</span>PA_WA) �Ѿ��� <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ModulePackage</span>.</span></span>cpp.obj �ж���<br>UATHelper: Packaging (Windows (<span class="hljs-number">64</span>-bit)):     <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AModule</span>.</span></span>cpp.obj : error LNK2005: <span class="hljs-string">&quot;wchar_t const * const GForeignEngineDir&quot;</span> (?GForeignEngineDir@@<span class="hljs-number">3</span>PEB_WEB) �Ѿ��� <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ModulePackage</span>.</span></span>cpp.obj �ж���<br>UATHelper: Packaging (Windows (<span class="hljs-number">64</span>-bit)):     <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AModule</span>.</span></span>cpp.obj : error LNK2005: <span class="hljs-string">&quot;void * __cdecl operator new(unsigned __int64)&quot;</span> (??<span class="hljs-number">2</span>@YAPEAX_K@Z) �Ѿ��� <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ModulePackage</span>.</span></span>cpp.obj �ж���<br>UATHelper: Packaging (Windows (<span class="hljs-number">64</span>-bit)):     <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AModule</span>.</span></span>cpp.obj : error LNK2005: <span class="hljs-string">&quot;void * __cdecl operator new(unsigned __int64,struct std::nothrow_t const &amp;)&quot;</span> (??<span class="hljs-number">2</span>@YAPEAX_KAEBUnothrow_t@std@@@Z) �Ѿ��� <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ModulePackage</span>.</span></span>cpp.obj �ж���<br>UATHelper: Packaging (Windows (<span class="hljs-number">64</span>-bit)):     <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AModule</span>.</span></span>cpp.obj : error LNK2005: <span class="hljs-string">&quot;void __cdecl operator delete(void *)&quot;</span> (??<span class="hljs-number">3</span>@YAXPEAX@Z) �Ѿ��� <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ModulePackage</span>.</span></span>cpp.obj �ж���<br>UATHelper: Packaging (Windows (<span class="hljs-number">64</span>-bit)):     <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AModule</span>.</span></span>cpp.obj : error LNK2005: <span class="hljs-string">&quot;void __cdecl operator delete(void *,struct std::nothrow_t const &amp;)&quot;</span> (??<span class="hljs-number">3</span>@YAXPEAXAEBUnothrow_t@std@@@Z) �Ѿ��� <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ModulePackage</span>.</span></span>cpp.obj �ж���<br>UATHelper: Packaging (Windows (<span class="hljs-number">64</span>-bit)):     <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AModule</span>.</span></span>cpp.obj : error LNK2005: <span class="hljs-string">&quot;void __cdecl operator delete(void *,unsigned __int64)&quot;</span> (??<span class="hljs-number">3</span>@YAXPEAX_K@Z) �Ѿ��� <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ModulePackage</span>.</span></span>cpp.obj �ж���<br>UATHelper: Packaging (Windows (<span class="hljs-number">64</span>-bit)):     <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AModule</span>.</span></span>cpp.obj : error LNK2005: <span class="hljs-string">&quot;void __cdecl operator delete(void *,unsigned __int64,struct std::nothrow_t const &amp;)&quot;</span> (??<span class="hljs-number">3</span>@YAXPEAX_KAEBUnothrow_t@std@@@Z) �Ѿ��� <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ModulePackage</span>.</span></span>cpp.obj �ж���<br>UATHelper: Packaging (Windows (<span class="hljs-number">64</span>-bit)):     <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AModule</span>.</span></span>cpp.obj : error LNK2005: <span class="hljs-string">&quot;void * __cdecl operator new[](unsigned __int64)&quot;</span> (??_U@YAPEAX_K@Z) �Ѿ��� <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ModulePackage</span>.</span></span>cpp.obj �ж���<br>UATHelper: Packaging (Windows (<span class="hljs-number">64</span>-bit)):     <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AModule</span>.</span></span>cpp.obj : error LNK2005: <span class="hljs-string">&quot;void * __cdecl operator new[](unsigned __int64,struct std::nothrow_t const &amp;)&quot;</span> (??_U@YAPEAX_KAEBUnothrow_t@std@@@Z) �Ѿ��� <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ModulePackage</span>.</span></span>cpp.obj �ж���<br>UATHelper: Packaging (Windows (<span class="hljs-number">64</span>-bit)):     <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AModule</span>.</span></span>cpp.obj : error LNK2005: <span class="hljs-string">&quot;void __cdecl operator delete[](void *)&quot;</span> (??_V@YAXPEAX@Z) �Ѿ��� <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ModulePackage</span>.</span></span>cpp.obj �ж���<br>UATHelper: Packaging (Windows (<span class="hljs-number">64</span>-bit)):     <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AModule</span>.</span></span>cpp.obj : error LNK2005: <span class="hljs-string">&quot;void __cdecl operator delete[](void *,struct std::nothrow_t const &amp;)&quot;</span> (??_V@YAXPEAXAEBUnothrow_t@std@@@Z) �Ѿ��� <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ModulePackage</span>.</span></span>cpp.obj �ж���<br>UATHelper: Packaging (Windows (<span class="hljs-number">64</span>-bit)):     <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AModule</span>.</span></span>cpp.obj : error LNK2005: <span class="hljs-string">&quot;void __cdecl operator delete[](void *,unsigned __int64)&quot;</span> (??_V@YAXPEAX_K@Z) �Ѿ��� <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ModulePackage</span>.</span></span>cpp.obj �ж���<br>UATHelper: Packaging (Windows (<span class="hljs-number">64</span>-bit)):     <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AModule</span>.</span></span>cpp.obj : error LNK2005: <span class="hljs-string">&quot;void __cdecl operator delete[](void *,unsigned __int64,struct std::nothrow_t const &amp;)&quot;</span> (??_V@YAXPEAX_KAEBUnothrow_t@std@@@Z) �Ѿ��� <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ModulePackage</span>.</span></span>cpp.obj �ж���<br>UATHelper: Packaging (Windows (<span class="hljs-number">64</span>-bit)):     <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AModule</span>.</span></span>cpp.obj : error LNK2005: <span class="hljs-string">&quot;struct FTargetNameRegistration GTargetNameRegistration&quot;</span> (?GTargetNameRegistration@@<span class="hljs-number">3</span>UFTargetNameRegistration@@A) �Ѿ��� <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ModulePackage</span>.</span></span>cpp.obj �ж���<br>UATHelper: Packaging (Windows (<span class="hljs-number">64</span>-bit)):     <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AModule</span>.</span></span>cpp.obj : error LNK2005: <span class="hljs-string">&quot;unsigned char * * GNameBlocksDebug&quot;</span> (?GNameBlocksDebug@@<span class="hljs-number">3</span>PEAPEAEEA) �Ѿ��� <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ModulePackage</span>.</span></span>cpp.obj �ж���<br>UATHelper: Packaging (Windows (<span class="hljs-number">64</span>-bit)):       ���ڴ����� D:\Codes\UE4\ModulePackage\Binaries\Win64\<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ModulePackage</span>.</span></span>lib �Ͷ��� D:\Codes\UE4\ModulePackage\Binaries\Win64\<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ModulePackage</span>.</span></span>exp<br>UATHelper: Packaging (Windows (<span class="hljs-number">64</span>-bit)):     D:\Codes\UE4\ModulePackage\Binaries\Win64\<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ModulePackage</span>.</span></span>exe : fatal error LNK1169: �ҵ�һ���������ض���ķ���<br>LogSlate: Took <span class="hljs-number">0.021891</span> seconds <span class="hljs-keyword">to</span> synchronously load lazily loaded font &#x27;../../../Engine/Content/Slate/Fonts/NotoNaskhArabicUI-<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Regular</span>.</span></span>ttf&#x27; (<span class="hljs-number">144</span>K)<br>LogSlate: Last resort fallback font was requested. Font: &#x27;../../../Engine/Content/Slate/Fonts/<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DroidSansFallback</span>.</span></span>ttf&#x27;, Character: &#x27;Ͷ (U+<span class="hljs-number">0376</span>)&#x27;<br>LogSlate: Took <span class="hljs-number">0.075434</span> seconds <span class="hljs-keyword">to</span> synchronously load lazily loaded font &#x27;../../../Engine/Content/SlateDebug/Fonts/<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LastResort</span>.</span></span>ttf&#x27; (<span class="hljs-number">5269</span>K)<br>UATHelper: Packaging (Windows (<span class="hljs-number">64</span>-bit)): Took <span class="hljs-number">153.3858471</span>s <span class="hljs-keyword">to</span> run <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UnrealBuildTool</span>.</span></span>exe, ExitCode=<span class="hljs-number">6</span><br>UATHelper: Packaging (Windows (<span class="hljs-number">64</span>-bit)): UnrealBuildTool failed. See log <span class="hljs-keyword">for</span> more details. (C:\Users\Goulandis\AppData\Roaming\Unreal Engine\AutomationTool\Logs\D+UE_4.<span class="hljs-number">27</span>\UBT-ModulePackage-Win64-<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Development</span>.</span></span>txt)<br>UATHelper: Packaging (Windows (<span class="hljs-number">64</span>-bit)): AutomationTool exiting <span class="hljs-keyword">with</span> ExitCode=<span class="hljs-number">6</span> (<span class="hljs-number">6</span>)<br>UATHelper: Packaging (Windows (<span class="hljs-number">64</span>-bit)): BUILD FAILED<br>PackagingResults: Error: Unknown Error<br></code></pre></td></tr></table></figure><p>error LNK2005的原因是说有重定义，但是新建的类就是一个空类始终无法想明白是什么原因导致的，无论是使用自定的Actor还是自定义的C++类都一样。</p><p>而网上关于自定义模块的打包的资料基本没有我在内外网搜索都翻个7-8页基本挨边的资料都找不到，唉，这就是UE最痛苦的地方。</p><p>在测试的过程中还碰到另一个问题，就是往自定义模块添加类的时候，引擎添加新类会出现中断，这个情况下去引用模块的Actor类资源会出现.generated.h文件打不开，导致VS编译始终报错，具体原因也不明，不知道为什么编辑器向自定义模块添加新类会出现中断，也不知道为什么.generated.h文件命名存在VS就是打不开，即使把目录包含到项目属性的VC++目录也一样。</p><h1 id="十四、引用第三方库"><a href="#十四、引用第三方库" class="headerlink" title="十四、引用第三方库"></a>十四、引用第三方库</h1><p>第三方库份两种，一种是动态库(dll)一种是静态库(lib)，想找一个简单的库来做测试最好的方式还是自己创建一个，我就创建一个计算圆面积的库。</p><h2 id="1-创建Lib库"><a href="#1-创建Lib库" class="headerlink" title="1.创建Lib库"></a>1.创建Lib库</h2><p>使用VS新建一个空项目，往项目中添加四个文件，Mian.cpp，Area.h，Area.cpp，Source.def</p><ul><li><p>Main.cpp：是用来放main函数，我自己操作的时候没有main函数会报无法解析外部符号的错误，不过在网上看别人制作库的时候却并没有添加main函数，可能是使用C++版本或是VS版本不同的原因吧；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Area.h：声明方法的头文件，也是提供给外部调用时include的头文件；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Area</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">float</span> <span class="hljs-title">GetArea</span><span class="hljs-params">(<span class="hljs-keyword">float</span> R)</span></span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>这里将方法封装在了一个类，当然我们也可以不用类来封装，而是直接写文件里作为全局函数来使用。</p></li><li><p>Area.cpp：实现方法的Cpp；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Area.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">Area::GetArea</span><span class="hljs-params">(<span class="hljs-keyword">float</span> R)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3.14</span>*<span class="hljs-built_in">pow</span>(R,<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Source.def：是在<code>右键项目-&gt;添加-&gt;添加新项-&gt;代码-&gt;模块定义文件</code>中添加的，用来描述库需要导出的内容，这是因为一个项目要导出库不是所有内容都要导出的，.def文件就给予我们导出的灵活性。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002455.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs def">LIBRARY CircleArea<br>EXPORTS<br>GetArea<br></code></pre></td></tr></table></figure><p>至于.def的具体语法在这里不是重点，就没有深入去研究了。</p></li></ul><p>然后将项目改成x64平台，因为UE的项目默认都是x64的，如果平台不一致，库将没有办法在UE中使用。</p><p>然后将<code>项目属性/配置属性/常规/配置类型</code>改为静态库。</p><p>然后生成项目，我们就可以在<code>项目目录/x64/Debug/</code>下看到我们的lib库了。</p><h2 id="2-添加Lib库"><a href="#2-添加Lib库" class="headerlink" title="2.添加Lib库"></a>2.添加Lib库</h2><p>第三方库UE有专门的文件夹放置—<code>项目目录/Source/ThirdParty</code>，ThirdParty文件夹还有include，lib两个文件夹，include放置第三方库的头文件，lib放置地方库的lib文件。</p><p>我们将上面制作出来的CircleArea库用到的头文件放入include中，将lib文件放库lib中。</p><p>然后编辑项目.Build.cs文件，哪个模块需要使用第三方库就编辑哪个模块的.Build.cs。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> UnrealBuildTool;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.IO;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UE4Cpp</span> : <span class="hljs-title">ModuleRules</span><br>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> ModulePath<br>    &#123;<br><span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> ModuleDirectory; &#125;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> ThirdPartyPath<br>&#123;<br><span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> Path.GetFullPath(Path.Combine(ModulePath, <span class="hljs-string">&quot;../ThirdParty&quot;</span>)); &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UE4Cpp</span>(<span class="hljs-params">ReadOnlyTargetRules Target</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">Target</span>)</span><br><span class="hljs-function"></span>&#123;<br>PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;<br>PublicDependencyModuleNames.AddRange(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123; <span class="hljs-string">&quot;Core&quot;</span>, <span class="hljs-string">&quot;CoreUObject&quot;</span>, <span class="hljs-string">&quot;Engine&quot;</span>, <span class="hljs-string">&quot;InputCore&quot;</span>,<span class="hljs-string">&quot;AModule&quot;</span>&#125;);<br>PrivateDependencyModuleNames.AddRange(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123;  &#125;);<br>PublicIncludePaths.Add(Path.Combine(ThirdPartyPath, <span class="hljs-string">&quot;include&quot;</span>));<br>PublicAdditionalLibraries.Add(Path.Combine(ThirdPartyPath, <span class="hljs-string">&quot;lib&quot;</span>, <span class="hljs-string">&quot;CircleArea.lib&quot;</span>));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在类里我对ModuleDirectory进行了封装，因为VS对UBT的支持还不是很好，很多UE提供的函数或变量VS是没有提示的，为了方便使用所以进行一次封装，同时也把ThirdParty文件路径也封装了。</p><p>在PublicIncludePaths中添加头文件的路径，在PublicAdditionalLibraries中添加lib库的路径，如此我们的库就添加进UE4中了</p><h2 id="3-使用Lib库"><a href="#3-使用Lib库" class="headerlink" title="3.使用Lib库"></a>3.使用Lib库</h2><p>使用Lib库的方法就比较简单了，直接在要使用的地方include头文件，然后就可以使用库里的类和方法了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;../ThirdParty/include/Area.h&quot;</span></span><br><span class="hljs-comment">//...</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AContainerctor::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br><span class="hljs-keyword">float</span> Area = Area::GetArea(<span class="hljs-number">10</span>);<br>UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Area=%f&quot;</span>), Area);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002503.png"></p><h2 id="4-创建Dll库"><a href="#4-创建Dll库" class="headerlink" title="4.创建Dll库"></a>4.创建Dll库</h2><p>创建动态库的方法和静态库一样，只是把配置类型改为动态库，然后生成，就可以在<code>x64/Debug/</code>目录下看到生成的.dll文件和.lib文件。</p><h2 id="5-添加Dll库"><a href="#5-添加Dll库" class="headerlink" title="5.添加Dll库"></a>5.添加Dll库</h2><p>添加动态库的方式有两种，其一：</p><p>在.Build.cs文件中添加。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnrealBuildTool;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.IO;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UE4Cpp</span> : <span class="hljs-title">ModuleRules</span><br>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> ModulePath<br>    &#123;<br><span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> ModuleDirectory; &#125;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> ThirdPartyPath<br>&#123;<br><span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> Path.GetFullPath(Path.Combine(ModulePath, <span class="hljs-string">&quot;../ThirdParty&quot;</span>)); &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UE4Cpp</span>(<span class="hljs-params">ReadOnlyTargetRules Target</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">Target</span>)</span><br><span class="hljs-function"></span>&#123;<br>PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;<br>PublicDependencyModuleNames.AddRange(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123; <span class="hljs-string">&quot;Core&quot;</span>, <span class="hljs-string">&quot;CoreUObject&quot;</span>, <span class="hljs-string">&quot;Engine&quot;</span>, <span class="hljs-string">&quot;InputCore&quot;</span>,<span class="hljs-string">&quot;AModule&quot;</span>&#125;);    PublicDelayLoadDLLs.Add(Path.Combine(ThirdPartyPath,<span class="hljs-string">&quot;dll&quot;</span>,<span class="hljs-string">&quot;CircleArea.dll&quot;</span>));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方式又引擎自动管理动态库的添加时机，在使用时要提前将动态库目录加入搜索列表，否则UE将找不到动态库。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">FPlatformProcess::PushDllDirectory(*(FPaths::GameSourceDir() / TEXT(<span class="hljs-string">&quot;ThirdParty/dll&quot;</span>)));<br></code></pre></td></tr></table></figure><p>其二就是在使用的时候直接使用绝对路径加载，详细可以直接看下一节的代码。</p><h2 id="6-使用Dll库"><a href="#6-使用Dll库" class="headerlink" title="6.使用Dll库"></a>6.使用Dll库</h2><p>如果使用第5节提到的第一种方法添加的动态库就这么使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">float</span><span class="hljs-params">(*_GetArea)</span><span class="hljs-params">(<span class="hljs-keyword">float</span> R)</span></span>;<br><span class="hljs-comment">//..</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AContainerctor::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br>FPlatformProcess::PushDllDirectory(*(FPaths::GameSourceDir() / TEXT(<span class="hljs-string">&quot;ThirdParty/dll&quot;</span>)));<br><span class="hljs-keyword">void</span>* DllHandle = FPlatformProcess::GetDllHandle(TEXT(<span class="hljs-string">&quot;CircleArea.dll&quot;</span>));<br><span class="hljs-keyword">if</span> (DllHandle)<br>&#123;<br>_GetArea DllGetArea = (_GetArea)FPlatformProcess::GetDllExport(DllHandle, TEXT(<span class="hljs-string">&quot;GetArea&quot;</span>));<br><span class="hljs-keyword">if</span> (DllGetArea)<br>&#123;<br><span class="hljs-keyword">float</span> Area = DllGetArea(<span class="hljs-number">10</span>);<br>UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Area=%f&quot;</span>), Area);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果使用的是第二种方法就这么使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">float</span><span class="hljs-params">(*_GetArea)</span><span class="hljs-params">(<span class="hljs-keyword">float</span> R)</span></span>;<br><span class="hljs-comment">//...</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AContainerctor::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br>FString DllPath = FPaths::Combine(*FPaths::GameSourceDir(), TEXT(<span class="hljs-string">&quot;ThirdParty/dll&quot;</span>), TEXT(<span class="hljs-string">&quot;CircleArea.dll&quot;</span>));<br><span class="hljs-keyword">if</span> (FPaths::FileExists(DllPath))<br>&#123;<br><span class="hljs-keyword">void</span>* DllHandle = FPlatformProcess::GetDllHandle(*DllPath);<br><span class="hljs-keyword">if</span> (DllHandle)<br>&#123;<br>_GetArea DllGetArea = (_GetArea)FPlatformProcess::GetDllExport(DllHandle, TEXT(<span class="hljs-string">&quot;GetArea&quot;</span>));<br><span class="hljs-keyword">if</span> (DllGetArea)<br>&#123;<br><span class="hljs-keyword">float</span> Area = DllGetArea(<span class="hljs-number">10</span>);<br>UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Area=%f&quot;</span>), Area);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>typedef float(*_GetArea)(float R)</code>：这是定义了一个函数指针<code>_GetArea</code>，函数接收一个float类型参数，返回一个float类型的值，和dll中的GetArea函数对应。</li><li>FPlatformProcess::GetDllHandle：获取Dll的引用；</li><li>(_GetArea)FPlatformProcess::GetDllExport：通过名字获取Dll中的对应函数入口，并强转成我们定义的函数指针类型，因为函数指针的类型是我们根据Dll中对应函数来定义的，所以一般强转都是可以成功的；</li><li>DllGetArea(10)：通过函数指针来调用Dll中的函数。</li></ul><h2 id="7-碰到的问题"><a href="#7-碰到的问题" class="headerlink" title="7.碰到的问题"></a>7.碰到的问题</h2><p>在试验的过程中碰到两个问题。</p><p>其一就是如果一个动态库里有两个不同的类但是两个类都拥有一个同名的函数，我们在调用的的时候应该如何区分呢？这是看到UE是通过函数名来获取Dll中的函数想到的问题，这个其实对于使用者来说不需要考虑，因为Dll在导出的时候就要求了不能有同名函数，否则编译会报错。</p><p>其二就是我在网上查到的所有的使用Dll的文件基本都是告诉我们怎么去使用Dll中的函数，没有一篇是将怎么去使用Dll中的类的，有在C++中使用的方法，不过直接搬到UE4中似乎并不适用。</p><h1 id="十五、断言"><a href="#十五、断言" class="headerlink" title="十五、断言"></a>十五、断言</h1><p>断言是UE4程序中的一种代码检查机制，有时我们在执行一段代码时，有些值是要确保一定存在的，不存在程序将不能在往下执行直接中断，断言就被用来处理这个问题的，断言是一种来调试代码的工具，断言不会被编译进要发布的代码中，所以断言不会影响Shipping版本。</p><p>断言判断的内容必须为true，否则将执行中断。</p><p>断言的定义在AssertionMacros.h文件中，断言分三类，check、verify和ensure。</p><h2 id="1-Check类型断言"><a href="#1-Check类型断言" class="headerlink" title="1.Check类型断言"></a>1.Check类型断言</h2><h3 id="check-expr"><a href="#check-expr" class="headerlink" title="check(expr)"></a>check(expr)</h3><p>expr为false直接中断程序，可以在Debug、Development、Shipping的Editor版本中运行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AContainerctor::CheckTest</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>check(Count == <span class="hljs-number">1</span>);<br>UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Count=%d&quot;</span>),Count);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="checkSlow-expr"><a href="#checkSlow-expr" class="headerlink" title="checkSlow(expr)"></a>checkSlow(expr)</h3><p>expr为false直接中断程序，只能在Debug版本中运行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AContainerctor::CheckTest</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>checkSlow(Count == <span class="hljs-number">1</span>);<br>UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Count=%d&quot;</span>),Count);<br>&#125;<br></code></pre></td></tr></table></figure><p>按照官方文档的说明是只能在Debug版本中运行，但是我在实际调试中发现，checkSlow似乎在任何情况下都没有运行，于是我打开Build.h看了一下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> UE_BUILD_DEBUG</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> DO_GUARD_SLOW</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DO_GUARD_SLOW1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> DO_CHECK</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DO_CHECK1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> DO_ENSURE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DO_ENSURE1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> STATS</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STATS((WITH_UNREAL_DEVELOPER_TOOLS || !WITH_EDITORONLY_DATA || USE_STATS_WITHOUT_ENGINE || USE_MALLOC_PROFILER || FORCE_USE_STATS) &amp;&amp; !ENABLE_STATNAMEDEVENTS)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> ALLOW_DEBUG_FILES</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ALLOW_DEBUG_FILES1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> ALLOW_CONSOLE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ALLOW_CONSOLE1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NO_LOGGING</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NO_LOGGING0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> UE_BUILD_DEVELOPMENT</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> DO_GUARD_SLOW</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DO_GUARD_SLOW0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> DO_CHECK</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DO_CHECK1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> DO_ENSURE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DO_ENSURE1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> STATS</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STATS((WITH_UNREAL_DEVELOPER_TOOLS || !WITH_EDITORONLY_DATA || USE_STATS_WITHOUT_ENGINE || USE_MALLOC_PROFILER || FORCE_USE_STATS) &amp;&amp; !ENABLE_STATNAMEDEVENTS)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> ALLOW_DEBUG_FILES</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ALLOW_DEBUG_FILES1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> ALLOW_CONSOLE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ALLOW_CONSOLE1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NO_LOGGING</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NO_LOGGING0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> UE_BUILD_TEST</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> DO_GUARD_SLOW</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DO_GUARD_SLOW0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> DO_CHECK</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DO_CHECKUSE_CHECKS_IN_SHIPPING</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> DO_ENSURE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DO_ENSUREUSE_ENSURES_IN_SHIPPING</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> STATS</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STATS((USE_MALLOC_PROFILER || FORCE_USE_STATS) &amp;&amp; !ENABLE_STATNAMEDEVENTS)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> ALLOW_DEBUG_FILES</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ALLOW_DEBUG_FILES1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> ALLOW_CONSOLE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ALLOW_CONSOLE1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NO_LOGGING</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NO_LOGGING!USE_LOGGING_IN_SHIPPING</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> UE_BUILD_SHIPPING</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> WITH_EDITOR</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> DO_GUARD_SLOW</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DO_GUARD_SLOW0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> DO_CHECK</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DO_CHECK1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> DO_ENSURE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DO_ENSURE1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> STATS</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STATS1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> ALLOW_DEBUG_FILES</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ALLOW_DEBUG_FILES1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> ALLOW_CONSOLE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ALLOW_CONSOLE0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NO_LOGGING</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NO_LOGGING0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> DO_GUARD_SLOW</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DO_GUARD_SLOW0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> DO_CHECK</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DO_CHECKUSE_CHECKS_IN_SHIPPING</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> DO_ENSURE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DO_ENSUREUSE_ENSURES_IN_SHIPPING</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> STATS</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STATS(FORCE_USE_STATS &amp;&amp; !ENABLE_STATNAMEDEVENTS)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> ALLOW_DEBUG_FILES</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ALLOW_DEBUG_FILES0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> ALLOW_CONSOLE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ALLOW_CONSOLEALLOW_CONSOLE_IN_SHIPPING</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NO_LOGGING</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NO_LOGGING!USE_LOGGING_IN_SHIPPING</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">error</span> Exactly one of [UE_BUILD_DEBUG UE_BUILD_DEVELOPMENT UE_BUILD_TEST UE_BUILD_SHIPPING] should be defined to be 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>确实DO_GUARD_SLOW宏只有在Debug模式下才被置为1其他模式都是0，我把Developer模式下的DO_GUARD_SLOW宏也设置成1，发现checkFlow在Debug模式和Developer模式下都运行了，不知道是不是bug。</p><h3 id="checkf-expr-text"><a href="#checkf-expr-text" class="headerlink" title="checkf(expr,text)"></a>checkf(expr,text)</h3><p>expr为false直接中断程序，并把Text打印到日志，可以在Debug、Development、Shipping Editor版本中运行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AContainerctor::CheckTest</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>checkf(Count == <span class="hljs-number">1</span>,TEXT(<span class="hljs-string">&quot;Count!=1&quot;</span>));<br>UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Count=%d&quot;</span>),Count);<br>&#125;<br></code></pre></td></tr></table></figure><p>关于checkf我们不能使用VS拉起来的引擎测试效果，VS拉起来的引擎会直接在VS中中断，导致错误信息无法打印到日志中。</p><h3 id="checkfSlow-expr-text"><a href="#checkfSlow-expr-text" class="headerlink" title="checkfSlow(expr,text)"></a>checkfSlow(expr,text)</h3><p>checkSlow的checkf版，和checkSlow一样也有bug。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AContainerctor::CheckTest</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>checkfSlow(Count == <span class="hljs-number">1</span>,TEXT(<span class="hljs-string">&quot;Count!=1&quot;</span>));<br>UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Count=%d&quot;</span>),Count);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="checkCode-code"><a href="#checkCode-code" class="headerlink" title="checkCode(code)"></a>checkCode(code)</h3><p>直接执行（）中的代码，实际测试….这他呀的根本不会中断，感觉没什么卵用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AContainerctor::CheckTest</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>checkCode(<br><span class="hljs-keyword">if</span> (Count != <span class="hljs-number">1</span>)<br>&#123;<br>Count = <span class="hljs-number">2</span>;<br>UE_LOG(LogTemp, Error, TEXT(<span class="hljs-string">&quot;Count=%d&quot;</span>), Count);<br>&#125;<br>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="checkNoEntry"><a href="#checkNoEntry" class="headerlink" title="checkNoEntry()"></a>checkNoEntry()</h3><p>如果程序执行了此语句就直接中断,用来截断不能被执行的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AContainerctor::CheckTest</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>checkNoEntry();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="checkNoReentry"><a href="#checkNoReentry" class="headerlink" title="checkNoReentry()"></a>checkNoReentry()</h3><p>如果此语句被执行超过1次，就中断程序，用来标注只能被执行一次的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AContainerctor::CheckTest</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>checkNoReentry();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="checkNoRecusion"><a href="#checkNoRecusion" class="headerlink" title="checkNoRecusion()"></a>checkNoRecusion()</h3><p>判断函数是否递归，如果递归则中断。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AContainerctor::CheckTest</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>checkNoRecursion();<br><span class="hljs-keyword">if</span> (Count == <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;CreateThread();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="unimplemented"><a href="#unimplemented" class="headerlink" title="unimplemented()"></a>unimplemented()</h3><p>如果被执行则中断，效果和checkNoEntry一样，不过主要用于因该被覆盖而不会被调用的虚函数，实则没什么乱用，我不理解不会被调用的函数留着干嘛。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AContainerctor::CheckTest</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>unimplemented();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-Verify类型断言"><a href="#2-Verify类型断言" class="headerlink" title="2.Verify类型断言"></a>2.Verify类型断言</h2><p>Verify类型的断言中表达式会独立于断言运行，就是说无论断言是否生效(DO_CHECK=1断言生效，DO_CHECK=0断言不生效)，代码执行到此语句的时候表达式都会运行，而Check类型的断言则是断言不生效时，表达式就不会执行。</p><p>verify有verify、verifySlow、verifyf、verifyfSlow四种，用法上check一样，当然bug也是一样的。</p><h2 id="3-Ensure类型断言"><a href="#3-Ensure类型断言" class="headerlink" title="3.Ensure类型断言"></a>3.Ensure类型断言</h2><p>ensure类型的断言和verify有点类似，在不出现会导致程序崩溃的错误时(如读取空指针)，ensure都不会中断，程序依然会执行但是ensure会在首次执行时将消息通知给引擎的崩溃报告器。</p><h3 id="ensure-exps"><a href="#ensure-exps" class="headerlink" title="ensure(exps)"></a>ensure(exps)</h3><p>首次执行时将false消息通知到崩溃报告器，不执行中断。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AContainerctor::EnsureTest</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ensure(Count == <span class="hljs-number">1</span>);<br>UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Ensure&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>通过VS拉起的引擎在执行到ensure时会直接在VS中断，所以要验证效果的话，引擎不能通过VS拉起。</p><p>执行了ensure程序不会中断后面的代码依然执行，并且会在首次执行时将错误报告打印在日志。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Warning:</span> Script Stack (<span class="hljs-number">2</span> frames):<br>Untitled_C.ExecuteUbergraph_Untitled<br>Untitled_C.InpActEvt_Three_K2Node_InputKeyEvent_0<br><span class="hljs-attr">LogStats:</span> <span class="hljs-attr">FPlatformStackWalk:</span>:StackWalkAndDump -  <span class="hljs-number">0.076</span> s<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> === Handled <span class="hljs-attr">ensure:</span> ===<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> Ensure condition <span class="hljs-attr">failed:</span> Count == <span class="hljs-number">1</span> [<span class="hljs-attr">File:</span><span class="hljs-attr">D:</span>\Codes\UE4\UE4Cpp\Source\UE4Cpp\Containerctor.cpp] [<span class="hljs-attr">Line:</span> <span class="hljs-number">33</span>]<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> <span class="hljs-attr">Stack:</span> <br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff92cfea1a8</span> UE4Editor-UE4Cpp.dll!&lt;lambda_39fe32f94e8347501feb44ad8f6d752a&gt;::operator()() [<span class="hljs-attr">D:</span>\Codes\UE4\UE4Cpp\Source\UE4Cpp\Containerctor.<span class="hljs-attr">cpp:</span><span class="hljs-number">33</span>]<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff92cfe4b8e</span> UE4Editor-UE4Cpp.dll!<span class="hljs-attr">AContainerctor:</span>:CreateThread() [<span class="hljs-attr">D:</span>\Codes\UE4\UE4Cpp\Source\UE4Cpp\Containerctor.<span class="hljs-attr">cpp:</span><span class="hljs-number">33</span>]<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff9667019c4</span> UE4Editor-CoreUObject.dll!UnknownFunction []<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff9669bf37b</span> UE4Editor-CoreUObject.dll!UnknownFunction []<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff9669e2573</span> UE4Editor-CoreUObject.dll!UnknownFunction []<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff9669e4d8d</span> UE4Editor-CoreUObject.dll!UnknownFunction []<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff9669b341a</span> UE4Editor-CoreUObject.dll!UnknownFunction []<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff9669e497c</span> UE4Editor-CoreUObject.dll!UnknownFunction []<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff9669e4d8d</span> UE4Editor-CoreUObject.dll!UnknownFunction []<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff9669e4184</span> UE4Editor-CoreUObject.dll!UnknownFunction []<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff9667019c4</span> UE4Editor-CoreUObject.dll!UnknownFunction []<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff9669e3ca3</span> UE4Editor-CoreUObject.dll!UnknownFunction []<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff947ce942a</span> UE4Editor-Engine.dll!UnknownFunction []<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff948ffec64</span> UE4Editor-Engine.dll!UnknownFunction []<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff94902eeee</span> UE4Editor-Engine.dll!UnknownFunction []<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff948b16460</span> UE4Editor-Engine.dll!UnknownFunction []<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff948b2763c</span> UE4Editor-Engine.dll!UnknownFunction []<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff948b14c2b</span> UE4Editor-Engine.dll!UnknownFunction []<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff948b26739</span> UE4Editor-Engine.dll!UnknownFunction []<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff947ccc06e</span> UE4Editor-Engine.dll!UnknownFunction []<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff948ee410e</span> UE4Editor-Engine.dll!UnknownFunction []<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff948eed2e4</span> UE4Editor-Engine.dll!UnknownFunction []<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff966de2398</span> UE4Editor-Core.dll!UnknownFunction []<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff966de27ce</span> UE4Editor-Core.dll!UnknownFunction []<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff966df40bd</span> UE4Editor-Core.dll!UnknownFunction []<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff948f093be</span> UE4Editor-Engine.dll!UnknownFunction []<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff948f0faba</span> UE4Editor-Engine.dll!UnknownFunction []<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff9485f349f</span> UE4Editor-Engine.dll!UnknownFunction []<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff9485fe2fc</span> UE4Editor-Engine.dll!UnknownFunction []<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff9465714c3</span> UE4Editor-UnrealEd.dll!UnknownFunction []<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff946e72ba6</span> UE4Editor-UnrealEd.dll!UnknownFunction []<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff664aa87a0</span> UE4Editor.exe!UnknownFunction []<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff664ac0fcc</span> UE4Editor.exe!UnknownFunction []<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff664ac10ba</span> UE4Editor.exe!UnknownFunction []<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff664ac40dd</span> UE4Editor.exe!UnknownFunction []<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff664ad5984</span> UE4Editor.exe!UnknownFunction []<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff664ad853a</span> UE4Editor.exe!UnknownFunction []<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff9d88f7034</span> KERNEL32.DLL!UnknownFunction []<br><span class="hljs-attr">LogOutputDevice:</span> <span class="hljs-attr">Error:</span> [Callstack] <span class="hljs-number">0x00007ff9da0fd0d1</span> ntdll.dll!UnknownFunction []<br><span class="hljs-attr">LogStats:</span>                SubmitErrorReport -  <span class="hljs-number">0.000</span> s<br><span class="hljs-attr">LogStats:</span>                    SendNewReport -  <span class="hljs-number">1.662</span> s<br><span class="hljs-attr">LogStats:</span>             <span class="hljs-attr">FDebug:</span>:EnsureFailed -  <span class="hljs-number">1.787</span> s<br><span class="hljs-attr">LogTemp:</span> Ensure<br></code></pre></td></tr></table></figure><h3 id="ensureMsgf-exps-text"><a href="#ensureMsgf-exps-text" class="headerlink" title="ensureMsgf(exps,text)"></a>ensureMsgf(exps,text)</h3><p>首次执行时将错误信息通知到崩溃报告器，并将text打印到日志。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AContainerctor::EnsureTest</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ensureMsgf(Count == <span class="hljs-number">1</span>,TEXT(<span class="hljs-string">&quot;Count!=1&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ensureAlways-exps"><a href="#ensureAlways-exps" class="headerlink" title="ensureAlways(exps)"></a>ensureAlways(exps)</h3><p>区别于ensure只在首次执行时通知崩溃报告器，ensureAlways只要执行就将错误信息通知到崩溃报告器，无论执行多少次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AContainerctor::EnsureTest</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ensureAlways(Count == <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ensureAlwaysMsgf-exps-text"><a href="#ensureAlwaysMsgf-exps-text" class="headerlink" title="ensureAlwaysMsgf(exps,text)"></a>ensureAlwaysMsgf(exps,text)</h3><p>ensureMsgf的Always版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AContainerctor::EnsureTest</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ensureAlways(Count == <span class="hljs-number">1</span>，TEXT(<span class="hljs-string">&quot;Count!=1&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE4】全局Widget</title>
    <link href="/2022/05/08/%E3%80%90UE4%E3%80%91UE4%E5%85%A8%E5%B1%80Widget/"/>
    <url>/2022/05/08/%E3%80%90UE4%E3%80%91UE4%E5%85%A8%E5%B1%80Widget/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>由于UE4在默认情况下会OpenLevel会将当前Level创建的Widget从ViewportClient中移除，所以默认的UserWidget会随着切换关切而消失。</p><a id="more"></a><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220508232919.gif"></p><p>有的时候我们可能需要使用一个全局的按钮什么的，所以就需要Widget不随切换关切而从ViewprotClient中移除，而是在我们想要移除的时候才移除，做一个全局的Widget其实也很简单，我只需要稍稍的重写一下UserWidget就好了。</p><p>首先创建一个自己的UserWidget子类，然后重写OnLevelRemovedFromWorld函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Blueprint/UserWidget.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;GlobalWidget.generated.h&quot;</span></span><br><br>UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROJECT_API</span> <span class="hljs-title">UGlobalWidget</span> :</span> <span class="hljs-keyword">public</span> UUserWidget<br>&#123;<br>GENERATED_BODY()<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnLevelRemovedFromWorld</span><span class="hljs-params">(ULevel* InLevel, UWorld* InWorld)</span> <span class="hljs-keyword">override</span></span>;<br>    UFUNCTION(BlueprintCallable,Category=<span class="hljs-string">&quot;GloablWidget&quot;</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RemoveGlobalWidget</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;GlobalWidget/GlobalWidget.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UGlobalWidget::OnLevelRemovedFromWorld</span><span class="hljs-params">(ULevel* InLevel, UWorld* InWorld)</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UGlobalWidget::RemoveGlobalWidget</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    RemoveFromParent();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>OnLevelRemovedFromWorld函数就是UserWidget往FWorldDelegates::LevelRemovedFromWorld代理中添加的函数，FWorldDelegates::LevelRemovedFromWorld代理会在Level从World中移除时调用；</li><li>RemoveGlobalWidget是自定义的函数，用于触发从ViewportClient中移除Widget。</li></ul><p>然后创建一个GlobalWidget的蓝图类：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220508232931.png"></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220508232942.png"></p><p>然后我们就可看一下效果了：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220508232947.gif"></p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE4】获取13位时间戳</title>
    <link href="/2022/05/08/%E3%80%90UE4%E3%80%91UE4%E8%8E%B7%E5%8F%9613%E4%BD%8D%E6%97%B6%E9%97%B4%E6%88%B3/"/>
    <url>/2022/05/08/%E3%80%90UE4%E3%80%91UE4%E8%8E%B7%E5%8F%9613%E4%BD%8D%E6%97%B6%E9%97%B4%E6%88%B3/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>UE4自身提供了一个FDateTime::ToUnixTimestamp函数可以将系统时间转换位时间戳，但是FDateTime::ToUnixTimestamp只能提供10位的时间错，翻阅了FDateTime中并没有提供13位的时间戳，且查看FDateTime::ToUnixTimestamp的源码，确实只精确到秒。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">FString <span class="hljs-title">UBPFunctionLibrary::GetTimestamp</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>FString Timestamp;<br>    FDateTime Time = FDateTime::UtcNow();<br>    int64 unixTimestamp = Time.ToUnixTimestamp();<br>    Timestamp = FString::Printf(TEXT(<span class="hljs-string">&quot;%lld&quot;</span>), unixTimestamp);<br>    UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Timestamp:%s&quot;</span>), *Timestamp);<br>    <span class="hljs-keyword">return</span> Timestamp<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-attr">LogTemp:</span> <span class="hljs-attr">Timestamp:</span><span class="hljs-number">1651734043</span><br></code></pre></td></tr></table></figure><p>当我们需要使用13位的时间戳时UE似乎就提供不了，所以只能通过C++的手段来获取。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><br><span class="hljs-comment">//...</span><br><span class="hljs-function">FString <span class="hljs-title">UBPFunctionLibrary::GetTimestamp</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">string</span> nowTimeUnix;<br><span class="hljs-built_in">string</span> cs_uninxtime;<br><span class="hljs-built_in">string</span> cs_milliseconds;<br>SYSTEMTIME sysTime;<br>GetLocalTime(&amp;sysTime);<br><span class="hljs-keyword">time_t</span> unixTime;<br>time(&amp;unixTime);<br><span class="hljs-keyword">char</span> buf[<span class="hljs-number">30</span>], bufms[<span class="hljs-number">30</span>];<br>sprintf_s(buf, <span class="hljs-keyword">sizeof</span>(buf), <span class="hljs-string">&quot;%I64d&quot;</span>, (INT64)unixTime);<br>sprintf_s(bufms, <span class="hljs-keyword">sizeof</span>(bufms), <span class="hljs-string">&quot;%03I64d&quot;</span>, (INT64)sysTime.wMilliseconds);<br>nowTimeUnix = <span class="hljs-built_in">string</span>(buf) + <span class="hljs-built_in">string</span>(bufms);<br>    FString Timestamp = FString(nowTimeUnix.c_str());<br>    UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Timestamp:%s&quot;</span>), *Timestamp);<br><span class="hljs-keyword">return</span> Timestamp;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-attr">LogTemp:</span> <span class="hljs-attr">Timestamp:</span><span class="hljs-number">1751734043331</span><br></code></pre></td></tr></table></figure><p>上面这种方法只能在Windows上使用，如果需要在Andriod上使用，则可以直接封装java的库函数。然后通过UE4的JNI框架去调用java函数，以达到在Android上获取13位的时间戳的效果。</p><p>UE4调用java的函数通过一个中间XML文件来实现，我们将需要调用的函数在XML中用java函数进行一层封装，然后再在UE4中调用这个封装函数来实现间接调用。</p><p>首先创建一个XML文件，这里命名为：JavaTest.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">gameActivityClassAdditions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">insert</span>&gt;</span><br>            &lt;![CDATA[<br>            public String getSystemTimestamp()<br>            &#123;<br>                long now = System.currentTimeMillis();<br>                return String.valueOf(now);<br>            &#125;<br>   ]]&gt;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">gameActivityClassAdditions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br></code></pre></td></tr></table></figure><p>将我们的封装函数写在gameActivityClassAdditions标签里，这里直接调用Android的库函数获取当前时间戳。</p><p>然后我们需要在.Build.cs文件里注明这个XML文件:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnrealBuildTool;<br><span class="hljs-keyword">using</span> System.IO;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">JavaTest423</span> : <span class="hljs-title">ModuleRules</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JavaTest423</span>(<span class="hljs-params">ReadOnlyTargetRules Target</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">Target</span>)</span><br><span class="hljs-function"></span>&#123;<br>PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;<br><br>PublicDependencyModuleNames.AddRange(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123; <span class="hljs-string">&quot;Core&quot;</span>, <span class="hljs-string">&quot;CoreUObject&quot;</span>, <span class="hljs-string">&quot;Engine&quot;</span>, <span class="hljs-string">&quot;InputCore&quot;</span> &#125;);<br><br>PrivateDependencyModuleNames.AddRange(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123;  &#125;);<br><br>        <span class="hljs-keyword">if</span> (Target.Platform == UnrealTargetPlatform.Android)<br>        &#123;<br>            PrivateDependencyModuleNames.Add(<span class="hljs-string">&quot;Launch&quot;</span>);<br>            AdditionalPropertiesForReceipt.Add(<span class="hljs-string">&quot;AndroidPlugin&quot;</span>, Path.Combine(ModuleDirectory, <span class="hljs-string">&quot;JavaTest.xml&quot;</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于只需要运行在Android上，所以这里做了平台判断。</p><p>然后创建一个Actor—JavaTest，在Actor中调用这个java函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;JavaTest.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Kismet/KismetSystemLibrary.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> PLATFORM_ANDROID</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Android/AndroidApplication.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Android/AndroidJavaEnv.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;../Source/Runtime/Launch/Public/Android/AndroidJNI.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>AJavaTest::AJavaTest()<br>&#123;<br>PrimaryActorTick.bCanEverTick = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AJavaTest::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br>    Timestamp();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AJavaTest::Tick</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime)</span></span><br><span class="hljs-function"></span>&#123;<br>Super::Tick(DeltaTime);<br>&#125;<br><span class="hljs-function">FString <span class="hljs-title">AJavaTest::Timestamp</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    FString Timestamp;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> PLATFORM_ANDROID</span><br>    jstring JavaString = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (JNIEnv* Env = FAndroidApplication::GetJavaEnv(<span class="hljs-literal">true</span>))<br>    &#123;<br>        <span class="hljs-comment">//寻找方法的地址</span><br>        <span class="hljs-keyword">static</span> jmethodID MethonId = FJavaWrapper::FindMethod(Env, FJavaWrapper::GameActivityClassID, <span class="hljs-string">&quot;getSystemTimestamp&quot;</span>, <span class="hljs-string">&quot;()Ljava/lang/String;&quot;</span>, <span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">//通过地址调用方法</span><br>        JavaString = (jstring)FJavaWrapper::CallObjectMethod(Env, FJavaWrapper::GameActivityThis, MethonId);<br>        <span class="hljs-keyword">if</span> (JavaString != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* JavaChars = Env-&gt;GetStringUTFChars(JavaString, JNI_FALSE);<br>            Timestamp = FString(UTF8_TO_TCHAR(JavaChars));<br>            Env-&gt;ReleaseStringUTFChars(JavaString, JavaChars);<br>            Env-&gt;DeleteLocalRef(JavaString);<br>        &#125;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Timestamp:%s&quot;</span>), *Timestamp);<br>    <span class="hljs-keyword">return</span> Timestamp;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后打一个Android包，安装到手机上运行，查看一下打印的日志：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">830</span>: <span class="hljs-number">05</span>-<span class="hljs-number">06</span> <span class="hljs-number">20</span>:<span class="hljs-number">38</span>:<span class="hljs-number">28</span>.<span class="hljs-number">134</span>  <span class="hljs-number">5103</span>  <span class="hljs-number">5159</span> D UE<span class="hljs-number">4</span>     :<span class="hljs-meta"> [2022.05.06-20.38.28:134][  0]LogTemp: Timestamp:1651840708134</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE4】 文件系统</title>
    <link href="/2022/01/27/%E3%80%90UE4%E3%80%91UE4%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/01/27/%E3%80%90UE4%E3%80%91UE4%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>先来看一下UE4文件系统的类组成情况：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127135722.png"></p><p>我们一个个类来看。</p><p>这里面类组成大致可以分为三大类：</p><ul><li>物理文件类：UE4封装的在各个平台下直接对文件进行操作的类，主要是IPhysicalPlatformFile及其子类；</li><li>包装文件类：UE4封装的对特定情况的文件进行操作的类，如对pak包的处理，包装文件类不会直接对文件进行操作，而是通过其持有的底层对象来进行文件操作，包装文件类持有的底层对象也可以是另一个包装文件类，这样一层层的持有对象，各个类就链接成了一条链，当链头接收到要处理的文件若自己能处理则直接处理，若自己无法处理则抛给自己持有的底层对象，底层对象重复这个操作直到有一个对象可以处理则停止，这条链的链尾就是一个物理文件对象，这就是UE4文件系统的责任链模式。包装文件类主要包括继承自IPlatformFile的除IPhysicalPlatformFile类及其子类以外的其他类；</li><li>平台文件管理器：FPlatformFileManager用于管理注册的平台文件类及其组成的文件操作链。</li></ul><p>参考博客:</p><p><a href="https://bajiaobujie.github.io/2019/04/25/2019-04-25-UE4%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%EF%BC%88%E4%B8%89%EF%BC%89FPakPlatformFile%E7%9B%B8%E5%85%B3/#more">芭蕉不解的博客</a>、<a href="https://zhuanlan.zhihu.com/p/35925797">FlyingTree</a>、<a href="https://www.cnblogs.com/shiroe/p/14803859.html">代码质疑人生</a>、<a href="https://blog.csdn.net/KKsuser/article/details/111659209">Khcys_</a>、<a href="https://dhbloo.github.io/2020/09/07/UE4-FileSystem/#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%88%9B%E5%BB%BA">dhb</a></p><a id="more"></a><h1 id="一、IPlatformFile"><a href="#一、IPlatformFile" class="headerlink" title="一、IPlatformFile"></a>一、IPlatformFile</h1><p>IPlatformfile是文件类的基类，是一个UE4预定义的C++接口，是一个顶层类不继承任何类，所以IPlatformFile类及其子类均不支持反射和垃圾回收，也就是说这些类的指针管理需要我们自己手动管理，析构时需要手动delete对象，以防内存泄漏。</p><p>作为基类IPlatformFile的主要作用是用于文件操作链中的多态和提供一些通用方法与属性，如:初始化，判断文件是否存在，读取、写入、移动、删除、拷贝文件等等，其中需要注意的是<code>virtual bool Initialize(IPlatformFile* Inner, const TCHAR* CmdLine) = 0;</code>在IPlatformfile类中是一个纯虚函数，在子类使用其作初始化时，对于包装文件类来说，第一个参数是他所指向的下一个文件类对象。对于物理文件类，第一个参数只能是空的; 第二个参数是命令行，部分文件类会从这里去解析一些参数。</p><h1 id="二、IPhysicalPlatformFile"><a href="#二、IPhysicalPlatformFile" class="headerlink" title="二、IPhysicalPlatformFile"></a>二、IPhysicalPlatformFile</h1><p>IPhysicalPlatformFile是物理文件类的基类，对SetLowerLevel函数进行了屏蔽，使其子类都无法访问SetLowerLevel函数，因为对于文件操作链来说，链尾一定是一个物理文件类，所以不需要再设置底层对象。</p><p>源码相当简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Common base for physical platform File I/O Interface</span><br><span class="hljs-comment">**/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CORE_API</span> <span class="hljs-title">IPhysicalPlatformFile</span> :</span> <span class="hljs-keyword">public</span> IPlatformFile<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//~ Begin IPlatformFile Interface</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">ShouldBeUsed</span><span class="hljs-params">(IPlatformFile* Inner, <span class="hljs-keyword">const</span> TCHAR* CmdLine)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Initialize</span><span class="hljs-params">(IPlatformFile* Inner, <span class="hljs-keyword">const</span> TCHAR* CmdLine)</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> IPlatformFile* <span class="hljs-title">GetLowerLevel</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetLowerLevel</span><span class="hljs-params">(IPlatformFile* NewLowerLevel)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function"></span>&#123;<br>check(<span class="hljs-literal">false</span>); <span class="hljs-comment">// can&#x27;t override wrapped platform file for physical platform file</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">const</span> TCHAR* <span class="hljs-title">GetName</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> IPlatformFile::GetPhysicalTypeName();<br>&#125;<br><span class="hljs-comment">//~ End IPlatformFile Interface</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在源码中IPhysicalPlatformFile::GetLowerLevel直接返回了一个nullptr。</p><p>查看FWindowsPlatformFile在UE4.26中的源码发现FWindowsPlatformFile.h是一个空的头文件，而整个FWindowsPlatformFile类都被定义在FWindowsPlatformFile.cpp中，这就谢绝了我们以常规的方式使用FWindowsPlatformFile这些类了，FAndriodPlatformFile类更是找都找不到，UE4这么做的意图已经很明显了，UE4是不想让开发者直接使用这些底层类的，这也是为什么UE4要提供一个FPlatformFileManager类的原因。</p><h1 id="三、FPlatformFileManager"><a href="#三、FPlatformFileManager" class="headerlink" title="三、FPlatformFileManager"></a>三、FPlatformFileManager</h1><p>PLatformFileManager类就是用UE4用于文件系统的跨平台用的，在引擎的主循环的FEngineLoop::PreInit函数中会调用FEngineLoop::PreInitPreStartupScreen，然后通过LaunchCheckForFileOverride函数检测是否需要设置当前文件系统，不需要设置则将引擎的文件系统设置成默认物理文件系统，如果需要设置则根据配置设置对应的文件系统，并将这个文件类的LowerLevel设置成对应的物理文件系统。</p><p>FPlatformFileManager提供GetPlatformFile函数返回一个IPlatformFile指针，通过多态来调用接口的具体实现，可以忽略掉底层不同平台类的文件操作实现，从而达到跨平台的效果。</p><p>IPlatformFile的文件操作依然是比较底层的操作，如IPlatformFile::OpenRead和IPlatformFile::OpenWrite函数返回的都是一个IFileHandle文件操作句柄，通过这个句柄才能对文件做跟底层的读写，如IFileHandle::Read和IFileHandle::Write函数都是直接读写的字节码。</p><p>IPlatformFile主要是提供对文件的整体操作，如移动、删除、拷贝、读取与设置文件属性，寻找文件，判断文件是否存在，获取文件大小，同时也提供对文件夹层面的操作，如创建、删除、复制、遍历文件夹等等。</p><p>而对于常规文件的读写UE4提供了一个更高层的类FileHelper来操作，对目录路径的操作UE4提供了FPaths，对配置文件的操作UE4提供了GConfig，读取Json文件UE4提供了内置的Json读写工具链。这些我们后面再看，先把IPlatformFile的子类过完。</p><h1 id="四、FPakPlatformFile"><a href="#四、FPakPlatformFile" class="headerlink" title="四、FPakPlatformFile"></a>四、FPakPlatformFile</h1><p>在IPlatFormFile派生的所有的包装文件类当中FPakPlatformFile是最重要也是最常用的，FPakPlatformFile是UE4专门用于Pak文件读取的包装文件类。</p><h2 id="1-什么是Pak文件"><a href="#1-什么是Pak文件" class="headerlink" title="1.什么是Pak文件"></a>1.什么是Pak文件</h2><p>pak文件，又称pak包，是UE4用于更新资源(包括热更新)的一种文件格式，UE4将多个文件合并到一个pak文件中，通过pak文件来更新资源，pak文件不仅能够装载UE4的资源文件，如：uasset、umap等，也能够装载非资源文件，如：xml、json、txt等，除了文件，pak文件还可以包含一些额外的信息，如：pak文件的加密情况，pak的版本等等。</p><p>要想对pak文件进行操作，我们首先要先获取pak文件。</p><p>pak文件的生成分为两步，烘培与打包。</p><h2 id="2-Cook资源-烘焙资源"><a href="#2-Cook资源-烘焙资源" class="headerlink" title="2.Cook资源(烘焙资源)"></a>2.Cook资源(烘焙资源)</h2><h3 id="为什么要烘焙资源"><a href="#为什么要烘焙资源" class="headerlink" title="为什么要烘焙资源"></a>为什么要烘焙资源</h3><p>由于程序运行的平台多种多样，而不同平台有着各自的资源格式，所以在创建Pak文件之前必须先烘焙对应平台的资源才行，UE4提供UE4Editor-Cmd.exe工具来提供资源烘焙，UE4Editor-Cmd.exe可以直接在cmd命令。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;引擎路径&gt;\Engine\Binaries\Win64\UE4Editor-Cmd.exe &lt;项目路径&gt;\RobotEngine.uproject <span class="hljs-attribute">-run</span>=Cook  <span class="hljs-attribute">-TargetPlatform</span>=&lt;平台类型&gt; -fileopenlog -unversioned <span class="hljs-attribute">-abslog</span>=&lt;日志输出路径&gt; -stdout -CrashForUAT -unattended -NoLogTimes  -UTF8Output<br></code></pre></td></tr></table></figure><p>烘培完的资源会存储在<code>&lt;项目文件夹&gt;/Saved/Cooked/&lt;对应的平台名称&gt;/&lt;项目名称&gt;/Content/&lt;对应的目录&gt;</code></p><h3 id="烘焙所支持的平台类型"><a href="#烘焙所支持的平台类型" class="headerlink" title="烘焙所支持的平台类型"></a>烘焙所支持的平台类型</h3><p>UE4的资源烘焙自持目前大部分主流平台：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127135749.png"></p><p>当然，如果我们只需要烘焙Windows平台的资源，UE4直接提供了烘焙按钮</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127135758.png"></p><h2 id="2-Pak文件的打包"><a href="#2-Pak文件的打包" class="headerlink" title="2.Pak文件的打包"></a>2.Pak文件的打包</h2><p>UE4提供了一个创建Pak文件的工具—UnrealPak.exe供我们使用，我们可以直接从cmd命令行运行UnrealPak.exe来对指定文件创建Pak包。</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">&lt;引擎路径&gt;<span class="hljs-symbol">\E</span>ngine<span class="hljs-symbol">\B</span>inaries<span class="hljs-symbol">\W</span>in64<span class="hljs-symbol">\U</span>nrealPak.exe &lt;pak文件路径&gt; -Create=&lt;项目路径&gt;<span class="hljs-symbol">\R</span>obotEngine<span class="hljs-symbol">\S</span>aved<span class="hljs-symbol">\C</span>ooked<span class="hljs-symbol">\A</span>ndroid_ASTC<span class="hljs-symbol">\R</span>obotEngine<span class="hljs-symbol">\C</span>ontent<span class="hljs-symbol">\C</span>omps<span class="hljs-symbol">\&lt;</span>cook资源文件所在的文件夹&gt; -compress<br></code></pre></td></tr></table></figure><p>这里有几点需要注意，pak文件路径是我们要存放创建出来的pak文件的路径，如：D:\PAK\mypak.pak，cook资源文件所在文件夹即cook后的uasset文件所在目录，切记不是文件路径，因为目录下可以包含多个资源文件，其中Andriod_ASTC是对应平台类型的文件夹，需要实际根据cook的平台选择对应的文件夹。</p><p><code>-compress</code>表示文件打包pak时进行压缩。</p><p>UnrealPak可以封装一个指定文件到Pak文件中，也可以封装一个指定文件夹下的所有文件到Pak文件中，还可以封装一个文件下中指定的多个文件夹和文件的组合到Pak文件中。</p><p>比如：</p><h3 id="指定单个目录打包Pak"><a href="#指定单个目录打包Pak" class="headerlink" title="指定单个目录打包Pak"></a>指定单个目录打包Pak</h3><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">D:<span class="hljs-symbol">\U</span>E_4.26_SourceCode<span class="hljs-symbol">\U</span>nrealEngine-4.26<span class="hljs-symbol">\E</span>ngine<span class="hljs-symbol">\B</span>inaries<span class="hljs-symbol">\W</span>in64<span class="hljs-symbol">\U</span>nrealPak.exe D:<span class="hljs-symbol">\U</span>E4<span class="hljs-symbol">\P</span>aks<span class="hljs-symbol">\P</span>akActor.pak -create=D:<span class="hljs-symbol">\U</span>E4<span class="hljs-symbol">\U</span>nkown<span class="hljs-symbol">\U</span>nkown<span class="hljs-symbol">\C</span>onfig -compress<br></code></pre></td></tr></table></figure><h3 id="指定多个目录和文件的组合打包Pak"><a href="#指定多个目录和文件的组合打包Pak" class="headerlink" title="指定多个目录和文件的组合打包Pak"></a>指定多个目录和文件的组合打包Pak</h3><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">D:<span class="hljs-symbol">\U</span>E_4.26_SourceCode<span class="hljs-symbol">\U</span>nrealEngine-4.26<span class="hljs-symbol">\E</span>ngine<span class="hljs-symbol">\B</span>inaries<span class="hljs-symbol">\W</span>in64<span class="hljs-symbol">\U</span>nrealPak.exe D:<span class="hljs-symbol">\U</span>E4<span class="hljs-symbol">\P</span>aks<span class="hljs-symbol">\P</span>akActor.pak -create=D:<span class="hljs-symbol">\U</span>E4<span class="hljs-symbol">\U</span>nkown<span class="hljs-symbol">\U</span>nkown<span class="hljs-symbol">\C</span>onfig<span class="hljs-symbol">\A</span>.txt -compress<br></code></pre></td></tr></table></figure><p>txt文件中目录和文件的组合格式如下：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">D:<span class="hljs-symbol">\G</span>oulandis<span class="hljs-symbol">\U</span>E4<span class="hljs-symbol">\P</span>aks<span class="hljs-symbol">\P</span>aks_0104143216 <br>D:<span class="hljs-symbol">\G</span>oulandis<span class="hljs-symbol">\U</span>E4<span class="hljs-symbol">\P</span>aks<span class="hljs-symbol">\P</span>aks_0104145559<br>D:<span class="hljs-symbol">\G</span>oulandis<span class="hljs-symbol">\U</span>E4<span class="hljs-symbol">\P</span>aks<span class="hljs-symbol">\J</span>son.json<br></code></pre></td></tr></table></figure><p>路径与路径之间必须用换行符隔开，如果存在不可用路径则文件打包失败。</p><h3 id="指定单个文件打包Pak"><a href="#指定单个文件打包Pak" class="headerlink" title="指定单个文件打包Pak"></a>指定单个文件打包Pak</h3><p>由于-create=只能接文件和目录，若是目录，则打包目录下的所有文件进Pak包，如果接的是文件，则会读取文件内容，将文件中的内容当作要打包的路径，所以直接指定文件路径的指令形式是无法打包单个文件的，因此我们还是需要使用文本来指定单个文件的路径的形式来打包单个文件。</p><p>-create可以读取常用的文本格式，如txt，ini，json等，只要里面内容符合格式要求即可读取。</p><h3 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a><font color="green">小知识</font></h3><p>当我们在打包引用程序的时候勾选Edit\Project Setting\Packaging\Use Pak File</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127135809.png"></p><p>则打包出来的资源将全部封装进一个独立的Pak包里面，pak包保存在<code>&lt;程序目录&gt;/&lt;项目名称&gt;/Content/Paks/</code>目录下，如果不勾选那么资源路径情况和编辑时一样，并且打包出来的资源也依旧是.uasset资源。由于pak文件可以加密而uasset不能加密，所以将资源封装进pak文件中有利于程序的安全性。</p><h2 id="3-Pak文件的挂载"><a href="#3-Pak文件的挂载" class="headerlink" title="3.Pak文件的挂载"></a>3.Pak文件的挂载</h2><p>首先我们需要明白一个机制，就是UE挂载Pak文件，仅仅是引擎内部注册一个Pak挂载点对应的文件夹，这样当引擎去寻找资源的时候就知道有这么一个地址可以去搜索资源，而在实际的物理文件中这个文件夹是不存在的，由此可以知晓，Pak文件挂载之后并不能直接使用Pak文件中资源，因为资源仍然是一个虚拟文件夹下的物理文件，还未加载到内存中。</p><p>然后创建一个类作为挂载代码的载体，这个载体可以AActor也可以是UObject，甚至可以是自定义的C++类。这里我使用一个UObject类来作为载体。</p><p>先上源码，后面再做解析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;IPlatformFilePak.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;GenericPlatform/GenericPlatformFile.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;UObject/NoExportTypes.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;PakExpand.generated.h&quot;</span></span><br><br>UCLASS(Blueprintable,BlueprintType)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UNKOWN_API</span> <span class="hljs-title">UPakExpand</span> :</span> <span class="hljs-keyword">public</span> UObject<br>&#123;<br>GENERATED_BODY()<br><span class="hljs-keyword">private</span>:<br>FPakPlatformFile* HandlePakPlatform;<br>IPlatformFile* HandleOriginPlatform;<br>FPlatformFileManager* PlatformFileManager;<br><span class="hljs-keyword">private</span>:<br>~UPakExpand();<br><span class="hljs-keyword">public</span>:<br>UPakExpand();<br>UFUNCTION(BlueprintCallable,Category=<span class="hljs-string">&quot;PakExpand&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Mount</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString PakFilePath)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//.cpp</span><br>UPakExpand::~UPakExpand()<br>&#123;<br>    PlatformFileManager = <span class="hljs-literal">nullptr</span>;<br>    HandleOriginPlatform = <span class="hljs-literal">nullptr</span>;<br>    HandlePakPlatform = <span class="hljs-literal">nullptr</span>;<br>&#125;<br>UPakExpand::UPakExpand()<br>&#123;<br>    <span class="hljs-comment">//获取平台文件链接管理器</span><br>    PlatformFileManager = &amp;FPlatformFileManager::Get();<br>    <span class="hljs-comment">//获取平台I/O接口，用于操作平台文件</span><br>    HandleOriginPlatform = &amp;PlatformFileManager-&gt;GetPlatformFile();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">UPakExpand::Mount</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString PakFilePath)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//判断文件时候是pak文件</span><br>    <span class="hljs-keyword">if</span> (!PakFilePath.EndsWith(<span class="hljs-string">&quot;.pak&quot;</span>))<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;  <br>    <span class="hljs-keyword">if</span> (!HandlePakPlatform)<br>    &#123;<br>        <span class="hljs-comment">//创建Pak平台文件系统</span><br>        HandlePakPlatform = <span class="hljs-keyword">new</span> FPakPlatformFile();<br>    &#125;<br>    <span class="hljs-comment">//使用平台接口初始化Pak文件平台包装器</span><br>    HandlePakPlatform-&gt;Initialize(HandleOriginPlatform, TEXT(<span class="hljs-string">&quot;&quot;</span>));<br>    <span class="hljs-comment">//将PakPlatformFile设置到最顶层，查找文件时优先查找PakPlatformFile内的文件</span><br>    PlatformFileManager-&gt;SetPlatformFile(*HandlePakPlatform);<br>    <span class="hljs-comment">//判断文件是否存在</span><br>    <span class="hljs-keyword">if</span> (!HandleOriginPlatform-&gt;FileExists(*PakFilePath))<br>    &#123; <br>        PlatformFileManager-&gt;SetPlatformFile(*HandleOriginPlatform);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">//创建pak对象</span><br>    TSharedPtr&lt;FPakFile&gt; PakFile = MakeShareable&lt;FPakFile&gt;(<span class="hljs-keyword">new</span> FPakFile(HandlePakPlatform, *PakFilePath, <span class="hljs-literal">false</span>));<br>    <span class="hljs-keyword">if</span> (!PakFile)<br>    &#123;<br>        PlatformFileManager-&gt;SetPlatformFile(*HandleOriginPlatform);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;   <br>    <span class="hljs-comment">//获取pak文件的无后缀文件名</span><br>    FString PakName = GetPakFileName(PakFilePath);<br>    TArray&lt;FString&gt; ExistPakFiles;<br>    <span class="hljs-comment">//查询已挂载的所有pak包名称</span><br>    HandlePakPlatform-&gt;GetMountedPakFilenames(ExistPakFiles);<br>    <span class="hljs-comment">//判断当前pak包是否已挂载</span><br>    <span class="hljs-keyword">if</span> (ExistPakFiles.Find(PakFilePath) &gt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        PlatformFileManager-&gt;SetPlatformFile(*HandleOriginPlatform);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    int32 Pos = PakFile-&gt;GetMountPoint().Find(<span class="hljs-string">&quot;Content/&quot;</span>);<br>    FString MountPoint = PakFile-&gt;GetMountPoint().RightChop(Pos);<br>    MountPoint = FPaths::ProjectDir() + MountPoint;<br>    PakFile-&gt;SetMountPoint(*MountPoint);<br>    <span class="hljs-comment">//使用pak包记录的挂载点挂载pak包</span><br>    <span class="hljs-keyword">if</span> (!HandlePakPlatform-&gt;Mount(*PakFilePath, <span class="hljs-number">0</span>, *PakFile-&gt;GetMountPoint()))<br>    &#123;<br>        PlatformFileManager-&gt;SetPlatformFile(*HandleOriginPlatform);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    PlatformFileManager-&gt;SetPlatformFile(*HandleOriginPlatform);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有一些类和函数需要说明一下：</p><ul><li>IPlatformFile：这是UE4对文件操作的最基础的类，定义了对文件进行操作的相关方法，UE4自己单独封装一个文件操作类而不是直接用C++的文件操作，是UE4为了提供平台的可移植性才建立这么一个更高层的I/O接口；</li><li>FPakPlatformFile：这个类是UE4对pak文件操作的一个封装类，派生与IPlatformFile类；</li><li>FPlatformFileManager：这个类是UE4用于获取不同平台的物理文件的封装，Get()方法是获取类自身的实例，GetPlatformFile()方法是获取文件操作链的链头，如果没有找到则返回nullptr；</li><li>Initialize()：初始化接口，第一个参数为FPakPlatformFile类指向的下一个文件类对象，我们这里是需要指向当前平台，第二参数是一个命令行，部分文件类会从这里解析一些参数，我们这里没有命令，所以用空字符串；</li><li>SetPlatformFile()：可以理解为想UE4文件系统设置Initialize()初始化的配置；</li><li>GetMountedPakFilenames()：获取已经挂载过的pak文件，参数为一个FString数组；</li><li>GetMountPoint()：获取pak文件的挂载点，这个挂载点是直接存储在pak文件中的，pak文件的结构具体将<a href="https://zhuanlan.zhihu.com/p/333857439">弘竣的开发笔记</a>；</li><li>RightChop()：返回字符串指定位置右侧的字符串；</li><li>SetMountPoint()：设置挂载点，pak文件的挂载必须得有挂载点，否则UE4就无法找到pak文件，挂载点就是pak文件在UE4中上级目录；</li><li>Mount()：挂载pak文件；</li></ul><p>这里有一点需要注意的是，PlatformFileManager-&gt;SetPlatformFile(*HandlePakPlatform);设置文件系统不可以在构造函数中执行否则打包会报错。</p><p>到这里一个pak文件的挂载就完成了。</p><h3 id="里面的一些坑"><a href="#里面的一些坑" class="headerlink" title="里面的一些坑"></a>里面的一些坑</h3><p>在网上搜了相当多的UE4pak挂载的文章，里面大多数使用共享指针来指向FPakPlatformFile，我在UE4.26中在未勾选Edit\Project Setting\Packaging\Use Pak File的情况下，不会有任何问题，但是在勾选了的情况下会在退出游戏时报：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127135820.png"></p><p>具体原因暂不清楚，所以我上面的源码一律没有使用共享指针，而是选择了C++指针，自己去管理指针。</p><h2 id="4-Pak文件的加载"><a href="#4-Pak文件的加载" class="headerlink" title="4.Pak文件的加载"></a>4.Pak文件的加载</h2><h3 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h3><p>想要加载Pak文件中的资源进入内存我们就只能使用C++的方式来加载，我以加载一个AActor为例，先上源码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">AActor* <span class="hljs-title">UPakExpand::SpawnActorFromPak</span><span class="hljs-params">(FString ClassRef, FTransform Transform, <span class="hljs-keyword">bool</span>&amp; Result)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!HandlePakPlatform)<br>    &#123;<br>        Result = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    PlatformFileManager-&gt;SetPlatformFile(*HandlePakPlatform);<br>    UClass* uclass = StaticLoadClass(AActor::StaticClass(), <span class="hljs-literal">NULL</span>, *ClassRef);<br>    <span class="hljs-keyword">if</span> (!uclass)<br>    &#123;<br>        Result = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    AActor* Actor = GetWorld()-&gt;SpawnActor(uclass,&amp;Transform);<br>    <span class="hljs-keyword">if</span> (!Actor)<br>    &#123;<br>        Result = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;   <br>    <span class="hljs-keyword">if</span> (!HandleOriginPlatform)<br>    &#123;<br>        Result = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    PlatformFileManager-&gt;SetPlatformFile(*HandleOriginPlatform);<br>    Result = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> Actor;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>PlatformFileManager-&gt;SetPlatformFile(*HandlePakPlatform);将文件系统切换到Pak文件系统，这样才能读取到Pak包中的资源，因为引擎默认使用的是物理文件系统，而Pak包挂载的不是物理文件，所以使用物理文件系统是无法读取到Pak文件内的资源的。</li><li>PlatformFileManager-&gt;SetPlatformFile(*HandleOriginPlatform);将文件系统切换回原来的文件系统，实际上切不切回去是没有影响的，因为SetPlatformFile是在当前的文件操作链的链头再加一个操作节点，然后以这个新的操作节点作为文件操作链的链头，当加载资源时会从操作链的链头开始搜索资源，当然，当我们不需要再加载Pak包中的资源时，切回去可以使操作链少一个节点，资源的寻找速度会更快一点，所以这里我还是切回去。</li></ul><h3 id="里面的一些坑-1"><a href="#里面的一些坑-1" class="headerlink" title="里面的一些坑"></a>里面的一些坑</h3><p>这里有一点是需要注意的，前面有说过挂载只是在引擎内部注册了一个虚拟文件夹，这个文件夹在实际的物理目录中是不存在的，所以如果我们在编辑状态下直接使用要打成Pak文件的这些资源，在挂载了Pak之后引擎依然是找不到这些资源的，原因我猜是编辑状态下使用资源保存的路径应该是封装整个程序资源的Pak文件的路径即这个Pak文件：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127135826.png"></p><p>这里面有一个比较隐晦的状况，就是如果我们打包的时候不排除需要Pak的文件夹，也就是说打包的时候把需要Pak的文件一并打进Unkown-WindowsNoEditor.pak这个Pak文件中，在实际运行的效果是，资源是可以被加载的，这是因为引擎加载的资源是Unkown-WindowsNoEditor.pak中的资源，而非我们自己挂载的Pak包中的资源，我们可通过修改Pak包中的资源内容，重新运行来证明这个问题。而如果我们把需要打Pak的文件夹不打包进Unkown-WindowsNoEditor.pak中，那么资源就识别不出来了。如果资源只是在Pak包自己内部使用则没有这个问题。</p><p>我们通过一个例子也许会更好理解一些。</p><p><strong>第一步：</strong></p><p>在Content文件夹下创建一个需要Pak的文件夹命名为DLCs，在里面创建两个资源，给Pak包外部使用的PakActor和给Pak包内部使用的PakWidget。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127135830.png"></p><p>两个资源的内部情况如下：</p><p><strong>PakActor：</strong></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127135835.png"></p><p>在PakActor中去创建PakWidget，注意这里是直接在编辑状态下去加载PakWidget，并且PakWidget和PakActor在同一个文件夹下，即将来打Pak包后，两个资源在同一个Pak包中。</p><p>PrintDebugLog是自己封装的一个打印日志的函数。</p><p><strong>PakWidget：</strong></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127135910.png"></p><p><strong>第二步：</strong></p><p>在另一个文件夹下去创建一个GameInstance，使用GameInstance去挂载并加载资源，这里我创建一个名为UnkGameInstance的GameInstance，并放在Content/GamePlay文件夹下，蓝图内容如下：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127135915.png"></p><p>这里我们先使用在编辑状态下直接使用UE4原生API<code>SpawnActorFromClass</code>来加载PakActor，</p><p>好，现在我们不排除Content/DLCs文件夹，在Project Setting/Packaging/Packaging/Directories to never cook项不添加文件夹，勾选Use Pak File。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127135920.png"></p><p>然后打一个Windows程序出来，然后把Content/DLCs文件夹打一个Pak包出来，我这里命名为PakActor.pak，并将Pak包放入程序目录/Content/DLCs/目录下。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127135929.png"></p><p>可以看到在勾选了UsePakFile时引擎自动生成了一个Paks文件夹下的<code>&lt;项目名&gt;-&lt;平台类型&gt;.pak</code>的文件，我这里是Unkown-WindowsNoEditor.pak文件，而DLCs文件夹是没有的，所以我们要自己创建一个，并把打包出来的Pak文件放进去，需要注意的是Pak文件的命名需要和加载时的名称要一致。</p><p>然后我们跑起来看一下。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127135933.png"></p><p>PakActor和PakWidget资源是加载出来了的，此时我们无法分辨加载的到底是Unkown-WindowsNoEditor.pak中的资源还是PakActor.pak中的资源，因为在两个pak包中都存在一份/Game/DLCs/PakActor.uasset和/Game/DLCs/PakWidget.uasset资源。</p><p>为了识别资源是哪个Pak包中的，有两种方式验证，先看第一种</p><p>现在我们修改一下PakActor蓝图的打印的内容：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127135937.png"></p><p>把this is PakActor修改成this is PakActor2，然后再打一个Pak包出来，同样命名为PakActor.pak并放到Content/DLCs/目录下替换掉之前的pak包，然后我们再跑一次看看，打印内容有没有变化。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127135942.png"></p><p>可以看到，打印的内容依旧是this is PakActor，这说明加载到PakActor不是PakActor.pak中的资源而是Unkown-WindowsNoEditor.pak中的资源，因为我们没有重新打包程序，所以Unkown-WindowsNoEditor.pak中的PakActor.uasset打印依然是this is PakActor，而PakActor.pak中PakActor.uasset打印已经修改成了this is PakActor2。</p><p>为了严谨起见，我们再用第二种方式验证一遍。</p><p>现在我们在打包时不把Content/DLCs/文件夹打进Unkown-WindowsNoEditor.pak中，在Project Setting/Packaging/Packaging/Directories to never cook项中把Content/DLCs/添加进去。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127135946.png"></p><p>然后我们再打包来跑一次看看。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127135950.png"></p><p>可以看到没有任何打印出来，并且PakWidget也没有加载出来，我们再看一下日志，日志存储在<code>&lt;程序目录&gt;/&lt;项目名称&gt;/Saved/Logs/</code>目录下。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127135955.png"></p><p>日志打印了PakActor is not valid这说明PakActor未识别到，由于此时Unkown-WindowsNoEditor.pak中不包含PakActor.uasset资源，只有PacActor.pak中包含，所以可以验证在编辑状态下使用Pak中的资源引擎保存的路径和实际Pak挂载的路径是不一致的(尽管匹配到物理路径上两者是一样的，个人猜想编辑状态下使用的是物理路径，而挂载使用的是虚拟路径，纯个人猜想)。</p><p>好，现在我们换一种方式来加载Pak包中的资源，使用前面我们封装好的UPakExpand::SpawnActorFromPak函数，通过C++的方式来加载，我们重新修改一下UnkGameInstance的蓝图内容。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127140009.png"></p><p>重新打一个包出来，这一次我们依旧不把Content/DLCs/文件夹打进Unkown-WindowsNoEditor.pak，重新打一份程序，再跑一次看看。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127140017.png"></p><p>可以看到，我们对PakActor的修改也生效了，嗯，这就是这个坑的解释。</p><h2 id="5-Pak文件的加密"><a href="#5-Pak文件的加密" class="headerlink" title="5.Pak文件的加密"></a>5.Pak文件的加密</h2><p>UE提供了UnrealPak工具提供了对Pak文件的加密功能，通过Project Settings/Crypto/Encryption/Generate New Encryption Key可以自动生成用于加密Pak文件的密钥，并且这些配置信息会保存在<code>&lt;项目目录&gt;/Config/DefaultCrypto.ini</code>文件中。</p><h3 id="使用预定义文件加密Pak文件"><a href="#使用预定义文件加密Pak文件" class="headerlink" title="使用预定义文件加密Pak文件"></a>使用预定义文件加密Pak文件</h3><p>在我们对项目进行了打包操作后，UE会根据Project Settings/Crypto/Encryption/中配置生成一个&lt;项目目录&gt;/Saved/Cooked/&lt;平台名称&gt;/&lt;项目名称&gt;/Metadata/Crypto.json文件，这个文件使用Json的格式保存了配置中的信息，以便UnrealPak使用。具体加密指令如下：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">D:<span class="hljs-symbol">\U</span>E_4.26_SourceCode<span class="hljs-symbol">\U</span>nrealEngine-4.26<span class="hljs-symbol">\E</span>ngine<span class="hljs-symbol">\B</span>inaries<span class="hljs-symbol">\W</span>in64<span class="hljs-symbol">\U</span>nrealPak.exe D:<span class="hljs-symbol">\U</span>E4<span class="hljs-symbol">\P</span>aks<span class="hljs-symbol">\P</span>akActor.pak -create=D:<span class="hljs-symbol">\U</span>E4<span class="hljs-symbol">\U</span>nkown<span class="hljs-symbol">\U</span>nkown<span class="hljs-symbol">\S</span>aved<span class="hljs-symbol">\C</span>ooked<span class="hljs-symbol">\W</span>indowsNoEditor<span class="hljs-symbol">\U</span>nkown<span class="hljs-symbol">\C</span>ontent<span class="hljs-symbol">\D</span>LCs -encrypt -encryptindex -compress -cryptokeys=D:<span class="hljs-symbol">\U</span>E4<span class="hljs-symbol">\U</span>nkown<span class="hljs-symbol">\U</span>nkown<span class="hljs-symbol">\S</span>aved<span class="hljs-symbol">\C</span>ooked<span class="hljs-symbol">\W</span>indowsNoEditor<span class="hljs-symbol">\U</span>nkown<span class="hljs-symbol">\M</span>etadata<span class="hljs-symbol">\C</span>rypto.json<br></code></pre></td></tr></table></figure><ul><li>-encrypt : 加密Pak文件；</li><li>-encryptindex : 加密索引，解包时不提供Key无法解包，如果不使用这个参数，解包时就不需要Key也可以解包；</li><li>-compress : 对Pak文件数据进行压缩；</li><li>-cryptokeys : 指向加密需要的带密钥的Json文件；</li></ul><p>更多指令可以参考<a href="https://www.cnblogs.com/shiroe/p/14803859.html">代码质疑人生</a>的这篇博客。</p><p>按理说在Project Settings/Crypto/Encryption/中应该可以对-encrypt和-encryptindex参数进行配置，且在Crypto.json中也都有字段存储，但是似乎在使用UnrealPak打包时依旧需要手动指定，否则加密无效。</p><h3 id="使用自定义文件加密Pak"><a href="#使用自定义文件加密Pak" class="headerlink" title="使用自定义文件加密Pak"></a>使用自定义文件加密Pak</h3><p>-cryptokeys除了可以读取UE打包时自动生成的json文件中的密钥来加密Pak，也可以使用自定义的json文件来加密Pak，只需要json中有一个<code>EncryptionKey</code>对象，对象中有一个<code>Key</code>字段即可，如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br><span class="hljs-attr">&quot;EncryptionKey&quot;</span>:<br>&#123;<br><span class="hljs-attr">&quot;Key&quot;</span>:<span class="hljs-string">&quot;xlTq7RXTF5yhLRkoJd8m9tQMdjxsalROP6DycVf+UNc=&quot;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Json可以有其他的自定义字段。</p><h2 id="6-Pak文件的解密"><a href="#6-Pak文件的解密" class="headerlink" title="6.Pak文件的解密"></a>6.Pak文件的解密</h2><h3 id="使用UnrealPak解密"><a href="#使用UnrealPak解密" class="headerlink" title="使用UnrealPak解密"></a>使用UnrealPak解密</h3><p>使用UnrealPak解密基本和加密是反着来的，当然加密和解密必须使用同一个Key，否者解密会失败。</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">D:<span class="hljs-symbol">\U</span>E_4.26_SourceCode<span class="hljs-symbol">\U</span>nrealEngine-4.26<span class="hljs-symbol">\E</span>ngine<span class="hljs-symbol">\B</span>inaries<span class="hljs-symbol">\W</span>in64<span class="hljs-symbol">\U</span>nrealPak.exe D:<span class="hljs-symbol">\U</span>E4<span class="hljs-symbol">\P</span>aks<span class="hljs-symbol">\P</span>akActor.pak -Extract D:<span class="hljs-symbol">\U</span>E4<span class="hljs-symbol">\P</span>aks<span class="hljs-symbol">\P</span>akContent -cryptokeys=D:<span class="hljs-symbol">\U</span>E4<span class="hljs-symbol">\U</span>nkown<span class="hljs-symbol">\U</span>nkown<span class="hljs-symbol">\S</span>aved<span class="hljs-symbol">\C</span>ooked<span class="hljs-symbol">\W</span>indowsNoEditor<span class="hljs-symbol">\U</span>nkown<span class="hljs-symbol">\M</span>etadata<span class="hljs-symbol">\C</span>rypto.json<br></code></pre></td></tr></table></figure><p>这个指令会把Pak中的文件全部解包成源文件。</p><h3 id="挂载时解密"><a href="#挂载时解密" class="headerlink" title="挂载时解密"></a>挂载时解密</h3><p>在代码中解密Pak包需要用到UE内置的FPakEncryptionKeyDelegate委托，且UE在FCoreDelegates类中已经预制了FPakEncryptionKeyDelegate的对象，可以通过FCoreDelegates::GetPakEncryptionKeyDelegate()函数获取。在UE通过Mount挂载Pak包是会判断Pak有没有加密，如果加密了则使用委托调用绑定的解密函数来获取密钥进而对Pak文件进行密钥验证。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//Mount重载，解密挂载</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">UPakExpand::Mount</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString PakFilePath, <span class="hljs-keyword">const</span> FString CryptoJsonPath)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (CryptoJsonPath.IsEmpty())<br>    &#123;<br>        <span class="hljs-keyword">return</span> Mount(PakFilePath);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        SetEncryptJsonPath(CryptoJsonPath);<br>        <span class="hljs-comment">//UE4预制委托，当挂载Pak包的时候自动调用</span><br>        FCoreDelegates::GetPakEncryptionKeyDelegate().BindUObject(<span class="hljs-keyword">this</span>, &amp;UPakExpand::UnEncrypt);<br>        <span class="hljs-keyword">return</span> Mount(PakFilePath);<br>    &#125;   <br>&#125;<br><span class="hljs-comment">//设置存储密钥的文件路径，之所以要专门设置密钥文件的路径，是因为GetPakEncryptionKeyDelegate()返回的委托是一个返回值为空，参数为uint8*的委托，无法直接往UnEncrypt函数传入文件路径</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UPakExpand::SetEncryptJsonPath</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString CryptoJsonPath)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (FPaths::FileExists(CryptoJsonPath))<br>    &#123;<br>        EncryptJsonPath = CryptoJsonPath;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//读取json文件</span><br><span class="hljs-function">FString <span class="hljs-title">UPakExpand::ReadEncryptKeyStrFromJson</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!FPaths::FileExists(EncryptJsonPath))<br>    &#123;<br>        <span class="hljs-keyword">return</span> FString(TEXT(<span class="hljs-string">&quot;&quot;</span>));<br>    &#125;<br>    FString JsonStr;<br>    FFileHelper::LoadFileToString(JsonStr, *EncryptJsonPath);<br>    TSharedPtr&lt;FJsonObject&gt; JsonObject = MakeShareable(<span class="hljs-keyword">new</span> FJsonObject());<br>    TSharedRef&lt;TJsonReader&lt;&gt;&gt; JsonReader = TJsonReaderFactory&lt;&gt;::Create(JsonStr);<br>    FString KeyStr;<br>    <span class="hljs-keyword">if</span> (FJsonSerializer::Deserialize(JsonReader, JsonObject))<br>    &#123;<br>        TSharedPtr&lt;FJsonObject&gt; EncryptionKey = JsonObject-&gt;GetObjectField(TEXT(<span class="hljs-string">&quot;EncryptionKey&quot;</span>));<br>        KeyStr = EncryptionKey-&gt;GetStringField(TEXT(<span class="hljs-string">&quot;Key&quot;</span>));<br>        <span class="hljs-keyword">return</span> KeyStr;<br>    &#125;<br>    <span class="hljs-keyword">return</span> FString(TEXT(<span class="hljs-string">&quot;&quot;</span>));<br>&#125;<br><span class="hljs-comment">//密钥转码将ascii码下表现为字符串的密钥转换成二进制码</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UPakExpand::UnEncrypt</span><span class="hljs-params">(uint8* Key)</span></span><br><span class="hljs-function"></span>&#123;<br>    FString KeyStr = ReadEncryptKeyStrFromJson();  <br>    TArray&lt;uint8&gt; KeyBase64Ary;<br>    FBase64::Decode(KeyStr, KeyBase64Ary);<br>    FMemory::Memcpy(Key, KeyBase64Ary.GetData(), FAES::FAESKey::KeySize);<br>&#125;<br></code></pre></td></tr></table></figure><p>Pak文件的解密实际上也不难，我们对第三小节Pak挂载的Mount函数进行函数重载，再挂载Pak文件之前先对Pak文件进行解密，这里之所以使用文件的形式来加载密钥而不是直接将密钥定义再代码里是为了更灵活的使不同的Pak包可以使用不同的密钥来加密解密。</p><h2 id="7-Pak加载的优先级"><a href="#7-Pak加载的优先级" class="headerlink" title="7.Pak加载的优先级"></a>7.Pak加载的优先级</h2><p>当同一份资源同时存在于两个pak文件中时，就涉及到资源加载的优先级问题了。</p><h3 id="目录优先级"><a href="#目录优先级" class="headerlink" title="目录优先级"></a>目录优先级</h3><p>我们可以直接从源码入手</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">int32 <span class="hljs-title">FPakPlatformFile::GetPakOrderFromPakFilePath</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString&amp; PakFilePath)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (PakFilePath.StartsWith(FString::Printf(TEXT(<span class="hljs-string">&quot;%sPaks/%s-&quot;</span>), *FPaths::ProjectContentDir(), FApp::GetProjectName())))<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (PakFilePath.StartsWith(FPaths::ProjectContentDir()))<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (PakFilePath.StartsWith(FPaths::EngineContentDir()))<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (PakFilePath.StartsWith(FPaths::ProjectSavedDir()))<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>源码的注释是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* Hardcode default load ordering of game main pak -&gt; game content -&gt; engine content -&gt; saved dir</span><br><span class="hljs-comment">* would be better to make this config but not even the config system is initialized here so we can&#x27;t do that</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> int32 <span class="hljs-title">GetPakOrderFromPakFilePath</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString&amp; PakFilePath)</span></span>;<br></code></pre></td></tr></table></figure><p>UE会在游戏启动时自动挂载某些目录下的Pak文件，分别是&lt;项目目录&gt;/Content/Paks，&lt;引擎目录&gt;/Content/Paks，&lt;项目目录&gt;/Saved/Paks</p><p>这里的项目目录和引擎目录均是打包后游戏根目录下的项目目录和引擎目录。</p><p>三者满足优先级：<code>&lt;项目目录&gt;/Content/Paks</code>  &gt;  <code>&lt;引擎目录&gt;/Content/Paks</code>  &gt;  <code>&lt;项目目录&gt;/Saved/Paks</code>，其中最高优先级为游戏主Pak包，即在&lt;项目目录&gt;/Content/Paks/目录下以项目名开头，由引擎打包出来的Pak文件。</p><p>但是我在实际测试中发现实际加载顺序不是这样的，具体原因未知。</p><p>我分别在三个目录下放入一个内容相同而名字不同的三个Pak文件，通过日志看看挂载顺序：</p><p>Pak位置情况：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127140030.png"></p><p>Pak加载日志，exe运行后会在/游戏根目录/Saved/Logs/目录下生成运行日志，其中<code>项目名称.log</code>为最新的日志：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127140034.png"></p><p>可以看到，位于&lt;项目目录&gt;/Saved/Paks/PakActor_3.pak最先加载，而游戏主Pak包/&lt;项目目录&gt;/Content/Paks/Unkown-WindowsNoEditor.pak第二加载，/&lt;项目目录&gt;/Content/Paks/PakActor_1.pak第三加载，/&lt;引擎目录&gt;/Content/Paks/PakActor_2.pak最后加载。</p><p>加载顺序似乎有出入，目前未找到原因，不过一般不影响正常游戏流程。</p><h3 id="二级优先级"><a href="#二级优先级" class="headerlink" title="二级优先级"></a>二级优先级</h3><p>在满足目录优先级的情况下，UE还增加了Pak文件名以<code>_P.pak</code>结尾的二级优先级，如：Pak_P.pak的优先级就要高于Pak.pak，而Pak_1_P.pak的优先级又高于Pak_P.pak，Pak_2_P.pak高于Pak_1_P.pak，以此类推。来实践验证一下。</p><p>前面有说过，在PakActor蓝图中创建了一个黑色的PakWidget界面，现在把PakWidget界面设置成白色，然后再打一个包，重命名为“PakActor_1_P.pak”，一并放入Content/DLCs目录下，这里还需要对挂载做一点改动，即把DLCs目录下的Pak文件都挂载起来，所以我们往UPakExpaned类中新增一个函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">TArray&lt;FString&gt; <span class="hljs-title">UPakExpand::GetAllPakFromDir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString Dir, <span class="hljs-keyword">bool</span>&amp; Result)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">FString <span class="hljs-title">PakDir</span><span class="hljs-params">(FPaths::ProjectContentDir() + Dir + TEXT(<span class="hljs-string">&quot;/&quot;</span>))</span></span>;<br>    IFileManager&amp; FileManager = IFileManager::Get();<br>    TArray&lt;FString&gt; ResultList;<br>    <span class="hljs-keyword">if</span> (FileManager.DirectoryExists(*PakDir))<br>    &#123;<br>        TArray&lt;FString&gt; PakList;      <br>        FileManager.FindFiles(PakList, *PakDir,TEXT(<span class="hljs-string">&quot;*.pak&quot;</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; PakList.Num(); i++)<br>        &#123;<br>            <span class="hljs-function">FString <span class="hljs-title">PakFilePath</span><span class="hljs-params">(PakDir + PakList[i])</span></span>;<br>            ResultList.Add(PakFilePath);<br>        &#125;<br>        Result = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ResultList.Num() &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        Result = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ResultList;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后再UnkGameInstance中对挂载步骤进行改进：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127140041.png"></p><p>Mount节点的CryptoJsonPath参数可以忽略，这是用来解密加密Pak包的。</p><p>Pak包位置：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127140047.png"></p><p>好，运行一下试试</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127140050.png"></p><p>可以看到加载的PakActor已经是PakActor_1_P.pak中的资源了。</p><h2 id="8-以DLC的形式进行资源更新"><a href="#8-以DLC的形式进行资源更新" class="headerlink" title="8.以DLC的形式进行资源更新"></a>8.以DLC的形式进行资源更新</h2><p>DLC的形式与pak包的形式不同的只在于pak包的生成方式，pak包是直接使用命令行烘培和打包的，而DLC则是使用的ProjectLauncher，最终资源都是以pak包的形式下载到本地，只是pak的形式需要我们手动写C++代码挂载，而DLC的形式将pak文件放到指定文件夹内可自动挂载并加载。</p><p>用DLC的形式需要配置两个ProjectLauncher，一个为打包本地的ProjectLauncher，一个为打包DLC的ProjectLauncher，具体配置方法见<a href="http://mingchuan.wang/2016/09/20/UE4-DLC/">wmc的一篇博文</a>。</p><h1 id="五、FCachedReadPlatformFile"><a href="#五、FCachedReadPlatformFile" class="headerlink" title="五、FCachedReadPlatformFile"></a>五、FCachedReadPlatformFile</h1><p>FCachedReadPlatformFile实现了文件的预读写逻辑，FCachedReadPlatformFile对IPlatformFile的修改主要是在OpenRead和OpenWrite的返回值中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">virtual</span> IFileHandle*<span class="hljs-title">OpenRead</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Filename, <span class="hljs-keyword">bool</span> bAllowWrite)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function"></span>&#123;<br>IFileHandle* InnerHandle=LowerLevel-&gt;OpenRead(Filename, bAllowWrite);<br><span class="hljs-keyword">if</span> (!InnerHandle)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FCachedFileHandle(InnerHandle, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> IFileHandle*<span class="hljs-title">OpenWrite</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Filename, <span class="hljs-keyword">bool</span> bAppend = <span class="hljs-literal">false</span>, <span class="hljs-keyword">bool</span> bAllowRead = <span class="hljs-literal">false</span>)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function"></span>&#123;<br>IFileHandle* InnerHandle=LowerLevel-&gt;OpenWrite(Filename, bAppend, bAllowRead);<br><span class="hljs-keyword">if</span> (!InnerHandle)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FCachedFileHandle(InnerHandle, bAllowRead, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>二者的返回值不再是IFileHanle而是其子类FCachedFileHandle，预读逻辑就在FCachedFileHandle中，每次预读64k的数据到一个缓存块，这个类应该是给一些为做预读取优化的平台使用的，而像Windows和PS4这些平台本身就对文件读取做了预读取的平台，UE是默认启用FCachedReadPlatformFile的，即在文件的责任链中是没有FCachedReadPlatformFile节点的，当然我们也可以通过可通过<code>NoCachedReadFile</code>参数和<code>CachedReadFile</code>参数强行关闭或启用。</p><p>个人认为，FCachedReadPlatformFile的使用就是将FCachedReadPlatformFile设置进责任链中，在读取文件时上层抛到FCachedReadPlatformFile时就进行预读取处理。实践验证由于我是Windows平台还想到什么好的验证方法，也就没验证了。</p><h1 id="六、FLoggedPlatformFile"><a href="#六、FLoggedPlatformFile" class="headerlink" title="六、FLoggedPlatformFile"></a>六、FLoggedPlatformFile</h1><p>FLoggedPlatformFile包装类会把每一次对文件的操作都通过UE_LOG使用LogPlatformFile打印到日志中去，使用方法也是将FLoggedPlatformFile对象设置进责任链中，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UPakExpand::ReadFile</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString FilePath)</span></span><br><span class="hljs-function"></span>&#123;<br>    TSharedPtr&lt;FLoggedPlatformFile&gt; LoggedPlatformFile = MakeShareable(<span class="hljs-keyword">new</span> FLoggedPlatformFile());<br>    IPlatformFile&amp; PlatformFile = FPlatformFileManager::Get().GetPlatformFile();<br>    LoggedPlatformFile-&gt;Initialize(PlatformFile, TEXT(<span class="hljs-string">&quot;&quot;</span>));<br>    FPlatformFileManager::Get().SetPlatformFile(*LoggedPlatformFile);<br>    FString FileData;<br>    FFileHelper::LoadFileToString(FileData, *FilePath);<br>    FileData = TEXT(<span class="hljs-string">&quot;this is write data&quot;</span>);<br>    FFileHelper::SaveStringToFile(FileData, *FilePath);<br>    FPlatformFileManager::Get().SetPlatformFile(*PlatformFile);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在UnkGameInstance中调用，运行，打开日志搜索LogPlatformFile：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127140100.png"></p><p>可以看到对文件的读写关闭等操作多被打印进了日志中。</p><h1 id="七、FPlatformFileOpenLog"><a href="#七、FPlatformFileOpenLog" class="headerlink" title="七、FPlatformFileOpenLog"></a>七、FPlatformFileOpenLog</h1><p>FPlatformFileOpenLog包装类的功能、用法和FLoggedPlatformFile类似，FPlatformFileOpenLog类只会记录文件的打开历史，并且在编辑器模式下运行使用单独的EditorOpenOrder.log文件保存，在非Shipping版本的游戏包中使用GameOpenOrder.log文件保存，在Shipping版本的有游戏包中不能使用。在编辑模式下的EditorOpenOrder.log文件保存在&lt;项目目录&gt;\Build\Windows\FileOpenOrder，在Game模式下的GameOpenOrder.log文件保存在&lt;游戏目录&gt;\Build\WindowsNoEditor\FileOpenOrder下。</p><p>现在我们把上面的ReadFile函数修改一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UPlatformFileExpand::ReadFile</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString FilePath)</span></span><br><span class="hljs-function"></span>&#123;<br>    TSharedPtr&lt;FPlatformFileOpenLog&gt; PlatformFileOpenLog = MakeShareable(<span class="hljs-keyword">new</span> FPlatformFileOpenLog());<br>    IPlatformFile&amp; PlatformFile = FPlatformFileManager::Get().GetPlatformFile();<br>    PlatformFileOpenLog-&gt;Initialize(PlatformFile, TEXT(<span class="hljs-string">&quot;&quot;</span>));<br>    FPlatformFileManager::Get().SetPlatformFile(*PlatformFileOpenLog);<br>    FString FileData;<br>    FFileHelper::LoadFileToString(FileData, *FilePath);<br>    DEBUGLOG(FEnumSet::DebugLogType::Log, (TEXT(<span class="hljs-string">&quot;Read file data:&quot;</span>) + FileData));<br>    FileData = TEXT(<span class="hljs-string">&quot;this is write data&quot;</span>);<br>    FFileHelper::SaveStringToFile(FileData, *FilePath);<br>    FPlatformFileManager::Get().SetPlatformFile(*PlatformFile);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后打开</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127140105.png"></p><p>不过后面的数字代表什么意思，暂时还没弄明白，无论重启多少次exe，或在一次启动中打开多次同一文件，后面的数字始终是1。</p><h1 id="八、FNetworkPlatformFile、FCookedIterativeNetworkFile和FStreamingNetworkPlatformFile"><a href="#八、FNetworkPlatformFile、FCookedIterativeNetworkFile和FStreamingNetworkPlatformFile" class="headerlink" title="八、FNetworkPlatformFile、FCookedIterativeNetworkFile和FStreamingNetworkPlatformFile"></a>八、FNetworkPlatformFile、FCookedIterativeNetworkFile和FStreamingNetworkPlatformFile</h1><h2 id="1-FNetworkPlatformFile"><a href="#1-FNetworkPlatformFile" class="headerlink" title="1.FNetworkPlatformFile"></a>1.FNetworkPlatformFile</h2><p>这三个包装文件类都是用于实现网络文件的读取功能，当UE要打开某个文件，而文件却不存在时，则先查看是否连接了文件服务器，连接了则从文件服务器下载文件到本地然后再打开。</p><p>源码中的描述是：用于将低级文件系统重定向到服务器的包装器。</p><p>FCookedIterativeNetworkFile和FStreamingNetworkPlatformFile的初始化函数和前面的包装文件类有所不同：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">InitializeInternal</span><span class="hljs-params">(IPlatformFile* Inner, <span class="hljs-keyword">const</span> TCHAR* HostIP)</span> <span class="hljs-keyword">override</span></span>;<br></code></pre></td></tr></table></figure><p>不仅要指定下层文件类对象，还要指定服务器端口地址，HostIP可以使用<code>tcp://</code>开头指定tcp通信协议，使用<code>http://</code>指定http通信协议，不指定则默认使用tcp，同时可以使用<code>+</code>号分隔来指定多个Host地址，初始化后UE会将本地文件与服务器文件做出映射，以便在本地没有找到文件时能快速的找到服务器中对应的文件，同时在Tick函数中会通过PerformHeartbeat函数监测服务器文件的更新，使本地文件与服务器文件保持一致。</p><p>三者具有优先级，优先级为：FStreamingNetworkPlatformFile<code>&gt;</code>FCookedIterativeNetworkFile<code>&gt;</code>FNetworkPlatformFile</p><p>且在Shipping版本中被禁止使用。</p><p>不是所有的目录下的文件都会在没读取到时去文件服务器下载，在源码中有一个LocalDirectories数组记录着只会进行本地读取的目录：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Save and Intermediate directories are always local</span><br>LocalDirectories.Add(FPaths::EngineDir() / TEXT(<span class="hljs-string">&quot;Binaries&quot;</span>));<br>LocalDirectories.Add(FPaths::EngineIntermediateDir());<br>LocalDirectories.Add(FPaths::ProjectDir() / TEXT(<span class="hljs-string">&quot;Binaries&quot;</span>));<br>LocalDirectories.Add(FPaths::ProjectIntermediateDir());<br>LocalDirectories.Add(FPaths::ProjectSavedDir() / TEXT(<span class="hljs-string">&quot;Backup&quot;</span>));<br>LocalDirectories.Add(FPaths::ProjectSavedDir() / TEXT(<span class="hljs-string">&quot;Config&quot;</span>));<br>LocalDirectories.Add(FPaths::ProjectSavedDir() / TEXT(<span class="hljs-string">&quot;Logs&quot;</span>));<br>LocalDirectories.Add(FPaths::ProjectSavedDir() / TEXT(<span class="hljs-string">&quot;Sandboxes&quot;</span>));<br></code></pre></td></tr></table></figure><p>分别是引擎目录下的Binaries，Intermediate目录，项目目录下的Binaries，Intermediate，Saved/Backup，Saved/Config，Saved/Logs，Saved/SandBoxes目录。</p><h2 id="2-FCookedIterativeNetworkFile"><a href="#2-FCookedIterativeNetworkFile" class="headerlink" title="2.FCookedIterativeNetworkFile"></a>2.FCookedIterativeNetworkFile</h2><p>FCookedIterativeNetworkFile在FNetworkPlatformFile的基础上增加了，本地Pak文件绕过网络访问的机制，如在某次更新中有些Pak文件未做修改，可以不更新，尽管服务器中这些Pak文件的版本号更高了，但是由于内容未做更改所以可以使用FCookedIterativeNetworkFile直接绕过更新。</p><h2 id="3-FStreamingNetworkPlatformFile"><a href="#3-FStreamingNetworkPlatformFile" class="headerlink" title="3.FStreamingNetworkPlatformFile"></a>3.FStreamingNetworkPlatformFile</h2><p>FStreamingNetworkPlatformFile在FNetworkPlatformFile的基础上实现了对服务器的流式访问，和FNetworkPlatformFile不能对服务器文件进行修改不同，FStreamingNetworkPlatformFile可以直接修改服务器上的文件，FStreamingNetworkPlatformFile对文件的访问操作均是直接操作的服务器文件。</p><p>这里引用<a href="https://dhbloo.github.io/2020/09/07/UE4-FileSystem/#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%88%9B%E5%BB%BA">dhb</a>大佬博客的一段原话：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl">打开文件的<span class="hljs-function"><span class="hljs-title">OpenRead</span>()、<span class="hljs-title">OpenWrite</span>()函数使用<span class="hljs-title">SendOpenMessage</span>()通知服务器打开文件，服务器会返回一个文件的句柄<span class="hljs-variable">ID</span>，后续对该文件的操作以这个句柄<span class="hljs-variable">ID</span>作为标识。在接口配套定义的<span class="hljs-variable">FStreamingNetworkFileHandle</span>文件句柄中，<span class="hljs-title">Read</span>()、<span class="hljs-title">Write</span>()等操作都被转换到对服务器发送消息，分别在<span class="hljs-title">SendReadMessage</span>()与<span class="hljs-title">SendWriteMessage</span>()中。这样，对文件的读取实时从服务器获得（每次网络传输以<span class="hljs-number">64</span><span class="hljs-variable">KB</span>的块为单位进行，进行缓存），而对文件的写入则实时发送到服务器。</span><br></code></pre></td></tr></table></figure><h1 id="九、FSandboxPlatformFile"><a href="#九、FSandboxPlatformFile" class="headerlink" title="九、FSandboxPlatformFile"></a>九、FSandboxPlatformFile</h1><h2 id="1-什么是沙盒"><a href="#1-什么是沙盒" class="headerlink" title="1.什么是沙盒"></a>1.什么是沙盒</h2><p>FSandboxPlatformFile是UE实现的一个简单的沙盒机制，首先我们需要了解什么是沙盒：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">沙盒机制是内存空间访问的一种安全机制，一个应用程序被分配到专属于自己的存储空间，程序只能在自己的空间中访问内存，不可以越过边界访问外部内存，这个区域就叫沙盒。<br></code></pre></td></tr></table></figure><h2 id="2-FSandboxPlatformFile的使用"><a href="#2-FSandboxPlatformFile的使用" class="headerlink" title="2.FSandboxPlatformFile的使用"></a>2.FSandboxPlatformFile的使用</h2><p>FSandboxPLatformFile的使用需要在.Build.cs中添加<code>SandBoxFile</code>模块，且FSandboxPlatformFile的构造函数不是公有的，需要使用FSandboxPLatformFile::Create函数来创建TUniquePtr指针来使用。</p><p>关于FSandboxPlatformFile的使用网上的资料几乎为零，在官方文档也只找到了类的描述，没办法还得自己上手撸源码。</p><p>首先先上一段自己写的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UPlatformFileExpand::ReadFile</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString FilePath)</span></span><br><span class="hljs-function"></span>&#123;<br>    TUniquePtr&lt;FSandboxPlatformFile&gt; SandboxPlatformFile = FSandboxPlatformFile::Create(<span class="hljs-literal">true</span>);<br>    IPlatformFile&amp; PlatformFile = FPlatformFileManager::Get().GetPlatformFile();<br>    SandboxPlatformFile-&gt;Initialize(&amp;PlatformFileTmp, TEXT(<span class="hljs-string">&quot;-Sandbox=Unique&quot;</span>));<br>    SandboxPlatformFile-&gt;SetSandboxEnabled(<span class="hljs-literal">true</span>);<br>    FPlatformFileManager::Get().SetPlatformFile(*SandboxPlatformFile);<br>    FString FileData;<br>    FFileHelper::LoadFileToString(FileData, *FilePath);<br>    FPlatformFileManager::Get().SetPlatformFile(PlatformFile);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Initialize：FSandboxPlatformFile的初始化需要添加命令行参数，<code>-sandbox=</code>，看源码可以看出UE提供多种沙盒类型：</li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FSandboxPlatformFile::Initialize</span><span class="hljs-params">(IPlatformFile* Inner, <span class="hljs-keyword">const</span> TCHAR* CmdLine)</span></span><br><span class="hljs-function"></span>&#123;<br>FString CommandLineDirectory;<br>FParse::Value( CmdLine, TEXT(<span class="hljs-string">&quot;-Sandbox=&quot;</span>), CommandLineDirectory);<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">if</span> (LowerLevel != <span class="hljs-literal">NULL</span> &amp;&amp; !CommandLineDirectory.IsEmpty())<br>&#123;<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">if</span>( CommandLineDirectory == TEXT(<span class="hljs-string">&quot;User&quot;</span>) )<br>&#123;<br><span class="hljs-comment">// Special case - platform defined user directory will be used</span><br>SandboxDirectory = FPlatformProcess::UserDir();<br>SandboxDirectory += TEXT(<span class="hljs-string">&quot;My Games/&quot;</span>);<br>SandboxDirectory += TEXT( <span class="hljs-string">&quot;UE4/&quot;</span> );<br>bSandboxIsAbsolute = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( CommandLineDirectory == TEXT(<span class="hljs-string">&quot;Unique&quot;</span>) )<br>&#123;<br><span class="hljs-keyword">const</span> FString Path = FPaths::GetRelativePathToRoot() / TEXT(<span class="hljs-string">&quot;&quot;</span>);<br>SandboxDirectory = FPaths::ConvertToSandboxPath( Path, *FGuid::NewGuid().ToString() );<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (CommandLineDirectory.StartsWith(TEXT(<span class="hljs-string">&quot;..&quot;</span>)))<br>&#123;<br><span class="hljs-comment">// for relative-specified directories, just use it directly, and don&#x27;t put into FPaths::ProjectSavedDir()</span><br>SandboxDirectory = CommandLineDirectory;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( FPaths::IsDrive( CommandLineDirectory.Mid( <span class="hljs-number">0</span>, CommandLineDirectory.Find(TEXT(<span class="hljs-string">&quot;/&quot;</span>), ESearchCase::CaseSensitive) ) ) == <span class="hljs-literal">false</span> ) <br>&#123;<br><span class="hljs-keyword">const</span> FString Path = FPaths::GetRelativePathToRoot() / TEXT(<span class="hljs-string">&quot;&quot;</span>);<br>SandboxDirectory = FPaths::ConvertToSandboxPath( Path, *CommandLineDirectory );<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>SandboxDirectory = CommandLineDirectory;<br>bSandboxIsAbsolute = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>  -Sandbox=可以指定<code>User</code>，<code>Unique</code>，<code>..</code>，<code>自定义目录</code>等参数。</p><ul><li><p><code>User</code>：在用户用户目录下创建沙盒目录，如：C:/Users/admin/Documents/My Games/UE4/Unkown/GitToken.txt</p></li><li><p><code>Unique</code>：在项目目录/Saved目录下使用唯一的编码创建沙盒目录，如：D:/UE4/Unkown/Unkown/Saved/Sandboxes/260659334D930AEACA179EB8977A20F8/Unkown/GitToken.txt</p></li><li><p><code>..</code>：在引擎目录/Binaries目录下创建沙盒目，如：D:/UnrealEngine-4.26/Engine/Binaries/Unkown/GitToken.txt</p></li><li><p><code>自定义参数</code>：使用在自定义目录下作为沙盒目录，如：D:/UESandbox/Unkown/GitToken.txt</p><p><font color="red"> 需要注意的是，这里所说的沙盒目录在实际物理文件夹下是不存在的，这里的目录只是作为一个安全边界来使用。</font></p></li><li><p>FPlatformFileManager::Get().SetPlatformFile(PlatformFile)：这里之所以要把责任链的链头还原回去是因为如果我不设置回去会导致崩溃，<font color="red">这里就有一个疑问了，既然必须要用的时候把沙盒添加到链头，用完了有必须还原回去，那么在还原回去之后，文件依然可以使用非沙盒模式去读取，所以这里使用沙盒又有什么意义呢？</font></p></li></ul><h2 id="3-FSandboxPlatformFile的原理"><a href="#3-FSandboxPlatformFile的原理" class="headerlink" title="3.FSandboxPlatformFile的原理"></a>3.FSandboxPlatformFile的原理</h2><p>FSandboxPlatformFile的核心就是ConvertToSandboxPath()<code>、</code>ConvertFromSandboxPath()，在访问文件时FSandboxPlatformFile会直接将访问文件的路径替换为沙盒路径来使用，使程序处于沙盒模式下无法通过非沙盒路径读写文件。</p><h1 id="十、FPlatformFileReadStats和FProfiledPlatformFile"><a href="#十、FPlatformFileReadStats和FProfiledPlatformFile" class="headerlink" title="十、FPlatformFileReadStats和FProfiledPlatformFile"></a>十、FPlatformFileReadStats和FProfiledPlatformFile</h1><p>FPlatformFileReadStats用于记录文件读取的速度，FProfiledPlatformFile用于记录文件操作得速度，不过这两个类在4.26中似乎已经废弃了，在源码中搜索不到这个类，官方文档也是个404页面。</p><h1 id="十一、FFileHelper"><a href="#十一、FFileHelper" class="headerlink" title="十一、FFileHelper"></a>十一、FFileHelper</h1><p>FFileHelper是UE最顶的文本文件处理类了，提供一系列接口用于处理文本文件，最神奇的是FFileHelper是一个结构体。</p><ul><li><p>BufferToString：从缓冲中读取内容到字符串，适用于比较大的文本，无法一次性把文本都读取到字符串时，使用缓冲分批读取；</p></li><li><p>LoadFileToArray：以二进制的形式一次性加载文本全部内容到一个unit8数组；</p></li><li><p>LoadFileToString：以字符串的形式一次性加载文本的全部内容到一个字符串中；</p></li><li><p>LoadFileToStringArray：以字符串的形式按行加载文本到FString数组中，数组中每一个元素存储文本中一行的文本；</p></li><li><p>LoadFileToStringArrayWithPredicate：以字符串的形式同时使用谓词对文本进行筛选后再加载到FString数组中，数组中每一个元素存储文本中一行的文本；</p><p>按照C++的用法，函数指针既可以指向一个Lambda表达式也是可以指向一个实际的函数的，指向实际的函数时只能使用静态函数；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//使用Lambda表达式</span><br>FFileHelper::LoadFileToStringArrayWithPredicate(Result, *FilePath, [](<span class="hljs-keyword">const</span> FString&amp; Item) &#123;<span class="hljs-keyword">return</span> Item.Contains(TEXT(<span class="hljs-string">&quot;Sandbox&quot;</span>)); &#125;);<br><br><span class="hljs-comment">//使用实际函数</span><br>TFunction&lt;<span class="hljs-keyword">bool</span>(<span class="hljs-keyword">const</span> FString&amp;)&gt; Fun = UPlatformFileExpand::Filter;<br>FFileHelper::LoadFileToStringArrayWithPredicate(Result, *FilePath, Fun);<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Filter</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString&amp; Item)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> Item.Contains(TEXT(<span class="hljs-string">&quot;Sandbox&quot;</span>));<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><ul><li><p>SaveArrayToFile：有两个中类型的重载，一个传入<code>TArrayView&lt;const uint8&gt;</code>类型的参数，一个是传入<code>TArray64&lt;uint8&gt;</code>类型的参数，二者都是TArray的变种，使用方法和TArray基本一致，只是内部构造可能有些不同；</p></li><li><p>SaveStringToFile：把字符串保存到文本文件，可以在字符转中使用<code>\n</code>来对写入的内容进行换行；</p></li><li><p>SaveStringArrayToFile：将String数组元素按行写入到文本文件，一个元素对应一行；</p></li><li><p>CreateBitmap：创建一个bmp图片，其中FColor*参数需要使用一个C++数组；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">FColor color[<span class="hljs-number">20</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>&#123;<br>    color[i] = FColor::Red;<br>&#125;<br>FFileHelper::CreateBitmap(*FilePath, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>, color);<br></code></pre></td></tr></table></figure></li><li><p>GenerateNextBitmapFilename、GenerateDateTimeBasedBitmapFilename：这两个函数从源码来看就是创建一个指定后缀的唯一的文件来存储位图文件，但是并没有创建实际的文件，没搞懂使用来干嘛的；</p></li><li><p>LoadANSITextFileToStrings：专门用来加载ANSI编码的文件；</p></li><li><p>IsFilenameValidForSaving：判断文件是否可用。</p></li></ul><h1 id="十二、FPaths"><a href="#十二、FPaths" class="headerlink" title="十二、FPaths"></a>十二、FPaths</h1><p>FPaths是UE专门用于处理文件路径的封装类，一般文件访问都绕不开FPaths，FPath记录着各种常用的项目、引擎等的目录。</p><ul><li><p>提供路径的接口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs c++">DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;LaunchDir:&quot;</span>) + FPaths::LaunchDir()));<br><span class="hljs-comment">//&gt; LaunchDir:D:\Goulandis\UE4\Unkown\Unkown\Intermediate\ProjectFiles/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;EngineDir:&quot;</span>) + FPaths::EngineDir()));<br><span class="hljs-comment">//&gt; EngineDir:../../../Engine/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;EngineUserDir:&quot;</span>) + FPaths::EngineUserDir()));<br><span class="hljs-comment">//&gt; EngineUserDir:../../../Engine/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;EngineVersionAgnosticUserDir:&quot;</span>) + FPaths::EngineVersionAgnosticUserDir()));<br><span class="hljs-comment">//&gt; EngineVersionAgnosticUserDir:../../../Engine/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;EngineContentDir:&quot;</span>) + FPaths::EngineContentDir()));<br><span class="hljs-comment">//&gt; EngineContentDir:../../../Engine/Content/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;EngineConfigDir:&quot;</span>) + FPaths::EngineConfigDir()));<br><span class="hljs-comment">//&gt; EngineConfigDir:../../../Engine/Config/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;EngineEditorSettingsDir:&quot;</span>) + FPaths::EngineEditorSettingsDir()));<br><span class="hljs-comment">//&gt; EngineEditorSettingsDir:../../../Engine/Saved/Config/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;EngineIntermediateDir:&quot;</span>) + FPaths::EngineIntermediateDir()));<br><span class="hljs-comment">//&gt; EngineIntermediateDir:../../../Engine/Intermediate/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;EngineSavedDir:&quot;</span>) + FPaths::EngineSavedDir()));<br><span class="hljs-comment">//&gt; EngineSavedDir:../../../Engine/Saved/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;EnginePluginsDir:&quot;</span>) + FPaths::EnginePluginsDir()));<br><span class="hljs-comment">//&gt; EnginePluginsDir:../../../Engine/Plugins/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;EngineDefaultLayoutDir:&quot;</span>) + FPaths::EngineDefaultLayoutDir()));<br><span class="hljs-comment">//&gt; EngineDefaultLayoutDir:../../../Engine/Config/Layouts/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;EngineProjectLayoutDir:&quot;</span>) + FPaths::EngineProjectLayoutDir()));<br><span class="hljs-comment">//&gt; EngineProjectLayoutDir:../../../../../Goulandis/UE4/Unkown/Unkown/Config/Layouts/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;EngineUserLayoutDir:&quot;</span>) + FPaths::EngineUserLayoutDir()));<br><span class="hljs-comment">//&gt; EngineUserLayoutDir:../../../Engine/Saved/Config/Layouts/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;EnterpriseDir:&quot;</span>) + FPaths::EnterpriseDir()));<br><span class="hljs-comment">//&gt; EnterpriseDir:D:/UE_4.26_SourceCode/UnrealEngine-4.26/Enterprise/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;EnterprisePluginsDir:&quot;</span>) + FPaths::EnterprisePluginsDir()));<br><span class="hljs-comment">//&gt; EnterprisePluginsDir:D:/UE_4.26_SourceCode/UnrealEngine-4.26/Enterprise/Plugins/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;EnterpriseFeaturePackDir:&quot;</span>) + FPaths::EnterpriseFeaturePackDir()));<br><span class="hljs-comment">//&gt; EnterpriseFeaturePackDir:D:/UE_4.26_SourceCode/UnrealEngine-4.26/Enterprise/FeaturePacks/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;EnginePlatformExtensionsDir:&quot;</span>) + FPaths::EnginePlatformExtensionsDir()));<br><span class="hljs-comment">//&gt; EnginePlatformExtensionsDir:../../../Engine/Platforms/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;ProjectPlatformExtensionsDir:&quot;</span>) + FPaths::ProjectPlatformExtensionsDir()));<br><span class="hljs-comment">//&gt; ProjectPlatformExtensionsDir:../../../../../Goulandis/UE4/Unkown/Unkown/Platforms/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;RootDir:&quot;</span>) + FPaths::RootDir()));<br><span class="hljs-comment">//&gt; RootDir:D:/UE_4.26_SourceCode/UnrealEngine-4.26/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;ProjectDir:&quot;</span>) + FPaths::ProjectDir()));<br><span class="hljs-comment">//&gt; ProjectDir:../../../../../Goulandis/UE4/Unkown/Unkown/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;ProjectUserDir:&quot;</span>) + FPaths::ProjectUserDir()));<br><span class="hljs-comment">//&gt; ProjectUserDir:../../../../../Goulandis/UE4/Unkown/Unkown/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;ProjectContentDir:&quot;</span>) + FPaths::ProjectContentDir()));<br><span class="hljs-comment">//&gt; ProjectContentDir:../../../../../Goulandis/UE4/Unkown/Unkown/Content/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;ProjectConfigDir:&quot;</span>) + FPaths::ProjectConfigDir()));<br><span class="hljs-comment">//&gt; ProjectConfigDir:../../../../../Goulandis/UE4/Unkown/Unkown/Config/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;ProjectSavedDir:&quot;</span>) + FPaths::ProjectSavedDir()));<br><span class="hljs-comment">//&gt; ProjectSavedDir:../../../../../Goulandis/UE4/Unkown/Unkown/Saved/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;ProjectIntermediateDir:&quot;</span>) + FPaths::ProjectIntermediateDir()));<br><span class="hljs-comment">//&gt; ProjectIntermediateDir:../../../../../Goulandis/UE4/Unkown/Unkown/Intermediate/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;ShaderWorkingDir:&quot;</span>) + FPaths::ShaderWorkingDir()));<br><span class="hljs-comment">//&gt; ShaderWorkingDir:C:/Users/admin/AppData/Local/Temp/UnrealShaderWorkingDir/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;ProjectPluginsDir:&quot;</span>) + FPaths::ProjectPluginsDir()));<br><span class="hljs-comment">//&gt; ProjectPluginsDir:../../../../../Goulandis/UE4/Unkown/Unkown/Plugins/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;ProjectModsDir:&quot;</span>) + FPaths::ProjectModsDir()));<br><span class="hljs-comment">//&gt; ProjectModsDir:../../../../../Goulandis/UE4/Unkown/Unkown/Mods/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;ProjectPersistentDownloadDir:&quot;</span>) + FPaths::ProjectPersistentDownloadDir()));<br><span class="hljs-comment">//&gt; ProjectPersistentDownloadDir:../../../../../Goulandis/UE4/Unkown/Unkown/Saved/PersistentDownloadDir</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;SourceConfigDir:&quot;</span>) + FPaths::SourceConfigDir()));<br><span class="hljs-comment">//&gt; SourceConfigDir:../../../../../Goulandis/UE4/Unkown/Unkown/Config/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;GeneratedConfigDir:&quot;</span>) + FPaths::GeneratedConfigDir()));<br><span class="hljs-comment">//&gt; GeneratedConfigDir:../../../../../Goulandis/UE4/Unkown/Unkown/Saved/Config/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;SandboxesDir:&quot;</span>) + FPaths::SandboxesDir()));<br><span class="hljs-comment">//&gt; SandboxesDir:../../../../../Goulandis/UE4/Unkown/Unkown/Saved/Sandboxes</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;ProfilingDir:&quot;</span>) + FPaths::ProfilingDir()));<br><span class="hljs-comment">//&gt; ProfilingDir:../../../../../Goulandis/UE4/Unkown/Unkown/Saved/Profiling/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;ScreenShotDir:&quot;</span>) + FPaths::ScreenShotDir()));<br><span class="hljs-comment">//&gt; ScreenShotDir:../../../../../Goulandis/UE4/Unkown/Unkown/Saved/Screenshots/Windows/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;BugItDir:&quot;</span>) + FPaths::BugItDir()));<br><span class="hljs-comment">//&gt; BugItDir:../../../../../Goulandis/UE4/Unkown/Unkown/Saved/BugIt/Windows/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;VideoCaptureDir:&quot;</span>) + FPaths::VideoCaptureDir()));<br><span class="hljs-comment">//&gt; VideoCaptureDir:../../../../../Goulandis/UE4/Unkown/Unkown/Saved/VideoCaptures/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;ProjectLogDir:&quot;</span>) + FPaths::ProjectLogDir()));<br><span class="hljs-comment">//&gt; ProjectLogDir:../../../../../Goulandis/UE4/Unkown/Unkown/Saved/Logs/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;AutomationDir:&quot;</span>) + FPaths::AutomationDir()));<br><span class="hljs-comment">//&gt; AutomationDir:../../../../../Goulandis/UE4/Unkown/Unkown/Saved/Automation/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;AutomationTransientDir:&quot;</span>) + FPaths::AutomationTransientDir()));<br><span class="hljs-comment">//&gt; AutomationTransientDir:../../../../../Goulandis/UE4/Unkown/Unkown/Saved/Automation/Tmp/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;AutomationReportsDir:&quot;</span>) + FPaths::AutomationReportsDir()));<br><span class="hljs-comment">//&gt; AutomationReportsDir:../../../../../Goulandis/UE4/Unkown/Unkown/Saved/Automation/Reports/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;AutomationLogDir:&quot;</span>) + FPaths::AutomationLogDir()));<br><span class="hljs-comment">//&gt; AutomationLogDir:../../../../../Goulandis/UE4/Unkown/Unkown/Saved/Automation/Logs/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;CloudDir:&quot;</span>) + FPaths::CloudDir()));<br><span class="hljs-comment">//&gt; CloudDir:../../../../../Goulandis/UE4/Unkown/Unkown/Saved/Cloud/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;GameDevelopersDir:&quot;</span>) + FPaths::GameDevelopersDir()));<br><span class="hljs-comment">//&gt; GameDevelopersDir:../../../../../Goulandis/UE4/Unkown/Unkown/Content/Developers/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;GameUserDeveloperFolderName:&quot;</span>) + FPaths::GameUserDeveloperFolderName()));<br><span class="hljs-comment">//&gt; GameUserDeveloperFolderName:admin</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;GameUserDeveloperDir:&quot;</span>) + FPaths::GameUserDeveloperDir()));<br><span class="hljs-comment">//&gt; GameUserDeveloperDir:../../../../../Goulandis/UE4/Unkown/Unkown/Content/Developers/admin/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;DiffDir:&quot;</span>) + FPaths::DiffDir()));<br><span class="hljs-comment">//&gt; DiffDir:../../../../../Goulandis/UE4/Unkown/Unkown/Saved/Diff/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;GameAgnosticSavedDir:&quot;</span>) + FPaths::GameAgnosticSavedDir()));<br><span class="hljs-comment">//&gt; GameAgnosticSavedDir:../../../Engine/Saved/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;EngineSourceDir:&quot;</span>) + FPaths::EngineSourceDir()));<br><span class="hljs-comment">//&gt; EngineSourceDir:../../../Engine/Source/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;GameSourceDir:&quot;</span>) + FPaths::GameSourceDir()));<br><span class="hljs-comment">//&gt; GameSourceDir:../../../../../Goulandis/UE4/Unkown/Unkown/Source/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;FeaturePackDir:&quot;</span>) + FPaths::FeaturePackDir()));<br><span class="hljs-comment">//&gt; FeaturePackDir:D:/UE_4.26_SourceCode/UnrealEngine-4.26/FeaturePacks/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;GetProjectFilePath:&quot;</span>) + FPaths::GetProjectFilePath()));<br><span class="hljs-comment">//&gt; GetProjectFilePath:../../../../../Goulandis/UE4/Unkown/Unkown/Unkown.uproject</span><br></code></pre></td></tr></table></figure></li><li><p>GetExtension：获取文件的后缀，不带<code>.</code>；</p></li><li><p>GetCleanFilename：获取带后缀的文件名，不包含路径；</p></li><li><p>GetBaseFilename：获取不带后缀的文件名，不包含路径；</p></li><li><p>GetPath：只获取路径；</p></li><li><p>GetPathLeaf：获取路径中的叶子节点，即路径中最后一个节点，如：D:\UE4\A.txt，则获取到A.txt，D:\UE4\，则获取到UE4；</p></li><li><p>ChangeExtension：当文件有后缀时，改变文件的后缀，否则直接退出；</p></li><li><p>SetExtension：无论文件有没有后缀都为为文件设置一个新的后缀；</p></li><li><p>FileExists：判断文件是否存在；</p></li><li><p>DirectoryExists：判断文件夹是否存在;</p></li><li><p>IsDrive：判断路径是否是根目录，路径中只有<code>C:</code>这种形式才被认定为根目录，<code>:</code>之后不能跟任何东西；</p></li><li><p>IsRelative：判断路径是否是相对路径，路径不能以<code>\</code>或<code>/</code>开头，否则会被认定为False；</p></li><li><p>NormalizeFilename：格式化路径，会将路径中的所有<code>\</code>替换为<code>/</code>；</p></li><li><p>IsSamePath：判断两个路径是否一样；</p></li><li><p>IsUnderDirectory：判断路径是否在某个指定目录下；</p></li><li><p>NormalizeDirectoryName：格式化目录，和NormalizeFilename类似；</p></li><li><p>RemoveDuplicateSlashes：删除路径中重复<code>/</code>；</p></li><li><p>CreateStandardFilename：把UE的相对路径转换成绝对路径，如上面的所示，由于FPaths获取的路径几乎都是<code>../../</code>这种形式，有的时候我们可能需要绝对路径，就可以使用这个函数来转换。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">DEBUGLOG(FEnumSet::DebugLogType::Warning, FPaths::CreateStandardFilename(FPaths::GetProjectFilePath()));<br><span class="hljs-comment">//&gt; GetProjectFilePath: D:/Goulandis/UE4/Unkown/Unkown/Unkown.uproject</span><br></code></pre></td></tr></table></figure></li><li><p>MakeStandardFilename：效果和CreateStandardFilename一致，只是CreateStandardFilename使用返回值返回路径，MakeStandardFilename直接传入引用，从参数返回；</p></li><li><p>MakePlatformFilename：这个函数好像没什么卵用，从源码上看就是跟格式化路劲好像没啥区别；</p></li><li><p>MakePathRelativeTo：传入两个路径，其中参数一为FString&amp;，参数二为const TCHAR*，如果二者是同一路径下的，那么将参数一的路径转化为相对于参数二的相对路径，如：参数一为：D:/UE/Content/A.txt，参数二为：D:/UE/B.txt，那么经过转换，参数将变成：Content/A.txt；如果二者路径不一致，则不做转换；</p></li><li><p>ConvertRelativePathToFull：这个函数似乎也是和CreateStandardFilename和MakeStandardFilename的作用是一样的，估计是历史遗留原因吧，很多重复功能的函数；</p></li><li><p>ConvertToSandboxPath：将路径转换为沙盒路径；</p></li><li><p>ConvertFromSandboxPath：将沙盒路径转为平台路径；</p></li><li><p>CreateTempFilename：创建临时文件，需要指定路径，可选文件名前缀和文件名后缀，函数会根据设置的路径、前缀、后缀生成一个随机名称的临时文件，如果没有指定后缀，默认使用.tmp，如果没有指定前缀，默认使用无前缀的随机数作为文件名；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">DEBUGLOG(FEnumSet::DebugLogType::Warning, FPaths::CreateTempFilename(TEXT(<span class="hljs-string">&quot;D:/Unkwon/Content/&quot;</span>,TEXT(<span class="hljs-string">&quot;Temp_&quot;</span>))));<br><span class="hljs-comment">//&gt; D:/Unkwon/Content/Temp_684BF44044F4C6356EFEC8BA14E6B32B.tmp</span><br></code></pre></td></tr></table></figure></li><li><p>GetInvalidFileSystemChars：获取操作系统规定的所有在路径中使用后是无效字符的字符串；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">DEBUGLOG(FEnumSet::DebugLogType::Warning, FPaths::GetInvalidFileSystemChars());<br><span class="hljs-comment">//&gt; /?:&amp;\*&quot;&lt;&gt;|%#@^</span><br></code></pre></td></tr></table></figure></li><li><p>MakeValidFileName：去除路径中的无效字符后，返回一个可用的路径；</p></li><li><p>ValidatePath：判断路径的组成字符中是否包含了操作系统规定的无效字符；</p></li><li><p>Split：将一个文件路径拆分成路径、不带后缀的文件名和后缀三部分；</p></li><li><p>Combine：这是一个可变参数的函数，将传入的参数组合成一个路径格式；</p><p><font color="green"><strong>小知识:</strong></font></p><p>这里涉及到了UE的可变参数，实际上就是C++11中的可变参数模板，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... STR&gt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UPlatformFileExpand::FuncTest</span><span class="hljs-params">(STR... Strs)</span></span><br><span class="hljs-function"></span>&#123;<br>    TCHAR* Str[] = &#123; Strs... &#125;;<br>    <span class="hljs-keyword">for</span> (TCHAR* Item : Str)<br>    &#123;<br>        UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;%s&quot;</span>), Item);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>STR是一个可变参数包，可以接收任意类型的任意数量的参数，只是传进来的参数需要自行进行处理，否则可能会因为参数类型不符而导致编译失败。</p><p>其中参数可以通过数组初始化的形式来使用数组接收参数包中的参数，当前提是需要提前对参数类型做处理，否者初始化就会失败，这种方式应该是UE自己实现的，C++中读取参数使用的是va_arg，va_start,va_end,va_list等来获取可变参数。</p></li><li><p>TearDown：释放所有FPaths所暂用的内存，由于FPaths类在程序开始由引擎自动初始化，其中保存了大量的路径字符串，如果不需要再用到FPaths了也可以直接把这部分内存释放出来。</p></li></ul><h1 id="十三、GConfig"><a href="#十三、GConfig" class="headerlink" title="十三、GConfig"></a>十三、GConfig</h1><p>GConfig是一个定义在CoreGlobals.cpp中一个全局FConfigCacheIni*变量，可以在UEC++中的任何地方使用，FConfigCacheIni是UE专门用来处理缓存在内存中的配置文件的类，其中涉及到FConfigFile、FConfigSection、FConfigValue类。</p><p>UE使用FConfigValue来封装配置文件中<code>=</code>号后面的内容，FConfigValue是一个结构体；使用一个<code>TPair&lt;FName,FConfigValue&gt;</code>来封装一行内容，其中TPair的Key就是一行中的Key，Value就是一行中的Value；使用FConfigSection来封装一个块的内容，FConfigSection是一个<code>TMultiMap&lt;FName,FConfigValue&gt;</code>的Map；使用FConfigFile来封装一个配置文件，FConfigFile是一个<code>TMap&lt;FString,FConfigSection&gt;</code>的Map。</p><h2 id="FConfigCacheIni"><a href="#FConfigCacheIni" class="headerlink" title="FConfigCacheIni"></a>FConfigCacheIni</h2><ul><li><p>DisableFileOperations和EnableFileOperations：这两个是相对的函数，具体是干什么的至今没搞懂；</p></li><li><p>AreFileOperationsDisabled：判断是DisableFileOperations状态还是EnableFileOperations状态；</p></li><li><p>IsReadyForUse：判断ini文件是否已经加载好了，GConfig在加载ini文件时，会把ini文件内容加载到一个FConfigFile类对象中，FConfigFile类才是直接对ini文件进行操作的类；</p></li><li><p>Parse1ToNSectionOfStrings：用于读取读取ini文件的二级键值，并用一个<code>TMap&lt;FString,TArray&lt;FStting&gt;&gt;&amp;</code>作为参数返回；如：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[TEXT]</span><br><span class="hljs-attr">AA</span>=T1<br><span class="hljs-attr">BB</span>=Y1<br><span class="hljs-attr">BB</span>=Y2<br><span class="hljs-attr">AA</span>=T2<br><span class="hljs-attr">BB</span>=Y3<br><span class="hljs-attr">AA</span>=W1<br><span class="hljs-attr">BB</span>=Y4<br><span class="hljs-attr">BB</span>=Y5<br><span class="hljs-attr">BB</span>=Y6<br></code></pre></td></tr></table></figure><p>其中AA=T1为一级键值，在T1下游两个二级键值BB=Y1，BB=Y2，以此类推，一级键值AA=T2下有一个二级键值BB=Y3，一级键值AA=W1下有三个二级键值BB=Y4，BB=Y5，BB=Y6。</p><p>Parse1ToNSectionOfStrings参数，其中Section为要读取的块的名称，KeyOne为一级键值名称，KeyN为二级键值名称，只能支持到二级键值。</p></li><li><p>Parse1ToNSectionOfNames：和Parse1ToNSectionOfStrings的效果一样只是使用FName替换了FString；</p></li><li><p>FindConfigFile：在已加载的配置文件中通过文件路径寻找FConfigFile类型的配置文件对象，只有已加载到内存中的配置文件才能被找到；</p></li><li><p>Find：Find的功能和FindConfigFile一样，只是新增了一个bool参数，指定在没有找到对象时是否创建一个；</p></li><li><p>FindConfigFileWithBaseName：使用不包含路径的文件名寻找加载到内存中FConfigFile对象；</p></li><li><p>Flush：清除指定的已加载到内存中的FConfigFile对象；</p></li><li><p>LoadFile：加载一个配置文件到一个FConfigFile对象并存储在内存中；</p></li><li><p>SetFile：为一个指定的配置文件设定一个新的FConfigFile对象，UE加载所有的配置文件使用了一个Map来在内存中存储，Map使用配置文件的全路径来作为Key，使用对应FConfigFile对象来作为Value；</p></li><li><p>UnloadFile：从内存中移除指定的FConfigFile对象；</p></li><li><p>Detach：这个函数着实是没弄明白是干什么的；</p></li><li><p>DoesSectionExist：判断指定块是否存在；</p></li><li><p>GetConfigFilenames：获取所有已加载到内存中的配置文件的名称，使用一个<code>TArray&lt;FString&gt;</code>数组存储；</p></li><li><p>GetSectionNames：获取所有的已加载到内存中的指定的配置文件的块的键值，使用一个<code>TArray&lt;FString&gt;</code>数组存储；</p></li><li><p>Exit：退出FConfigCacheIni，清除所有加载到内存的FConfigFile对象；</p></li><li><p>GetMaxMemoryUsage：获取FConfigCachIni的做大内存使用量；</p></li><li><p>ForEachEntry：遍历指定块的所有行，通过传入的FKeyValueSink委托绑定操作函数；</p></li><li><p>Factory：创建一个FConfigChechIni实例；</p></li><li><p>InitializeConfigSystem：创建GConfig实例，加载标准的全局ini文件；</p></li><li><p>GetDestIniFilename：这个函数会根据平台的类型给定标准的ini文件在不同平台中的名称；</p></li><li><p>LoadGlobalIniFile：加载ini文件，并把生成的FConfigFile配置到GConfig以便使用；</p></li><li><p>LoadLocalIniFile：加载ini文件，但不把生成的FConfigFile配置到GConfig；</p></li><li><p>LoadExternalIniFile：从指定的配置文件文件夹中加载配置文件，可以使用直接使用不带后缀的文件名加载；</p></li><li><p>SaveCurrentStateForBootstrap：将当前的FConfigCacheIni中的所有配置项存储到指定的配置文件中；</p></li><li><p>ini文件操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetString</span><span class="hljs-params">( <span class="hljs-keyword">const</span> TCHAR* Section, <span class="hljs-keyword">const</span> TCHAR* Key, FString&amp; Value, <span class="hljs-keyword">const</span> FString&amp; Filename )</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetText</span><span class="hljs-params">( <span class="hljs-keyword">const</span> TCHAR* Section, <span class="hljs-keyword">const</span> TCHAR* Key, FText&amp; Value, <span class="hljs-keyword">const</span> FString&amp; Filename )</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetSection</span><span class="hljs-params">( <span class="hljs-keyword">const</span> TCHAR* Section, TArray&lt;FString&gt;&amp; Result, <span class="hljs-keyword">const</span> FString&amp; Filename )</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetString</span><span class="hljs-params">( <span class="hljs-keyword">const</span> TCHAR* Section, <span class="hljs-keyword">const</span> TCHAR* Key, <span class="hljs-keyword">const</span> TCHAR* Value, <span class="hljs-keyword">const</span> FString&amp; Filename )</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetText</span><span class="hljs-params">( <span class="hljs-keyword">const</span> TCHAR* Section, <span class="hljs-keyword">const</span> TCHAR* Key, <span class="hljs-keyword">const</span> FText&amp; Value, <span class="hljs-keyword">const</span> FString&amp; Filename )</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">RemoveKey</span><span class="hljs-params">( <span class="hljs-keyword">const</span> TCHAR* Section, <span class="hljs-keyword">const</span> TCHAR* Key, <span class="hljs-keyword">const</span> FString&amp; Filename )</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">EmptySection</span><span class="hljs-params">( <span class="hljs-keyword">const</span> TCHAR* Section, <span class="hljs-keyword">const</span> FString&amp; Filename )</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">EmptySectionsMatchingString</span><span class="hljs-params">( <span class="hljs-keyword">const</span> TCHAR* SectionString, <span class="hljs-keyword">const</span> FString&amp; Filename )</span></span>;<br><span class="hljs-function">FString <span class="hljs-title">GetStr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section, <span class="hljs-keyword">const</span> TCHAR* Key, <span class="hljs-keyword">const</span> FString&amp; Filename )</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetInt</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR* Key,int32&amp; Value,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetFloat</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR* Key,<span class="hljs-keyword">float</span>&amp; Value,<span class="hljs-keyword">const</span> FString&amp;Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetDouble</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR*Section,<span class="hljs-keyword">const</span> TCHAR* Key,<span class="hljs-keyword">double</span>&amp; Value,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetBool</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR* Key,<span class="hljs-keyword">bool</span>&amp; Value,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function">int32 <span class="hljs-title">GetArray</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR*Section,<span class="hljs-keyword">const</span> TCHAR* Key,TArray&lt;FString&gt;&amp; out_Arr,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function">int32 <span class="hljs-title">GetSingleLineArray</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR* Key,TArray&lt;FString&gt;&amp; out_Arr,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetColor</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR* Key,FColor&amp;Value,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetVector2D</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR* Key,FVector2D&amp; Value,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetVector</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR* Key,FVector&amp; Value,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetVector4</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR* Key,FVector4&amp; Value,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetRotator</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR* Key,FRotator&amp;Value,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetInt</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR* Key,int32Value,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetFloat</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR* Key,<span class="hljs-keyword">float</span> Value,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetDouble</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR*Section,<span class="hljs-keyword">const</span> TCHAR* Key,<span class="hljs-keyword">double</span>Value,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetBool</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR* Key,<span class="hljs-keyword">bool</span>Value,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetArray</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR*Key,<span class="hljs-keyword">const</span> TArray&lt;FString&gt;&amp; Value,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetSingleLineArray</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR* Key,<span class="hljs-keyword">const</span> TArray&lt;FString&gt;&amp; In_Arr,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetColor</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR* Key,FColor Value,<span class="hljs-keyword">const</span> FString&amp;Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetVector2D</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR* Key,FVector2D Value,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetVector</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR* Key,FVector Value,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetVector4</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR* Key,<span class="hljs-keyword">const</span> FVector4&amp; Value,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetRotator</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR* Key,FRotator Value,<span class="hljs-keyword">const</span> FString&amp;Filename)</span></span>;<br></code></pre></td></tr></table></figure><h1 id="十四、FJsonObject"><a href="#十四、FJsonObject" class="headerlink" title="十四、FJsonObject"></a>十四、FJsonObject</h1></li></ul><p>UE提供FJsonObject来对json文件进行操作，同时提供一整套的json操作工具链，如：FJsonValue，FJsonReader，FJsonSerializer，FJsonWriter，FJsonTypes等。</p><p>详细使用请查看<a href="https://goulandis.github.io/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%AF%BB%E5%86%99Json%E6%96%87%E4%BB%B6/">这里</a>。</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE4】UE4GamePlay框架</title>
    <link href="/2021/12/08/%E3%80%90UE4%E3%80%91UE4GamePlay%E6%A1%86%E6%9E%B6/"/>
    <url>/2021/12/08/%E3%80%90UE4%E3%80%91UE4GamePlay%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>这篇博文主要记录一些自己在学习GamePlay的过程中一些心得记录，最开始使用的是UE5源码学习，后来不知道不小心改了啥，UE5源码崩了，就换回了UE4.26所以源码部分可能会有一部分来自UE5有一部分来自UE4，会有点出入。</p><a id="more"></a><p>参考博客：<a href="https://docs.unrealengine.com/en-US/index.html">UE4官方文档</a>、<a href="https://zhuanlan.zhihu.com/p/22813908">大钊</a>、<a href="https://zhuanlan.zhihu.com/p/67055774">南京周润发</a>、<a href="https://blog.csdn.net/qq_29523119/article/details/84981218">带带大师兄</a>、<a href="https://www.cnblogs.com/yblackd/p/13819045.html">yblackd</a>、<a href="https://blog.csdn.net/qq_36409711/article/details/78889074">董国政</a>、 <a href="https://www.cnblogs.com/AnKen/p/7897076.html">Ken_An</a>、<a href="https://zhuanlan.zhihu.com/p/393346131">张悟基</a>、<a href="https://zhuanlan.zhihu.com/p/166547096">paprika</a></p><h1 id="一、整体框架"><a href="#一、整体框架" class="headerlink" title="一、整体框架"></a>一、整体框架</h1><p>首先来看一下整体框架：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210226143303.png"></p><p><font color="red"> 红色部分为主体，从右往左为组合关系，至上而下为派生关系。</font></p><p>在整个UE宇宙的构成中，UEngine就类似化学元素，UObject就类似物质，物质通过演化便衍生出了物体—AActor和UActorComponent，AActor继续演化就出现了生物APawn，人—ACharacter，于是世界便有了信息—AInfo，规则—AGameMode，大量的物体、生物组合在一起便形成了大陆—ULevel，不同的大陆组合在一起便形成了世界—UWorld，世界有着自己的信息—FWorldContext和客观规律—UGameInstance。</p><p>而在UE这个宇宙有很多个Word，如编辑时的World，编辑时运行的World，运行时的World等等，查看源码就可知道UE宇宙有五大世界。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> EWorldType<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Type</span></span><br><span class="hljs-class">&#123;</span><br>None,<span class="hljs-comment">// An untyped world, in most cases this will be the vestigial worlds of streamed in sub-levels</span><br>Game,<span class="hljs-comment">// The game world</span><br>Editor,<span class="hljs-comment">// A world being edited in the editor</span><br>PIE,<span class="hljs-comment">// A Play In Editor world</span><br>Preview,<span class="hljs-comment">// A preview world for an editor tool</span><br>Inactive<span class="hljs-comment">// An editor world that was loaded but not currently being edited in the level editor</span><br>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先我们先了解一下这些类的具体作用，然后再细致的了解各个类。</p><h2 id="1-UEngine"><a href="#1-UEngine" class="headerlink" title="1.UEngine"></a>1.UEngine</h2><p>UEngine类是UE的基础，UEngine提供一些最底层的交互—与操作系统的交互，而根据不同的运行模式UE与操作系统的交互模式又有少许不同，所以UEngine又派生出了UGameEngine和UEditerEngine来负责不同运行模式下的交互模式。</p><p>其中有一个很重要的全局指针GEngine，通过GEngine可以访问各种UE的全局资源，同时GEngine还提供多线程访问能力。</p><p>关于UEngine的资料实在是太少了，官方文档中对UEngine的描述也就一句话，对UEngine的理解也就止步于此了。</p><h2 id="2-UObject"><a href="#2-UObject" class="headerlink" title="2.UObject"></a>2.UObject</h2><p>UObject是构成UE世界最基础的物质，所以UObject提供供UE世界运行的最基本的功能：</p><ul><li>Garbage collection：垃圾收集</li><li>Reference updating：引用自动更新</li><li>Reflection：反射</li><li>Serialization：序列化</li><li>Automatic updating of default property changes：自动检测默认变量的更改</li><li>Automatic property initialization：自动变量初始化</li><li>Automatic editor integration：和虚幻引擎编辑器的自动交互</li><li>Type information available at runtime：运行时类型识别</li><li>Network replication：网络复制</li></ul><p>在之后再深入浅出的讲解各个功能。</p><h2 id="3-AActor"><a href="#3-AActor" class="headerlink" title="3.AActor"></a>3.AActor</h2><p>AActor是派生自UObject的一个及其重要的类，AActor在UObject的基础上再进一步提供了：</p><ul><li>Replication：网络复制</li><li>Spawn：动态创建</li><li>Tick：每帧运行</li></ul><p>Replicatoin使AActor有了分裂复制的生育能力，Spawn使AActor在UE世界中出生，在UE4世界中死去，Tick使AActor有了心跳，AActor便组成了丰富多彩的UE世界。</p><p>AActor拥有一个庞大的子孙族群，ALevelScriptActor、ANavigationObjectBase、APawn、AController、AInfo这些都是AActor的直系后代，而这些后代也都各自拥有自己的庞大分支族群，构成了UE世界中最强大的种族AActor。</p><h3 id="ALevelScriptActor"><a href="#ALevelScriptActor" class="headerlink" title="ALevelScriptActor"></a>ALevelScriptActor</h3><p>ALevelScriptActor在官方文档中的表述就是ULevelScriptBlueprint生成的类的基类，通过名称我们就很容易联想到关卡蓝图，没错ULevelScriptBlueprint就是我们最常用的关卡蓝图，ULevelScriptBlueprint继承自UObject，所以ULevelScriptBlueprint的子类是一个多继承的虚继承类，而ALevelScriptActor就为其提供AActor的能力。</p><p>在官方文档中有提及默认关卡蓝图是可以通过DefualtGame.ini配置文件替换成自定义关卡蓝图的，具体使用方法在后面在探讨。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210309211442.png"></p><h3 id="ANavigationObjectBase"><a href="#ANavigationObjectBase" class="headerlink" title="ANavigationObjectBase"></a>ANavigationObjectBase</h3><p>ANavigationObjectBase的资料实在是少的可怜，就连官方文档也是没有一个字的描述，源码也是相当简单，总共就70行，由ANavigationObjectBase是APlayerState的基类，和它继承的接口INavAgentInterface可以猜测ANavigationObjectBase应该和网络复制有关，具体细节留到以后更熟悉UE4了再深入探讨吧。</p><h3 id="APlayerStart"><a href="#APlayerStart" class="headerlink" title="APlayerStart"></a>APlayerStart</h3><p>APlayerStart的作用就是记录APawn在游戏开始时生成的Position与Rotation信息，UE设计APlayerStart的初忠就是想让游戏的关卡设十师和场景设计师的工作分离开来，也就解耦合。那么，如果Level中不存在APlayerStart ，APawn 会出生在哪是呢？答案是世界原点(0，0，0)</p><h3 id="APawn"><a href="#APawn" class="headerlink" title="APawn"></a>APawn</h3><p>APawn在AActor的基础上再度添加了：</p><ul><li>被Controller控制</li><li>PhysicsCollision：物理碰撞</li><li>MovementInput：移动响应接口</li></ul><p>等能力，有了MovementInput接口APawn就拥有了可运动的能力，这里UE的逻辑划分十分精妙，UE将一个可运动的物体巧妙地划分成了APwan和AController，APawn重点表现在物体，而这个物体具备运动能力，但是自身不具备运动技巧；而AController这是控制APawn运动地大脑，用来控制APawn如何运动，如果把APawn比作是提线木偶，那么AController就是控制木偶运动地线。</p><p>到了APawn这一代，AActor的衍化之旅开始衍化出现于玩家间交互的能力，而这之中的佼佼者便是ACharacter。</p><h3 id="ACharacter"><a href="#ACharacter" class="headerlink" title="ACharacter"></a>ACharacter</h3><p>ACharacter是APwan的特化加强版，在UE世界中可以称之为“人”，ACharacter是一个专门为人形角色定制的APawn，自带CharacterMovement组件，可以使人形角色像人一样行走。</p><h3 id="ADefaultPawn"><a href="#ADefaultPawn" class="headerlink" title="ADefaultPawn"></a>ADefaultPawn</h3><p>最初始的APawn使最基本的APawn类，只提供APawn的一些基本能力，而没有提供支持这些能力的组件，而在具体实际使用情况中我们使用的APawn应该还需要组合一些其他的能力，以适应不同的场景，如：我们知道APawn可以运动，但在实际场景中我们是要确定这个APawn是因该直立行走还是爬行，是用轮子行驶还是用翅膀飞行，APawn在玩家眼里应该长什么样子，是人还是蛇，是因该左球形碰撞还是应该做方形碰撞，这些都是APawn不具备的能力，这时ADefaultPawn便出现了，ADefaultPawn自带DefualtPawnMovement、CollisionComponent、StaticMeshCompnent三件套，为ADefaultPawn提供了默认的场景表现。</p><h3 id="ASpectatorPawn"><a href="#ASpectatorPawn" class="headerlink" title="ASpectatorPawn"></a>ASpectatorPawn</h3><p>在游戏中存在一种特殊的玩家—观战玩家，这类玩家不需要具体表现形式，只需要一些相机的漫游能力，于是ASpectatorPawn出现了，ASpectatorPawn继承自ADefaultPawn，ASpectatorPawn提供了一个基本的USpectatorPawnMovement（不带重力漫游），并关闭了StaticMesh的显示，碰撞也设置到了“Spectator”通道。</p><h3 id="AController"><a href="#AController" class="headerlink" title="AController"></a>AController</h3><p>AController就是控制APawn运动的大脑了，ACtroller负责处理一些直接与玩家交互的控制逻辑，AController是从AActor派生的与APawn同级的子类，在UE的设计中，在同一时刻一个AController和一个APawn之间是1:1的关系，AController可以在多个APawn之间通过Possess/UnPossess切换。AController有两种控制APawn的方式，一种是AController直接附在APawn的身上控制APawn的移动，如驾驶汽车，一种是以上帝的视角控制APawn的移动，如控制第三人称的角色。</p><h3 id="APlayerController"><a href="#APlayerController" class="headerlink" title="APlayerController"></a>APlayerController</h3><p>APlayerController是由AController派生出来专门用于负责玩家交互逻辑的AController，APlayerController提供了：</p><ul><li>Camera管理</li><li>Input输入响应</li><li>UPlayer关联</li><li>HUD显示</li><li>Level切换</li><li>Voice音源监听</li></ul><p>这些能力。</p><h3 id="AAIController"><a href="#AAIController" class="headerlink" title="AAIController"></a>AAIController</h3><p>在一个游戏中有玩家控制的角色也可以有NPC，那么NPC的行动逻辑有谁来控制呢？答案就是AAIController，AAIController与APlayerController完全不同，因为一个NPC不要管理Camera，不需要响应玩家的输入，不需要关联UPlayer，不需要显示HUD，不需要监听音源，只有Level切换可能会在少数情况下需要，那么AAIController因该做什么呢？UE为它设计的是这些事：</p><ul><li>Navigation：自动寻路</li><li>AI Component：用于启动运行行为树，使用黑板数据</li><li>Task系统：让AI去完成一些任务</li></ul><p>当然一个游戏中是至少需要一个APlayerController的，但是可以没有AAIController。</p><h3 id="AInfo"><a href="#AInfo" class="headerlink" title="AInfo"></a>AInfo</h3><p>AInfo是一些数据保存类的基类，AInfo不需要运动和碰撞，也不需要物理表现，仅仅只是保存数据，所以UE在AInfo中将这些功能都隐藏了，之所以不直接继承自UObject，而继承自AActor是因为游戏数据是需要具备网络复制的能力的，而UObject不具备这个能力</p><h3 id="AWordSettings"><a href="#AWordSettings" class="headerlink" title="AWordSettings"></a>AWordSettings</h3><p>AWordSetting继承自AInfo用来配置和保存一些Level配置，主要用于配置Level的GameMode信息，光照信息，导航系统，声音系统，LOD系统，物理加速度等关卡信息。由此可以知道一个Level对应一个AWordSetting，但是一个AWordSetting可以应用在多个Level上。</p><h3 id="AGameMode"><a href="#AGameMode" class="headerlink" title="AGameMode"></a>AGameMode</h3><p>AGameMode就是用于配置AWorldSetting中的GameMode属性的。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210310162744.png"></p><p>在UE的设计中AGameMode就是游戏世界的逻辑，及整个游戏的玩法规则，而在实际情况中一个游戏既可以只有一个玩法也可以有多种玩法规则，所以AWordSetting与AGameMode的对应关系也是一个AWorldSetting只能对应一个AGameMode，而一个AGameMode可以对应多个AWorldSetting。那么AGameMode应该负责哪些逻辑呢？UE是这么规定的：</p><ul><li>Class登记：记录GameMode中各种类的信息</li><li>Spawn：创建Pawn和PlayerController等</li><li>游戏进度：游戏暂停重启的逻辑</li><li>过场动画逻辑</li><li>多人游戏的步调同步</li></ul><h3 id="AGameState"><a href="#AGameState" class="headerlink" title="AGameState"></a>AGameState</h3><p>AGameState用于保存游戏数据，如任务进度，游戏活动等。</p><h3 id="APlayerState"><a href="#APlayerState" class="headerlink" title="APlayerState"></a>APlayerState</h3><p>APlayerState是一个用于存储玩家状态的类，在一个游戏客户端，尤其是网络游戏客户端中是可以存在多个APlayerState对象的，不同的APlayerState保存不同玩家的状态，同时APlayerState也可以存在于服务器中。APlayerState的生命周期为一整个Level的生命周期。</p><p>到这是AActor家族下的几个重要成员的基本功能我们便有了一个大概的了解了，这里我们来捋一下这些成员之间的关系和在UE世界中的地位。<br><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208141236.jpeg" alt="Alt"></p><h2 id="4-UActorComponent"><a href="#4-UActorComponent" class="headerlink" title="4.UActorComponent"></a>4.UActorComponent</h2><p>UActorComponent是UE向U3D看齐的一个产物，虽然UE世界有了Actor就有了形形色色的物体生物，但是不同的生物拥有不同的技能，而同一个Actor可以会某个技能也可以不会，这种概念使用组合的方式组合到Actor下是最理想的，于是Component便出现了，UActorComponent直接继承自UObject，与AActor同级，Component既可以嵌套在Actor下，也可以嵌套在其他的Component下，但是需要注意的是，UActorComponent这一级是不提供互相嵌套的能力的，只有到其子类USceneComponent一级才提供互相嵌套能力。</p><h3 id="USceneComponent"><a href="#USceneComponent" class="headerlink" title="USceneComponent"></a>USceneComponent</h3><p>USceneComponent主要提供两大能力，一是Transform，二是SceneComponent的互相嵌套。一般我们直接在Level里创建的Actor都会默认带有一个SceneComponent组件。</p><h3 id="UPrimitiveComponent"><a href="#UPrimitiveComponent" class="headerlink" title="UPrimitiveComponent"></a>UPrimitiveComponent</h3><p>UPrimitiveComponent主要提供Actor用于物体渲染和碰撞相关的基础能力。</p><h3 id="UMeshComponent"><a href="#UMeshComponent" class="headerlink" title="UMeshComponent"></a>UMeshComponent</h3><p>UMeshComponent由UPrimitiveComponent派生而来，主要提供具体的渲染显示方面的能力。</p><h3 id="UChildActorComponent"><a href="#UChildActorComponent" class="headerlink" title="UChildActorComponent"></a>UChildActorComponent</h3><p>从名字就可以窥探其功能一二了，UChildComponent在Actor中主要用于链接Actor与Component，提供Component和Actor的嵌套能力。</p><h2 id="5-ULevel"><a href="#5-ULevel" class="headerlink" title="5.ULevel"></a>5.ULevel</h2><p>ULevel可以看作是UE世界的大陆，是AActor的容器，前面提到的ALevelScriptActor便是ULevel默认带有的关卡蓝图，在这个关卡蓝图中编写便是这块大陆的逻辑，同时ULevel也默认带有一个AWorldSetting。</p><h2 id="6-UWorld"><a href="#6-UWorld" class="headerlink" title="6.UWorld"></a>6.UWorld</h2><p>在UE中所有的ULevel互相联系就构成了一个UWorld，ULevel构建UWorld的方式有两种，一种是以SubLevel的形式，像关卡流一样，一个关卡链接下一个关卡，来组成UWorld，一种是每一个ULevel就是这个大地图的UWorld中的一块地图，ULevel之间以相对位置衔接在一起，构成一个大地图来组成这个UWorld。无论是那种构成形式，在一个UWorld中都有一个PersistentLevel，PersistenetLevel就是主Level，是玩家最初始的出生地，这里用的是最初始而不是游戏开始，是因为，现在很多在游戏开始时玩家的出点可能不是PersistentLevel而是上一次玩家离线时的位置。</p><h2 id="7-FWorldContext"><a href="#7-FWorldContext" class="headerlink" title="7.FWorldContext"></a>7.FWorldContext</h2><p>FWorldContext不对开发者公开，是UE内部用来处理引擎UWorld上下文的类，比如当我们从编辑状态的EditorWorld点击播放切换到PIEWorld即运行状态时，这个过程中EditorWorld到PIEWorld之间的信息交换就是通过FWorldContext实现的。可以说FWorldContext处理的是UWorld级的通信。</p><h2 id="8-UGameInstance"><a href="#8-UGameInstance" class="headerlink" title="8.UGameInstance"></a>8.UGameInstance</h2><p>UGameInstance可以说是凌驾于所有AActor、UActorComponent、ULevel、UWorld之上的类，通常情况下一个Game中应该只有一个，这里的Game是UEngine中提到的所有World的总和，当然这不是绝对的，对于更高层次的开发者，UE也是提供了多个UGameInstance协同的扩展的。UGameInstance的生命周期就是从游戏进程启动到游戏进程结束。</p><p>所以UGameInstance主要处理：</p><ul><li>UWorld、ULevel之间的切换</li><li>UPlayer的创建，这里的UPlayer又和前面的APlayerController有所不同，这一点在后面再介绍。</li><li>全局配置</li><li>GameMode的切换</li></ul><h2 id="9-UNetDriver"><a href="#9-UNetDriver" class="headerlink" title="9.UNetDriver"></a>9.UNetDriver</h2><p>从名字就可以略知一二，UNetDriver是UE处理网络同步相关的类，UNetDriver中有两个主要的成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UNetConnection</span>* <span class="hljs-title">ServerConnection</span>;</span><br>TArray&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UNetConnection</span>*&gt;</span> ClientConnections;<br></code></pre></td></tr></table></figure><p>ServerConnection是客户端到服务器的连接，ClientConnections数组是服务器到客户端群的连接的数组。而在UNetConnnection中又有一个很重要的成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">TMap&lt;TWeakObjectPtr&lt;AActor&gt;,<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UActorChannel</span>*&gt;</span> ActorChannels<br></code></pre></td></tr></table></figure><p>ActorChannels是在服务器与客户端完成连接后用于实现Actor同步的对象。</p><h2 id="10-UPlayer"><a href="#10-UPlayer" class="headerlink" title="10.UPlayer"></a>10.UPlayer</h2><p>UPlayer即玩家，ULevel可以切换，UWorld可以交替，但是尽管ULevel、UWorld如何变换，玩家还是那个玩家，所以UPlayer是和UGameInstance同一级别的存在，在整个GamePlay架构中UPlayer主要以GameModeBase中的一个属性出现。</p><p>在一个单机游戏中UPlayer是唯一的存在，但是在一个网络联级游戏中，表示同一实体的UPlayer即存在于玩家本地的客户端中，同时也存在于其他玩家的多个客户端中，那么玩家的输入就既要作用于本地的APawn上，同时在其他玩家的客户端中的表示这个实体的APawn也要做出响应的反应，于是UE便将UPlayer又派生出了两个子类，ULocalPlayer和UNetConnection。其中ULocalPlayer就是处理本地客户端的输入逻辑的类。</p><h3 id="UNetConnection"><a href="#UNetConnection" class="headerlink" title="UNetConnection"></a>UNetConnection</h3><p>UNetConnection就是处理其他玩家在本地客户端中的APawn的类，所以UNetConnection也是一个玩家。</p><h2 id="11-USaveGame"><a href="#11-USaveGame" class="headerlink" title="11.USaveGame"></a>11.USaveGame</h2><p>前面提到了AGameState是一个保存游戏数据的类，这个保存是一个临时保存，所以当游戏程序关闭之后AGameState中数据也就不存在了，而USaveGame就是用来保存存档的类，USaveGame提供游戏数据永久性保存，我们只需要往USaveGame中添加我们要保存的属性字段，就可以直接调用USaveGame的接口直接将游戏数据序列化保存到本地文件中，相当的方便。</p><p>花了这么长的篇幅也就简要的介绍了一下GamePlay的整体框架，总共由这11个类组成，说起来不多，但是里面的门道却是相当深奥，这需要在以后的使用中慢慢学习消化。</p><p>那么接下来就开始各个类的详细使用学习了。</p><h1 id="二、UObject"><a href="#二、UObject" class="headerlink" title="二、UObject"></a>二、UObject</h1><p>首先我们来看UObject提供的功能：</p><ul><li>Garbage collection：垃圾收集</li><li>Reference updating：引用自动更新</li><li>Reflection：反射</li><li>Serialization：序列化</li><li>Automatic updating of default property changes：自动检测默认变量的更改</li><li>Automatic property initialization：自动变量初始化</li><li>Automatic editor integration：和虚幻引擎编辑器的自动交互</li><li>Type information available at runtime：运行时类型识别</li><li>Network replication：网络复制</li></ul><h2 id="1-垃圾回收"><a href="#1-垃圾回收" class="headerlink" title="1.垃圾回收"></a>1.垃圾回收</h2><p>首先我们来研究研究UE4是如何进行垃圾回收的。</p><p>这里推荐两位大佬的博客：<a href="https://zhuanlan.zhihu.com/p/67055774">带带大师兄</a>、<a href="https://blog.csdn.net/qq_29523119/article/details/84981218">南京周润发</a></p><p>可以配合着看。</p><p>由于C++不提供GC功能，所有UE自己实现了一套GC功能，使用的也是最经典的<code>标记-清理</code>垃圾回收方式。</p><h3 id="GC的过程"><a href="#GC的过程" class="headerlink" title="GC的过程"></a>GC的过程</h3><p>UEGC分为来两个阶段，第一个阶段UE从根集合开始遍历，遍历所有可达对象，于是UE就知道了哪些对象还在被引用，哪些对象已经不可被引用了。第二阶段UE会逐步的清理这些不可达对象，形式为分帧分批清理，为什么要这么做呢？想想我们卸载一次性Level时的感受就知道了，分批处理可以保证我们在使用UE时的顺滑而不卡顿。</p><p>UEGC的主要函数是在UObjectGlobals.h头文件中CollectGarbage函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CollectGarbage</span><span class="hljs-params">(EObjectFlags KeepFlags, <span class="hljs-keyword">bool</span> bPerformFullPurge)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// No other thread may be performing UObject operations while we&#x27;re running</span><br>AcquireGCLock();<br><br><span class="hljs-comment">// Perform actual garbage collection</span><br>CollectGarbageInternal(KeepFlags, bPerformFullPurge);<br><br><span class="hljs-comment">// Other threads are free to use UObjects</span><br>ReleaseGCLock();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到GC的整体流程很自然的划分成了三个阶段，获取GC锁、执行CollectGarbageInternal和释放GC锁。使用锁的原因是UEGC是多线程的，为了防止在GC的过程中对象被其他线程访问，以保证异步加载的稳定。而CollectGarbageInternal函数则进行垃圾回收和对象标记与清理，两个参数KeepFlags表示这些被标记的对象无论是否被引用都将被保留，bPerformFullPurge表示GC时进行全清理还是分帧分批清理。</p><p>那么GC又是如何进行对象标记的呢？还是看源码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * Deletes all unreferenced objects, keeping objects that have any of the passed in KeepFlags set</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @paramKeepFlagsobjects with those flags will be kept regardless of being referenced or not</span><br><span class="hljs-comment"> * @parambPerformFullPurgeif true, perform a full purge after the mark pass</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CollectGarbageInternal</span><span class="hljs-params">(EObjectFlags KeepFlags, <span class="hljs-keyword">bool</span> bPerformFullPurge)</span></span><br><span class="hljs-function"></span>&#123;<br>SCOPE_TIME_GUARD(TEXT(<span class="hljs-string">&quot;Collect Garbage&quot;</span>));<br>SCOPED_NAMED_EVENT(CollectGarbageInternal, FColor::Red);<br>CSV_EVENT_GLOBAL(TEXT(<span class="hljs-string">&quot;GC&quot;</span>));<br>CSV_SCOPED_TIMING_STAT_EXCLUSIVE(GarbageCollection);<br><br>FGCCSyncObject::Get().ResetGCIsWaiting();<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(WITH_CODE_GUARD_HANDLER) &amp;&amp; WITH_CODE_GUARD_HANDLER</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CheckImageIntegrityAtRuntime</span><span class="hljs-params">()</span></span>;<br>CheckImageIntegrityAtRuntime();<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>DECLARE_SCOPE_CYCLE_COUNTER( TEXT( <span class="hljs-string">&quot;CollectGarbageInternal&quot;</span> ), STAT_CollectGarbageInternal, STATGROUP_GC );<br>STAT_ADD_CUSTOMMESSAGE_NAME( STAT_NamedMarker, TEXT( <span class="hljs-string">&quot;GarbageCollection - Begin&quot;</span> ) );<br><br><span class="hljs-comment">// We can&#x27;t collect garbage while there&#x27;s a load in progress. E.g. one potential issue is Import.XObject</span><br>check(!IsLoading());<br><br><span class="hljs-comment">// Reset GC skip counter</span><br>GNumAttemptsSinceLastGC = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// Flush streaming before GC if requested</span><br><span class="hljs-keyword">if</span> (GFlushStreamingOnGC)<br>&#123;<br><span class="hljs-keyword">if</span> (IsAsyncLoading())<br>&#123;<br>UE_LOG(LogGarbage, Log, TEXT(<span class="hljs-string">&quot;CollectGarbageInternal() is flushing async loading&quot;</span>));<br>&#125;<br>FGCCSyncObject::Get().GCUnlock();<br>FlushAsyncLoading();<br>FGCCSyncObject::Get().GCLock();<br>&#125;<br><br><span class="hljs-comment">// Route callbacks so we can ensure that we are e.g. not in the middle of loading something by flushing</span><br><span class="hljs-comment">// the async loading, etc...</span><br>FCoreUObjectDelegates::GetPreGarbageCollectDelegate().Broadcast();<br>GLastGCFrame = GFrameCounter;<br><br>&#123;<br><span class="hljs-comment">// Set &#x27;I&#x27;m garbage collecting&#x27; flag - might be checked inside various functions.</span><br><span class="hljs-comment">// This has to be unlocked before we call post GC callbacks</span><br>FGCScopeLock GCLock;<br><br>UE_LOG(LogGarbage, Log, TEXT(<span class="hljs-string">&quot;Collecting garbage%s&quot;</span>), IsAsyncLoading() ? TEXT(<span class="hljs-string">&quot; while async loading&quot;</span>) : TEXT(<span class="hljs-string">&quot;&quot;</span>));<br><br><span class="hljs-comment">// Make sure previous incremental purge has finished or we do a full purge pass in case we haven&#x27;t kicked one</span><br><span class="hljs-comment">// off yet since the last call to garbage collection.</span><br><span class="hljs-keyword">if</span> (GObjIncrementalPurgeIsInProgress || GObjPurgeIsRequired)<br>&#123;<br>IncrementalPurgeGarbage(<span class="hljs-literal">false</span>);<br>FMemory::Trim();<br>&#125;<br>check(!GObjIncrementalPurgeIsInProgress);<br>check(!GObjPurgeIsRequired);<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> VERIFY_DISREGARD_GC_ASSUMPTIONS</span><br><span class="hljs-comment">// Only verify assumptions if option is enabled. This avoids false positives in the Editor or commandlets.</span><br><span class="hljs-keyword">if</span> ((GUObjectArray.DisregardForGCEnabled() || GUObjectClusters.GetNumAllocatedClusters()) &amp;&amp; GShouldVerifyGCAssumptions)<br>&#123;<br>DECLARE_SCOPE_CYCLE_COUNTER(TEXT(<span class="hljs-string">&quot;CollectGarbageInternal.VerifyGCAssumptions&quot;</span>), STAT_CollectGarbageInternal_VerifyGCAssumptions, STATGROUP_GC);<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> StartTime = FPlatformTime::Seconds();<br>VerifyGCAssumptions();<br>VerifyClustersAssumptions();<br>UE_LOG(LogGarbage, Log, TEXT(<span class="hljs-string">&quot;%f ms for Verify GC Assumptions&quot;</span>), (FPlatformTime::Seconds() - StartTime) * <span class="hljs-number">1000</span>);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-comment">// Fall back to single threaded GC if processor count is 1 or parallel GC is disabled</span><br><span class="hljs-comment">// or detailed per class gc stats are enabled (not thread safe)</span><br><span class="hljs-comment">// Temporarily forcing single-threaded GC in the editor until Modify() can be safely removed from HandleObjectReference.</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> bForceSingleThreadedGC = !FApp::ShouldUseThreadingForPerformance() || !FPlatformProcess::SupportsMultithreading() ||<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> PLATFORM_SUPPORTS_MULTITHREADED_GC</span><br>(FPlatformMisc::NumberOfCores() &lt; <span class="hljs-number">2</span> || GAllowParallelGC == <span class="hljs-number">0</span> || PERF_DETAILED_PER_CLASS_GC_STATS);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span><span class="hljs-comment">//PLATFORM_SUPPORTS_MULTITHREADED_GC</span></span><br><span class="hljs-literal">true</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span><span class="hljs-comment">//PLATFORM_SUPPORTS_MULTITHREADED_GC</span></span><br><br><span class="hljs-comment">// Perform reachability analysis.</span><br>&#123;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> StartTime = FPlatformTime::Seconds();<br>FRealtimeGC TagUsedRealtimeGC;<br>            <span class="hljs-comment">//-----------------------------------------------------------</span><br>TagUsedRealtimeGC.PerformReachabilityAnalysis(KeepFlags, bForceSingleThreadedGC);<br>            <span class="hljs-comment">//-----------------------------------------------------------</span><br>UE_LOG(LogGarbage, Log, TEXT(<span class="hljs-string">&quot;%f ms for GC&quot;</span>), (FPlatformTime::Seconds() - StartTime) * <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-comment">// Reconstruct clusters if needed</span><br><span class="hljs-keyword">if</span> (GUObjectClusters.ClustersNeedDissolving())<br>&#123;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> StartTime = FPlatformTime::Seconds();<br>GUObjectClusters.DissolveClusters();<br>UE_LOG(LogGarbage, Log, TEXT(<span class="hljs-string">&quot;%f ms for dissolving GC clusters&quot;</span>), (FPlatformTime::Seconds() - StartTime) * <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-comment">// Fire post-reachability analysis hooks</span><br>FCoreUObjectDelegates::PostReachabilityAnalysis.Broadcast();<br><br>&#123;<br>FGCArrayPool::Get().ClearWeakReferences(bPerformFullPurge);<br><br>GatherUnreachableObjects(bForceSingleThreadedGC);<br><br><span class="hljs-keyword">if</span> (bPerformFullPurge || !GIncrementalBeginDestroyEnabled)<br>&#123;<br>UnhashUnreachableObjects(<span class="hljs-comment">/**bUseTimeLimit = */</span> <span class="hljs-literal">false</span>);<br>FScopedCBDProfile::DumpProfile();<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Set flag to indicate that we are relying on a purge to be performed.</span><br>GObjPurgeIsRequired = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// Reset purged count.</span><br>GPurgedObjectCountSinceLastMarkPhase = <span class="hljs-number">0</span>;<br>GObjCurrentPurgeObjectIndexResetPastPermanent = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">// Perform a full purge by not using a time limit for the incremental purge. The Editor always does a full purge.</span><br><span class="hljs-keyword">if</span> (bPerformFullPurge || GIsEditor)<br>&#123;<br>IncrementalPurgeGarbage(<span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (bPerformFullPurge)<br>&#123;<br>ShrinkUObjectHashTables();<br>&#125;<br><br><span class="hljs-comment">// Destroy all pending delete linkers</span><br>DeleteLoaders();<br><br><span class="hljs-comment">// Trim allocator memory</span><br>FMemory::Trim();<br>&#125;<br><br><span class="hljs-comment">// Route callbacks to verify GC assumptions</span><br>FCoreUObjectDelegates::GetPostGarbageCollect().Broadcast();<br><br>STAT_ADD_CUSTOMMESSAGE_NAME( STAT_NamedMarker, TEXT( <span class="hljs-string">&quot;GarbageCollection - End&quot;</span> ) );<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我在PerformReachabilityAnalysis函数处做了标记，GC时UE就是通过这个函数进行对象标记的，PerformReachabilityAnalysis函数会做多线程实时的分析对象的引用关系，然后标记出可达与不可达对象。标记是如何进行的还得深入到PerformReachabilityAnalysis函数，再上源码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Performs reachability analysis.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param KeepFlagsObjects with these flags will be kept regardless of being referenced or not</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PerformReachabilityAnalysis</span><span class="hljs-params">(EObjectFlags KeepFlags, <span class="hljs-keyword">bool</span> bForceSingleThreaded = <span class="hljs-literal">false</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>LLM_SCOPE(ELLMTag::GC);<br><br>SCOPED_NAMED_EVENT(FRealtimeGC_PerformReachabilityAnalysis, FColor::Red);<br>DECLARE_SCOPE_CYCLE_COUNTER(TEXT(<span class="hljs-string">&quot;FRealtimeGC::PerformReachabilityAnalysis&quot;</span>), STAT_FArchiveRealtimeGC_PerformReachabilityAnalysis, STATGROUP_GC);<br><br><span class="hljs-comment">/** Growing array of objects that require serialization */</span><br>FGCArrayStruct* ArrayStruct = FGCArrayPool::Get().GetArrayStructFromPool();<br>TArray&lt;UObject*&gt;&amp; ObjectsToSerialize = ArrayStruct-&gt;ObjectsToSerialize;<br><br><span class="hljs-comment">// Reset object count.</span><br>GObjectCountDuringLastMarkPhase.Reset();<br><br><span class="hljs-comment">// Make sure GC referencer object is checked for references to other objects even if it resides in permanent object pool</span><br><span class="hljs-keyword">if</span> (FPlatformProperties::RequiresCookedData() &amp;&amp; FGCObject::GGCObjectReferencer &amp;&amp; GUObjectArray.IsDisregardForGC(FGCObject::GGCObjectReferencer))<br>&#123;<br>ObjectsToSerialize.Add(FGCObject::GGCObjectReferencer);<br>&#125;<br><br>&#123;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> StartTime = FPlatformTime::Seconds();<br>MarkObjectsAsUnreachable(ObjectsToSerialize, KeepFlags, bForceSingleThreaded);<br>UE_LOG(LogGarbage, Verbose, TEXT(<span class="hljs-string">&quot;%f ms for Mark Phase (%d Objects To Serialize&quot;</span>), (FPlatformTime::Seconds() - StartTime) * <span class="hljs-number">1000</span>, ObjectsToSerialize.Num());<br>&#125;<br><br>&#123;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> StartTime = FPlatformTime::Seconds();<br>PerformReachabilityAnalysisOnObjects(ArrayStruct, bForceSingleThreaded);<br>UE_LOG(LogGarbage, Verbose, TEXT(<span class="hljs-string">&quot;%f ms for Reachability Analysis&quot;</span>), (FPlatformTime::Seconds() - StartTime) * <span class="hljs-number">1000</span>);<br>&#125;<br>        <br><span class="hljs-comment">// Allowing external systems to add object roots. This can&#x27;t be done through AddReferencedObjects</span><br><span class="hljs-comment">// because it may require tracing objects (via FGarbageCollectionTracer) multiple times</span><br>FCoreUObjectDelegates::TraceExternalRootsForReachabilityAnalysis.Broadcast(*<span class="hljs-keyword">this</span>, KeepFlags, bForceSingleThreaded);<br><br>FGCArrayPool::Get().ReturnToPool(ArrayStruct);<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> UE_BUILD_DEBUG</span><br>FGCArrayPool::Get().CheckLeaks();<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>首先前面的宏暂时可以忽略掉，</p><p>第一步，<code>FGCArrayStruct* ArrayStruct = FGCArrayPool::Get().GetArrayStructFromPool();</code>UE将UObject的所有的强引用和弱引用都存储大ArrayStruct数据结构中，FGCArrayPool是UEGC的主要执行类</p><p>第二步，<code>TArray&lt;UObject*&gt;&amp; ObjectsToSerialize = ArrayStruct-&gt;ObjectsToSerialize;</code>分离UObject的强引用到ObjectsToSerialize 数组中。</p><p>这是FGCArrayStruct结构体的源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FGCArrayStruct</span></span><br><span class="hljs-class">&#123;</span><br>TArray&lt;UObject*&gt; ObjectsToSerialize;<br>TArray&lt;UObject**&gt; WeakReferences;<br>&#125;;<br></code></pre></td></tr></table></figure><p>ObjectsToSerialize存储强引用，WeakReferences存储弱引用。</p><p>第三步，<code>GObjectCountDuringLastMarkPhase.Reset();</code>重置对象的引用计数。</p><p>第四步，通过一个if判断标记可达对象，于是可达对象与不可达对象就被标记出来了，接下来便是GC清理。</p><h3 id="GC的触发"><a href="#GC的触发" class="headerlink" title="GC的触发"></a>GC的触发</h3><p>UE的GC发生在游戏线程上，支持多线程GC，和大多数主流语言的GC一样支持自动触发和手动触发。</p><p><strong>手动触发</strong></p><p>手动触发UE也提供了两种方式，其一是通过C++函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">GEngine-&gt;ForceGarbageCollection();<br></code></pre></td></tr></table></figure><p>这里需要注意的是<code>GEngine</code>在<code>Engine.h</code>头文件下。</p><p>手动触发的使用场景一般是在卸载某些资源后，手动触发GC回收这些资源在使用过程中的无用对象。</p><p>其二是蓝图节点：</p><p><img src="https://img-blog.csdnimg.cn/6ab594d5e4154b8585510ce4e8816e1d.png#pic_center"></p><p>手动调用这两个函数，UE会跳过GC算法，在下一次Tick时直接进行GC。</p><p><font color="red"> 这里有一点需要注意，在大多数情况下，手动GC一般只能回收NewObject函数创建的对象，而UWorld()-&gt;SpawnActor函数创建的对象无论如何调用都无法销毁，这是因为，当UE创建一个Actor之后在UWorld中就已经保存了这个Actor的引用，所以无论我们如何释放Actor的引用，这个Actor的引用计数都不会归零，所以要销毁一个Actor还是需要通过Actor-&gt;Destroy()函数。</font></p><p>我们可以个一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//AACtor.cpp</span><br>AActor1::AActor1()<br>&#123;<br>PrimaryActorTick.bCanEverTick = <span class="hljs-literal">true</span>;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Actor1 Created&quot;</span>));<br>&#125;<br><br>AActor1::~AActor1()<br>&#123;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Actor1 Destryed&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//AMyActor.h</span><br>UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">INSIDEUE4_API</span> <span class="hljs-title">AMyActor2</span> :</span> <span class="hljs-keyword">public</span> AActor<br>&#123;<br>GENERATED_BODY()<br><br><span class="hljs-keyword">public</span>:<br>AMyActor2();<br>AActor1 *a;<span class="hljs-comment">//注意这里没有加UPROPERTY()宏</span><br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Tick</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime)</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//AMyActor2</span><br>AMyActor2::AMyActor2()<br>&#123;<br>PrimaryActorTick.bCanEverTick = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AMyActor2::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br>a = UWorld()-&gt;SpawnActor&lt;AActor1&gt;();<br>a = <span class="hljs-literal">NULL</span>;<br>GEngine-&gt;ForceGarbageCollection();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AMyActor2::Tick</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime)</span></span><br><span class="hljs-function"></span>&#123;<br>Super::Tick(DeltaTime);<br>&#125;<br></code></pre></td></tr></table></figure><p>OutputLog:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-attr">LogTemp:</span> <span class="hljs-attr">Warning:</span> Actor1 Created<br></code></pre></td></tr></table></figure><p>可以看到使用UWorld()-&gt;SpawnActor创建的Actor即使手动强制GC也没有被回收，因为这个Actor是可达对象。</p><p><strong>自动触发</strong></p><p>要想UE自动触发的GC能能够回收我们创建的对象，那么我们创建的对象就必须继承自UObject，至于加不加UPROPERTY()宏似乎不影响GC的回收，如下面的测试结果，还是以上面的例子为例，把BeginPlay函数改为如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//AMyActor2</span><br>AMyActor2::AMyActor2()<br>&#123;<br>PrimaryActorTick.bCanEverTick = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AMyActor2::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br>a = NewObject&lt;AActor1&gt;();<br>a = <span class="hljs-literal">NULL</span>;<br>GEngine-&gt;ForceGarbageCollection();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AMyActor2::Tick</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime)</span></span><br><span class="hljs-function"></span>&#123;<br>Super::Tick(DeltaTime);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们将MyActor2拖入场景中，运行，OutputLog输出，可以找到下面两句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">LogTemp: Warning: Actor1 Created<br><br>LogTemp: Warning: Actor1 Destryed<br></code></pre></td></tr></table></figure><p>可以看到，没有使用UPROPERTY()宏的变量a依旧在手动GC时被回收了，这里为了效果明显点使用了手动强制回收，其实使用自动GC也是一样的。</p><p><font color="green">这里有提个疑问：</font></p><p>当我们在一个继承自UObject的类组合一个继承自UObject的对象，如果在这个对象定义前没有使用UPROPERTY()宏，那么在Play后UE会调用一次这个对象的析构函数，但是这个对象依然可以被使用，而如果在定义这个对象前使用了UPROPERTY()宏，那么这对象将和组合类被析构时一起被析构。疑问为什么UE会调用一次被组合对象的析构且析构后依然可以使用这个对象。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//UMyObject.cpp</span><br>UMyObject::UMyObject()<br>&#123;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;UMyObject Created&quot;</span>));<br>&#125;<br><br>UMyObject::~UMyObject()<br>&#123;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;UMyObject Destoryed&quot;</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UMyObject::Fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;UMyObject&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//AMyActor2.h</span><br>UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">INSIDEUE4_API</span> <span class="hljs-title">AMyActor2</span> :</span> <span class="hljs-keyword">public</span> AActor<br>&#123;<br>GENERATED_BODY()<br><br><span class="hljs-keyword">public</span>:<br>AMyActor2();<br>UPROPERTY()<br>UMyObject* obj;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Tick</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime)</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//AMyActor2.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AMyActor2::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br>obj = NewObject&lt;UMyObject&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><p>使用UPROPERTY()宏的输出结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//在点击Play后输出结果</span><br>LogTemp: Warning: AMyActor2 Created<br>LogTemp: Warning: UMyObject Created<br><span class="hljs-comment">//再点击Stop后输出结果</span><br>LogTemp: Warning: UMyObject Destoryed<br>LogTemp: Warning: AMyActor2 Destroyed<br></code></pre></td></tr></table></figure><p>不使用UPROPERTY()宏的输出结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//在点击Play后输出结果</span><br>LogTemp: Warning: AMyActor2 Created<br>LogTemp: Warning: UMyObject Created<br>LogTemp: Warning: UMyObject Destoryed<br><span class="hljs-comment">//再点击Stop后输出结果</span><br>LogTemp: Warning: AMyActor2 Destroyed<br></code></pre></td></tr></table></figure><p>很明显在Play后UMyObject对象的析构函数被调用了，但是此时如果继续访问UMyObject里的成员依旧可以访问。</p><h3 id="TWeakObjectPtr、TWeakPtr（既保存引用又可GC）"><a href="#TWeakObjectPtr、TWeakPtr（既保存引用又可GC）" class="headerlink" title="TWeakObjectPtr、TWeakPtr（既保存引用又可GC）"></a>TWeakObjectPtr、TWeakPtr（既保存引用又可GC）</h3><p>有时我们可能需要在一个类里面临时保存一些对象，但是一旦保存了引用，就需要手动释放才能保证这些对象可以被GC自动回收，关于这个方面UE也贴心的为我们提供了<font color="red"> TWeakObjectPtr</font>指针，当然，这也是C++弱指针的UE魔改办罢了，使用这个指针既可以引用对象，但是又不会造成引用计数+1。可以通过一个例子很好的看出来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//AACtor1.cpp</span><br>AActor1::AActor1()<br>&#123;<br>PrimaryActorTick.bCanEverTick = <span class="hljs-literal">true</span>;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Actor1 Created&quot;</span>));<br>&#125;<br><br>AActor1::~AActor1()<br>&#123;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Actor1 Destryed&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//AMyActor2</span><br>UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">INSIDEUE4_API</span> <span class="hljs-title">AMyActor2</span> :</span> <span class="hljs-keyword">public</span> AActor<br>&#123;<br>GENERATED_BODY()<br><br><span class="hljs-keyword">public</span>:<br>AMyActor2();<br>AActor1* a;<br>TWeakObjectPtr&lt;AActor1&gt; p;<br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Tick</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime)</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//AMyActor2.cpp/BeginPlay()</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AMyActor2::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br>a = NewObject&lt;AActor1&gt;();<br>p = a;<br>a = <span class="hljs-literal">NULL</span>;<br>GEngine-&gt;ForceGarbageCollection();<br>&#125;<br></code></pre></td></tr></table></figure><p>OutputLog:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-attr">LogTemp:</span> <span class="hljs-attr">Warning:</span> Actor1 Created<br><br><span class="hljs-attr">LogTemp:</span> <span class="hljs-attr">Warning:</span> Actor1 Destryed<br></code></pre></td></tr></table></figure><p>可以看到，AActor1对象依旧被强制回收了。</p><p>而TWeakPtr则对于自定义类的弱指针。</p><p><font color="red">注意：弱指针不可以被用来作为TSet或TMap的Key，因为一个对象被GC时无法通知一个容器的Key，但是可以用来作为容器的Value。</font></p><h3 id="TSharedPtr、TSharedRef（自定义类的GC）"><a href="#TSharedPtr、TSharedRef（自定义类的GC）" class="headerlink" title="TSharedPtr、TSharedRef（自定义类的GC）"></a>TSharedPtr、TSharedRef（自定义类的GC）</h3><p>自定义类的GC，UE也贴心的提供了<font color="red"> TSharedPtr和TSharedRef</font>对象来为自定义类支持GC，TSharedPtr本质上是一个被封装过的指针，使用形式上依然保留指针的风格。</p><p><font color="red"> 创建TSharedPtr指针指向一个自定义类时，需要使用<code>MakeShareable()</code>函数，如：</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">TSharedPtr&lt;UMyObject&gt; p = MakeShareable(NewObject&lt;UMyObject&gt;());<br>TSharedPtr&lt;FActor&gt; f = MakeShareable(<span class="hljs-keyword">new</span> FActor());<br></code></pre></td></tr></table></figure><p>TSharedPtr和TSharedRef都可以为自定义类提供GC功能，二者的区别只在于TSharedPtr可以为null，而SharedRef不可以。我在网上查询发现有三种方法构建TSharedRef，分别为：</p><p>第一种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">TSharedRef&lt;FActor&gt; <span class="hljs-title">ref</span><span class="hljs-params">(<span class="hljs-keyword">new</span> FActor())</span></span>;<br></code></pre></td></tr></table></figure><p>第二种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">TSharedRef&lt;FActor&gt; ref = MakeShared&lt;FActor&gt;(<span class="hljs-keyword">new</span> FActor());<br></code></pre></td></tr></table></figure><p>第三种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">TSharedPtr&lt;FActor&gt; ptr = MakeShareable&lt;FActor&gt;(<span class="hljs-keyword">new</span> FActor());<br>TSharedRef&lt;FActor&gt; ref = ptr.ToSharedRef();<br></code></pre></td></tr></table></figure><p>其中第二种方法在编写时没有任何问题但在编译时无法通过，并提示：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">The TSharedRef() <span class="hljs-function"><span class="hljs-keyword">constructor</span> <span class="hljs-title">is</span> <span class="hljs-title">for</span> <span class="hljs-title">internal</span> <span class="hljs-title">usage</span> <span class="hljs-title">only</span> <span class="hljs-title">for</span> <span class="hljs-title">hot</span>-<span class="hljs-title">reload</span> <span class="hljs-title">purposes</span>. <span class="hljs-title">Please</span> <span class="hljs-title">do</span> <span class="hljs-title">NOT</span> <span class="hljs-title">use</span> <span class="hljs-title">it</span>.</span><br></code></pre></td></tr></table></figure><p>使用的编译环境为：UE4.22 + VS2017</p><h3 id="FGCObject（在自定义类中控制UObject对象的GC）"><a href="#FGCObject（在自定义类中控制UObject对象的GC）" class="headerlink" title="FGCObject（在自定义类中控制UObject对象的GC）"></a>FGCObject（在自定义类中控制UObject对象的GC）</h3><p>当我们在一个自定义类中组合一个UObject对象时，如果不做特殊处理也会出现GC触发中发现的疑问，在自定义类没有被析构时，UObject的对象的析构函数就被调用了，但是对象依然可以被使用。目前没有发现这种情况会导致什么样的后果，但是作为一个合格的UE程序还是应该尽量避免这种情况的发生，那么在一个自定义类中组合一个UObject对象，应该如何控制UObject对象的GC呢？</p><p>UE4提供了一个叫做<font color="red">FGCObject</font>的类，位于<font color="red">GCObject.h</font>头文件中，我们需要使自定义类继承自FGCObject类，然后再实现AddReferencedObjects函数，并在函数中通过Collector.AddReferencedObject()函数将所有的UObject对象UE4自动管理即可。</p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">INSIDEUE4_API</span> <span class="hljs-title">FActor</span> :</span> FGCObject<br>&#123;<br><span class="hljs-keyword">public</span>:<br>FActor();<br>~FActor();<br>UMyObject* obj;<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddReferencedObjects</span><span class="hljs-params">(FReferenceCollector&amp; Collector)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function"></span>&#123;<br>Collector.AddReferencedObject(obj);<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后，UObject对象就会在FActor对象析构时才被析构。</p><h2 id="2-序列化"><a href="#2-序列化" class="headerlink" title="2.序列化"></a>2.序列化</h2><h3 id="FObjectWriter和FObjectReader序列化对象到文件和从文件读取"><a href="#FObjectWriter和FObjectReader序列化对象到文件和从文件读取" class="headerlink" title="FObjectWriter和FObjectReader序列化对象到文件和从文件读取"></a>FObjectWriter和FObjectReader序列化对象到文件和从文件读取</h3><p>FObjectWriter可以将对象数据序列化为二进制流，然后配合FFileHelper将流写入文件即可实现对象状态存储到文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOperatActor::SaveObject</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>USerializationObj* obj= NewObject&lt;USerializationObj&gt;();<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;OldStr:%s&quot;</span>), *obj-&gt;str);<br>obj-&gt;str = TEXT(<span class="hljs-string">&quot;OperatActor&quot;</span>);<br>TArray&lt;uint8&gt; bytes;<br>FObjectWriter(obj, bytes);<br>FFileHelper::SaveArrayToFile(bytes, *FString(<span class="hljs-string">&quot;D:\\Goulandis\\UE4\\MyProject\\obj.txt&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>配合FFileHelper将文件中的对象状态读入字节数组，FObjectReader就可以将字节数组中的对象状态写入新的对象中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">USerializationObj* <span class="hljs-title">AOperatActor::LoadObject</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>USerializationObj* newObj = NewObject&lt;USerializationObj&gt;();<br>TArray&lt;uint8&gt; bytes;<br>FFileHelper::LoadFileToArray(bytes, *FString(<span class="hljs-string">&quot;D:\\Goulandis\\UE4\\MyProject\\obj.txt&quot;</span>));<br><span class="hljs-function">FObjectReader <span class="hljs-title">reader</span><span class="hljs-params">(newObj, bytes)</span></span>;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;NewStr:%s&quot;</span>), *newObj-&gt;str);<br><span class="hljs-keyword">return</span> newObj;<br>&#125;<br></code></pre></td></tr></table></figure><p>看一下运行结果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142748.png"></p><p>可以看到，新创建的USerializationObj对象的状态是被修改过后的状态。</p><p>Actor的使用方式和UObject是一样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOperatActor::SaveActor</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ASerializationActor* actor = GetWorld()-&gt;SpawnActor&lt;ASerializationActor&gt;();<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;OldStr:%s&quot;</span>), *actor-&gt;str);<br>actor-&gt;str = TEXT(<span class="hljs-string">&quot;NewActor&quot;</span>);<br>TArray&lt;uint8&gt; bytes;<br>FObjectWriter(actor, bytes);<br>FFileHelper::SaveArrayToFile(bytes, *FString(<span class="hljs-string">&quot;D:\\Goulandis\\UE4\\MyProject\\actor.txt&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ASerializationActor * <span class="hljs-title">AOperatActor::LoadActor</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ASerializationActor* actor = GetWorld()-&gt;SpawnActor&lt;ASerializationActor&gt;();<br>TArray&lt;uint8&gt; bytes;<br>FFileHelper::LoadFileToArray(bytes, *FString(<span class="hljs-string">&quot;D:\\Goulandis\\UE4\\MyProject\\actor.txt&quot;</span>));<br><span class="hljs-function">FObjectReader <span class="hljs-title">reader</span><span class="hljs-params">(actor,bytes)</span></span>;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;NewStr:%s&quot;</span>), *actor-&gt;str);<br><span class="hljs-keyword">return</span> actor;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142724.png"></p><h2 id="3-反射"><a href="#3-反射" class="headerlink" title="3.反射"></a>3.反射</h2><p>在使用UE4的反射时有一个基础概念是必须要清楚的，即UE4的反射系统是建立在一整套的宏的设计上的，也就是说，想要一个类、属性、方法、枚举、结构体等支持UE4的反射，那么类必须加UCLASS宏标识，属性必须加UPROPERTTY宏标识，方法必须加UFUNCTION宏标识，枚举必须加UENUM宏标识，结构体必须加USTRUCT宏标识，如果不加这些宏来标识对应的目标，那么这些目标对于UE4的反射系统来说就是不可见的。</p><h3 id="搜索所有的Object"><a href="#搜索所有的Object" class="headerlink" title="搜索所有的Object"></a>搜索所有的Object</h3><p>C++本身的反射系统RTTI相当薄弱，所以UE在C++的基础上借助UObject自己实现了一套反射系统，同时借鉴了C#的长处提供了一系列反射用的系统函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">TArray&lt;UObject*&gt; result;<br>GetObjectsOfClass(UClass::StaticClass(), result);   <span class="hljs-comment">//获取所有的class和interface</span><br>GetObjectsOfClass(UEnum::StaticClass(), result);   <span class="hljs-comment">//获取所有的enum</span><br>GetObjectsOfClass(UScriptStruct::StaticClass(), result);   <span class="hljs-comment">//获取所有的struct</span><br></code></pre></td></tr></table></figure><h3 id="运行时创建对象"><a href="#运行时创建对象" class="headerlink" title="运行时创建对象"></a>运行时创建对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOperatActor::FindSerializationObj</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>UClass* uclass = FindObject&lt;UClass&gt;(ANY_PACKAGE, TEXT(<span class="hljs-string">&quot;SerializationObj&quot;</span>));<br>USerializationObj* obj = Cast&lt;USerializationObj&gt;(uclass-&gt;GetDefaultObject());<br>obj-&gt;PrintStr();<br>&#125;<br></code></pre></td></tr></table></figure><p>UE4提供FindObject模板函数来搜索指定的类的类型信息，返回的类型元素据通过UClass类型对象存储，UClass对象就是UE4专门用来存储元数据的类型，UClass中提供了大量的方法来操作元数据，<a href="https://docs.unrealengine.com/en-US/API/Runtime/CoreUObject/UObject/UClass/index.html">UClass</a>，这里使用GetDefaultObject函数调用默认的构造函数创建SerializationObj类型的对象，需要注意的是GetDefaultObject返回的是一个UObject对象，所以需要使用Cast来做类型转换。</p><h3 id="遍历对象内所有的属性、函数"><a href="#遍历对象内所有的属性、函数" class="headerlink" title="遍历对象内所有的属性、函数"></a>遍历对象内所有的属性、函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOperatActor::Foreach</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>UClass* uclass = FindObject&lt;UClass&gt;(ANY_PACKAGE, TEXT(<span class="hljs-string">&quot;SerializationObj&quot;</span>));<br>USerializationObj* obj = Cast&lt;USerializationObj&gt;(uclass-&gt;GetDefaultObject());<br>    UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;UProprty Start&quot;</span>));<br><span class="hljs-keyword">for</span> (TFieldIterator&lt;UProperty&gt; i(obj-&gt;GetClass()); i; ++i)<br>&#123;<br>UProperty* up = *i;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;UProperty:%s&quot;</span>), *up-&gt;GetName());<br>&#125;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;UProprty End&quot;</span>));<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;UFunction Start&quot;</span>));<br><span class="hljs-keyword">for</span> (TFieldIterator&lt;UFunction&gt; i(obj-&gt;GetClass()); i; ++i)<br>&#123;<br>UFunction* uf = *i;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;UFunction:%s&quot;</span>), *uf-&gt;GetName());<br>&#125;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;UFunction End&quot;</span>));<br>&#125;<br><br></code></pre></td></tr></table></figure><p>USerializationObj头文件内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">UCLASS(BlueprintType)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROJECT_API</span> <span class="hljs-title">USerializationObj</span> :</span> <span class="hljs-keyword">public</span> UObject<br>&#123;<br>GENERATED_BODY()<br><span class="hljs-keyword">public</span>:<br>UPROPERTY(BlueprintReadWrite)<br>FString str = <span class="hljs-string">&quot;Init String&quot;</span>;<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br><br>USerializationObj();<br>UFUNCTION()<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintStr</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>输出：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142713.png"></p><p><font color="red">注意：</font></p><ul><li><font color="red">对于<code>UClass* uclass = FindObject&lt;UClass&gt;(ANY_PACKAGE, TEXT(&quot;SerializationObj&quot;));</code>需要注意的是UClass不能使用智能指针来装载，如：<code>TSharedPtr&lt;UClass&gt; uclass = MakeShared(FindObject&lt;UClass&gt;(ANY_PACKAGE,TEXT(&quot;SerializationObje&quot;)))</code>，使用智能指针在编译阶段和运行阶段都没有问题，但是结束运行时会导致引擎崩溃（直接启动的引擎会崩溃，通过vs启动的引擎会报异常），根据崩溃的提示，原因视乎和GC有关，具体原因未明。</font></li><li><font color="red"><code>for (TFieldIterator&lt;UProperty&gt; i(obj-&gt;GetClass()); i; ++i)</code>的i的构造参数是UClass类型，而GetClass函数是一个实例函数，所以要取得一个类的UClass数据就不得不提供一个它的实例</font></li></ul><p>此外由于静态变量无法被UPROPERTY宏标识，所以static属性对于UE4的反射系统来说也是不可见的，使用<code>for (TFieldIterator&lt;UProperty&gt; i(obj-&gt;GetClass()); i; ++i)</code>遍历属性是可以发现其中没有静态属性的。</p><h3 id="遍历类的继承的所有接口"><a href="#遍历类的继承的所有接口" class="headerlink" title="遍历类的继承的所有接口"></a>遍历类的继承的所有接口</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOperatActor::Foreach</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    UClass* uclass = FindObject&lt;UClass&gt;(ANY_PACKAGE, TEXT(<span class="hljs-string">&quot;SerializationObj&quot;</span>));<br>USerializationObj* obj = Cast&lt;USerializationObj&gt;(uclass-&gt;GetDefaultObject());<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Interfaces Start&quot;</span>));<br><span class="hljs-keyword">for</span> (FImplementedInterface&amp; i : obj-&gt;GetClass()-&gt;Interfaces)<br>&#123;<br>UClass* inter = i.Class;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Interface:%s&quot;</span>), *inter-&gt;GetName());<br>&#125;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Interfaces End&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>USerializationObj头文件内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">UCLASS(BlueprintType)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROJECT_API</span> <span class="hljs-title">USerializationObj</span> :</span> <span class="hljs-keyword">public</span> UObject,<span class="hljs-keyword">public</span> ITestInterface1,<span class="hljs-keyword">public</span> ITestInterface2<br>&#123;<br>GENERATED_BODY()<br><span class="hljs-keyword">public</span>:<br>UPROPERTY(BlueprintReadWrite)<br>FString str = <span class="hljs-string">&quot;Init String&quot;</span>;<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br><br>USerializationObj();<br>UFUNCTION()<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintStr</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142435.png" alt="、"></p><h3 id="遍历枚举"><a href="#遍历枚举" class="headerlink" title="遍历枚举"></a>遍历枚举</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++">UENUM()<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">TestEnum</span></span><br><span class="hljs-class">&#123;</span><br>A,<br>B,<br>C<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOperatActor::Foreach</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Enum Start&quot;</span>));<br>UEnum* enumClass = StaticEnum&lt;TestEnum&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; enumClass-&gt;NumEnums() - <span class="hljs-number">1</span>; i++)<br>&#123;<br>FString enumStr = enumClass-&gt;GetValueAsString(TestEnum(enumClass-&gt;GetValueByIndex(i)));<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Enum:%s&quot;</span>), *enumStr);<br>&#125;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Enum End&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142430.png"></p><h3 id="遍历元数据"><a href="#遍历元数据" class="headerlink" title="遍历元数据"></a>遍历元数据</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOperatActor::Foreach</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    UClass* uclass = FindObject&lt;UClass&gt;(ANY_PACKAGE, TEXT(<span class="hljs-string">&quot;SerializationObj&quot;</span>));<br>USerializationObj* obj = Cast&lt;USerializationObj&gt;(uclass-&gt;GetDefaultObject());<br>    UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Meta Start&quot;</span>));<br>UMetaData* meta = obj-&gt;GetOutermost()-&gt;GetMetaData();<br>TMap&lt;FName, FString&gt;* keyValues = meta-&gt;GetMapForObject(obj);<br><span class="hljs-keyword">if</span> (keyValues != <span class="hljs-literal">nullptr</span> &amp;&amp; keyValues-&gt;Num() &gt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">for</span> (TPair&lt;FName, FString&gt; p : *keyValues)<br>&#123;<br>FString key = p.Key.ToString();<br>FString vuale = p.Value;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Meta:Key=%s,Value=%s&quot;</span>),*key,*vuale);<br>&#125;<br>&#125;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Meta End&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="red">需要注意的是，一个对象的UMetaData数据不能直接获取，而需要通过GetOutermost函数获取这个对象的UPakage对象再通过UPakage对象的GetMetaData函数来获取，由于UE4使用<code>TMap&lt;FName,FString&gt;</code>的数据结构来存储元数据，所以我们通过UMetaData对象的GetMapForObject函数获取的元数据需要使用一个<code>TMap&lt;FName,FString&gt;来存储，而TMap的元素又是一个TPair，所以遍历时可以使用一个范围for循环并使用</code>TPair&lt;FName,FString&gt;<code>结构来存储取出的</code>TMap&lt;FName,FString&gt;<code>元素。</code></font></p><p>对于元素据暂时没有深入去研究，总之如果我们只创建一个UObject类并且只往里面添加一些属性和函数，类的元数据都是空的，尝试过向UCLASS和UPROPERTY宏中添加meta内容，元数据依旧是空的，所以在使用<code>TMap&lt;FName,FString&gt;</code>时最好先判空。</p><p><font color="red">这里有一个坑，就是UE_LOG不能打印FName类型的字符串，FName类型字符串必须通过ToString函数转换成FString才能被UE_LOG打印，更坑的是直接打印FName时，在编写代码时编辑器不会报错，只有在编译时才会报错。</font></p><h3 id="遍历继承关系"><a href="#遍历继承关系" class="headerlink" title="遍历继承关系"></a>遍历继承关系</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOperatActor::Foreach</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;SuperClass Start&quot;</span>));<br>TArray&lt;FString&gt; className;<br>className.Add(obj-&gt;GetClass()-&gt;GetName());<br>UClass* super = obj-&gt;GetClass()-&gt;GetSuperClass();<br><span class="hljs-keyword">while</span> (super)<br>&#123;<br>className.Add(super-&gt;GetName());<br>super = super-&gt;GetSuperClass();<br>&#125;<br>FString superClassStr = FString::Join(className, TEXT(<span class="hljs-string">&quot;-&gt;&quot;</span>));<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;SuperClass:%s&quot;</span>), *superClassStr);<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;SuperClass End&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142403.png"></p><p>将UClass换成UStruct最终效果也是一样的，因为UClass继承自UStruct。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOperatActor::Foreach</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;SuperClass Start&quot;</span>));<br>TArray&lt;FString&gt; className;<br>className.Add(obj-&gt;GetClass()-&gt;GetName());<br>UStruct* super = obj-&gt;GetClass()-&gt;GetSuperUStruct();<br><span class="hljs-keyword">while</span> (super)<br>&#123;<br>className.Add(super-&gt;GetName());<br>super = super-&gt;GetSuperUStruct();<br>&#125;<br>FString superClassStr = FString::Join(className, TEXT(<span class="hljs-string">&quot;-&gt;&quot;</span>));<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;SuperClass:%s&quot;</span>), *superClassStr);<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;SuperClass End&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="遍历所有的子类"><a href="#遍历所有的子类" class="headerlink" title="遍历所有的子类"></a>遍历所有的子类</h3><p>首先为USerializationObj类创建两个子类：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142357.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">oid <span class="hljs-title">AOperatActor::Foreach</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;DerivedClass Start&quot;</span>));<br>TArray&lt;UClass*&gt; res;<br>GetDerivedClasses(USerializationObj::StaticClass(), res, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">for</span> (UClass* uc : res)<br>&#123;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;SubClass:%s&quot;</span>),*uc-&gt;GetName());<br>&#125;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;DerivedClass End&quot;</span>));   <br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142332.png"></p><h3 id="动态操作实例属性"><a href="#动态操作实例属性" class="headerlink" title="动态操作实例属性"></a>动态操作实例属性</h3><p>UE4提供了一个通过名字来动态获取属性的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOperatActor::Invoke</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    UClass* uclass = FindObject&lt;UClass&gt;(ANY_PACKAGE, TEXT(<span class="hljs-string">&quot;SerializationObj&quot;</span>));<br>USerializationObj* obj = Cast&lt;USerializationObj&gt;(uclass-&gt;GetDefaultObject());<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;FindPropertyByName Start&quot;</span>));<br>UProperty* upro = obj-&gt;GetClass()-&gt;FindPropertyByName(FName(TEXT(<span class="hljs-string">&quot;str&quot;</span>)));<br>FString* str = upro-&gt;ContainerPtrToValuePtr&lt;FString&gt;(obj);<br>check(str);<br>*str = TEXT(<span class="hljs-string">&quot;UProperty FString&quot;</span>);<br>obj-&gt;PrintStr();<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;FindPropertyByName End&quot;</span>));<br>&#125;<br><br></code></pre></td></tr></table></figure><p>SerializationObj类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">UCLASS(BlueprintType,meta=(DiaplayName=<span class="hljs-string">&quot;Obj&quot;</span>))<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROJECT_API</span> <span class="hljs-title">USerializationObj</span> </span><br><span class="hljs-class">&#123;</span><br>GENERATED_BODY()<br><span class="hljs-keyword">public</span>:<br>UPROPERTY(BlueprintReadWrite,meta=(EditCondition=<span class="hljs-string">&quot;bCanNamePropertyShow&quot;</span>))<br>FString str = <span class="hljs-string">&quot;Init String&quot;</span>;<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span>:<br>    UPROPERTY()<br>FString priStr = TEXT(<span class="hljs-string">&quot;Private String&quot;</span>);<br><span class="hljs-keyword">public</span>:<br>USerializationObj();<br>UFUNCTION()<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintStr</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142327.png"></p><p><code>UClass::FindPropertyByName()</code>函数可以通过名字来访问调用对象中的属性，而FindPropertyByName()返回的也不是直接可用的属性，而是包含这个属性信息的UProperty类，然后通过<code>UProperty::ContainerPtrToValuePtr()</code>函数可以获取这个属性的指针，通过这个指针即可修改属性的值了。这个方法可直接修改实例中的任何属性，在测试修改const属性时发现了一个问题，即被UPROPERTY宏修饰的属性如果加上const那么程序将无法编译通过</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142323.png"></p><p>除此之外也可通过遍历属性的方法来获取想要的属性，同样支持任何保护级</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOperatActor::Invoke</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    UClass* uclass = FindObject&lt;UClass&gt;(ANY_PACKAGE, TEXT(<span class="hljs-string">&quot;SerializationObj&quot;</span>));<br>USerializationObj* obj = Cast&lt;USerializationObj&gt;(uclass-&gt;GetDefaultObject());<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Private Property Start&quot;</span>));<br><span class="hljs-keyword">for</span> (TFieldIterator&lt;UProperty&gt; i(obj-&gt;GetClass()); i; ++i)<br>&#123;<br>UProperty* up = *i;<br><span class="hljs-keyword">if</span> (up-&gt;GetName() == TEXT(<span class="hljs-string">&quot;priStr&quot;</span>))<br>&#123;<br>FString* priStr = up-&gt;ContainerPtrToValuePtr&lt;FString&gt;(obj);<br>check(priStr);<br>*priStr = TEXT(<span class="hljs-string">&quot;UProperty PrivateString&quot;</span>);<br>obj-&gt;PrintPrivateStr();<br>&#125;<br>&#125;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Private Property End&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>当然直接通过指针来操作属性在安全性上是不够的，大多数时候我们可能只是需要属性的一份值拷贝就够了，所以UE4针对FString类型的属性提供了两个更安全的操作函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOperatActor::Invoke</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    UClass* uclass = FindObject&lt;UClass&gt;(ANY_PACKAGE, TEXT(<span class="hljs-string">&quot;SerializationObj&quot;</span>));<br>USerializationObj* obj = Cast&lt;USerializationObj&gt;(uclass-&gt;GetDefaultObject());<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;ExportTextItem Start&quot;</span>));<br>FString outStr;<br>UProperty* outUpro = obj-&gt;GetClass()-&gt;FindPropertyByName(FName(TEXT(<span class="hljs-string">&quot;str&quot;</span>)));<br>outUpro-&gt;ExportTextItem(outStr, outUpro-&gt;ContainerPtrToValuePtr&lt;FString*&gt;(obj), <span class="hljs-literal">nullptr</span>, (UObject<br>*)obj, PPF_None);<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;OutStr:%s&quot;</span>),*outStr);<br>outStr = TEXT(<span class="hljs-string">&quot;NewFString&quot;</span>);<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;OutStr:%s&quot;</span>), *outStr);<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;OutStr:%s&quot;</span>), *obj-&gt;str);<br>FString inStr = TEXT(<span class="hljs-string">&quot;NewFString&quot;</span>);<br>outUpro-&gt;ImportText(*inStr, outUpro-&gt;ContainerPtrToValuePtr&lt;FString*&gt;(obj), PPF_None, obj);<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;InStr:%s&quot;</span>), *obj-&gt;str);<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;ExportTextItem End&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142316.png"></p><p><code>UProperty::ExportTextIte</code>函数返回的是一个FString，而非FString*，所以获取到的是一份FString的拷贝，可以看到我们对outStr做修改是不会影响到到obj中的str的，同时UE4也提供拷贝设值<code>UProperty::ImportText</code>函数，将inStr的值拷贝赋值到obj的str中，之后obj的str的值就发生了变化。</p><h3 id="动态调用实例函数"><a href="#动态调用实例函数" class="headerlink" title="动态调用实例函数"></a>动态调用实例函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOperatActor::InvokeFunction</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;InvokeFunction Start&quot;</span>));<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fun_Params</span></span><br><span class="hljs-class">&#123;</span><br>FString pam1;<br><span class="hljs-keyword">bool</span> pam2;<br>FString ret;<br>&#125;;<br>UClass* uclass = FindObject&lt;UClass&gt;(ANY_PACKAGE, TEXT(<span class="hljs-string">&quot;SerializationObj&quot;</span>));<br>USerializationObj* obj = Cast&lt;USerializationObj&gt;(uclass-&gt;GetDefaultObject());<br>UFunction* fun = obj-&gt;FindFunctionChecked(<span class="hljs-string">&quot;ExcternalInvokeFun&quot;</span>);<br>Fun_Params pams;<br>pams.pam1 = TEXT(<span class="hljs-string">&quot;Invoke ExcternalInvokeFun&quot;</span>);<br>pams.pam2 = <span class="hljs-literal">true</span>;<br>obj-&gt;ProcessEvent(fun, &amp;pams);<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;InvokeFunction:ret=%s&quot;</span>), *pams.ret);<br>UFunction* fun_none = obj-&gt;FindFunctionChecked(<span class="hljs-string">&quot;PrintStr&quot;</span>);<br>obj-&gt;ProcessEvent(fun_none, <span class="hljs-literal">nullptr</span>);<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;InvokeFunction End&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>SerializationObj头文件内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++">UCLASS(BlueprintType,meta=(DiaplayName=<span class="hljs-string">&quot;Obj&quot;</span>))<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROJECT_API</span> <span class="hljs-title">USerializationObj</span> :</span> <span class="hljs-keyword">public</span> UObject,<span class="hljs-keyword">public</span> ITestInterface1,<span class="hljs-keyword">public</span> ITestInterface2<br>&#123;<br>GENERATED_BODY()<br><span class="hljs-keyword">public</span>:<br>UPROPERTY(BlueprintReadWrite,meta=(EditCondition=<span class="hljs-string">&quot;bCanNamePropertyShow&quot;</span>))<br>FString str = <span class="hljs-string">&quot;Init String&quot;</span>;<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">static</span> FString staticStr;<br><span class="hljs-keyword">private</span>:<br>UPROPERTY()<br>FString priStr = TEXT(<span class="hljs-string">&quot;Private String&quot;</span>);<br><span class="hljs-keyword">public</span>:<br>USerializationObj();<br>UFUNCTION()<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintStr</span><span class="hljs-params">()</span></span>;<br>UFUNCTION()<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintPrivateStr</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>;<br>UFUNCTION()<br><span class="hljs-function">FString <span class="hljs-title">ExcternalInvokeFun</span><span class="hljs-params">(FString pam1, <span class="hljs-keyword">bool</span> pam2)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142309.png"></p><p>事实上真正通过反射调用函数的方法是：<code>ProcessEvent</code>，而有参函数和无参函数的调用又有所区别，首先需要通过<code>UObject::FindFunctionChecked</code>函数通过函数名获取函数的元数据信息存储到UFunction类中，无参函数的调用就可以直接通过<code>ProcessEvent(UFunction*,nullptr)</code>来调用了，第一个参数是存储了指定函数元数据信息的UFunction，由于没有参数所以传入函数参数的第二个参数直接设为nullptr即可。</p><p>而对于有参数有返回值的函数调用，则需要提前创建好存储函数参数和返回值的结构体，如上面例子中Fun_Params，名字可以随意取，但是结构体的成员类型、数量和顺序必须和对应的gen.cpp文件中UE4为这个函数创建的存储函数参数信息的结构体一直，我们可以看一下这个结构体的结构，位置在：项目根目录\Intermediate\Build\Win64\UE4Editor\Inc\MyProject\SerializationObj.gen.cpp，我这里类的名字是SerializationObj，所以文件叫SerializationObj.gen.cpp。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SerializationObj_eventExcternalInvokeFun_Parms</span></span><br><span class="hljs-class">&#123;</span><br>FString pam1;<br><span class="hljs-keyword">bool</span> pam2;<br>FString ReturnValue;<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后对应函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">FString <span class="hljs-title">USerializationObj::ExcternalInvokeFun</span><span class="hljs-params">(FString pam1, <span class="hljs-keyword">bool</span> pam2)</span></span><br><span class="hljs-function"></span>&#123;<br>FString ret = TEXT(<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-keyword">if</span> (pam2)<br>&#123;<br>ret = pam1 + TEXT(<span class="hljs-string">&quot;_True&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>ret = pam1 + TEXT(<span class="hljs-string">&quot;_False&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>结构体的成员和函数的参数列表类型和顺序一一对应的，最后一个成员固定名字为ReturnValue用于存储函数的返回值。</p><p>所以我们在调用有参有返回值的函数时需要创建一个对应这种结构的结构体，使用这个结构体的变量来传递参数和接收返回值，如上面例子中的：pams。</p><p>相较于C#中Invoke函数，将参数和返回值直接装箱至object中，UE4却没有办法这么做，因为UE4的UObject系统和原生C++可以算是两套系统，UE4的UObject没办法像C#那样将所有的类型都装箱到UObject中，索性把装箱的操作直接交给开发者做了，所以才有创建存储参数返回值的结构体的步骤。</p><h3 id="C-通过反射调用蓝图函数和事件"><a href="#C-通过反射调用蓝图函数和事件" class="headerlink" title="C++通过反射调用蓝图函数和事件"></a>C++通过反射调用蓝图函数和事件</h3><p>由于蓝图函数和事件在编译后也是以UFunction的元数据存储的，所以通过反射是可以实现C++调用蓝图函数和事件的。</p><p>首先创建一个继承自Actor的蓝图MyBlueprint，并在蓝图中新增函数PrintStr和自定义事件PrintWorld：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142302.png"></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142257.png"></p><p>然后在C++中增加调用蓝图函数和事件的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOperatActor::InvokeBPFunction</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (TActorIterator&lt;AActor&gt; bpActor(GetWorld()); bpActor; ++bpActor)<br>&#123;<br><span class="hljs-keyword">if</span> (bpActor-&gt;GetName() == TEXT(<span class="hljs-string">&quot;MyBlueprint&quot;</span>))<br>&#123;<br><span class="hljs-keyword">for</span> (TFieldIterator&lt;UFunction&gt; bpFun(bpActor-&gt;GetClass()); bpFun; ++bpFun)<br>&#123;<br><span class="hljs-keyword">if</span> (bpFun-&gt;HasAnyFunctionFlags(FUNC_BlueprintEvent) &amp;&amp; bpFun-&gt;HasAnyFunctionFlags(FUNC_BlueprintCallable) &amp;&amp; bpFun-&gt;GetName() == TEXT(<span class="hljs-string">&quot;PrintStr&quot;</span>))<br>&#123;<br>UFunction* fun = *bpFun;<br>uint8* buff = <span class="hljs-keyword">static_cast</span>&lt;uint8*&gt;(FMemory_Alloca(fun-&gt;ParmsSize));<br>FFrame frame = FFrame(*bpActor, fun, buff);<br>fun-&gt;Invoke(*bpActor, frame, buff);<br>&#125;<br><span class="hljs-keyword">if</span> (bpFun-&gt;HasAnyFunctionFlags(FUNC_BlueprintEvent) &amp;&amp; bpFun-&gt;HasAnyFunctionFlags(FUNC_BlueprintCallable) &amp;&amp; bpFun-&gt;GetName() == TEXT(<span class="hljs-string">&quot;PrintWorld&quot;</span>))<br>&#123;<br>UFunction* fun = *bpFun;<br>uint8* buff = <span class="hljs-keyword">static_cast</span>&lt;uint8*&gt;(FMemory_Alloca(fun-&gt;ParmsSize));<br>FFrame frame = FFrame(*bpActor, fun, buff);<br>fun-&gt;Invoke(*bpActor, frame, buff);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们逐行分析：</p><p><code>for (TActorIterator&lt;AActor&gt; bpActor(GetWorld()); bpActor; ++bpActor)</code>，遍历Level中所有的Actor，这里有一个坑，就是GetWorld()必须使用Actor自身的GetWorld()函数，不能使用GEngine-&gt;GetWorld()，否则运行时会提示资源被占用；</p><p><code>if (bpActor-&gt;GetName() == TEXT(&quot;MyBlueprint&quot;))</code>，找到我们需要的蓝图；</p><p><code>for (TFieldIterator&lt;UFunction&gt; bpFun(bpActor-&gt;GetClass()); bpFun; ++bpFun)</code>，遍历蓝图中的所有的函数和事件，蓝图函数和事件在底层元数据都是以UFunction的形式存储的，所以遍历的时候可以同时遍历函数和事件；</p><p><code>if (bpFun-&gt;HasAnyFunctionFlags(FUNC_BlueprintEvent) &amp;&amp; bpFun-&gt;HasAnyFunctionFlags(FUNC_BlueprintCallable) &amp;&amp; bpFun-&gt;GetName() == TEXT(&quot;PrintStr&quot;))</code>，找到蓝图中名字为PrintStr的函数HasAnyFunctionFlags()函数用于判断当前函数是否拥有某个标记，如：FUNC_BlueprintEvent—函数时蓝图事件，FUNC_BlueprintCallable—函数是蓝图可调用函数即蓝图函数；</p><p><code>UFunction* fun = *bpFun;</code>获取函数的元素据存储到UFunction中；</p><p><code>uint8* buff = static_cast&lt;uint8*&gt;(FMemory_Alloca(fun-&gt;ParmsSize));</code>，为函数栈申请内存空间，FMemory_Alloca申请自动内存的宏，fun-&gt;ParmsSize函数的总变量大小；</p><p><code>FFrame frame = FFrame(*bpActor, fun, buff);</code>，创建函数栈；</p><p><code>fun-&gt;Invoke(*bpActor, frame, buff);</code>，通过函数栈执行函数</p><p>这种方式调用蓝图函数虽然很灵活方便，但是效率实在堪忧，能不用还是尽量别用吧。</p><h3 id="C-通过子类重写调用蓝图函数"><a href="#C-通过子类重写调用蓝图函数" class="headerlink" title="C++通过子类重写调用蓝图函数"></a>C++通过子类重写调用蓝图函数</h3><p>通过C++父类申明函数，蓝图子类实现函数，C++父类调用函数的方式也可以实现C++调用蓝图函数，虽然这种方式不属于反射的范畴了，不过想起来了还是记录一下吧。</p><p>首先对于C++类AOperActor创建一个给蓝图来实现的函数BPPrint</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROJECT_API</span> <span class="hljs-title">AOperatActor</span> :</span> <span class="hljs-keyword">public</span> AActor<br>&#123;<br>GENERATED_BODY()<br><br><span class="hljs-keyword">public</span>:<br>AOperatActor();<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Tick</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime)</span> <span class="hljs-keyword">override</span></span>;<br>UFUNCTION(BlueprintImplementableEvent)<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BPPrint</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p><font color="red">这里需要注意的是，如果需要用蓝图子类来实现父类函数的话，这个函数必须是public权限，且需要标识BlueprintImplementableEvent，这个标识符会告诉UE4这个函数可以在蓝图中被当作事件来使用，并且会对这个函数进行默认实现，也就是实现一个空函数体，这就是为什么即使我们不在子类里实现这个函数直接调用也不会报错的原因。</font></p><p>然后我们创建一个继承自AOperator类的蓝图类并在蓝图类里实现BPPrint函数</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142244.png"></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142240.png"></p><p>这里实现BPPrint函数的方式有两个，一个是直接右键搜索BPPrint就像调用事件一样，直接调出实现，另一个是在Function中重写BPPrint，最终的结果和表现形式是一样的。</p><p>然后最关键的一点就是，OperatorActorInherit这个实现了BPPrint函数的蓝图类必须要在场景中函数调用才能生效，我们在AOperatorActor类的BeginPlay函数中调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOperatActor::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br>BPPrint();<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142234.png"></p><p>我这里选择使用一个Actor来做C++通过继承调用蓝图函数的例子而不是Object，也正是因为实现函数的蓝图必须在场景里调用才生效，而Object是不能存在于场景中的。</p><p>上面说到蓝图VM会为被BlueprintImplementableEvent标识的函数生成默认实现，事实上UE4也提供了函数的自定义默认实现的，即使用<code>BlueprintNativeEvent</code>标识就可以自定义函数的默认实现了，且必须要实现，否则编译不能通过，更重要的是函数名还有所变化，如：我们要自定义BPPrint的默认实现，那么BPPrint的实现应该如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOperatActor::BPPrint_Implementation</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>GEngine-&gt;AddOnScreenDebugMessage(<span class="hljs-number">-1</span>, <span class="hljs-number">5.f</span>, FColor::Red, FString::Printf(TEXT(<span class="hljs-string">&quot;BPPrint&quot;</span>)));<br>&#125;<br></code></pre></td></tr></table></figure><p>后缀<code>_Implementation</code>是必须要加的，否则编译无法通过。</p><p>此时如果我们不在子类中重写这个函数那么调用是默认调用父类的函数实现，如果我们在子列中重写这个函数的实现那么调用的就是子类的函数实现了。如：</p><p>不在子类中重写：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142228.png"></p><p>在子类中重写：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142223.png"></p><p>这里有一个问题，就是父类的实现会被多调用一次，原因未知。</p><p>除了通过重写父类函数然后直接通过调用父类函数的形式在C++中调用子类的蓝图函数的调用方式外，UE4还提供了直接通过函数名字来调用子类的任意函数的接口：</p><h3 id="C-通过CallFunctionByNameWithArguments调用蓝图函数"><a href="#C-通过CallFunctionByNameWithArguments调用蓝图函数" class="headerlink" title="C++通过CallFunctionByNameWithArguments调用蓝图函数"></a>C++通过CallFunctionByNameWithArguments调用蓝图函数</h3><p>大部分操作和前面的C++通过子类重写调用蓝图函数一样，需要一个继承自父类的蓝图子类，不同的是子类不需要重写父类的函数，父类可以直接通过CallFunctionByNameWithArguments接口使用函数名调用子类蓝图中任意函数。</p><p>子类蓝图中的PrintHello函数</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142207.png"></p><p>注意这个函数是直接由子类创建的。</p><p>然后就可以直接在父类里调用了，我这里直接在BeginePlay里调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOperatActor::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br>FString cmd = FString::Printf(TEXT(<span class="hljs-string">&quot;PrintHello HHHHHH&quot;</span>));<br>FOutputDeviceDebug de;<br>CallFunctionByNameWithArguments(*cmd, de, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142131.png"></p><p><font color="red">这里有几点需要注意，FString::Printf中的字符串使用空格隔开，一个字符串为要调用的函数名，之后的字符串为参数，各个参数之间也是用空格隔开，FOutputDeviceDebug来自头文件OutputDeviceDebug.h</font></p><p>当然CallFunctionByNameWithArguments接口也有通过子类重写来调用蓝图的方式一样需要通过子类来调用蓝图，所以一样需要这个子类蓝图要存在于场景中，否则调用一样无效，所以有一样的局限性，就是只支持Actor类型。</p><h1 id="三、AActor"><a href="#三、AActor" class="headerlink" title="三、AActor"></a>三、AActor</h1><h2 id="1-Actor网络同步"><a href="#1-Actor网络同步" class="headerlink" title="1.Actor网络同步"></a>1.Actor网络同步</h2><p>Actor的网络同步可以参考<a href="https://goulandis.github.io/2021/08/11/%E3%80%90UE5%E3%80%91UE5%20Dedicated%20Server%E4%B8%93%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5/">另一篇博文</a>的第三节</p><h2 id="2-GameMode"><a href="#2-GameMode" class="headerlink" title="2.GameMode"></a>2.GameMode</h2><h3 id="GameMode的执行过程"><a href="#GameMode的执行过程" class="headerlink" title="GameMode的执行过程"></a>GameMode的执行过程</h3><p>这里引用Ken_An大佬总结的一张精髓图片</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127141200.png"></p><p>GameMode只运行在服务器当中，对于单机游戏来说，由于UE4的服务器代码和客户端代码是一体的所以单机游戏本身可以算是自己的服务器，对网络游戏来说，GameMode只存在于服务器当中，在客户端中只拥有GameMode的一些副本，GameMode存在于ULevel中，当游戏切换Level时，当前GameMode会随着Level的切换而被销毁，并在新的Level加载之后产生新的GameMode。</p><p>GameMode的创建到Pawn的生成过程：</p><ul><li><p>游戏进程开始运行，此时UE创建GameInstance，GameInstance初始化WorldSetting中设置的GameMode，事实上在UE创建GameInstance时还创建UEngine和UWorld；</p></li><li><p>UE调用UGameEngine::Start函数，Start函数调用UEngine::Browse函数，再由Browse函数调用UEngine::LoadMap函数，由LoadMap函数来加载Map，创建新的World，并调用AGameInstance::CreateGameModeForURL创建GameMode；</p></li><li><p>SetGameMode函数主要是确保GameMode只能在Server端创建，并调用AGameInstance::CreateGameModeForURL函数创建GameMode，而CreateGameModeForURL就是实际直接调用SpawnActor创建GameMode的函数了；</p></li><li><p>CreateGameModeForURL函数会去读取WorldSetting的配置，并配置到新创建GameMode中；</p></li><li><p>Client发送连接请求：Client通过ClientTravel函数向服务器请求连接；</p></li><li><p>Server处理Client的请求连接：如果Server接受Client的连接，则发送配置的Server Default Map给Client；</p></li><li><p>Client加载地图成功之后，Server调用AGameModeBase::PreLogin函数，如果Server不想某个Client接入游戏，可以在PreLogin中拒绝；</p></li><li><p>如果Server接受Client加入游戏，则调用AGameModeBase::Login，如果不接受则不调用：每当有一个Client加入游戏，Login函数就会创建一个PlayerController并复制一份到对应的Client中替换Client的本地PlayerController，此时Client和Server就通过PlayerController建立起了通信连接，RPC调用就生效了，但是按官方的说法此时调用RPC还是不安全的，应该在AGameModeBase::PostLogin函数执行完之后再调用；</p><p><font color="green">疑问：按照官方的说法，PreLogin在Login之前调用，且源码中也是一个公有的虚函数，我在自定义的GameMode中重写的PreLogin函数在游戏运行时并没有调用而重写的Login和PostLogin会调用，关于这方面的资料实在是太过于匮乏，目前尚不知道原因何在。</font></p></li><li><p>PostLogin调用HandleStartingNewPlayer：HandleStartingNewPlayer函数是可以被蓝图重写的；</p></li><li><p>HandleStartingNewPlayer调用RestartPlayer：RestartPlayer为蓝图可调用函数，但UE不允许RestartPlayer函数被蓝图重写，允许被C++重写；</p></li><li><p>RestartPlayer函数会通过FindPlayerStart函数为将要Spawn的Pawn选取出生位置，然后调用RestartPlayerAtPlayerStart函数在在指定位置生成Pawn；</p></li><li><p>RestartPlayerAtPlayerStart则会调用SpawnDefaultPawnFor函数实际生成Pawn并设置生成位置，然后提供InitStartSpot函数在引擎认为完成Pawn的生成之前来调整Pawn的出生位置，InitStartSpot在源码中是一个空函数，可以被蓝图重写，然后RestartPlayerAtPlayerStart会调用FinishRestartPlayer函数来设置Controller的朝向，并通知引擎确认Pawn的生成；</p></li><li><p>SpawnDefaultPawnFor函数也是一个蓝图可重写函数，会初始化Pawn生成的Transform，然后调用SpawnDefaultPawnAtTransform函数在指定的Transform生成Pawn；</p></li><li><p>SpawnDefaultPawnAtTransform函数则是实际调用SpawnActor函数来创建Pawn的最底层函数了，SpawnDefaultPawnAtTransform也是一个蓝图可重写函数；</p><p>至此从GameMode生成到Pawn的生成过程就结束了。</p></li></ul><h3 id="AGameMode与AGameModeBase"><a href="#AGameMode与AGameModeBase" class="headerlink" title="AGameMode与AGameModeBase"></a>AGameMode与AGameModeBase</h3><p>AGameMode继承自AGameModeBase，AGameModeBase提供基础的游戏玩法规则，角色控制链中各种类的注册，游戏进度的暂停与重启，过场动画等，而AGameMode则在AGameModeBase的基础上加上了多人联机匹配的机制，如AGameMode提供了联机时的各种状态(等待加入，等待准备，游戏中等等)，当游戏中的玩家断开连接时，AGameMode提供挂起玩家并存储玩家状态，待玩家重返游戏时恢复的机制。根据<a href="https://docs.unrealengine.com/4.27/zh-CN/InteractiveExperiences/Framework/GameMode/">官方文档</a>中描述AGameMode的产生在AGameModeBase之前，而AGameModeBase是在UE4.14之后才加入的，目的是在AGameMode上面再添加一个层级，以便UE4后续对GameMode的扩展。这些功能都在AGameMode的源码中有所反应，如下面截取的部分源码片段：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">*...</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/** What match state we are currently in */</span><br>UPROPERTY(Transient)<br>FName MatchState;<br><br><span class="hljs-comment">/** Updates the match state and calls the appropriate transition functions */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetMatchState</span><span class="hljs-params">(FName NewState)</span></span>;<br><br><span class="hljs-comment">/** Overridable virtual function to dispatch the appropriate transition functions before GameState and Blueprints get SetMatchState calls. */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnMatchStateSet</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/** Implementable event to respond to match state changes */</span><br>UFUNCTION(BlueprintImplementableEvent, Category=<span class="hljs-string">&quot;Game&quot;</span>, meta=(DisplayName=<span class="hljs-string">&quot;OnSetMatchState&quot;</span>, ScriptName=<span class="hljs-string">&quot;OnSetMatchState&quot;</span>))<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">K2_OnSetMatchState</span><span class="hljs-params">(FName NewState)</span></span>;<br><br><span class="hljs-comment">// Games should override these functions to deal with their game specific logic</span><br><br><span class="hljs-comment">/** Called when the state transitions to WaitingToStart */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HandleMatchIsWaitingToStart</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/** Returns true if ready to Start Match. Games should override this */</span><br>UFUNCTION(BlueprintNativeEvent, Category=<span class="hljs-string">&quot;Game&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ReadyToStartMatch</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/** Called when the state transitions to InProgress */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HandleMatchHasStarted</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/** Returns true if ready to End Match. Games should override this */</span><br>UFUNCTION(BlueprintNativeEvent, Category=<span class="hljs-string">&quot;Game&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ReadyToEndMatch</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/** Called when the map transitions to WaitingPostMatch */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HandleMatchHasEnded</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/** Called when the match transitions to LeavingMap */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HandleLeavingMap</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/** Called when the match transitions to Aborted */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HandleMatchAborted</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">*...</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="4-GameState"><a href="#4-GameState" class="headerlink" title="4.GameState"></a>4.GameState</h2><p>按照官方的说法GameState是用来保存游戏全局数据的，如任务进度，NPC状态等，GameState在服务器产生并会备份一份到所有的客户端，并且GameState对所有客户端可见，与PlayerState相对，PlayerState用于保存客户端自身的状态。GameState有GameMode创建。</p><p>只有服务器上GameState在状态发生改变时才会自行同步备份到所有的客户端，客户端的GameState副本自身不会自行同步GameState的状态到Server，如一个客户端触发了一个NPC的状态，修改了这个客户端中GameState备份的NPC状态，这个GameState备份不会将修改过的状态同步的服务器和其他的客户端，但如果修改状态的逻辑在服务器中执行，修改的GameState时服务器上的GameState，则这个状态的修改会自行同步到所有的客户端，所以对GameState的修改应该在服务器中进行。</p><p>GameState属于GameMode配置的一部分所以会跟随着GameMode的产生而产生，销毁而销毁。</p><h3 id="GameState的创建过程"><a href="#GameState的创建过程" class="headerlink" title="GameState的创建过程"></a>GameState的创建过程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AGameModeBase::PreInitializeComponents</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::PreInitializeComponents();<br><br>FActorSpawnParameters SpawnInfo;<br>SpawnInfo.Instigator = GetInstigator();<br>SpawnInfo.ObjectFlags |= RF_Transient;<span class="hljs-comment">// We never want to save game states or network managers into a map</span><br><br><span class="hljs-comment">// Fallback to default GameState if none was specified.</span><br><span class="hljs-keyword">if</span> (GameStateClass == <span class="hljs-literal">nullptr</span>)<br>&#123;<br>UE_LOG(LogGameMode, Warning, TEXT(<span class="hljs-string">&quot;No GameStateClass was specified in %s (%s)&quot;</span>), *GetName(), *GetClass()-&gt;GetName());<br>GameStateClass = AGameStateBase::StaticClass();<br>&#125;<br><br>UWorld* World = GetWorld();<br>GameState = World-&gt;SpawnActor&lt;AGameStateBase&gt;(GameStateClass, SpawnInfo);<br>World-&gt;SetGameState(GameState);<br><span class="hljs-keyword">if</span> (GameState)<br>&#123;<br>GameState-&gt;AuthorityGameMode = <span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// Only need NetworkManager for servers in net games</span><br>AWorldSettings* WorldSettings = World-&gt;GetWorldSettings();<br>World-&gt;NetworkManager = WorldSettings-&gt;GameNetworkManagerClass ? World-&gt;SpawnActor&lt;AGameNetworkManager&gt;(WorldSettings-&gt;GameNetworkManagerClass, SpawnInfo) : <span class="hljs-literal">nullptr</span>;<br><br>InitGameState();<br>&#125;<br></code></pre></td></tr></table></figure><p>在GameMode构造的时候会初始化GameState的类型为AGameStateBase，GameMode在AGameModeBase::PreInitializeComponents函数中通过SpawnInfo来确定GameMode指定的GameState类型，然后调用SpawnActor创建GameState对象，然后调用InitGameState配置GameState的一些属性。</p><p>在AGameModeBase::InitGameState中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AGameModeBase::InitGameState</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>GameState-&gt;GameModeClass = GetClass();<br>GameState-&gt;ReceivedGameModeClass();<br><br>GameState-&gt;SpectatorClass = SpectatorClass;<br>GameState-&gt;ReceivedSpectatorClass();<br>&#125;<br></code></pre></td></tr></table></figure><p>GameState获取了当前GameMode对象的引用和当前SpectatorPawn的对象，SpectatorPawn是旁观者类。</p><h2 id="5-PlayerState"><a href="#5-PlayerState" class="headerlink" title="5.PlayerState"></a>5.PlayerState</h2><p>和GameState相对PlayerState用于保存玩家数据，和GameState一样PlayerState也首先在Server中生成并同步副本到所的Client中，一个Client的当前Level中会保存所有加入这局游戏的玩家的PlayerState。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127141227.png"></p><p>如，我们有三个玩家加入游戏，那么在运行时Level下就出现了三个PlayerState。</p><p>PlayerSate存在于Controller和Pawn中，Controller保存PlayerState的源对象，Pawn保存PlayerState的引用，即PlayerState的生命周期跟着Controller走，这也比较符合PlayerState的定位，PlayerState保存的是玩家数据而不是角色数据，因为一局游戏中一个玩家可以操控多个角色。</p><p>和GameState一样，PlayerState也在Server中的PlayerSate状态发生变化时会自动同步状态到所有客户端中对应的PlayerState副本，而Client中PlayerState副本状态发生改变时不会自动同步到Server，所以对PlayerState的修改也应该在服务器中进行。</p><h3 id="PlayerState的创建过程"><a href="#PlayerState的创建过程" class="headerlink" title="PlayerState的创建过程"></a>PlayerState的创建过程</h3><ul><li>GameMode在Login函数中调用SpawnPlayerController函数；</li><li>SpawnPlayerController会根据配置情况调用不通的函数来创建PlayerController；</li><li>PlayerController调用PostInitializeComponents函数进行初始化，PostInitializeComponents是APlayerController继承自AActor的函数，在Actor所有组件初始化后初始化自己时调用；</li><li>PostInitializeComponents函数调用InitPlayerState函数创建PlayerState实例，InitPlayerState函数是APlayerController继承自AController的函数；</li><li>InitPlayerState函数通过SpawnInfo确定创建的PlayerState的类型，然后调用SpawnActor创建PlayerState实例。</li></ul><h2 id="6-WorldSettings"><a href="#6-WorldSettings" class="headerlink" title="6.WorldSettings"></a>6.WorldSettings</h2><p>WorldSettings的资料着实是太少太少了，连官方论坛中都很少提及，官方文档也就了了一句话，WorldSettings主要做的就是对游戏世界的一系列配置，如：大地图的动态加载与卸载，世界光照，声音系统，边界检查，导航系统，AI系统，世界重力模拟等等，具体的一些选项功能可以查看<a href="https://blog.csdn.net/jiangdengc/article/details/57421143">Im-JC</a>的博文。</p><p>WorldSettings是蓝图不可见的，如果我们需要动态的获取WorldSettings里的一些配置则需要通过GetActorsWithClass来获取。</p><p>默认WorldSettings是可以更换的，在ProjectSettings/Engine/GeneralSetttings/DefualtClass下</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127141336.png"></p><p>可以看到不仅WorldSettings可以配置，GameViewportClient、LocalPlayer、LevelScriptActor，PhysicsCollisionHandler等都可以自定义配置，UE是真的强大，连关卡蓝图、UI显示，物理碰撞等都给予了我们自定义能力。</p><p>我们在编辑器中打开的WorldSettings视图并不是WorldSettings，而是由WorldSettings提供一个可视化编辑界面。</p><h3 id="WorldSettings的创建过程"><a href="#WorldSettings的创建过程" class="headerlink" title="WorldSettings的创建过程"></a>WorldSettings的创建过程</h3><p>在UE源码中好一阵找，发现WorldSettings的创建有四个地方，分别是</p><p><strong>UEditorLevelUtils::AddLevelToWorld_Internal</strong></p><p><strong>UEditorEngine::CreateTransLevelMoveBuffer</strong></p><p><strong>UWorld::RepairWorldSettings</strong></p><p><strong>UWorld::InitializeNewWorld</strong></p><p>UEditorLevelUtils和UEditorEngine都是和编辑器相关的，不在GamePlay的框架内，这里就不讨论了，我们重点看一下UWorld中的。</p><p>InitializeNewWorld函数是实际创建WorldSettings的地方，而RepairWorldSettings按照源码的解释就是用于确保游戏中切实有一个可用的WorldSettings的功能函数，RepairWorldSettings在UWorld::PostLogin时被调用。</p><ul><li>GameInstance在InitializeStandalone中调用UWorld::CreateWorld函数；</li><li>UWorld::CreateWorld函数调用InitializeNewWorld来创建WorldSettings；</li><li>UWorld::InitializeNewWorld函数就是实际创建WorldSettings的函数，InitializeNewWorld会先读取ProjectSettings中的WorlSettings的配置，如果配置了则创建对应的WorldSettings类实例，否则创建默认的WorldSettings实例。</li></ul><h2 id="7-ALevelScriptActor"><a href="#7-ALevelScriptActor" class="headerlink" title="7.ALevelScriptActor"></a>7.ALevelScriptActor</h2><p>ALevelScriptActor就是我们常说的关卡蓝图，ALevelScriptActor是一个在关卡中的隐藏Actor，在Level列表里是看不到的。</p><h3 id="自定义关卡蓝图"><a href="#自定义关卡蓝图" class="headerlink" title="自定义关卡蓝图"></a>自定义关卡蓝图</h3><p>既然关卡蓝图也是一个Actor那么理论上关卡蓝图也是可以自定义的，经过一番研究UE4还真提供了自定义关卡蓝图的功能。</p><p>ALevelScriptActor不是一个蓝图类，所以我们直接去创建蓝图是找不到一个ALevelScriptActor基类可供继承的，所以我们只能先用C++去创建一个继承自ALevelScriptActor的自定义C++类，然后再修改关卡蓝图的父类为自定义的ALevelScriptActor类。</p><p>这里我创建了一个LSPLevelScriptActor类并重写了BeginPlay函数，在BeginPlay函数里只打印一串字符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Engine/LevelScriptActor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;LSPLevelScriptActor.generated.h&quot;</span></span><br><br>UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LSPTETRISCLIENT_API</span> <span class="hljs-title">ALSPLevelScriptActor</span> :</span> <span class="hljs-keyword">public</span> ALevelScriptActor<br>&#123;<br>GENERATED_BODY()<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//.cpp</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;LSPLevelScriptActor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Engine.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ALSPLevelScriptActor::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    GEngine-&gt;AddOnScreenDebugMessage(<span class="hljs-number">-1</span>, <span class="hljs-number">10</span>, FColor::Red, <span class="hljs-string">&quot;LSPLevelScriptActor::BeginPlay&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然后我们打开想要自定义关卡蓝图的关卡，并打开关卡蓝图，在ClassSettings/ClassOptions/ParentClass设置成为自定义的LSPLevelScriptActor，那么当我们运行BeginPlay事件时，就会在屏幕上打印LSPLevelScriptActor::BeginPlay</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127141439.png"></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127141443.png"></p><h2 id="8-APlayerController"><a href="#8-APlayerController" class="headerlink" title="8.APlayerController"></a>8.APlayerController</h2><p>APlayController与AIController相对，专用于给玩家操作的角色控制器，在AGameMode章节有说过APlayerController是由AGameModeBase::Login函数创建。APlayerController在游戏运行时是不可视的，主要负责接收外部输入，如鼠标键盘、游戏手柄等，并根据输入按一定的逻辑来控制与其绑定的APwan。APlayerController可以通过Possess函数来获取一个APawn的控制权，也可以通过UnPossess函数还放弃一个APawn的控制权。</p><p>在UE4的设计里，APwan和APlayerController都是可以接收外部输入的，如InputAxis事件既可以放在APawn里对APwan进行控制，也可以APlayerController里对指定APawn进行控制，那么二者对外部输入的处理有什么不同呢？事实上，APlayerController在逻辑上的层级要高于APawn的，也就是说外部输入要先进入APlayerController再由APlayerController传递给APawn，这就使得APlayController可以对APawn的输入进行拦截。</p><p>既然APawn和APlayerController都可以接收外部输入，那么对输入逻辑的处理应该放在APawn里还是放在APlayerController里呢？</p><p>个人理解是人应该放在APawn里，为什么呢？因为在一个游戏里，同一个玩家是可以操作多种类型的角色的，如GTA5里面，玩家既可以控制人型角色，也可以开各种车辆，还可以还飞机。各种角色对接收的输入和对输入的处理都是不一样的，如当玩家按下键盘s时，如果APawn是一个人，那么角色应该向后走，如果APawn是一辆车，那么角色应该减速，如果APawn是一个架飞机，那么角色因该下降。这么多中不同的对同一输入的处理不因该由一个APlayerController来出来，而是将之拆分到不同的APawn中处理。</p><h3 id="输入顺序"><a href="#输入顺序" class="headerlink" title="输入顺序"></a>输入顺序</h3><p>UE4里可以接收输入的有4种类，APlayController、APawn、ALevelScriptActor和普通Actor</p><p>Actor只要设置EnableInput或AutoReceiveInput就可以接收输入了</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127141515.png"></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127141519.png"></p><p>UE4的可接收输入对象的输入优先级：</p><p>Actor&gt;APlayerController&gt;ALevelScriptActor&gt;APawn</p><h3 id="输入栈"><a href="#输入栈" class="headerlink" title="输入栈"></a>输入栈</h3><p>UE4对输入的接收有一个输入栈的概念，在游戏一开始时，UE4会对所有的可接收输入的对象进行入栈处理，UE4通过入栈顺序来对可接收输入对象的输入优先级进行分级，先直接上一段源码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">APlayerController::BuildInputStack</span><span class="hljs-params">(TArray&lt;UInputComponent*&gt;&amp; InputStack)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// Controlled pawn gets last dibs on the input stack</span><br>    <span class="hljs-comment">//获取当前控制的APawn</span><br>APawn* ControlledPawn = GetPawnOrSpectator();<br><span class="hljs-keyword">if</span> (ControlledPawn)<br>&#123;<br><span class="hljs-keyword">if</span> (ControlledPawn-&gt;InputEnabled())<br>&#123;<br><span class="hljs-comment">// Get the explicit input component that is created upon Pawn possession. This one gets last dibs.</span><br>            <span class="hljs-comment">//获取APawn的输入组件</span><br><span class="hljs-keyword">if</span> (ControlledPawn-&gt;InputComponent)<br>&#123;<br>                <span class="hljs-comment">//首先将APawn的输入组件入栈</span><br>InputStack.Push(ControlledPawn-&gt;InputComponent);<br>&#125;<br><br><span class="hljs-comment">// See if there is another InputComponent that was added to the Pawn&#x27;s components array (possibly by script).</span><br><span class="hljs-keyword">for</span> (UActorComponent* ActorComponent : ControlledPawn-&gt;GetComponents())<br>&#123;<br>UInputComponent* PawnInputComponent = Cast&lt;UInputComponent&gt;(ActorComponent);<br><span class="hljs-keyword">if</span> (PawnInputComponent &amp;&amp; PawnInputComponent != ControlledPawn-&gt;InputComponent)<br>&#123;<br>InputStack.Push(PawnInputComponent);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// LevelScriptActors are put on the stack next</span><br>    <span class="hljs-comment">//将拥有输入的关卡蓝图入栈</span><br><span class="hljs-keyword">for</span> (ULevel* Level : GetWorld()-&gt;GetLevels())<br>&#123;<br>ALevelScriptActor* ScriptActor = Level-&gt;GetLevelScriptActor();<br><span class="hljs-keyword">if</span> (ScriptActor)<br>&#123;<br><span class="hljs-keyword">if</span> (ScriptActor-&gt;InputEnabled() &amp;&amp; ScriptActor-&gt;InputComponent)<br>&#123;<br>InputStack.Push(ScriptActor-&gt;InputComponent);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//将PlayerController自身入栈</span><br><span class="hljs-keyword">if</span> (InputEnabled())<br>&#123;<br>InputStack.Push(InputComponent);<br>&#125;<br><br><span class="hljs-comment">// Components pushed on to the stack get priority</span><br>    <span class="hljs-comment">//将拥有输入的Actor入栈，CurrentInputStach会保存所有拥有InputComponent组件的Actor的InputComponent组件的引用</span><br><span class="hljs-keyword">for</span> (int32 Idx=<span class="hljs-number">0</span>; Idx&lt;CurrentInputStack.Num(); ++Idx)<br>&#123;<br>UInputComponent* IC = CurrentInputStack[Idx].Get();<br><span class="hljs-keyword">if</span> (IC)<br>&#123;<br>InputStack.Push(IC);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>CurrentInputStack.RemoveAt(Idx--);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了验证输入优先级，我创建了一个具有APawn，APlayerController，具有输入的ALevelScriptActor，具有输入的Actor的关卡。</p><p>我在APawn中加入了前后左右滚动的事件InputAxisMoveForward和InputAxisMoveRight，同时在APlayerController，ALevelScriptActor，Actor中分别都加入一个InputAxisMoveRight，且只进行文字打印操作。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127142056.png"></p><p>先来直接看一下结果</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127142103.gif"></p><p>可以看到字符串的输出顺序为Actor Input-&gt;Controller Input-&gt;ServerMap Input-&gt;APawn Input</p><p>此时键盘输入依旧会一次从栈顶的Actor一直传递到栈底的APawn，但是APawn的InputAxisMoveRight已经被其上层的InputComponent截断，所以APawn只能进行前后移动而无法左右移动。</p><h3 id="输入流程"><a href="#输入流程" class="headerlink" title="输入流程"></a>输入流程</h3><p>先上一张从张悟基大佬哪里盗来的流程图。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127142148.png"></p><ul><li><p>在UE4LaunchEngineLoop.h文件中有一个专门处理引擎循环的类FEngineLoop，UE4在FEngineLoop::Tick()函数中处理每帧获取设备输入，主要处理逻辑。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">FSlateApplication&amp; SlateApp = FSlateApplication::Get();<br>&#123;              QUICK_SCOPE_CYCLE_COUNTER(STAT_FEngineLoop_Tick_PollGameDeviceState);<br>SlateApp.PollGameDeviceState();<br> &#125;<br></code></pre></td></tr></table></figure><p>其中使用了大量的宏，以本小菜的水平当前还看不懂😬，只知道逻辑是在这里处理的。</p></li><li><p>UE4使用FSlateApplication类来将各种各样的硬件输入转化为固定的对应响应事件，如FSlateApplication::OnControllerButtonReleased()函数就是专门处理按键释放的函数，既可以处理手柄按钮释放，也可以处理键盘按键释放。</p><p>在UE4中有一个GenericApplication类是专门做平台处理的接口，在FSlateApplication的基类FSlateApplicationBase中就保存了一个GenericApplication的实例指针。GenericApplication中的函数都是虚函数，GenericApplication类会根据不同平台生成对应的子类的实例，FSlateApplication会根据不同的平台去做不同的输入处理，如在PC平台上就会调用在更底层的输入处理中调用FSlateApplication::OnControllerButtonReleased()函数将键盘释放转化为ProcessKeyUpEvent事件，在PS4平台中同样在更底层的输入处理中调用FSlateApplication::OnControllerButtonReleased()函数将按钮释放转化为ProcessKeyUpEvent事件。</p><p>关于GenericApplication的资料实在找不到，这里纯是个人理解。</p></li><li><p>到这一步，UE4就将各种各种各样的平台输入统一到几个输入处理事件中了，这里以键盘按键释放为例，继续往下走，键盘按键释放操作被映射到ProcessKeyUpEvent事件中，ProcessKeyUpEvent事件主要就做一件事，就是将输入优先传入UMG中，判断UMG中是否有对这个按键操作进行了监听，如果监听了，则将输入传入到UMG中，而输入是否继续传入到World中由UMG决定，如果没有监听则直接将输入传递到World中。</p><p>这里需要注意的是，UMG不能直接对键盘进行监听也不能对AxisInput进行监听，只能监听ActionInput。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208141930.png"></p><p>其中<font color="red">Consume</font>参数就决定了输入是否继续往下传递。</p></li><li><p>如果输入继续往下传递，这时输入会进入到UGameViewportClient中，UGameViewportClient中有对应输入类型的处理函数，通过这些函数将输入传递给PlayerControlelr，Actor、PlayerController、LevelScriptActor、Pawn才能接收到输入，这里输入会按照PlayerController的输入栈来传递输入事件。</p><p><font color="red">这里的资料也是少得可怜，至于输入到底是如何从FSlateApplication传递到UGameViewportClient中的始终未得其解。</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//UGameViewportClient.h</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">InputKey</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FInputKeyEventArgs&amp; EventArgs)</span> <span class="hljs-keyword">override</span></span>;<br>UE_DEPRECATED(<span class="hljs-number">4.21</span>, <span class="hljs-string">&quot;Use the new InputKey(const FInputKeyEventArgs&amp; EventArgs) function.&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">InputKey</span><span class="hljs-params">(FViewport* InViewport, int32 ControllerId, FKey Key, EInputEvent Event, <span class="hljs-keyword">float</span> AmountDepressed = <span class="hljs-number">1.f</span>, <span class="hljs-keyword">bool</span> bGamepad = <span class="hljs-literal">false</span>)</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">final</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">InputAxis</span><span class="hljs-params">(FViewport* Viewport, int32 ControllerId, FKey Key, <span class="hljs-keyword">float</span> Delta, <span class="hljs-keyword">float</span> DeltaTime, int32 NumSamples=<span class="hljs-number">1</span>, <span class="hljs-keyword">bool</span> bGamepad=<span class="hljs-literal">false</span>)</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">InputChar</span><span class="hljs-params">(FViewport* Viewport,int32 ControllerId, TCHAR Character)</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">InputTouch</span><span class="hljs-params">(FViewport* Viewport, int32 ControllerId, uint32 Handle, ETouchType::Type Type, <span class="hljs-keyword">const</span> FVector2D&amp; TouchLocation, <span class="hljs-keyword">float</span> Force, FDateTime DeviceTimestamp, uint32 TouchpadIndex)</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">InputMotion</span><span class="hljs-params">(FViewport* Viewport, int32 ControllerId, <span class="hljs-keyword">const</span> FVector&amp; Tilt, <span class="hljs-keyword">const</span> FVector&amp; RotationRate, <span class="hljs-keyword">const</span> FVector&amp; Gravity, <span class="hljs-keyword">const</span> FVector&amp; Acceleration)</span> <span class="hljs-keyword">override</span></span>;<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>在PlayerController中也有处理UGameViewportClient传入的输入类型的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//APlayerController.h</span><br><span class="hljs-comment">/** Handles a key press */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">InputKey</span><span class="hljs-params">(FKey Key, EInputEvent EventType, <span class="hljs-keyword">float</span> AmountDepressed, <span class="hljs-keyword">bool</span> bGamepad)</span></span>;<br><br><span class="hljs-comment">/** Handles a touch screen action */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">InputTouch</span><span class="hljs-params">(uint32 Handle, ETouchType::Type Type, <span class="hljs-keyword">const</span> FVector2D&amp; TouchLocation, <span class="hljs-keyword">float</span> Force, FDateTime DeviceTimestamp, uint32 TouchpadIndex)</span></span>;<br><br>UE_DEPRECATED(<span class="hljs-number">4.20</span>, <span class="hljs-string">&quot;InputTouch now takes a Force&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">InputTouch</span><span class="hljs-params">(uint32 Handle, ETouchType::Type Type, <span class="hljs-keyword">const</span> FVector2D&amp; TouchLocation, FDateTime DeviceTimestamp, uint32 TouchpadIndex)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> InputTouch(Handle, Type, TouchLocation, <span class="hljs-number">1.0f</span>, DeviceTimestamp, TouchpadIndex);<br>&#125;<br><br><span class="hljs-comment">/** Handles a controller axis input */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">InputAxis</span><span class="hljs-params">(FKey Key, <span class="hljs-keyword">float</span> Delta, <span class="hljs-keyword">float</span> DeltaTime, int32 NumSamples, <span class="hljs-keyword">bool</span> bGamepad)</span></span>;<br><br><span class="hljs-comment">/** Handles motion control */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">InputMotion</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FVector&amp; Tilt, <span class="hljs-keyword">const</span> FVector&amp; RotationRate, <span class="hljs-keyword">const</span> FVector&amp; Gravity, <span class="hljs-keyword">const</span> FVector&amp; Acceleration)</span></span>;<br></code></pre></td></tr></table></figure><p>而Actor、ScriptLeveActor、PlayerController、Pawn则创建各自的InputComponent组件压入PalyerController的输入栈来接收PlayerController的输入，收到输入则去执行绑定的响应函数。</p></li></ul><h3 id="Actor在C-中接收输入"><a href="#Actor在C-中接收输入" class="headerlink" title="Actor在C++中接收输入"></a>Actor在C++中接收输入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AActor_Acom::BindAxis</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    EnableInput(GWorld-&gt;GetFirstPlayerController());<br>    InputComponent-&gt;BindAction(<span class="hljs-string">&quot;ActorInputO&quot;</span>,EInputEvent::IE_Pressed, <span class="hljs-keyword">this</span>, &amp;AActor_Acom::PrintText);<br>&#125;<br></code></pre></td></tr></table></figure><p>和在蓝图中差不多，也需要先Actor接收输入，需要注意的是要获取当前的PlayerController需要使用GWorld，而绑定事件的InputComponent-&gt;BindAction只能绑定ActionInput，且必须是在ProjectSettings/Input中注册过的才行。</p><h2 id="9-APawn"><a href="#9-APawn" class="headerlink" title="9.APawn"></a>9.APawn</h2><p>APawn在整个UPlayer-&gt;APlayerController-&gt;APawn的控制链中主要负责角色的物理表现和与角色相关的输入响应。</p><p>关于APawn好像也没啥可看的，网上关于APawn的资料几乎没有，具体的深入研究等之后在进行吧。</p><h1 id="四、UGameInstance"><a href="#四、UGameInstance" class="headerlink" title="四、UGameInstance"></a>四、UGameInstance</h1><p>GameInstance可以理解为UE虚拟的游戏进程，双击exe游戏开始，GameInstance创建，结束游戏，杀死进程，GameInstance销毁，所以GameInstance的生命周期就是一个游戏的游玩过程。</p><p>GameInstance虽说是单例，但是UE并没有规定一个游戏里只能存在一个GameInstance，只是由UE存储的GameInstance实例只有一个，且必定是ProjectSetting中配置的GameInstance类型。</p><p>GameInstance在各个端之间是互相独立且互不通信的，像Server中的GameInstance和Client中的GameInstance是两个互相独立的实例，且二者没有能力直接通信，因为UE就没有给予GameInstance网络通信的能力。</p><h3 id="哪些逻辑应该写在GameInstance中"><a href="#哪些逻辑应该写在GameInstance中" class="headerlink" title="哪些逻辑应该写在GameInstance中"></a>哪些逻辑应该写在GameInstance中</h3><ul><li><p>保存跨关卡的全局数据</p><p>由于GameState和PlayerState的实例都会随着Level的切换而被销毁，所以一些需要跨关卡存在的数据就需要使用GameInstance来保存了。</p></li><li><p>一些需要全局使用UI</p><p>由于UE的UI是使用Widget来实现的，在使用UI时需要先CreateWidget，然后将widget实例AddToViewport，所以一些需要全局使用的UI如：背包，人物属性等UI的逻辑就可以写在GameInstance中，以避免跳转关卡时重新初始化这些实例。</p></li><li><p>Level切换</p><p>虽然OpenLevel这些关卡切换的实现在UGameEngine中，GameEngine是比GameInstance更高一级的存在，一般而言我们很少使用到GameEngine，除非是针对编辑器的开发，所以将关切切换的逻辑写在GameInstance中更合理。</p></li><li><p>与服务器的连接，TCP，HTTP等逻辑</p><p>因为GameInstance作为一个全局实例，可以很方便的在各个地方获取，这就方便了服务器的重连，和资源下载。</p></li></ul><h3 id="GameInstance的创建过程"><a href="#GameInstance的创建过程" class="headerlink" title="GameInstance的创建过程"></a>GameInstance的创建过程</h3><p>其实在<strong>GameMode的执行过程</strong>中已经有所体现，事实上当我们双击exe运行游戏进程时，第一个创建出来的实例不是GameInstance，而是GameEngine。</p><ul><li><p>游戏进程启动，创建GameEngine；</p></li><li><p>GameEngine调用Init函数，读取ProjectSetting中配置的GameInstance的类型，</p><p>判断是否配置了GameInstance类型，是则创建对应类型的GameInstance实例，否则创建默认的GameInstance实例；</p></li><li><p>调用GameInstance的初始化函数，创建FWorldContext，通过FWorldContext创建UWorld，再通过UWorld，GameInstance就可以创建GameMode了。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UGameEngine::Init</span><span class="hljs-params">(IEngineLoop* InEngineLoop)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//... </span><br><br>    FSoftClassPath GameInstanceClassName = GetDefault&lt;UGameMapsSettings&gt;()-&gt;GameInstanceClass;<br>    UClass* GameInstanceClass = (GameInstanceClassName.IsValid() ? LoadObject&lt;UClass&gt;(<span class="hljs-literal">NULL</span>, *GameInstanceClassName.ToString()) : UGameInstance::StaticClass());<br>    <span class="hljs-keyword">if</span> (GameInstanceClass == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>UE_LOG(LogEngine, Error, TEXT(<span class="hljs-string">&quot;Unable to load GameInstance Class &#x27;%s&#x27;. Falling back to generic UGameInstance.&quot;</span>), *GameInstanceClassName.ToString());<br>GameInstanceClass = UGameInstance::StaticClass();<br>&#125;<br>GameInstance = NewObject&lt;UGameInstance&gt;(<span class="hljs-keyword">this</span>, GameInstanceClass);<br>GameInstance-&gt;InitializeStandalone();<br>    <br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="五、UPlayer"><a href="#五、UPlayer" class="headerlink" title="五、UPlayer"></a>五、UPlayer</h1><p>UPlayer就是UE虚拟出来的玩家，在一个多人游戏中玩家有两类，自己和别人，所以UPlayer也随之派生出两个子类，ULoaclPlayer和UNetConnection，ULocalPlayer就是自己，UNetConnection就是别人。</p><h2 id="UPlayer的绑定"><a href="#UPlayer的绑定" class="headerlink" title="UPlayer的绑定"></a>UPlayer的绑定</h2><ul><li><p>在FSeamlessTravelHandler::Tick()函数中调用了GameMode-&gt;PostSeamlessTravel();</p></li><li><p>PostSeamlessTravel函数主要是创建一个GameSession和调用HandleSeamlessTravelPlayer来为APlayerController设置UPlayer。</p></li><li><p>HandleSeamlessTravelPlayer()函数调用SwapPlayerControllers()函数来为APlayerController设置UPlayer，在SwapPlayerControllers最终使用APlayerController::SetPlayer()函数设置UPlayer。</p></li></ul><h1 id="六、UEngine"><a href="#六、UEngine" class="headerlink" title="六、UEngine"></a>六、UEngine</h1><p>UEngine下有两个主要的子类，UGameEngine和UEditorEngine，UGameEngine是游戏运行时的UEngine实例，UEditorEngine是UE编辑器实例，UEngine在Engine.h中用GEngine全局变量保存。</p><p>UEngine是整个游戏开始的最初是的入口，主要负责做一些顶层类的初始化工作，如初始化负责渲染和输入UGameViewportClient，负责记录World信息的FWorldContext，负责管理音频的FAudioDeviceManager，配置默认的UEngine，负责模块管理的FModuleManager，负责资产管理的UAssetManager，对一些配置文件的加载，如Engine.ini。</p><p>关于UEngine::Init函数，看了一下源码，UE5相较于UE4修改还挺大的。</p><h2 id="自定义引擎类"><a href="#自定义引擎类" class="headerlink" title="自定义引擎类"></a>自定义引擎类</h2><p>UE4的一大好处就是极度自由，UE4除了提供自定义GamePlay框架里的各种类，连自定义引擎类的能力都提供了，由于引擎类有两种UGameEngine和UEditorEngine，所以自定引擎类也分两种，继承自UGameEngine的类只能用于Game模式，继承自UEditorEngine的类只能用于Editor模式，由于UEditorEngine在除了自己魔改UE的情况一般不会修改，所以我们只看UGameEngine就行了。</p><p>首先我们创建一个继承自UGameEngine的ULSPGameEngine类，我们可以在类里面重载基类函数或新增自定义函数来扩展自己的引擎类，我这里就不进行扩展了，然后打开项目目录下的/Config/DefaultEngine.ini文件，在<font color="red">[/Script/Engine.Engine]</font>栏将<font color="red">GameEngine=/Script/Engine.Engine</font>改成自己的引擎类，<font color="red">GameEngine=/Script/LSPTetrisClient.LSPGameEngine</font>，其中LSPTetrisClient是模块名称，LSPGameEngine是自定义引擎类的名称，如果没有这一行就自己加一行进去。怎么看自己的项目模块名称呢？在.uproject文件下，默认模块的名字就是自己项目的模块名称。</p><p>到这一步自定义引擎类就设置完毕了，要然配置文件生效我们要编译一下并重启引擎，让引擎重新去读取DefaultEngine.ini文件。</p><p>那么怎么检测自定义引擎类是否生效了呢？</p><p>这里我在GameInstance里加了一个函数来检测。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ULSPTetrisGameInstance::Print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>UGameEngine* LSPEngine = Cast&lt;ULSPGameEngine&gt;(GEngine);<br><span class="hljs-keyword">if</span> (LSPEngine)<br>&#123;<br>LSPEngine-&gt;AddOnScreenDebugMessage(<span class="hljs-number">-1</span>, <span class="hljs-number">10</span>, FColor::Red, TEXT(<span class="hljs-string">&quot;GEngine is LSPGameEngine&quot;</span>));<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>GEngine-&gt;AddOnScreenDebugMessage(<span class="hljs-number">-1</span>, <span class="hljs-number">10</span>, FColor::Red, TEXT(<span class="hljs-string">&quot;GEngine is GameEngine 1&quot;</span>));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>把这个函数暴露给蓝图，然后在关卡蓝图中调用。先看一下PIE模式下的运行结果：</p><p><img src="https://img-blog.csdnimg.cn/98c6be086a9140659828406e1a41bbf1.png?x-oss-process=type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAR291bGFuZGlz,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"></p><p>可以看到ULSPGameEngine并未生效，这是因为GameEngine只在Game模式下才起作用，UE会根据不同的运行模式来生成不同UEngine，现在我们打个包出来再看下结果：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e0612b1fb9c800069e17fdf2a5e07c5b.png#pic_center"></p><p>可以看到ULSPGameEngine生效了。</p><h1 id="七、UWorld"><a href="#七、UWorld" class="headerlink" title="七、UWorld"></a>七、UWorld</h1><p>UWorld在UE4源码中的描述是这样的</p><ul><li>World 是代表地图或沙箱的顶级对象，Actor 和组件将在其中存在并被渲染。</li><li>一个世界可以是一个单一的持久化关卡，带有一个可选的流媒体关卡列表，这些关卡通过体积和蓝图函数加载和卸载或者它可以是一组按世界构成组织的关卡。</li><li>在独立游戏中，通常只有一个世界存在，除非在目的地和当前世界都存在的无缝区域过渡期间。</li><li>在编辑器中存在许多世界：正在编辑的关卡、每个 PIE 实例、每个具有交互式渲染视口的编辑器工具等等。</li></ul><p>UWorld中存在一个ULevel数组用于保存World下的多个Level。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">...<br><span class="hljs-comment">/** Array of levels currently in this world. Not serialized to disk to avoid hard references. */</span><br>UPROPERTY(Transient)<br>TArray&lt;TObjectPtr&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ULevel</span>&gt;</span>&gt; Levels;<br>...<br></code></pre></td></tr></table></figure><p>UWolrld是一个相当庞大的类，它管理相当大数量的世界配置和世界信息，如：关卡列表、角色控制器列表、相机列表、玩家数量、音频管理器列表、世界时间，玩家控制器的数量、世界重力、世界物理模拟属性等等，也提供着大量的世界基础能力，如：加载或卸载关卡、向永久性关卡中流式添加或卸载关卡，世界的暂停与重置，AI系统的管理，添加和移除Pawn等等。</p><p>一般来说一个游戏只会存在一个UWorld，并且UWorld如同UEngine一样在UWorld.h中也使用一个全局变量GWorld来存储，在一般的Actor中我们可以同过GetWorld()函数来获取GWorld。</p><h2 id="UWorld的创建"><a href="#UWorld的创建" class="headerlink" title="UWorld的创建"></a>UWorld的创建</h2><ul><li><p>首先由UGameInstance::InitializeStandalone函数调用UWorld::CreateWorld函数来创建一个World，同时会将自身的引用传递给UWorld，还会将创建出来UWorld配置给WorldContext；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UGameInstance::InitializeStandalone</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FName InPackageName, UPackage* InWorldPackage)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// Creates the world context. This should be the only WorldContext that ever gets created for this GameInstance.</span><br>WorldContext = &amp;GetEngine()-&gt;CreateNewWorldContext(EWorldType::Game);<br>WorldContext-&gt;OwningGameInstance = <span class="hljs-keyword">this</span>;<br><br><span class="hljs-comment">// In standalone create a dummy world from the beginning to avoid issues of not having a world until LoadMap gets us our real world</span><br>UWorld* DummyWorld = UWorld::CreateWorld(EWorldType::Game, <span class="hljs-literal">false</span>, InPackageName, InWorldPackage);<br>DummyWorld-&gt;SetGameInstance(<span class="hljs-keyword">this</span>);<br>WorldContext-&gt;SetCurrentWorld(DummyWorld);<br><br>Init();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>UWorld::CreateWorld函数则是实际调用NewObject创建UWorld的函数，同时会为新创建出来的World配置一系列参数，并将新的World添加进UEngine中存储，最主要的就是调用UWorld::InitializeNewWorld函数来加载项目设置里配置的默认地图；</p></li><li><p>UWorld::InitializeNewWorld函数会创建PersistentLevel，并将当前UWorld对象设置成PersistentLevel，同时也会对PersistentLevel进行一些列的配置操作，然后调用UWorld::InitWorld函数来初始化世界；</p></li><li><p>UWorld::InitWorld函数就是UWolrd的初始化函数了，InitWorld会根据WorldSetting初始化World，初始化寻路系统、AI系统、物理碰撞，物理重力，Brush系统，为当前世界配置PersistentLevel。</p></li></ul><h1 id="八、ULevel"><a href="#八、ULevel" class="headerlink" title="八、ULevel"></a>八、ULevel</h1><p>ULevel的概念就是关卡，ULevel会保存其所属的UWorld的引用。ULevel的组成与其他的.uasset资源还有点不一样，因为ULevel又其下的所有Actor，ULevel专有LevelScriptActor，同时又有各种光照烘培信息，所以ULevel在UE中使用.umap的格式存储，而我们进行光照烘培后产生的对应的UMapBuildDataRegistry文件则是专门用于存储烘培信息的。</p><h2 id="1-初始Level的创建"><a href="#1-初始Level的创建" class="headerlink" title="1.初始Level的创建"></a>1.初始Level的创建</h2><ul><li>默认地图的加载首先由UEngine::Start函数拉起，UEngine::Start函数只做了一件事，通过UEngine中保存的GameInstance引用调用UGameInstance::StartGameInstance函数；</li><li>UGameInstance::StartGameInstance会去读取默认的地图设置，并获取需要默认加载地图名称，然后将地图名称传递给UEngine::Browse函数；</li><li>UEngine::Browse就是具体调用LoadMap函数加载地图的函数了。</li></ul><h2 id="2-使用蓝图加载umap资源"><a href="#2-使用蓝图加载umap资源" class="headerlink" title="2.使用蓝图加载umap资源"></a>2.使用蓝图加载umap资源</h2><p>蓝图加载关卡有两种反式，一种是OpenLevel一种是LoadLevelInstance，OpenLevel是关闭当前关卡进入指定关卡，而LoadLevelInstance则是将指定关卡作为SubLevel，当前关卡作为PersistentLevel，将SubLevel挂载到PersistentLevel下，二者均可以直接通过关卡的名字加载关卡。</p><h2 id="3-使用C-加载umap资源"><a href="#3-使用C-加载umap资源" class="headerlink" title="3.使用C++加载umap资源"></a>3.使用C++加载umap资源</h2><p>这里我就直接在GameInstance中编写逻辑了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UMyGameInstance::AddStreamingLevel</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">bool</span> loadSucess = <span class="hljs-literal">false</span>;<br>    ULevelStreamingDynamic* ls=ULevelStreamingDynamic::LoadLevelInstance(GetWorld(), FString(<span class="hljs-string">&quot;SubOneMap&quot;</span>), FVector(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), FRotator(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), loadSucess);<br>    GetWorld()-&gt;AddStreamingLevel(ls);<br>    ls-&gt;SetShouldBeLoaded(<span class="hljs-literal">true</span>);<br>    ls-&gt;SetShouldBeVisible(<span class="hljs-literal">true</span>);<br>    GetWorld()-&gt;UpdateLevelStreaming();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-使用LevelStreamingVolume加载关卡"><a href="#4-使用LevelStreamingVolume加载关卡" class="headerlink" title="4.使用LevelStreamingVolume加载关卡"></a>4.使用LevelStreamingVolume加载关卡</h2><p>除了上面两种关卡手动加载的方式，UE还提供使用LevelStreamingVolume触发器来自动触发关卡加载，LevelStreamingVolume类似一个触发器，LevelStreaming会检测进入其中的PlayerController，如果发现有PlayerController进入则自动加载指定的关卡，当检测到触发区域不存在PlayerController了，则自动卸载对应关卡。</p><p>LevelStreamingVolume的关卡加载也是基于PersistentLevel进行的，所有的LevelStreamingVolume都应该存在与PersistentLevel中，需要加载的SubLevel都应该预先挂载到PersistentLevel上，这样我们就可以在Window/Levels/SummonsLevelDetails的LevelDetails面板中在InspectLevel中选择要加载的关卡，我这里叫SubOneMap，然后在LevelStreaming/StreamingVolumes中绑定PersistentLevel中的LevelStreamingVolume，这样一个LevelStreamingVolume就和一个关卡绑定了。这里StreamingVolumes是一个数组，所以</p><p><img src="https://img-blog.csdnimg.cn/ef363f96d6e442739bf68fa84fb601d5.png?x-oss-process=type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAR291bGFuZGlz,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"></p><p>现在我们来部署一个场景试试效果：</p><p>首先在主关卡和子关卡中分别布置如下场景。</p><p><img src="https://img-blog.csdnimg.cn/ef363f96d6e442739bf68fa84fb601d5.png?x-oss-process=type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAR291bGFuZGlz,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"></p><p><img src="https://img-blog.csdnimg.cn/df8febdbd5434a63aaba4aad3e29543a.png?x-oss-process=type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAR291bGFuZGlz,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"></p><p>其中子关卡是可以不需要关照的，因为主关卡中已经存在光照了。</p><p>然后按照上面所说的方式，将子关卡挂载到主关卡下，设置好子关卡在主关卡中的位置，并绑定LevelStreaminVolume。运行来看一下效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208141641.gif"></p><h1 id="九、FWorldContext"><a href="#九、FWorldContext" class="headerlink" title="九、FWorldContext"></a>九、FWorldContext</h1><p>根据官方文档的描述，FWorldContext用于处理World的切换，同时也保存着World的信息，在UE中UWorld的切换流程是先销毁当前World然后加载下一个Wolrd，因此前一个World的信息就可以通过FWolrdContext传递到后一个World，FWorldContext有UEngine统一管理，且不对外公开。而对不同的UEngine，FWorldContext的数量是不定的，在GameEngine中FWorldContext是唯一的，而中EditorEngine一定存在一个管理编辑器World的FWorldContext，同时可能存在多个管理PIEWorld的FWorldContext，在UE的逻辑中编辑器也是一个World。</p><p>源码中对于FWorldContext的描述是这样的：</p><ul><li>在引擎级别处理 UWorlds 的上下文。当引擎带来和破坏世界时，我们需要一种方法来保持世界属于什么。</li><li>WorldContexts 可以被认为是一个轨道。默认情况下，我们有 1 个轨道用于加载和卸载关卡。添加第二个上下文就是添加第二个轨道；世界继续生存的另一条轨道。</li><li>对于 GameEngine，将有一个 WorldContext，直到我们决定支持多个同步世界。</li><li>对于 EditorEngine，EditorWorld 可能有一个 WorldContext，PIE World 可能有一个 WorldContext。</li><li>FWorldContext 提供了一种管理“当前 PIE UWorld*”的方法以及连接/旅行到新世界的状态。</li><li>FWorldContext 应该保留在 UEngine 类的内部。外部代码不应保留指针或尝试直接管理 FWorldContext。</li><li>外部代码仍然可以处理 UWorld<em>，并将 UWorld</em>s 传递给引擎级函数。引擎代码可以查找给定 UWorld* 的相关上下文。</li><li>为方便起见，FWorldContext 可以维护指向 UWorld<em>s 的外部指针。例如，PIE 可以将 UWorld</em> UEditorEngine::PlayWorld 与 PIE 世界上下文联系起来。如果 PIE UWorld 发生变化，UEditorEngine::PlayWorld 指针将自动更新。这是通过 AddRef() 和 SetCurrentWorld() 完成的。</li></ul><p>纯机翻，看看就行。</p><h2 id="FWorldContext的创建过程"><a href="#FWorldContext的创建过程" class="headerlink" title="FWorldContext的创建过程"></a>FWorldContext的创建过程</h2><ul><li>在第四节中已经说明过，FWorldContext是由UGameInstance::InitializeStandalone函数调用UEngine::CreateNewWorldContext函数来创建的；</li><li>而UEngine::CreateNewWorldContext函数就是直接new FWorldContext对象的地方，FWorldContext是一个C++结构体，所以UE直接new在了堆上。</li></ul><p>FWorldContext由UE内部管理，对开发者来说是不需要接触的，所以暂时也不需要过深入的了解，只需知道FWorldContext是个什么，干什么的就可以了，以后有时间再去深入了解吧。</p><h1 id="十、USaveGame"><a href="#十、USaveGame" class="headerlink" title="十、USaveGame"></a>十、USaveGame</h1><p>前面已经提到过USaveGame是UE封装好的一个用于持久化保存游戏数据的类，在源码中的描述是这样的：</p><ul><li>此类充当可用于保存游戏状态的保存游戏对象的基类。</li><li>当您创建自己的保存游戏子类时，您将为要保存的信息添加成员变量。</li><li>然后当你想保存游戏时，使用 CreateSaveGameObject 创建这个对象的实例，填写数据，并使用 SaveGameToSlot，提供一个插槽名称。</li><li>要加载游戏，您只需使用 LoadGameFromSlot，然后从结果对象中读取数据。</li></ul><p>而且有意思的是USaveGame是一个空类，贴一下源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">UCLASS(abstract, Blueprintable, BlueprintType)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ENGINE_API</span> <span class="hljs-title">USaveGame</span> :</span> <span class="hljs-keyword">public</span> UObject<br>&#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *@see UGameplayStatics::CreateSaveGameObject</span><br><span class="hljs-comment"> *@see UGameplayStatics::SaveGameToSlot</span><br><span class="hljs-comment"> *@see UGameplayStatics::DoesSaveGameExist</span><br><span class="hljs-comment"> *@see UGameplayStatics::LoadGameFromSlot</span><br><span class="hljs-comment"> *@see UGameplayStatics::DeleteGameInSlot</span><br><span class="hljs-comment"> */</span><br><br>GENERATED_UCLASS_BODY()<br>&#125;;<br></code></pre></td></tr></table></figure><p>这是因为，USaveGame只负责存储游戏数据，即我们可以通过在USaveGame类中创建变量来保存游戏中的数据，将这些游戏数据保存到USaveGame中，然后通过一下方法就可以对USaveGame中的游戏数据进行持久化保存和读取了：</p><ul><li>   UGameplayStatics::CreateSaveGameObject：创建USaveGame类</li><li>   UGameplayStatics::SaveGameToSlot：将USaveGame类序列化保存到磁盘中的.sav文件中</li><li>   UGameplayStatics::DoesSaveGameExist：判断磁盘中默认保存目录下是否存在对应的指定槽位名称的.sav文件</li><li>   UGameplayStatics::LoadGameFromSlot：加载指定槽位名称的.sav文件并返回反序列化后的USaveGame对象</li><li>   UGameplayStatics::DeleteGameInSlot：删除指定槽位名称的.sav文件</li><li>   UGameplayStatics::AsyncSaveGameToSlot：异步地将USaveGame类序列化保存到磁盘中的.sav文件中</li><li>   UGameplayStatics::AsyncLoadGameFromSlot：异步地加载指定槽位名称的.sav文件并返回反序列化后的USaveGame对象</li></ul><p>用法也是非常简单，就没什么好说地了。需要了解的是，我们在编辑器中跑游戏的时候，USaveGame会把.sav文件保存到/项目文件夹/Saved/SaveGame/文件夹下，.sav文件的名字就是保存时的槽位名字，一个.sav文件就是一个存档，当游戏被打包后，.sav文件则存放在/项目目录/Saved/SaveGames/文件夹下</p><h1 id="十一、UActorCompoent"><a href="#十一、UActorCompoent" class="headerlink" title="十一、UActorCompoent"></a>十一、UActorCompoent</h1><p>关于Compoent比较细致一点的文章，网上也是少之又少，只好继续自己撸源码了。</p><p>根据官方文档的说法就是，UE将Actor除基本功能以外的其他功能都拆分成了一个个的UActorComponent了，如负责移动的MovementComponent、负责接收输入的InputComponent、负责物理动画的PhysicalAnimationComponent、负责场景坐标的ScneCompnent、负责模型显示的MeshComponent等等，连是时间线也有一个专门TimeLineComponent负责。</p><p>Compoent对于Actor来说是一种扩展，且Component是能挂载在Actor下，那么一个Component如何挂载到一个Actor下呢？</p><h2 id="1-Compoent挂载"><a href="#1-Compoent挂载" class="headerlink" title="1.Compoent挂载"></a>1.Compoent挂载</h2><h3 id="编辑模式挂载与卸载"><a href="#编辑模式挂载与卸载" class="headerlink" title="编辑模式挂载与卸载"></a>编辑模式挂载与卸载</h3><p>编辑模式直接手动挂载，UE会自动为我们注册组件。卸载直接删除就好。</p><h3 id="蓝图动态挂载与卸载"><a href="#蓝图动态挂载与卸载" class="headerlink" title="蓝图动态挂载与卸载"></a>蓝图动态挂载与卸载</h3><p>蓝图提供<code>Add Component by Class</code>节点来动态的添加组件，同时提供<code>DestroyComponent</code>节点来卸载组件，需要注意的是DestroyComponent节点是一个UActorComponent的一个虚函数。</p><p>已知在4.26中预设了Add Component by Class节点，在4.23中没有。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127144846.png"></p><h3 id="C-动态挂载与卸载"><a href="#C-动态挂载与卸载" class="headerlink" title="C++动态挂载与卸载"></a>C++动态挂载与卸载</h3><p>当我们创建一个C++组件，UE会自动在UClass中添加一个BlueprintSpawnableComponent元数据，这个元数据就是使C++组件可以直接在编辑器里使用，直接在编辑器里添加这个组件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROJECT_API</span> <span class="hljs-title">UAcom_Actor_CPP</span> :</span> <span class="hljs-keyword">public</span> UActorComponent<br>&#123;<br>GENERATED_BODY()<br>&#125;<br></code></pre></td></tr></table></figure><p>C++挂载组件有两种方式，一种是在构造函数中挂载，一种是在运行时挂载，在构造函数中挂载和直接在编辑器中挂载是一样的，都属于编辑时挂载。</p><p><strong>在构造函时挂载</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">AActor_Acom::AActor_Acom()<br>&#123;<br>PrimaryActorTick.bCanEverTick = <span class="hljs-literal">true</span>;<br>    UAcom_Actor_CPP* acom = CreateDefaultSubobject&lt;UAcom_Actor_CPP&gt;(TEXT(<span class="hljs-string">&quot;Acom_Actor_CPP_Contruct&quot;</span>));<br>    AddInstanceComponent(acom);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在运行时挂载</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AActor_Acom::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br>    UAcom_Actor_CPP* acom = NewObject&lt;UAcom_Actor_CPP&gt;(<span class="hljs-keyword">this</span>,TEXT(<span class="hljs-string">&quot;Acom_Actor_CPP_BeginePaly&quot;</span>));<br>    acom-&gt;RegisterComponent();<br>&#125;<br></code></pre></td></tr></table></figure><p>那么二者有什么区别内？</p><p>首先构造时挂载的组件我们在Actor的Details面板中是可以看见组件的，而运行时挂载的组件我们是看不到的，<font color="red">这就意味着构造时挂载的组件我们可以在编辑时和运行时编辑组件的暴露给蓝图的内容，而运行时挂载则对开发者完全不透明。</font></p><p>其次在构造时挂载组件我们需要再手动注册组件，因为CreateDefaultSubobject函数已经对组件进行了注册，需要注意的是CreateDefaultSubobject函数只能在构造函数中使用，在构造函数之外使用会直接导致异常中断，这是因为在CreateDefaultSubobject的源码中直接规定了CreateDefaultSubobject只能在构造函数中使用，否者直接中断。至于AddInstanceComponent函数则是将新创建出来的组件添加到Actor组件列表中，如果不添加进去，尽管Actor也会创建一个新的组件，但是在Actor的Details面板中也看不到组件信息了。而在运行时挂载则需要对组件进行注册，即RegisterComponent，否则Actor只是在堆区创建了一个UObject，却没有把组件添加进World也没有挂载到Actor上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">UObject* <span class="hljs-title">UObject::CreateDefaultSubobject</span><span class="hljs-params">(FName SubobjectFName, UClass* ReturnType, UClass* ClassToCreateByDefault, <span class="hljs-keyword">bool</span> bIsRequired, <span class="hljs-keyword">bool</span> bIsTransient)</span></span><br><span class="hljs-function"></span>&#123;<br>FObjectInitializer* CurrentInitializer = FUObjectThreadContext::Get().TopInitializer();<br>UE_CLOG(!CurrentInitializer, LogObj, Fatal, TEXT(<span class="hljs-string">&quot;No object initializer found during construction.&quot;</span>));<br>UE_CLOG(CurrentInitializer-&gt;Obj != <span class="hljs-keyword">this</span>, LogObj, Fatal, TEXT(<span class="hljs-string">&quot;Using incorrect object initializer.&quot;</span>));<br><span class="hljs-keyword">return</span> CurrentInitializer-&gt;CreateDefaultSubobject(<span class="hljs-keyword">this</span>, SubobjectFName, ReturnType, ClassToCreateByDefault, bIsRequired, bIsTransient);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>卸载组件</strong></p><p>UE提供了UActorComponent::UnregisterComponent函数来取消组件注册，取消注册的同时也会销毁组件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AActor_Acom::Unregister</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    acom-&gt;UnregisterComponent();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-UActorComponent"><a href="#2-UActorComponent" class="headerlink" title="2.UActorComponent"></a>2.UActorComponent</h2><p>由于从UActorComponent派生出来的子类数量相当庞大，所以只重点看几个基类，UActorComponent、USeneComponent、UPrimitiveComponent、UChildActorComponent我们一个个的来看。</p><p>首先我们来看看它们的UML：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127144840.png"></p><p>可以看到UActorComponent是直接继承自UObject的Component的基类，而UE预定义的几个Component类都派生自UActorComponent的子类USeneComponent。</p><p>UActorComponent主要提供一些通用的接口，如ResgisterComponent，UnresgisterComponent，TickComponent，BingePlay，EndPlay，InitializeComponent，UninitializeComponent，SetActive，GetWorld等等。</p><h2 id="3-USceneComponent"><a href="#3-USceneComponent" class="headerlink" title="3.USceneComponent"></a>3.USceneComponent</h2><p>USceneComponent组件为Actor提供在World中Transform功能，包括三维坐标，旋转角和缩放，相对坐标能力。</p><p>并且由于USceneComponent具有相对坐标的能力所以USceneComponent可以进行组件嵌套，同时USceneComponent提供GetChildrenComponent函数来获取嵌套在USceneComponent下的所有组件，同时提供AttachToComponent函数用于去嵌入某个组件下。</p><h3 id="USceneComponent的C-动态动态嵌套"><a href="#USceneComponent的C-动态动态嵌套" class="headerlink" title="USceneComponent的C++动态动态嵌套"></a>USceneComponent的C++动态动态嵌套</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AActor_Acom::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br>    acom = NewObject&lt;UAcom_Scene_CPP&gt;(<span class="hljs-keyword">this</span>, TEXT(<span class="hljs-string">&quot;Acom_Scene_CPP_BeginePaly&quot;</span>));<br>    acom-&gt;RegisterComponent();<br>    UAcom_Scene_CPP* acomChild = NewObject&lt;UAcom_Scene_CPP&gt;(<span class="hljs-keyword">this</span>, TEXT(<span class="hljs-string">&quot;Acom_Scene_CPP_Child&quot;</span>));<br>    acomChild-&gt;RegisterComponent();<br>    acomChild-&gt;AttachToComponent(acom,FAttachmentTransformRules::SnapToTargetIncludingScale,FName(<span class="hljs-string">&quot;Acom_Scene_CPP_Child_1&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>UE提供了AttachToComponent方法来见过一个USceneComponent嵌套进另一个USceneComponent中。<font color="red">需要注意的是，AttachToCpmponent函数无法再构造函数中使用，否则直接编译不过。</font></p><p>事实上UE提供了AttachTo和AttachToComponent两个函数来进行USceneComponent的嵌套，AttachTo时已经过时的方法，在源码的标注的是4.12的时候就已经弃用了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">UE_DEPRECATED(<span class="hljs-number">4.12</span>, <span class="hljs-string">&quot;This function is deprecated, please use AttachToComponent instead.&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">USceneComponent::AttachTo</span><span class="hljs-params">(class USceneComponent* Parent, FName InSocketName, EAttachLocation::Type AttachType = EAttachLocation::KeepRelativeOffset , <span class="hljs-keyword">bool</span> bWeldSimulatedBodies = <span class="hljs-literal">false</span>)</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">USceneComponent::AttachToComponent</span><span class="hljs-params">(USceneComponent* Parent, <span class="hljs-keyword">const</span> FAttachmentTransformRules&amp; AttachmentRules, FName SocketName)</span></span><br></code></pre></td></tr></table></figure><p>而AttachToComponent中新增了一个必须输入的参数—FAttachmentTransformRules，这是一个结构体，总共有四个对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/** Rules for attaching components */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ENGINE_API</span> <span class="hljs-title">FAttachmentTransformRules</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-comment">/** Various preset attachment rules. Note that these default rules do NOT by default weld simulated bodies */</span><br><span class="hljs-keyword">static</span> FAttachmentTransformRules KeepRelativeTransform;<br><span class="hljs-keyword">static</span> FAttachmentTransformRules KeepWorldTransform;<br><span class="hljs-keyword">static</span> FAttachmentTransformRules SnapToTargetNotIncludingScale;<br><span class="hljs-keyword">static</span> FAttachmentTransformRules SnapToTargetIncludingScale;<br><br>FAttachmentTransformRules(EAttachmentRule InRule, <span class="hljs-keyword">bool</span> bInWeldSimulatedBodies)<br>: LocationRule(InRule)<br>, RotationRule(InRule)<br>, ScaleRule(InRule)<br>, bWeldSimulatedBodies(bInWeldSimulatedBodies)<br>&#123;&#125;<br><br>FAttachmentTransformRules(EAttachmentRule InLocationRule, EAttachmentRule InRotationRule, EAttachmentRule InScaleRule, <span class="hljs-keyword">bool</span> bInWeldSimulatedBodies)<br>: LocationRule(InLocationRule)<br>, RotationRule(InRotationRule)<br>, ScaleRule(InScaleRule)<br>, bWeldSimulatedBodies(bInWeldSimulatedBodies)<br>&#123;&#125;<br><br><span class="hljs-comment">/** The rule to apply to location when attaching */</span><br>EAttachmentRule LocationRule;<br><br><span class="hljs-comment">/** The rule to apply to rotation when attaching */</span><br>EAttachmentRule RotationRule;<br><br><span class="hljs-comment">/** The rule to apply to scale when attaching */</span><br>EAttachmentRule ScaleRule;<br><br><span class="hljs-comment">/** Whether to weld simulated bodies together when attaching */</span><br><span class="hljs-keyword">bool</span> bWeldSimulatedBodies;<br>&#125;;<br></code></pre></td></tr></table></figure><p>FAttachmentTransformRules参数描述了子组件嵌入父组件是的坐标与缩放规则：</p><ul><li>KeepRelativeTransform：嵌入的子组件使用其父组件的相对坐标；</li><li>KeepWorldTransform：嵌入的子组件保持自己的世界坐标；</li><li>SnapToTargetNotIncludeingScale：使用(0,0,0)的相对坐标并重置Scaleda到(1,1,1)；</li><li>SnapToTargetIncludeingScale：使用(0,0,0)的相对坐标但不重置Scale到(1,1,1)；</li></ul><h3 id="USceneComponent的蓝图动态嵌套"><a href="#USceneComponent的蓝图动态嵌套" class="headerlink" title="USceneComponent的蓝图动态嵌套"></a>USceneComponent的蓝图动态嵌套</h3><p>UE蓝图提供了两个接口来嵌套USceneComponent，AttachActorToComponent和Attach ComponentToComponent。</p><p>AttachActorToComponent是直接将子USceneComponent嵌套到Actor的RootComponent下；</p><p>Attach ComponentToComponent则是将子USceneComponent嵌套到指定的USceneComponent下。</p><h2 id="4-UPrimitiveComponent"><a href="#4-UPrimitiveComponent" class="headerlink" title="4.UPrimitiveComponent"></a>4.UPrimitiveComponent</h2><p>UPrimitiveComponent是一系列可视组件的基类，如碰撞体相关的ShepeComponent、BoxComponent等，与渲染相关的StaticMeshComponent、ModelComponent等，工具相关的ArrowComponent、SplineComponent等，与场景相关的BrushComponent、LandscapeComponent等。</p><p>UPrimitiveComponent直接继承自USceneComponent所以也拥有坐标相关的能力，在此之上UPrimitiveComponent还提供了物理碰撞和渲染相关的能力，按照源码注释的说法就是：</p><ul><li>PrimitiveComponents 是包含或生成某种几何体的场景组件，通常用于渲染或用作碰撞数据。</li><li>对于各种类型的几何体，有几个子类，但目前最常见的ShapeComponents（Capsule、Sphere、Box）、StaticMeshComponent 和 SkeletalMeshComponent。</li><li>ShapeComponents 生成用于碰撞检测但不渲染的几何体，而 StaticMeshComponents 和 SkeletalMeshComponents 包含渲染的预构建几何体，但也可用于碰撞检测。</li></ul><p><font color="red">值得注意的是，UPrimitiveComponent默认是不开启Tick的，所以我们如果想要TickComponent函数就需要在构造函数中手动打开<code>PrimaryComponentTick.bCanEverTick = true;</code></font></p><p>UPrimitiveComponent的基本能力已经不在GamePlay范畴，这里就不继续深入了，以后有时间再深入了解。</p><h2 id="5-UChildActorComponent"><a href="#5-UChildActorComponent" class="headerlink" title="5.UChildActorComponent"></a>5.UChildActorComponent</h2><p>UChildActorComponent是专门用于Actor嵌套子Actor功能的组件，UChildActorComponent在注册时和其他组件有些不同，因为UChildActorComponent会在注册时自动创建一个Actor，在销毁时也会将Actor一并销毁，所以如果我们在组件注册时未设定UChildActorComponent绑定的Actor类型，UChildActorComponent会创建默认的AActor，只有绑定了Actor类型才会去创建指定类型的Actor。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UChildActorComponent::CreateChildActor</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>AActor* MyOwner = GetOwner();<br><span class="hljs-keyword">if</span> (MyOwner &amp;&amp; !MyOwner-&gt;HasAuthority())<br>&#123;<br>AActor* ChildClassCDO = (ChildActorClass ? ChildActorClass-&gt;GetDefaultObject&lt;AActor&gt;() : <span class="hljs-literal">nullptr</span>);<br><span class="hljs-comment">//...</span><br>    &#125;<br>DestroyChildActor();<br><span class="hljs-keyword">if</span>(ChildActorClass != <span class="hljs-literal">nullptr</span>)<br>&#123;<br><span class="hljs-comment">//...</span><br>ChildActor = World-&gt;SpawnActor(ChildActorClass, &amp;Location, &amp;Rotation, Params);<br><span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在运行时创建"><a href="#在运行时创建" class="headerlink" title="在运行时创建"></a>在运行时创建</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AActor_Acom::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br>    acom = NewObject&lt;UAcom_Child_CPP&gt;(<span class="hljs-keyword">this</span>, TEXT(<span class="hljs-string">&quot;Acom_Child_CPP_BeginePlay&quot;</span>));   <br>    TSubclassOf&lt;ACubeActor&gt; cube = ACubeActor::StaticClass();<br>    acom-&gt;SetChildActorClass(cube);<br>    acom-&gt;RegisterComponent();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在构造时创建"><a href="#在构造时创建" class="headerlink" title="在构造时创建"></a>在构造时创建</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">AActor_Acom::AActor_Acom()<br>&#123;<br>PrimaryActorTick.bCanEverTick = <span class="hljs-literal">true</span>;<br>    acom = CreateDefaultSubobject&lt;UAcom_Child_CPP&gt;(TEXT(<span class="hljs-string">&quot;Acom_Child_CPP_Contruct&quot;</span>));  <br>    TSubclassOf&lt;ACubeActor&gt; cube = ACubeActor::StaticClass();<br>    acom-&gt;SetChildActorClass(cube);<br>    AddInstanceComponent(acom); <br>&#125;<br></code></pre></td></tr></table></figure><p>和PtimitiveComponent一样UChildActorComponent也默认不开启Tick。</p><h1 id="十三、总结"><a href="#十三、总结" class="headerlink" title="十三、总结"></a>十三、总结</h1><p>最后来总结一下整个GamePlay的初始化流程，这张图是基于UE4.26来制作的，所以与前面的UE5源码的流程可能会有点出入：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127144919.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Git】Git操作手册</title>
    <link href="/2021/08/11/%E3%80%90Git%E3%80%91Git%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/"/>
    <url>/2021/08/11/%E3%80%90Git%E3%80%91Git%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><a id="more"></a><h2 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">&lt;仓库地址&gt;</span><br></code></pre></td></tr></table></figure><h2 id="查看当前分支"><a href="#查看当前分支" class="headerlink" title="查看当前分支"></a>查看当前分支</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git branch</span><br></code></pre></td></tr></table></figure><h2 id="查看所有分支"><a href="#查看所有分支" class="headerlink" title="查看所有分支"></a>查看所有分支</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git branch -a</span><br></code></pre></td></tr></table></figure><h2 id="切换本地分支"><a href="#切换本地分支" class="headerlink" title="切换本地分支"></a>切换本地分支</h2><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">git checkout <span class="hljs-attribute">&lt;本地分支名&gt;</span><br></code></pre></td></tr></table></figure><h2 id="下载远程分支到本地分支"><a href="#下载远程分支到本地分支" class="headerlink" title="下载远程分支到本地分支"></a>下载远程分支到本地分支</h2><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">git checkout -b <span class="hljs-attribute">&lt;本地分支名&gt;</span> <span class="hljs-attribute">&lt;远程分支名&gt;</span><br></code></pre></td></tr></table></figure><p>远程分支名一般为<code>origin/远程仓库名</code></p><h2 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h2><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">git branch -D <span class="hljs-attribute">&lt;本地分支名&gt;</span><br></code></pre></td></tr></table></figure><h2 id="新建本地分支"><a href="#新建本地分支" class="headerlink" title="新建本地分支"></a>新建本地分支</h2><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">git branch <span class="hljs-attribute">&lt;新分支名&gt;</span><br></code></pre></td></tr></table></figure><h2 id="提交本地分支到仓库"><a href="#提交本地分支到仓库" class="headerlink" title="提交本地分支到仓库"></a>提交本地分支到仓库</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> &lt;分支名&gt;<br></code></pre></td></tr></table></figure><h2 id="查看本地仓库修改状态"><a href="#查看本地仓库修改状态" class="headerlink" title="查看本地仓库修改状态"></a>查看本地仓库修改状态</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git status</span><br></code></pre></td></tr></table></figure><h2 id="清除本地所有修改-未add"><a href="#清除本地所有修改-未add" class="headerlink" title="清除本地所有修改(未add)"></a>清除本地所有修改(未add)</h2><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">git clean -df .<br></code></pre></td></tr></table></figure><h2 id="查看提交日志"><a href="#查看提交日志" class="headerlink" title="查看提交日志"></a>查看提交日志</h2><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">git <span class="hljs-keyword">log</span> <span class="hljs-variable">&lt;文件路径&gt;</span><br></code></pre></td></tr></table></figure><p>加文件路径则查看指定文件的提交日志，不加则查看所有的提交日志</p><h2 id="查看所有文件的修改"><a href="#查看所有文件的修改" class="headerlink" title="查看所有文件的修改"></a>查看所有文件的修改</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git diff</span><br></code></pre></td></tr></table></figure><h2 id="查看指定文件的修改"><a href="#查看指定文件的修改" class="headerlink" title="查看指定文件的修改"></a>查看指定文件的修改</h2><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">git diff <span class="hljs-attribute">&lt;文件路径&gt;</span><br></code></pre></td></tr></table></figure><h2 id="还原所有文件的修改"><a href="#还原所有文件的修改" class="headerlink" title="还原所有文件的修改"></a>还原所有文件的修改</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git checkout</span><br></code></pre></td></tr></table></figure><h2 id="还原指定文件的修改"><a href="#还原指定文件的修改" class="headerlink" title="还原指定文件的修改"></a>还原指定文件的修改</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git checkout &lt;文件路径&gt;<span class="hljs-regexp">//</span>多个文件之间用空格隔开<br></code></pre></td></tr></table></figure><h2 id="Add指定文件"><a href="#Add指定文件" class="headerlink" title="Add指定文件"></a>Add指定文件</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">git <span class="hljs-keyword">add</span><span class="bash"> &lt;文件路径&gt;</span><br></code></pre></td></tr></table></figure><p>多文件用空格隔开</p><h2 id="回退Add的操作"><a href="#回退Add的操作" class="headerlink" title="回退Add的操作"></a>回退Add的操作</h2><p>有时我们会直接<code>git add .</code>可能会将我们不想往上传的文件给add了，此时可以使用</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">git reset <span class="hljs-attribute">&lt;文件路径&gt;</span><br></code></pre></td></tr></table></figure><p>单独的git reset是回退所有add操作，git reset &lt;文件路径&gt;可以指定回退某一个文件，多文件用空格隔开。</p><h2 id="撤销Commit"><a href="#撤销Commit" class="headerlink" title="撤销Commit"></a>撤销Commit</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard HEAD^</span><br></code></pre></td></tr></table></figure><p>HEAD指向当前节点的指针，HEAD^指向前一个结点的指针</p><h2 id="查看Commit提交"><a href="#查看Commit提交" class="headerlink" title="查看Commit提交"></a>查看Commit提交</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">git <span class="hljs-keyword">show</span><br></code></pre></td></tr></table></figure><h2 id="添加Fork仓库"><a href="#添加Fork仓库" class="headerlink" title="添加Fork仓库"></a>添加Fork仓库</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">git <span class="hljs-keyword">add</span><span class="bash"> upstrem &lt;Fork仓库路径&gt;</span><br></code></pre></td></tr></table></figure><h2 id="同步Fork仓库到本地"><a href="#同步Fork仓库到本地" class="headerlink" title="同步Fork仓库到本地"></a>同步Fork仓库到本地</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git pull upstream</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作手册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE5】UE5 Dedicated Server专用服务器与网络同步</title>
    <link href="/2021/08/11/%E3%80%90UE5%E3%80%91UE5%20Dedicated%20Server%E4%B8%93%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5/"/>
    <url>/2021/08/11/%E3%80%90UE5%E3%80%91UE5%20Dedicated%20Server%E4%B8%93%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>这篇文章是个人在学习UE4的网络同步方面的内容的一些记录，因为UE5出来了，顺带也一起熟悉熟悉UE5，所以也就直接使用UE5来实践了。说句实在话，UE4网络同步这块确实挺难的，我自己在网上搜索的博客的内容要么停留在很浅层面只搭建一个ds服务器，要么就直接深入源码去剖析UE4的网络机制，处在中间层面的内容少之又少，不得不自己好一阵研究，强烈推荐这几位博主的博文，我在学习的过程中也从中受益匪浅。</p><p> <a href="https://www.cnblogs.com/AnKen/p/7897076.html">Ken_An</a>、<a href="https://blog.ch-wind.com/ue4-multiplayer-and-network-overview/">风蚀之月</a>、 <a href="https://blog.csdn.net/weixin_37864449/article/details/89096536">刘东无敌</a>还有我师傅推荐给我的一本<a href="https://cedric-neukirchen.net/Downloads/Compendium/UE4_Network_Compendium_by_Cedric_eXi_Neukirchen.pdf">关于UE4网络的PDF</a>。</p><a id="more"></a><hr><h1 id="一、什么是Dedicated-Server"><a href="#一、什么是Dedicated-Server" class="headerlink" title="一、什么是Dedicated Server"></a>一、什么是Dedicated Server</h1><p>UE5除了<strong>Nanite</strong>和<strong>Lumen</strong>两个比较大的技术改动之外，其他的部分实际上和UE4基本是一致的，所以虽说使用的是UE5来搭建Dedicated Server，实际操作和UE4没什么区别。</p><p>事实上UE5有提供两种服务器Dedicated Server和Listen Server，Dedicated Server是专用服务器，服务器和客户端是剥离开来的，而Listen Server则是类似局域网联机一般的，使用其中某一个客户端作为服务器的模式。</p><p>这里就谈到游戏网络同步的方式了，游戏网络同步的方式一般分为两种方式，P2P和C/S，P2P即每一台客户端之间互相直连，这种方式的同步极为复杂，对联机游戏来说基本已经淘汰了。C/S即经典的客户端/服务器模式，C/S又可细分为两种，一种是由一个客户端做主机，其他的客户端连接这个主机来进行网络同步，主机即拥有服务器功能也拥有客户端功能，这种模式多用于局域网联机，这种模式中每一个客户端都可以成为主机；一种是单独剥离服务器的功能，服务端只处理服务器相关的业务，所有的客户端都通过连接服务器来进行网络同步，同时客户端只留下客户端相关的业务，这就是网游中最常用的模式了。</p><p>首先我们需要明确一个认知—UE5的客户端代码和服务器代码是一体的，即两端的代码实际上是混杂在一起的。我们经常听到一种说法叫“前后端分离”，就是服务器干服务器的，客户端干客户端的，二者各为两个工程互不干扰，互相之间通过TCP或者UDP进行通信。而UE5的模式则是客户端和服务器不分离，同在一个工程之中，互相之间的代码使用宏来区分。两种方式各有各的好处。</p><p>我们这里要学习的ds服务器就是从这个一体的工程中单独剥离出来的一个服务器，为什么要剥离呢？如果不剥离，网络同步就变成了C/S模式的第一种情况了，但是大多数情况下服务器是不需要场景渲染，人物控制这些客户端业务的，剥离出来可以减轻服务器的运行压力。</p><p>Dedicated Server服务器简称ds服务器，是UE5用于解决FPS同步问题的一种专用服务器，UE5在UDP上自己做了一层根据游戏特点专门优化的网络协议(epic不愧是fps起家的😂)，专门用于ds通信，ds服务器的一大特点就是客户端和服务器共享一份代码，因为高性能的同步需要各种客户端预测和回溯的方法，可以很好的解决同步延迟问题。但是UE5ds服务器承载量不高，不适合用于需要连接大量客户端的场景。</p><hr><h1 id="二、搭建DS服务器"><a href="#二、搭建DS服务器" class="headerlink" title="二、搭建DS服务器"></a>二、搭建DS服务器</h1><p>暂时我们先搭一个最简单的，只有客户端连接功能的ds服务器，后面我们再慢慢迭代的往里面加功能。</p><h2 id="1-使用源码编译UE5引擎"><a href="#1-使用源码编译UE5引擎" class="headerlink" title="1.使用源码编译UE5引擎"></a>1.使用源码编译UE5引擎</h2><h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><p><a href="https://github.com/EpicGames/UnrealEngine/releases/tag/5.0.0-early-access-1">直接zip下载</a></p><p><a href="https://github.com/EpicGames/UnrealEngine">git克隆</a></p><p>git clone记得要切换分支到ue5-early-access这是抢先体验版的源码。</p><h3 id="下载依赖项"><a href="#下载依赖项" class="headerlink" title="下载依赖项"></a>下载依赖项</h3><p>运行Setup.bat，要下载挺多东西的，得等一段时间。</p><h3 id="生成VS工程文件"><a href="#生成VS工程文件" class="headerlink" title="生成VS工程文件"></a>生成VS工程文件</h3><p>运行GenerateProjectFiles.bat生成VS工程文件</p><p>需要注意的是，UE5只支持VS2019，所以编译源码之前得先把VS2019安装好。</p><p>这时有可能会报路径过长的错误，只需要把引擎剪贴到盘符根目录去就行了。</p><p>跑完之后工程目录下就会出现一个UE5.sln文件，使用VS2019打开即可编译了。</p><h2 id="2-为什么需要使用源码编译的UE5"><a href="#2-为什么需要使用源码编译的UE5" class="headerlink" title="2.为什么需要使用源码编译的UE5"></a>2.为什么需要使用源码编译的UE5</h2><p>因为我们编译ds服务器需要使用<code>Development Server</code>模式编译，而使用epic启动器下载的UE5创建的工程没有这个模式，只有自己使用源码编译的UE5创建的工程才有这个模式</p><h2 id="3-编译DS服务器"><a href="#3-编译DS服务器" class="headerlink" title="3.编译DS服务器"></a>3.编译DS服务器</h2><p>如果用UE5创建C++工程报.net版本过低，就去VS把对应的.net版本下下来即可。</p><p>我们需要分别为Server端，Client端和过渡时分别创建一个默认地图，所以我们创建三个地图</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210802213953.png"></p><p>然后再Project Setting/Map&amp;Mod中分别如下配置</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809225937.png"></p><p>在关卡蓝图的tick事件上分别编写一些字符串打印，以便后面观察地图的切换。</p><p>我这里直接打印了地图名字：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210802213959.png"></p><p>顺带提一句，如果创建工程时不是创建的C++工程，而是空工程或者纯蓝图工程则需要随便创建一个C++类来打开VS工程。</p><p>据说如果不创建一个C++类就直接去编译ds可能编译不过，我这里是直接创建了一个GameInstance再编译的，所以也就没有碰到这个问题，想想UE5应该把这个bug解决了吧，如果碰到了这个问题就去创建一个类再编译吧。</p><p>在VS里把编译模式更换成Development Server，然后手动添加一个xx.Target.cs文件，目前内容比较简单，我们只需要拷贝一份UE5自动生成xxEditor.Target.cs文件更名为xxServer.Target.cs，然后把里面的Editor字样都换成Server就可以了。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnrealBuildTool;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LSPTetrisClientServerTarget</span> : <span class="hljs-title">TargetRules</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LSPTetrisClientServerTarget</span>(<span class="hljs-params"> TargetInfo Target</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">Target</span>)</span><br><span class="hljs-function"></span>&#123;<br>Type = TargetType.Editor;<br>DefaultBuildSettings = BuildSettingsVersion.V2;<br>ExtraModuleNames.AddRange( <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123; <span class="hljs-string">&quot;LSPTetrisClient&quot;</span> &#125; );<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们手动将文件添加到工程里。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210802214005.png"></p><p>最后编译，编译事件比较长，需要耐心等待一下，编译完之后我们就可以在工程目录<code>Binaries\Win64</code>下看到编译出来的exe文件了。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809225931.png"></p><p>如果编译出来没有的话，就重新选择一下<code>Switch Unreal Engine version</code>，然后再编译。</p><p>此时的exe还是不能运行的，因为它需要依赖一些客户端的代码，所以需要等客户端打包出来之后，放到客户端的文件夹下运行。</p><h2 id="4-打包客户端"><a href="#4-打包客户端" class="headerlink" title="4.打包客户端"></a>4.打包客户端</h2><p>把VS编译模式更改成Development Editor，可以直接从vs启动引擎，也可以通过uproject启动引擎，然后打包工程，顺带一提，UE5把打包选项更换到了这个位置</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210802214045.png"></p><p>到这一步就可以把之前编译出来的ds服务器的exe拷贝到打包出来的客户端目录里了<code>..\Binaries\Windows\LSPTetrisClient\Binaries\Win64</code>。</p><p>直接双击启动ds服务器，服务器是没有界面的，会直接在后台运行，如果想要关闭，就得去任务管理器关闭了，想要有界面有两种方式启动，其一，通过cmd启动，给exe传入log参数</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">start</span> LSPTetrisClientServer.exe -<span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p>如果没有进入xxServer.exe所在文件夹记得使用绝对路径；</p><p>其二，为xxServer.exe创建快捷方式，在右键/属性/快捷方式/目标，后面加-log，需要用空格隔开，通过快捷方式启动。</p><h2 id="5-客户端连接ds服务器"><a href="#5-客户端连接ds服务器" class="headerlink" title="5.客户端连接ds服务器"></a>5.客户端连接ds服务器</h2><p>启动ds服务器，再启动客户端，这里我在局域网里用两台电脑测试，做服务器的主机ip为10.14.32.50，做客户端的主机ip为10.14.99.156。</p><p>将打出来的包拷贝到另一台电脑里，如果直接运行<code>Windows\LSPTetrisClient\Binaries\Win64</code>下的客户端exe，提示缺少dll无法运行的话，UE5还在包的根目录贴心的准备了一个安装运行环境的exe，双击把环境安装好就可以运行了。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210802214056.png"></p><p><strong>测试结果：</strong></p><p>启动ds服务器时，可以看到服务器加载了默认的ServerMap</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210802214103.png"></p><p>然后我们再另一台电脑上启动客户端，此时客户端加载了在项目中配置的默认地图</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210802214112.png"></p><p>由于我们没有在地图中加任何Actor，所以地图是一片黑，后面我们再往里面加东西，我们也没有写连接ds的逻辑，所以这里我们使用控制台来连接ds，在客户端窗口按下<code>~</code>这个键，输入</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">open</span> <span class="hljs-number">10.14</span><span class="hljs-number">.32</span><span class="hljs-number">.50</span><span class="hljs-comment">//这是我的运行ds服务器主机的IP</span><br></code></pre></td></tr></table></figure><p>然后我们就可以看到客户端同步到服务器的地图了</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210802214120.png"></p><p>并且在ds服务器中也能看到有客户端连接进来</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210802214127.png"></p><h2 id="6-实现人物同步"><a href="#6-实现人物同步" class="headerlink" title="6.实现人物同步"></a>6.实现人物同步</h2><p>现在我们开始迭代下一个版本，最基础的人物控制的同步。首先向工程中添加第三人称模板进来。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210802214134.png"></p><p>这时可能会添加不了或者添加进去了有一些东西找不到，这是因为我们在编译引擎时只编译了引擎没有编译Programs下面那一堆的东西，直接再编译一次整个解决方案就好了。</p><h3 id="向场景中添加内容"><a href="#向场景中添加内容" class="headerlink" title="向场景中添加内容"></a>向场景中添加内容</h3><p>现在我们的场景还是一片黑，因为我们的场景里面啥都没有，打开预设面板</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210802214141.png"></p><p>搜索<code>BP_Sky_Sphere</code>和<code>DirectionalLight</code>，将天空球和平行光添加到场景里，现在场景就变成了我们熟悉的界面了。分别把ClientMap和ServerMap都布置好，TransitionMap就不需要了，ServerMap里面还需要添加一个Plane以便人物生成之后有地方站立，和一个PlayerStart控制人物的生成位置。</p><h3 id="编写连接ds服务器的逻辑"><a href="#编写连接ds服务器的逻辑" class="headerlink" title="编写连接ds服务器的逻辑"></a>编写连接ds服务器的逻辑</h3><p>然后我们在GameInstance里面编写连接ds服务器的逻辑，逻辑也很简单，直接调用一个内置api就好了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ULSPTetrisGameInstance::ConnectDs</span><span class="hljs-params">(FString ip)</span></span><br><span class="hljs-function"></span>&#123;<br>GetWorld()-&gt;GetFirstPlayerController()-&gt;ClientTravel(ip, TRAVEL_Absolute); <br>&#125;<br></code></pre></td></tr></table></figure><p>ClientTravel是PlayerController里的一个函数，所以需要先通过World获取PlayerController来调用。</p><p>ClientTravel有四种连接模式，我们这里使用绝对网址即IP，其他的模式可以直接去<a href="https://docs.unrealengine.com/4.26/en-US/API/Runtime/Engine/Engine/ETravelType/">官方文档</a>了解。</p><p>然后我们再创建一个UMG来输入IP地址并可以点击登录。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210802214151.png"></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210802214200.png"></p><p>SetFullscreenMode设置游戏以窗口模式运行。</p><p>然后UMG的创建就直接放在ClientMap的关卡蓝图里了。</p><p>然后我们再重新编译一个ds服务器和客户端，如果没有更改服务器相关的代码是不需要重新编译ds服务器的，这里保险起见我还是都重新编了一个。</p><h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210804155737.gif"></p><p>机器有点不行，跑起来卡卡的。</p><hr><h1 id="三、Actor同步"><a href="#三、Actor同步" class="headerlink" title="三、Actor同步"></a>三、Actor同步</h1><h2 id="1-普通Actor的网络同步"><a href="#1-普通Actor的网络同步" class="headerlink" title="1.普通Actor的网络同步"></a>1.普通Actor的网络同步</h2><p>使用第三人称模板之所以这么容易就把人物同步给实现了，是因为里面很多设置模板都已经给我们设置好了，那么现在我们继续迭代，实现我们自定义的Actor的网络同步。</p><p>比如我们按下E键在角色前方创建一个物理方块，如何将这个物理方块从创建到掉落的整个过程在所有客户端同步？</p><p>首先我们为方块创建一个出生点，我在人物下面添加一个Sphere组件，去除Sphere的staticmesh使它不显示，然后将相对位置移动到人物前上方用于作为生成方块的位置，</p><p>然后我们创建一个Actor，命名为Cube，给与一个cube的static mesh，给予一个box collision组件，box collision和static mesh都要勾选Simulate Physics和Mass给与Cube物理效果和重力效果。最重要的一步——–勾选Replication/Replicates，使Cube可以在各个客户端之间复制，否则Actor是无法进行同步的。</p><p>在Cube里只做一件事，就是生成后3秒自动销毁，给一个自定义事件执行销毁逻辑，并在构造函数里调用。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210802215840.png" alt="image-20210802215806819"></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210802215842.png" alt="image-20210802215735373"></p><p>然后我们在ThridPersonCharacter中也添加一个自定义事件，用于执行创建Cube的逻辑，然后在按键E的检测事件中调用这个事件。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210802220241.png" alt="image-20210802220238583"></p><h3 id="蓝图的属性复制"><a href="#蓝图的属性复制" class="headerlink" title="蓝图的属性复制"></a>蓝图的属性复制</h3><p>为什么一定要将Cube的创建封装在一个自定义事件里？因为只有自定义事件才可以选择是事件的执行位置。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210802220405.png" alt="image-20210802220402817"></p><ul><li>Not Replicated：不进行网络复制；</li><li>Multicast：由服务器调用，在服务器和所有客户端执行；</li><li>Run on Server：在客户端中调用，在服务器中执行；</li><li>Run on owning Client：只在有所有权的客户端执行，执行结果不会同步到其他客户端。</li></ul><h3 id="执行效果"><a href="#执行效果" class="headerlink" title="执行效果"></a>执行效果</h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210804155737.gif"></p><p>这里加了一个人物触碰时更改cube颜色的效果，以便同步时显示的更明显。</p><h3 id="Actor的所有权—ROLE"><a href="#Actor的所有权—ROLE" class="headerlink" title="Actor的所有权—ROLE"></a>Actor的所有权—ROLE</h3><p>UE将Actor的控制权分成了三类，分别是：</p><ul><li><p>ROLE_None：这个None就是我们平常理解的None，不属于下面三种的都是None</p></li><li><p>ROLE_Authority：服务器拥有所有Actor的控制权，即所有的Actor在服务器端的控制权都是ROLE_Authority</p></li><li><p>ROLE_AutonomousProxy：客户端对本地Actor拥有这个控制权</p></li><li><p>ROLE_SimulatedProxy：客户端对网络Actor，即其他端的Actor，拥有这个控制权</p></li></ul><p>这个三个属性是UE设计Actor时就为Actor设计好的固有属性，可以用于判断一个Actor所在位置，因为UE的服务器代码和客户端代码是一体的，所以Actor设计这个属性是十分必要的。</p><p>我们可以用一个示例来具体观摩一下，我们将项目继续迭代，现在我们在角色的头顶添加一个TextRender，然后把GetLocalRole的控制权名称设置到TextRender上。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809225948.png"></p><p>然后运行起来</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809225951.png"></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809230015.png"></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809230012.png"></p><p>可以看到，在服务器端的窗口上所有的人物都显示的是ROLE_Authority，而在两个客户端的窗口上只有自己控制的人物显示ROLE_AutonomousProxy，其他的都显示ROLE_SimulatedProxy，尽管其中有一个人物是服务器生成的，但对于这个客户端来说它也属于其他端的Actor。</p><h2 id="2-自定义Pawn的网络同步"><a href="#2-自定义Pawn的网络同步" class="headerlink" title="2.自定义Pawn的网络同步"></a>2.自定义Pawn的网络同步</h2><p>关于自定义Pawn的网络同步，在网上的资料简直少得可怜，项目迭代到这里，也是磕磕绊绊搞了好一阵子。</p><p>这里为了和第三人称模板完全脱离关系，我们创建一些自己的GamePlay。</p><ul><li>创建一个自己的GameMode：LSPGameMode</li><li>创建一个自己的PlayerController：LSPPlayerController</li><li>创建一个自己的可控制的Pawn：Ball</li></ul><p>然后把GameMode换成LSPGameMode，把LSPGameMode的PlayerControllerClass换成LSPPlayerController，把DefaultPawnClass换成Ball。</p><h3 id="实现一个可控制滚动的Pawn"><a href="#实现一个可控制滚动的Pawn" class="headerlink" title="实现一个可控制滚动的Pawn"></a>实现一个可控制滚动的Pawn</h3><p>这里推荐跟着UE4中的Rolling模板来做，在UE5中这个模板已经被移除了。</p><p>Pawn的结构</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809230019.png"></p><p>这里为了看起来滚动明显一点就给了一个Cube的Mesh。</p><p>Pawn的蓝图</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809230245.png"></p><p>这里PlayerController的硬件输入配置还是沿用第三人称模板预定义好的那些配置。</p><p>这里单独把角色控制封装在一个事件里也是为了让控制Pawn滚动的蓝图跑在服务器上，这样服务器才能把一个客户端的运动同步到其他的客户端。</p><p>这里Speed和JumpImpulse的值要给大一点，否则滚跳起来没什么效果。</p><p>在实现可滚动的方块时，出现了摄像机和方块一起滚动的问题，这是我们需要把SpringArm下的这些勾都取消掉。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809230039.png"></p><p>到这里一个可控制的滚动方块就成了，下面是运行效果</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809230039.png"></p><p>然后打包客户端，按理来说ds服务器是不需要再编译了的，因为服务器也是用的客户端的代码，编译出来的exe也就是提供一个服务器的入口，如果不行的话建议也再编译一次服务器。</p><h3 id="运行效果-1"><a href="#运行效果-1" class="headerlink" title="运行效果"></a>运行效果</h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809230136.gif"></p><h1 id="四、Actor的属性同步"><a href="#四、Actor的属性同步" class="headerlink" title="四、Actor的属性同步"></a>四、Actor的属性同步</h1><h2 id="1-简单属性的同步"><a href="#1-简单属性的同步" class="headerlink" title="1.简单属性的同步"></a>1.简单属性的同步</h2><p>前面我们都是停留在角色移动的网络同步上，而实际游戏中除了最基础移动同步外，还有很多其他的属性数据也需要同步，比如当某一个客户端的角色换了一个皮肤之后，其他的客户端里这个角色也应该同步显示新的皮肤。</p><p>如果要实现客户端的属性发生改变的同时属性值同步到其他客户端中，我们需要铭记两点：</p><ul><li>属性的Replication应勾选Replicated或RepNotify；</li><li>修改属性的代码或蓝图必须运行在服务器上。</li></ul><p><strong>Actor的Replication</strong></p><p>Replication是任何派生于UObject的类的变量的固有属性，用于标识这个变量是否允许网络同步。在蓝图中Replication属性有三种可选值</p><ul><li>None：属性不允许网络同步；</li><li>Replication：属性允许网络同步；</li><li>RepNotify：属性允许网络同步，同时绑定一个回调函数，属性发生变化时回调，在蓝图中回调函数会自动创建在FUNCTION中并以<code>OnRep_</code>开头，以属性名结尾，如属性pos的回调函数为<code>OnRep_pos</code>。</li></ul><p>现在我们继续迭代项目，我们在自定义Pawn中添加一个整型变量Time，这里我选择将Time的Repliction属性设置成RepNotify，以便Time发生变化时修改TextRender的Text。然后在Pawn中添加一个TextRender用于显示Time的值，我们把TextRender放在SpringArm下，这样文字就不会跟着方块滚动。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809230154.png"></p><p>然后在Ball中添加如下蓝图：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809230159.png"></p><p>这里要注意的一点就是Time值得修改要运行在服务器上，所以SetTime节点我用来一个运行在服务器上的自定义事件封装。</p><p>OnRep_Time函数</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809230207.png"></p><p>Client Widget的蓝图</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809230210.png"></p><p>这里使用的是Editable Text并添加了一个On Text Commited事件，这个事件在输入完成后按下Enter键触发。</p><p>然后我们跑起来看一下效果，为了方便起见，这里我就直接使用Listen Server模式来运行了</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809230214.gif"> </p><h2 id="1-复杂属性的同步"><a href="#1-复杂属性的同步" class="headerlink" title="1.复杂属性的同步"></a>1.复杂属性的同步</h2><p>按理来说，将属性的Replication设置为Replicated或RepNotify，然后在服务器上修改属性值，属性就应该由服务器广播到所有客户端同步，然而我在测试同步一个UObject类作为Actor的属性时，发现仅仅通过上面的步骤无法在所有的客户端同步这个属性。如果将修改操作封装在一个Run on Server事件中，那么只有服务器中对应的Actor的值被修改了却没有同步到其他的客户端，如果将修改操作封装在一个Multicast事件中，则只有在服务器中做的修改才会被同步。我这里通过两层封装解决了这个问题，至于这个问题具体是什么原因造成的，暂时还没弄明白。</p><p>具体迭代步骤：</p><p>创建一个继承至UObject的类—BallData用于存储自定义Pawn—Ball的数据。</p><p>在BallData中创建一个FString类型的数组—SpeekStr，初始化三组数据，并设置Replication为Replicated。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809235321.png"></p><p>在Ball中创建一个BallData类型的变量，设置Replication为Replicated。</p><p>在Ball中增加如下蓝图</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809235324.png"></p><p>我在BeginPlay中构建BallData对象，并启动每3秒读取一次数组值的循环事件。</p><p>这里我们要同步的是BallData类型变量Data中的SpeekStr数组，对数组的元素增加操作我使用两成封装，第一层直接将操作封装在一个Multicast事件中，然后将Multicast事件封装在一个Run on Server事件中，这样MultiSpeek将运行在服务器中，然后再有服务器调用广播事件AddSpeek，将对数组的元素增加操作广播到所有的客户端中。</p><p>执行效果</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809235352.gif"></p><h1 id="五、C-中的网络同步"><a href="#五、C-中的网络同步" class="headerlink" title="五、C++中的网络同步"></a>五、C++中的网络同步</h1><p>C++的网络同步在函数层面主要就是UFUNCTION宏的三个参数Server、Client和NetMulticast，而在变量层面主要UPROPERTY宏的参数Replicated。</p><p>一般情况下我们的网络同步都是在Actor中进行，这里我直接深一个层次，在继承自UObject的UActorComponent组件中来进行网络同步。其实大部分操作和Actor基本是一样的，只有一小部分的区别。</p><p>这里我创建一个继承自UActorComponent的组件UChatComponent，并把ChatComponent组件添加到Ball身上。</p><p>然后我这里先上一份源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//ChatComponent.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Components/TextRenderComponent.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Blueprint/UserWidget.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Components/ActorComponent.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ChatComponent.generated.h&quot;</span></span><br><br><br>UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LSPTETRISCLIENT_API</span> <span class="hljs-title">UChatComponent</span> :</span> <span class="hljs-keyword">public</span> UActorComponent<br>&#123;<br>GENERATED_BODY()<br><br><span class="hljs-keyword">public</span>:<br>UChatComponent();<br>UPROPERTY(Replicated)<br><span class="hljs-keyword">int</span> cubeCount = <span class="hljs-number">0</span>;<br>UPROPERTY(ReplicatedUsing = OnRep_cubeCountTotal, EditAnywhere, BlueprintReadWrite)<br><span class="hljs-keyword">int</span> cubeCountTotal = <span class="hljs-number">20</span>;<br>UPROPERTY(EditAnywhere,BlueprintReadWrite)<br>FColor TextColor = FColor(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">private</span>:<br>APlayerController* playerPtr;<br>UClass* Cube;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TickComponent</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)</span> <span class="hljs-keyword">override</span></span>;<br><br>UFUNCTION(Server,Reliable)<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SpwanCube</span><span class="hljs-params">()</span></span>;<br>UFUNCTION(Client,Reliable,BlueprintCallable)<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SwitchTextRenderColor</span><span class="hljs-params">()</span></span>;<br>UFUNCTION(NetMulticast, Reliable)<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">NetMulticastSetTextRenderColor</span><span class="hljs-params">(UTextRenderComponent* textRender)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GetLifetimeReplicatedProps</span><span class="hljs-params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span></span>;<br>    UFUNCTION()<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRep_cubeCountTotal</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//ChatComponent.cpp</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Replication/ChatComponent.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;InputCoreTypes.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Net/UnrealNetwork.h&quot;</span></span><br><br>UChatComponent::UChatComponent()<br>&#123;<br>PrimaryComponentTick.bCanEverTick = <span class="hljs-literal">true</span>;<br>SetIsReplicated(<span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UChatComponent::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br>playerPtr = GetWorld()-&gt;GetFirstPlayerController();<br>Cube = LoadClass&lt;AActor&gt;(<span class="hljs-literal">NULL</span>, TEXT(<span class="hljs-string">&quot;Blueprint&#x27;/Game/Map/Cube.Cube_C&#x27;&quot;</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UChatComponent::TickComponent</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)</span></span><br><span class="hljs-function"></span>&#123;<br>Super::TickComponent(DeltaTime, TickType, ThisTickFunction);<br><br><span class="hljs-keyword">if</span> (playerPtr-&gt;IsInputKeyDown(EKeys::LeftMouseButton))<br>&#123;<br>SpwanCube();<br>&#125;<br>SwitchTextRenderColor();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UChatComponent::SwitchTextRenderColor_Implementation</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (GetWorld()-&gt;IsServer())<br>&#123;<br><span class="hljs-keyword">if</span> (cubeCount &gt;= cubeCountTotal)<br>&#123;<br>cubeCount = <span class="hljs-number">0</span>;<br>TArray&lt;UTextRenderComponent*&gt; comps;<br>GetOwner()-&gt;GetComponents(comps);<br><span class="hljs-keyword">if</span> (comps.Num() != <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>UTextRenderComponent* textRender = comps[<span class="hljs-number">0</span>];<br>NetMulticastSetTextRenderColor(textRender);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UChatComponent::SpwanCube_Implementation</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (Cube &amp;&amp; GetWorld())<br>&#123;<br>GetWorld()-&gt;SpawnActor&lt;AActor&gt;(Cube, GetOwner()-&gt;GetActorTransform());<br>cubeCount++;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UChatComponent::NetMulticastSetTextRenderColor_Implementation</span><span class="hljs-params">(UTextRenderComponent* textRender)</span></span><br><span class="hljs-function"></span>&#123;<br>textRender-&gt;SetTextRenderColor(TextColor);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UChatComponent::GetLifetimeReplicatedProps</span><span class="hljs-params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function"></span>&#123;<br>Super::GetLifetimeReplicatedProps(OutLifetimeProps);<br>DOREPLIFETIME(UChatComponent, cubeCount);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UChatComponent::OnRep_cubeCountTotal</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (cubeCountTotal &gt;= <span class="hljs-number">40</span>)<br>&#123;<br>FString msg = FString::FromInt(cubeCountTotal);<br>GEngine-&gt;AddOnScreenDebugMessage(<span class="hljs-number">-1</span>, <span class="hljs-number">5</span>, FColor::Red, *msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面我们一行一行的来解析</p><h2 id="1-UNFUNCTION-Server-Reliable"><a href="#1-UNFUNCTION-Server-Reliable" class="headerlink" title="1.UNFUNCTION(Server, Reliable)"></a>1.UNFUNCTION(Server, Reliable)</h2><p>Server表示这个函数在客户端调用在服务器执行，和前面的Run on Server蓝图事件对应。</p><h2 id="2-UFUNCTION-Client-Reliable"><a href="#2-UFUNCTION-Client-Reliable" class="headerlink" title="2.UFUNCTION(Client, Reliable)"></a>2.UFUNCTION(Client, Reliable)</h2><p>Client表示这个函数在服务器调用在拥有这个Actor或UObject的客户端执行，函数执行的结果只在执行函数的客户端显示，不会同步到其他的客户端，和前面的Run on owning Client蓝图事件对应。</p><h2 id="3-UFUNCTION-NetMulticast-Reliable"><a href="#3-UFUNCTION-NetMulticast-Reliable" class="headerlink" title="3.UFUNCTION(NetMulticast, Reliable)"></a>3.UFUNCTION(NetMulticast, Reliable)</h2><p>NetMulticast表示这个函数在服务器调用并在服务器和所有与服务器连接并拥有这个Actor或Object的客户端上执行，和前面的Multicast蓝图事件对应。</p><h2 id="4-Reliable"><a href="#4-Reliable" class="headerlink" title="4.Reliable"></a>4.Reliable</h2><p>Server，Client和Multicast都需要搭配Reliable使用，否则编译无法通过，Reliable表示函数可以在网络空间进行复制，并会忽略带宽或网络错误而被确保送达，这保证了RPC的安全性。</p><h2 id="5-RPC函数的实现"><a href="#5-RPC函数的实现" class="headerlink" title="5.RPC函数的实现"></a>5.RPC函数的实现</h2><p>当一个函数被标识了Server，Client或Multicast宏后，函数的实现就和普通函数不一样了，函数实现的函数名和函数定义的函数名发生了变化，函数实现的函数名需要加一个<code>_Implementation</code>后缀，否则编译会报错。</p><h2 id="6-重写GetLifetimeReplicatedProps函数"><a href="#6-重写GetLifetimeReplicatedProps函数" class="headerlink" title="6.重写GetLifetimeReplicatedProps函数"></a>6.重写GetLifetimeReplicatedProps函数</h2><p>在UE5中，Actor是默认拥有网络同步能力的，但是UObject没有默认拥有网络同步，所以如果我们不重写GetLifetimeReplicatedProps函数，尽管成员函数标识了Server，Client或NetMulticast宏，UObject也依旧不具备网络同步的能力。</p><h2 id="7-DOREPLIFETIME"><a href="#7-DOREPLIFETIME" class="headerlink" title="7.DOREPLIFETIME"></a>7.DOREPLIFETIME</h2><p>除了<code>DOREPLIFETIME</code>宏UE5还有一个<code>DOREPLIFETIME_CONDITION</code>宏，二者的实机作用都是一样的，都是用于注册属性的条件复制的，当我们类里的变量</p><p>这里我在BeginPlay里加载了一个在前面第三节创建的Cube蓝图类，然后在SpawnCube函数中实现Cube的创建过程，这样Cube的创建过程就跑在了服务器上，而Cube勾选了Replicated，这样Cube的创建过程就可以通过服务器同步到所有的客户端中了。</p><p>然后我在SwitchTextRenderColor函数中修改Ball下面的UTextRenderComponent组件的字体颜色。由于SwitchTextRenderColor是在服务器调用在客户端执行，所以函数里面使用了<code>GetWorld()-&gt;IsServer()</code>来判断执行端是否是服务器，如果不做判断的话，函数会在服务器上调用但是却会在所有拥有UChatComponent组件的Ball上执行，而我要的效果是当服务器中Ball发射了超过20个Cube时只修改服务器上的Ball的Textrender的字体颜色，并把这个效果同步到其他客户端中对应的Ball上。</p><p>所以我在SwitchTextRenderColor中有调用了一个NetMulticast函数NetMulticastSetTextRenderColor以将这个执行结果的变化同步到其他的客户端中。</p><p>我们来看一下效果</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811223042.gif"></p><p>可以看到只有在服务器中Ball执行的时候颜色才会发生变化，并将变化同步到了所有的客户算中。</p><p>这里在UI里加了一个可以更改cubeCountTotal值的蓝图，和颜色修改后自动恢复过来的蓝图，蓝图比较简单就不贴出来了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【UE4】UE4在网页里展示虚拟形象</title>
    <link href="/2021/08/05/%E3%80%90UE4%E3%80%91UE4%E5%9C%A8%E7%BD%91%E9%A1%B5%E9%87%8C%E5%B1%95%E7%A4%BA%E8%99%9A%E6%8B%9F%E5%BD%A2%E8%B1%A1/"/>
    <url>/2021/08/05/%E3%80%90UE4%E3%80%91UE4%E5%9C%A8%E7%BD%91%E9%A1%B5%E9%87%8C%E5%B1%95%E7%A4%BA%E8%99%9A%E6%8B%9F%E5%BD%A2%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>参考博客：<a href="https://zhuanlan.zhihu.com/p/235547851">吾爱豆</a></p><a id="more"></a><h1 id="一、通过UMG来展示角色"><a href="#一、通过UMG来展示角色" class="headerlink" title="一、通过UMG来展示角色"></a>一、通过UMG来展示角色</h1><p>在UE4中使用UMG来展示角色的原理主要通过UE4提供的一个<code>SceneCapture2D</code>相机来捕捉场景中的画面，搭配<code>Render Target</code>将捕捉到的画面显示到贴图上，然后将贴图制作成材质，将材质运用到UMG中就可以了，当然也不一定非得要将贴图制作成材质再给UMG使用，贴图也是可以直接给UMG使用的，只是我们后面还需要在材质里对贴图做一些处理，所以这里就直接把贴图做成材质了。</p><p>首先像场景中添加一个SceneCapture2D，并把它位置设置到角色前，设置到自己想要的效果就行了。</p><p>然后再创建一个Render Target，在SceneCapture2D的Details/Scene Capture/Texture Target下把目标贴图设置成我们新建的Render Target，这样Render Target就可以接收到SceneCapture2D捕捉到的画面了。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210805215100.png"></p><p>然后创建一个Material，双击打开材质界面，把材质的Matrial Domain设置成User Interface，把Blend Mode设置成Translucent，Translucent是后面过滤背景用的，现在先设置好。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210805215107.png"></p><p>把RenderTarget直接拖进材质界面，会自动生成一个Texture Sample节点，然后把节点连接到材质。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210805215111.png"></p><p>然后我们需要创建一个UMG来展示角色，创建一个UserWidget，添加一个Image用于展示角色。把Image的Brush/Image设置成我们创建的材质，于是人物就出来了。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210805215115.png"></p><p>运行出来的效果就是这样的</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210805215119.gif"></p><p>这里我给人物加了一点动画。</p><h1 id="二、过滤不需要的背景"><a href="#二、过滤不需要的背景" class="headerlink" title="二、过滤不需要的背景"></a>二、过滤不需要的背景</h1><p>从上面的运行结果可以看到，效果还是不错的，只是我想要角色，而不想要地板和天空球，怎么办呢？</p><p>SceneCapture2D提供了一种渲染模式Use ShowOnly List，意思是只渲染我们添加到列表里的Actor，我们把SceneCapture2D的Scene Capture/Primitive Render Mode换成Use ShowOnly List模式，然后再Show Only Actors下添加我们要显示的角色，这里Capture Source要设置成SceneColor(HDR) in RGB，Inv Opacity in A，in A表示颜色模式是带透明度的，这个设置是过滤背景的关键，没有透明度信息的话，就没办法过滤背景了。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210805215123.png"></p><p>到这一步我们运行场景的话，效果就是这样的。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210805215127.png"></p><p>可以看到Image上已经没有显示Palne和天空了，但是不渲染的部分都是黑色的，怎么办呢？这就需要用的材质了，打开我们之前创建的Material，添加一个OneMinus节点，设置到透明度上。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210805215131.png"></p><p>然后我们再运行，效果是这样的。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210805215135.png"></p><p>可以看到Image中出人物的部分已经完全变透明了。</p><h1 id="三、设置网页图层"><a href="#三、设置网页图层" class="headerlink" title="三、设置网页图层"></a>三、设置网页图层</h1><p>既然小已经达成了，我们就可以把人物嵌入到网页里了。</p><p>这里我们需要自定义一个WebBrowser控件，具体的操作可以看我的<a href="https://goulandis.github.io/2021/05/14/%E3%80%90UE4%E3%80%91UE4%E5%86%85%E5%B5%8CWeb%E5%8F%8A%E4%B8%8EWeb%E9%80%9A%E4%BF%A1/">另一篇博文</a>。</p><p>做好之后，就可以直接Palette里搜索到我们自定的WebBrowser了，拖两个到UMG中，然后在蓝图中分别给两个WebBrowser加载两个网页。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210805215139.png"></p><p>现在运行，网页会把我们的角色给遮挡住，我们要的效果是角色夹在两个网页之间，这就需要我们自己手动调整三个图层的前后位置了。</p><p>只需要把显示角色Image的Slot/ZOrder的值设置在两个WebBrowser之间就可以了，这个值默认为0，值越大表示图层越高，高图层会覆盖低图层。</p><p>然后我们看一下效果。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210805215142.gif"></p><p>然后具体角色想要在网页上达到什么效果就自己灵活调整了。如果觉得角色太暗，可以在场景中为角色打个灯光。</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE4】UE4实现自定义框选</title>
    <link href="/2021/05/14/%E3%80%90UE4%E3%80%91UE4%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A1%86%E9%80%89/"/>
    <url>/2021/05/14/%E3%80%90UE4%E3%80%91UE4%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A1%86%E9%80%89/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>要在UE4中实现自定义框选功能，首先我们来分析一下顶顶一框选插件需要些什么模块？</p><ul><li>绘制模块</li><li>显示模块</li><li>计算模块</li></ul><p>嗯，大概分这么三个模块，好，现在我们一个个模块来分析实现。首先分析实现一下显示模块。</p><a id="more"></a><p><font color="green">提示：</font></p><p><font color="green">如果功能需要打包成插件，请先浏览第四章</font></p><h1 id="一、显示模块"><a href="#一、显示模块" class="headerlink" title="一、显示模块"></a>一、显示模块</h1><p>首先我们需要做一些准备</p><h2 id="1-创建Wedgit作为显示载体"><a href="#1-创建Wedgit作为显示载体" class="headerlink" title="1.创建Wedgit作为显示载体"></a>1.创建Wedgit作为显示载体</h2><p>UE4绘制直线的方式很多，这里我使用DrawLine在RenderTarget里绘制，绘制的实现放在后面说。</p><p>然后我们需要让自定义框选的线显示在屏幕上，那么使用<code>wedgit</code>来显示是比较理想的，所以我们来创建一个widget，命名为<code>CustomSelectUI</code>，并为CustomSelectUI添加一个<code>image</code>作为显示的载体，命名为Background。</p><h2 id="2-创建Material作为RenderTarget的显示载体"><a href="#2-创建Material作为RenderTarget的显示载体" class="headerlink" title="2.创建Material作为RenderTarget的显示载体"></a>2.创建Material作为RenderTarget的显示载体</h2><p>光一个image也是无法显示我们绘制的线的，因为我们的线是画在RenderTarget里的，而image没法直接使用RenderTarget，所以我们还需要创建一个Material来承载RenderTarget。这里创建一个Material命名为Mat_Paint。</p><h2 id="3-为Material创建一个Texture"><a href="#3-为Material创建一个Texture" class="headerlink" title="3.为Material创建一个Texture"></a>3.为Material创建一个Texture</h2><p>创建的Texture是有讲究的，Texture必须是存黑色的即RPG(0,0,0)，然后分辨率可自定义。这里我使用PS制作了一个纯黑的PNG图片，并设置分辨率为2048x2048，并导入到UE4生成Texture，并命名为Mat_Transparent_Max。<br><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180719.png" alt="在这里插入图片描述"></p><p>使用纯黑色的原因在第四小节说明。</p><h2 id="4-实现Material的作用"><a href="#4-实现Material的作用" class="headerlink" title="4.实现Material的作用"></a>4.实现Material的作用</h2><p>Material出来作为RenerTarget的载体外，还有设置笔刷的颜色，以及使背景透明的作用。</p><p>先来看一下Mat_Paint的蓝图</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180725.png" alt="在这里插入图片描述"></p><p>首先将Mat_Paint节点的<code>Details/Material/Material Domain</code>更换为User Interface，即将Material改为Material Interface。</p><p>并未Mat_Paint添加一个Texture，将之前创建的Mat_Transparent_Max拖入Mat_Paint中，右键节点选择Convert to Parameter将节点参数化，并取名<code>RT_Texture</code>，这是为了后面动态设置做的准备。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180731.png" alt="在这里插入图片描述"></p><p>然后将RT_Texture连接到Mat_Paint中的Opacity上，Opacity节点是Material控制材质透明度的接口，在Opacity中RGB(0,0,0)表示全透明，RGB(1,1,1)表示不透明，即纯黑色表示全透明，纯白色表示不透明，这就是为什么我们需要一张纯黑色的Texture的原因。因为我们需要一个透明的材质赋予image这样我们才能看到Wedgit后面的场景，使场景不会被我们的image遮挡。</p><p>然后创建一个Constant3Vector，并且也将其参数化，命名为PaintColor，这为之后修改画笔颜色预留接口。将PaintColor连接到Mat_Paint的Final Color上。Final Color接口控制着材质最终显示的颜色。</p><p>到这里，擦材质我们就做好了。</p><h2 id="5-显示"><a href="#5-显示" class="headerlink" title="5.显示"></a>5.显示</h2><p>这里我在CustomSelectUI构造时为Background添加Mat_Paint动态材质。我们来看一下蓝图</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180738.png" alt="在这里插入图片描述"></p><ul><li>RenderMat变量是Material Instance Dynamic类型用于存储动态创建的Mat_Paint，方便之后使用；</li><li>LineLinearColor变量是LinearColor类型，用于设置画笔颜色</li></ul><p>到这里显示部分就完成了。</p><h1 id="二、绘制模块"><a href="#二、绘制模块" class="headerlink" title="二、绘制模块"></a>二、绘制模块</h1><h2 id="1-获取鼠标在屏幕中的位置坐标"><a href="#1-获取鼠标在屏幕中的位置坐标" class="headerlink" title="1.获取鼠标在屏幕中的位置坐标"></a>1.获取鼠标在屏幕中的位置坐标</h2><p>线的绘制我使用DrawLine函数根据鼠标点击的点来绘制点与点之间的直线，绘制模块最终要的两个步骤就是获取鼠标点击的屏幕上的点和根据点集绘制多边形。</p><p>实现获取鼠标在屏幕上的位置，这里我们需要重写两个函数，OnMouseButtonUp和OnMouseButtonDown,我们来看一下蓝图。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180748.png" alt="在这里插入图片描述"></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180754.png" alt="在这里插入图片描述"></p><ul><li><p>MouseDown用于标识鼠标的按下与抬起，true表示按下，false表示抬起。</p></li><li><p>Setup控制是否开始绘制。</p></li><li><p>IsFirstPoint标识第一个点与其余点。</p></li><li><p>PolygonPoints是存储鼠标点击的点的数组，启动绘制之后鼠标每点击一次变向数组中添加一个Vector2D元素。</p></li><li><p>CurrentPoint存储鼠标当前点击的屏幕坐标。</p></li><li><p>StartPoint存储绘制直线的起点的屏幕坐标。</p></li><li><p>MousePositionAdaptDPI是自己封装的获取鼠标屏幕坐标的函数，之所以封装是为例修改方便。</p></li></ul><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180801.png" alt="在这里插入图片描述"></p><p>到此，获取鼠标的屏幕坐标就实现了，接下来要根据鼠标点击确定的点集PolygonPoints绘制直线。</p><h2 id="2-绘制直线"><a href="#2-绘制直线" class="headerlink" title="2.绘制直线"></a>2.绘制直线</h2><p>再绘制直线之前，需要做一些准备工作，即创建直线绘制的载体RenderTarget并用之前创建好的RenderMat承载，然后将RenderMat绑定到Background上显示。这里我绑定到Setup按钮的OnClicked事件下。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180807.png" alt="在这里插入图片描述"></p><ul><li><p>CreateCanvasRenderTarget2D函数负责创建RenderTarget，RenderTarget可以直接使用引擎默认的，也可以自己创建自定义的，这里我使用引擎默认的。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180812.png" alt="在这里插入图片描述"></p><p>Width和Height控制着RenderTarget的长宽比例，超出这个比例的部分屏幕将无法绘制，如：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180820.png" alt="在这里插入图片描述"></p><p>红框部分的屏幕比例就是1920：1080，超出着部分的屏幕将无法绘制，当然在全屏运行的情况下不会出现这种问题。出现这个问题是因为我的计算机屏幕尺寸就是1920：1080，运行时，UE4的实际运行窗口是蓝色部分，很明显由于windows菜单栏和UE运行窗口的菜单栏占据了屏幕的部分像素，所以UE的实际运行窗口是蓝色部分，其比例显然不是1920：1080，所以超出部分就没办法绘制了。这个RenderTarget的比例可以根据自己的实际需求更改。</p></li><li><p>SetupCustomSelect函数负责绘制的启动与关闭</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180828.png" alt="在这里插入图片描述"><br>准备工作结束后便可以开始绘制直线了，直线的绘制放在Tick函数下，每帧绘制。</p></li></ul><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180834.png" alt="在这里插入图片描述"></p><ul><li><p>LineThickness控制直线绘制时的粗细程度。</p></li><li><p>StartPaint是具体的直线绘制函数。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180840.png" alt="在这里插入图片描述"></p><p>其中RenderColor必须设置纯白色，只有这样绘制出来的直线才是不透明的。</p></li></ul><p><font color="red">绘制直线这里有一点需要注意，即需要设置我们Background的锚点为左上角，因为RenderTarget的原点在左上角，只有这样鼠标点击的位置才会和绘制的位置匹配，否则会出现位置偏移的问题。</font></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180848.png" alt="在这里插入图片描述"></p><h2 id="3-清除绘制内容"><a href="#3-清除绘制内容" class="headerlink" title="3.清除绘制内容"></a>3.清除绘制内容</h2><p>考虑到会有绘制出错的情况，所以添加一个清除绘制内容的功能。清除绘制内容原理比较简单，只需要清除RenderTarget缓存和PolygonPoints点击即可。</p><p>这里我绑定在Delete按钮的OnClicked事件下。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180854.png" alt="在这里插入图片描述"></p><h2 id="4-结束绘制"><a href="#4-结束绘制" class="headerlink" title="4.结束绘制"></a>4.结束绘制</h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180859.png" alt="在这里插入图片描述"></p><p>结束绘制之后就要开始计算框选内容了，SureSelect函数负责这方面的实现，计算后面讲解。</p><p>结束绘制之后需要将最后一个点和第一个点连接来，确保多边形是一个封闭的多边形。EndPaint函数负责这个功能的实现。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180904.png" alt="在这里插入图片描述"></p><h1 id="三、计算"><a href="#三、计算" class="headerlink" title="三、计算"></a>三、计算</h1><p>计算这里需要用到C++了，在蓝图的SureSelect函数里调用C++的计算函数。</p><p>创建一个继承自Actor的C++类，并命名为CustomSelectActor，下面贴出C++源码：</p><p><code>.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LeastPointNum 4</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ActorSamplingPoints 9</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Runtime/Engine/Classes/Kismet/GameplayStatics.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Engine/World.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;GameFramework/Actor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;EngineUtils.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;GameFramework/PlayerController.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;GameFramework/Actor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CustomSelectActor.generated.h&quot;</span></span><br><br>USTRUCT()<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FBoxPointSet</span></span><br><span class="hljs-class">&#123;</span><br>GENERATED_USTRUCT_BODY()<br><span class="hljs-keyword">public</span>:<br>TArray&lt;FVector2D&gt; points;<br>FBoxPointSet()<br>&#123;<br>points.Init(FVector2D(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">9</span>);<br>&#125;<br>&#125;;<br><br>UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CUSTOMSELECT_API</span> <span class="hljs-title">ACustomSelectActor</span> :</span> <span class="hljs-keyword">public</span> AActor<br>&#123;<br>GENERATED_BODY()<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">const</span> FVector BoundsPointMapping[<span class="hljs-number">8</span>] =<br>&#123;<br>FVector(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<br>FVector(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>),<br>FVector(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>),<br>FVector(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>),<br>FVector(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<br>FVector(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>),<br>FVector(<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>),<br>FVector(<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>)<br>&#125;;<br><br><span class="hljs-keyword">protected</span>:<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-keyword">public</span>:<br>ACustomSelectActor();<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Tick</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime)</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GetMax</span><span class="hljs-params">(TArray&lt;FVector2D&gt;&amp; points, <span class="hljs-keyword">float</span>&amp; max_x, <span class="hljs-keyword">float</span>&amp; max_y, <span class="hljs-keyword">int</span>&amp; len)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GetMin</span><span class="hljs-params">(TArray&lt;FVector2D&gt;&amp; points, <span class="hljs-keyword">float</span>&amp; min_x, <span class="hljs-keyword">float</span>&amp; min_y, <span class="hljs-keyword">int</span>&amp; len)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SpwanVertArr</span><span class="hljs-params">(TArray&lt;FVector2D&gt;&amp; polygonPoints, TArray&lt;<span class="hljs-keyword">float</span>&gt;&amp; vertx, TArray&lt;<span class="hljs-keyword">float</span>&gt;&amp; verty, <span class="hljs-keyword">int</span>&amp; len)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">PNPoly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nvert, TArray&lt;<span class="hljs-keyword">float</span>&gt; vertx, TArray&lt;<span class="hljs-keyword">float</span>&gt; verty, <span class="hljs-keyword">float</span> testx, <span class="hljs-keyword">float</span> testy)</span></span>;<br>UFUNCTION(BlueprintImplementableEvent)<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ProjectWorldLocationToWidgetPosition</span><span class="hljs-params">(APlayerController* player_ctrl, FVector worldLocation, FVector2D&amp; screenPosition)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GetFBoxPointsSet</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;FBoxPointSet&gt;&amp; fboxPointsArr,</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;AActor*&gt;&amp; actorArr,</span></span><br><span class="hljs-function"><span class="hljs-params">TSubclassOf&lt;AActor&gt;&amp; classFilter,</span></span><br><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span>&amp; bIncludeNonCollidingComponents,</span></span><br><span class="hljs-function"><span class="hljs-params">APlayerController* player_ctrl)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GetActorsRefByPointsSet</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;AActor*&gt;&amp; outActors,</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;<span class="hljs-keyword">float</span>&gt;&amp; vertx,</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;<span class="hljs-keyword">float</span>&gt;&amp; verty,</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;FBoxPointSet&gt;&amp; fboxPointsArr,</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;AActor*&gt;&amp; actorArr,</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;FVector2D&gt;&amp; polygonPoints,</span></span><br><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span>&amp; len)</span></span>;<br>UFUNCTION(BlueprintCallable, Category = <span class="hljs-string">&quot;CustomSelect&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CustomSelect</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;AActor*&gt;&amp; outActors,</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;FVector2D&gt; polygonPoints,</span></span><br><span class="hljs-function"><span class="hljs-params">TSubclassOf&lt;AActor&gt; classFilter,</span></span><br><span class="hljs-function"><span class="hljs-params">APlayerController * player_ctrl,</span></span><br><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span> bIncludeNonCollidingComponents)</span></span>;<br>UFUNCTION(BlueprintCallable, Category = <span class="hljs-string">&quot;CustomSelect&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">CompuePolygonArea</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TArray&lt;FVector2D&gt; polygonPoints)</span></span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p><code>.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CustomSelectActor.h&quot;</span></span><br><br>ACustomSelectActor::ACustomSelectActor()<br>&#123;<br>PrimaryActorTick.bCanEverTick = <span class="hljs-literal">false</span>;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ACustomSelectActor::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ACustomSelectActor::Tick</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime)</span></span><br><span class="hljs-function"></span>&#123;<br>Super::Tick(DeltaTime);<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ACustomSelectActor::GetMax</span><span class="hljs-params">(TArray&lt;FVector2D&gt;&amp; points, <span class="hljs-keyword">float</span>&amp; max_x, <span class="hljs-keyword">float</span>&amp; max_y, <span class="hljs-keyword">int</span>&amp; len)</span></span><br><span class="hljs-function"></span>&#123;<br>max_x = points[<span class="hljs-number">0</span>].X;<br>max_y = points[<span class="hljs-number">0</span>].Y;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (max_x &lt; points[i].X)<br>&#123;<br>max_x = points[i].X;<br>&#125;<br><span class="hljs-keyword">if</span> (max_y &lt; points[i].Y)<br>&#123;<br>max_y = points[i].Y;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ACustomSelectActor::GetMin</span><span class="hljs-params">(TArray&lt;FVector2D&gt;&amp; points, <span class="hljs-keyword">float</span>&amp; min_x, <span class="hljs-keyword">float</span>&amp; min_y, <span class="hljs-keyword">int</span>&amp; len)</span></span><br><span class="hljs-function"></span>&#123;<br>min_x = points[<span class="hljs-number">0</span>].X;<br>min_y = points[<span class="hljs-number">0</span>].Y;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (min_x &gt; points[i].X)<br>&#123;<br>min_x = points[i].X;<br>&#125;<br><span class="hljs-keyword">if</span> (min_y &gt; points[i].Y)<br>&#123;<br>min_y = points[i].Y;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ACustomSelectActor::SpwanVertArr</span><span class="hljs-params">(TArray&lt;FVector2D&gt;&amp; polygonPoints, TArray&lt;<span class="hljs-keyword">float</span>&gt;&amp; vertx, TArray&lt;<span class="hljs-keyword">float</span>&gt;&amp; verty, <span class="hljs-keyword">int</span>&amp; len)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br>vertx.Add(polygonPoints[i].X);<br>verty.Add(polygonPoints[i].Y);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ACustomSelectActor::PNPoly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nvert, TArray&lt;<span class="hljs-keyword">float</span>&gt; vertx, TArray&lt;<span class="hljs-keyword">float</span>&gt; verty, <span class="hljs-keyword">float</span> testx, <span class="hljs-keyword">float</span> testy)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">bool</span> ret = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = nvert - <span class="hljs-number">1</span>; i &lt; nvert; j = i++)<br>&#123;<br><span class="hljs-keyword">if</span> (((verty[i] &gt; testy) != (verty[j] &gt; testy)) &amp;&amp; (testx &lt; (vertx[j] - vertx[i]) * (testy - verty[i]) / (verty[j] - verty[i]) + vertx[i]))<br>&#123;<br>ret = !ret;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ACustomSelectActor::GetFBoxPointsSet</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;FBoxPointSet&gt;&amp; fboxPointsArr,</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;AActor*&gt;&amp; actorArr,</span></span><br><span class="hljs-function"><span class="hljs-params">TSubclassOf&lt;AActor&gt;&amp; classFilter,</span></span><br><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span>&amp; bIncludeNonCollidingComponents,</span></span><br><span class="hljs-function"><span class="hljs-params">APlayerController * player_ctrl)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (TActorIterator&lt;AActor&gt; Itr(GWorld-&gt;GetWorld(), classFilter); Itr; ++Itr)<br>&#123;<br>AActor* EachActor = *Itr;<br><span class="hljs-keyword">const</span> FBox EachActorBounds = Cast&lt;AActor&gt;(EachActor)-&gt;GetComponentsBoundingBox(bIncludeNonCollidingComponents);<br><span class="hljs-keyword">const</span> FVector BoxCenter = EachActorBounds.GetCenter();<br><span class="hljs-keyword">const</span> FVector BoxExtents = EachActorBounds.GetExtent();<br><span class="hljs-function">FBox2D <span class="hljs-title">ActorBox2D</span><span class="hljs-params">(ForceInit)</span></span>;<br>fboxPointsArr.Add(FBoxPointSet());<br><span class="hljs-keyword">for</span> (uint8 BoundsPointItr = <span class="hljs-number">0</span>; BoundsPointItr &lt; <span class="hljs-number">8</span>; BoundsPointItr++)<br>&#123;<br>FVector2D ScreenPos;<br><span class="hljs-keyword">if</span> (ProjectWorldLocationToWidgetPosition(player_ctrl, BoxCenter + (BoundsPointMapping[BoundsPointItr] * BoxExtents), ScreenPos))<br>&#123;<br>ActorBox2D += ScreenPos;<br>fboxPointsArr[i].points[BoundsPointItr + <span class="hljs-number">1</span>] = ScreenPos;<br>&#125;<br>&#125;<br>fboxPointsArr[i].points[<span class="hljs-number">0</span>] = ActorBox2D.GetCenter();<br>actorArr.Add(EachActor);<br>i++;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ACustomSelectActor::GetActorsRefByPointsSet</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;AActor*&gt;&amp; outActors,</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;<span class="hljs-keyword">float</span>&gt;&amp; vertx,</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;<span class="hljs-keyword">float</span>&gt;&amp; verty,</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;FBoxPointSet&gt;&amp; fboxPointsArr,</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;AActor*&gt;&amp; actorArr,</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;FVector2D&gt;&amp; polygonPoints,</span></span><br><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span>&amp; len)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> fboxlen = fboxPointsArr.Num();<br><span class="hljs-keyword">int</span> pointslen = polygonPoints.Num();<br><span class="hljs-keyword">float</span> max_x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">float</span> max_y = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">float</span> min_x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">float</span> min_y = <span class="hljs-number">0</span>;<br>GetMax(polygonPoints, max_x, max_y, len);<br>GetMin(polygonPoints, min_x, min_y, len);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; fboxlen; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; ActorSamplingPoints; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (fboxPointsArr[i].points[j].X&lt;min_x || fboxPointsArr[i].points[j].X&gt;max_x ||<br>fboxPointsArr[i].points[j].Y&lt;min_y || fboxPointsArr[i].points[j].Y&gt;max_y)<br>&#123;<br><span class="hljs-keyword">break</span>;<br>j = ActorSamplingPoints;<br>&#125;<br><span class="hljs-keyword">if</span> (PNPoly(len, vertx, verty, fboxPointsArr[i].points[j].X, fboxPointsArr[i].points[j].Y))<br>&#123;<br>outActors.Add(actorArr[i]);<br>j = ActorSamplingPoints;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ACustomSelectActor::CustomSelect</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;AActor*&gt;&amp; outActors,</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;FVector2D&gt; polygonPoints,</span></span><br><span class="hljs-function"><span class="hljs-params">TSubclassOf&lt;AActor&gt; classFilter,</span></span><br><span class="hljs-function"><span class="hljs-params">APlayerController * player_ctrl,</span></span><br><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span> bIncludeNonCollidingComponents)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> len = polygonPoints.Num();<br><span class="hljs-keyword">if</span> (len &lt; LeastPointNum)<br>&#123;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Polygon has too few points&quot;</span>));<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>TArray&lt;<span class="hljs-keyword">float</span>&gt; vertx;<br>TArray&lt;<span class="hljs-keyword">float</span>&gt; verty;<br>SpwanVertArr(polygonPoints, vertx, verty, len);<br>TArray&lt;AActor*&gt; actorArr;<br>TArray&lt;FBoxPointSet&gt; fboxPointsArr;<br>GetFBoxPointsSet(fboxPointsArr, actorArr, classFilter, bIncludeNonCollidingComponents, player_ctrl);<br>GetActorsRefByPointsSet(outActors, vertx, verty, fboxPointsArr, actorArr, polygonPoints, len);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">ACustomSelectActor::CompuePolygonArea</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TArray&lt;FVector2D&gt; polygonPoints)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> point_num = polygonPoints.Num();<br><span class="hljs-keyword">if</span> (point_num &lt; <span class="hljs-number">3</span>)<br>&#123;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;The area is not polygon!&quot;</span>));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<br>&#125;<br><span class="hljs-keyword">double</span> s = polygonPoints[<span class="hljs-number">0</span>].Y * (polygonPoints[point_num - <span class="hljs-number">1</span>].X - polygonPoints[<span class="hljs-number">1</span>].X);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; point_num; ++i)<br>s += polygonPoints[i].Y * (polygonPoints[i - <span class="hljs-number">1</span>].X - polygonPoints[(i + <span class="hljs-number">1</span>) % point_num].X);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">fabs</span>(s / <span class="hljs-number">2.0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p><code>BoundsPointMapping[8]</code>用于确定场景中Actor的边界盒子的8个点。</p></li><li><p>结构体FBoxPointSet是用来存储采样点集的数据结构，这里我取Actor边界盒子的8个点加中点一共9个点作为采样点集。</p></li><li><p>GetMax和GetMin计算多边形点集的横纵坐标的最大值和最小值。</p></li><li><p>SpawnVertArr负责将多边形点集分成横坐标点集和纵坐标点集。</p></li><li><p>PNPoly函数使用PNPoly算法判断一个点是否在多边形内部。</p></li><li><p>ProjectWorldLocationToWidgetPosition函数是一个由C++父类声明，由蓝图子类实现的函数，负责将场景中的Actor的边界盒子的点的空间坐标投影到屏幕坐标。之所以使用这种方式是因为ProjectWorldLocationToWidgetPosition蓝图节点没有C++版本，而必须使用ProjectWorldLocationToWidgetPosition蓝图节点的原因是ProjectWorldLocationToWidgetPosition蓝图节点投影出来的坐标会根据屏幕尺寸变化而自动适应，其他的空间坐标转屏幕坐标的蓝图节点在非全屏与全屏下会出现位置偏移。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180923.png" alt="在这里插入图片描述"><br>所以这里需要创建一个继承自CustomSelectActor的蓝图子类来重写ProjectWorldLocationToWidgetPosition函数。</p></li><li><p>GetFBoxPointsSet函数负责获取世界中所有Actor的采样点集。</p></li><li><p>GetActorsRefByPointsSet函数负责使用PNPoly函数取在多边形内部的Actor的引用。</p></li><li><p>CustomSelect函数否则暴漏给蓝图提供数据输入输出的接口。</p></li><li><p>CompuePolygonArea函数负责计算多边形的面积，目前还有一些问题，暂时不用理睬。</p></li></ul><p>至此多边形框选功能就完全实现了。来看一下效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180929.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180935.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180942.png" alt="在这里插入图片描述"></p><h1 id="四、将功能包成UE4插件"><a href="#四、将功能包成UE4插件" class="headerlink" title="四、将功能包成UE4插件"></a>四、将功能包成UE4插件</h1><p>如果需要将功能打包成插件，那么就需要将CustomSelectActor的C++类创建在插件里。</p><h2 id="1-创建一个空插件"><a href="#1-创建一个空插件" class="headerlink" title="1.创建一个空插件"></a>1.创建一个空插件</h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180952.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180958.png" alt="在这里插入图片描述"></p><p>创建之后需要在VS中编一下项目，然后关闭引擎，重新打开项目，以便引擎重新加载dll文件，因为插件不属于引擎的一部分，所以引擎没办法直接热加载插件内容。</p><h2 id="2-在插件文件夹下创建C-类"><a href="#2-在插件文件夹下创建C-类" class="headerlink" title="2.在插件文件夹下创建C++类"></a>2.在插件文件夹下创建C++类</h2><p>我们需要将CustomSelectActor类创建在插件文件夹下，创建好空插件后，再创建C++类时可以选择创建文件夹。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514181004.png" alt="在这里插入图片描述"><br>然后按一、二、三的步骤实现功能即可。</p><h2 id="3-打包插件"><a href="#3-打包插件" class="headerlink" title="3.打包插件"></a>3.打包插件</h2><p>进入插件管理点集打包</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514181009.png" alt="在这里插入图片描述"><br>至此插件就打包好了。</p><p>参考博客：<br><a href="https://blog.csdn.net/weixin_36369675/article/details/88419361">https://blog.csdn.net/weixin_36369675/article/details/88419361</a><br><a href="https://www.cnblogs.com/anningwang/p/7581545.html">https://www.cnblogs.com/anningwang/p/7581545.html</a><br><a href="https://www.cnblogs.com/TenosDoIt/p/4047211.html">https://www.cnblogs.com/TenosDoIt/p/4047211.html</a></p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE4】基于Spline的测距功能</title>
    <link href="/2021/05/14/%E3%80%90UE4%E3%80%91UE4%E5%9F%BA%E4%BA%8ESpline%E7%9A%84%E6%B5%8B%E8%B7%9D%E5%8A%9F%E8%83%BD/"/>
    <url>/2021/05/14/%E3%80%90UE4%E3%80%91UE4%E5%9F%BA%E4%BA%8ESpline%E7%9A%84%E6%B5%8B%E8%B7%9D%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="基于Spline的测距功能插件"><a href="#基于Spline的测距功能插件" class="headerlink" title="基于Spline的测距功能插件"></a>基于Spline的测距功能插件</h1><a id="more"></a><h1 id="一、功能分析"><a href="#一、功能分析" class="headerlink" title="一、功能分析"></a>一、功能分析</h1><p>这里首先分析一下整个插件的功能部件</p><ul><li><p>SplineActor—基于Spline的线条显示模块</p></li><li><p>Ranging—对整个插件功能的整体控制</p></li><li><p>DistancePanel—距离显示UI</p></li><li><p>Point—线上的点，集成DistancePanel</p></li><li><p>FunLib—高复用函数集合</p><p>资产状况：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174241.png" alt="在这里插入图片描述"></p></li></ul><p>由于使用屏幕坐标转世界坐标的方式实现测距功能可能及其复杂，所以这里使用比较直观简便的三维Spline来实现测距功能。</p><h1 id="二、制作线上的点Point"><a href="#二、制作线上的点Point" class="headerlink" title="二、制作线上的点Point"></a>二、制作线上的点Point</h1><h2 id="1-Point的结构分析"><a href="#1-Point的结构分析" class="headerlink" title="1.Point的结构分析"></a>1.Point的结构分析</h2><p>Point是一个拥有StaticMesh和WedgitComponent组件的Actor，StaticMesh我这里使用Shape，Materials是自己做的一个发光材质。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174247.png" alt="在这里插入图片描述"></p><h2 id="2-MeshMeterial材质"><a href="#2-MeshMeterial材质" class="headerlink" title="2.MeshMeterial材质"></a>2.MeshMeterial材质</h2><p>Materials蓝图：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174258.png" alt="在这里插入图片描述"></p><h2 id="3-Point核心函数实现"><a href="#3-Point核心函数实现" class="headerlink" title="3.Point核心函数实现"></a>3.Point核心函数实现</h2><p>Point主要实现一个函数两个事件</p><ul><li>函数ShowDistance—负责距离显示</li><li>事件InitFontInfo—负责获取初始字体信息</li><li>事件ShowText—控制距离是否显示</li></ul><p>在构造函数需要记录DistancePanel的初始位置信息和初始字体信息。</p><p>ConstructScript：记录DistancePanel的初始位置信息和初始字体信息</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174305.png" alt="在这里插入图片描述"></p><p>InitFontInfo：记录字体的初始信息</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174317.png" alt="在这里插入图片描述"></p><p>ShowText：设置显示字体的大小。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174323.png" alt="在这里插入图片描述"></p><p>Tick函数：SetActorRotation设置点上的文字跟随摄像机旋转使之始终面向摄像机，GetMouseLocation-&gt;SetActorLocation-&gt;ShowText当SureLocation为false时即未确定点的位置时设置点跟随鼠标移动，当点跟随鼠标移动时不显示距离。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174329.png" alt="在这里插入图片描述"></p><ul><li>FontInfo：是一个SlateFontInfoStructure结构体用于设置距离显示的字体样式。</li><li>SureLocation：bool变量，确认点是否已经确定了位置坐标，当点没有确定位置坐标时，点将跟随鼠标移动。</li><li>InitScale3D：Vector变量，保存DistancePanel的初始大小。</li><li>SureAdsorb：bool变量，控制闭环吸附，当为true时，起点具有吸附功能，可以将终点吸附到起点位置实现闭环。</li></ul><p>ShowDistance：将输入的距离信息显示出来。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174336.png" alt="在这里插入图片描述"></p><p>至此点的设计完毕。</p><h1 id="三、用于显示的Widget"><a href="#三、用于显示的Widget" class="headerlink" title="三、用于显示的Widget"></a>三、用于显示的Widget</h1><p>创建一个UserWidget命名为DistancePanel，DistancePanel比较简单，CanvasPanel下就一个Text即可，只有一个函数UpdateTextScale，然后在EventConstruct中记录Text的初始大小。</p><p>EventConstruct：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174342.png" alt="在这里插入图片描述"></p><p>UpdateTextScale：更新Text的大小，使Text跟随摄像机距离地板的远近变大变小，以保证Text的大小在视野中保持不变。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174347.png" alt="在这里插入图片描述"></p><h1 id="三、使用Spline制作线段"><a href="#三、使用Spline制作线段" class="headerlink" title="三、使用Spline制作线段"></a>三、使用Spline制作线段</h1><h2 id="1-SplineActor结构分析"><a href="#1-SplineActor结构分析" class="headerlink" title="1.SplineActor结构分析"></a>1.SplineActor结构分析</h2><p>Spline是UE4的样条线组件，Spline是一组点和线的集合，但是Spline的点和线只有在编辑模式下可见，在运行模式下不可见，Spline可以通过选中其中的点按下Alt键并拖动鼠标来添加新的点。</p><p>我们需要一个Actor作为Spline的载体，创建一个Actor命名为Spline。Spline的组件结构为：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174354.png" alt="在这里插入图片描述"></p><ul><li>StaticMesh：使用Shape和自定义的材质，这个Mesh作为起点使用。</li><li>Spline：样条线组件，此Actor的核心组件。</li><li>Sphere：球型触发器，用于起点吸附。</li></ul><h2 id="2-在编辑模式下实现Spline编辑"><a href="#2-在编辑模式下实现Spline编辑" class="headerlink" title="2.在编辑模式下实现Spline编辑"></a>2.在编辑模式下实现Spline编辑</h2><p>在编辑模式下实现样条线的编辑需要在构造函数中实现下面的逻辑：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174403.png" alt="在这里插入图片描述"></p><p>核心函数分析：</p><ul><li><p>AddSplineMeshComponent：这是一个自定义的封装函数，作用就是提高复用率，</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174410.png" alt="在这里插入图片描述"></p></li></ul><p>  StaticMesh决定线的样式，Meterial决定线的颜色；</p><ul><li><p>AttachToMeshComponent：将添加的SplineMeshComponent组件设置StaticMesh为父节点；</p></li><li><p>Set Start and End：函数根据Get LocationandTangentatSplinePoint函数获取的起点和终点的位置和切角，将生成的SplineMeshComponent组件附着在上面。</p></li></ul><p>这样我们的Spline样条线就被设置成了我们设定的模样，并且在运行时可见。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174417.png" alt="在这里插入图片描述"></p><h2 id="3-运行时动态添加Spline的点"><a href="#3-运行时动态添加Spline的点" class="headerlink" title="3.运行时动态添加Spline的点"></a>3.运行时动态添加Spline的点</h2><p>由于在运行模式下无法像在编辑模式下通过Alt键拖动点来添加Spline的点，所以我们需要通过蓝图来实现。这项功能封装在AddPoint函数中。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174423.png" alt="在这里插入图片描述"></p><p>AddPoint函数通过输入的坐标位置动态生成Spline的点</p><ul><li>AddSplinePoint：向Spline中添加新的点；</li><li>SpawnActorPoint：目的是在Spline的生成的新点的位置处生成一个具象化的Point；</li><li>Sequence的的Then0分支作用是当生成一个新的Point时，确定上一个Point的位置坐标；</li><li>PointArray是一个Point类型的数组，用于存储生成的Point的引用，SplineMeshComponentArray是一个SplineMeshComponent类型的数组，用于存储生成的SplineMeshComponent组件的引用，两个数组的作用是方便之后对Point和SplineMeshComponent的操作。</li><li>AddSplineMeshComponent、AttachToComponent和SetSartandEnd函数作用和构造函数中一样；</li><li>UpddateTotaldistance函数用于更新距离显示，具体实现在后面介绍。</li></ul><p>AddPoint函数在AddPointEvent事件中调用。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174433.png" alt="在这里插入图片描述"></p><ul><li>GetMouseLocation是FunLib库中的一个函数负责获取鼠标坐在的屏幕坐标转换成空间坐标。</li></ul><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174439.png" alt="在这里插入图片描述"></p><h2 id="4-实时更新样条线"><a href="#4-实时更新样条线" class="headerlink" title="4.实时更新样条线"></a>4.实时更新样条线</h2><p>实时更新样条线的功能封装在UpdateCurrentSplinePoint函数中。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174446.png" alt="在这里插入图片描述"></p><p>UpdateCurrentSplinePoint函数在SplineActor的Tick函数中调用，每帧删除前一个Spline的点，在新的坐标位置下添加一个新的Spline的点，由于Point是跟随鼠标移动的，所以通过这个操作在宏观上的表现就是Spline的点在跟随鼠标一点，之所以使用这种方式，是因为Spline中的点似乎没办法直接修改位置。</p><p>每帧设置好位置之后再重新渲染一遍Mesh组件，就达到如下效果了：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174453.gif" alt="在这里插入图片描述"></p><p>这样在运行状态下编辑Spline样条线就制作完成了。</p><h1 id="四、实时更新距离"><a href="#四、实时更新距离" class="headerlink" title="四、实时更新距离"></a>四、实时更新距离</h1><p>实时更新距离的功能封装在UpdateTotalDistance函数下。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174502.png" alt="在这里插入图片描述"></p><ul><li>Ranging变量就是Ranging类型，存储Ranging的引用，在重新计算总距离前先将存储中距离的变量TotalDistance清零；</li><li>然后一次取PointArray中的Point来计算Point与Point之间的距离，0号索引的Point较为特殊需要与其他索引的Point分开计算，因为0号索引的Point需要与SplineActor的位置计算距离；</li><li>ShowDistance函数封装在Point类中，负责将输入的距离显示出来。</li></ul><p>显示总距离专门创建了一个DistancePanel来显示。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174508.png" alt="在这里插入图片描述"></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180451.png" alt="在这里插入图片描述"></p><ul><li>HiddenTotalDistance控制总距离是否显示。</li></ul><p>到这里基本的功能就基本实现了，下面实现一些必要的附加功能。</p><h1 id="五、封装Ranging类"><a href="#五、封装Ranging类" class="headerlink" title="五、封装Ranging类"></a>五、封装Ranging类</h1><p>由于SplineActor类是插件的核心类，不宜对外开放调用接口，且SplineActor类自身拥有Mesh，直接拖入场景中会显示Mesh，效果不佳，所以在SplineActor之外再封装一成没有Mesh的Ranging是十分必要的，有Ranging类提供对外调用的接口。</p><p>Ranging类的封装函数和变量：<br><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180459.png" alt="在这里插入图片描述"></p><ul><li><p>SetupRanging：启动测距，在鼠标所在位置生成SplineActor；</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180504.png" alt="在这里插入图片描述"></p></li></ul><ul><li>AddPoint：封装SplineActor中的AddPointEvent事件；</li></ul><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180511.png" alt="在这里插入图片描述"></p><ul><li>EndRanging：结束测距，封装ActorSpline的DeleteLastPoint函数，函数的具体实现在之后介绍；</li></ul><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180516.png" alt="在这里插入图片描述"></p><ul><li><p>Remove：删除所有的点线，封装SplineActor的RemoveAllPoint函数，函数的具体实现在之后介绍；</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180522.png" alt="在这里插入图片描述"></p></li></ul><ul><li><p>SplineActor：存储SplineActor的引用；</p></li><li><p>TotalDistance：存储总距离的值；</p></li><li><p>DistanceUint：显示总距离时的单位；</p></li><li><p>K：存储SplineActor中DistancePanel随相机距离变化大小的变化倍率；我这里设定的值为0.0002。</p></li></ul><p>文字随相机距离变化的函数实现封装在Ranging的UpdeteDistancePanelScale事件中，事件在Ranging的Tick函数中调用。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180542.png" alt="在这里插入图片描述"></p><h1 id="六、保持Point的DistancePanel组件的大小不变"><a href="#六、保持Point的DistancePanel组件的大小不变" class="headerlink" title="六、保持Point的DistancePanel组件的大小不变"></a>六、保持Point的DistancePanel组件的大小不变</h1><p>为了保证观感效果，Point的显示距离的DistancePanel组件的大小应该跟随相机的远近保持保持一定的大小，以保证相机贴近地面时，文字不会过大，相机原理地面时文字不过过小而看不见。</p><p>实现原理就在Ranging的UpdateDistancePanelScale事件中。</p><h1 id="七、返回上一步功能"><a href="#七、返回上一步功能" class="headerlink" title="七、返回上一步功能"></a>七、返回上一步功能</h1><p>当我们确定点的位置时会出现位置确定错误的情况，所以返回上一步的功能也是十分必要的，具体实现在SplineActor的DeleteLastPoint函数中。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180550.png" alt="在这里插入图片描述"></p><p>原理是移除上一个Spline的点和其匹配的Point、SplineMeshComponent并删除数组中对应的元素，然后更新一次距离，如果剩下最后一个点时，再撤回就直接将SplineActor删除并把显示总距离的DistancePanel移除，防止再创建SplineActor时再生成一个DiatancePanel而出现两个DistancePanel。</p><h1 id="八、移除所有的点"><a href="#八、移除所有的点" class="headerlink" title="八、移除所有的点"></a>八、移除所有的点</h1><p>当测距完成后需要清除所有的点，所以此功能也是必要的，具体实现在SplineActor的RemoveAllPoint中。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180557.png" alt="在这里插入图片描述"></p><h1 id="九、起点吸附功能"><a href="#九、起点吸附功能" class="headerlink" title="九、起点吸附功能"></a>九、起点吸附功能</h1><p>起点吸附是为了实现闭环。具体实现在SplineActor的EventActorBeginOverlap事件中。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180603.png" alt="在这里插入图片描述"></p><p>原理就是当SplineActor的Sphere触发器检测到Point时将此Point的坐标设置到起点的坐标处。</p><h1 id="九、整体效果预览"><a href="#九、整体效果预览" class="headerlink" title="九、整体效果预览"></a>九、整体效果预览</h1><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180609.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【BAT】BATWindows自动脚本同步GitHUb远程仓库</title>
    <link href="/2021/05/14/%E3%80%90BAT%E3%80%91BATWindows%E8%87%AA%E5%8A%A8%E8%84%9A%E6%9C%AC%E5%90%8C%E6%AD%A5GitHUb%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
    <url>/2021/05/14/%E3%80%90BAT%E3%80%91BATWindows%E8%87%AA%E5%8A%A8%E8%84%9A%E6%9C%AC%E5%90%8C%E6%AD%A5GitHUb%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><a id="more"></a><p>Windows自动脚本，我已自动同步GitHub仓库为例。</p><p>先上源码，可以直接用TXT写，然后将文件后缀改为.bat。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">start &quot;C:\Windows\System32\cmd.exe&quot;<br>G:<br>cd Git\Temp<br>git add .<br>git commit -m &quot;From Auto Updata&quot;<br>git push<br>pause<br>taskkill /f /im cmd.exe<br></code></pre></td></tr></table></figure><ul><li>start “C:\Windows\System32\cmd.exe”：打开Windows CMD控制台</li><li>G：切换到G盘，因为我的Git仓库放在G盘</li><li>cd Git\Temp：进入远程仓库所在的文件夹Temp，我的远程仓库放在G:/Goulandis/Git/Temp文件夹下</li><li><code>git add .</code>到<code>git push</code>是git同步远程仓库的命令</li><li>pause：pause命令用于暂停命令继续执行，本例中可有可无，这里加上主要是为了方便查看执行过程</li><li>taskkill /f /im cmd.exe：自动关闭CMD</li></ul><p>将文件后缀改为.bat之后，再将文件放入G:Goulandis(这是我电脑的路径)，这是根据cd Git\Temp决定的，我的Git文件夹就在G:Goulandis文件夹下，所以我将脚本放在G:Goulandis文件夹下，当然若觉得麻烦，也可直接将脚本放在Temp文件下，也就是仓库的.git文件夹所在的文件夹下，这时就不需要进行盘符和文件夹切换了，即上面代码中第二第三行删除。</p><p>双击运行，测试一下执行效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171713.png"></p><p>如果自动脚本很多的话，有一种更便捷的方法，就是专门为自动脚本创建一个文件夹，然后将其路径添加进环境变量中</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BAT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE4】UE4使用蓝图动态修改粒子参数</title>
    <link href="/2021/05/14/%E3%80%90UE4%E3%80%91UE4%E4%BD%BF%E7%94%A8%E8%93%9D%E5%9B%BE%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E7%B2%92%E5%AD%90%E5%8F%82%E6%95%B0/"/>
    <url>/2021/05/14/%E3%80%90UE4%E3%80%91UE4%E4%BD%BF%E7%94%A8%E8%93%9D%E5%9B%BE%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E7%B2%92%E5%AD%90%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><a id="more"></a><p>如果对UE4联级粒子P_Water系统比较熟悉的可能对动态修改粒子参数不陌生。</p><p>UE4的联级粒子系统大部分的模块都拥有一个<font color="red"> Distribution</font>子栏，其中可以选择如下模式</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171010.png"></p><p>其中<font color="red"> Distribution Vector Particle Parameter</font>就是参数模式，选择之后Distribution栏会变成这样</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171019.png"></p><p>其中Parameter Name就是参数的名字，在蓝图调用参数时需要用到。Min Input、Max Input、Min Output、Max Output分别限制参数的的最小输入、最大输入、最小输出、最大输出。</p><p>UE4的粒子系统提供8中类型的参数供外部控制：</p><ul><li>Actor Parameters</li><li>Auto Attachment Parameters</li><li>Color Parameters</li><li>Float Parameters</li><li>Float Rand Parameters</li><li>Material Parameters</li><li>Vector Parameters</li><li>Vector Rand Parameters</li></ul><p>8中参数类型的用法是一样的，这里我们以Vector Parameters，用以修改粒子的发射速度Initial Velocity为例。</p><p>首先将Initial Velocity模块的的Velocity/Start Velocity/Distribution选择Distribution Vector Particle Parameter模式，在Parameter Name栏设置参数名字为WaterSpeed，再设置好输入输出限制。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171025.png"></p><p>然后就可以在蓝图中使用这个参数了，首先打开关卡蓝图，我这里创建一个专门的函数SetWaterSpeed用来修改这个参数，蓝图脚本如下：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171031.png"></p><p>P_Water是放在场景中的粒子系统，获取粒子系统的ParticleSystemComponent粒子系统组件，这样就可以通过Set Vector Parameter函数来获取组上指定名字的参数了，由于Set Vector Parameter是按名字来获取参数的，所以同一种类型参数尽量不要重名。</p><p>然后进行函数调用。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171037.png"></p><p>测试一下粒子发射速度是否改变</p><p>初始状态</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171043.png"></p><p>按下Up键后</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171051.png"></p><p>按下Down键后</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171059.png"></p><p>目前尚未找到如何读取粒子系统的参数的方法。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE4】UE4内嵌Web及与Web通信</title>
    <link href="/2021/05/14/%E3%80%90UE4%E3%80%91UE4%E5%86%85%E5%B5%8CWeb%E5%8F%8A%E4%B8%8EWeb%E9%80%9A%E4%BF%A1/"/>
    <url>/2021/05/14/%E3%80%90UE4%E3%80%91UE4%E5%86%85%E5%B5%8CWeb%E5%8F%8A%E4%B8%8EWeb%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><a id="more"></a><p>UE4嵌入Web及UE4到Web的通信，我使用UE 4.22.3版本，以UE4嵌入ECharts并与ECharts通信为例。</p><h1 id="一、自定义WebBrowser"><a href="#一、自定义WebBrowser" class="headerlink" title="一、自定义WebBrowser"></a>一、自定义WebBrowser</h1><p>UwebBrowser是UE4自带的用于浏览Web的插件类，为了后面进行UE4与Web的通信，所以这里我们需要自定义一个UWebBrowser类。</p><h2 id="1-创建自定义WebBrowser类"><a href="#1-创建自定义WebBrowser类" class="headerlink" title="1.创建自定义WebBrowser类"></a>1.创建自定义WebBrowser类</h2><p>在C++ Classes中右键创建一个自己的继承自widget类的C++类–MyWebBrowser。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170722.png"></p><h2 id="2-编写自定义WebBrowser"><a href="#2-编写自定义WebBrowser" class="headerlink" title="2.编写自定义WebBrowser"></a>2.编写自定义WebBrowser</h2><p>然后在VS中搜索WebBrowser.cpp和WebBrowser.h这是UE4自带的WebBrowser类，虽说是写一个自定义的WebBrowser，但是我们的自定义的WebBrowser在功能上基本和UE4自带的webBrowser一致，所以我们只需将UE4自带的WebBrowser中的代码拷贝到我们自己的MyWebBrowser中稍作修改即可。</p><p>当然拷贝时不是全盘拷贝，只需拷贝如下WebBrowser.h中虚线以下的部分拷贝到我们的MyWebBrowser.h中。有时可能出现FOnUrlChanged和FOnBeforePopup报错，等VS反应一下就好了，有时可以直接编译，报红也是可以编译通过的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*WebBrowser.h*/</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Components/Widget.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;WebBrowser.generated.h&quot;</span></span><br><br>UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WEBBROWSERWIDGET_API</span> <span class="hljs-title">UWebBrowser</span> :</span> <span class="hljs-keyword">public</span> UWidget<br>&#123;<br>    <span class="hljs-comment">/*--------------------------------------------------------------------------------------*/</span><br>GENERATED_UCLASS_BODY()<br><br><span class="hljs-keyword">public</span>:<br>DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnUrlChanged, <span class="hljs-keyword">const</span> FText&amp;, Text);<br>DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnBeforePopup, FString, URL, FString, Frame);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Load the specified URL</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param NewURL New URL to load</span><br><span class="hljs-comment"> */</span><br>UFUNCTION(BlueprintCallable, Category=<span class="hljs-string">&quot;Web Browser&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoadURL</span><span class="hljs-params">(FString NewURL)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Load a string as data to create a web page</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param Contents String to load</span><br><span class="hljs-comment"> * @param DummyURL Dummy URL for the page</span><br><span class="hljs-comment"> */</span><br>UFUNCTION(BlueprintCallable, Category=<span class="hljs-string">&quot;Web Browser&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoadString</span><span class="hljs-params">(FString Contents, FString DummyURL)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Executes a JavaScript string in the context of the web page</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* @param ScriptText JavaScript string to execute</span><br><span class="hljs-comment">*/</span><br>UFUNCTION(BlueprintCallable, Category = <span class="hljs-string">&quot;Web Browser&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ExecuteJavascript</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString&amp; ScriptText)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Get the current title of the web page</span><br><span class="hljs-comment"> */</span><br>UFUNCTION(BlueprintCallable, Category=<span class="hljs-string">&quot;Web Browser&quot;</span>)<br><span class="hljs-function">FText <span class="hljs-title">GetTitleText</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Gets the currently loaded URL.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* @return The URL, or empty string if no document is loaded.</span><br><span class="hljs-comment">*/</span><br>UFUNCTION(BlueprintCallable, Category = <span class="hljs-string">&quot;Web Browser&quot;</span>)<br><span class="hljs-function">FString <span class="hljs-title">GetUrl</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br><br><span class="hljs-comment">/** Called when the Url changes. */</span><br>UPROPERTY(BlueprintAssignable, Category = <span class="hljs-string">&quot;Web Browser|Event&quot;</span>)<br>FOnUrlChanged OnUrlChanged;<br><br><span class="hljs-comment">/** Called when a popup is about to spawn. */</span><br>UPROPERTY(BlueprintAssignable, Category = <span class="hljs-string">&quot;Web Browser|Event&quot;</span>)<br>FOnBeforePopup OnBeforePopup;<br><br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-comment">//~ Begin UWidget interface</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SynchronizeProperties</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-comment">// End UWidget interface</span><br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ReleaseSlateResources</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> bReleaseChildren)</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> WITH_EDITOR</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">const</span> FText <span class="hljs-title">GetPaletteCategory</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-comment">/** URL that the browser will initially navigate to. The URL should include the protocol, eg http:// */</span><br>UPROPERTY(EditAnywhere, Category=Appearance)<br>FString InitialURL;<br><br><span class="hljs-comment">/** Should the browser window support transparency. */</span><br>UPROPERTY(EditAnywhere, Category=Appearance)<br><span class="hljs-keyword">bool</span> bSupportsTransparency;<br><br><span class="hljs-keyword">protected</span>:<br>TSharedPtr&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SWebBrowser</span>&gt;</span> WebBrowserWidget;<br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-comment">// UWidget interface</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> TSharedRef&lt;SWidget&gt; <span class="hljs-title">RebuildWidget</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-comment">// End of UWidget interface</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HandleOnUrlChanged</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FText&amp; Text)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">HandleOnBeforePopup</span><span class="hljs-params">(FString URL, FString Frame)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>WebBrowser.cpp则是全盘拷贝到我们的MyWebBrowser.cpp中，然后将所有的UWebBrowser修改为UMyWebBrowser，将#include “WebBrowser.h”改为我们自己的#include “MyWebBrowser.h”即可。</p><p>这里需要注意，有时会因为引擎位置不同导致#include “SWebBrowser.h”头文件打不开，此时我们需要给SWebBrowser.h一个路径即可，如：#include “Runtime/WebBrowser/Public/SWebBrowser.h”。</p><p>然后如下的代码中的Experimental，可以改也可以不改，这段代码主要控制我们自定义的MyWebBrowser显示在UI的Palette中的分栏位置，这里我都改为My。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> WITH_EDITOR</span><br><br><span class="hljs-function"><span class="hljs-keyword">const</span> FText <span class="hljs-title">UWebBrowser::GetPaletteCategory</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> LOCTEXT(<span class="hljs-string">&quot;Experimental&quot;</span>, <span class="hljs-string">&quot;Experimental&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>然后就可以编译了。</p><h2 id="3-完整代码"><a href="#3-完整代码" class="headerlink" title="3.完整代码"></a>3.完整代码</h2><p>这里贴出完整代码，供参考。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*MyWebBrowser.h*/</span><br><br><span class="hljs-comment">// Fill out your copyright notice in the Description page of Project Settings.</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Components/Widget.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;MyWebBrowser.generated.h&quot;</span></span><br><br>UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WEBTEST_API</span> <span class="hljs-title">UMyWebBrowser</span> :</span> <span class="hljs-keyword">public</span> UWidget<br>&#123;<br>GENERATED_UCLASS_BODY()<br><br><span class="hljs-keyword">public</span>:<br>DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnUrlChanged, <span class="hljs-keyword">const</span> FText&amp;, Text);<br>DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnBeforePopup, FString, URL, FString, Frame);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Load the specified URL</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param NewURL New URL to load</span><br><span class="hljs-comment"> */</span><br>UFUNCTION(BlueprintCallable, Category = <span class="hljs-string">&quot;Web Browser&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoadURL</span><span class="hljs-params">(FString NewURL)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Load a string as data to create a web page</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param Contents String to load</span><br><span class="hljs-comment"> * @param DummyURL Dummy URL for the page</span><br><span class="hljs-comment"> */</span><br>UFUNCTION(BlueprintCallable, Category = <span class="hljs-string">&quot;Web Browser&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoadString</span><span class="hljs-params">(FString Contents, FString DummyURL)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Executes a JavaScript string in the context of the web page</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* @param ScriptText JavaScript string to execute</span><br><span class="hljs-comment">*/</span><br>UFUNCTION(BlueprintCallable, Category = <span class="hljs-string">&quot;Web Browser&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ExecuteJavascript</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString&amp; ScriptText)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Get the current title of the web page</span><br><span class="hljs-comment"> */</span><br>UFUNCTION(BlueprintCallable, Category = <span class="hljs-string">&quot;Web Browser&quot;</span>)<br><span class="hljs-function">FText <span class="hljs-title">GetTitleText</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Gets the currently loaded URL.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* @return The URL, or empty string if no document is loaded.</span><br><span class="hljs-comment">*/</span><br>UFUNCTION(BlueprintCallable, Category = <span class="hljs-string">&quot;Web Browser&quot;</span>)<br><span class="hljs-function">FString <span class="hljs-title">GetUrl</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br><br><span class="hljs-comment">/** Called when the Url changes. */</span><br>UPROPERTY(BlueprintAssignable, Category = <span class="hljs-string">&quot;Web Browser|Event&quot;</span>)<br>FOnUrlChanged OnUrlChanged;<br><br><span class="hljs-comment">/** Called when a popup is about to spawn. */</span><br>UPROPERTY(BlueprintAssignable, Category = <span class="hljs-string">&quot;Web Browser|Event&quot;</span>)<br>FOnBeforePopup OnBeforePopup;<br><br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-comment">//~ Begin UWidget interface</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SynchronizeProperties</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-comment">// End UWidget interface</span><br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ReleaseSlateResources</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> bReleaseChildren)</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> WITH_EDITOR</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">const</span> FText <span class="hljs-title">GetPaletteCategory</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-comment">/** URL that the browser will initially navigate to. The URL should include the protocol, eg http:// */</span><br>UPROPERTY(EditAnywhere, Category = Appearance)<br>FString InitialURL;<br><br><span class="hljs-comment">/** Should the browser window support transparency. */</span><br>UPROPERTY(EditAnywhere, Category = Appearance)<br><span class="hljs-keyword">bool</span> bSupportsTransparency;<br><br><span class="hljs-keyword">protected</span>:<br>TSharedPtr&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SWebBrowser</span>&gt;</span> WebBrowserWidget;<br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-comment">// UWidget interface</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> TSharedRef&lt;SWidget&gt; <span class="hljs-title">RebuildWidget</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-comment">// End of UWidget interface</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HandleOnUrlChanged</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FText&amp; Text)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">HandleOnBeforePopup</span><span class="hljs-params">(FString URL, FString Frame)</span></span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*MyWebBrowser.cpp*/</span><br><br><span class="hljs-comment">// Fill out your copyright notice in the Description page of Project Settings.</span><br><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;MyWebBrowser.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Runtime/WebBrowser/Public/SWebBrowser.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Widgets/Layout/SBox.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Widgets/Text/STextBlock.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Async/TaskGraphInterfaces.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;UObject/ConstructorHelpers.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> WITH_EDITOR</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Materials/MaterialInterface.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Materials/MaterialExpressionMaterialFunctionCall.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Materials/MaterialExpressionTextureSample.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Materials/MaterialExpressionTextureSampleParameter2D.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Materials/MaterialFunction.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Factories/MaterialFactoryNew.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;AssetRegistryModule.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;PackageHelperFunctions.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOCTEXT_NAMESPACE <span class="hljs-meta-string">&quot;WebBrowser&quot;</span></span><br><br><span class="hljs-comment">/////////////////////////////////////////////////////</span><br><span class="hljs-comment">// UWebBrowser</span><br><br>UMyWebBrowser::UMyWebBrowser(<span class="hljs-keyword">const</span> FObjectInitializer&amp; ObjectInitializer)<br>: Super(ObjectInitializer)<br>&#123;<br>bIsVariable = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UMyWebBrowser::LoadURL</span><span class="hljs-params">(FString NewURL)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (WebBrowserWidget.IsValid())<br>&#123;<br><span class="hljs-keyword">return</span> WebBrowserWidget-&gt;LoadURL(NewURL);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UMyWebBrowser::LoadString</span><span class="hljs-params">(FString Contents, FString DummyURL)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (WebBrowserWidget.IsValid())<br>&#123;<br><span class="hljs-keyword">return</span> WebBrowserWidget-&gt;LoadString(Contents, DummyURL);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UMyWebBrowser::ExecuteJavascript</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString&amp; ScriptText)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (WebBrowserWidget.IsValid())<br>&#123;<br><span class="hljs-keyword">return</span> WebBrowserWidget-&gt;ExecuteJavascript(ScriptText);<br>&#125;<br>&#125;<br><br><span class="hljs-function">FText <span class="hljs-title">UMyWebBrowser::GetTitleText</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (WebBrowserWidget.IsValid())<br>&#123;<br><span class="hljs-keyword">return</span> WebBrowserWidget-&gt;GetTitleText();<br>&#125;<br><br><span class="hljs-keyword">return</span> FText::GetEmpty();<br>&#125;<br><br><span class="hljs-function">FString <span class="hljs-title">UMyWebBrowser::GetUrl</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (WebBrowserWidget.IsValid())<br>&#123;<br><span class="hljs-keyword">return</span> WebBrowserWidget-&gt;GetUrl();<br>&#125;<br><br><span class="hljs-keyword">return</span> FString();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UMyWebBrowser::ReleaseSlateResources</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> bReleaseChildren)</span></span><br><span class="hljs-function"></span>&#123;<br>Super::ReleaseSlateResources(bReleaseChildren);<br><br>WebBrowserWidget.Reset();<br>&#125;<br><br><span class="hljs-function">TSharedRef&lt;SWidget&gt; <span class="hljs-title">UMyWebBrowser::RebuildWidget</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (IsDesignTime())<br>&#123;<br><span class="hljs-keyword">return</span> SNew(SBox)<br>.HAlign(HAlign_Center)<br>.VAlign(VAlign_Center)<br>[<br>SNew(STextBlock)<br>.Text(LOCTEXT(<span class="hljs-string">&quot;Web Browser&quot;</span>, <span class="hljs-string">&quot;Web Browser&quot;</span>))<br>];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>WebBrowserWidget = SNew(SWebBrowser)<br>.InitialURL(InitialURL)<br>.ShowControls(<span class="hljs-literal">false</span>)<br>.SupportsTransparency(bSupportsTransparency)<br>.OnUrlChanged(BIND_UOBJECT_DELEGATE(FOnTextChanged, HandleOnUrlChanged))<br>.OnBeforePopup(BIND_UOBJECT_DELEGATE(FOnBeforePopupDelegate, HandleOnBeforePopup));<br><br><span class="hljs-keyword">return</span> WebBrowserWidget.ToSharedRef();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UMyWebBrowser::SynchronizeProperties</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::SynchronizeProperties();<br><br><span class="hljs-keyword">if</span> (WebBrowserWidget.IsValid())<br>&#123;<br><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UMyWebBrowser::HandleOnUrlChanged</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FText&amp; InText)</span></span><br><span class="hljs-function"></span>&#123;<br>OnUrlChanged.Broadcast(InText);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">UMyWebBrowser::HandleOnBeforePopup</span><span class="hljs-params">(FString URL, FString Frame)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (OnBeforePopup.IsBound())<br>&#123;<br><span class="hljs-keyword">if</span> (IsInGameThread())<br>&#123;<br>OnBeforePopup.Broadcast(URL, Frame);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">// Retry on the GameThread.</span><br>TWeakObjectPtr&lt;UMyWebBrowser&gt; WeakThis = <span class="hljs-keyword">this</span>;<br>FFunctionGraphTask::CreateAndDispatchWhenReady([WeakThis, URL, Frame]()<br>&#123;<br><span class="hljs-keyword">if</span> (WeakThis.IsValid())<br>&#123;<br>WeakThis-&gt;HandleOnBeforePopup(URL, Frame);<br>&#125;<br>&#125;, TStatId(), <span class="hljs-literal">nullptr</span>, ENamedThreads::GameThread);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> WITH_EDITOR</span><br><br><span class="hljs-function"><span class="hljs-keyword">const</span> FText <span class="hljs-title">UMyWebBrowser::GetPaletteCategory</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> LOCTEXT(<span class="hljs-string">&quot;My&quot;</span>, <span class="hljs-string">&quot;My&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-comment">/////////////////////////////////////////////////////</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> LOCTEXT_NAMESPACE</span><br><br></code></pre></td></tr></table></figure><h1 id="二、嵌入Web页面"><a href="#二、嵌入Web页面" class="headerlink" title="二、嵌入Web页面"></a>二、嵌入Web页面</h1><p>我们创建的MyWebBrowser继承自Widget属于UI范畴，所以Web显示操作属于UI操作。</p><h2 id="1-创建Web嵌入所用UI"><a href="#1-创建Web嵌入所用UI" class="headerlink" title="1.创建Web嵌入所用UI"></a>1.创建Web嵌入所用UI</h2><p>在Content Browser中右键/User Interface/Widget Buleprint，创建UI蓝图，这里我命名为WebBrowser。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170745.png"></p><p>打开WebBrowser，如果上面代码都编译通过了，那么在UI的Palette中应该会有一My栏，栏中有一个My Web Browser控件，这就是我们创建的自定义WebBrowser。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170752.png"></p><p>将My Web Browser拖入Hierachy中的Canvas Panel中并调整好大小。</p><h2 id="2-显示UI"><a href="#2-显示UI" class="headerlink" title="2.显示UI"></a>2.显示UI</h2><p>打开关卡蓝图，写入如下蓝图脚本：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170758.png"></p><p>注意，Class中填入的是我们刚创建的UI蓝图webBrowser。</p><h2 id="3-嵌入Web"><a href="#3-嵌入Web" class="headerlink" title="3.嵌入Web"></a>3.嵌入Web</h2><p>在UI蓝图webBrowser的Graph中写入如下蓝图脚本，在New URL中下入<a href="http://www.baidu.com用以测试./">www.baidu.com用以测试。</a></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170806.png"></p><p>运行测试</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170812.png"></p><p>测试通过。</p><h1 id="三、UE4到Web通信"><a href="#三、UE4到Web通信" class="headerlink" title="三、UE4到Web通信"></a>三、UE4到Web通信</h1><p>UE4到Web的通信，这里以UE4到ECharts的通信为例，首先到ECharts官网下载一个自己喜欢的图表源码到本地。</p><p>ECharts官网： <a href="https://www.echartsjs.com/zh/index.html">https://www.echartsjs.com/zh/index.html</a> </p><p>我以折线图为例</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170819.png"></p><p>ECharts上手较为简单，官方有5分钟快速上手教程，有详尽的API解释，这里不多累赘。</p><p>这里以使用UE4设置折线图Y轴的最大值和最小值为例。</p><h2 id="1-通信前的准备"><a href="#1-通信前的准备" class="headerlink" title="1.通信前的准备"></a>1.通信前的准备</h2><p>UE4到Web的通信需要通过SWebBrowser类的一个函数来绑定通信对象，然后通过这个对象进行数据通信。</p><p>首先我们需要定义一个函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">UFUNCTION(BlueprintCallable, Category = <span class="hljs-string">&quot;Web Browser&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UMyWebBrowser::BindUObject</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString &amp; Name, UObject * Object, <span class="hljs-keyword">bool</span> bIsPermanent)</span></span>;<br></code></pre></td></tr></table></figure><p>函数调用SWebBrowser类里的<code>void SWebBrowser::BindUObject(const FString &amp; Name, UObject * Object, bool bIsPermanent);</code>函数实现通信中介的创建。</p><p>这里要注意BindUObject函数需要暴露给蓝图调用。</p><p>函数实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UMyWebBrowser::BindUObject</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString &amp; Name, UObject * Object, <span class="hljs-keyword">bool</span> bIsPermanent)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (WebBrowserWidget.IsValid())<br>&#123;<br>WebBrowserWidget-&gt;BindUObject(Name, Object, bIsPermanent);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-创建通信对象与数据传递方法"><a href="#2-创建通信对象与数据传递方法" class="headerlink" title="2.创建通信对象与数据传递方法"></a>2.创建通信对象与数据传递方法</h2><p>然后再在WebBrowser的Graph的蓝图脚本中添加BindUObject的调用创建通信中介对象。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170828.png"></p><p>其中Name中填写的就是通信中介对象的名字，名字可以自定义，这里命的名字在Web中调用时用的对象名，中介对象就是Self，即当前Widget对象。</p><p>UE4到Web的通信是Web主动调用UE4的方法，通信的数据则是这个方法的返回值，Web可以获取到这个返回值，通过这个对象中的这个方法的返回值即可达到数据通信的目的。</p><p>在WebBrowser的My Blueprint/Functions中添加两个用于数据传递的方法，GetMin和GetMax。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170833.png"></p><p><font color="red">这里要注意，用于数据传递的方法的返回值的名字必须是<code>ReturnValue</code>否则数据无法传递。</font></p><p>之后就可以在Web中操作通过obj这个对象操作这些函数来获取UE4里的Min和Max变量了。</p><p>这里贴出Web源码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;meta charset=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;<br>    &lt;!-- 引入 echarts.js --&gt;<br>&lt;script src=<span class="hljs-string">&quot;C:/Users/Administrator/Desktop/ECharts/echarts.min.js&quot;</span>&gt;&lt;/script&gt;<br>    &lt;script src=<span class="hljs-string">&quot;C:/Users/Administrator/Desktop/ECharts/jquery.min.js&quot;</span>&gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body style = <span class="hljs-string">&quot;background-color:#d8d8d8&quot;</span>&gt;<br>    &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt;<br>&lt;div id=<span class="hljs-string">&quot;main&quot;</span> style=<span class="hljs-string">&quot;width: 1000px;height:450px;position:1px; top:1px;&quot;</span>&gt;CHART&lt;/div&gt;<br>&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;<br>         <br><span class="hljs-keyword">var</span> myChart = echarts.init(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;main&quot;</span>));<br><span class="hljs-keyword">var</span> x = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>,<span class="hljs-number">17</span>,<span class="hljs-number">18</span>,<span class="hljs-number">19</span>,<span class="hljs-number">20</span>,<span class="hljs-number">20</span>,<span class="hljs-number">22</span>,<span class="hljs-number">23</span>,<span class="hljs-number">24</span>,<span class="hljs-number">25</span>,<span class="hljs-number">26</span>,<span class="hljs-number">27</span>,<span class="hljs-number">28</span>,<span class="hljs-number">29</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">32</span>,<span class="hljs-number">33</span>,<span class="hljs-number">34</span>,<span class="hljs-number">35</span>,<span class="hljs-number">36</span>,<span class="hljs-number">37</span>,<span class="hljs-number">38</span>,<span class="hljs-number">39</span>,<span class="hljs-number">40</span>];<br><span class="hljs-keyword">var</span> y = [];<br><br><span class="hljs-keyword">var</span> y_min = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">var</span> y_max = <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Set</span>(<span class="hljs-params"></span>)</span>&#123;<br>option = &#123;<br>tooltip :<br>&#123;<br>trigger : <span class="hljs-string">&#x27;axis&#x27;</span>,<br><span class="hljs-comment">//十字锚点</span><br>axisPointer:<br>&#123;<br>type: <span class="hljs-string">&#x27;cross&#x27;</span>,<br>animation: <span class="hljs-literal">false</span>,<br>label: &#123;<span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&#x27;#505765&#x27;</span>&#125;,<br>lineStyle : &#123;<span class="hljs-attr">type</span> : <span class="hljs-string">&#x27;dashed&#x27;</span>&#125;<br>&#125;<br>&#125;,<br>xAxis: &#123;<span class="hljs-attr">data</span>: x&#125;,<br>yAxis: <br>&#123;<br>splitLine: &#123;<span class="hljs-attr">show</span>: <span class="hljs-literal">false</span> &#125;,<br>min : y_min,<br>max : y_max<br>&#125;,<br>dataZoom: [<br>&#123;<span class="hljs-attr">startValue</span>: <span class="hljs-string">&#x27;2014-06-01&#x27;</span>&#125;, <br>&#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;inside&#x27;</span>&#125;<br>],<br>series: &#123;<br>type: <span class="hljs-string">&#x27;line&#x27;</span>,<br>data: y<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SetYMinAndMax</span>(<span class="hljs-params"></span>)</span>&#123;<br>ue.obj.getmin().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ReturnValue</span>)</span>&#123;<br>y_min = ReturnValue;<br>&#125;);<br>ue.obj.getmax().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ReturnValue</span>)</span>&#123;<br>y_max = ReturnValue;<br>&#125;);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AddData</span>(<span class="hljs-params"></span>)</span>&#123;<br>y.push(<span class="hljs-built_in">Math</span>.random());<br>&#125;<br><br>SetYMinAndMax();<br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>AddData();<br><span class="hljs-built_in">Set</span>();<br>myChart.setOption(option);<br>&#125;,<span class="hljs-number">1000</span>);<br>    &lt;/script&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>其中SetYMinAndMax函数便是UE4与Web的数据通信。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SetYMinAndMax</span>(<span class="hljs-params"></span>)</span>&#123;<br>ue.obj.getmin().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ReturnValue</span>)</span>&#123;<br>y_min = ReturnValue;<br>&#125;);<br>ue.obj.getmax().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ReturnValue</span>)</span>&#123;<br>y_max = ReturnValue;<br>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="red">这里还需要注意，ue.obj.getmin()和ue.obj.getmax()必须使用小写，否则也无法通信，其次匿名函数function(ReturnValue)的参数名也必须为ReturnValue不可更改，否则数据依然无法传递。</font></p><p>然后测试一下数据传递是否正确。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170845.png"></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170850.png"></p><p>可以看到Y轴的最大值由1改为了Max变量的值2。数据传递成功。</p><p>上面的Web程序要运行还需要两个文件<code>echarts.min.js</code>和<code>jquery.min.js</code>，文件放在：</p><p>这是B站上的视频教程：<a href="https://www.bilibili.com/video/av47212309">https://www.bilibili.com/video/av47212309</a></p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE4】UE4角色控制</title>
    <link href="/2021/05/14/%E3%80%90UE4%E3%80%91UE4%E8%A7%92%E8%89%B2%E6%8E%A7%E5%88%B6/"/>
    <url>/2021/05/14/%E3%80%90UE4%E3%80%91UE4%E8%A7%92%E8%89%B2%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><a id="more"></a><h1 id="一、UE4的角色控制框架"><a href="#一、UE4的角色控制框架" class="headerlink" title="一、UE4的角色控制框架"></a>一、UE4的角色控制框架</h1><p>做角色控制之前，我们首先要了解UE4的角色控制框架，了解引擎是如何控制角色移动和做出各种骚姿势的。</p><h2 id="1-Pawn"><a href="#1-Pawn" class="headerlink" title="1.Pawn"></a>1.Pawn</h2><p>Pawn类就是UE4里可用于操控的游戏物体，Pawn类继承自Actor拥有Actor的所有特性，并且Pawn还带有</p><ul><li>Controller：可以被操控；</li><li>PhysicsCollision：物理碰撞；</li><li>MovementInput：事件响应，大多数情况下用于键盘输入事件响应。</li></ul><h2 id="2-Character"><a href="#2-Character" class="headerlink" title="2.Character"></a>2.Character</h2><p>Character就是我们即将要使用的类，Character继承自Pawn，也拥有可操控性，物理碰撞和事件响应，除此之外，Character还拥有CapsuleComponent(椭圆碰撞体)，ArrowComponent(角色正面方向)，Mesh。我们向Mesh上添加模型，Character便拥有了可显示的网格。</p><p>当然Pawn派生的还有defaultPawn,SpectatorPawn，这里就不探讨了。</p><h2 id="3-Controller"><a href="#3-Controller" class="headerlink" title="3.Controller"></a>3.Controller</h2><p>Controller也派生自Actor，是与Pawn平级的类，Controller负责控制Pawn及Pawn的派生类，但Controller一般负责高层面的控制，如角色切换，多角色控制等，而Pawn和Character负责处理角色自身的简单控制逻辑，如角色的移动，跑，蹲，跳等运动逻辑。</p><p>由于Controller是独立Pawn存在的，所以Controller可以独立存在与World中，如：上帝视角。</p><p>一个Controller可以控制多个Pawn，一个Pawn也可以被多个Controller控制。</p><p>但是一个Pawn要想被控制就必须关联至少一个Controller，否则尽管在Pawn中编写了控制逻辑，我们依然无法操控Pawn。</p><h1 id="二、角色控制"><a href="#二、角色控制" class="headerlink" title="二、角色控制"></a>二、角色控制</h1><p>与U3D的角色控制一样，在UE4中进行角色控制前也需要进行按键的映射注册。</p><h2 id="1-注册按键映射"><a href="#1-注册按键映射" class="headerlink" title="1.注册按键映射"></a>1.注册按键映射</h2><p>在<code>Project Settings/Input/Bindings</code>下，有一个Action Mappings(行为映射)和一个Axis Mappings(轴映射)，Action Mappings是与角色三维坐标轴无关的映射，一般用于触发角色的行为，如：跳，蹲，拾取等行为，并且UE4还为Action Mappings封装好了组合键，在U3D中，组合键的逻辑是需要我们自己写的。Axis Mappings是与角色三维坐标轴有关的映射，一般用于触发角色的移动与视角控制。</p><p><font color="red"> 我们将映射注册好之后，UE4会自动按照我们的命名创建触发事件蓝图，这个在后面详细讲解</font>。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171219.png"></p><p>这里详细说一下视角控制，视角控制一般使用鼠标来控制(当然也可以使用键盘，只是大多数情况下使用鼠标)，所有我们使用的映射是Mouse Y和Mouse X，我们用一张图来理解Mouse Y和Mouse X的方向：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171226.png"></p><p>Mouse Y就是鼠标的Y轴，Mouse X就是鼠标的X轴。</p><h2 id="2-使用角色蓝图编写控制逻辑"><a href="#2-使用角色蓝图编写控制逻辑" class="headerlink" title="2.使用角色蓝图编写控制逻辑"></a>2.使用角色蓝图编写控制逻辑</h2><p>首先我们创建一个继承自Character的蓝图类，然后为Character中添加SpringArm组件并在SpringArm组件下添加Camera组件，SpringArm组件是专门为Camera服务的组件，用于连接Mesh和Camera，可以对Camera进行一些操作，如相机偏移等。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171233.png"></p><p>然后向Mesh中添加我们需要的模型，一个Character基本组件就搭建好了</p><p>然后我们就可以在Character蓝图类的Event Graph中编写控制逻辑了。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171240.png"></p><p>Input Axis MoveForword，Input Axis MoveRight，Input Axis LookUp，Input Axis Turn都是UE4按照我们注册按键映射时的名字为我们创建好的事件，当我们按下对应的键时事件就会被触发。</p><p>UE4使用MovementComponent封装好了Pawn的移动实现，Character中也自带有一个CharacterMovement，我们只需要向组件中添加输入就可以使角色移动了，Add Movement Input函数就是用于MovementComponent组件输入的函数，我们只需要传给Add Movement Input函数移动方向和值就可以使角色按照我们规定的方向移动，移动方向的获取，UE4也封装好了Get Forward Vector(正前方)和Get Right Vector(正右方)来获取某一个轴上的正前与正右的方向矢量，Get Control Rotation函数可以获取角色当前的方向矢量，而角色的前后左右移动是在Z轴的垂直面，即XY平面上移动，所以我们需要获取Z轴的正前正右的方向矢量，我们可以使用Break将角色当前的方向矢量拆开成xyz三个标量，只拿Z轴的值再使用Make封装成矢量，这样Get Forward Vector和Get Right Vector所拿到就是Z轴的正前方与正右方了。</p><p>而角色的视角转向，UE4使用的是 Controller Yaw，Controller Pitch，Controller Roll来控制的，Controller Yaw控制的是角色的上下方向的视角旋转，Controller Pitch控制的是角色的左右方向的视角旋转，Controller Roll控制的是角色的前后方向的视角旋转，和MoveComponent一样UE4也提供Add Controller Yaw Input，Add Controller Pitch Input，Add Controller Roll Input分别为三者传值。我们只需要将映射对应的值输入给三个函数即可实现角色视角的旋转控制了，然后勾选SpringArm的Details/Camera Settings/Use Pawn Controller Rotation，将视角旋转控制应用到相机上，这样角色就可以通过鼠标进行视角控制了。</p><h2 id="3-关联角色控制器"><a href="#3-关联角色控制器" class="headerlink" title="3.关联角色控制器"></a>3.关联角色控制器</h2><p>UE4的角色控制框架规定了，我们必须为角色关联一个Controller才可以对角色进行控制。</p><p>在角色的Details/Input/Auto Receive Input选项中可以切换控制器，UE4为我们封装好了一个Controller–Player 0，我们选择Player 0就可以对角色进行控制了。其他的Palyer 1，Player 2等是用于其他的用途的，我们这里不探讨。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171247.png"></p><h1 id="三、配置骨骼动画"><a href="#三、配置骨骼动画" class="headerlink" title="三、配置骨骼动画"></a>三、配置骨骼动画</h1><p>完成以上步骤，我们的角色就可以在场景中自由自动了，但是这个移动只是纯移动，并不带有移动动画，要想移动更真实，我们还需要为角色配置骨骼动画。</p><p>需要注意的是不是什么动画都可以往角色身上套的，只有和角色骨骼相匹配的动画才可以被角色使用，如果我们想要使用某些动画，我们就需要设置模型的骨骼为这些动画配套的骨骼。</p><h2 id="1-配置骨骼"><a href="#1-配置骨骼" class="headerlink" title="1.配置骨骼"></a>1.配置骨骼</h2><p>在导入模型的时候就可以为模型选定骨骼，选定好骨骼的模型导入工程后就不能在更换骨骼了，想要更换骨骼就需要重新导入。这里我们使用UE4自带的骨骼。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171254.png"></p><p>还有一步是为模型添加物理资产，在模型视图的Asset Details/Physics/Physics Asset选择与骨骼动画配套的物理资产，至于这个物理资产具体是干什么的这里不深究。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171300.png"></p><h2 id="2-混合空间"><a href="#2-混合空间" class="headerlink" title="2.混合空间"></a>2.混合空间</h2><p>如上图，我们可以看到一个Blend Space和一个Bland Space 1D，这是UE4专门用来处理某一类动画混合的模块。Blend Space是二维混合空间，可以混合两个方向上的动作，比如，向前前后是一个方向，向左向右是一个方向，Blend Space就可以混合这两个方向的所有动作；而Blend Space 1D则只能混合一个方向上的动作。</p><p>这里我们需要为角色前后左右两个方向上的移动添加动作，所以选择Blend Space。打开混合空间</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171307.png"></p><p>在动作混合视图中UE4已经为我们预设好了很多骨骼动画，横轴与纵轴的名字要命名规范，因为这两个轴的名字会作为混合空间的参数，从外界传值进来的。横轴纵轴的最大值最小值和分割数都可以根据自己的实际需求设置。</p><p>Preview Base Pose是用来设置关键帧姿势的，有的骨骼动画直接包含了姿势动作，Preview Base Pose会自动赋值，有的骨骼动画只包含了动作，这时就需要我们手动赋予姿势了，如我们后面需要用到的扭头的动画。</p><p>然后添加上我们需要的动画即可，当Speed变化时，角色的动画会在Idle-Walk-Run之间切换，当Deriction变化时，角色的动画会在Left和Right之间切换。</p><h2 id="3-动画蓝图"><a href="#3-动画蓝图" class="headerlink" title="3.动画蓝图"></a>3.动画蓝图</h2><p>Animation Blueprint是UE4封装的专门用于管理动画的类，Animation Blueprint可以管理骨骼动画的混合空间也可以直接管理骨骼动画。</p><p>在Content Browser中右键选择Animation/Animation Blueprint，然后Parent Class选择父类为AnimInstance，Target Skeletion选择我们角色应用的骨骼，就可以创建一个管理我们选定的骨骼动画的管理蓝图了。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171314.png"></p><p>进入动画蓝图，在Anim  Graph视图，我们可以看见一个Final Animation Pose节点，这是UE4封装好的处理角色最终要显示的动画的模块，右键添加添加一个状态机。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171320.png"></p><p>双击状态机，进入状态机里，右键添加一个状态并命名为Idle_Walk_Run。一个状态机可以管理多个状态。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171328.png"></p><p>双击进入状态，在右侧Asset Browser中选择我们配置好的混合空间，并在左侧MyBlueprint/Variables中添加两个变量Speed和Deriction分别给混合空间的横轴Speed和纵轴Deriction赋值。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171335.png"></p><p>然后在动画蓝图的Event Graph中编写逻辑为Speed和Deriction变量赋值。</p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171341.png" style="zoom:200%;"><p>直接看到角色移动的控制逻辑，UE4为我们封装好了Caculate Deriction来计算角色的移动方向，我们只需要使用Get Velocity和GetActorRotation获取角色的速度矢量和旋转方向赋值给Calculate Deriction既可以了，速度矢量的模，UE4也封装好了VectorLength来计算。</p><p>最后在角色蓝图的Mesh的Details/Animation中将Animation Mode设置成Use Animation Blueprint，将Anim Class设置成我们创建的动画蓝图，这样我们的动画就可以应用到我们的角色上了。</p><h1 id="四、多动画管理"><a href="#四、多动画管理" class="headerlink" title="四、多动画管理"></a>四、多动画管理</h1><p>我们的游戏角色一般不可能只有移动的动画，一般还会有其他的动画，如拾取，下蹲等，这时我们就需要进行多动画混合空间的管理了。</p><p>多动画管理有两类，一类是与角色移动动画同级的混合动画，在一个时刻是能播放一个动画，二者不兼容，如下蹲，一类是可以在角色移动动画播放的同时也可以播放的混合动画，在一个时刻两个动画都可以播放，二者兼容，如角色站立时扭头。</p><h2 id="1-不兼容的同级动画管理"><a href="#1-不兼容的同级动画管理" class="headerlink" title="1.不兼容的同级动画管理"></a>1.不兼容的同级动画管理</h2><p>按照第三步，我们也可以创建一个Blend Space来混合下蹲动画。当然如果下蹲动画只有一个，就没必要使用Blend Space了，可以直接使用动画蓝图来管理动画。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171351.png"></p><p>同样，我们创建一个状态机Crouch，在状态机里配置下蹲动画。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171400.png"></p><p>需要注意的是，下蹲动画的横轴和纵轴也需要命名为Speed和Deriction，因为我们的下蹲移动使用的也是前后左右两个方向来控制动画。</p><p>然后在动画蓝图的Anim Graph中添加一个Blend Poses by bool来管理移动与下蹲动画，并创建一个bool值来判断动画的执行</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171406.png"></p><p>Is Crouch为true时走True Pose,为False时走False Pose，并且可以设置两个分支的动画过度时间。</p><p>然后就是在Event Graph中编写下蹲动画的控制逻辑。如步骤三中逻辑控制图的下蹲控制逻辑，UE4甚至封装好了下蹲判断，Is Crouching，可以直接判断角色当前是否处于下蹲状态，直接将这个状态赋值给IsCrouch变量，然后使用Get MoveMen Component给Is Crouching传值。</p><p>当然如果我们有更多的不兼容动画需要管理，UE4也为我们提供了Blend Poses by int来管理</p><h2 id="2-可兼容动画管理"><a href="#2-可兼容动画管理" class="headerlink" title="2.可兼容动画管理"></a>2.可兼容动画管理</h2><p>可兼容的动画的混合就不是使用Blend Space来混合了，而是使用Aim Offset来混合。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171413.png"></p><p>一般可兼容的动画使用的是关键帧，即只有动画没有姿势，我们需要将动画应用到某一姿势上去，如上图应用到Idle上的Idle的扭头动作。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171419.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE4】UE4Socket编程</title>
    <link href="/2021/05/14/%E3%80%90UE4%E3%80%91UE4Socket%E7%BC%96%E7%A8%8B/"/>
    <url>/2021/05/14/%E3%80%90UE4%E3%80%91UE4Socket%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><a id="more"></a><h1 id="一、基于C-的服务器"><a href="#一、基于C-的服务器" class="headerlink" title="一、基于C++的服务器"></a>一、基于C++的服务器</h1><p>当然服务器也是可以使用UE4写的，不过对于一般的不需要UI的服务器来说，直接使用C++控制台程序编写要方便得多。</p><h2 id="1-所需头文件和静态库"><a href="#1-所需头文件和静态库" class="headerlink" title="1.所需头文件和静态库"></a>1.所需头文件和静态库</h2><p><code>#include &lt;winsock.h&gt;</code></p><p><code>#pragma comment(lib &quot;ws2_32.lib&quot;)</code></p><p><font color="red"> 需要注意的是，winsock.h是Windows环境使用的头文件，对于其他的环境需要使用其他的头文件，如在Linux下使用的是socket.h。</font></p><p>有的时候也是用winsock2.h，winsockt2.h是winsockt.h的升级版，一个文件中不可同时存在winsockt.h和winsockt2.h，因为winsockt2.h中有重定义winsockt.h中的内容。</p><h2 id="2-创建套接字"><a href="#2-创建套接字" class="headerlink" title="2.创建套接字"></a>2.创建套接字</h2><p><strong>Server.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;winsock.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> comment(lib, <span class="hljs-meta-string">&quot;ws2_32.lib&quot;</span>)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Server</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>WSADATA wsd;<span class="hljs-comment">//存放套接字的属性，如：版本信息等</span><br>SOCKET serverSocket;<br>SOCKET clientSocket;<br>SOCKADDR_IN serverAddr;<span class="hljs-comment">//用于设置套接字使用的地址类型，端口和</span><br><br>Server(<span class="hljs-keyword">int</span> port);<br>~Server();<br><br><span class="hljs-function">SOCKET <span class="hljs-title">ClientListen</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Receive</span><span class="hljs-params">(SOCKET clientSocket)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>创建套接字</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++">Server::Server(<span class="hljs-keyword">int</span> port)<br>&#123;<br><span class="hljs-comment">//打开2.2版本的套接字，注册套接字</span><br><span class="hljs-keyword">if</span> (WSAStartup(MAKEWORD(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), &amp;wsd) != <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;初始化套接字动态库错误&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//创建套接字，AF_INET--使用Inter使用，SOCK_STREAM--使用流式传输，IPPROTO_TCP--使用TCP连接</span><br>serverSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);<br><span class="hljs-keyword">if</span> (serverSocket == INVALID_SOCKET)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;套接字创建失败&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>WSACleanup();<span class="hljs-comment">//注销套接字</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>serverAddr.sin_family = AF_INET;<span class="hljs-comment">//配置地址类型为InterIP</span><br>serverAddr.sin_port = htons(port);<span class="hljs-comment">//配置占用端口</span><br>serverAddr.sin_addr.S_un.S_addr = INADDR_ANY;<span class="hljs-comment">//接受任何IP类型</span><br><span class="hljs-comment">//将IP和端口与套接字绑定</span><br><span class="hljs-keyword">int</span> ret = bind(serverSocket, (LPSOCKADDR)&amp;serverAddr, <span class="hljs-keyword">sizeof</span>(SOCKADDR_IN));<br><span class="hljs-keyword">if</span> (ret == SOCKET_ERROR)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;套接字绑定失败&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>closesocket(serverSocket);<span class="hljs-comment">//关闭套接字</span><br>WSACleanup();<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其间也可以加一个版本判断，判断注册的套接字是否是2.2版本的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (LOBYTE(wsd.wVersion != <span class="hljs-number">2</span> || HIBYTE(wsd.wVersion) != <span class="hljs-number">2</span>))<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;套接字版本错误，需要打开2.2版本的套接字&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>WSACleanup();<br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-套接字监听"><a href="#3-套接字监听" class="headerlink" title="3.套接字监听"></a>3.套接字监听</h2><p>C++没有提供专门的异步套接字监听方法，如果不想使用阻塞的方式，即同步方式监听套接字的话，就需要通过线程来实现异步监听了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">SOCKET <span class="hljs-title">Server::ClientListen</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> ret = listen(serverSocket, SOMAXCONN);<span class="hljs-comment">//开启套接字监听，SOMAXCONN--监听队列设为最大</span><br><span class="hljs-keyword">if</span> (ret == SOCKET_ERROR)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;监听时发生错误&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>closesocket(serverSocket);<br>WSACleanup();<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br>sockaddr_in clientAddr;<span class="hljs-comment">//用于存储接收到的客户端的地址信息</span><br><span class="hljs-keyword">int</span> clientAddrLen = <span class="hljs-keyword">sizeof</span>(clientAddr);<br>    <span class="hljs-comment">//接受serverSocket缓冲区里clientAddrlen长度的内容，即一个套接字</span><br>SOCKET clientSocket = accept(serverSocket, (sockaddr FAR*)&amp;clientAddr, &amp;clientAddrLen);<br><span class="hljs-keyword">if</span> (clientSocket == INVALID_SOCKET)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;接受客户端时发生错误&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>closesocket(serverSocket);<br>WSACleanup();<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;接受到客户端&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> clientSocket;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-接受消息"><a href="#4-接受消息" class="headerlink" title="4.接受消息"></a>4.接受消息</h2><p>获取到客户端的套接字后，就可以就收客户端发送过来的消息了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Server::Receive</span><span class="hljs-params">(SOCKET clientSocket)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">char</span> receiveBuff[<span class="hljs-number">50</span>];<span class="hljs-comment">//接受消息内容缓冲数组</span><br>    <span class="hljs-comment">//接受消息</span><br>recv(clientSocket, receiveBuff, <span class="hljs-built_in">strlen</span>(receiveBuff), <span class="hljs-number">0</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, receiveBuff);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-发送消息"><a href="#5-发送消息" class="headerlink" title="5.发送消息"></a>5.发送消息</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Server::Send</span><span class="hljs-params">(SOCKET clientSocket, <span class="hljs-keyword">char</span> * sendBuff)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//发送sendBuff发送消息数组钟的内容到clientSocket套接字</span><br>send(clientSocket, sendBuff, <span class="hljs-built_in">strlen</span>(sendBuff) + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二、GameMode与GameInstance"><a href="#二、GameMode与GameInstance" class="headerlink" title="二、GameMode与GameInstance"></a>二、GameMode与GameInstance</h1><p>由于UE4在换关卡的时候会删除世界大纲中的上一关卡中的所有的内容，所以对于需要在整个游戏运行期间都必须工作的套接字来说，需要在一个从游戏开始运行到游戏程序关闭都存在的场所中工作，这个场所就是GameInstance，而使用自定义GameInstance需要用到GameMode，所以在写UE4客户端套接字之前，我们有必要先了解GameInstance和GameMode。</p><h2 id="1-GameInstance"><a href="#1-GameInstance" class="headerlink" title="1.GameInstance"></a>1.GameInstance</h2><p>要了解GameInstance，首先我们要对UE的引擎结构有一点点的了解。</p><p>UE的宇宙是由UEngine这个创世神管理的各个World组成的，每个World就是一个个平行世界，编辑模式是一个World，运行模式是一个World，而每个World又由各个Level组成，每个Level又由各个Actor组成，而每个Actor拥有各种不同Component从而形成了各式各样的Actor，于是多姿多彩的UE世界便展开了，而GameInstance就是凌驾于World之上的存在。</p><p><font color="red"> GameInstance的生命周期就是整个游戏进程的生命周期，从游戏开始到游戏程序关闭，并且GameInstance在整个游戏进程中只存在一个对象，即单例，就如名字一般</font>。所以任何凌驾于Level和World之上的逻辑都应该在GameInstance中保存和实现，比如游戏网络连接，因为Level在切换时UE4会清空上一个Level在世界大纲中所有内容，然后加载下一个Level的内容，此时如果把游戏网络连接的逻辑放在Level或World中，这些逻辑就会被清空，在上一个Level内容被清空到下一个Level中重新加载网络连接逻辑的期间游戏会处于网络孤立状态。在游戏运行期间World在任意时刻其实都是是唯一的，为什么网络连接的逻辑不能放在World中，而要放在GameInstance中呢?这是因为UE在加载新的Level时，其实是在销毁前一个World，创建了一个新的World。但是World依然只有一个。</p><p><strong>使用GameInstance</strong></p><p>使用GameInstance的方法很简单，就是创建一个类继承自UGameInstance的子类，这个子类就继承到了GameInstance的所有属性了。</p><p>但是GameInstance不存在于世界大纲中该如何执行在其中实现的逻辑代码呢？这就是我们接下来要来了解的GameMode的事了。</p><h2 id="2-GameMode"><a href="#2-GameMode" class="headerlink" title="2.GameMode"></a>2.GameMode</h2><p>首先我们需要知道什么是GameMode，在UE4里GameMode是对应World层存在的，UE4给予GameMode的职责就是处理与实现游戏逻辑，即游戏的玩法，这里我们要区分GameMode与LevelBlueptint，LevelBlueprint是对应Level存在在，每一个Level有且只有一个LevelBlueprint，而GameMode是对应World存在的，每一个World有且只有一个GameMode，但是一个UE4游戏中是可以有多个GameMode，就像一个游戏可以有多种规则玩法一样。</p><p>在UE4里GameInstance里的内容可以被全局调用，那么我们为什么要使用GameMode来实现网络连接而不是用更易理解的LevelBlueprint呢？这是因为GameMode提供了内容在拥有不同GameMode的World中迁移的能力，加以大多数游戏一般只有一中游戏规则，即一个GameMode，所以在GameMode中做网络连接的逻辑是较为恰当的。</p><p><strong>使用GameMode</strong></p><p>GameMode实质上是一个继承自GameModeBase的蓝图类，我们只需创建一个继承自GameModeBase的GameMode，就可以在GameMode中编写蓝图脚本调用C++函数来实现游戏逻辑了，为什么在GameMode中只进行函数调用呢？因为如果所有的代码逻辑都在GameMode中实现就会显得GameMode过于臃肿，所以GameMode一般进行函数调用，而函数的实现则在C++类中处理。</p><p>至此，客户端的网络部分的代码逻辑在什么地方编写就基本确定了。</p><h1 id="三、UE4客户端"><a href="#三、UE4客户端" class="headerlink" title="三、UE4客户端"></a>三、UE4客户端</h1><h2 id="1-前提准备"><a href="#1-前提准备" class="headerlink" title="1.前提准备"></a>1.前提准备</h2><ul><li><p>UE4编写网络模块的逻辑需要在.Build.cs文件里添加两个模块<font color="red"> “Sockets”, “Networking”</font>；</p></li><li><p>创建一个继承自UGameInstance的类作为网络部分的代码实现模块；</p></li><li><p>创建一个继承自GameModeBase的GameMode，并在Settings/Project Settings/Maps&amp;Mode下设置项目默认的GameMode和GameInstance。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171635.png"></p></li></ul><h2 id="2-连接服务器"><a href="#2-连接服务器" class="headerlink" title="2.连接服务器"></a>2.连接服务器</h2><p><strong>.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;FReceiveThread.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Runtime/NEtworking/Public/Networking.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Engine/GameInstance.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ServerConnector.generated.h&quot;</span></span><br><br>UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYGAME_API</span> <span class="hljs-title">UServerConnector</span> :</span> <span class="hljs-keyword">public</span> UGameInstance<br>&#123;<br>GENERATED_BODY()<br><span class="hljs-keyword">private</span>:<br><br>FSocket *connectSocket;<br>FIPv4Address ip;<br>TSharedPtr&lt;FReceiveThread&gt; receiveThread;<br><br><span class="hljs-keyword">public</span>:<br><br>FString msg;<br><br><span class="hljs-keyword">public</span>:<br>UServerConnector() &#123;&#125;<br><span class="hljs-comment">//create socket and connect server</span><br>UFUNCTION(BlueprintCallable,Category=<span class="hljs-string">&quot;ClientSocket&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ServerConnect</span><span class="hljs-params">(FString ip,int32 port)</span></span>;<br><span class="hljs-comment">//send message to server</span><br>UFUNCTION(BlueprintCallable, Category = <span class="hljs-string">&quot;ClientSocket&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Send</span><span class="hljs-params">(FString msg)</span></span>;<br><span class="hljs-comment">//receive message from server</span><br>UFUNCTION(BlueprintCallable, Category = <span class="hljs-string">&quot;ClientSocket&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Receive</span><span class="hljs-params">()</span></span>;<br><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>连接Server</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">UServerConnector::ServerConnect</span><span class="hljs-params">(FString ip, int32 port)</span></span><br><span class="hljs-function"></span>&#123;<br>FIPv4Address::Parse(ip,<span class="hljs-keyword">this</span>-&gt;ip);<span class="hljs-comment">//将字符串表示的ip转换成点分十进制的ip</span><br>    <span class="hljs-comment">//创建服务器套接字地址，PLATFROM_SOCKTSUBSYSTEM--选择当前系统的套接字</span><br>TSharedPtr&lt;FInternetAddr&gt; addr = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateInternetAddr();<br>addr-&gt;SetIp(<span class="hljs-keyword">this</span>-&gt;ip.Value);<span class="hljs-comment">//向套接字地址绑定服务器ip</span><br>addr-&gt;SetPort(port);<span class="hljs-comment">//向套接字地址绑定服务器端口</span><br>    <span class="hljs-comment">//创建客户端套接字，NAME_Stream--使用流式传输，Default--套接字描述，false使用TCP，Ture使用UDP连接</span><br>connectSocket = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateSocket(NAME_Stream, TEXT(<span class="hljs-string">&quot;Default&quot;</span>), <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">if</span> (!connectSocket-&gt;Connect(*addr))<span class="hljs-comment">//连接服务器</span><br>&#123;<br>UE_LOG(LogTemp, Error, TEXT(<span class="hljs-string">&quot;ServerConnector.cpp:Connect Failed&quot;</span>));<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>UE_LOG(LogTemp, Error, TEXT(<span class="hljs-string">&quot;Connect Succeed&quot;</span>));<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-发送消息"><a href="#3-发送消息" class="headerlink" title="3.发送消息"></a>3.发送消息</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">UServerConnector::Send</span><span class="hljs-params">(FString msg)</span></span>&#123;    <span class="hljs-comment">//将字符串形式的消息转换成TCHAR*类型，因为二进制流的转换只支持TCHAR类型TCHAR *seriallizedChar = msg.GetCharArray().GetData();int32 size = FCString::Strlen(seriallizedChar) + 1;//计算消息的内存大小int32 sent = 0;//这一行是Send函数的格式要求，提供给Send内部使用的参数    //将消息转化成二进制流并向服务器发送消息if (!connectSocket-&gt;Send((uint8*)TCHAR_TO_UTF8(seriallizedChar), size, sent))&#123;UE_LOG(LogTemp, Error, TEXT(&quot;Message Send Failly&quot;));return false;&#125;UE_LOG(LogTemp, Error, TEXT(&quot;Message Send Successlly&quot;));return true;&#125;</span><br></code></pre></td></tr></table></figure><h2 id="4接受消息"><a href="#4接受消息" class="headerlink" title="4接受消息"></a>4接受消息</h2><p>接受消息就需要使用到UE4线程了，那么首先我们就需要了解UE4线程。</p><p>在UE4中线程就是一个继承自FRunnable的类，我们创建这个类的对象的同时就开启了线程，<font color="red"> 要注意的是继承自FRunnable的类是一个自定义类，即以F开头的类，并且自定义类在UE4的内容浏览器中是不显示的</font>。</p><p><strong>需要包含的头文件</strong></p><ul><li><p>#include “Runnable.h”</p></li><li><p>#include “RunnableThread.h”</p><p>或者我们也可以直接只包含#include “ThreadingBase.h”头文件，ThreadingBase.h里面就已经包含了线程所需要的所有的头文件</p></li></ul><h3 id="h"><a href="#h" class="headerlink" title=".h"></a><strong>.h</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CoreMinimal.h&quot;</span>#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Runnable.h&quot;</span>#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;RunnableThread.h&quot;</span>#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Networking.h&quot;</span><span class="hljs-comment">//#include &quot;ThreadingBase.h&quot;class MYGAME_API FReceiveThread : public FRunnable&#123;private:FRunnableThread* thread = nullptr;bool threadRuning;FSocket* socket;//需要读取消息的线程public:FString msg;private:virtual uint32 Run() override;virtual void Stop() override;public:FReceiveThread(FSocket* socket);~FReceiveThread();;&#125;;</span></span><br></code></pre></td></tr></table></figure><p><strong>.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;FReceiveThread.h&quot;</span>FReceiveThread::FReceiveThread(FSocket* socket)&#123;this-&gt;socket = socket;thread = FRunnableThread::Create(this, TEXT(<span class="hljs-meta-string">&quot;ReceiveThread&quot;</span>), 0);threadRuning = true;&#125;uint32 FReceiveThread::Run()&#123;<span class="hljs-meta-keyword">if</span> (!socket) return 0;TArray<span class="hljs-meta-string">&lt;uint8&gt; buff;int32 readType = 0;while (threadRuning)&#123;buff.Init(0, 1024u);socket-&gt;Recv(buff.GetData(), buff.Num(), readType);msg = FString(ANSI_TO_TCHAR(reinterpret_cast&lt;const char*&gt;(buff.GetData())));UE_LOG(LogTemp, Error, TEXT(&quot;%s&quot;), *msg);&#125;return 1;&#125;void FReceiveThread::Stop()&#123;threadRuning = false;if (thread) thread-&gt;WaitForCompletion();&#125;FReceiveThread::~FReceiveThread()&#123;threadRuning = false;delete thread;thread = NULL;&#125;</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C++】C++11新特性</title>
    <link href="/2021/03/17/%E3%80%90C++%E3%80%91C++11%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2021/03/17/%E3%80%90C++%E3%80%91C++11%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><a id="more"></a><h1 id="一、auto类型推导"><a href="#一、auto类型推导" class="headerlink" title="一、auto类型推导"></a>一、auto类型推导</h1><p>auto这个关键字其实在C++11之前就已经存在了，在C++98中的auto关键字的作用是指明变量的存储类型，与static相对，在比较老C++书籍中可以找得到相关内容，只是在我们的实际编程中基本上被忽略，这是因为我们在创建变量时默认的存储类型就是auto—自动存储类型的，不需要显示表示，只有在需要声明静态变量时才会显示表示static，以指明变量的存储类型为静态存储类型。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>这里a和b的存储类型都是auto类型。</p><p>在C++11之后，C++标准摒弃了C++98的auto关键字的用法，将auto关键字的功能换成了自动类型推导，就和现在大多数脚本语言中的var一样。</p><p><font color="red"> 需要注意的是，在自动类型推导中，小数会被默认推导成double类型而不是float。</font></p><p>auto的出现并不意味着C++变成了弱类型语言，auto在程序中仅仅只起到占位符的作用，在编译期间它才会被替换成具体的类型，所以在运行时类型依然是明确的。</p><p><font color="red">auto关键字支持多变量声明，但是同时声明的变量必须是同一类型的，否则会出现编译不通过的错误。</font>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> a = <span class="hljs-number">1</span>,b = <span class="hljs-number">1.1</span>;<br></code></pre></td></tr></table></figure><p>这种情况会报错。</p><p><font color="red"> 在声明auto变量时，必须对变量进行初始化。</font>这种情况是语法错误：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> a,b;<br></code></pre></td></tr></table></figure><h2 id="auto、指针与引用"><a href="#auto、指针与引用" class="headerlink" title="auto、指针与引用"></a>auto、指针与引用</h2><p>先来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">auto</span> *p1 = &amp;a;<br><span class="hljs-keyword">auto</span> p2 = &amp;a;<br><span class="hljs-keyword">auto</span> p3 = p1;<br><span class="hljs-keyword">auto</span> &amp;r1 = a;<br><span class="hljs-keyword">auto</span> r2 = r1;<br><br><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(p1).name() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(p2).name() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(p3).name() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(r1).name() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(r2).name() &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *<br><span class="hljs-keyword">int</span> *<br><span class="hljs-keyword">int</span> *<br><span class="hljs-keyword">int</span><br><span class="hljs-keyword">int</span><br></code></pre></td></tr></table></figure><p>可以看到<font color="red">auto推导出了指针类型，却忽略了&amp;类型</font>，这一点是需要注意的。</p><h2 id="auto与const"><a href="#auto与const" class="headerlink" title="auto与const"></a>auto与const</h2><p>还是先来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">auto</span> c1 = a;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> c2 = a;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> *p = &amp;a;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;r1 = a;<br><span class="hljs-keyword">auto</span> &amp;r2 = r1;<br><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(c1).name() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(c2).name() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(p).name() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(r1).name() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(r2).name() &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span><br><span class="hljs-keyword">int</span><br><span class="hljs-keyword">int</span> <span class="hljs-keyword">const</span> *<br><span class="hljs-keyword">int</span><br><span class="hljs-keyword">int</span><br></code></pre></td></tr></table></figure><p>可以看到除了指针类型，其他的都被推导成了int类型，我们再在上面的代码中加一些代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">auto</span> c1 = a;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> c2 = a;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> *p = &amp;a;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;r1 = a;<br><span class="hljs-keyword">auto</span> &amp;r2 = r1;<br><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(c1).name() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(c2).name() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(p).name() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(r1).name() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(r2).name() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br><span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>;<br>c1 = <span class="hljs-number">2</span>;<br>c2 = <span class="hljs-number">2</span>;<br>p = b;<br>r1 = <span class="hljs-number">2</span>;<br>r2 = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>当我们添加了这段代码之后，除了<code>c1=2</code>，其他的行都会报语法错误，所以尽c2，r1，r2被推导为int类型，但是const的约束依旧存在，但是c1没有报语法错误，也就是说c1实际上是非const类型，即<code>auto c1 = a</code>，在默认情况下auto将c1推导为非常量，如果需要设置为常量则需要显示标识const。</p><p>关于<code>typeid().name()</code> 有一点很迷，就是在C++的语法中，只有常量指针类型在类型名上带有const，如上面的int const *，而其他的无论是指针常量、常量引用在类型上都是忽略const的，但是在我们把一个变量常量的地址赋予一个非常量指针时，则会报：</p><p><img src="/2021/03/17/%E3%80%90C++%E3%80%91C++11%E6%96%B0%E7%89%B9%E6%80%A7/%E3%80%90UE4%E3%80%91UE4GamePlay%E6%9E%B6%E6%9E%84%5CSnipaste_2021-03-18_14-34-58.png"></p><p>在网上没有找到相关的解析，推测在C++语法上是只有常量指针类型带有const，没有其他的带有const的类型的，而出现上面的提示十有八九是编辑器做的，而非C++本身的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>auto的作用是类型推导，本质是占位符，在编译阶段，编译器会将正确的类型替换到auto位置上；</li><li>auto可以和任何类型搭配，包括指针与引用；</li><li>在声明auto变量时必须对uto变量初始化；</li><li>auto关键字可以用作函数返回值类型。</li></ul><h1 id="二、decltype类型推导"><a href="#二、decltype类型推导" class="headerlink" title="二、decltype类型推导"></a>二、decltype类型推导</h1><p>由于auto的使用在有些方面上收到限制，比如，声明auto变量时必须对变量进行初始化，而在实际使用时，可能没法进行初始化，于是decltype就出现了，decltype也是C++的一个关键字。</p><p>decltype通过表达式来推导类型，表达式可以是一个变量、常量、或者函数，使用形式为<code>decltype(exp),exp为表达式</code>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* a)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> *a * <span class="hljs-number">0.2f</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">decltype</span>(fun(&amp;b)) a;<br>&#125;<br></code></pre></td></tr></table></figure><p>和auto一样decltype也可以用作函数返回值类型。</p><h2 id="decltype与auto的区别"><a href="#decltype与auto的区别" class="headerlink" title="decltype与auto的区别"></a>decltype与auto的区别</h2><ul><li>auto关键字声明的变量必须初始化，decltype不需要；</li><li>auto在类中只能用于定义静态成员，decltype可以用于任何成员；</li><li>decltype的使用上比auto更灵活；</li><li>auto更具初始值来推导类型，decltype根据表达式来推导类型。</li></ul><h1 id="三、返回类型后置语法"><a href="#三、返回类型后置语法" class="headerlink" title="三、返回类型后置语法"></a>三、返回类型后置语法</h1><p>有时候我们写函数需要用到函数参数来推导，由于C++的返回值是前置语法，所以返回值是无法使用函数参数的，于是便有了返回值类型后置语法，先看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span> U&gt;<br>auto fun(T a,U b)-&gt;decltype(a+b)<br>&#123;<br><span class="hljs-keyword">return</span> a+b;<br>&#125;<br></code></pre></td></tr></table></figure><p>返回值类型后置语法可以将decltype使用参数推导出的类型赋予auto中，所以在这个语法中auto，decltype是必不可少的。</p><p>我们仔细思考后会发现好像直接这样使用也是可以达到最终效果的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">fun</span><span class="hljs-params">(T a,U b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a+b;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么返回值后置类型语法的作用又是什么呢？事实上我们在多想一下就会明白，<code>auto fun(T a,U b)-&gt;decltype(a+b)</code>语法把auto的类型限制在decltype(a+b)的推导类型的范围内了，而auto fun(T a,U b)中auto是可以为任何类型的。但是在大多数使用场景下似乎还是没什么区别。</p><p>到这里只有一句感叹，C++在类型推导上相较于主流脚本语言的类型推导还是薄弱了很多很多。</p><h1 id="四、左值与右值"><a href="#四、左值与右值" class="headerlink" title="四、左值与右值"></a>四、左值与右值</h1>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPlus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Python】Python学习笔记</title>
    <link href="/2021/02/04/%E3%80%90Python%E3%80%91Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/02/04/%E3%80%90Python%E3%80%91Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><center><font size="6"><strong>Python基础</strong></font></center><a id="more"></a><h1 id="一、中文编码、注释与标准文档"><a href="#一、中文编码、注释与标准文档" class="headerlink" title="一、中文编码、注释与标准文档"></a>一、中文编码、注释与标准文档</h1><h2 id="1-中文编码"><a href="#1-中文编码" class="headerlink" title="1.中文编码"></a>1.中文编码</h2><p>若只需要在单个文件中指定中文编码，只需在文件开始处添加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># _*_ coding: UTF-8 _*_</span><br></code></pre></td></tr></table></figure><p>即可。</p><p>如果要在整个工程里设置中文编码，则需要在编辑器中设置工程的编码为UTF-8。</p><h2 id="2-单行注释"><a href="#2-单行注释" class="headerlink" title="2.单行注释"></a>2.单行注释</h2><p>python使用<code>#</code>来接单行注释</p><h2 id="3-多行注释"><a href="#3-多行注释" class="headerlink" title="3.多行注释"></a>3.多行注释</h2><p>python使用<code>&#39;&#39;&#39;</code>或<code>&quot;&quot;&quot;</code>（三个单引号或三个双引号）来包含多行注释</p><p>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这是单行注释</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">这是使用三个单引号的</span><br><span class="hljs-string">多行注释</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">这是使用三个双引号的</span><br><span class="hljs-string">多行注释</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h2 id="4-标准文档"><a href="#4-标准文档" class="headerlink" title="4.标准文档"></a>4.标准文档</h2><p><a href="https://docs.python.org/zh-cn/3.7/library/index.html">官方文档</a></p><h1 id="二、标识符与代码块"><a href="#二、标识符与代码块" class="headerlink" title="二、标识符与代码块"></a>二、标识符与代码块</h1><h2 id="1-标识符规则"><a href="#1-标识符规则" class="headerlink" title="1.标识符规则"></a>1.标识符规则</h2><ul><li>python标识符大小写敏感。</li><li>python中以下划线开头的标识符有特殊的含义，以单下划线开头的标识符代表不能直接访问的类属性，需要通过类提供的接口进行访问，不能用from xxx import *导入，如：_value。</li><li>以双下划线开头的标识符代表类的私有成员，如：<code>__value</code>。</li><li>以双下划线开头和结尾的标识符代表python里特殊方法的专用标识符，如：<code>__init__()</code>代表类的构造函数。</li></ul><h2 id="2-保留字符"><a href="#2-保留字符" class="headerlink" title="2.保留字符"></a>2.保留字符</h2><table><thead><tr><th align="center"></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">and</td><td align="center">exec</td><td align="center">not</td></tr><tr><td align="center">assert</td><td align="center">finally</td><td align="center">or</td></tr><tr><td align="center">break</td><td align="center">for</td><td align="center">pass</td></tr><tr><td align="center">class</td><td align="center">from</td><td align="center">print</td></tr><tr><td align="center">continue</td><td align="center">global</td><td align="center">raise</td></tr><tr><td align="center">def</td><td align="center">if</td><td align="center">return</td></tr><tr><td align="center">del</td><td align="center">import</td><td align="center">try</td></tr><tr><td align="center">elif</td><td align="center">in</td><td align="center">while</td></tr><tr><td align="center">else</td><td align="center">is</td><td align="center">with</td></tr><tr><td align="center">except</td><td align="center">lambda</td><td align="center">yield</td></tr></tbody></table><h2 id="3-代码块"><a href="#3-代码块" class="headerlink" title="3.代码块"></a>3.代码块</h2><p>python与C系列语言最大的不同就是python没有了<code>&#123;&#125;</code>囊括的代码块，而采用了<font color="red">缩进</font>来表示代码块，即在一个代码块中的代码采用同等数量的数量的缩进，缩进的数量按空格的数量计算，采用同一缩进量的代码属于同一格代码块。</p><p>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> ture:<br>    a = <span class="hljs-number">1</span><br>    b = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><code>a=1;</code>与<code>b=2</code>同属于if语句的代码块中。</p><h3 id="python空行规范"><a href="#python空行规范" class="headerlink" title="python空行规范"></a>python空行规范</h3><ul><li><p>类与其他代码块之间需要空两行</p></li><li><p>方法体与其他代码块之间需要空一行</p></li><li><p>全局函数与其他代码块之间需要空两行</p><p>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><br>    names = <span class="hljs-string">&#x27;aa&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, age, name</span>):</span><br>        self.age = age<br>        self.name = name<br>        addr = <span class="hljs-string">&#x27;beijing&#x27;</span><br>        names = <span class="hljs-string">&quot;bb&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">GetName</span>(<span class="hljs-params">self</span>):</span><br>        self.sex = <span class="hljs-string">&#x27;female&#x27;</span><br>        print(<span class="hljs-string">&#x27;my name is &#x27;</span> + self.names)<br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">PP</span>():</span><br>        print(names)<br>    <br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">OO</span>(<span class="hljs-params">cls</span>):</span>       <br>        print(cls.names)<br><br><br>p = Person(<span class="hljs-number">18</span>, <span class="hljs-string">&#x27;lusa&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul><h2 id="4-多行语句"><a href="#4-多行语句" class="headerlink" title="4.多行语句"></a>4.多行语句</h2><p>由于python即使用了<code>;</code>来分割同行的不同语句，同时通过新行来结束上一句语句，所以如果代码需要换行的话需要使用<font color="red"> <code>\</code></font>来分割多行。</p><p>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = b \<br>+ c \<br>    + d<br></code></pre></td></tr></table></figure><p><font color="green"> <strong>例外</strong>：包括在<code>[]</code>、<code>()</code>、<code>&#123;&#125;</code>中的语句换行不需要使用<code>\</code>。</font></p><h1 id="三、变量及数据结构"><a href="#三、变量及数据结构" class="headerlink" title="三、变量及数据结构"></a>三、变量及数据结构</h1><p>python支持</p><ul><li>Numbers-数字</li><li>String-字符串</li><li>List-列表</li><li>Tuple-原表</li><li>Dictionary-字典</li></ul><p>几种数据类型。</p><h2 id="1-Numbers"><a href="#1-Numbers" class="headerlink" title="1.Numbers"></a>1.Numbers</h2><p>其中Numbers又分为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph LR;<br>Numbers---int---有符号整型;<br>Numbers---long---长整型-使用小写l或大写L表示;<br>Numbers---float---浮点型;<br>Numbers---complex---复数-使用a+bj表示或complex函数生成;<br></code></pre></td></tr></table></figure><p>需要注意的是python不支持double。</p><p><font color="red"> long在python3.x以后被移除。</font></p><h2 id="2-String"><a href="#2-String" class="headerlink" title="2.String"></a>2.String</h2><p><font color="red">使用Python字符串时首先需要明确一点，就是Python不支持单字符，在Python中单字符也被当作字符串使用。</font></p><p>Python的字符串可以使用<code>&#39;</code>,<code>&quot;</code>,<code>&#39;&#39;&#39;</code>,<code>&quot;&quot;&quot;</code>来标识字符串，有单引号和双引号来表示字符串就够了，那么为什么Python要使用三单引号<code>&#39;&#39;&#39;</code>和三双引号<code>&quot;&quot;&quot;</code>来标识字符串呢？</p><h3 id="39-39-39-和-quot-quot-quot-的优点"><a href="#39-39-39-和-quot-quot-quot-的优点" class="headerlink" title="&#39;&#39;&#39;和&quot;&quot;&quot;的优点"></a><code>&#39;&#39;&#39;</code>和<code>&quot;&quot;&quot;</code>的优点</h3><p>要想直观的了解三单引号和三双引号的优点，我们首先使用C#字符串来写一个SQL语句</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">string</span> sql=<span class="hljs-string">&quot;select xm as 姓名,xb as 性别 from db_table where xm = @xm and xb = @xb and (bm like &#x27;%666&#x27; or bm like &#x27;666%&#x27;) order by grade &gt; 90 desc&quot;</span>;<br>OleDbCommand cmd = <span class="hljs-keyword">new</span> OleDbCommand();<br>cmd.CommandText = sql;<br>cmd.Parameters.AddWithValue(<span class="hljs-string">&quot;@xm&quot;</span>, txtName.Text);<br>cmd.Parameters.AddWithValue(<span class="hljs-string">&quot;@xb&quot;</span>, txtSex.Text);<br>cmd.Connection = conn;<br>conn.Open();<br>cmd.ExecuteNonQuery();<br></code></pre></td></tr></table></figure><p>我们再使用Python写一句同样的SQL语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Python">sql = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">select xm as 姓名,xb as 性别 from db_table </span><br><span class="hljs-string">where xm = &#x27;&#123;0&#125;&#x27; and xb = &#123;1&#125; and (bm like &#x27;%666&#x27; or bm like &#x27;666%&#x27;) </span><br><span class="hljs-string">order by grade &gt; 90 desc</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>.<span class="hljs-built_in">format</span>(txtName.Text,txtSex.Text)<br>cuesor = conn.cursor()<br>cursor.execute(sql)<br>cursor.close()<br></code></pre></td></tr></table></figure><p>有没有发现Python在写sql字符串时十分优雅呢？尤其是在写很长的sql语句时这个效果尤为突出，得益于Python三引号字符串的可换行支持，Python的sql可以在传参的同时保留sql的优雅格式，极大的提高了sql的可阅读性。</p><p>python的字符串是不可变的，当我们对字符串进行操作时，python都会生成新的字符串，而不会在旧的字符串的基础上进行修改。</p><ul><li>与C系列语言对字符串的操作有些差异的是python使用<code>*</code>来重复字符串，如：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;a&#x27;</span><br>str2 = <span class="hljs-built_in">str</span>*<span class="hljs-number">2</span> <span class="hljs-comment">#str2存储的是&#x27;aa&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>String支持从前索引和从后索引，从前索引的首地址索引为0，从后索引的末地址为-1</li></ul><table><thead><tr><th align="center">a</th><th align="center">b</th><th align="center">c</th><th align="center">d</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">3</td></tr><tr><td align="center">-4</td><td align="center">-3</td><td align="center">-2</td><td align="center">-1</td></tr></tbody></table><ul><li>python支持直接通过索引截取子字符串，如：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;abcd&#x27;</span><br>str2 = <span class="hljs-built_in">str</span>[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>] <span class="hljs-comment">#str2存储的是&#x27;bc&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="转移字符"><a href="#转移字符" class="headerlink" title="转移字符"></a>转移字符</h3><table><thead><tr><th>字符</th><th>说明</th></tr></thead><tbody><tr><td><code>\</code>(在行尾时)</td><td>续行符</td></tr><tr><td>\</td><td>反斜杠符号</td></tr><tr><td>&#39;</td><td>单引号</td></tr><tr><td>&quot;</td><td>双引号</td></tr><tr><td>\a</td><td>响铃</td></tr><tr><td>\b</td><td>退格(Backspace)</td></tr><tr><td>\e</td><td>转义</td></tr><tr><td>\000</td><td>空</td></tr><tr><td>\n</td><td>换行</td></tr><tr><td>\v</td><td>纵向制表符</td></tr><tr><td>\t</td><td>横向制表符</td></tr><tr><td>\r</td><td>回车</td></tr><tr><td>\f</td><td>换页</td></tr><tr><td>\oyy</td><td>八进制数，y 代表 0~7 的字符，例如：\012 代表换行</td></tr><tr><td>\xyy</td><td>十六进制数，以 \x 开头，yy代表的字符，例如：\x0a代表换行</td></tr><tr><td>\other</td><td>其它的字符以普通格式输出</td></tr></tbody></table><h3 id="两个特殊的字符串运算符"><a href="#两个特殊的字符串运算符" class="headerlink" title="两个特殊的字符串运算符"></a>两个特殊的字符串运算符</h3><table><thead><tr><th>字符</th><th>说明</th><th>实例</th></tr></thead><tbody><tr><td>r/R</td><td><font color="red">原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母<code>r</code>（可以大小写）以外，与普通字符串有着几乎完全相同的语法。</font></td><td>print(r’/n’)<br>输出结果：<br>/n</td></tr><tr><td>%</td><td>格式字符串</td><td></td></tr><tr><td>u</td><td>在字符串的前面加上一个字母u即表示创建Unicode字符串，可以通过<code>\u</code>+Unicode编码向字符串中插入任何Unicode支持的字符</td><td>print(u’a\u2201a’)<br>输出结果：<br>a⤀a</td></tr></tbody></table><h3 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><p>Python中的字符串格式化和C基本保持一致，插入整型也是用的<code>%d</code></p><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>%c</td><td>格式化字符及其ASCII码</td></tr><tr><td>%s</td><td>格式化字符串</td></tr><tr><td>%d</td><td>格式化整数</td></tr><tr><td>%u</td><td>格式化无符号整型</td></tr><tr><td>%o</td><td>格式化无符号八进制数</td></tr><tr><td>%x</td><td>格式化无符号十六进制数</td></tr><tr><td>%X</td><td>格式化无符号十六进制数（大写）</td></tr><tr><td>%f</td><td>格式化浮点数字，可指定小数点后的精度</td></tr><tr><td>%e</td><td>用科学计数法格式化浮点数</td></tr><tr><td>%E</td><td>作用同%e，用科学计数法格式化浮点数</td></tr><tr><td>%g</td><td>%f和%e的简写</td></tr><tr><td>%G</td><td>%F 和 %E 的简写</td></tr><tr><td>%p</td><td>用十六进制数格式化变量的地址</td></tr></tbody></table><h3 id="格式化操作辅助指令"><a href="#格式化操作辅助指令" class="headerlink" title="格式化操作辅助指令"></a>格式化操作辅助指令</h3><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>定义宽度或者小数点精度</td></tr><tr><td>-</td><td>用做左对齐</td></tr><tr><td>+</td><td>在正数前面显示加号( + )</td></tr><tr><td><code>&lt;sp&gt;</code></td><td>在正数前面显示空格</td></tr><tr><td>#</td><td>在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’)</td></tr><tr><td>0</td><td>显示的数字前面填充’0’而不是默认的空格</td></tr><tr><td>%</td><td>‘%%’输出一个单一的’%’</td></tr><tr><td>(var)</td><td>映射变量(字典参数)</td></tr><tr><td>m.n.</td><td>m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)</td></tr></tbody></table><h3 id="String内置函数"><a href="#String内置函数" class="headerlink" title="String内置函数"></a>String内置函数</h3><table><thead><tr><th align="left"><strong>方法</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/python/att-string-capitalize.html">string.capitalize()</a></td><td align="left">把字符串的第一个字符大写</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-center.html">string.center(width)</a></td><td align="left">返回一个原字符串居中,并使用空格填充至长度 width 的新字符串</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-count.html">string.count(str, beg=0, end=len(string))</a></strong></td><td align="left">返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-decode.html">string.decode(encoding=’UTF-8’, errors=’strict’)</a></td><td align="left">以 encoding 指定的编码格式解码 string，如果出错默认报一个 ValueError 的 异 常 ， 除非 errors 指 定 的 是 ‘ignore’ 或 者’replace’</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-encode.html">string.encode(encoding=’UTF-8’, errors=’strict’)</a></td><td align="left">以 encoding 指定的编码格式编码 string，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-endswith.html">string.endswith(obj, beg=0, end=len(string))</a></strong></td><td align="left">检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-expandtabs.html">string.expandtabs(tabsize=8)</a></td><td align="left">把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8。</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-find.html">string.find(str, beg=0, end=len(string))</a></strong></td><td align="left">检测 str 是否包含在 string 中，如果 beg 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回-1</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-format.html">string.format()</a></strong></td><td align="left">格式化字符串</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-index.html">string.index(str, beg=0, end=len(string))</a></strong></td><td align="left">跟find()方法一样，只不过如果str不在 string中会报一个异常.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-isalnum.html">string.isalnum()</a></td><td align="left">如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True,否则返回 False</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-isalpha.html">string.isalpha()</a></td><td align="left">如果 string 至少有一个字符并且所有字符都是字母则返回 True,否则返回 False</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-isdecimal.html">string.isdecimal()</a></td><td align="left">如果 string 只包含十进制数字则返回 True 否则返回 False.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-isdigit.html">string.isdigit()</a></td><td align="left">如果 string 只包含数字则返回 True 否则返回 False.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-islower.html">string.islower()</a></td><td align="left">如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-isnumeric.html">string.isnumeric()</a></td><td align="left">如果 string 中只包含数字字符，则返回 True，否则返回 False</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-isspace.html">string.isspace()</a></td><td align="left">如果 string 中只包含空格，则返回 True，否则返回 False.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-istitle.html">string.istitle()</a></td><td align="left">如果 string 是标题化的(见 title())则返回 True，否则返回 False</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-isupper.html">string.isupper()</a></td><td align="left">如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-join.html">string.join(seq)</a></strong></td><td align="left">以 string 作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-ljust.html">string.ljust(width)</a></td><td align="left">返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-lower.html">string.lower()</a></td><td align="left">转换 string 中所有大写字符为小写.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-lstrip.html">string.lstrip()</a></td><td align="left">截掉 string 左边的空格</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-maketrans.html">string.maketrans(intab, outtab])</a></td><td align="left">maketrans() 方法用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-max.html">max(str)</a></td><td align="left">返回字符串 <em>str</em> 中最大的字母。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-min.html">min(str)</a></td><td align="left">返回字符串 <em>str</em> 中最小的字母。</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-partition.html">string.partition(str)</a></strong></td><td align="left">有点像 find()和 split()的结合体,从 str 出现的第一个位置起,把 字 符 串 string 分 成 一 个 3 元 素 的 元 组 (string_pre_str,str,string_post_str),如果 string 中不包含str 则 string_pre_str == string.</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-replace.html">string.replace(str1, str2, num=string.count(str1))</a></strong></td><td align="left">把 string 中的 str1 替换成 str2,如果 num 指定，则替换不超过 num 次.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-rfind.html">string.rfind(str, beg=0,end=len(string) )</a></td><td align="left">类似于 find() 函数，返回字符串最后一次出现的位置，如果没有匹配项则返回 -1。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-rindex.html">string.rindex( str, beg=0,end=len(string))</a></td><td align="left">类似于 index()，不过是从右边开始.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-rjust.html">string.rjust(width)</a></td><td align="left">返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-rpartition.html">string.rpartition(str)</a></td><td align="left">类似于 partition()函数,不过是从右边开始查找</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-rstrip.html">string.rstrip()</a></td><td align="left">删除 string 字符串末尾的空格.</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-split.html">string.split(str=””, num=string.count(str))</a></strong></td><td align="left">以 str 为分隔符切片 string，如果 num 有指定值，则仅分隔 num+ 个子字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-splitlines.html">string.splitlines(keepends)</a></td><td align="left">按照行(‘\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-startswith.html">string.startswith(obj, beg=0,end=len(string))</a></td><td align="left">检查字符串是否是以 obj 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查.</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-strip.html">string.strip(obj)</a></strong></td><td align="left">在 string 上执行 lstrip()和 rstrip()</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-swapcase.html">string.swapcase()</a></td><td align="left">翻转 string 中的大小写</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-title.html">string.title()</a></td><td align="left">返回”标题化”的 string,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-translate.html">string.translate(str, del=””)</a></strong></td><td align="left">根据 str 给出的表(包含 256 个字符)转换 string 的字符,要过滤掉的字符放到 del 参数中</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-upper.html">string.upper()</a></td><td align="left">转换 string 中的小写字母为大写</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-zfill.html">string.zfill(width)</a></td><td align="left">返回长度为 width 的字符串，原字符串 string 右对齐，前面填充0</td></tr></tbody></table><h2 id="3-Tuple"><a href="#3-Tuple" class="headerlink" title="3.Tuple"></a>3.Tuple</h2><p>==元组类似与C#中<code>readonly List</code>，是一个只读列表，但是python的元组的元素可以是不同的类型，python用<code>()</code>来表示元组。==元组支持存储不同类型元素，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">t = (<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3.14</span>)<br></code></pre></td></tr></table></figure><p>这里的元组只读及元素不可修改</p><h3 id="创建空元组"><a href="#创建空元组" class="headerlink" title="创建空元组"></a>创建空元组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">t = ()<br></code></pre></td></tr></table></figure><h3 id="创建一个值的元组"><a href="#创建一个值的元组" class="headerlink" title=" 创建一个值的元组"></a><font color="red"> 创建一个值的元组</font></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">t = (<span class="hljs-number">12</span>,)//逗号不可省略<br></code></pre></td></tr></table></figure><p><font color="red"> 需要特别注意的是<code>,</code>不可省略，如果省略了，<code>t=(12)</code>就等于<code>t=12</code></font></p><h3 id="元组的分片操作"><a href="#元组的分片操作" class="headerlink" title="元组的分片操作"></a>元组的分片操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">t = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)<br>print(t[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>])<br><span class="hljs-comment">#输出结果为2，3</span><br></code></pre></td></tr></table></figure><p>分片操作可以批量的取元组中的数据，值不能取到3号索引，只能取到3号索引的前一位。</p><h3 id="Tuple的-和-操作"><a href="#Tuple的-和-操作" class="headerlink" title="Tuple的+和*操作"></a>Tuple的+和*操作</h3><p>和字符串一样，列表的+运算用于组合列表，列表的*运算用于重复列表，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">tu1 = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>tu2 = tu1 + tu1<br>print(tu2)<br>tu3 = tu1*<span class="hljs-number">3</span><br>print(tu3)<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]  <br></code></pre></td></tr></table></figure><h3 id="Tuple的无关分隔符"><a href="#Tuple的无关分隔符" class="headerlink" title="Tuple的无关分隔符"></a>Tuple的无关分隔符</h3><p>任意无符号对象，只要以<code>,</code>分隔，Python都将其是为元组，如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span> <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">3.14</span><br>tu = x, y = <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span><br></code></pre></td></tr></table></figure><p><code>1, 2, &#39;a&#39;, 3.14</code>，会被视为一个元组，及print打印的事实上是一个元组，tu也会被Python默认转换成一个元组，当然x，y还是可以才开使用的。</p><h3 id="Python内置元组操作函数"><a href="#Python内置元组操作函数" class="headerlink" title="Python内置元组操作函数"></a>Python内置元组操作函数</h3><table><thead><tr><th align="left">方法</th><th>描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/python/att-tuple-cmp.html">cmp(tuple1, tuple2)</a></td><td>比较两个元组元素。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-tuple-len.html">len(tuple)</a></td><td>计算元组元素个数。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-tuple-max.html">max(tuple)</a></td><td>返回元组中元素最大值。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-tuple-min.html">min(tuple)</a></td><td>返回元组中元素最小值。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-tuple-tuple.html">tuple(seq)</a></td><td>将列表转换为元组。</td></tr></tbody></table><h2 id="4-List"><a href="#4-List" class="headerlink" title="4.List"></a>4.List</h2><p>List就和C#中的List基本一致，但是python的List更灵活</p><h3 id="List初始化"><a href="#List初始化" class="headerlink" title="List初始化"></a>List初始化</h3><p>List的初始化使用<code>[]</code>，我们可以使用‘数字’、‘字符串’、‘元组’或‘列表’来初始化一个列表，列表也支持分片操作。</p><p>python的列表可以在一个列表中存储不同类型的元素。</p><p>并且提供一些基础函数</p><ul><li><p>index：从列表中找出某个元素的位置，如果有多个相同的元素，则返回第一个元素的位置，如果没有找到则抛出异常。</p></li><li><p>count：统计某个元素在列表中出现的次数。</p></li><li><p>append：列表末尾增加新的元素。</p></li><li><p>extend：将一个新列表的元素添加到原列表中。</p><p>注意到，虽然 append 和 extend 可接收一个列表作为参数，但是 append 方法是将其作为一个元素添加到列表中，而 extend 则是将新列表的元素逐个添加到原列表中。</p></li><li><p>insert：将某个元素添加到某个位置。</p></li><li><p>pop：移除列表中的一个元素（默认是最后一个），并且返回该元素的值。</p></li><li><p>remove：移除列表中的某个匹配元素，如果有多个匹配，则移除第一个。</p></li><li><p>reverse：将列表中的元素进行反转。</p></li><li><p>sort：对列表进行排序，注意该方法会改变原来的列表，而不是返回新的排序列表，另外，sort 方法的返回值是空。</p><p>如果要使用sort对列表进行排序，那么列表中元素应该保持同一类型。</p></li><li><p>clear：清空列表。</p></li></ul><h3 id="列表的集合运算"><a href="#列表的集合运算" class="headerlink" title="列表的集合运算"></a>列表的集合运算</h3><p>Python提供内置的<code>set()</code>函数来对元素集进行集合运算，set函数支持所有可迭代的对象，包括list和tuple。只要是set函数支持的对象，尽管进行运算的两个对象不是相同类型也依旧可以进行集合运算，如：</p><p><strong>取交集</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">l1 = [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-literal">True</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>l2 = (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-literal">True</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br>print(<span class="hljs-built_in">set</span>(l1) &amp; <span class="hljs-built_in">set</span>(l2))<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-number">1</span>， <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p><font color="red"> 注意：当bool值进行集合运算时会被转换成0和1，但是这个0和1不会和数字的0和1重复。</font></p><p>Python集合运算符</p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>|</td><td>取并集</td></tr><tr><td>&amp;</td><td>取交集</td></tr><tr><td>-</td><td>取差集</td></tr><tr><td>^</td><td>取对称差集</td></tr></tbody></table><p><font color="red"> 集合运算符支持<code>set()</code>函数返回的<code>set</code>集合作为运算对象。</font></p><h3 id="List的-和-操作"><a href="#List的-和-操作" class="headerlink" title="List的+和*操作"></a>List的+和*操作</h3><p>和字符串一样，列表的+运算用于组合列表，列表的*运算用于重复列表，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">li = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>li2 = li + li<br>print(li2)<br>li3 = li*<span class="hljs-number">3</span><br>print(li3)<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]  <br></code></pre></td></tr></table></figure><h3 id="Python内置列表操作函数"><a href="#Python内置列表操作函数" class="headerlink" title="Python内置列表操作函数"></a>Python内置列表操作函数</h3><table><thead><tr><th align="left">函数</th><th>描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/python/att-list-cmp.html">cmp(list1, list2)</a></td><td>比较两个列表的元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-list-len.html">len(list)</a></td><td>列表元素个数</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-list-max.html">max(list)</a></td><td>返回列表元素最大值</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-list-min.html">min(list)</a></td><td>返回列表元素最小值</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-list-list.html">list(seq)</a></td><td>将元组转换为列表</td></tr></tbody></table><h3 id="List内置函数"><a href="#List内置函数" class="headerlink" title="List内置函数"></a>List内置函数</h3><table><thead><tr><th align="left">方法</th><th>描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/python/att-list-append.html">list.append(obj)</a></td><td>在列表末尾添加新的对象</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-list-count.html">list.count(obj)</a></td><td>统计某个元素在列表中出现的次数</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-list-extend.html">list.extend(seq)</a></td><td>在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-list-index.html">list.index(obj)</a></td><td>从列表中找出某个值第一个匹配项的索引位置</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-list-insert.html">list.insert(index, obj)</a></td><td>将对象插入列表</td></tr><tr><td align="left">[list.pop(<a href="https://www.runoob.com/python/att-list-pop.html">index=-1])</a></td><td>移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-list-remove.html">list.remove(obj)</a></td><td>移除列表中某个值的第一个匹配项</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-list-reverse.html">list.reverse()</a></td><td>反向列表中元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-list-sort.html">list.sort(cmp=None, key=None, reverse=False)</a></td><td>对原列表进行排序</td></tr></tbody></table><h2 id="5-Dictionary"><a href="#5-Dictionary" class="headerlink" title="5.Dictionary"></a>5.Dictionary</h2><p>Python的字典和C#中的字典的用法基本一致，不同的时Python使用<code>&#123;&#125;</code>来创建字典，使用<code>:</code>来连接键值对，使用<code>,</code>来分割元素。如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">dic = &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-literal">True</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&quot;Py&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>: <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><p>Python自定更强大的地方在于，Python字典在一个字典里支持不同类型的键和值。</p><p><font color="red"> 字典的键只能是数字、字符串或元组类型，而值没有任何要求。</font></p><h3 id="Python内置字典操作函数"><a href="#Python内置字典操作函数" class="headerlink" title="Python内置字典操作函数"></a>Python内置字典操作函数</h3><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/python/att-dictionary-cmp.html">cmp(dict1, dict2)</a></td><td>比较两个字典元素。</td></tr><tr><td><a href="https://www.runoob.com/python/att-dictionary-len.html">len(dict)</a></td><td>计算字典元素个数，即键的总数。</td></tr><tr><td><a href="https://www.runoob.com/python/att-dictionary-str.html">str(dict)</a></td><td>输出字典可打印的字符串表示。</td></tr><tr><td><a href="https://www.runoob.com/python/att-dictionary-type.html">type(variable)</a></td><td>返回输入的变量类型，如果变量是字典就返回字典类型。</td></tr></tbody></table><h3 id="Dictionary内置函数"><a href="#Dictionary内置函数" class="headerlink" title="Dictionary内置函数"></a>Dictionary内置函数</h3><table><thead><tr><th align="left">函数</th><th>描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/python/att-dictionary-clear.html">dict.clear()</a></td><td>删除字典内所有元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-dictionary-copy.html">dict.copy()</a></td><td>返回一个字典的浅复制</td></tr><tr><td align="left">[dict.fromkeys(seq<a href="https://www.runoob.com/python/att-dictionary-fromkeys.html">, val])</a></td><td>创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-dictionary-get.html">dict.get(key, default=None)</a></td><td>返回指定键的值，如果值不在字典中返回default值</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-dictionary-has_key.html">dict.has_key(key)</a></td><td>如果键在字典dict里返回true，否则返回false</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-dictionary-items.html">dict.items()</a></td><td>以列表返回可遍历的(键, 值) 元组数组</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-dictionary-keys.html">dict.keys()</a></td><td>以列表返回一个字典所有的键</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-dictionary-setdefault.html">dict.setdefault(key, default=None)</a></td><td>和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-dictionary-update.html">dict.update(dict2)</a></td><td>把字典dict2的键/值对更新到dict里</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-dictionary-values.html">dict.values()</a></td><td>以列表返回字典中的所有值</td></tr><tr><td align="left">[pop(key<a href="https://www.runoob.com/python/python-att-dictionary-pop.html">,default])</a></td><td>删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/python-att-dictionary-popitem.html">popitem()</a></td><td>返回并删除字典中的最后一对键和值。</td></tr></tbody></table><h2 id="6-日期和时间"><a href="#6-日期和时间" class="headerlink" title="6.日期和时间"></a>6.日期和时间</h2><p>Python的日期时间函数被放在了<code>time</code>、<code>datetime</code>和<code>calender</code>模块下，这里有几个点是需要注意的</p><h3 id="time-time"><a href="#time-time" class="headerlink" title="time.time()"></a>time.time()</h3><p>time.time()函数返回的是从1970年1月1日午夜到当前时间所经过的总时长。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br>print(time.time())<br><span class="hljs-comment">#当前时间为：2021.2.6 09：51</span><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1612576137.817901</span><br></code></pre></td></tr></table></figure><h3 id="time-localtime"><a href="#time-localtime" class="headerlink" title="time.localtime()"></a>time.localtime()</h3><p>那么如何输出当前时间呢？答案就是使用<code>time.localtime(time.time())</code>来计算当前时间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br>print(time.localtime(time.time()))<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">time.struct_time(tm_year=<span class="hljs-number">2021</span>, tm_mon=<span class="hljs-number">2</span>, tm_mday=<span class="hljs-number">6</span>, tm_hour=<span class="hljs-number">9</span>, tm_min=<span class="hljs-number">51</span>, tm_sec=<span class="hljs-number">39</span>, tm_wday=<span class="hljs-number">5</span>, tm_yday=<span class="hljs-number">37</span>, tm_isdst=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>可以看到，函数返回的不是格式化的<code>2021.2.6 9:51</code>而是一个<code>struct_time</code>时间元组，什么是时间元组？</p><h3 id="时间元组"><a href="#时间元组" class="headerlink" title="时间元组"></a>时间元组</h3><p>很多Python函数用一个元组装起来的9组数字处理时间:</p><table><thead><tr><th align="left">序号</th><th align="left">字段</th><th align="left">值</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">4位数年</td><td align="left">2008</td></tr><tr><td align="left">1</td><td align="left">月</td><td align="left">1 到 12</td></tr><tr><td align="left">2</td><td align="left">日</td><td align="left">1到31</td></tr><tr><td align="left">3</td><td align="left">小时</td><td align="left">0到23</td></tr><tr><td align="left">4</td><td align="left">分钟</td><td align="left">0到59</td></tr><tr><td align="left">5</td><td align="left">秒</td><td align="left">0到61 (60或61 是闰秒)</td></tr><tr><td align="left">6</td><td align="left">一周的第几日</td><td align="left">0到6 (0是周一)</td></tr><tr><td align="left">7</td><td align="left">一年的第几日</td><td align="left">1到366 (儒略历)</td></tr><tr><td align="left">8</td><td align="left">夏令时</td><td align="left">-1, 0, 1, -1是决定是否为夏令时的旗帜</td></tr></tbody></table><p>而struct_time就是其中之一，struct_time的结构：</p><table><thead><tr><th align="left">序号</th><th align="left">属性</th><th align="left">值</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">tm_year</td><td align="left">2021</td></tr><tr><td align="left">1</td><td align="left">tm_mon</td><td align="left">1 到 12</td></tr><tr><td align="left">2</td><td align="left">tm_mday</td><td align="left">1 到 31</td></tr><tr><td align="left">3</td><td align="left">tm_hour</td><td align="left">0 到 23</td></tr><tr><td align="left">4</td><td align="left">tm_min</td><td align="left">0 到 59</td></tr><tr><td align="left">5</td><td align="left">tm_sec</td><td align="left">0 到 61 (60或61 是闰秒)</td></tr><tr><td align="left">6</td><td align="left">tm_wday</td><td align="left">0到6 (0是周一)</td></tr><tr><td align="left">7</td><td align="left">tm_yday</td><td align="left">1 到 366(儒略历)</td></tr><tr><td align="left">8</td><td align="left">tm_isdst</td><td align="left">-1, 0, 1, -1是决定是否为夏令时的旗帜</td></tr></tbody></table><h3 id="获取格式化时间"><a href="#获取格式化时间" class="headerlink" title="获取格式化时间"></a>获取格式化时间</h3><p>那么如何获取格式化时间呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">print(time.asctime(time.localtime(time.time())))<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">Sat Feb  <span class="hljs-number">6</span> <span class="hljs-number">10</span>:<span class="hljs-number">28</span>:09 <span class="hljs-number">2021</span><br></code></pre></td></tr></table></figure><p>time.localtime()返回的是一个字符串，除此之外我们看还可以使用<font color="red"><code>time.strftime()</code></font>函数来自定义时间格式化格式，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">print(time.strftime(<span class="hljs-string">&quot;%H:%M:%S %Y-%m-%d&quot;</span>, time.localtime()))<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">10</span>:<span class="hljs-number">51</span>:<span class="hljs-number">12</span> <span class="hljs-number">2021</span>-02-06<br></code></pre></td></tr></table></figure><h3 id="时间日期格式化符号"><a href="#时间日期格式化符号" class="headerlink" title="时间日期格式化符号"></a>时间日期格式化符号</h3><table><thead><tr><th>符号</th><th>描述</th></tr></thead><tbody><tr><td>%y</td><td>两位数的年份表示（00-99）</td></tr><tr><td>%Y</td><td>四位数的年份表示（000-9999）</td></tr><tr><td>%m</td><td>月份（01-12）</td></tr><tr><td>%d</td><td>月内中的一天（0-31）</td></tr><tr><td>%H</td><td>24小时制小时数（0-23）</td></tr><tr><td>%I</td><td>12小时制小时数（01-12）</td></tr><tr><td>%M</td><td>分钟数（00-59）</td></tr><tr><td>%S</td><td>秒（00-59）</td></tr><tr><td>%a</td><td>本地简化星期名称</td></tr><tr><td>%A</td><td>本地完整星期名称</td></tr><tr><td>%b</td><td>本地简化的月份名称</td></tr><tr><td>%B</td><td>本地完整的月份名称</td></tr><tr><td>%c</td><td>本地相应的日期表示和时间表示</td></tr><tr><td>%j</td><td>年内的一天（001-366）</td></tr><tr><td>%p</td><td>本地A.M.或P.M.的等价符</td></tr><tr><td>%U</td><td>一年中的星期数（00-53）星期天为星期的开始</td></tr><tr><td>%w</td><td>星期（0-6），星期天为星期的开始</td></tr><tr><td>%W</td><td>一年中的星期数（00-53）星期一为星期的开始</td></tr><tr><td>%x</td><td>本地相应的日期表示</td></tr><tr><td>%X</td><td>本地相应的时间表示</td></tr><tr><td>%Z</td><td>当前时区的名称</td></tr><tr><td>%%</td><td>%号本身</td></tr></tbody></table><h3 id="time与datetime库"><a href="#time与datetime库" class="headerlink" title="time与datetime库"></a>time与datetime库</h3><p>python处理时间处理time模块还可以使用datetime模块，那么time和datetime之间有什么区别呢？</p><p>在 Python 文档里，<code>time</code>是归类在<code>Generic Operating System Services</code>中，换句话说， 它提供的功能是更加接近于操作系统层面的。通读<a href="https://docs.python.org/2.7/library/time.html">文档</a>可知，time 模块是围绕着 Unix Timestamp 进行的。</p><p>该模块主要包括一个类 <code>struct_time</code>，另外其他几个函数及相关常量。 需要注意的是在该模块中的大多数函数是调用了所在平台<code>C library</code>的同名函数， 所以要特别注意有些函数是平台相关的，可能会在不同的平台有不同的效果。另外一点是，由于是基于Unix Timestamp，所以其所能表述的日期范围被限定在 1970 - 2038 之间，如果你写的代码需要处理在前面所述范围之外的日期，那可能需要考虑使用<code>datetime</code>模块更好。</p><p>datetime 比 time 高级了不少，可以理解为 datetime 基于 time 进行了封装，提供了更多实用的函数。</p><table><thead><tr><th>类</th><th>描述</th></tr></thead><tbody><tr><td>timedelta</td><td>主要用于计算时间跨度</td></tr><tr><td>tzinfo</td><td>时区相关</td></tr><tr><td>time</td><td>只关注时间</td></tr><tr><td>date</td><td>只关注日期</td></tr><tr><td>datetime</td><td>同时有时间和日期</td></tr></tbody></table><h3 id="calendar库"><a href="#calendar库" class="headerlink" title="calendar库"></a>calendar库</h3><p>calendar库主要用于处理日历，如：打印2021年2月的日历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">print(calendar.month(<span class="hljs-number">2021</span>, <span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">    January <span class="hljs-number">2021</span><br>Mo Tu We Th Fr Sa Su<br>             <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span><br> <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span> <span class="hljs-number">10</span><br><span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span><br><span class="hljs-number">18</span> <span class="hljs-number">19</span> <span class="hljs-number">20</span> <span class="hljs-number">21</span> <span class="hljs-number">22</span> <span class="hljs-number">23</span> <span class="hljs-number">24</span><br><span class="hljs-number">25</span> <span class="hljs-number">26</span> <span class="hljs-number">27</span> <span class="hljs-number">28</span> <span class="hljs-number">29</span> <span class="hljs-number">30</span> <span class="hljs-number">31</span><br></code></pre></td></tr></table></figure><h3 id="time库内置函数"><a href="#time库内置函数" class="headerlink" title="time库内置函数"></a>time库内置函数</h3><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/python/att-time-altzone.html">time.altzone</a></td><td align="left">返回格林威治西部的夏令时地区的偏移秒数。如果该地区在格林威治东部会返回负值（如西欧，包括英国）。对夏令时启用地区才能使用。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-time-asctime.html">time.asctime([tupletime])</a></td><td align="left">接受时间元组并返回一个可读的形式为”Tue Dec 11 18:07:14 2008”（2008年12月11日 周二18时07分14秒）的24个字符的字符串。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-time-clock.html">time.clock( )</a></td><td align="left">用以浮点数计算的秒数返回当前的CPU时间。用来衡量不同程序的耗时，比time.time()更有用。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-time-ctime.html">time.ctime([secs])</a></td><td align="left">作用相当于asctime(localtime(secs))，未给参数相当于asctime()</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-time-gmtime.html">time.gmtime([secs])</a></td><td align="left">接收时间戳（1970纪元后经过的浮点秒数）并返回格林威治天文时间下的时间元组t。注：t.tm_isdst始终为0</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-time-localtime.html">time.localtime([secs])</a></td><td align="left">接收时间戳（1970纪元后经过的浮点秒数）并返回当地时间下的时间元组t（t.tm_isdst可取0或1，取决于当地当时是不是夏令时）。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-time-mktime.html">time.mktime(tupletime)</a></td><td align="left">接受时间元组并返回时间戳（1970纪元后经过的浮点秒数）。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-time-sleep.html">time.sleep(secs)</a></td><td align="left">推迟调用线程的运行，secs指秒数。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-time-strftime.html">time.strftime(fmt[,tupletime])</a></td><td align="left">接收以时间元组，并返回以可读字符串表示的当地时间，格式由fmt决定。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-time-strptime.html">time.strptime(str,fmt=’%a %b %d %H:%M:%S %Y’)</a></td><td align="left">根据fmt的格式把一个时间字符串解析为时间元组。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-time-time.html">time.time( )</a></td><td align="left">返回当前时间的时间戳（1970纪元后经过的浮点秒数）。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-time-tzset.html">time.tzset()</a></td><td align="left">根据环境变量TZ重新初始化时间相关设置。</td></tr></tbody></table><h3 id="两个time库重要属性"><a href="#两个time库重要属性" class="headerlink" title="两个time库重要属性"></a>两个time库重要属性</h3><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><strong>time.timezone</strong></td><td align="left">属性 time.timezone 是当地时区（未启动夏令时）距离格林威治的偏移秒数（&gt;0，美洲&lt;=0大部分欧洲，亚洲，非洲）。</td></tr><tr><td align="left"><strong>time.tzname</strong></td><td align="left">属性time.tzname包含一对根据情况的不同而不同的字符串，分别是带夏令时的本地时区名称，和不带的。</td></tr></tbody></table><h3 id="calendar内置函数"><a href="#calendar内置函数" class="headerlink" title="calendar内置函数"></a>calendar内置函数</h3><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><strong>calendar.calendar(year,w=2,l=1,c=6)</strong></td><td align="left">返回一个多行字符串格式的year年年历，3个月一行，间隔距离为c。 每日宽度间隔为w字符。每行长度为21* W+18+2* C。l是每星期行数。</td></tr><tr><td align="left"><strong>calendar.firstweekday( )</strong></td><td align="left">返回当前每周起始日期的设置。默认情况下，首次载入 calendar 模块时返回 0，即星期一。</td></tr><tr><td align="left"><strong>calendar.isleap(year)</strong></td><td align="left">是闰年返回 True，否则为 False。<code>&gt;&gt;&gt; import calendar &gt;&gt;&gt; print(calendar.isleap(2000)) True &gt;&gt;&gt; print(calendar.isleap(1900)) False</code></td></tr><tr><td align="left"><strong>calendar.leapdays(y1,y2)</strong></td><td align="left">返回在Y1，Y2两年之间的闰年总数。</td></tr><tr><td align="left"><strong>calendar.month(year,month,w=2,l=1)</strong></td><td align="left">返回一个多行字符串格式的year年month月日历，两行标题，一周一行。每日宽度间隔为w字符。每行的长度为7* w+6。l是每星期的行数。</td></tr><tr><td align="left"><strong>calendar.monthcalendar(year,month)</strong></td><td align="left">返回一个整数的单层嵌套列表。每个子列表装载代表一个星期的整数。Year年month月外的日期都设为0;范围内的日子都由该月第几日表示，从1开始。</td></tr><tr><td align="left"><strong>calendar.monthrange(year,month)</strong></td><td align="left">返回两个整数。第一个是该月的星期几的日期码，第二个是该月的日期码。日从0（星期一）到6（星期日）;月从1到12。</td></tr><tr><td align="left"><strong>calendar.prcal(year,w=2,l=1,c=6)</strong></td><td align="left">相当于 **print calendar.calendar(year,w=2,l=1,c=6)**。</td></tr><tr><td align="left"><strong>calendar.prmonth(year,month,w=2,l=1)</strong></td><td align="left">相当于 <strong>print calendar.month(year,month,w=2,l=1)</strong> 。</td></tr><tr><td align="left"><strong>calendar.setfirstweekday(weekday)</strong></td><td align="left">设置每周的起始日期码。0（星期一）到6（星期日）。</td></tr><tr><td align="left"><strong>calendar.timegm(tupletime)</strong></td><td align="left">和time.gmtime相反：接受一个时间元组形式，返回该时刻的时间戳（1970纪元后经过的浮点秒数）。</td></tr><tr><td align="left"><strong>calendar.weekday(year,month,day)</strong></td><td align="left">返回给定日期的日期码。0（星期一）到6（星期日）。月份为 1（一月） 到 12（12月）。</td></tr></tbody></table><h2 id="7-set集合"><a href="#7-set集合" class="headerlink" title="7.set集合"></a>7.set集合</h2><p>python的set集合和C++的set集合的用法基本是一样的，set集合是一个无序不重复序列，python使用<code>&#123;&#125;</code>或<code>set()</code>函数来创建set集合，区别字典的地方是{}包括的元素不是键值对，需要注意的是，创建空集合只能通过set()函数。</p><h2 id="8-类型转换"><a href="#8-类型转换" class="headerlink" title="8.类型转换"></a>8.类型转换</h2><p>Python提供了大量内置类型转换函数：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>int(x <a href="https://www.runoob.com/python/python-func-int.html">,[base])</a></td><td>将x转换为一个整数</td></tr><tr><td>long(x <a href="https://www.runoob.com/python/python-func-long.html">,[base] )</a></td><td>将x转换为一个长整数</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-float.html">float(x)</a></td><td>将x转换到一个浮点数</td></tr><tr><td>complex(real <a href="https://www.runoob.com/python/python-func-complex.html">[,imag])</a></td><td>创建一个复数</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-str.html">str(x)</a></td><td>将对象 x 转换为字符串</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-repr.html">repr(x)</a></td><td>将对象 x 转换为表达式字符串</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-eval.html">eval(str)</a></td><td>用来计算在字符串中的有效Python表达式,并返回一个对象</td></tr><tr><td><a href="https://www.runoob.com/python/att-tuple-tuple.html">tuple(s)</a></td><td>将序列 s 转换为一个元组</td></tr><tr><td><a href="https://www.runoob.com/python/att-list-list.html">list(s)</a></td><td>将序列 s 转换为一个列表</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-set.html">set(s)</a></td><td>转换为可变集合</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-dict.html">dict(d)</a></td><td>创建一个字典。d 必须是一个序列 (key,value)元组。</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-frozenset.html">frozenset(s)</a></td><td>转换为不可变集合</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-chr.html">chr(x)</a></td><td>将一个整数转换为一个字符</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-unichr.html">unichr(x)</a></td><td>将一个整数转换为Unicode字符</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-ord.html">ord(x)</a></td><td>将一个字符转换为它的整数值</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-hex.html">hex(x)</a></td><td>将一个整数转换为一个十六进制字符串</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-oct.html">oct(x)</a></td><td>将一个整数转换为一个八进制字符串</td></tr></tbody></table><h1 id="四、运算符"><a href="#四、运算符" class="headerlink" title="四、运算符"></a>四、运算符</h1><h2 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1.算术运算符"></a>1.算术运算符</h2><p>Python的算术运算基本和C系列语言没什么区别，唯一的区别在于Python将C系列语言的求幂函数和取整函数直接内置到了Python的运算符里了，如：</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>**</td><td>求幂运算符，二元运算符，a**b表示求a的b次幂</td></tr><tr><td>//</td><td>取整运算符，二元运算符，a//b表示a对b取整，如9//4 = 2</td></tr></tbody></table><h2 id="2-赋值运算符"><a href="#2-赋值运算符" class="headerlink" title="2.赋值运算符"></a>2.赋值运算符</h2><p>和算数运算符一样，Python也将求幂运算和取整运算的赋值运算内置到运算符里。</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>**=</td><td>幂赋值运算符</td></tr><tr><td>//=</td><td>取整赋值运算符</td></tr></tbody></table><h2 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3.逻辑运算符"></a>3.逻辑运算符</h2><p>由于Python的底层是用C写的所有C的逻辑运算符（<code>&amp;</code>,<code>|</code>,<code>!</code>）在Python中就不能再使用了，所以Python使用（<code>and</code>,<code>or</code>,<code>not</code>）来做逻辑运算符，用法和<code>&amp;</code>,<code>|</code>,<code>!</code>一样。</p><h2 id="4-成员运算符"><a href="#4-成员运算符" class="headerlink" title="4.成员运算符"></a>4.成员运算符</h2><p>和前面一样，Python也将判断函数直接内置到运算符中了，Python成员运算符作用就是判断指定序列中是否包含某个指定元素，序列支持字符串，列表和元组。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>in</td><td>如果指定元素在指定序列中则返回True</td></tr><tr><td>not in</td><td>如果指定元素不在指定序列中则返回True</td></tr></tbody></table><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">li</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>tu = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)<br>st = “<span class="hljs-number">12345</span>”<br><span class="hljs-selector-tag">a</span> = <span class="hljs-number">1</span><br><span class="hljs-selector-tag">b</span> = ‘<span class="hljs-number">1</span>’<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(a in li)</span></span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(a not in tu)</span></span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(b in st)</span></span><br></code></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-literal">True</span><br><span class="hljs-literal">False</span><br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h2 id="5-身份运算符"><a href="#5-身份运算符" class="headerlink" title="5.身份运算符"></a>5.身份运算符</h2><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>is</td><td>判断两个对象是否来自同一引用</td></tr><tr><td>is not</td><td>判断两个对象是否不同的引用</td></tr></tbody></table><p>Pyhton的身份运算符和C#的is是不一样的，Python的is用于判断两个对象是否来引用同一引用，而C#的is则是判断某一对象是否是指定类型。</p><p>使用案例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span>  = <span class="hljs-number">1</span><br><span class="hljs-selector-tag">b</span> = a<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(a is b)</span></span><br><span class="hljs-selector-tag">b</span> = <span class="hljs-number">2</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(a is not b)</span></span><br>c = <span class="hljs-number">2</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(b is c)</span></span><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-literal">True</span><br><span class="hljs-literal">True</span><br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>这里出现了一个疑问，为什么b和c来自同一引用呢？<br>我们查看一下b和c的内存地址</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-title">id</span>(<span class="hljs-variable">b</span>))</span><br><span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-title">id</span>(<span class="hljs-variable">c</span>))</span><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">2324527120200</span><br><span class="hljs-number">2324527120200</span><br></code></pre></td></tr></table></figure><p>可以看到b和c指向了同一内存地址，原来Python在对程序优化的时候会将程序中的内容相同的常量存储到一个存储地址中。</p><h1 id="五、控制语句"><a href="#五、控制语句" class="headerlink" title="五、控制语句"></a>五、控制语句</h1><p>Python的条件语句与C系列语言最大的不同是，Python的条件语句可以不使用<code>()</code>来包含条件表达式，当然也可以是使用，大多数情况下还是建议使用（），以使代码的阅读性更高。</p><h2 id="1-if语句"><a href="#1-if语句" class="headerlink" title="1.if语句"></a>1.if语句</h2><p>当条if-else语句的用法和C系列基本一致。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">if</span> <span class="hljs-literal">True</span>:<br><span class="hljs-attribute">a</span>=1<br><span class="hljs-attribute">b</span>=1<br><span class="hljs-keyword">else</span>:<br><span class="hljs-attribute">a</span>=2<br><span class="hljs-attribute">b</span>=2<br></code></pre></td></tr></table></figure><p><font color="red"> 其中<code>:</code>是必须的</font><br>Python中比较特殊的是else if语句，在Python中使用<font color="red"> elif</font>表示。</p><h2 id="2-while循环语句"><a href="#2-while循环语句" class="headerlink" title="2.while循环语句"></a>2.while循环语句</h2><p>Python的while循环可以搭配esle使用，当循环跳出时执行else语句，个人感觉没什么实际用处。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gauss">a = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> a&lt;<span class="hljs-number">3</span>:<br><span class="hljs-keyword">print</span>(a)<br>a += <span class="hljs-number">1</span><br><span class="hljs-keyword">else</span>:<br><span class="hljs-keyword">print</span>(“循环结束”)<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">0<br>1<br>2<br>循环结束<br></code></pre></td></tr></table></figure><h2 id="3-for循环"><a href="#3-for循环" class="headerlink" title="3.for循环"></a>3.for循环</h2><p><font color="red"> 在写循环语句之前有一点是需要明确的，及根据Python的设计理念Python已经不使用自增<code>++</code>自减<code>--</code>运算符了，所以需要自增时应使用<code>a += 1</code></font></p><h3 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h3><p>for in的用法和C#的foreach一致，可以遍历任何序列，如：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">li</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> <span class="hljs-built_in">li</span>:<br><span class="hljs-built_in">print</span>(item)<br><span class="hljs-keyword">else</span>：<br><span class="hljs-built_in">print</span>(“<span class="hljs-keyword">for</span> end”)<br></code></pre></td></tr></table></figure><p>和while一样for也可以配合else使用</p><h3 id="for-in-range"><a href="#for-in-range" class="headerlink" title="for in range()"></a>for in range()</h3><p>for in range()就是不同的for循环，通过下标来遍历序列，如：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">li</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len(<span class="hljs-built_in">li</span>)):<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">li</span>[i])<br><span class="hljs-keyword">else</span>:<br><span class="hljs-built_in">print</span>(“<span class="hljs-keyword">for</span> end”)<br></code></pre></td></tr></table></figure><p><font color="red"> 需要注意实际上for in中是不包含range()的，range只是一个辅助函数，用于确定下标的范围。如果我们直接像下面那样写是会报语法错误的，如：</font></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">for</span> i in <span class="hljs-number">4</span>:<br><span class="hljs-comment">#code</span><br></code></pre></td></tr></table></figure><p>如果我们想让循环只跑4轮，应该用range(4)来确定下标范围，如：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-keyword">range</span>(<span class="hljs-number">4</span>):<br></code></pre></td></tr></table></figure><h3 id="continue、break和pass"><a href="#continue、break和pass" class="headerlink" title="continue、break和pass"></a>continue、break和pass</h3><p>Python的continue和break的用法和C系列语言基本一致，Python中新增了pass语句，pass语句就是C系列语言中<code>;</code>及空语句，一般用于空循环中维护代码的结构性。</p><h1 id="六、函数"><a href="#六、函数" class="headerlink" title="六、函数"></a>六、函数</h1><h2 id="1-函数定义"><a href="#1-函数定义" class="headerlink" title="1.函数定义"></a>1.函数定义</h2><ul><li>函数代码块以 <strong>def</strong> 关键词开头，后接函数标识符名称和圆括号**()**。</li><li>任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。</li><li><font color="red">函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</font></li><li>函数内容以冒号起始，并且缩进。</li><li><strong>return [表达式]</strong> 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。</li></ul><p>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fun</span>(<span class="hljs-params">a</span>):</span><br>    <span class="hljs-string">&quot;打印a的平方并返回&quot;</span><br>    b = a*a<br>    print(b)<br>    <span class="hljs-keyword">return</span> b<br></code></pre></td></tr></table></figure><h2 id="2-函数调用"><a href="#2-函数调用" class="headerlink" title="2.函数调用"></a>2.函数调用</h2><p><font color="red"> 在调用Python函数时有一点是需要特别注意的，由于Python是解释型语言，Python脚本在运行时是一行一行地放入解释器中进行解释的，因此Pyhton不支持函数的声明定义的分离，所有Python的函数调用必须在定义之后，否则将会报函数未定义。</font></p><h2 id="3-参数传递"><a href="#3-参数传递" class="headerlink" title="3.参数传递"></a>3.参数传递</h2><p>在讨论函数参数之前，我们需要了解两个概念：</p><ul><li><p>不可变对象：不可变对象都是不可变类型，<font color="red">Python的不可变类型有数字、字符串、元组</font>，不可变对象指向的内存地址上的内容是不可更改的，如需操作其内容Python会开辟一个新的内存地址来存储编辑后的内容。</p></li><li><p>可变对象：可变对象都是可变类型，不是不可变类型的类型都是可变类型，包括列表、字典、自定义类型等，可变类型对象指向的内存地址的内容是可更改，操作可变对象的内容时Python不会开辟新的内存，而是直接修改原地址内容。</p></li></ul><p><font color="red">函数传入不可变对象的原理和C++的传值原理是一样的，函数传入可变对象的原理和C++传址原理是一样的。</font></p><h3 id="传参原理"><a href="#传参原理" class="headerlink" title="传参原理"></a>传参原理</h3><p>由于Python的变量都是若类型的，参数也不例外，函数在定义参数时只有名字没有类型，所以Python在调用函数时，参数的传递是根据实参的顺序来给形参赋值的。</p><h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>Python的函数支持关键字传参，关键字传参的原理是指定实参来赋值指定形参，所以可以无视参数的传入顺序。如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fun</span>(<span class="hljs-params">a,b,c</span>):</span><br>    print(a+b+c)<br>fun(b = <span class="hljs-number">1</span>,c = <span class="hljs-number">2</span>,a = <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>Python的函数也支持默认参数，原理和C++一样。</p><h3 id="单-号不定长参数"><a href="#单-号不定长参数" class="headerlink" title="单*号不定长参数"></a>单*号不定长参数</h3><p>Python的不定长参数和C++则有些不同，Python使用<code>*</code>来标识不定长参数，所有形参匹配之外的参数都将存储到不定长参数中，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fun</span>(<span class="hljs-params">a,b,*c</span>):</span><br>    d = a + b<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> c:<br>        d += item<br>    print(d)<br>fun(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>在这个过程中，1被赋予a，2被赋予b，3和4被赋予c</p><p>Python支持不定长参数的单独使用，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fun</span>(<span class="hljs-params">*param</span>):</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>如果函数的参数只有一个不定长参数，那么函数传入的任何参数都会存储到不定长参数里。</p><p><font color="red"> 单<code>*</code>号不定长参数会将传入的所有参数封装在一个元组里，且单<code>*</code>号不定长参数只支持参数的顺序传入，不支持关键字传入。</font></p><p>当函数只有单<code>*</code>号不定长参数时，单<code>*</code>号不定长参数因该放在最后一个参数，如果不放在最后将会报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fun</span>(<span class="hljs-params">*c, t</span>):</span><br>    c[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">5</span><br>    print(c[<span class="hljs-number">0</span>])<br>    print(t)<br></code></pre></td></tr></table></figure><p>报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;d:\Codes\Python\MyFirstPython.py&quot;</span>, line <span class="hljs-number">9</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    fun(li, <span class="hljs-number">2</span>)<br>TypeError: fun() missing <span class="hljs-number">1</span> required keyword-only argument: <span class="hljs-string">&#x27;t&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="双-号不定长参数"><a href="#双-号不定长参数" class="headerlink" title="双*号不定长参数"></a>双*号不定长参数</h3><p>除了单<code>*</code>号不定长参数外，Python还支持双<code>*</code>号不定长参数，<font color="red"> 双<code>*</code>号不定长参数支持关键字传入，不支持顺序传入，双<code>*</code>号不定长参数会将传入的参数封装在一个字典里，其中关键字的名字存入字典的键中，关键字的值存入字典的值中。</font>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fun</span>(<span class="hljs-params">t,**d</span>):</span><br>    print(t)<br>    print(d[<span class="hljs-string">&#x27;x&#x27;</span>])<br>    print(d[<span class="hljs-string">&#x27;y&#x27;</span>])<br>fun(<span class="hljs-number">1</span>,x=<span class="hljs-number">2</span>,y=<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>当函数中同时存在单<code>*</code>号不定长参数和双<code>*</code>号不定长参数时，双<code>*</code>号不定长参数应放在最后一个参数位置，单<code>*</code>号参数应放在倒数第二个参数位置。</p><h2 id="4-匿名函数"><a href="#4-匿名函数" class="headerlink" title="4.匿名函数"></a>4.匿名函数</h2><p>Python的匿名函数的使用场景是，当函数体只由比较简单的Lambda表达式组成时才使用。匿名函数除了没有函数名，其他的和有名函数没有什么区别。如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">f = <span class="hljs-keyword">lambda</span> a,b=<span class="hljs-number">1</span>: a+b<br>print(f(<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>在lambda表达式的结构中，<code>:</code>之前的为参数，<code>:</code>号之后有且只有一条语句，这是由Python语句分割的方式决定的。从上面的例子我们还可以发现，lambda表达式支持默认参数，且自带返回值，lambda表达式将表达式的结果作为返回值，需要注意的是，lambda表达式中不能进行复制操作，否则将报语法错误。</p><h1 id="七、模块"><a href="#七、模块" class="headerlink" title="七、模块"></a>七、模块</h1><p>一个Python文件就是一个Python模块，一个Python包也是一个Python模块。</p><h2 id="1-导入模块（包）"><a href="#1-导入模块（包）" class="headerlink" title="1.导入模块（包）"></a>1.导入模块（包）</h2><h3 id="整模块导入"><a href="#整模块导入" class="headerlink" title="整模块导入"></a>整模块导入</h3><p>Python使用<code>import</code>+<code>模块名</code>来导入模块，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> MyFirstPython<br></code></pre></td></tr></table></figure><p>当我们将一个Python作为模块导入到另一个文件时，Python会在工程文件夹下的<code>__pycache</code>文件夹下生成一个模块名对应的<code>pyc</code>文件，如上面的例子则会生成一个<code>PyFirstPython.cpython-39.pyc</code>其中cpython-39为python版本号，这个文件是做什么用的呢？pyc文件是一个二进制文件，且已经经过Python加密，直接打开会显示乱码，pyc的主要作用就是加快模块的导入速度，注意这里是导入速度而非运行速度，pyc文件可以通过反编译器重新反编译成可执行的Python文件。</p><p>python支持使用<code>,</code>来分割模块，达到同时导入多个包的目的，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> MyfirstPython,MySecondPython<br></code></pre></td></tr></table></figure><h3 id="单函数导入"><a href="#单函数导入" class="headerlink" title="单函数导入"></a>单函数导入</h3><p>python除了支持整个文件的模块导入，同时也支持只导入模块中的一个函数，python使用<code>from 模块名 import 函数名</code>来从指定模块导入单个函数，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> MySecondPython <span class="hljs-keyword">import</span> fun <span class="hljs-keyword">as</span> f<br></code></pre></td></tr></table></figure><p>同时，python在导入模块或模块中的函数时可以使用<code>as</code>关键字为模块或函数起别名。</p><p>form import还可以使用<code>*</code>来达到import的效果，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> MyFirstPython <span class="hljs-keyword">import</span> * <span class="hljs-comment">#相当于import MyFirstPython</span><br></code></pre></td></tr></table></figure><h3 id="python导入模块时的路径搜索顺序"><a href="#python导入模块时的路径搜索顺序" class="headerlink" title="python导入模块时的路径搜索顺序"></a>python导入模块时的路径搜索顺序</h3><ul><li>1、当前目录</li><li>2、如果不在当前目录，Python 则搜索在 shell 变量 PYTHONPATH 下的每个目录。</li><li>3、如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/。</li></ul><h3 id="python使用导入模块的全局变量"><a href="#python使用导入模块的全局变量" class="headerlink" title="python使用导入模块的全局变量"></a>python使用导入模块的全局变量</h3><p>有一点十分不方便的就是在当前文件下无法直接使用导入模块的全局变量，只能通过为指定变量编写读写函数才能操作全局变量，这是由python的变量规则决定的。</p><h3 id="Pyhton模块打包"><a href="#Pyhton模块打包" class="headerlink" title="Pyhton模块打包"></a>Pyhton模块打包</h3><p>Python提供了多个打包工具，我使用的是python3.9内置的<code>setuptools</code>库，setuptools库中提供了一个setup函数用于打包模块，具体操作如下：</p><ul><li><p>1.在工程目录下新建一个setup.py文件，这个文件用于配置一些包的必要信息，配置信息都由关键字参数的形式传入setup函数中，具体参数信息如下;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python">setup(<br>    name=about[<span class="hljs-string">&quot;__title__&quot;</span>],  <span class="hljs-comment"># 包名称</span><br>    version=about[<span class="hljs-string">&quot;__version__&quot;</span>],  <span class="hljs-comment"># 包版本</span><br>    description=about[<span class="hljs-string">&quot;__description__&quot;</span>],  <span class="hljs-comment"># 包详细描述</span><br>    long_description=readme,   <span class="hljs-comment"># 长描述，通常是readme，打包到PiPy需要</span><br>    author=about[<span class="hljs-string">&quot;__author__&quot;</span>],  <span class="hljs-comment"># 作者名称</span><br>    author_email=about[<span class="hljs-string">&quot;__author_email__&quot;</span>],  <span class="hljs-comment"># 作者邮箱</span><br>    url=about[<span class="hljs-string">&quot;__url__&quot;</span>],   <span class="hljs-comment"># 项目官网</span><br>    packages=packages,    <span class="hljs-comment"># 项目需要的包</span><br>    data_files=file_data,   <span class="hljs-comment"># 打包时需要打包的数据文件，如图片，配置文件等</span><br>    include_package_data=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 是否需要导入静态数据文件</span><br>    python_requires=<span class="hljs-string">&quot;&gt;=3.0, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3*&quot;</span>,  <span class="hljs-comment"># Python版本依赖</span><br>    install_requires=requires,  <span class="hljs-comment"># 第三方库依赖</span><br>    zip_safe=<span class="hljs-literal">False</span>,  <span class="hljs-comment"># 此项需要，否则卸载时报windows error</span><br>    classifiers=[    <span class="hljs-comment"># 程序的所属分类列表</span><br>        <span class="hljs-string">&#x27;Development Status :: 5 - Production/Stable&#x27;</span>,<br>        <span class="hljs-string">&#x27;Intended Audience :: Developers&#x27;</span>,<br>        <span class="hljs-string">&#x27;Natural Language :: English&#x27;</span>,<br>        <span class="hljs-string">&#x27;Programming Language :: Python&#x27;</span>,<br>        <span class="hljs-string">&#x27;Programming Language :: Python :: 3&#x27;</span>,<br>        <span class="hljs-string">&#x27;Programming Language :: Python :: 3.4&#x27;</span>,<br>        <span class="hljs-string">&#x27;Programming Language :: Python :: 3.5&#x27;</span>,<br>        <span class="hljs-string">&#x27;Programming Language :: Python :: 3.6&#x27;</span>,<br>        <span class="hljs-string">&#x27;Programming Language :: Python :: 3.7&#x27;</span>,<br>        <span class="hljs-string">&#x27;Programming Language :: Python :: Implementation :: CPython&#x27;</span>,<br>        <span class="hljs-string">&#x27;Programming Language :: Python :: Implementation :: PyPy&#x27;</span><br>    ],<br>)<br></code></pre></td></tr></table></figure><p>当然这里面所有的参数都不是非必须，如果我们一个参数都不传入，则pyhton会生成一个名为<code>UNKNOW-0.0.0.tar.gz</code>的包。</p></li><li><p>2.使用cmd进入setup.py所在目录，使用<code>python setup.py sdist</code>命令之后，python会在此目录下生成一个<code>dist</code>目录和一个<code>包名.egg-info</code>目录，包名及setup函数中name指定的名称，为命名则为UNKNOWN.egg-info，这个文件夹下是一些包的详细信息文件。</p></li></ul><p>如此包便打包完成了，这中间踩了一写坑，记录一下：</p><p>使用python setup.py sdist命令无反应，然后使用python -v发现也不输出python版信息，此时打开此电脑/属性/高级系统设置/高级/环境变量，发现path中都以存在python目录，可是使用python -v就是无反应。</p><p>解决方案：在cmd下使用<code>set PATH=Python完成目录;%PATH%</code>，不知道为什么需要使用命令行配置一下系统环境才行。</p><p>当然不同的打包工具，打包过程略有不同，这里就详细展开了。</p><h1 id="八、Python的内置函数"><a href="#八、Python的内置函数" class="headerlink" title="八、Python的内置函数"></a>八、Python的内置函数</h1><h2 id="1-数学函数"><a href="#1-数学函数" class="headerlink" title="1.数学函数"></a>1.数学函数</h2><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/python/func-number-abs.html">abs()</a></td><td>返回数字的绝对值，如abs(-10) 返回 10</td></tr><tr><td><a href="https://www.runoob.com/python/func-number-cmp.html">cmp()</a></td><td>如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1</td></tr><tr><td><a href="https://www.runoob.com/python/func-number-max.html">max()</a></td><td>返回给定参数的最大值，参数可以为序列</td></tr><tr><td><a href="https://www.runoob.com/python/func-number-min.html">min()</a></td><td>返回给定参数的最小值，参数可以为序列</td></tr><tr><td><a href="https://www.runoob.com/python/func-number-pow.html">pow()</a></td><td>x^y 运算后的值，及求x的y次幂</td></tr><tr><td><a href="https://www.runoob.com/python/func-number-round.html">round(x [,n])</a></td><td>返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-sum.html">sum()</a></td><td>对序列求和</td></tr><tr><td><a href="https://www.runoob.com/python/func-number-round.html">round()</a></td><td>返回浮点数x的四舍五入值</td></tr></tbody></table><h2 id="5-反射函数"><a href="#5-反射函数" class="headerlink" title="5.反射函数"></a>5.反射函数</h2><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/python/python-func-dir.html">dir()</a></td><td>dir函数返回一个包含了一个模块里所定义的所有模块、变量和函数，dir函数只是列出名称，无其他实际意义，其中以<code>__</code>开头的是模块相关的默认属性，如：<code>__name__</code>指向模块的名字，<code>__file__</code>指向模块文件的名字，dir函数可以传入模块名称，则输出的是模块相关的信息，如果不传入参数则输出当前作用域的相关信息</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-globals.html">globals()</a></td><td>在函数内使用则返回一个包含该函数能访问的所有全局名字的字典，在函数外使用效果和在函数内使用一样</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-locals.html">locals()</a></td><td>在函数内使用则返回一个包含该函数内的全部局部名字的字典，在函数外使用效果和globals()函数一样</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-callable.html">callable()</a></td><td>检查一个对象是否是可调用的。如果返回 True，object 仍然可能调用失败；但如果返回 False，调用对象 object 绝对不会成功。</td></tr></tbody></table><h2 id="6-类型转换函数"><a href="#6-类型转换函数" class="headerlink" title="6.类型转换函数"></a>6.类型转换函数</h2><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/python/python-func-bool.html">bool()</a></td><td>将对象转换为bool类型，对于空元组和空列表将转换为false</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-float.html">float()</a></td><td>在python中没有double类型，python的float精度就已经达到了double的精度</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-int.html">int()</a></td><td>转整型</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-long.html">long()</a></td><td>转长整型</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-str.html">str()</a></td><td>将对象转换成字符串，支持任何对象</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-eval.html">eval()</a></td><td>eval函数可以用来做字符串转列表、元组和字典等，如：<code>a = eval(&#39;[1,2]&#39;)</code>、<code>b = eval(&#39;(1,2)&#39;)</code>，a是一个列表，b是一个元组，其中字典需要注意的是要使用纯字符串，如：<code>c = eavl(r&quot;&#123;&#39;a&#39;:1,&#39;b&#39;:2&#125;&quot;)</code>，c就是一个字典了，除此之外，eval函数还可以用来运行字符串命令，如：<code>eval(&#39;bool(1)&#39;)</code>，输出为<code>True</code></td></tr><tr><td><a href="https://www.runoob.com/python/att-list-list.html">list()</a></td><td>将可迭代序列(包括元组，字符串，字典等)转换成列表，如：字符串转列表<code>a = list(&#39;abc&#39;)</code>则a列表内容为<code>[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]</code>、字典转列表则会返回一个key值列表</td></tr><tr><td><a href="https://www.runoob.com/python/att-tuple-tuple.html">tuple()</a></td><td>将可迭代序列(包括元组，字符串，字典等)转换成元组，如：字符串转元组<code>a = tuple(&#39;abc&#39;)</code>则a列表内容为<code>(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;)</code>、字典转元组则会返回一个key值元组</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-dict.html">dict()</a></td><td>dict函数支持三种转换形式，其一使用关键字的形式，关键字名称为键，关键字的值为值，如：<code>a=dict(a=1,b=1)</code>则a就是字典<code>&#123;&#39;a&#39;:1,&#39;b&#39;:2&#125;</code>，其二使用zip函数的形式，zip函数将两个可迭代序列按位置打包成二元元组，dict函数则将二元元组的第一个元素作为键，第二个元素作为值创建字典，如：<code>a=dict(zip([&#39;a&#39;,&#39;b&#39;],[1,2]))</code>，其中zip函数返回值为<code>[(&#39;a&#39;,1),(&#39;b&#39;,2)]</code>，dict函数返回值为<code>&#123;&#39;a&#39;:1,&#39;b&#39;:2&#125;</code>，其三使用可迭代对象的形式，如：<code>a=dict([(&#39;a&#39;,1),(&#39;b&#39;:2)])</code>其中可迭代对象可以是任何子成员为二元序列的对象</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-chr.html">chr()</a></td><td>将数字转换成对应的字符</td></tr></tbody></table><h2 id="6-其他内置函数"><a href="#6-其他内置函数" class="headerlink" title="6.其他内置函数"></a>6.其他内置函数</h2><p>详情见<a href="https://www.runoob.com/python/python-built-in-functions.html">菜鸟教程</a></p><h1 id="九、文件IO"><a href="#九、文件IO" class="headerlink" title="九、文件IO"></a>九、文件IO</h1><h2 id="1-标准输出"><a href="#1-标准输出" class="headerlink" title="1.标准输出"></a>1.标准输出</h2><p>print()在终端打印，这里需要注意的是python3已经不支持<code>print &#39;aa&#39;</code>这种打印方式了。</p><h2 id="2-标准输入"><a href="#2-标准输入" class="headerlink" title="2.标准输入"></a>2.标准输入</h2><p>input()从终端输入，有时我们会看到row_input函数或input函数接收python表达式的标准输入，这些都是ptrhon2的标准输入函数和输入特性，在python3中python只保留了一个input函数作为标准输入，且input函数不在支持python表达式的输入，而是把所有的输入当作是字符串。</p><h2 id="3-文件读写"><a href="#3-文件读写" class="headerlink" title="3.文件读写"></a>3.文件读写</h2><p>python的文件读写通过内置类型<code>file</code>类型来进行操作，而file类型对象的创建需要通过内置函数<code>open</code>来创建。</p><h3 id="open函数"><a href="#open函数" class="headerlink" title="open函数"></a>open函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">open</span>(file_name ,access_mode, buffering)<br></code></pre></td></tr></table></figure><ul><li><p>file_name：文件路径</p></li><li><p>access_mode：打开模式，默认为只读，具体模式如下：</p><table><thead><tr><th align="left">字符</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left"><code>&#39;r&#39;</code></td><td align="left">读取（默认）</td></tr><tr><td align="left"><code>&#39;w&#39;</code></td><td align="left">写入，并先截断文件</td></tr><tr><td align="left"><code>&#39;x&#39;</code></td><td align="left">排它性创建，如果文件已存在则失败</td></tr><tr><td align="left"><code>&#39;a&#39;</code></td><td align="left">写入，如果文件存在则在末尾追加</td></tr><tr><td align="left"><code>&#39;b&#39;</code></td><td align="left">二进制模式</td></tr><tr><td align="left"><code>&#39;t&#39;</code></td><td align="left">文本模式（默认）</td></tr><tr><td align="left"><code>&#39;+&#39;</code></td><td align="left">更新磁盘文件（读取并写入）</td></tr></tbody></table><p>python3以后删除了很多打开模式，只保留了上面几种，所以如果在python3环境中使用<code>+</code>打开模式就会报错。</p></li><li><p>buffering：是否寄存行，可选参数，具体取值如下：</p><table><thead><tr><th>取值</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>取0，不寄存行</td></tr><tr><td>1</td><td>取1，寄存行</td></tr><tr><td>&gt;1</td><td>取大于1的值，寄存行，且设置寄存区的缓冲大小为当前值</td></tr><tr><td>&lt;0</td><td>取小于0的值，寄存行，且设置寄存区的缓冲大小为系统默认值</td></tr></tbody></table></li><li><p>返回值：open函数打开文件，读取文件内容到内存并一个可操作文件的file类型对象。</p></li></ul><h3 id="file类型对象内置函数"><a href="#file类型对象内置函数" class="headerlink" title="file类型对象内置函数"></a>file类型对象内置函数</h3><table><thead><tr><th align="left">序号</th><th align="left">方法及描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/python3/python3-file-close.html">file.close()</a></td><td align="left">关闭文件。关闭后文件不能再进行读写操作。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-file-flush.html">file.flush()</a></td><td align="left">刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-file-fileno.html">file.fileno()</a></td><td align="left">返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-file-isatty.html">file.isatty()</a></td><td align="left">如果文件连接到一个终端设备返回 True，否则返回 False。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-file-read.html">file.read([size])</a></td><td align="left">从文件读取指定的字节数，如果未给定或为负则读取所有。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-file-readline.html">file.readline([size])</a></td><td align="left">读取整行，包括 “\n” 字符。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-file-readlines.html">file.readlines([sizeint])</a></td><td align="left">读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-file-seek.html">file.seek(offset[, whence])</a></td><td align="left">移动文件读取指针到指定位置</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-file-tell.html">file.tell()</a></td><td align="left">返回文件当前位置。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-file-truncate.html">file.truncate([size])</a></td><td align="left">从文件的首行首字符开始截断，截断文件为 size 个字符，无 size 表示从当前位置截断；截断之后后面的所有字符被删除，其中 windows 系统下的换行代表2个字符大小。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-file-write.html">file.write(str)</a></td><td align="left">将字符串写入文件，返回的是写入的字符长度。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-file-writelines.html">file.writelines(sequence)</a></td><td align="left">向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。</td></tr></tbody></table><h3 id="file类型对象内置属性"><a href="#file类型对象内置属性" class="headerlink" title="file类型对象内置属性"></a>file类型对象内置属性</h3><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">file.closed</td><td align="left">返回true如果文件已被关闭，否则返回false。</td></tr><tr><td align="left">file.mode</td><td align="left">返回被打开文件的访问模式。</td></tr><tr><td align="left">file.name</td><td align="left">返回文件的名称。</td></tr><tr><td align="left">file.softspace</td><td align="left">如果用print输出后，必须跟一个空格符，则返回false。否则返回true。</td></tr></tbody></table><h2 id="4-文件及目录操作"><a href="#4-文件及目录操作" class="headerlink" title="4.文件及目录操作"></a>4.文件及目录操作</h2><p>这里的文件操作不是对文件的内容进行增删改操作而是在文件级别进行重命名删除设置权限等操作，对文件做这些操作需要用到<code>os</code>模块，os模块提供大量的函数对文件进行操作，文件数量过多这里就不贴出来了，具体见菜鸟教程：</p><p><a href="https://www.runoob.com/python/os-file-methods.html">os文件操作函数</a></p><h1 id="十、异常"><a href="#十、异常" class="headerlink" title="十、异常"></a>十、异常</h1><h2 id="1-异常处理语句"><a href="#1-异常处理语句" class="headerlink" title="1.异常处理语句"></a>1.异常处理语句</h2><p>Python的异常处理语句是<code>try/except</code>，需要监测异常的代码放在<code>try:</code>块下，在异常发生后需要执行的代码放在<code>except:</code>块下，except后可以接异常类型也可以不接，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    a = <span class="hljs-number">1</span>/<span class="hljs-number">0</span><br><span class="hljs-keyword">except</span> ZeroDivisionError:<br>    print(<span class="hljs-string">&#x27;0不可以做除数&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-string">&#x27;没有异常&#x27;</span>)<br><span class="hljs-keyword">finally</span>:<br>    print(<span class="hljs-string">&#x27;有没有异常都会执行&#x27;</span>)<br></code></pre></td></tr></table></figure><p>可以看到，和条件语句一样try/except语句也可以接else分支，else分支在没有异常发生时执行。、</p><h2 id="2-抛出异常"><a href="#2-抛出异常" class="headerlink" title="2.抛出异常"></a>2.抛出异常</h2><p>python使用<code>raise</code>语句来抛出异常，需要注意的是，raise必须抛出一个异常类，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    a = <span class="hljs-number">1</span>/<span class="hljs-number">0</span><br><span class="hljs-keyword">except</span> ZeroDivisionError:<br>    <span class="hljs-keyword">raise</span> ZeroDivisionError(<span class="hljs-string">&#x27;0不可以做除数&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="3-标准异常"><a href="#3-标准异常" class="headerlink" title="3.标准异常"></a>3.标准异常</h2><table><thead><tr><th align="left">异常名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">BaseException</td><td align="left">所有异常的基类</td></tr><tr><td align="left">SystemExit</td><td align="left">解释器请求退出</td></tr><tr><td align="left">KeyboardInterrupt</td><td align="left">用户中断执行(通常是输入^C)</td></tr><tr><td align="left">Exception</td><td align="left">常规错误的基类</td></tr><tr><td align="left">StopIteration</td><td align="left">迭代器没有更多的值</td></tr><tr><td align="left">GeneratorExit</td><td align="left">生成器(generator)发生异常来通知退出</td></tr><tr><td align="left">StandardError</td><td align="left">所有的内建标准异常的基类</td></tr><tr><td align="left">ArithmeticError</td><td align="left">所有数值计算错误的基类</td></tr><tr><td align="left">FloatingPointError</td><td align="left">浮点计算错误</td></tr><tr><td align="left">OverflowError</td><td align="left">数值运算超出最大限制</td></tr><tr><td align="left">ZeroDivisionError</td><td align="left">除(或取模)零 (所有数据类型)</td></tr><tr><td align="left">AssertionError</td><td align="left">断言语句失败</td></tr><tr><td align="left">AttributeError</td><td align="left">对象没有这个属性</td></tr><tr><td align="left">EOFError</td><td align="left">没有内建输入,到达EOF 标记</td></tr><tr><td align="left">EnvironmentError</td><td align="left">操作系统错误的基类</td></tr><tr><td align="left">IOError</td><td align="left">输入/输出操作失败</td></tr><tr><td align="left">OSError</td><td align="left">操作系统错误</td></tr><tr><td align="left">WindowsError</td><td align="left">系统调用失败</td></tr><tr><td align="left">ImportError</td><td align="left">导入模块/对象失败</td></tr><tr><td align="left">LookupError</td><td align="left">无效数据查询的基类</td></tr><tr><td align="left">IndexError</td><td align="left">序列中没有此索引(index)</td></tr><tr><td align="left">KeyError</td><td align="left">映射中没有这个键</td></tr><tr><td align="left">MemoryError</td><td align="left">内存溢出错误(对于Python 解释器不是致命的)</td></tr><tr><td align="left">NameError</td><td align="left">未声明/初始化对象 (没有属性)</td></tr><tr><td align="left">UnboundLocalError</td><td align="left">访问未初始化的本地变量</td></tr><tr><td align="left">ReferenceError</td><td align="left">弱引用(Weak reference)试图访问已经垃圾回收了的对象</td></tr><tr><td align="left">RuntimeError</td><td align="left">一般的运行时错误</td></tr><tr><td align="left">NotImplementedError</td><td align="left">尚未实现的方法</td></tr><tr><td align="left">SyntaxError</td><td align="left">Python 语法错误</td></tr><tr><td align="left">IndentationError</td><td align="left">缩进错误</td></tr><tr><td align="left">TabError</td><td align="left">Tab 和空格混用</td></tr><tr><td align="left">SystemError</td><td align="left">一般的解释器系统错误</td></tr><tr><td align="left">TypeError</td><td align="left">对类型无效的操作</td></tr><tr><td align="left">ValueError</td><td align="left">传入无效的参数</td></tr><tr><td align="left">UnicodeError</td><td align="left">Unicode 相关的错误</td></tr><tr><td align="left">UnicodeDecodeError</td><td align="left">Unicode 解码时的错误</td></tr><tr><td align="left">UnicodeEncodeError</td><td align="left">Unicode 编码时错误</td></tr><tr><td align="left">UnicodeTranslateError</td><td align="left">Unicode 转换时错误</td></tr><tr><td align="left">Warning</td><td align="left">警告的基类</td></tr><tr><td align="left">DeprecationWarning</td><td align="left">关于被弃用的特征的警告</td></tr><tr><td align="left">FutureWarning</td><td align="left">关于构造将来语义会有改变的警告</td></tr><tr><td align="left">OverflowWarning</td><td align="left">旧的关于自动提升为长整型(long)的警告</td></tr><tr><td align="left">PendingDeprecationWarning</td><td align="left">关于特性将会被废弃的警告</td></tr><tr><td align="left">RuntimeWarning</td><td align="left">可疑的运行时行为(runtime behavior)的警告</td></tr><tr><td align="left">SyntaxWarning</td><td align="left">可疑的语法的警告</td></tr><tr><td align="left">UserWarning</td><td align="left">用户代码生成的警告</td></tr></tbody></table><h2 id="4-自定义异常"><a href="#4-自定义异常" class="headerlink" title="4.自定义异常"></a>4.自定义异常</h2><p>python的自定义异常只需要将自定义异常类继承自python标准异常类即可。</p><h1 id="十一、面向对象"><a href="#十一、面向对象" class="headerlink" title="十一、面向对象"></a>十一、面向对象</h1><p>python在设计之初就已经是一门面向对象的语言了，在python中一切皆对象，包括所有的基础类型也是对象，这使得python在创建类和对象时十分容易，但是这也导致python十分消耗内存空间，因为哪怕只创建一个整型也会消耗对于C语言的内存空间。</p><h2 id="1-定义类"><a href="#1-定义类" class="headerlink" title="1.定义类"></a>1.定义类</h2><p>和大多数语言一样，python也使用<code>class</code>关键字来标识类，使用同等量的缩进来标识类的范围，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><br>    age = <span class="hljs-number">0</span><br>    name = <span class="hljs-string">&#x27;&#x27;</span><br>    __id = <span class="hljs-number">1</span><br>    _sex = <span class="hljs-string">&#x27;female&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, age, name</span>):</span><br>        self.age = age<br>        self.name = name<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">GetName</span>(<span class="hljs-params">this</span>):</span><br>        print(<span class="hljs-string">&#x27;my name is &#x27;</span> + this.name)<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__SetId</span>():</span><br>        <span class="hljs-built_in">id</span> = 001<br><br><br>p = Person(<span class="hljs-number">18</span>, <span class="hljs-string">&#x27;lusa&#x27;</span>)<br>p.GetName()<br></code></pre></td></tr></table></figure><h2 id="2-成员变量"><a href="#2-成员变量" class="headerlink" title="2.成员变量"></a>2.成员变量</h2><h3 id="私有成员变量"><a href="#私有成员变量" class="headerlink" title="私有成员变量"></a>私有成员变量</h3><p>由于python无法使用public，private等关键字，所以python使用双下划线开头来标识私有成员变量。如上面代码中的<code>__id</code>。</p><h3 id="保护成员变量"><a href="#保护成员变量" class="headerlink" title="保护成员变量"></a>保护成员变量</h3><p>python使用单下划线开头来标识保护成员变量，如上面代码中的<code>_sex</code>。</p><h3 id="公有成员变量"><a href="#公有成员变量" class="headerlink" title="公有成员变量"></a>公有成员变量</h3><p>不带有任何前缀的变量的就是公有成员变量。</p><h2 id="3-成员函数"><a href="#3-成员函数" class="headerlink" title="3.成员函数"></a>3.成员函数</h2><h3 id="私有函数、保护函数和公有函数"><a href="#私有函数、保护函数和公有函数" class="headerlink" title="私有函数、保护函数和公有函数"></a>私有函数、保护函数和公有函数</h3><p>和变量一样，python使用双下划线来前缀来标识私有函数，用单下划线前缀来标识保护函数，无前缀函数表示公有函数。</p><h3 id="self参数"><a href="#self参数" class="headerlink" title="self参数"></a>self参数</h3><p><font color="red">与其他语言不同的是，python的函数都必须带有一个self参数，self参数的在效果上与C++的this指针很像，但是python的self参数不是类自带的，在定义函数时需要手动显示表示，且必须放在函数的第一个参数位置，self参数的名字不一定非得叫self也可以叫其他的名字，如上面代码中的GetName函数的this，但是按照python的规范建议将都是用self命名，self参数指向当前类实例，类的实例变量都必须使用self参数才能访问，直接使用是无法访问的，如：</font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><br>    age = <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, param</span>):</span><br>        age = param<br></code></pre></td></tr></table></figure><p>不通过self参数访问类的成员变量将直接报语法错误。</p><h2 id="4-类变量、实例变量和局部变量"><a href="#4-类变量、实例变量和局部变量" class="headerlink" title="4.类变量、实例变量和局部变量"></a>4.类变量、实例变量和局部变量</h2><h3 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h3><p>定义在类的内部且定义在方法体外的变量，如上面代码中age，<font color="red">类变量可以被类直接访问，也可以被实例直接访问，同时可以被实例方法和类方法方法访问，但是不可以被静态方法访问</font>。如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><br>    names = <span class="hljs-string">&#x27;aa&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, age, name</span>):</span><br>        self.age = age<br>        self.name = name<br>        addr = <span class="hljs-string">&#x27;beijing&#x27;</span><br>        names = <span class="hljs-string">&quot;bb&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">GetName</span>(<span class="hljs-params">self</span>):</span><br>        self.sex = <span class="hljs-string">&#x27;female&#x27;</span><br>        print(<span class="hljs-string">&#x27;my name is &#x27;</span> + self.names)<br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">PP</span>():</span><br>        print(names)<br>    <br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">OO</span>(<span class="hljs-params">cls</span>):</span>       <br>        print(cls.names)<br><br><br>p = Person(<span class="hljs-number">18</span>, <span class="hljs-string">&quot;lusa&quot;</span>)<br>print(p.names)<br>p.names = <span class="hljs-string">&quot;cc&quot;</span><br>p.GetName()<br>print(Person.names)<br>Person.names = <span class="hljs-string">&quot;dd&quot;</span><br>Person.OO()<br>print(p.names)<br>Person.PP()<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">aa<br>my name <span class="hljs-keyword">is</span> cc<br>aa<br>dd<br>cc<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;d:\Codes\Python\MyFirstPython.py&quot;</span>, line <span class="hljs-number">31</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    Person.PP()<br>  File <span class="hljs-string">&quot;d:\Codes\Python\MyFirstPython.py&quot;</span>, line <span class="hljs-number">16</span>, <span class="hljs-keyword">in</span> PP<br>    print(names)<br>NameError: name <span class="hljs-string">&#x27;names&#x27;</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> definedd<br></code></pre></td></tr></table></figure><p>可以看到，类变量names初始值为aa，我们的本意是在构造函数中再赋值bb但是再实际输出中names的值依旧是aa，当我们使用实例给类变量names赋值为cc时，输出GetName函数输出就变为了cc，然而直接通过类名访问的结果依旧是aa，当我们通过类名赋值names为dd时，类方法输出的结果就变为了dd，然而用实例访问的结果依旧时cc，最终运行到类的静态方法PP处则报错了，由上结果可得出结论：</p><ul><li>类在创建实例时会拷贝一份类变量到实例中，实例中类变量和类中的类变量互相独立</li><li>构造函数不可以初始化类变量，当我们在构造函数初始化一个类变量的同名变量时，实际上python初始化的是一个和类变量同名的局部变量</li><li>同一个类变量既可以被类实例访问也可以被类名直接访问，但二者内存地址时两个内存地址</li><li>静态方法不可以访问类变量</li></ul><h3 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h3><p>实例变量是定义在构造函数内部且通过self引出的变量，这两点十分重要，如果一个变量不是在构造函数里创建即使通过self引出也依旧不是实例变量，或一个变量在构造函数中创建但不是由self引出，那它也不是实例变量，而是函数的局部变量，如：上面代码中self.sex，和构造函数里的addr和names，我们是不可以使用实例访问的。</p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>在构造函数中创建的不由self引出的变量或在其他方法中创建的变量，如上面代码中GetName啊哈桑农户里的self.sex和构造函数里的addr和names</p><h2 id="5-类方法、实例方法和静态方法"><a href="#5-类方法、实例方法和静态方法" class="headerlink" title="5.类方法、实例方法和静态方法"></a>5.类方法、实例方法和静态方法</h2><p>被<code>@classmethod</code>修饰的方法就是类方法，被<code>@staticmethod</code>修饰的方法就是静态方法，除此之外其余的方法都是实例方法。类方法和静态方法也有保护级。</p><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p>类方法属于类，可以直接通过类型访问，也可以同通过实例访问，访问效果是一样的。在创建类方法时必须至少需要一个参数，一般命名为<code>cls</code>，用于python传递默认参数–类。如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@classmethod</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">OO</span>(<span class="hljs-params">cls</span>):</span><br>    print(cls.names)<br></code></pre></td></tr></table></figure><p>cls不可省略，在类方法中只能通过cls来访问类变量，且只能访问类变量。</p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>静态方法同类方法很相似，也可以被类名和实例直接访问。不同的是，静态方法不需要cls参数，python不会传递默认参数到静态方法，静态方法不可以直接访问类的任何成员。</p><h3 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h3><p>python支持方法中嵌套创建方法，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">funa</span>():</span><br>    a = <span class="hljs-number">1</span><br>    print(a)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">funb</span>():</span><br>        <span class="hljs-keyword">nonlocal</span> a<br>        a += <span class="hljs-number">1</span><br>        print(a)<br>   <br>    funb()<br><br><br>funa()<br></code></pre></td></tr></table></figure><h1 id="十二、作用域"><a href="#十二、作用域" class="headerlink" title="十二、作用域"></a>十二、作用域</h1><p>python的作用域大部分与C系列语言的作用域差不多，只是有三点比较特殊：</p><ul><li><p>python中只有类、函数、模块才会引入新的作用域，控制语句不会引入新的作用域，也就是说，在控制语句中创建的变量可以在控制语句外部被访问</p><p>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>    print(i)<br><br>print(i)<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></li><li><p>如果要在函数内部访问全局变量需要在在函数内部使用<code>global</code>申明，否则python将创建一个同名的局部变量而不是引用全局变量</p><p>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">1</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fun</span>():</span><br>    a += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>python会直接报语法错误，因为我们使用了一个未定义的局部变量，但是当我们使用global申明之后，我们访问的就是全局变量了，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">1</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fun</span>():</span><br>    <span class="hljs-keyword">global</span> a<br>    a += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p>如果要在嵌套函数中访问外层函数的变量需要使用<code>nonlocal</code>申明，否则python也会创建一个同名的局部函数，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">1</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fun</span>():</span><br>    <span class="hljs-keyword">global</span> a<br>    a += <span class="hljs-number">1</span><br>    b = <span class="hljs-number">2</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">funb</span>():</span><br>        <span class="hljs-keyword">global</span> a<br>        <span class="hljs-keyword">nonlocal</span> b<br>        b += <span class="hljs-number">1</span><br>        print(a)<br>        print(b)<br><br>    funb()<br><br><br>fun()<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C++】C++ PremierReadNote</title>
    <link href="/2021/02/03/%E3%80%90C++%E3%80%91C++%20PremierReadNote/"/>
    <url>/2021/02/03/%E3%80%90C++%E3%80%91C++%20PremierReadNote/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="C-Primer-阅读笔记"><a href="#C-Primer-阅读笔记" class="headerlink" title="C++ Primer 阅读笔记"></a>C++ Primer 阅读笔记</h1><hr><a id="more"></a><h1 id="一、开始"><a href="#一、开始" class="headerlink" title="一、开始"></a>一、开始</h1><hr><h2 id="1-输入输出流的数据传输过程"><a href="#1-输入输出流的数据传输过程" class="headerlink" title="1.输入输出流的数据传输过程"></a>1.输入输出流的数据传输过程</h2><p><strong>输入:</strong><br>[窗]-&gt;[输入流对象(cin)]</p><p><strong>输出:</strong><br>[输出流对象(cout，cerr，clog)-&gt;[窗口]</p><p>c++从窗口中读取输入时不是直接存储在变量中而是先存储在istream类型对象cin中，输出是也非直接从变量输出到窗口而是先写入ostream对象cout/cerr/clog中，在从对象传输到窗口。</p><h2 id="2-输出运算符“-lt-lt-”"><a href="#2-输出运算符“-lt-lt-”" class="headerlink" title="2.输出运算符“&lt;&lt;”"></a>2.输出运算符“&lt;&lt;”</h2><p>“&lt;&lt;”运算符输出的是一个ostream类型对象，“&lt;&lt;”接受两个运算对象，其中左侧的运算对象必须是一个ostream对象，右侧可以是需要输出的值，“&lt;&lt;”将需要输出的值写入到ostream对象中。<br>std::cout&lt;&lt;”num:”&lt;&lt;a&lt;&lt;std::endl；<br>“&lt;&lt;”连续表达式可以理解为:<br>((std::cout&lt;&lt;”num:”)&lt;&lt;a)&lt;&lt;std::endl；<br>每一个括号最终返回的都是一个ostream对象。其中endl是“操纵符”，运行效果是换行，并将与设备关联的缓冲区的内容刷新到设备中去，如果不写endl则在程序运行结束或缓冲区满后系统自动将缓冲区内容刷新到设备中去。<br>输入运算符“&gt;&gt;”和输出运算符运行逻辑一样。</p><h2 id="3-char与unsigned-char"><a href="#3-char与unsigned-char" class="headerlink" title="3.char与unsigned char"></a>3.char与unsigned char</h2><p>在计算机中char也是分无符号和有符号两类的，char与int等类型不同的是，int等类型不显示标注unsigned默认为有符号数，而char在不同硬件环境中表示的类型可能是不一样的，所以为保证移植性最好在使用时指定signed和unsigned，c++标准不建议使用char来存储数值，这种区别主要出现在char类型向值类型的转换的过程中。</p><h2 id="4-有符号数与无符号数的运算"><a href="#4-有符号数与无符号数的运算" class="headerlink" title="4.有符号数与无符号数的运算"></a>4.有符号数与无符号数的运算</h2><p>在c++运算优先级中，无符号数的优先级大于有符号数，所以当一个表达式中即存在有符号数又不存在无符号数时，运算将被转换为无符号数的运算，由于无符号数表示的最小值是0所以当表达式的运算结果为负数时就会出现运算错误。</p><h2 id="5-c-11的四种变量初始化方式"><a href="#5-c-11的四种变量初始化方式" class="headerlink" title="5.c++11的四种变量初始化方式"></a>5.c++11的四种变量初始化方式</h2><p>int a=0;<br>int a={0};<br>int a{0};</p><h2 id="int-a-0"><a href="#int-a-0" class="headerlink" title="int a(0);"></a>int a(0);</h2><h1 id="二、变量和基本类型"><a href="#二、变量和基本类型" class="headerlink" title="二、变量和基本类型"></a>二、变量和基本类型</h1><hr><p>1.const引用的隐式类型转换<br>举例使用const限定的int类型的引用来引用double类型的变量的过程：double b=3.14;const int a=b;<br>在将double类型变量赋值给const int类型的引用时系统先创建一个临时变量，并将double隐式成int类型的结果存放到临时变量中，然后再将临时变量赋给引用，此时引用本质上是int类型的临时变量的别名，之后如果更改了double类型变量的值，引用值随之改变。</p><h2 id="2-constexpr变量"><a href="#2-constexpr变量" class="headerlink" title="2.constexpr变量"></a>2.constexpr变量</h2><p>constexpr是一个常量表达式，与const不同的是，const限定的变量只能被常量、常量的引用、常量表达式和常量与常量引用的表达式赋值，而constexpr可以被常量、常量的引用、表达式、以及可以在编译阶段就确定返回值的函数赋值。const在程序运行时的本质是在程序用的const的地方直接替换成期对应<br>的常量，而constexpr则是替换其在编译器期计算出来的结果值。<br>constexpr的意义在于constexpr强制要求赋值给变量的表达式必须在编译阶段可计算出结果值，这对很多重复运算的简单表达式直接限定了在编译期只进行一次运算起到了优化效果。</p><h2 id="3-constexpr指针"><a href="#3-constexpr指针" class="headerlink" title="3.constexpr指针"></a>3.constexpr指针</h2><p>被constexpr限定的指针的初始值只能是nullptr或者0或者指向一个地址固定不变的对象，这里需要注意在函数里的任何对象都不是存储在固定地址中的，所以constexpr限定的指针不能指向函数中的对象，全局对象则是存在在固定地址中的所以constexpr限定的指针可以指向这样的对象。</p><h2 id="4-c-11的两种别名声明方法"><a href="#4-c-11的两种别名声明方法" class="headerlink" title="4.c++ 11的两种别名声明方法"></a>4.c++ 11的两种别名声明方法</h2><p>typedef bm int;<br>using bm=int;</p><h2 id="5-decltype类型指示符"><a href="#5-decltype类型指示符" class="headerlink" title="5.decltype类型指示符"></a>5.decltype类型指示符</h2><p>decltype的作用是通过表达式或函数的返回值动态的推断其指示变量的类型，如：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal">decltype(<span class="hljs-function"><span class="hljs-keyword">fun</span>()) <span class="hljs-title">sum</span></span> = x;<span class="hljs-regexp">//sum</span>的类型为<span class="hljs-function"><span class="hljs-keyword">fun</span>函数返回值的类型，<span class="hljs-title">sum</span></span>的值由x赋予<br></code></pre></td></tr></table></figure><h2 id="顶层Const与底层Const"><a href="#顶层Const与底层Const" class="headerlink" title="顶层Const与底层Const"></a>顶层Const与底层Const</h2><p>由于指针本身也是一个对象，所以在Const修饰指针时，就立存在修饰指针或修饰指针所指的对象。如果Const修饰指针则是底层Const，如果修饰指针所指的对象则是顶层Const。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span>* pa;//<span class="hljs-keyword">const</span>修饰指针，所以为底层<span class="hljs-keyword">const</span><br><span class="hljs-built_in">int</span>* <span class="hljs-keyword">const</span> pb;//<span class="hljs-keyword">const</span>修饰pb，所以为顶层<span class="hljs-keyword">const</span><br></code></pre></td></tr></table></figure><hr><h1 id="三、字符串、向量和数组"><a href="#三、字符串、向量和数组" class="headerlink" title="三、字符串、向量和数组"></a>三、字符串、向量和数组</h1><hr><h2 id="1-c-11的string对象的初始化方式"><a href="#1-c-11的string对象的初始化方式" class="headerlink" title="1.c++11的string对象的初始化方式"></a>1.c++11的string对象的初始化方式</h2><p>string s;<br>string str=s;<br>string str(s);<br>string str(“str”);<br>string str=”str”;<br>string str(2,’s’);//这种形式得到的是字符串”ss”,其中括号里只能使用字符。</p><h2 id="2-cin、getline-和cin-getline"><a href="#2-cin、getline-和cin-getline" class="headerlink" title="2.cin、getline()和cin.getline()"></a>2.cin、getline()和cin.getline()</h2><p>cin在对象在从缓存中读取数据时遇到空格符，制表符，换行符时或读至文件尾时会结束读取。<br>getline()可以读取空格符，遇到换行符时或读至文件尾时结束读取。<br>cin.getline()作用和getline一样，只是cin.getline和cin都是标准输出流iosteeam中的对象方法，而getline这是属于string.h中的方法。</p><h2 id="3-string-size-type类型"><a href="#3-string-size-type类型" class="headerlink" title="3.string::size_type类型"></a>3.string::size_type类型</h2><p><code>size_type</code>类型是c++定义的几种标准库类型的几种配套类型，其目的在于解决在不同机器中因为机器字长不同而导致string.size()的返回值无法存储的问题，比如在一个16位的机器中int整型存储的最大字符数为32767，但这对于储存一个文件大小的string来说这个大小是明显不够的，所以c++引入<code>size_type</code>，以解决不同机器上string.size()的返回值一定能被存储。<br><code>size_type</code>的本质是无符号类型所以在使用string.size()和有符号数做运算时要十分注意，因为这会导致计算结果出现异常。<br>需要注意的一点是<code>size_type</code>类型实际上不是一个确定的类型，在使用<code>size_type</code>时应注明<code>size_type</code>的类型，如:<code>string::size_type,vector&lt;int&gt;::size_type</code>。</p><h2 id="4-cctype头文件提供的一些字符判断函数"><a href="#4-cctype头文件提供的一些字符判断函数" class="headerlink" title="4.cctype头文件提供的一些字符判断函数"></a>4.cctype头文件提供的一些字符判断函数</h2><ul><li><p>isalnum(c) 当c是字母过数字时为真</p></li><li><p>isalpha(c) 当c是字母时为真</p></li><li><p>iscntrl(c) 当c是控制字符时为真</p></li><li><p>isdigit(c) 当c是数字时为真</p></li><li><p>isgraph(c) 当c不是空格但可以打印时为真</p></li><li><p>islower(c) 当c是小写字母时为真</p></li><li><p>isprint(c) 当c是可打印字符时为真(即c是空格或c具有可视化形式)</p></li><li><p>ispunct(c) 当c是标点符号时为真(即c不是控制字符、数字、字母、可打印空白中的一种)</p></li><li><p>isspace(c) 当c是空格时为真</p></li><li><p>isupper(c) 当c是大写字母时为真</p></li><li><p>isxdigit(c) 当c是16进制数字时为真</p></li><li><p>tolower(c) 如果c是大写字母则输出其小写</p></li><li><p>toupper(c) 如果c是小写字母则输出其大写</p></li></ul><h2 id="5-c-11的“foreach”"><a href="#5-c-11的“foreach”" class="headerlink" title="5.c++11的“foreach”"></a>5.c++11的“foreach”</h2><p>c++本没有foreach循环，但是c++11为for语句添加了新的语法:<br>for(param:array){}这个for语法每次循环从array中读取一个数据并存放在param中用于操作<br>需要注意的是param如果不使用引用的话，param实际是array中元素的拷贝，此时对param进行修改不会改变array的元素，如需要更改array中的元素的值时需要对param取引用。<br>还有一点十分重要的是不可以在范围for语句中更改array的容量大小，这是因为能被范围for遍历的序列都需要包含begin,end两个返回迭代器的成员，我们可以先看一下范围for的源码:<br>for(auto beg=v.begin(),end=v.end();beg!=end;++beg)<br>{<br>}<br>可以看到在范围for中实际上在循环前就已经存储了可遍历序列的begin,end迭代器，所以如果在循环中改变了序列的大小循环就会出错。</p><h2 id="6-vector容器的初始化方式"><a href="#6-vector容器的初始化方式" class="headerlink" title="6.vector容器的初始化方式"></a>6.vector容器的初始化方式</h2><ul><li>vector<T> v v是一个空的vector</T></li><li>vector<T> v2(v) v2是一个包含v所有副本的的vector</T></li><li>vector<T> v2=v 等价物v2(v)</T></li><li>vector<T> v(n,val) v是一个包含了n个重复元素，每个元素都是val的vector</T></li><li>vector<T> v(n) v是一个包含了n个重复执行了初始化的对象</T></li><li>vector<T> v{a,b,c……} v是一个包含了初始值个数元素的vector，每个元素被赋予对应的初始值</T></li><li>vector<T> v={a,b,c……} 等于v{a,b,c……}</T></li><li><font color="red"> 使用数组初始化vector容器，vector<T>(begin(array),end(array))，其中begin(array)是数组array的首地址，end(array)是数组array的尾地址 </T></font></li></ul><h2 id="7-vector对象能高效增长"><a href="#7-vector对象能高效增长" class="headerlink" title="7.vector对象能高效增长"></a>7.vector对象能高效增长</h2><p>c++标准要求vector容器在运行时能高效快速地添加元素，在c++11标准中vector的动态添加元素的性能要优于预先规定容器大小的性能，只有一种情况例外，就是vector中的元素全部都是相同的时候这种情况会反过来。</p><h2 id="8-迭代器的end"><a href="#8-迭代器的end" class="headerlink" title="8.迭代器的end"></a>8.迭代器的end</h2><p>迭代器的end()并不实际指向某个元素，所以不能对其进行递增或解引用操作。 </p><h2 id="9-iterator和const-iterator"><a href="#9-iterator和const-iterator" class="headerlink" title="9.iterator和const_iterator"></a>9.iterator和const_iterator</h2><p>iterator和<code>const_iterator</code>是标准库定义的迭代器的类型，一般迭代器没有固定的类型，一般使用<code>类型::iterator</code>或<code>const_iterator</code>来确定迭代器的类型，如：<code>vector&lt;int&gt;::iterator  it</code><br><code>iterator</code>为可读可写迭代器，<code>iterator</code>迭代器只能用于非常量容器；<br><code>const_iterator</code>为只读迭代器，<code>const_iterator</code>既可以用于非常量容器又可以用于常量容器，但是常量容器只能使用<code>const_iterator</code>迭代器。</p><h2 id="10-cbegin与cend"><a href="#10-cbegin与cend" class="headerlink" title="10.cbegin与cend"></a>10.cbegin与cend</h2><p>cbegin和cend与begin和end相对，cbegin和cend返回const_iterator迭代器。</p><h2 id="11-迭代器的-gt-运算符"><a href="#11-迭代器的-gt-运算符" class="headerlink" title="11.迭代器的-&gt;运算符"></a>11.迭代器的-&gt;运算符</h2><p>在使用迭代器的过程中经常需要通过解引用后再进行.运算，如：<code>(*it).empty()</code>，操作较为繁琐，c++11对这个操作进行了简化，即通过-&gt;运算来替换<code>(*it).</code>，前面的操作就可以替换为<code>it-&gt;empty()</code></p><h2 id="12-容器的删添操作会是迭代器、引用和指针失效"><a href="#12-容器的删添操作会是迭代器、引用和指针失效" class="headerlink" title="12.容器的删添操作会是迭代器、引用和指针失效"></a>12.容器的删添操作会是迭代器、引用和指针失效</h2><p><font color="red">这是因为容器的删添操作可能会出现存储空间的重新分配，用string作为例子是最贴切的，当我们想一个string字符串中添加一个字符时，如：</font></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sting v</span> = <span class="hljs-string">&quot;str&quot;</span>;<br><span class="hljs-attribute">v</span> = v + ‘s’;<br><br></code></pre></td></tr></table></figure><p><font color="red">程序的实际操作是先创建一个临时变量来存储添加之后的字符串strs，然后再将v指向新分配的存储空间，于是指向之前空间位置的迭代器、引用和指针自然就失效了。</font></p><h2 id="13-迭代器的运算"><a href="#13-迭代器的运算" class="headerlink" title="13.迭代器的运算"></a>13.迭代器的运算</h2><p><img src="https://i.loli.net/2020/08/27/EG2yOZL4H8YvhsT.jpg" alt="Alt"></p><p>迭代器之后同时也可以进行加减运算其结果为dfference_type的带符号整型数表示两个迭代器之间的距离。</p><h2 id="14-数组的特殊性"><a href="#14-数组的特殊性" class="headerlink" title="14.数组的特殊性"></a>14.数组的特殊性</h2><p><font color="red">不能使数组来初始化数组，也不能使用数组来赋值数组，有的编译器支持数组初始化和赋值这是编译器的自身扩展，但仍然不应该这样做，因为当换了编译环境后程序可能就会出错人。</font></p><h2 id="15-存放存放指针的数组和指向数组的指针"><a href="#15-存放存放指针的数组和指向数组的指针" class="headerlink" title="15.存放存放指针的数组和指向数组的指针"></a>15.存放存放指针的数组和指向数组的指针</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">int</span> *<span class="hljs-selector-tag">ptr</span><span class="hljs-selector-attr">[2]</span>;<span class="hljs-comment">//拥有两个指针成员的数组</span><br><span class="hljs-selector-tag">int</span> <span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-tag">ptr2</span><span class="hljs-selector-attr">[2]</span>;<span class="hljs-comment">//错误，不存在引用数组</span><br><span class="hljs-selector-tag">int</span> (*ptr3)<span class="hljs-selector-attr">[2]</span>;<span class="hljs-comment">//指向有两个长度的整型数组的指针</span><br><span class="hljs-selector-tag">int</span> (&amp;ptr4)<span class="hljs-selector-attr">[2]</span>;<span class="hljs-comment">//指向两个长度的整型数组的引用</span><br><br></code></pre></td></tr></table></figure><h2 id="16-数组和指针"><a href="#16-数组和指针" class="headerlink" title="16.数组和指针"></a>16.数组和指针</h2><p>数组的名字实际上就是指向数组收地址的指针，所以下面操作得到是指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> arr[<span class="hljs-number">2</span>] = &#123;&#125;;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ptr</span><span class="hljs-params">(arr)</span></span>;<span class="hljs-comment">//per是一个指向arr首地址的int*类型指针</span><br><br></code></pre></td></tr></table></figure><p><font color="red">使用decltype进行上面的操作不会得到指针，而是得到数组，如：</font></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">decltype</span>(arr) arr<span class="hljs-number">2</span> = &#123;<span class="hljs-number">1</span>&#125;;//arr<span class="hljs-number">2</span>是一个包含一个元素的int型数组<br></code></pre></td></tr></table></figure><p><font color="red">对数组执行下标运算实质上是对指向数组首地址的指针执行下标运算，如：</font></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> i = ia[<span class="hljs-number">2</span>]; <span class="hljs-comment">//实际得到是(ia+2)所指向的元素</span><br></code></pre></td></tr></table></figure><p><font color="red">数组的下标运算只要不超过数组长度就可以执行下标运算，如：含有10个元素数组下标从0-9，但是 下标运算可以取到10，即a[10]，a[10]是数组的尾元素的下一个位置，但是对a[10]只能进行去地址运算(&amp;a[10])，不能对a[10]解引用或读取。</font></p><h2 id="17-ptrdiff-t类型"><a href="#17-ptrdiff-t类型" class="headerlink" title="17.ptrdiff_t类型"></a>17.ptrdiff_t类型</h2><p>和<code>size_type</code>一样，<code>ptrdiff_t</code>是c++11专门定制给begin()与end()的运算结果的类型，用于适应不同机器的字长。<br><font color="red">需要注意的是，内置数组下标值不是<code>ptrdiff_t</code>类型，如：a[1]，1就不是<code>ptrdiff_t</code>类型。</font></p><h2 id="18-void-指针"><a href="#18-void-指针" class="headerlink" title="18.void *指针"></a>18.void *指针</h2><p>任何非常量值都可以存入<code>void *</code>指针中。</p><h1 id="四、表达式"><a href="#四、表达式" class="headerlink" title="四、表达式"></a>四、表达式</h1><hr><h2 id="1-为定义行为"><a href="#1-为定义行为" class="headerlink" title="1.为定义行为"></a>1.为定义行为</h2><p>c++中存在一些为定义行为，如&lt;&lt;运算符在c++中并没有定义其后表达式的运算顺序，此时运行下面代码就会出现为定义行为。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;++i&lt;&lt;<span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure><p>此时会出现0，1或1，1两种结果，这是因为&lt;&lt;没有明确指定何时及如何对运算对象求值，但是在实际使用过程中并没有出现上述情况，这可能是编译器为&lt;&lt;规定了运算顺序。</p><h2 id="2-溢出与其他算术异常"><a href="#2-溢出与其他算术异常" class="headerlink" title="2.溢出与其他算术异常"></a>2.溢出与其他算术异常</h2><p><img src="https://i.loli.net/2020/09/04/QRnNjiTqEeOGaLV.jpg" alt="6"></p><h2 id="3-运算符的优先级"><a href="#3-运算符的优先级" class="headerlink" title="3.运算符的优先级"></a>3.运算符的优先级</h2><p><img src="https://i.loli.net/2020/10/09/6aVu9jBoswIgUEY.jpg" alt="Alt"></p><h2 id="4-前置递增运算符与后置递增运算符的运行过程"><a href="#4-前置递增运算符与后置递增运算符的运行过程" class="headerlink" title="4.前置递增运算符与后置递增运算符的运行过程"></a>4.前置递增运算符与后置递增运算符的运行过程</h2><p>前置递增运算符先将对象递增之后再返回递增后的结果，而后置递增运算符则先创建一个临时变量先将旧的值存储起来，然后再将变量递增，再将旧的值返回。<br>相对于前置递增运算符，后置递增运算符需要创建一个临时变量，这就产生了一个消耗，在一些普通的后置递增运算中可能不大可看得出来，但在较为复杂的迭代器中这种额外的消耗就会产生巨大的性能浪费，所以平时使用时尽量使用前置递增运算符。</p><h2 id="5-表达式在运算过程中值发生变化"><a href="#5-表达式在运算过程中值发生变化" class="headerlink" title="5.表达式在运算过程中值发生变化"></a>5.表达式在运算过程中值发生变化</h2><p><font color="red">在一个运算表达式中，参与运算的值不应该在运算的过程中发生变化，否则极易造成未定义行为，如：</font><br><font color="red"><code>v[i++]&lt;v[i]</code>，在大于号运算的过程中v[i++]的值向后移动了一位，造成了值的变化，由于C++没有定义二元运算符两端未定义自增运算符的运算顺序，所级就造成了未定义行为。</font></p><h2 id="6-有符号数的位运算"><a href="#6-有符号数的位运算" class="headerlink" title="6.有符号数的位运算"></a>6.有符号数的位运算</h2><p>有符号数尽量不要做位运算，因为位运算容易改变有符号数的符号位导致未定义行为。</p><h2 id="7-位运算中的类型提升"><a href="#7-位运算中的类型提升" class="headerlink" title="7.位运算中的类型提升"></a>7.位运算中的类型提升</h2><p>在程序编写时需要注意，任何占字节小于int类型的类型变量进行位运算时都会产生类型提升而被转换成int类型，如下代码所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">char</span> s=<span class="hljs-string">&#x27;s&#x27;</span>;<br><span class="hljs-keyword">short</span> a=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">bool</span> b=<span class="hljs-literal">true</span>;<br><span class="hljs-keyword">long</span> c=<span class="hljs-number">2</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(s)&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(~s)&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(s&lt;&lt;<span class="hljs-number">1</span>)&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;----------&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(a)&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(~a)&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;----------&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(b)&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(~b)&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;----------&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(c)&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(~c)&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;----------&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;~s&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;~b&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：<br><img src="https://i.loli.net/2020/10/23/GUI54xhOrQs7oyK.jpg" alt="Alt"></p><h2 id="8-sizeof计算指针大小"><a href="#8-sizeof计算指针大小" class="headerlink" title="8.sizeof计算指针大小"></a>8.sizeof计算指针大小</h2><p>sizeof在计算指针时有个很有趣的现象，因为sizeof满足右结合律且优先级与<code>*</code>相同，所以在<code>sizeof *p</code>中，先对p解引用，然后在对解引用后的内容计算所占内存大小，由于sizeof并没有使用解引用的内容，所以<code>*p</code>是否为空是否有效对sizeof的计算没有影响。<br><code>sizeof *p</code> == <code>sizeof(*p)</code></p><h2 id="9-隐式转换的过程"><a href="#9-隐式转换的过程" class="headerlink" title="9.隐式转换的过程"></a>9.隐式转换的过程</h2><p>以<code>int a=3.14+3；</code>为例<br>在这个例子中3.14是山比double类型，3是int类型，运算时为了保证精度C++会将int类型转换成double类型，而不是因为结果是int类型而将double类型转换成int类型，所以在表达示右侧的运算过程得到的结果是一个double类型的值，当这个值被赋值给a的时候才进行double到int的类型转换。</p><hr><h1 id="五、语句"><a href="#五、语句" class="headerlink" title="五、语句"></a>五、语句</h1><hr><h2 id="1-switch语句跨case标签引用变量"><a href="#1-switch语句跨case标签引用变量" class="headerlink" title="1.switch语句跨case标签引用变量"></a>1.switch语句跨case标签引用变量</h2><p>若需要在一个 case 语句下定义变量同时在多个 case 语下使用这个变量，则定义变量时不能同时初始化变量，应另起等于初始变量，否则编译器会报跨标签访问错误，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">switch</span> (a)<br>&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">int</span> b;  <span class="hljs-comment">//如果直接int b=1;则会报跨标签访问错误</span><br>        b=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        ;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-C-无法捕获计算溢出异常和除0异常"><a href="#2-C-无法捕获计算溢出异常和除0异常" class="headerlink" title="2.C++无法捕获计算溢出异常和除0异常"></a>2.C++无法捕获计算溢出异常和除0异常</h2><p>C++认为计算溢出和除0异常属于底层事件，应被同样底层的事件去处理，所以C++没有提供计算溢出和除0异常，如果需要捕获这两类异常在Windows系统中应使用Windows提供的SEH模型<code>__try</code>、<code>__except</code>、<code>__finally</code>异常语句，使用方法和try-catch基本类似，与try-catch不同的是，SEH中使用的是<code>__try-__except</code>搭配和<code>__try-__finally</code>搭配。</p><hr><h1 id="六、函数"><a href="#六、函数" class="headerlink" title="六、函数"></a>六、函数</h1><hr><h2 id="1-静态局布变量"><a href="#1-静态局布变量" class="headerlink" title="1.静态局布变量"></a>1.静态局布变量</h2><p>在函数体内使用static关键字可以效静态局布量，静态局布变量的生命周期从变量定义到程序结束，但是静态局布变量只对函数可见，在函数外不可访问。</p><h2 id="2-C-程序的编译过程"><a href="#2-C-程序的编译过程" class="headerlink" title="2.C++程序的编译过程"></a>2.C++程序的编译过程</h2><p><img src="https://i.loli.net/2020/11/09/bJ5xRFg6TGHnLCO.jpg" alt="Alt"></p><h2 id="3-函数调用过程中的形参创建"><a href="#3-函数调用过程中的形参创建" class="headerlink" title="3.函数调用过程中的形参创建"></a>3.函数调用过程中的形参创建</h2><p>函数的每一次调用都会重新创建形参并传入实参对其进行初始化，形餐盘类型决定了形参与实参的交互类型，如果形参是引用类型，则形参与相对应的实参相绑定，作为实参的别名使用；如果形参是值类型，则实参的值拷贝给形参，形参与实参相互独立。</p><h2 id="4-函数的指针参数传递"><a href="#4-函数的指针参数传递" class="headerlink" title="4.函数的指针参数传递"></a>4.函数的指针参数传递</h2><p><font color="red">当指针作为实参传递给函数形参时，传递的是指针的值拷贝而不是指针所指的对象，且形参指针与实参指针是两个不同的指针，此时形参指针与实参指针指向同一对象，修改形参的指针指向不会影实参指针。</font></p><h2 id="5-引用形参的限制"><a href="#5-引用形参的限制" class="headerlink" title="5.引用形参的限制"></a>5.引用形参的限制</h2><ul><li><p>如果将函数的参数定义普通引用参数，那么这个形参就无法接受const对象、字面值和需要类型转换的对象作为实参。</p></li><li><p>如果将函数的参数定义为const引用参数，这个参数可以接受第一条中的参数，但是却无法修改参数的值。</p></li></ul><h2 id="6-数组的两个特殊性质"><a href="#6-数组的两个特殊性质" class="headerlink" title="6.数组的两个特殊性质"></a>6.数组的两个特殊性质</h2><ul><li>数组不可被拷贝</li><li>数组再使用时被转换为指针</li></ul><h2 id="7-数组引用形参"><a href="#7-数组引用形参" class="headerlink" title="7.数组引用形参"></a>7.数组引用形参</h2><p>当我们使用数组作普通形参时，</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">void <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(int* arr)</span></span>;<br>void <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(int arr[])</span></span>;<br>void <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(int arr[<span class="hljs-number">10</span>])</span></span>;<br></code></pre></td></tr></table></figure><p>表示的都是同一个函数，且形参可接受任意长度的实参数组，但是当将普通形参改为引用形参时，</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">void <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(int (&amp;arr)</span></span>[<span class="hljs-number">10</span>]);<br></code></pre></td></tr></table></figure><p><code>(&amp;arr)</code>中()不可缺少，否则形参变成引用的数组而非数组的引用，且形参只能接收长度为10的数组。</p><h2 id="8-main函数传参"><a href="#8-main函数传参" class="headerlink" title="8.main函数传参"></a>8.main函数传参</h2><p>有的时候我们会遇到这样的main函数：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>通常情况下，直接使用argv，argv中的内容是空的，那么main函数在什么情况下会接收参数呢？<br>事实上main函数本身就是当前程序的入口，在当前程序中没有其他程序为main函数传入参数了，当我们把写好的程序打包后在外部调用时就可以给main函数传入参数了，如在CMD中调程序</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">prog -o -d ofile data0<span class="hljs-regexp">//</span>prog为程序名<br></code></pre></td></tr></table></figure><p><font color="red">需要注意的是argv数组的0号索引存储程序的名字，参数从1号索引开始存储，且最后一个索引位置固定内容为0</font></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPlus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Dev】DevExpress应用</title>
    <link href="/2021/02/03/%E3%80%90Dev%E3%80%91DevExpress%E5%BA%94%E7%94%A8/"/>
    <url>/2021/02/03/%E3%80%90Dev%E3%80%91DevExpress%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="一、大纲"><a href="#一、大纲" class="headerlink" title="一、大纲"></a>一、大纲</h2><p>最近使用DevExpress做C/S开发碰到了一些问题，在解决问题的同时在这里做一下记录，下面列出涉及到技术点</p><ul><li><strong>Dev框架下GridControl与GridView</strong></li><li><strong>使用模板列动态替换GridView的指定列</strong></li><li><strong>GridView分组并去掉列名的前缀</strong></li><li><strong>FPT服务器文件预览与下载</strong></li><li><strong>单元格添加按钮并添加自定义点击事件</strong></li><li><strong>GridView数据导出到Excel</strong></li><li><strong>向Word模板中写数据</strong></li></ul><a id="more"></a><h2 id="二、Dev框架下的GridControl和GridView"><a href="#二、Dev框架下的GridControl和GridView" class="headerlink" title="二、Dev框架下的GridControl和GridView"></a>二、Dev框架下的GridControl和GridView</h2><h3 id="1-GridControl和GridView的关系"><a href="#1-GridControl和GridView的关系" class="headerlink" title="1.GridControl和GridView的关系"></a>1.GridControl和GridView的关系</h3><p>Dev框架下GridControl负责操作数据，GridView负责展示数据，GridControl是GridView的容器，一个GridControl可以容纳多个GridView，在GridView中的任何数据操作都不会影响到GridControl中的源数据，即当我们将GridControl中数据重新刷入GridView时，GridView中数据操作会被清除，所以如果我们有要在本地展示的数据则需要在GridControl刷数据进入GridView的时候重新再刷入一次本地数据。</p><h3 id="2-GridControl输入数据到GridView的原理"><a href="#2-GridControl输入数据到GridView的原理" class="headerlink" title="2.GridControl输入数据到GridView的原理"></a>2.GridControl输入数据到GridView的原理</h3><p>GridControl的数据刷入GridView的操作由Dev框架执行，我们需要做的只是把数据绑定到GridControl.DataSource中即可。</p><p>只有当GridView中存在与GridControl数据源对应列时，GridControl才能将对应列的数据刷入GridView的对应列中，这里的对应列指的是GridView中列的<code>FiledName</code>的值与GridControl数据源的列名相同，且大小写敏感。</p><p>在GridView的列属性中有三个极为重要的属性：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090745.png"></p><ul><li><p>Name：列在程序中操作的标识符，类似变量名，对列的操作都由它来引用，如：修改colfilename列的列宽</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">colfilename.Width = <span class="hljs-number">300</span>;<br></code></pre></td></tr></table></figure></li><li><p>ColumnEdit：用于挂载模板列的属性，可以将列动态的替换为其他类型的控件，例子中是将列挂载了一个多行编辑框，这样就可以在单元格中显示多行内容</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090756.png"></p></li><li><p>FieldName：FieldName属性是列与GridControl数据源对应的标志，如果想要将GridControl数据源中某一列的数据刷入当前列，那么当前列的FieldName的取值必须和数据源中对应列的列名一致，并且FielName也是用来获取表格数据的标识，如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">gridView_FileViewer.GetFocusedDataRow()[<span class="hljs-string">&quot;path&quot;</span>]<span class="hljs-comment">//取所选行的path列单元格的数据</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-向GridView存在而GridControl中不存在的列刷入数据"><a href="#3-向GridView存在而GridControl中不存在的列刷入数据" class="headerlink" title="3.向GridView存在而GridControl中不存在的列刷入数据"></a>3.向GridView存在而GridControl中不存在的列刷入数据</h3><p>有的时候为了展示需要，我们需要在GridView中增加新列刷入自己的数据，而新增列在GridControl的数据源中没有与之对应的列，即在数据源中没有对应的字段（这里的数据源通常情况下指的就是数据库中的表），此时我们就需要在GridControl.Datasource中动态地添加一列来与新增列对应。</p><p>为什么要要在GridControl.Datasource中动态地添加一列呢？</p><p>这可能是由GridControl和GridView的内部机制影响的，当一列在GridView中存在而GridControl中不存在时，我们是无法向此列写入数据的，即使数据是来自本地而不是数据库，并且编译器会报错：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090901.png"></p><p>如果我们要向GridView存在而GridControl中不存在的列刷入数据，那么我们必须在GridControl的DataSource中动态的加列，下面是示例代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LoadFileNameColumn</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs args</span>)</span><br><span class="hljs-function"></span>&#123;<br>GridColumn col = gridView_JobPlacement.Columns[<span class="hljs-string">&quot;xgwj&quot;</span>];<span class="hljs-comment">//取表格xgwj列的索引</span><br><br><span class="hljs-comment">/*代码块说明：</span><br><span class="hljs-comment">*   作用：向gridview的datasource动态添加filename列，使GridView中的filename列与DataSource中的filename字段对应</span><br><span class="hljs-comment">*   说明：因为在GridView中添加了filename列如果在GridView的DataSource中没有与之对应的字段，</span><br><span class="hljs-comment">*       则无法对filename列做任何操作</span><br><span class="hljs-comment">*/</span><br>DataTable gridViewTable = gridControl_JobPlacement.DataSource <span class="hljs-keyword">as</span> DataTable;<span class="hljs-comment">//取DataSource的引用并转换成DataTable</span><br><span class="hljs-keyword">if</span> (!gridViewTable.Columns.Contains(<span class="hljs-string">&quot;filename&quot;</span>))<span class="hljs-comment">//判断DataSource中是否已存在filename列</span><br>&#123;<br>DataColumn dsFileNameCol = <span class="hljs-keyword">new</span> DataColumn();<span class="hljs-comment">//创建新列</span><br>dsFileNameCol.ColumnName = <span class="hljs-string">&quot;filename&quot;</span>;<span class="hljs-comment">//将新列命名为filename</span><br>         gridViewTable.Columns.Add(dsFileNameCol);<span class="hljs-comment">//将新列添加到DataSource中</span><br>&#125;<span class="hljs-comment">//至此，DataSource中就存在与GridView中的filename列对应的filename列了</span><br><br><span class="hljs-comment">//遍历GridView所有行，对有文件组编码的行在filename列载入文件列表信息</span><br> <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> rowIndex = <span class="hljs-number">0</span>; rowIndex &lt; gridView_JobPlacement.RowCount; rowIndex++)<br>&#123;     <br> DataRow row = gridView_JobPlacement.GetDataRow(rowIndex);<span class="hljs-comment">//根据索引数据行</span><br><span class="hljs-keyword">if</span> (row[<span class="hljs-string">&quot;xgwj&quot;</span>].ToString() != <span class="hljs-string">&quot;&quot;</span>)<span class="hljs-comment">//如果数据行中的xgwj列单元格不为空，则向单元格刷入指定数据</span><br>&#123;<br><span class="hljs-built_in">string</span> fileGroupTmp = gridView_JobPlacement.GetRowCellDisplayText(rowIndex, col);<span class="hljs-comment">//取指定单元格显示的内容</span><br><span class="hljs-built_in">string</span> fileGroup = CodingTool.GetFileGroup(fileGroupTmp);<span class="hljs-comment">//将单元格存储的文件组编码转换成数据库可用的编码</span><br>DataTable table = bll.SelectFromFileTableByFileGroup(fileGroup);<span class="hljs-comment">//根据编码到数据库查询文件列表</span><br><span class="hljs-keyword">foreach</span>(DataRow tableRow <span class="hljs-keyword">in</span> table.Rows)<span class="hljs-comment">//遍历文件列表将文件名刷入新增列</span><br>&#123;<br>row[<span class="hljs-string">&quot;filename&quot;</span>] += tableRow[<span class="hljs-string">&quot;filename&quot;</span>]+<span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-comment">//将数据刷入filename列单元格</span><br>&#125;<br>         &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、使用模板列动态替换GridView中的指定列"><a href="#三、使用模板列动态替换GridView中的指定列" class="headerlink" title="三、使用模板列动态替换GridView中的指定列"></a>三、使用模板列动态替换GridView中的指定列</h2><p>有的时候为了保密需要，在数据库中部分字段会用编码标识，如：人名使用编码标识，张三对应编码001，但是在表格中展示的时候应该显示人名而不是编码，此时我们就需要用到模板列的动态替换。</p><p>直接上代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#">Security.BLL.userinfo ubll = <span class="hljs-keyword">new</span> Security.BLL.userinfo();<br><br>RepositoryItemGridLookUpEdit replaceRegistrant = <span class="hljs-keyword">new</span> RepositoryItemGridLookUpEdit();<br>replaceRegistrant.DataSource = ubll.GetAllList().Tables[<span class="hljs-number">0</span>];<span class="hljs-comment">//绑定数据源到RepositoryItemGridLookUpEdit</span><br>replaceRegistrant.DisplayMember = <span class="hljs-string">&quot;fullname&quot;</span>;  <span class="hljs-comment">//选择要替换显示的字段</span><br>replaceRegistrant.ValueMember = <span class="hljs-string">&quot;ID&quot;</span>;  <span class="hljs-comment">//</span><br>replaceRegistrant.NullText = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-comment">//字段为空时要显示的内容</span><br>gridView_JobPlacement.Columns[<span class="hljs-string">&quot;djr&quot;</span>].ColumnEdit = replaceRegistrant;<span class="hljs-comment">//将RepositoryItemGridLookUpEdit绑定到GridView的“djr”列</span><br><br>RepositoryItemGridLookUpEdit replacePricipal = <span class="hljs-keyword">new</span> RepositoryItemGridLookUpEdit();<br>replacePricipal.DataSource = ubll.GetAllList().Tables[<span class="hljs-number">0</span>];<span class="hljs-comment">//绑定数据源到RepositoryItemGridLookUpEdit</span><br>replacePricipal.DisplayMember = <span class="hljs-string">&quot;fullname&quot;</span>;  <span class="hljs-comment">//选择要替换显示的字段</span><br>replacePricipal.ValueMember = <span class="hljs-string">&quot;ID&quot;</span>;  <span class="hljs-comment">//</span><br>replacePricipal.NullText = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-comment">//字段为空时要显示的内容</span><br>gridView_JobPlacement.Columns[<span class="hljs-string">&quot;fzr&quot;</span>].ColumnEdit = replacePricipal;<span class="hljs-comment">//将RepositoryItemGridLookUpEdit绑定到GridView的“djr”列</span><br></code></pre></td></tr></table></figure><p>这是通过代码添加动态的添加模板列，同时我们也可以在列属性中的ColumnEdit属性中静态的添加模板列。</p><h2 id="四、GridView分组并去掉列名的前缀"><a href="#四、GridView分组并去掉列名的前缀" class="headerlink" title="四、GridView分组并去掉列名的前缀"></a>四、GridView分组并去掉列名的前缀</h2><h3 id="1-分组"><a href="#1-分组" class="headerlink" title="1.分组"></a>1.分组</h3><p>GridView分组只需要在需要分组的列的属性中将GroupIndex属性值由“-1”改为0即可，如果需要二级分组则在需要分组的列的属性中将GroupIndex属性值由“-1”改为1，以此类推需要三级分组则改为2。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090912.png"></p><h3 id="2-去掉列名前缀"><a href="#2-去掉列名前缀" class="headerlink" title="2.去掉列名前缀"></a>2.去掉列名前缀</h3><p>分完组后如果不做修改我们加载数据之后表格是这样的：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090919.png"></p><p>有时我们不需要显示列名前缀，这时我们需要修改GridView的GroupFormat属性修改为{1}，GroupFormat属性的默认值是<code>&#123;0&#125;: [#image]&#123;1&#125; &#123;2&#125;</code>，其中</p><ul><li>{0}显示列标题</li><li>[#image]显示图片</li><li>{1}显示列的内容值</li><li>{2}显示列的摘要</li></ul><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090923.png"></p><p>设置好之后，效果是这样的:</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090936.png"></p><h2 id="四、FTP文件预览与下载"><a href="#四、FTP文件预览与下载" class="headerlink" title="四、FTP文件预览与下载"></a>四、FTP文件预览与下载</h2><p>直接上代码，解释都放注释上了：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PreviewFile</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender,EventArgs e</span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (fileDic == <span class="hljs-literal">null</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//自定义函数，获取文件在服务器中的路径</span><br>    <span class="hljs-built_in">string</span> serverPath = ServerFTP.CreateFilePathInServerBySQLPath(gridView_FileViewer.GetFocusedDataRow()[<span class="hljs-string">&quot;path&quot;</span>].ToString());<br>    <span class="hljs-comment">//获取文件名</span><br>    <span class="hljs-built_in">string</span> fileName = gridView_FileViewer.GetFocusedDataRow()[<span class="hljs-string">&quot;file&quot;</span>].ToString();<br>    <span class="hljs-comment">//根据路径将文件下载到本地，并返回文件路径</span><br>    <span class="hljs-built_in">string</span> savePath = ServerFTP.currentMode.RequestFile(serverPath,fileName,GeneralLib.FTPDownloadStyle.CACHE);<br>    <span class="hljs-keyword">if</span> (savePath != <span class="hljs-string">&quot;&quot;</span>)<br>    &#123;<br>        <span class="hljs-comment">//调用系统软件打开文件</span><br>        FileIO.OpenFileInWindows(savePath);<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>这里挑几个比较重要的函数讲解</p><p><strong>RequestFile</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">RequestFile</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> serverPath,<span class="hljs-built_in">string</span> fileName, FTPDownloadStyle style</span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">string</span> savePath = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">switch</span> (style)<br>    &#123;<br>        <span class="hljs-comment">//下载文件到缓存临时文件夹，用于预览</span><br>        <span class="hljs-keyword">case</span> FTPDownloadStyle.CACHE:<br>            savePath = Path.Combine(ServerFTP.cachePath, fileName);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//下载文件到所选的文件夹，用于下载</span><br>        <span class="hljs-keyword">case</span> FTPDownloadStyle.CHOOSEDIC:<br>            savePath = FileIO.ChooseSaveFile(fileName, <span class="hljs-string">&quot;&quot;</span>, ServerFTP.chooseTempDic);       <br>            <span class="hljs-comment">//保存所选的文件夹，以便下次打开直接进入相应目录</span><br>            ServerFTP.chooseTempDic = Path.GetDirectoryName(savePath);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (savePath == <span class="hljs-literal">null</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//判断目录是否存在</span><br>    <span class="hljs-keyword">if</span> (!Directory.Exists(Path.GetDirectoryName(savePath)))<br>    &#123;<br>        <span class="hljs-comment">//如果不存在则创建目录</span><br>        Directory.CreateDirectory(Path.GetDirectoryName(savePath));<br>    &#125;<br><br><span class="hljs-comment">//根据文件路径创建FPT连接实例</span><br>    FtpWebRequest ftp = (FtpWebRequest)WebRequest.Create(serverPath);<br>    <span class="hljs-comment">//从配置文件中读取登录项</span><br>    ICredentials credentials = <span class="hljs-keyword">new</span> NetworkCredential(Config.Get[<span class="hljs-string">&quot;ftp_username&quot;</span>], Config.Get[<span class="hljs-string">&quot;ftp_password&quot;</span>]);<br>    <span class="hljs-comment">//配置FPT服务器登录项</span><br>    ftp.Credentials = credentials；<br>    <span class="hljs-comment">//配置FPT操作为下载文件</span><br>    ftp.Method = WebRequestMethods.Ftp.DownloadFile;<br><span class="hljs-comment">//向FPT服务器发出操作请求</span><br>    FtpWebResponse response = (FtpWebResponse)ftp.GetResponse();<br>    <span class="hljs-comment">//创建流缓冲区接收FPT服务器反馈的字节流</span><br>    Stream responseStream = response.GetResponseStream();<br>    <span class="hljs-comment">//根据存储路径在本地创建文件</span><br>    FileStream fs = File.Create(savePath);<br>    <span class="hljs-comment">//创建用于批量取缓冲区字节数据的数据</span><br>    <span class="hljs-built_in">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[ConstLib.BUFFER_SIZE];<br>    <span class="hljs-built_in">int</span> read = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">do</span><br>    &#123;<br>        <span class="hljs-comment">//将缓冲区的字节数据读入字节数组</span><br>        read = responseStream.Read(buffer, <span class="hljs-number">0</span>, buffer.Length);<br>        <span class="hljs-comment">//将字节数组的数据写入到文件中</span><br>        fs.Write(buffer, <span class="hljs-number">0</span>, read);<br>        <span class="hljs-comment">//清楚fs的流缓冲区，这里fs的流缓冲区与responseStream流缓冲区不是同一个缓冲区，需要注意</span><br>        fs.Flush();<br>    &#125;<br>    <span class="hljs-keyword">while</span> (read != <span class="hljs-number">0</span>)；<br>        <br>    fs.Flush();<br>    <span class="hljs-comment">//关闭文件</span><br>    fs.Close();<br>    <br>    <span class="hljs-keyword">return</span> savePath;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>OpenFileInWindows</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Process <span class="hljs-title">OpenFileInWindows</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> filePath</span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//创建一个新的进程</span><br>    ProcessStartInfo info = <span class="hljs-keyword">new</span> ProcessStartInfo();<br>    <span class="hljs-comment">//设置进程要打开的文档，Windows会根据文件类型的默认开打应用来启动对应应用程序来打开文件</span><br>    info.FileName = Path.GetFileName(filePath);<br>    <span class="hljs-comment">//设置启动进程的初始目录</span><br>    info.WorkingDirectory = Path.GetDirectoryName(filePath);<br>    <span class="hljs-comment">//设置进程启动后，窗口的状态，可以设置为最大化，最小化和正常</span><br>    info.WindowStyle = ProcessWindowStyle.Normal;<br>    <span class="hljs-comment">//启动进程</span><br>    Process proc = Process.Start(info);<br><br>    <span class="hljs-keyword">return</span> proc;<br>&#125;<br></code></pre></td></tr></table></figure><p>当关闭文件时清楚临时文件夹的内容</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CleanCacheDirectory</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//判断临时文件夹是否存在</span><br>    <span class="hljs-keyword">if</span> (!Directory.Exists(ServerFTP.cachePath))<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        <span class="hljs-comment">//等待系统将占用文件的进程杀死再清空临时文件夹</span><br>        System.Threading.Thread.Sleep(<span class="hljs-number">500</span>);<br>        <span class="hljs-comment">//获取临时文件夹目录信息</span><br>        DirectoryInfo dicInfo = <span class="hljs-keyword">new</span> DirectoryInfo(ServerFTP.cachePath);<br>        <span class="hljs-comment">//直接删除临时文件夹</span><br>        dicInfo.Delete(<span class="hljs-literal">true</span>);<br>    &#125;<br>    catch<br>    &#123;<br>        <span class="hljs-comment">//如果目录被其他进程占用，则暂时不清空临时文件夹</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我使用的是最简单的直接删除临时文件夹的暴力删除法，这样做会有一个问题就是，在程序删除文件夹的时候，可能预览文件的进程还没有被系统杀死或有其他的进程占用了目录中文件，这都会导致目录删除失败而抛出异常，我的解决方案是在删除目录之前等待500ms，等待系统将预览文件的进程杀死后在删除文件夹，但是如果是其他的进程占用了目录，则需要手动结束进程才能继续删除临时文件夹，我的解决方案是，如果有其他进程占用了目录，则本次本次临时缓冲区先不删除，等下次有机会再删除。所以这里的try-catch不是用来抛出异常的，而是用来推出函数的。</p><p>当然比较理想的删除方法是遍历整个目录中文件和子文件夹，依次删除目录下文件和子文件夹，有被其他进程占用的文件暂时不删除。这样就可以只留下被占用的文件，而不是整个目录。</p><h2 id="五、单元格添加按钮并添加自定义点击事件"><a href="#五、单元格添加按钮并添加自定义点击事件" class="headerlink" title="五、单元格添加按钮并添加自定义点击事件"></a>五、单元格添加按钮并添加自定义点击事件</h2><p>有时我们需要向某一列的单元格添加点击事件，甚至向某一个单元格添加点击事件，这时我们就需要向单元格添加按钮了。</p><h3 id="1-向单元格添加简单的点击事件"><a href="#1-向单元格添加简单的点击事件" class="headerlink" title="1.向单元格添加简单的点击事件"></a>1.向单元格添加简单的点击事件</h3><p>如果我们只想在某一单元格添加简单的点击事件</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">gridView_JobPlacement_RowCellClick</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, RowCellClickEventArgs e</span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (e.RowHandle == <span class="hljs-number">1</span> &amp;&amp; e.Column.FieldName == <span class="hljs-string">&quot;filename&quot;</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (e.Button == MouseButtons.Left)<br>        &#123;<br>            <span class="hljs-comment">//todo</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (e.Button == MouseButtons.Right)<br>        &#123;<br><span class="hljs-comment">//todo</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(e.Button == MouseButtons.Moddle)<br>        &#123;<br>            <span class="hljs-comment">//todo</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这时我们需要用到RowCellClick事件，RowCellClick事件在鼠标点击单元格时触发，然后我们只需要判定鼠标点击是哪一行哪一列，就可以实现某一个单元格的点击事件了。当然我们也可以通过添加按钮来实现。</p><h3 id="2-向单元格添加复杂点击事件"><a href="#2-向单元格添加复杂点击事件" class="headerlink" title="2.向单元格添加复杂点击事件"></a>2.向单元格添加复杂点击事件</h3><p>如果我们想向单元格添加一系列复杂的点击事件，如在某一单元格内做文件的上传，预览，下载，删除等操作，这时我们就需要借助模板列了，使用模板列是无法只向某一个单元添加点击事件的，因为模板列挂载的是一整列。</p><p>我需要用到模板列<code>RepositoryItemButtonEdit</code>，我可以在列属性里静态挂载，也可以在代码中动态挂载，重要的是我们需要用到<code>RepositoryItemButtonEdit</code>属性里的<code>Buttons</code>属性，向Buttons属性里添加元素。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090945.png"></p><p>光是添加按钮单元中还是看不到按钮的，我们还需要将每个按钮的Kind属性设置为Glyph，这样我们才能在单元格中看到按钮</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090950.png"></p><p>添加完按钮就可以向对应按钮添加点击事件了，我们可以发现在列属性里找不到事件，所以我们需要在代码中为按钮添加点击事件，这时我们需要用到<code>repositoryItemButtonEdit.Buttons[0].Click</code>，其中repositoryItemButtonEdit是模板列的名字，Buttons[0]是第一个按钮的引用，我们只需要向Click事件添加我们想要执行的函数即可。</p><h2 id="六、GridView数据导出到Excel"><a href="#六、GridView数据导出到Excel" class="headerlink" title="六、GridView数据导出到Excel"></a>六、GridView数据导出到Excel</h2><p> GridView的数据要导出到Excel有很多种方法，可以最直接的就是遍历GridView，然后将数据写入Excel，这算是比较麻烦的做法了，事实上Dev已经提供了一些便捷的方法。</p><h3 id="1-GetAllFilteredAndSortedRows-方法"><a href="#1-GetAllFilteredAndSortedRows-方法" class="headerlink" title="1.GetAllFilteredAndSortedRows()方法"></a>1.GetAllFilteredAndSortedRows()方法</h3><p>Dev提供了一个<code>GridView.DataController.GetAllFilteredAndSortedRows()</code>方法，可以用于提取GridView当前数据，在筛选排序等操作之后更改了的数据也可以提取。</p><p><font color="red"> 但是，GridView类中的DataController对象在VS中被隐藏了，即通过提示器是找不到GDataController对象的的，只能通过手写调用。</font></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090957.png"></p><p>GetAllFilteredAndSortedRows()方法返回的是一个IList泛型列表，数据写入Excel一就要自己手动写入，写入方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//需要包含的引用</span><br><span class="hljs-keyword">using</span> DevExpress.XtraSpreadsheet;<br><span class="hljs-keyword">using</span> DevExpress.Spreadsheet;<br><br>SpreadsheetControl ss = <span class="hljs-keyword">new</span> SpreadsheetControl();<br><span class="hljs-keyword">var</span> book = ss.Document;<br>Worksheet sheet = book.Worksheets[<span class="hljs-number">0</span>];<br>sheet.Import(table, <span class="hljs-literal">true</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-comment">//table是DataTable类型，也是要导出到Excel的数据</span><br></code></pre></td></tr></table></figure><p><font color="red"> 其中有一点需要格外注意，在使用Import函数时需要引用<code>DevExpress.Docs</code>程序集，因为Import函数在这个程序集里，Dev在DevExpress.Docs程序集里给Worksheet的父类ExternalWorksheet写了扩展，也就是扩展了Import函数等，其中DevExpress.Docs程序集和DevExpress.Spreadsheet程序集的命名空间是一样的，如果没有搞清楚这一点很容易产生玄学问题🥴</font></p><h3 id="2-GridView-Export-方法"><a href="#2-GridView-Export-方法" class="headerlink" title="2.GridView.Export()方法"></a>2.GridView.Export()方法</h3><p>最简单的方法就是使用Dev官方提供的导出方法GridView.Export().</p><p>Dev已经在GridView中添加了官方的Export方法，支持多种导出格式：</p><ul><li>Xls</li><li>Xlsx</li><li>Html</li><li>Mht</li><li>Pdf</li><li>Text</li><li>Rtf</li><li>Csv</li><li>Image</li><li>Docx</li></ul><p>同时提供三种重载：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326091003.png"></p><p>使用方法也很简单：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 将GridView中的数据导出到Excel</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;fileName&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;view&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ExportExcel</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> fileName, GridView view</span>)</span><br><span class="hljs-function"></span>&#123;<br>    SaveFileDialog sfd = <span class="hljs-keyword">new</span> SaveFileDialog();<br>    sfd.Title = <span class="hljs-string">&quot;另存为&quot;</span>;<br>    sfd.InitialDirectory = <span class="hljs-string">&quot;C:\\&quot;</span>;<br>    sfd.Filter = <span class="hljs-string">&quot;Excel文件(*.xlsx) | *.xlsx&quot;</span>;<br>    sfd.FileName = fileName;<span class="hljs-comment">//fileName文件名不需要包含后缀</span><br>    <span class="hljs-keyword">if</span> (sfd.ShowDialog() == DialogResult.OK)<br>    &#123;<br>        view.Export(DevExpress.XtraPrinting.ExportTarget.Xlsx, sfd.FileName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>view.Export是dev自带的导出方法，在导出文件后dev会自动调用系统对此文件的默认打开应用来打开文件，当然dev也提供内置的预览方法，这在下一节导出word模板中使用。</li></ul><h2 id="七、向Word模板中写入数据"><a href="#七、向Word模板中写入数据" class="headerlink" title="七、向Word模板中写入数据"></a>七、向Word模板中写入数据</h2><h3 id="1-载入word模板文件"><a href="#1-载入word模板文件" class="headerlink" title="1.载入word模板文件"></a>1.载入word模板文件</h3><p>向word模板中写入数据我这里主要使用的是<font color="red">RichEditControl</font>类，RichEditControl类提供海量的富文本API接口，这里主要讲解使用到的API。</p><p>首先打开word文档，RichEditControl类提供RichEditControl.LoadDocument(string path)方法加载文档，RichEditControl类也提供多个LoadDocument函数的重载给予各种文件的加载形式，我这里使用的是直接通过文件路径加载文档。LoadDocument函数支持DOC、DOCX、RTP、HTM、HTML、MHT、XML和EPUB类型的文档，可以自动检测文档类型。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">RichEditControl.LoadDocument(<span class="hljs-built_in">string</span> path)<br></code></pre></td></tr></table></figure><p>将文档载入内存之后就可以通过<font color="red">RichEditControl.Document.Text</font>属性查看文档内容了，也可以通过RichEditControl.Document.Text属性判断文档是否加载成功。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">if</span>(richEditControl.Document.Text == <span class="hljs-literal">null</span>)<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-向word模板的指定位置写入数据"><a href="#2-向word模板的指定位置写入数据" class="headerlink" title="2.向word模板的指定位置写入数据"></a>2.向word模板的指定位置写入数据</h3><p>向word模板的指定位置写入数据主要使用Word的书签和域，我这里使用的是书签，在word中想要插入数据的地方添加一个书签即可，如：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326091009.png"></p><p>我想要在生产号、型号和图号后面的单元格写入数据，那么我只需要在这些单元中添加书签即可，添加书签的步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph LR;<br>将光标定位到要添加的书签的位置--&gt;插入--&gt;书签--&gt;添加一个书签名--&gt;添加<br></code></pre></td></tr></table></figure><p>添加完书签时候在word上是看不到的，但是把光标定位到书签所在的位置处，插入书签时会自定定位到所插入的书签名。</p><p>然后即可通过<font color="red"> Document.Replace(DocumentRange range,string text)</font>函数来向书签所在位置插入数据了，其中DocumentRange类型的参数需要通过<font color="red">Document.Bookmarks[string bookmarks].Range</font>来将字符串类型的书签标志转换为DocumentRange类型的可用书签标志。</p><p>如：我要在生产号、型号和图号后面的单元格写入数据，那么我需要分别在这些单元格中插入书签<code>sch</code>、<code>xh</code>、<code>th</code>，然后通过下面代码即可向word模板中写入数据</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#">RichEditControl richEdit = <span class="hljs-keyword">new</span> RichEditControl();<br>richEdit.LoadDocument(<span class="hljs-string">&quot;C:/a.doc&quot;</span>);<br>Document doc = rich.Document;<br>doc.Replace(doc.Bookmarks[<span class="hljs-string">&quot;sch&quot;</span>].Range,<span class="hljs-string">&quot;01&quot;</span>);<br>doc.Replace(doc.Bookmarks[<span class="hljs-string">&quot;xh&quot;</span>].Range,<span class="hljs-string">&quot;02&quot;</span>);<br>doc.Replace(doc.Bookmarks[<span class="hljs-string">&quot;th&quot;</span>].Range,<span class="hljs-string">&quot;03&quot;</span>);<br></code></pre></td></tr></table></figure><p>原理就是书签提供了一个占位符，而dev则通过搜索匹配的占位符，将指定数据替换掉占位符。</p><h3 id="3-向word模板中的表格插入新行并写入内容"><a href="#3-向word模板中的表格插入新行并写入内容" class="headerlink" title="3.向word模板中的表格插入新行并写入内容"></a>3.向word模板中的表格插入新行并写入内容</h3><p>向word模板中的表格插入新行则稍微复杂一些。主要步骤如下：</p><ul><li><p>首先word文档中要有一个模板表格</p></li><li><p>需要在要插入表的位置添加书签table</p></li><li><p>遍历word文档中所有的表再遍历每一个表中所有的单元格，查找到书签所在的单元格</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> TableCell <span class="hljs-title">GetTableCell</span>(<span class="hljs-params">Document document</span>) </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//遍历文档中所有的表</span><br>    <span class="hljs-keyword">foreach</span> (Table table <span class="hljs-keyword">in</span> document.Tables)<br>    &#123;<br>        <span class="hljs-built_in">int</span> row = <span class="hljs-number">0</span>, col = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">bool</span> ok = <span class="hljs-literal">false</span>;<br>        TableCell retCell = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">//遍历表格中所有的单元格</span><br>        table.ForEachCell((cell, rowIndex, columnIndex) =&gt;<br>                          &#123;<br>                              <span class="hljs-keyword">if</span> (cell.Range.Contains(document.Bookmarks[<span class="hljs-string">&quot;table&quot;</span>].Range.Start))<br>                              &#123;<br>                                  row = rowIndex;<br>                                  col = columnIndex;<br>                                  retCell = cell;<br>                                  ok = <span class="hljs-literal">true</span>;<br>                              &#125;<br>                          &#125;);<br>        <span class="hljs-keyword">if</span> (ok)<br>        &#123;<br>            <span class="hljs-keyword">return</span> retCell;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><font color="red">Table.ForEachCell(TableCellProcessorDelegate cellProcessor)</font>函数传入的是一个委托。这里使用的是匿名方法</p></li><li><p>在指定单元格后新增行</p><p>可以使用<font color="red">Document.Tables[int index].Rows.Append()</font>函数在表的最后追加行，或使用<font color="red"> Document.Tables[int index].Rows.InsertAfter(int rowIndex)</font>函数在指定行之后插入行。其中Document.Tables[int index].Rows.Append()中index（表的索引）可以通过<font color="red"> Document.Tables.IndexOf(Table table)</font>函数获取，而table又可以同通过上一步查找到的TableCell对象retCell.Table属性获取。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#">RichEditControl richEdit = <span class="hljs-keyword">new</span> RichEditControl();<br>richEdit.LoadDocument(<span class="hljs-string">&quot;C:/a.doc&quot;</span>);<br>Document doc = rich.Document;<br>TableCell cell = GetTableCell(doc);<br>doc.BeginUpdate();<br><span class="hljs-built_in">int</span> index = doc.Tables.IndexOf(cell.Table);<br>doc.Tables[index].Rows.Append();<span class="hljs-comment">//或者</span><br><span class="hljs-comment">//doc.Table[index].Rows.InsertAfter(cell.Row.Index - 1);</span><br><span class="hljs-comment">//获取指定单元格的占位符范围</span><br>DocumentRange range = doc.Tables[index].Rows[cell.Row.Index].Cells[cell.Index].ContentRange;<br>doc.Replace()<br>doc.EndUpdate();<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dev</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE4】UE4联级粒子系统</title>
    <link href="/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <url>/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="一、粒子系统的一些基本概念"><a href="#一、粒子系统的一些基本概念" class="headerlink" title="一、粒子系统的一些基本概念"></a>一、粒子系统的一些基本概念</h1><h2 id="1-Particle-System-粒子系统"><a href="#1-Particle-System-粒子系统" class="headerlink" title="1.Particle System(粒子系统)"></a>1.Particle System(粒子系统)</h2><p>粒子系统如同贴图、模型一样属于UE4的驻留资产，不能单独存在于场景中，必须使用载体依托才能在场景中渲染出来，粒子系统包含粒子特效的所有配置。粒子系统在UE4中表现为如下样子：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224655.png"></p><h3 id="创建粒子系统"><a href="#创建粒子系统" class="headerlink" title="创建粒子系统"></a>创建粒子系统</h3><p>在内容浏览器中右键选择Particle System可以直接创建粒子系统。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224659.png"></p><h2 id="2-Emitter-Actor-粒子发射器"><a href="#2-Emitter-Actor-粒子发射器" class="headerlink" title="2.Emitter Actor(粒子发射器)"></a>2.Emitter Actor(粒子发射器)</h2><p>粒子发射器就是粒子系统的载体，粒子发射器承载粒子系统确定粒子系统在场景中的位置坐标等信息。但是似乎UE4没办法直接创建空的粒子发射器，UE4的粒子发射器在将粒子系统拖入场景中时，UE4会自动为该粒子系统创建一个粒子发射器。</p><h2 id="3-Particle-System-Component-粒子系统组件"><a href="#3-Particle-System-Component-粒子系统组件" class="headerlink" title="3.Particle System Component(粒子系统组件)"></a>3.Particle System Component(粒子系统组件)</h2><p>粒子系统组件是一个包含了粒子系统的蓝图，粒子系统组件可以使用代码逻辑来控制粒子系统。</p><h1 id="二、Cascade-粒子编辑器"><a href="#二、Cascade-粒子编辑器" class="headerlink" title="二、Cascade(粒子编辑器)"></a>二、Cascade(粒子编辑器)</h1><p>粒子系统的核心就是粒子编辑器，在粒子编辑器里我们可以创造出琳琅满目的粒子特效。</p><p>粒子编辑器包含Toolbar、Emitters、Details、Viewport和Curve Editor等视图。</p><h2 id="1-ToolBar-工具栏"><a href="#1-ToolBar-工具栏" class="headerlink" title="1.ToolBar(工具栏)"></a>1.ToolBar(工具栏)</h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224706.png"></p><h2 id="2-Emitters"><a href="#2-Emitters" class="headerlink" title="2.Emitters"></a>2.Emitters</h2><p>Emitters是用于控制粒子属性的视图，Emitters的基本组成单元就是Emitter(发射器)，这里的Emitter和前面提到的Emitter Actor有一些差异，二者都是粒子发射器，但是Emitter是属于粒子系统内部的发射器，主要用于对粒子系统的某一部分的粒子发射，如爆炸的粒子特效中可以由烟、火光和火花等粒子部分组成，Emitter就是用于发射这些粒子部分的发射器，而Emitter Actor则是用于发射整个粒子系统的发射器。</p><h2 id="3-Emitter-发射器"><a href="#3-Emitter-发射器" class="headerlink" title="3.Emitter(发射器)"></a>3.Emitter(发射器)</h2><p>在Emitters视图中每一列就是一个Emitter，一个Emitter控制一个粒子部分。一个Emitter拥有Required和Spawn两个固有组成模块，即每个Emitter被创建出来就拥有Required和Spawn模块，且这两个模块不能删除。</p><p>Emitter的执行顺序是自左而右的。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224709.png"></p><h3 id="创建Emitter"><a href="#创建Emitter" class="headerlink" title="创建Emitter"></a>创建Emitter</h3><p>直接在Emitters视图的空白出右键选择New Particle Sprite Emitter即可。</p><h3 id="赋值Emitter"><a href="#赋值Emitter" class="headerlink" title="赋值Emitter"></a>赋值Emitter</h3><p>选中需要复制的Emitter右键/Emiter/Duplicate Emitter即可。</p><h3 id="删除Emitter"><a href="#删除Emitter" class="headerlink" title="删除Emitter"></a>删除Emitter</h3><p>选中需要删除的Emitter右键/Emitter/Delete Emitter，或直接按delete键。</p><h2 id="4-Emitter的分类"><a href="#4-Emitter的分类" class="headerlink" title="4.Emitter的分类"></a>4.Emitter的分类</h2><p>直接创建的Emitter默认为普通Emitter即没有任何特殊属性的Emitter，要创建具有特殊属性的特殊的Emitter需要修改Emitter的TypeData属性，右键/TypeData选择需要的类型即可修改Emitter的类型。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224713.png"></p><h3 id="AnimTrail-Data"><a href="#AnimTrail-Data" class="headerlink" title="AnimTrail Data"></a>AnimTrail Data</h3><p>骨骼动画发射器，AnimTrail可以使粒子跟随人物骨骼运动而运动，如下图的跟随人物手臂运动的彩虹带</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224716.png"></p><p>AnimTrail是配合UE4的动画系统一起使用的，使用AnimTrail我们需要选择一段动画片段如下图</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224721.png"></p><p>发射器会在选定的时间片段内发射粒子，在右侧的Trail栏中选定粒子需要跟随的骨骼和骨骼需要绑定的粒子系统，就可以使粒子跟随着骨骼运动了。</p><h3 id="Beam-Data"><a href="#Beam-Data" class="headerlink" title="Beam Data"></a>Beam Data</h3><p>光束发射器，Beam有一个源点和一个目标点，粒子由源点发射运动到目标点销毁，Beam在粒子由源点运动到目标点的过程中可以设置粒子抖动，使粒子的运动具有抖动效果，如下图的闪电。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224725.png"></p><p>Beam拥有一个专属Module–Beam，在这个模块里可以为Beam添加Source(源点)、Target(目标点)和Noise(噪声)，Noise就是控制粒子抖动的Module，要想粒子出现抖动有几点是必须要做的，即勾选Noise模块的Low Freq/Low Freq Enabled、设置Frequency(噪声点的频率，影响粒子抖动的平滑程度)；Source和Target模块的Suorce Tangent/Distribution/Constant和Target Tangent/Distribution/Constant(影响源点到目标点的粒子抖动的曲率)，要想这两个设置起作用还必须设置Source/Source Tangent Method为User Set，目标点也是一样的设置；还有一点就是要想粒子从源点向目标点运动还需要设置Beam Data模块的Beam/Beam Method为Target。</p><h3 id="GPU-Sprites"><a href="#GPU-Sprites" class="headerlink" title="GPU Sprites"></a>GPU Sprites</h3><p>GPU Sprites是普通粒子的加强版，可以使粒子具有更完美的物理效果，但当对于普通粒子发射器来说更消耗GPU性能。</p><p><strong>矢量场：</strong></p><p>矢量场是GPU粒子独有的属性，GPU粒子在矢量成的控制下可以作出任意轨迹运用，如：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224729.png"></p><p>矢量场有多个属性控制模块</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224733.png"></p><p>矢量场默认是看不见的，我们需要在Viewport里勾选View/Vector Fields，使矢量场可见。</p><h3 id="Mesh-Data"><a href="#Mesh-Data" class="headerlink" title="Mesh Data"></a>Mesh Data</h3><p>网格发射器，Mesh可以使粒子使用模型网格，这样发射出来的粒子就是一个个具体的模型，如下图所示。</p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224735.png" style="zoom:50%;"><h3 id="Ribbon-Data"><a href="#Ribbon-Data" class="headerlink" title="Ribbon Data"></a>Ribbon Data</h3><p>光带发射器，Ribbon可以记录粒子的运行轨迹，并可以对其属性进行编辑，如下图使用粒子运行轨迹制作的光带。</p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224739.png" style="zoom:50%;"><p>Ribbon的粒子生成模块不是使用Spawn，而是Spawn PerUnit，由于Spawn是Emitter的固有Module所以无法移除，我们要启用Spawn PerUnit则需要将Spawn Module的Spawn/Distribution/Constant设置为0，达到间接禁用Spawn的效果。这样彩带粒子就是用Spawn PerUnit生成粒子了，想要彩带粒子跟随其他粒子运动我们还需要一个Module–Trail/Source，将Source Module里的Source/Source Mothod设置为PET2SRCM Particle，并且Source Name设置为需要跟随粒子部分的Emitter的名字，这样就可以产生一个跟随其他粒子的彩带了，当然这个彩带粒子是需要设置贴图的，否则尽管生成了，但是却没有渲染。</p><h2 id="4-Module-模块"><a href="#4-Module-模块" class="headerlink" title="4.Module(模块)"></a>4.Module(模块)</h2><p>模块用于控制粒子某一方面的属性，在Emitter中每一行就是一个Module，Module的种类很多，这里只列举自己使用过的Module。</p><p>UE4Module的执行顺序是自上而下的所以当一个Emitter中有两个相同的Module时，下面的Module会覆盖上面的Module。</p><h3 id="添加Module"><a href="#添加Module" class="headerlink" title="添加Module"></a>添加Module</h3><p>选中需要添加Module的Emitter，右键选择需要的Module即可</p><h3 id="移除Module"><a href="#移除Module" class="headerlink" title="移除Module"></a>移除Module</h3><p>选中需要移除的Module右键/Delete Module，或直接按Delete键。</p><h3 id="拷贝Module"><a href="#拷贝Module" class="headerlink" title="拷贝Module"></a>拷贝Module</h3><p>Shift+拖动即可拷贝一个Module到另一个Emitter中。</p><h3 id="Required"><a href="#Required" class="headerlink" title="Required"></a>Required</h3><p>Required控制粒子的显示方面的属性，如粒子贴图，显示模式等。</p><ul><li>Sub UV栏控制贴图的逐帧融合。</li></ul><h3 id="Spawn"><a href="#Spawn" class="headerlink" title="Spawn"></a>Spawn</h3><p>Spawn控制粒子的发射方面的属性，如粒子发射量，发射模式等。</p><ul><li>Spawn栏控制粒子持续性的发射；</li><li>Burst栏控制粒子间歇性的爆炸发射。</li></ul><h3 id="LifeTime"><a href="#LifeTime" class="headerlink" title="LifeTime"></a>LifeTime</h3><p>LifeTime控制粒子的声明周期方面的属性。</p><h3 id="Initial-Size"><a href="#Initial-Size" class="headerlink" title="Initial Size"></a>Initial Size</h3><p>Initial Size控制粒子初始尺寸方面的属性。</p><h3 id="Initial-Velocity"><a href="#Initial-Velocity" class="headerlink" title="Initial Velocity"></a>Initial Velocity</h3><p>Initial Velocity控制粒子初始速度方面的属性。</p><h3 id="Color-Over-Life"><a href="#Color-Over-Life" class="headerlink" title="Color Over Life"></a>Color Over Life</h3><p>Color Over Life控制粒子生命周期内的颜色变化方面的属性。</p><p>生命周期的初始颜色是Color Over Life/Distribution/Constant Curve/Points/0/Out Val，</p><p>生命周期的结束颜色是Color Over Life/Distribution/Constant Curve/Points/1/Out Val。</p><h3 id="Initial-Location"><a href="#Initial-Location" class="headerlink" title="Initial Location"></a>Initial Location</h3><p>Initial Location控制粒子发射的初始位置方面的属性，通过Start Location/Distribution/Max和Min可以控制粒子发射时的位置分布，如Max，Min都为0时粒子只从一个点发射出来，当设置了值，粒子会在设置的范围内随机发射出来。</p><h3 id="Const-Acceleration"><a href="#Const-Acceleration" class="headerlink" title="Const Acceleration"></a>Const Acceleration</h3><p>Const Acceleration控制粒子的运动的加速度。</p><h3 id="Size-By-Speed"><a href="#Size-By-Speed" class="headerlink" title="Size By Speed"></a>Size By Speed</h3><p>Size By Speed控制粒子的尺寸随速度的变化，要想粒子的尺寸可以随速度变化需要将Required模块的Emitter/Screen Alignment设置为PSA Velocity。</p><h3 id="Light"><a href="#Light" class="headerlink" title="Light"></a>Light</h3><p>Light控制粒子发光，但是似乎只有发生碰撞之后才会发光。</p><h3 id="Actor-Collision"><a href="#Actor-Collision" class="headerlink" title="Actor Collision"></a>Actor Collision</h3><p>Actor Collision控制粒子的物理碰撞。</p><h3 id="Orbit"><a href="#Orbit" class="headerlink" title="Orbit"></a>Orbit</h3><p>Obirt控制粒子的随机运动。</p><h1 id="三、LOD-细节层次"><a href="#三、LOD-细节层次" class="headerlink" title="三、LOD(细节层次)"></a>三、LOD(细节层次)</h1><p>默认情况下任何创建出来的粒子系统默认为LOD0等级的细节层次，我们可以在Toolbar中的Add LOD添加细节层次，在LOD中切换细节层次。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224746.png"></p><p>Details/LOD栏可以设置LOD切换与距离的关系，可以在不同的细节层次下修改Emitter不会对其他的细节层次产生影响，这样就可以很精确的控制各个细节层次了。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE4】UE4组件</title>
    <link href="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/"/>
    <url>/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>不同的蓝图脚本拥有不同的组件集，蓝图脚本的组件集过于庞大，这里只对自己使用过的组件进行列举。</p><p><font color="red">说明：红色字体表示一级目录组件，绿色字体表示二级目录，黄色字体为三级目录(三级目录较为少见所以使用和二级目录相同的三级标题)，白色字体为具体组件说明</font>。</p><h1 id="一、材质蓝图组件"><a href="#一、材质蓝图组件" class="headerlink" title="一、材质蓝图组件"></a>一、材质蓝图组件</h1><h2 id="Constans-常量"><a href="#Constans-常量" class="headerlink" title="Constans(常量)"></a><font color="red">Constans(常量)</font></h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224830.png"></p><table><thead><tr><th>组件</th><th>作用</th></tr></thead><tbody><tr><td>Constans</td><td>一维量，可以表示任何一维数据，如：小数、整数等</td></tr><tr><td>Constans2Vector</td><td>二维量，可以表示任何二维数据，如：二维坐标</td></tr><tr><td>Constans3Vector</td><td>三维量，可以表示任何三维数据，如：三维坐标、RBG等</td></tr><tr><td>Constans4Vector</td><td>四维量，可以表示任何四维数据，如：四元数</td></tr></tbody></table><h2 id="Math-数学函数"><a href="#Math-数学函数" class="headerlink" title="Math(数学函数)"></a><font color="red">Math(数学函数)</font></h2><h4 id="Multiply-乘积"><a href="#Multiply-乘积" class="headerlink" title="Multiply(乘积)"></a><strong>Multiply(乘积)</strong></h4><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224834.png"></p><h3 id="Lerp-插值"><a href="#Lerp-插值" class="headerlink" title="Lerp(插值)"></a><font color="green">Lerp(插值)</font></h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224837.png"></p><p>Lerp组件在Math的多个二级目录中存在，有各种类型的插值变化。</p><p><strong>输入：</strong></p><ul><li>A：插值变化的起始值；</li><li>B：插值变化的目标值；</li><li>Alpha：插值的变化规则，连接Float的TimeLine插值将按照TimeLine的规则变化。</li></ul><p><strong>输出：</strong></p><ul><li>Return Value：返回变化后的插值，将Lerp放入帧函数中可以获得每帧变化的插值。</li></ul><h1 id="二、普通蓝图组件"><a href="#二、普通蓝图组件" class="headerlink" title="二、普通蓝图组件"></a>二、普通蓝图组件</h1><hr><h2 id="Add-TimeLine-添加时间线"><a href="#Add-TimeLine-添加时间线" class="headerlink" title="Add TimeLine(添加时间线)"></a><font color="red">Add TimeLine(添加时间线)</font></h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224840.png"></p><p><strong>输入：</strong></p><ul><li>Play：播放，播放完毕下一次触发时不会从头开始，而是会从上一次时间点继续开始；</li><li>Play from Start：从头开始播放，每次触发都从时间线起点开始执行；</li><li>Stop：暂停，触发后直接从当前时刻暂停；</li><li>Reverse：倒序播放，从当前时刻开始倒叙播放；</li><li>Reverse from End：从末尾开始倒序播放；</li><li>Set New Time：设置新的时间起点，即时间线从新设置的时间点开始执行；</li><li>New Time：新的时间起点由外部输入。</li></ul><p><strong>输出：</strong></p><ul><li>Update：在时间线内每帧执行；</li><li>Finished：时间线结束时触发；</li><li>Direction：返回时间线的执行方向，只有两个值“Forward”和“Backward”；</li><li>New Track 0：自己创建的时间线，创建了才会有，显示的名字也是自己命名的时间线的名字。</li></ul><h2 id="Add-Event-添加事件"><a href="#Add-Event-添加事件" class="headerlink" title="Add Event(添加事件)"></a><font color="red">Add Event(添加事件)</font></h2><h3 id="Collision-碰撞体组件"><a href="#Collision-碰撞体组件" class="headerlink" title="Collision(碰撞体组件)"></a><font color="green">Collision(碰撞体组件)</font></h3><h4 id="Event-ActorBeginOverlap-自动触发触发器"><a href="#Event-ActorBeginOverlap-自动触发触发器" class="headerlink" title="Event ActorBeginOverlap(自动触发触发器)"></a><strong>Event ActorBeginOverlap(自动触发触发器)</strong></h4><p>每当有物体进入触发器时自动触发</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224844.png"></p><ul><li>Other Actor：返回进入触发器的游戏物体的信息。</li></ul><h3 id="Game"><a href="#Game" class="headerlink" title="Game"></a><font color="green">Game</font></h3><h3 id="Damage"><a href="#Damage" class="headerlink" title="Damage"></a><font color="orange">Damage</font></h3><h4 id="Event-AnyDamage"><a href="#Event-AnyDamage" class="headerlink" title="Event AnyDamage"></a><strong>Event AnyDamage</strong></h4><p>Event AnyDamage事件是配合Apply Damage组件一起使用的，当Apply Damage组件执行时，会自动触发Event AnyDamage事件。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224847.png"></p><p><strong>输出：</strong></p><ul><li><p>Damage：从Apply Damage组件的Damage中传递过来的值；</p></li><li><p>Damage Type：从Apply Damage组件传递过来的Damage Type Class；</p></li><li><p>Instigated By：从Apply Damage组件传递过来的Event Instigateor；</p></li><li><p>Damage Causer：从Apply Damage组件传递过来的Damage Causer；</p></li></ul><h2 id="Camera-Fades-相机渐变"><a href="#Camera-Fades-相机渐变" class="headerlink" title="Camera Fades(相机渐变)"></a><font color="red">Camera Fades(相机渐变)</font></h2><p>Camera Fades组件是只有在Get Player Camera Menager组件的外拉中才能搜索到的专门服务于Get Player Camera Menager组件的相机组件集。</p><h4 id="Start-Camera-Fade-开始渐变"><a href="#Start-Camera-Fade-开始渐变" class="headerlink" title="Start Camera Fade(开始渐变)"></a><strong>Start Camera Fade(开始渐变)</strong></h4><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224850.png"></p><ul><li>Target：渐变目标相机，默认为当前相机；</li><li>From Alpha：渐变起始Alpha；</li><li>To Alpha：渐变目标Alpha；</li><li>Duration：渐变持续时间；</li><li>Color：渐变颜色；</li><li>Should Fade Audio：启用声音渐变；</li><li>Hold when Finished：渐变结束后保持当前Alpha值。</li></ul><h4 id="Stop-Camera-Fade-结束渐变"><a href="#Stop-Camera-Fade-结束渐变" class="headerlink" title="Stop Camera Fade(结束渐变)"></a><strong>Stop Camera Fade(结束渐变)</strong></h4><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224853.png"></p><p>触发时立刻停止当前渐变。</p><h2 id="Event-BeginPlay"><a href="#Event-BeginPlay" class="headerlink" title="Event BeginPlay"></a><font color="red">Event BeginPlay</font></h2><p>游戏开始时自动触发</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224857.png"></p><h2 id="Execute-Console-Command-执行控制台命令"><a href="#Execute-Console-Command-执行控制台命令" class="headerlink" title="Execute Console Command(执行控制台命令)"></a><font color="red">Execute Console Command(执行控制台命令)</font></h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224900.png"></p><ul><li>Command：控制台命令字符串</li><li>Specific Player：执行控制台命令的执行器，默认为当前GameMode指定的Player</li></ul><h3 id="常见控制台命令"><a href="#常见控制台命令" class="headerlink" title="常见控制台命令"></a><font color="green">常见控制台命令</font></h3><ul><li><p>start fps：显示帧率</p></li><li><p>start unit：显示性能调试信息</p></li><li><p>start rhi：显示GPU上的消耗细则</p><p><a href="https://docs.unrealengine.com/zh-CN/TestingAndOptimization/PerformanceAndProfiling/StatCommands/index.html">更多start命令</a></p></li><li><p>r.MobileContentScaleFactor 0：控制内容在移动设备中的缩放方式，0表示使用设备原始分辨率，如将DPI缩放曲线用于UI缩放，必须设为0</p></li><li><p>DisableAllScreenMessages：禁用所有在运行中的屏幕提示</p></li></ul><h2 id="Input-输入流"><a href="#Input-输入流" class="headerlink" title="Input(输入流)"></a><font color="red">Input(输入流)</font></h2><h3 id="Keyboard-Events-按键触发事件"><a href="#Keyboard-Events-按键触发事件" class="headerlink" title="Keyboard Events(按键触发事件)"></a><font color="green">Keyboard Events(按键触发事件)</font></h3><p>包含所有键盘按键出发事件</p><h2 id="Game-1"><a href="#Game-1" class="headerlink" title="Game"></a><font color="red">Game</font></h2><h4 id="Get-Player-Pawn-获取角色对象"><a href="#Get-Player-Pawn-获取角色对象" class="headerlink" title="Get Player Pawn(获取角色对象)"></a><strong>Get Player Pawn(获取角色对象)</strong></h4><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224905.png"></p><ul><li><p>Play Index：输入角色索引，可以直接设置也可以外部输入；</p></li><li><p>Return Value：返回获取的角色对象(Object)。</p></li></ul><h4 id="Get-Current-Level-Name-获取关卡名字"><a href="#Get-Current-Level-Name-获取关卡名字" class="headerlink" title="Get Current Level Name(获取关卡名字)"></a><strong>Get Current Level Name(获取关卡名字)</strong></h4><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224909.png"></p><ul><li>Remove Prefix String：移除前缀字符串；</li><li>Return Value：返回获取到的关卡名称(String)。</li></ul><h4 id="Get-Player-Camera-Manager-获取角色相机管理器"><a href="#Get-Player-Camera-Manager-获取角色相机管理器" class="headerlink" title="Get Player Camera Manager(获取角色相机管理器)"></a><strong>Get Player Camera Manager(获取角色相机管理器)</strong></h4><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224916.png"></p><ul><li>Player Index：输入角色索引；</li><li>Return Value：返回输入角色身上的相机对象。</li></ul><h3 id="Damage-1"><a href="#Damage-1" class="headerlink" title="Damage"></a><font color="green">Damage</font></h3><h4 id="Apply-Damage"><a href="#Apply-Damage" class="headerlink" title="Apply Damage"></a><strong>Apply Damage</strong></h4><p>Apply Damage组件一般和Event AnyDamage组件配合使用，当Apply Damage组件触发时，UE4会自动调用Event AnyDamage事件。需要注意的是，只有在Base Daamge不为0时才能触发Event Damage事件。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224919.png"></p><p><strong>输入：</strong></p><ul><li><p>Ddamaged Actor：受到伤害的对象；</p></li><li><p>Base Damage：输入的伤害值；</p></li><li><p>Event Instigator：引发伤害的对象，如：持枪的敌人；</p></li><li><p>Damage Causer：实际造成伤害的对象，如：子弹；</p></li><li><p>Damage Type Class：伤害的类型；</p></li></ul><p><strong>输出：</strong></p><p>Return Value：最终造成的实际伤害。</p><h3 id="Player-Controller-角色控制器组件"><a href="#Player-Controller-角色控制器组件" class="headerlink" title="Player Controller(角色控制器组件)"></a><font color="green">Player Controller(角色控制器组件)</font></h3><h3 id="Set-View-Target-With-Blend-相机线性移动"><a href="#Set-View-Target-With-Blend-相机线性移动" class="headerlink" title="Set View Target With Blend(相机线性移动)"></a>Set View Target With Blend(相机线性移动)</h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224923.png"></p><ul><li>Target：目标是PlayerController</li><li>New View Target：相机需要移动到的目的点</li><li>Blend Time：相机聚焦过程所需时间</li><li>Blend Func：聚焦方式</li><li>Blend Exp：控制曲线形状的指数，（实测中好像也没什么效果）</li><li>Lock Outgoing：为true时锁定视角移动，false则相机会转向</li></ul><h2 id="Rendering-渲染"><a href="#Rendering-渲染" class="headerlink" title="Rendering(渲染)"></a><font color="red">Rendering(渲染)</font></h2><h3 id="Components"><a href="#Components" class="headerlink" title="Components"></a><font color="green">Components</font></h3><h3 id="Light"><a href="#Light" class="headerlink" title=" Light"></a><font color="orange"> Light</font></h3><h4 id="Set-Intensity-设置光源强度"><a href="#Set-Intensity-设置光源强度" class="headerlink" title="Set Intensity(设置光源强度)"></a><strong>Set Intensity(设置光源强度)</strong></h4><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224927.png"></p><ul><li>Target：目标光源；</li><li>New Intensity：目标光源强度。</li></ul><h4 id="Get-Intensity-获取光源强度"><a href="#Get-Intensity-获取光源强度" class="headerlink" title="Get Intensity(获取光源强度)"></a><strong>Get Intensity(获取光源强度)</strong></h4><p>使用和Set Intensity一样。</p><h2 id="String-字符串组件"><a href="#String-字符串组件" class="headerlink" title="String(字符串组件)"></a><font color="red">String(字符串组件)</font></h2><h3 id="Append-字符串连接"><a href="#Append-字符串连接" class="headerlink" title="Append(字符串连接)"></a><font color="green">Append(字符串连接)</font></h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224931.png"></p><h3 id="Switch-On-String-字符串匹配"><a href="#Switch-On-String-字符串匹配" class="headerlink" title="Switch On String(字符串匹配)"></a><font color="green">Switch On String(字符串匹配)</font></h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224933.png"></p><ul><li>Selection：输入字符串</li><li>Default：默认输出端口</li><li>Add pin：添加匹配端口</li></ul><h2 id="Utilities-通用组件"><a href="#Utilities-通用组件" class="headerlink" title="Utilities(通用组件)"></a><font color="red">Utilities(通用组件)</font></h2><h3 id="Flow-Control"><a href="#Flow-Control" class="headerlink" title="Flow Control"></a><font color="green">Flow Control</font></h3><h4 id="Branch-if语句"><a href="#Branch-if语句" class="headerlink" title="Branch(if语句)"></a>Branch(if语句)</h4><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224936.png"></p><p>蓝图的if语句</p><ul><li>Condition：输入的判断条件，一般和各种判断组件的输出连接。</li></ul><h4 id="Delay-延迟函数"><a href="#Delay-延迟函数" class="headerlink" title="Delay(延迟函数)"></a>Delay(延迟函数)</h4><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224939.png"></p><ul><li>Duration：延迟时间。</li></ul><h3 id="Keyboard-Events-按键触发事件-1"><a href="#Keyboard-Events-按键触发事件-1" class="headerlink" title="Keyboard Events(按键触发事件)"></a><font color="green">Keyboard Events(按键触发事件)</font></h3><p>包含一些字符串操作函数。</p><h3 id="Text"><a href="#Text" class="headerlink" title="Text"></a><font color="green">Text</font></h3><h4 id="Equal"><a href="#Equal" class="headerlink" title="Equal"></a>Equal</h4><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224942.png"></p><p>输入两个比较对象，输出判断结果(Bool)。</p><p>各种其他的判断组件用法一致。</p><h3 id="Transformation"><a href="#Transformation" class="headerlink" title=" Transformation"></a><font color="green"> Transformation</font></h3><h4 id="Set-Actor-Scale-3D"><a href="#Set-Actor-Scale-3D" class="headerlink" title="Set Actor Scale 3D"></a>Set Actor Scale 3D</h4><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224945.png"></p><p>设置Actor的Scale值</p><ul><li>Target：要设置的目标Actor；</li><li>New Scale 3D：要设置的目标Scale值。</li></ul><h4 id="Get-Actor-Scale-3D"><a href="#Get-Actor-Scale-3D" class="headerlink" title="Get Actor Scale 3D"></a>Get Actor Scale 3D</h4><p>获取Actor的Scale值。</p><h4 id="Set-Timer-By-Function-Name"><a href="#Set-Timer-By-Function-Name" class="headerlink" title="Set Timer By Function Name"></a>Set Timer By Function Name</h4><p>节点：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224947.png"></p><p>描述：通过函数名定时调用函数</p><p>输入：</p><ul><li>Object：调用函数所在蓝图，默认为节点所在蓝图</li><li>Function Name：要调用的函数的名字</li><li>Time：定时调用时间间隔</li><li>Looping：是否循环调用</li></ul><p>输出：</p><ul><li>一个Timer Handle结构体，记录了一些函数调用的信息</li></ul><p><strong>关联节点：</strong></p><h4 id="Pause-Timer-By-Function-Name"><a href="#Pause-Timer-By-Function-Name" class="headerlink" title="Pause Timer By Function Name"></a>Pause Timer By Function Name</h4><p>节点：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224951.png"></p><p>描述：暂停有Set Timer By Function Name节点启用的函数定时调用过程</p><p>输入：与Set Timer By Function Name类似</p><h4 id="Unpause-Timer-By-Function-Name"><a href="#Unpause-Timer-By-Function-Name" class="headerlink" title="Unpause Timer By Function Name"></a>Unpause Timer By Function Name</h4><p>节点：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224954.png"></p><p>描述：取消Pause Timer By Function Name的效果，继续Set Timer By Function Name的函数定时调用</p><h4 id="Clear-Timer-By-Function-Name"><a href="#Clear-Timer-By-Function-Name" class="headerlink" title="Clear Timer By Function Name"></a>Clear Timer By Function Name</h4><p>节点：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224957.png"></p><p>描述：清除Set Timer By Function Name的定时调用设置</p><h4 id="Set-Timer-By-Event"><a href="#Set-Timer-By-Event" class="headerlink" title="Set Timer By Event"></a>Set Timer By Event</h4><p>节点：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811225001.png"></p><p>描述：设置定时调用事件，与Set Timer By Function Name不同Set Timer By Evnet没有对应的Pause和Unpause节点，且Set Timer By Event只能调用所在蓝图的事件</p><p>输入：</p><ul><li>Evnet：绑定需要调用的蓝图事件</li><li>Time：定时调用的时间间隔</li><li>Looping：是否循环调用</li></ul><h4 id="Puase-Timer-By-Handle"><a href="#Puase-Timer-By-Handle" class="headerlink" title="Puase Timer By Handle"></a>Puase Timer By Handle</h4><p>节点：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811225005.png"></p><p>描述：通过Set Timer By Function Name和Set Timer By Evnet的Timer Handle返回值来控制调用流程，暂停函数调用</p><p>输入：</p><ul><li>Handle：Timer Handle结构体，输入Set Timer By Function Name和Set Timer By Evnet的返回值</li></ul><h4 id="Upause-Timer-By-Handle"><a href="#Upause-Timer-By-Handle" class="headerlink" title="Upause Timer By Handle"></a>Upause Timer By Handle</h4><p>节点：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811225009.png"></p><p>描述：清除Pause Timer By Handle的暂定效果继续Set Timer By Function或Set Timer By Event的定时效果</p><h4 id="Clear-And-Invalidate-Timer-By-Handle"><a href="#Clear-And-Invalidate-Timer-By-Handle" class="headerlink" title="Clear And Invalidate Timer By Handle"></a>Clear And Invalidate Timer By Handle</h4><p>节点：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811225012.png"></p><p>描述：通过Timer Handle值清除Set Timer By Function Name和Set Timer By Event的定时调用设置</p><h1 id="三、物理组件"><a href="#三、物理组件" class="headerlink" title="三、物理组件"></a>三、物理组件</h1><p>UE4除了提供大量蓝图脚本函数组件来对蓝图类进行精细控制外还提供了一系列物理组件对蓝图类进行一些常规的复杂控制。</p><h2 id="Camera"><a href="#Camera" class="headerlink" title="Camera"></a><font color="red">Camera</font></h2><h4 id="Camera-1"><a href="#Camera-1" class="headerlink" title="Camera"></a><strong>Camera</strong></h4><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811225027.png"></p><p>相机，用于渲染视野，一般配合Spring Arm一起使用。</p><h4 id="Spring-Arm"><a href="#Spring-Arm" class="headerlink" title="Spring Arm"></a><strong>Spring Arm</strong></h4><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811225031.png"></p><p>弹簧悬臂，将相机附于其上可以实现相机跟随</p><h2 id="Movement"><a href="#Movement" class="headerlink" title="Movement"></a><font color="red">Movement</font></h2><h4 id="Rotating-Movement"><a href="#Rotating-Movement" class="headerlink" title="Rotating Movement"></a><strong>Rotating Movement</strong></h4><p>旋转控制，提供一系列参数对对蓝图类的旋转运动进行控制</p><h2 id="Rendering"><a href="#Rendering" class="headerlink" title="Rendering"></a><font color="red">Rendering</font></h2><h4 id="Static-Mesh"><a href="#Static-Mesh" class="headerlink" title="Static Mesh"></a><strong>Static Mesh</strong></h4><p>静态网格，网格控制蓝图的贴图材质、模型外观、阴影渲染等。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE4】UE4连接MySQL</title>
    <link href="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%BF%9E%E6%8E%A5MySQL/"/>
    <url>/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%BF%9E%E6%8E%A5MySQL/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="使用MySQLIntegration插件连接Mysql"><a href="#使用MySQLIntegration插件连接Mysql" class="headerlink" title="使用MySQLIntegration插件连接Mysql"></a>使用MySQLIntegration插件连接Mysql</h1><ul><li>Update Data from Query Async组件后面必须再跟一个其他的节点，节点才能正常执行</li><li>UE4 C++编程中不能出现私有私有变量？</li><li>UE4 C++静态变量？</li><li>MySQL Integration插件只支持sql语句，不支持存储过程</li><li>在蓝图中实现的C++函数在蓝图中没法使用？</li><li>暴露给蓝图的变量和函数必须是公有且非静态的</li><li>UE4 C++类创建对象，大象无形31页</li><li>UE4 C++编程中if else语句必须加{}</li></ul><h2 id="1-MySQL-Integration安装"><a href="#1-MySQL-Integration安装" class="headerlink" title="1.MySQL Integration安装"></a>1.MySQL Integration安装</h2><p>MySQL Integration插件可以直接在UE4商城中搜索到，直接下载安装即可，如何是从外部导入的离线包，直接将插件文件夹丢入UE4安装目录下的Engine\Plugins文件夹下即可。</p><h2 id="2-激活MySQL-Integration"><a href="#2-激活MySQL-Integration" class="headerlink" title="2.激活MySQL Integration"></a>2.激活MySQL Integration</h2><p>激活插件直接在UE4中的Edit/Plugins/Installed下找到MySQL Integration勾选Enabled即可，勾选插件之后UE4会提示需要重启UE4才可激活，重启软件就可以激活插件了。</p><h2 id="3-MySQL-Integration提供的蓝图组件"><a href="#3-MySQL-Integration提供的蓝图组件" class="headerlink" title="3.MySQL Integration提供的蓝图组件"></a>3.MySQL Integration提供的蓝图组件</h2><p>官方文档： <a href="https://sameek4.github.io/KodeSpire/Pages/MySQLIntegration.html">https://sameek4.github.io/KodeSpire/Pages/MySQLIntegration.html</a> </p><h3 id="Set-Connection-Properties-Mysql连接"><a href="#Set-Connection-Properties-Mysql连接" class="headerlink" title="Set Connection Properties(Mysql连接)"></a>Set Connection Properties(Mysql连接)</h3><p>Set Connection Properties组件提供UE4对Mysql的连接服务。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224542.png"></p><p><strong>输入：</strong></p><ul><li>server：数据库的连接ip；</li><li>DBName：数据库的名字；</li><li>User ID：登录数据库用户名；</li><li>Password：登录数据库的用户密码；</li><li>Extra Param：SetConnectionProperties提供的额外参数传入；</li><li>Is Trusted：启用windows用户名和密码登录数据库。</li></ul><h3 id="Check-Connection-State-Mysql连接状态检查"><a href="#Check-Connection-State-Mysql连接状态检查" class="headerlink" title="Check  Connection State(Mysql连接状态检查)"></a>Check  Connection State(Mysql连接状态检查)</h3><p>此组件提供对Mysql连接的状态的查询服务。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224546.png"></p><p><strong>输出：</strong></p><ul><li><p>Error Message：输出错误信息；</p></li><li><p>Return Value：输出连接状态；</p><p>包含如下状态值(类型为插件定义的EMysqlConnectionStateEnum枚举)：</p><ul><li>Broken：数据库损坏；</li><li>Closed：连接关闭；</li><li>connecting：正在连接；</li><li>Eecuting：正在发送命令；</li><li>Fetching：数据库正在检索数据；</li><li>Open：连接以正常打开，可以正常使用数据库。</li></ul></li></ul><h3 id="Update-Data-from-Query-Async-异步发送非查询sql命令"><a href="#Update-Data-from-Query-Async-异步发送非查询sql命令" class="headerlink" title="Update Data from Query Async(异步发送非查询sql命令)"></a>Update Data from Query Async(异步发送非查询sql命令)</h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224549.png"></p><p>此组件提供非查询的sql命令发送服务，即发送insert，delete，create等命令。</p><h3 id="Update-Data-from-Query-同步发送非查询sql命令"><a href="#Update-Data-from-Query-同步发送非查询sql命令" class="headerlink" title="Update Data from Query (同步发送非查询sql命令)"></a>Update Data from Query (同步发送非查询sql命令)</h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224602.png"></p><p><strong>输入：</strong></p><ul><li>Query：sql命令字符串；</li></ul><p><strong>输出：</strong></p><ul><li><p>Success Status：命令的执行状态</p><p>有三种执行状态值，类型为插件自定义的EMysqlSuccessStateEnum枚举，</p><ul><li>Executing：sql命令正在发送；</li><li>Success：sql命令执行成功；</li><li>Failed：sql命令执行失败。</li></ul></li><li><p>Error Message：输出错误信息。</p></li></ul><h3 id="Check-Query-EXecution-State-检查上一条命令的执行状态"><a href="#Check-Query-EXecution-State-检查上一条命令的执行状态" class="headerlink" title="Check Query EXecution State(检查上一条命令的执行状态)"></a>Check Query EXecution State(检查上一条命令的执行状态)</h3><p>此组件提任何sql命令的执行状态检查，<font color="red">但仅限检查Check Query EXecution State执行前的上一条sql语句的状态检查。</font></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224607.png"></p><p>输出内容和Update Data from Query一致。</p><h3 id="Select-Data-from-Query-Async-异步发送查询命令"><a href="#Select-Data-from-Query-Async-异步发送查询命令" class="headerlink" title="Select Data from Query Async(异步发送查询命令)"></a>Select Data from Query Async(异步发送查询命令)</h3><p>此组件仅限发送select语句，其他语句发送无效，<font color="red"> 查询到的数据会存储到插件自带的数据结构中，可以使用下面介绍的Get Selected Table组件进行数据访问。</font></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224613.png"></p><h2 id="Get-Selected-Table-读取数据表"><a href="#Get-Selected-Table-读取数据表" class="headerlink" title="Get Selected Table(读取数据表)"></a>Get Selected Table(读取数据表)</h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224619.png"></p><p><strong>输出:</strong></p><ul><li>Result by Column：以列的形式返回数据，<font color="red">返回一个MySQLDataTableStructures的结构体数据，每一个结构体就是一列，MySQLDataTableStructures结构体包含两个成员ColumnName(列名)和ColumnData(列数据)，其中ColumnData是一个FString类型的TArray数组，数组中每一个元数就是该列中某一行的数据。</font></li><li>Result by Row：以行的形式返回数据，返回一个<font color="red"> 返回一个MySQLDataRowStructures类型的结构体数组，每一个结构体就是一行，MySQLDataRowStructures结构体包含一个FString类型的TArray数组，数组中每一个元素就是该行中某一列的数据。</font></li></ul><h2 id="4-MySQL-Integration的注意事项"><a href="#4-MySQL-Integration的注意事项" class="headerlink" title="4.MySQL Integration的注意事项"></a>4.MySQL Integration的注意事项</h2><h3 id="MySQL-Integration不支持存储过程"><a href="#MySQL-Integration不支持存储过程" class="headerlink" title="MySQL Integration不支持存储过程"></a>MySQL Integration不支持存储过程</h3><p>MySQL Integration插件不支持数据库的存储过程的语法，在Query引脚输入“Call ProdureceName(ParameterList) ”是没有办法唤醒数据库中的存储过程的，所以很多的数据库中的查询和插入逻辑就需要在外部实现了。</p><h3 id="MySQL-Integration不提供C-函数"><a href="#MySQL-Integration不提供C-函数" class="headerlink" title="MySQL Integration不提供C++函数"></a>MySQL Integration不提供C++函数</h3><p>MySQL Integration插件只提供蓝图组件不提供C++函数，也就是说数据库的连接查询等只能使用蓝图来实现，但大多数情况我们又必须在C++中访问数据库，在这钟情况下我们该如何做呢？</p><p>目前，我只想到一种方法，就是在C++中创建访问数据库的类在类中声明数据库的访问函数，用这个类的蓝图子类来重写该数据库访问函数，以实现父类中该数据库访问函数，这是由C++继承中的重写的特性实现的。</p><p>具体做法如下：</p><p>首先在C++中创建一个专门负责连接数据库的类并在类中声明连接函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;MysqlJsonCpp.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;GameFramework/Actor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;MysqlConnector.generated.h&quot;</span></span><br><br>UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DATA_SYS_API</span> <span class="hljs-title">AMysqlConnector</span> :</span> <span class="hljs-keyword">public</span> AActor<br>&#123;<br>GENERATED_BODY()<br><span class="hljs-keyword">public</span>:<br><br>UPROPERTY(BlueprintReadWrite,Category = <span class="hljs-string">&quot;VariableRW&quot;</span>)<br>FString errorMessage;<br>UPROPERTY(BlueprintReadWrite, Category = <span class="hljs-string">&quot;VariableRW&quot;</span>)<br>FString stateMessage;<br><br><span class="hljs-keyword">protected</span>:<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-keyword">public</span>:<br><br>AMysqlConnector();<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Tick</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime)</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-comment">//从配置文件ConnectConfig.json中读取Mysql连接配置文件</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ConnectMysqlByConfig</span><span class="hljs-params">()</span></span>;<br>    <br><span class="hljs-comment">//使用MySQLIntegration插件连接Mysql</span><br>UFUNCTION(BlueprintImplementableEvent,Category = <span class="hljs-string">&quot;OverridFunction&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">(FName server, FName dbName, FName userId, FName passwd)</span></span>;<br>    <br><span class="hljs-comment">//使用MySQLIntegration插件检查连接状态</span><br>UFUNCTION(BlueprintImplementableEvent, Category = <span class="hljs-string">&quot;OverridFunction&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ConnectState</span><span class="hljs-params">(FString &amp;errorMessageParam,FString &amp;stateMessageParam)</span></span>;<br><span class="hljs-comment">//获取连接状态</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetConnectState</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面的void Connect(FName server, FName dbName, FName userId, FName passwd);函数就是需要用蓝图实现的数据库连接函数，<font color="red"> 这里要注意，这个函数只能在C++中声明，不可以实现，否则父类调用此函数时将无法关联到子类的重写，并且这个函数需要使用<code>BlueprintImplementableEvent</code>参数暴露给蓝图</font>。</p><p><font color="red"> 这里还需要注意，如果这个函数中使用了变量的引用，那么这个变量也需要使用<code>UPROPERTY(BlueprintReadWrite, Category = &quot;VariableRW&quot;)</code>暴漏给蓝图，如上面的<code>FString errorMessage;</code>一样。</font></p><p>这样我们就可以创建一个蓝图类来继承这个类，</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224624.png"></p><p>然后在该蓝图类的MyBlueprint/Functions/Override下看到我们在C++类中声明的函数，直接重写实现即可，如：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224631.png"></p><p>实现时候我们就可以在C++中调用这个函数了，这个函数就会通过重写关联到蓝图自类中的重写过程，如此数据库便连接上了。</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE4】UE4读写Json文件</title>
    <link href="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%AF%BB%E5%86%99Json%E6%96%87%E4%BB%B6/"/>
    <url>/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%AF%BB%E5%86%99Json%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h1><p>如果我们想要在UE4中读写Json文件，那么我们必须使UE4包含<font color="red">Json和JsonUtilities</font>这两个模块，那么UE4如何添加模块呢？</p><p>UE4添加预定义模块的方法很简单，我只需打开工程的.Biuld.cs文件，在其中的<code>PublicDependencyModuleNames.AddRange()</code>函数中追加两个模块即可，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> UnrealBuildTool;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DATA_sys</span> :</span> ModuleRules<br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DATA_sys</span><span class="hljs-params">(ReadOnlyTargetRules Target)</span> : <span class="hljs-title">base</span><span class="hljs-params">(Target)</span></span><br><span class="hljs-function"></span>&#123;<br>PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;<br><br>PublicDependencyModuleNames.AddRange(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123; <span class="hljs-string">&quot;Core&quot;</span>, <span class="hljs-string">&quot;CoreUObject&quot;</span>, <span class="hljs-string">&quot;Engine&quot;</span>, <span class="hljs-string">&quot;InputCore&quot;</span> ,<span class="hljs-string">&quot;Json&quot;</span>,<span class="hljs-string">&quot;JsonUtilities&quot;</span>&#125;);<br><br>PrivateDependencyModuleNames.AddRange(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123;  &#125;);<br><br><span class="hljs-comment">// Uncomment if you are using Slate UI</span><br><span class="hljs-comment">// PrivateDependencyModuleNames.AddRange(new string[] &#123; &quot;Slate&quot;, &quot;SlateCore&quot; &#125;);</span><br><br><span class="hljs-comment">// Uncomment if you are using online features</span><br><span class="hljs-comment">// PrivateDependencyModuleNames.Add(&quot;OnlineSubsystem&quot;);</span><br><br><span class="hljs-comment">// To include OnlineSubsystemSteam, add it to the plugins section in your uproject file with the Enabled attribute set to true</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们要添加自定义模块就有点麻烦了，当然这里就不赘述了。</p><p>包含这两个模块之后，我们还需要用到<font color="red"> Json.h、JsonObject.h、JsonSerializer.h</font>三个头文件，其中JsonSerializer.h是用于Json序列化与反序列化用的。</p><p>至此我们就可以使用UE4自带的工具进行Json文件的读写工作了。</p><h1 id="二、Json文件写"><a href="#二、Json文件写" class="headerlink" title="二、Json文件写"></a>二、Json文件写</h1><h2 id="1-非序列化写入"><a href="#1-非序列化写入" class="headerlink" title="1.非序列化写入"></a>1.非序列化写入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AMysqlJsonCpp::CreatJson</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>FString filePath = FPaths::GameContentDir() + TEXT(<span class="hljs-string">&quot;MysqlConfig/Connect.json&quot;</span>);<br>FString jsonStr;<br>TSharedRef&lt;TJsonWriter&lt;&gt;&gt; jsonWriter = TJsonWriterFactory&lt;&gt;::Create(&amp;jsonStr);<br>jsonWriter-&gt;WriteObjectStart();<br>jsonWriter-&gt;WriteValue(TEXT(<span class="hljs-string">&quot;server&quot;</span>), TEXT(<span class="hljs-string">&quot;127.0.0.1&quot;</span>));<br>jsonWriter-&gt;WriteObjectEnd();<br>jsonWriter-&gt;Close();<br>FFileHelper::SaveStringToFile(jsonStr, *filePath);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>FPaths::GameContentDir()</code>返回当前工程目录的Content文件夹的路径，FPaths为UE4的路径读写工具；</p></li><li><p><code>FString jsonStr</code>的作用是用于关联UE4的Json写工具TJsonWriter&lt;&gt;，作为输入流载体，且JsonStr必须是FString类型；</p></li><li><p><code>TShareRef&lt;T&gt;</code>是UE4自身的共享指针类型；</p></li><li><p><code>TJsonWriter&lt;&gt;</code>是UE4专门用于写Json的模板类，其中类型参数通常为TCHAR，其中有多个方法供开发者使用：</p><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>Close()</td><td>关闭写工具</td></tr><tr><td>WriterArrayStart()</td><td>开始一个Json数组</td></tr><tr><td>WriterArrayEnd()</td><td>结束一个Json数组</td></tr><tr><td>WriterNull(FString)</td><td>为一个键写一个空值</td></tr><tr><td>WriterObjectStart()</td><td>开始一个Json对象</td></tr><tr><td>WriterObjectEnd()</td><td>结束一个Json对象</td></tr><tr><td>WriterValue(FString,FString/int32/float/bool)</td><td>向Json文件写入键值对</td></tr></tbody></table></li></ul><ul><li><p><code>TJsonWriterFactory&lt;&gt;::Create(FString)</code>是UE4用来生成Json写工具TJsonWriter&lt;&gt;的类，TJsonFactory&lt;&gt;只有一个方法就是Create；</p></li><li><p><code>FFileHelper</code>UE4的文件读写工具，方法<code>SaveStringToFile(TJsonWriter*,FString*)</code>函数的作用就是将Json写工具中的Json数据写到FString字符串中的路径文件中。</p></li></ul><p>使用非序列化方式写入Json时，写入方式需要严格按照Json的语法格式来做，如最开始需要使用WriterObjectStart()创建一个根前括号，即Json语法中最外面一层的<code>&#123;</code>，所有写入结束后需要使用WriterObjectEnd()声明根对象结束，即Json语法中的最外面一层的<code>&#125;</code>，同理数组也需要按对象一样的方法进行处理。如此才能写入一个结构完整的Json文本。</p><h2 id="2-序列化写入"><a href="#2-序列化写入" class="headerlink" title="2.序列化写入"></a>2.序列化写入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AMyActor::Test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>TSharedPtr&lt;FJsonObject&gt; rootObj = MakeShareable(<span class="hljs-keyword">new</span> FJsonObject());<br>rootObj-&gt;SetStringField(<span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>);<br>TArray&lt;TSharedPtr&lt;FJsonValue&gt;&gt; arrValue;<br>TSharedPtr&lt;FJsonValueString&gt; tmp = MakeShareable(<span class="hljs-keyword">new</span> FJsonValueString(<span class="hljs-string">&quot;array&quot;</span>));<br>arrValue.Add(tmp);<br>rootObj-&gt;SetArrayField(<span class="hljs-string">&quot;array&quot;</span>, arrValue);<br>FString filePath = FPaths::GameContentDir() + TEXT(<span class="hljs-string">&quot;MysqlConfig/text.json&quot;</span>);<br>FString jsonStr;<br>TSharedRef&lt;TJsonWriter&lt;TCHAR&gt;&gt; jsonWriter = TJsonWriterFactory&lt;TCHAR&gt;::Create(&amp;jsonStr);<br>FJsonSerializer::Serialize(rootObj.ToSharedRef(), jsonWriter);<br>FFileHelper::SaveStringToFile(jsonStr, *filePath);<br>UE_LOG(LogTemp, Error, TEXT(<span class="hljs-string">&quot;%s&quot;</span>),*filePath);<br>&#125;<br></code></pre></td></tr></table></figure><p>序列化的写入方式则无需考虑按Json的语法结构进行写入，序列化的写入方式是通过一个FJsonObject对象进行Json文本的写入。</p><ul><li>首先使用MakeSahreable()函数创建一个FJsonObject对象并使用共享指针引用。</li><li>然后我们便可以使用FJsonObject对象中的<code>SetArrayField(FString,TArray&lt;FSharePtr&lt;FJsonValue&gt;&gt;)</code>、<code>SetBoolFiled(FString,bool)</code>、<code>SetNumberField(FString,Number)</code>、<code>SetStringField(FString,FString)</code>、<code>SetObjectField(FString,TSharePtr&lt;FJsonObject&gt;)</code>、<code>SetField(FString,TSharePtr&lt;FJsonValue&gt;)</code>等函数向FJsonObject对象中写分别入数组、bool值、数字、字符串、对象和Json键值对。其中数组的写入较为麻烦，我们需要先向创建Json键值对类型共享指针的TArray数组<code>TArray&lt;TSharePtr&lt;FJsonValue&gt;&gt;</code>。并向数组中添加指向FJsonValue对象的共享指针后然后才可以使用SetArrayField进行数组的Json文本写入。</li><li>我们序列化写好的FJsonObject对象需要转化为FString字符串才能向文本中写入数据，FJsonObject转化为FString输入流的方式就是<code>FJsonSerializer::Serialize(TSharePtr&lt;FJsonObject&gt;.ToShareRef(),TSharePtr&lt;FJsonWriter&gt;)</code>;其中<code>TSharePtr&lt;FJsonWriter&gt;</code>和非序列化写入一样需要绑定一个FString作为输入流载体。</li><li>最后就可以通过FFileHelper::SaveStringToFile(FString,*FString)，前一个FString是输入流载体，后一个*FString是Json文件的存储路径。</li></ul><h1 id="三、Json文件读"><a href="#三、Json文件读" class="headerlink" title="三、Json文件读"></a>三、Json文件读</h1><h2 id="1-反序列化读取"><a href="#1-反序列化读取" class="headerlink" title="1.反序列化读取"></a>1.反序列化读取</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">TArray&lt;FName&gt; <span class="hljs-title">AMysqlJsonCpp::ReadMysqlConnectConfig</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>FString filePath = FPaths::GameContentDir() + TEXT(<span class="hljs-string">&quot;MysqlConfig/Connect.json&quot;</span>);<br><span class="hljs-keyword">if</span> (FPaths::FileExists(filePath))<br>&#123;<br>FString server;<br>FString dbName;<br>FString userId;<br>FString passwd;<br>TArray&lt;FName&gt; connectConfig;<br>FString fileStr;<br>FFileHelper::LoadFileToString(fileStr, *filePath);<br>TSharedPtr&lt;FJsonObject&gt; rootObject = MakeShareable(<span class="hljs-keyword">new</span> FJsonObject());<br>TSharedRef&lt;TJsonReader&lt;&gt;&gt; jsonReader = TJsonReaderFactory&lt;&gt;::Create(fileStr);<br><span class="hljs-keyword">if</span> (FJsonSerializer::Deserialize(jsonReader, rootObject))<br>&#123;<br>server = rootObject-&gt;GetStringField(<span class="hljs-string">&quot;server&quot;</span>);<br>dbName = rootObject-&gt;GetStringField(<span class="hljs-string">&quot;dbName&quot;</span>);<br>userId = rootObject-&gt;GetStringField(<span class="hljs-string">&quot;userId&quot;</span>);<br>passwd = rootObject-&gt;GetStringField(<span class="hljs-string">&quot;passwd&quot;</span>);<br>&#125;<br>connectConfig.Add(FName(*server));<br>connectConfig.Add(FName(*dbName));<br>connectConfig.Add(FName(*userId));<br>connectConfig.Add(FName(*passwd));<br>&#125;<br><br><span class="hljs-keyword">return</span> TArray&lt;FName&gt;();<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>首先Json文本的读取需要将Json文本以字符串的形式读入到一个FString的输入流载体中；</li><li>然后我们需要将这个输入流载体绑定到TJsonReader&lt;&gt;读出工具上；</li><li>然后使用<code>FJsonSerializer::Deserialize(TSharePtr&lt;TJsonReader&lt;&gt;&gt;,TSahrePtr&lt;FJsonObject&gt;)</code>将输入流载体的Json数据反序列化到FJsonObject对象中；</li><li>最后我们就可以使用FJsonObject对象中的<code>GetArrayField(FString)</code>、<code>GetBoolFiled(FString)</code>、<code>GetNumberField(FString)</code>、<code>GetStringField(FString)</code>、<code>GetObjectField(FString)</code>、<code>GetField(FString)</code>等方法从Json对象中读取指定键的值了。</li></ul>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE4】UE4蓝图基础</title>
    <link href="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/"/>
    <url>/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="一、蓝图可视化脚本与蓝图系统"><a href="#一、蓝图可视化脚本与蓝图系统" class="headerlink" title="一、蓝图可视化脚本与蓝图系统"></a>一、蓝图可视化脚本与蓝图系统</h1><h2 id="1-蓝图脚本"><a href="#1-蓝图脚本" class="headerlink" title="1.蓝图脚本"></a>1.蓝图脚本</h2><p>蓝图可视化脚本简称“蓝图”或“蓝图脚本”，是一种需要编译的面向对象的可视化编程语言，蓝图完全集成在UE4中，蓝图通过节点与连线工作。</p><h3 id="蓝图脚本的节点"><a href="#蓝图脚本的节点" class="headerlink" title="蓝图脚本的节点"></a>蓝图脚本的节点</h3><ul><li>触发事件，在蓝图脚本中以红色的节点出现</li><li>函数，在看图脚本中以蓝色的节点出现</li><li>变量，在蓝图脚本中中以黄色节点出现</li></ul><h2 id="2-蓝图系统"><a href="#2-蓝图系统" class="headerlink" title="2.蓝图系统"></a>2.蓝图系统</h2><p>蓝图系统又称“蓝图”或“蓝图类”，蓝图类可以看成是一个包含游戏内容的容器，其中可以包含组件、脚本或可以仅仅包含数据。</p><p>蓝图类有点类似Unity3d中的预设(prefb)，蓝图类可以类似预设一般保存对象状态，可以随时拖入场景中使用，只是在其他功能上不如预设，如预设在U3D中的打包中可以发挥出优秀的效果，但是蓝图类只能作为容器使用。</p><p><font color="red"> 蓝图类包含蓝图脚本，每一个蓝图类都包含一个默认的蓝图脚本。</font></p><h3 id="蓝图类的分类"><a href="#蓝图类的分类" class="headerlink" title="蓝图类的分类"></a>蓝图类的分类</h3><ul><li><strong>关卡蓝图</strong>：关卡蓝图在每个Level中只能存在一个，负责整个关卡的运行逻辑，关卡的初始化，帧更新都在关卡蓝图里进行；</li><li><strong>普通蓝图</strong>：普通蓝图就是UE4的预设，在普通蓝图中我们可以对其中的对象进行一些的配置，如设置网格，贴图，粒子特效，添加相机，添加物理材质和挂载蓝图脚本等等；</li><li><strong>游戏模式蓝图</strong>：UE4中游戏模式也是以蓝图的形式存在的，游戏模式蓝图控制一系列游戏的规则；</li><li><strong>材质蓝图</strong>：在UE4中贴图材质也是蓝图的形式存在的，在材质蓝图中我们可以如同建模软件一般对材质进行一系列更高级的材质配置，如下图的一个简单示例：</li></ul><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224209.png"></p><h2 id="4-创建蓝图"><a href="#4-创建蓝图" class="headerlink" title="4.创建蓝图"></a>4.创建蓝图</h2><p>创建蓝图的方法很多，这里介绍比较常用的方法</p><ul><li>可以直接在Content Browser(内容浏览器)中右键创建一个空的蓝图类，空蓝图除了包含一个根组件外不再包含其他东西，当我们在空蓝图中创建了对象后可以通过拖拽的方式将对象拖动到根组件位置处，用游戏对象替换根组件作为根组件，这样创建空蓝图时的白色小球就会消失；</li><li>在World Outliner(世界大纲)中选中游戏对象，可以通过工具栏中的Blueprints工具中的下面两个选项创建一个包含所选内容的蓝图类；</li></ul><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224214.png"></p><ul><li>通过Blueprints工具的New Empty Blueprint Class也可以直接创建空蓝图类；</li><li>然而关卡蓝图似乎只能通过Blueprints工具的Open Blueprint Class打开。</li></ul><h1 id="二、变量与对象引用"><a href="#二、变量与对象引用" class="headerlink" title="二、变量与对象引用"></a>二、变量与对象引用</h1><h2 id="1-在蓝图中创建变量"><a href="#1-在蓝图中创建变量" class="headerlink" title="1.在蓝图中创建变量"></a>1.在蓝图中创建变量</h2><p>在蓝图中创建变量的方式有两种，其一：直接点击My BluePrint/Variables/+Variable，默认创建bool行的变量，可以点击变量前的色块更换变量类型。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224219.png"></p><p>其二：在蓝图脚本区域右键-&gt;输入Get New Var，可以直接在蓝图脚本中以节点的形式创建变量，在右侧细节面板中设置变量的值。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224223.png"></p><p>所有创建好的变量都会在My Blueprint面板Variables栏中显示。</p><p><font color="red"> 在创建好的变量的Details/Variable/Variable Type选项中可以设置变量为普通变量、数组、Set容器和Map容器。</font></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224225.png"></p><h2 id="2-在蓝图中使用变量"><a href="#2-在蓝图中使用变量" class="headerlink" title="2.在蓝图中使用变量"></a>2.在蓝图中使用变量</h2><p>可以直接在蓝图脚本区域右键-&gt;输入Get/Set [变量名]即可获取变量的获取/设置组件，也可以直接从左侧的My Blueprint面板Variables栏中拖拽变量到蓝图脚本区域选择Get/Set。</p><h2 id="3-生成时公开与私有变量"><a href="#3-生成时公开与私有变量" class="headerlink" title="3.生成时公开与私有变量"></a>3.生成时公开与私有变量</h2><p>蓝图中的公有与私有与程序中的公有私有有一些不同，蓝图中只分为生成时公开和私有两种访问权限。</p><h3 id="生成时公开-Expose-on-Spawn"><a href="#生成时公开-Expose-on-Spawn" class="headerlink" title="生成时公开(Expose on Spawn)"></a>生成时公开(Expose on Spawn)</h3><p>勾选生成时公开后，在蓝图类使用Spawn Actor from Class组件生成蓝图类实例时，勾选生成时公开的变量将可以接受外部值输入。<br><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224229.png"></p><p>如上图可以看到勾选生成时公开的变量会以输入接口的形式出现在Spawn Actor from Class节点里。这里需要注意的是，勾选Expose on Spawn，还需要勾选Instance Editable，否则会报警告。</p><h3 id="私有变量-Private"><a href="#私有变量-Private" class="headerlink" title="私有变量(Private)"></a>私有变量(Private)</h3><p>设置成私有变量的变量只能在蓝图类里访问，蓝图类的外部实例也无法访问这个变量，如上图，变量L没有设置成私有，所以可以通过Spawn Actor from Class组件生成的实例访问这个变量，而设置成私有的K变量搜索不到Set K节点。</p><h2 id="3-在蓝图中使用组件引用"><a href="#3-在蓝图中使用组件引用" class="headerlink" title="3.在蓝图中使用组件引用"></a>3.在蓝图中使用组件引用</h2><p>很多时候我们需要调节自身Actor上的组件的某些参数，那么我们就需要获得这个组件的引用以便获取组件上的参数进行调节，那么我们如何获得组件的引用呢？</p><p>其实方法也很简单，在My Blueprint/Variabales下有一个子栏“Components”其中存放着当前Actor上的所有的组件的引用，使用方法就是直接将需要的组件引用拖拽到蓝图脚本区域即可。获得了组件引用我们就可以通过引用使用不同的方法获取组件上的不同的参数了。</p><h2 id="4-动态获取世界大纲中的Actor"><a href="#4-动态获取世界大纲中的Actor" class="headerlink" title="4.动态获取世界大纲中的Actor"></a>4.动态获取世界大纲中的Actor</h2><p>在蓝图脚本中有四个方法获取外部Actor：</p><ul><li>Get All Actor of Class：通过类型来获取外部Actor</li></ul><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224234.png"></p><ul><li>Get All Actor with Tag：通过标签来获取外部Actor</li></ul><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224237.png"></p><ul><li>Get All Actor with Interface：通过外部接口在获取外部Actor</li></ul><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224240.png"></p><ul><li>Get Actors：通过层来获取Actor</li></ul><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224243.png"></p><h1 id="三、蓝图的数据类型"><a href="#三、蓝图的数据类型" class="headerlink" title="三、蓝图的数据类型"></a>三、蓝图的数据类型</h1><h2 id="1-5个基本数据类型"><a href="#1-5个基本数据类型" class="headerlink" title="1.5个基本数据类型"></a>1.5个基本数据类型</h2><p>UE4蓝图中基本数据类型只有5个，需要注意的是蓝图中没有char、double、short、long等数据类型，在C++与蓝图的配合使用时需要注意这些类型的变量。</p><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><h3 id="Byte"><a href="#Byte" class="headerlink" title="Byte"></a>Byte</h3><p>8位，一字节，0-255。</p><h3 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h3><p>32位整型，四字节。</p><h3 id="Integer64"><a href="#Integer64" class="headerlink" title="Integer64"></a>Integer64</h3><p>64位整型，八字节，能存储更大的数。</p><h3 id="Float"><a href="#Float" class="headerlink" title="Float"></a>Float</h3><p>32位单精度浮点型，其中1符号位、8指数位、23数值位，UE4中默认保留小数点后6位。UE4中只有Float类型没有Double类型。</p><h2 id="2-3种字符串"><a href="#2-3种字符串" class="headerlink" title="2.3种字符串"></a>2.3种字符串</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>蓝图中String类型就是蓝图C++中的FString类型，普通字符串，可以对其中的字符进行增删查改。</p><h3 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h3><p>Name是一种固定字符串类型，变量初始化以后不能在对其中的内容进行修改，且Name类型的字符串不区分大小写，多用于作为全局变量来唯一标识对象。Name类型的字符串在运行过程中存储于内存的字符串表中，使用效率高。</p><h3 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h3><p>Text是String的长度加强版，通常用于存储一段文字并可以进行国际化处理。</p><h2 id="3-Vector-维度向量"><a href="#3-Vector-维度向量" class="headerlink" title="3.Vector(维度向量)"></a>3.Vector(维度向量)</h2><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>默认创建的Vector是Vector 3D，即三维量，包含x、y、z三个值，可以表示任何任何三维量，如：三维坐标和RGB等。</p><h3 id="Vector-2D-和Vector-4"><a href="#Vector-2D-和Vector-4" class="headerlink" title="Vector 2D 和Vector 4"></a>Vector 2D 和Vector 4</h3><p>Vector 2D就是二维量，Vector 4就是四维量，常用于表示四元素。</p><h3 id="Two-Vectors"><a href="#Two-Vectors" class="headerlink" title="Two Vectors"></a>Two Vectors</h3><p>Two Vectors就是一个关于Vector的pair(对组)，pair在C++的STL种较为常用，是一个只包含两个元素的容器。</p><h2 id="4-Rotator-三维旋转量"><a href="#4-Rotator-三维旋转量" class="headerlink" title="4.Rotator(三维旋转量)"></a>4.Rotator(三维旋转量)</h2><p>包含：</p><p>x：roll，翻滚角，以x为轴，进行yz平面的旋转；</p><p>y：pitch，俯仰角，以y为轴，进行xz平面的旋转；</p><p>z：yaw，航向角，以z为轴，进行xy平面的旋转。</p><h2 id="5-Transform"><a href="#5-Transform" class="headerlink" title="5.Transform"></a>5.Transform</h2><p>Transfrom类型是一个3*3的矩阵，包含Location、Rotation和Scale三个三维向量。</p><h1 id="四、条件语句"><a href="#四、条件语句" class="headerlink" title="四、条件语句"></a>四、条件语句</h1><h2 id="1-Branch-if条件判断"><a href="#1-Branch-if条件判断" class="headerlink" title="1.Branch(if条件判断)"></a>1.Branch(if条件判断)</h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224256.png"></p><p>传入一个bool值，进行分流，通常和比较组件配合使用，如：“==”、“&gt;”等。</p><h2 id="2-Switch"><a href="#2-Switch" class="headerlink" title="2.Switch"></a>2.Switch</h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224300.png"></p><ul><li>Selection：case判断的变量；</li><li>Default：默认执行分支；</li><li>Add pin：添加执行分支。</li></ul><h1 id="五、循环语句"><a href="#五、循环语句" class="headerlink" title="五、循环语句"></a>五、循环语句</h1><h2 id="1-For-Loop-for循环"><a href="#1-For-Loop-for循环" class="headerlink" title="1.For Loop(for循环)"></a>1.For Loop(for循环)</h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224303.png"></p><ul><li>First Index/Last Index：提供循环的次数；</li><li>Loop Body：循环体执行分支；</li><li>Index：返回当前循环索引；</li><li>Conpleted：循环完毕后执行分支。</li></ul><h2 id="2-For-Loop-whit-Break-可跳出的for循环"><a href="#2-For-Loop-whit-Break-可跳出的for循环" class="headerlink" title="2.For Loop whit Break(可跳出的for循环)"></a>2.For Loop whit Break(可跳出的for循环)</h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224306.png"></p><p>使用方法和For Loop类似。</p><h2 id="3-For-Each-Loop-数组遍历"><a href="#3-For-Each-Loop-数组遍历" class="headerlink" title="3.For Each Loop(数组遍历)"></a>3.For Each Loop(数组遍历)</h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224309.png"></p><p>专门有用遍历数组的循环。</p><ul><li>Array：需要遍历的数组；</li><li>Loop Body：循环体分支；</li><li>Array Element：遍历的数组元素；</li><li>Array Index：当前索引；</li><li>Completed：遍历结束执行分支。</li></ul><h2 id="4-For-Each-Loop-with-Break-可跳出的数组遍历"><a href="#4-For-Each-Loop-with-Break-可跳出的数组遍历" class="headerlink" title="4.For Each Loop with Break(可跳出的数组遍历)"></a>4.For Each Loop with Break(可跳出的数组遍历)</h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224313.png"></p><p>用法和Foreach Loop一样，只是多了一个跳出执行分支。</p><h2 id="5-Reverse-for-Each-Loop-反向数组遍历"><a href="#5-Reverse-for-Each-Loop-反向数组遍历" class="headerlink" title="5.Reverse for Each Loop(反向数组遍历)"></a>5.Reverse for Each Loop(反向数组遍历)</h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224316.png"></p><h2 id="6-While-Loop-while循环"><a href="#6-While-Loop-while循环" class="headerlink" title="6.While Loop(while循环)"></a>6.While Loop(while循环)</h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224320.png"></p><h1 id="六、数组"><a href="#六、数组" class="headerlink" title="六、数组"></a>六、数组</h1><h2 id="1-创建数组"><a href="#1-创建数组" class="headerlink" title="1.创建数组"></a>1.创建数组</h2><p>创建数组要比创建变量多一个步骤，首先我们需要创建一个变量，然后再将这个变量的Details/Varialble Type选项的右侧色块选择九宫格，即可将对应变量转换成对应类型的数组。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224322.png"></p><h2 id="2-为数组赋值"><a href="#2-为数组赋值" class="headerlink" title="2.为数组赋值"></a>2.为数组赋值</h2><h3 id="Add-Array"><a href="#Add-Array" class="headerlink" title="Add(Array)"></a>Add(Array)</h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224326.png"></p><p>传入一个数组和一个元素即可通过Add(Array)组件为组数赋值</p><p>如：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224329.png"></p><p>循环完毕后数组Array内便存储有0-10的是个int型元素。</p><h2 id="3-获取元素"><a href="#3-获取元素" class="headerlink" title="3.获取元素"></a>3.获取元素</h2><h3 id="Get-a-copy"><a href="#Get-a-copy" class="headerlink" title="Get(a copy)"></a>Get(a copy)</h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224333.png"></p><p>获取指定索引的元素的拷贝。</p><h3 id="Get-a-ref"><a href="#Get-a-ref" class="headerlink" title="Get(a ref)"></a>Get(a ref)</h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224336.png"></p><p>获取指定索引的元素的引用。</p><h2 id="4-插入元素"><a href="#4-插入元素" class="headerlink" title="4.插入元素"></a>4.插入元素</h2><h3 id="Add-Aray"><a href="#Add-Aray" class="headerlink" title="Add(Aray)"></a>Add(Aray)</h3><p>直接在数组的末尾插入元素的方法也是使用Add(Array)组件，Add(Array)组件的的插入过程就是直接在数组的末尾插入元素。</p><h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224339.png"></p><p>指定位置插入使用Insert组件，输入参数从上至下依次为目标数组、要插入的元素、目标插入的索引位置。</p><p>当要使用Insert组件在数组末尾插入，而又不知道数组大小时，可以使用Last Index组件直接获取输入数组的尾索引，当然直接使用只会在最后一个索引位置插入，而使最后一位元素向后移动一位，而达不到在数组尾部插入的效果，所以需要加一食用。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224342.png"></p><h3 id="Set-Array-Elem"><a href="#Set-Array-Elem" class="headerlink" title="Set Array Elem"></a>Set Array Elem</h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224345.png"></p><p>设置输入数组指定索引的元素的值，Size to Fit选项可以设置如果指定索引不存在时数组自动扩充size大小。</p><h2 id="5-查找元素"><a href="#5-查找元素" class="headerlink" title="5.查找元素"></a>5.查找元素</h2><h3 id="Contains-Item"><a href="#Contains-Item" class="headerlink" title="Contains Item"></a>Contains Item</h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224349.png"></p><p>Contains Item组件可以查找指定数组中是否包含某一元素，但是Contains Item只返回bool的判断结果，不会返回目标的索引值。</p><h3 id="Find-Item"><a href="#Find-Item" class="headerlink" title="Find Item"></a>Find Item</h3><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Git/Temp/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-59-54.png"></p><p>Find Item则是从输入数组中查找指定元素并返回第一次查找到该元素的索引值。</p><h2 id="6-删除元素"><a href="#6-删除元素" class="headerlink" title="6.删除元素"></a>6.删除元素</h2><h3 id="Remove-Index"><a href="#Remove-Index" class="headerlink" title="Remove Index"></a>Remove Index</h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224353.png"></p><p>通过索引删除元素</p><h3 id="Remove-Item"><a href="#Remove-Item" class="headerlink" title="Remove Item"></a>Remove Item</h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224357.png"></p><p>从输入数组中移除指定元素，Remove Item会删除数组中所有指定的元素，如果删除成功则返回true，失败则返回false。</p><h2 id="7-筛选元素"><a href="#7-筛选元素" class="headerlink" title="7.筛选元素"></a>7.筛选元素</h2><h3 id="Filter-Array"><a href="#Filter-Array" class="headerlink" title="Filter Array"></a>Filter Array</h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224400.png"></p><p>过滤数组可以按类型来筛选数组元素，用于父类型数组存储子类型元素时进行类型筛选，如：Actor数组筛选MyClass类型元素，Filter Array返回一个筛选后的新数组。</p><h2 id="8-清空数组"><a href="#8-清空数组" class="headerlink" title="8.清空数组"></a>8.清空数组</h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224406.png"></p><p>使用Clear组件可以将数组内的元素全部清空。</p><h2 id="9-获取数组长度"><a href="#9-获取数组长度" class="headerlink" title="9.获取数组长度"></a>9.获取数组长度</h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224409.png"></p><h2 id="10-设置数组长度"><a href="#10-设置数组长度" class="headerlink" title="10.设置数组长度"></a>10.设置数组长度</h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224412.png"></p><h1 id="七、结构体"><a href="#七、结构体" class="headerlink" title="七、结构体"></a>七、结构体</h1><h2 id="1-结构体创建"><a href="#1-结构体创建" class="headerlink" title="1.结构体创建"></a>1.结构体创建</h2><p>蓝图中结构体的创建是没办法在蓝图脚本视图中创建的，UE4蓝图中结构体是与蓝图脚本同级的蓝图类，创建蓝图结构体的方法：在Content Browser中右键-&gt;Create Advanced Assect/Blueprint栏-&gt;Structure，即可创建一个结构体，创建出来的结构体默认拥有一个bool值得成员变量。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224416.png"></p><h2 id="2-定义成员变量"><a href="#2-定义成员变量" class="headerlink" title="2.定义成员变量"></a>2.定义成员变量</h2><p>蓝图中得结构体只能创建成员变量，不能创建成员函数，成员变量可以直接设置默认值。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224420.png"></p><h2 id="3-结构的使用"><a href="#3-结构的使用" class="headerlink" title="3.结构的使用"></a>3.结构的使用</h2><p>将结构体创建好以后便可以直接在蓝图脚本中搜索到并使用了。</p><h1 id="八、枚举"><a href="#八、枚举" class="headerlink" title="八、枚举"></a>八、枚举</h1><h2 id="1-枚举的创建"><a href="#1-枚举的创建" class="headerlink" title="1.枚举的创建"></a>1.枚举的创建</h2><p>枚举的创建和使用和结构体区别不大，创建方式一如结构体一般,Content Browser中右键-&gt;Create Advanced Assect/Blueprint栏-&gt;Enumeration，创建好后UE4也会在一个新的视图中对枚举进行编辑，枚举的编辑操作也相当简单，只有向枚举中添加与删除元素的操作，这些元素都可以添加注解提示，枚举也可以添加整个枚举的注解提示。</p><h2 id="2-枚举的使用"><a href="#2-枚举的使用" class="headerlink" title="2.枚举的使用"></a>2.枚举的使用</h2><p>枚举的使用就如同变量的使用一般，没有什么可说的。</p><h1 id="九、接口"><a href="#九、接口" class="headerlink" title="九、接口"></a>九、接口</h1><h2 id="1-接口的定义"><a href="#1-接口的定义" class="headerlink" title="1.接口的定义"></a>1.接口的定义</h2><p>接口的定义和和蓝图函数库，蓝图宏库一样，但是接口的不像函数库和宏库一般可以再一个蓝图类中定义多个函数和宏，接口就是一个蓝图类，并且接口的编辑界面及其简约，可编辑视图只有一个My Blueprint和一个Detials,在My Blueprint/Functions栏可以新建接口函数，在对应的接口函数的Details/Graph可以设置一些接口函数的描述和Const属性，在Details/Inputs和Outputs栏可以设置接口函数的输入与输出参数。</p><h2 id="2-接口的继承"><a href="#2-接口的继承" class="headerlink" title="2.接口的继承"></a>2.接口的继承</h2><p>接口是一个抽象蓝图，接口的实现必须通过继承接口的蓝图来实现，在蓝图中接口继承通过Toolbar/Class Settings/Interfaces栏即可添加接口到当前蓝图类是指继承此接口。</p><h2 id="3-接口的实现"><a href="#3-接口的实现" class="headerlink" title="3.接口的实现"></a>3.接口的实现</h2><h3 id="无返回值的接口实现"><a href="#无返回值的接口实现" class="headerlink" title="无返回值的接口实现"></a>无返回值的接口实现</h3><p>在一个蓝图继承了一个无返回值得接口后，这个接口将以事件的形式出现在这个蓝图类的All Actions for this Blueprint里</p><p>如：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224426.png"></p><p>蓝图以这个事件作为接口函数的入口，以此节点开始便可以开始实现各个蓝图类各自继承的接口函数的逻辑了。</p><h3 id="有返回值得接口实现"><a href="#有返回值得接口实现" class="headerlink" title="有返回值得接口实现"></a>有返回值得接口实现</h3><p>有返回值的接口不会以事件的形式出现在Add Event里，而是会直接出现在My Blueprint/Interface栏里，我们双击即可打开接口函数的编辑视图，在视图中实现接口即可。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224430.png"></p><h2 id="4-接口函数的调用"><a href="#4-接口函数的调用" class="headerlink" title="4.接口函数的调用"></a>4.接口函数的调用</h2><p>蓝图通过<code>[接口名](Mesasge)</code>组件来调用接口中的函数，如下图中的Interface1(Message)和Interface2(Message)。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224433.png"></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224436.png"></p><p>接口的使用需要指定使用的接口是哪个蓝图类中实现的接口和接口需要传入的参数。在蓝图类的My Blueprint/Variables栏是可以搜索到我们自己创建的蓝图类的，通过过去蓝图类的引用便可以指定接口函数的实现者了。当然我们也可以使用Get All Actors with Interface组件来获取实现了指定接口的所有蓝图类，然后再对这些蓝图类中实现的函数进行调用。</p><h1 id="十、蓝图函数库"><a href="#十、蓝图函数库" class="headerlink" title="十、蓝图函数库"></a>十、蓝图函数库</h1><p><font color="red"> 蓝图函数库是一个可以被所有蓝图类调用的函数集合，蓝图函数库里的方法全部都被定义为静态方法</font>，用于定义一些不与特定游戏对象绑定的功能性函数的实现。</p><h2 id="1-创建蓝图函数库"><a href="#1-创建蓝图函数库" class="headerlink" title="1.创建蓝图函数库"></a>1.创建蓝图函数库</h2><p>创建蓝图函数库的方式和创建结构体类似，在Content Browser中右键-&gt;Create Advanced Assect/Blueprint栏-&gt;Bluprint Function LiberLibrary。</p><h2 id="2-实现蓝图函数库里的函数"><a href="#2-实现蓝图函数库里的函数" class="headerlink" title="2.实现蓝图函数库里的函数"></a>2.实现蓝图函数库里的函数</h2><p>和结构体一样，创建好的蓝图函数库UE4会创建一个新的界面用于编辑库里函数；</p><ul><li>在My Blueprint/Functions栏可以申明函数</li><li>在My Blueprint/Local Variables栏可以生命局部变量，在其Details中可以设置局部变量默认值；</li><li>在对应函数的Details/Input和Output栏可以分别设置函数的输入输出参数</li><li>在脚本编辑区可以实现函数逻辑。</li></ul><h2 id="3-使用蓝图函数库里的函数"><a href="#3-使用蓝图函数库里的函数" class="headerlink" title="3.使用蓝图函数库里的函数"></a>3.使用蓝图函数库里的函数</h2><p>要使用蓝图函数库里的函数，可直接在脚本编辑区右键输入函数名即可在Class栏中看到蓝图函数库里的函数了。</p><h1 id="十一、蓝图宏库"><a href="#十一、蓝图宏库" class="headerlink" title="十一、蓝图宏库"></a>十一、蓝图宏库</h1><p>宏在UE4中几乎无处不在，蓝图宏库是开发者使用蓝图自定义的一系列的宏的容器，蓝图宏库和蓝图函数库一样可以定义多个宏；</p><ul><li>蓝图宏库与蓝图函数库不同的是，蓝图宏库中的宏是在预编译过程中完成处理的，即蓝图宏库不需要编译；</li><li>自定义的宏，可以有任意数量的输入输出引脚，即一个宏可以没有输出引脚，这样的宏可以只进行数据处理，一个宏也可以有多个输入输出引脚，这样的宏可以根据不同的逻辑选择不同的执行流，而蓝图函数库中的函数必须有且只有一个输入和一个输出引脚；</li><li>与函数不同，宏中不可以再定义成员变量，即宏只负责处理逻辑，不提供暂存能力。</li></ul><h2 id="1-创建蓝图宏库"><a href="#1-创建蓝图宏库" class="headerlink" title="1.创建蓝图宏库"></a>1.创建蓝图宏库</h2><p>宏库的创建与函数库的创建是一样的，在Content Browser中右键-&gt;Create Advanced Assect/Blueprint栏-&gt;Bluprint Macro LiberLibrary。</p><h2 id="2-蓝图宏声明"><a href="#2-蓝图宏声明" class="headerlink" title="2.蓝图宏声明"></a>2.蓝图宏声明</h2><ul><li>在My Blueprint/Macro中可以声明一个宏；</li><li>在指定宏的Details/Inputs和Outputs中可以定义输入与输出引脚和参数。</li></ul><h2 id="3-蓝图宏的使用"><a href="#3-蓝图宏的使用" class="headerlink" title="3.蓝图宏的使用"></a>3.蓝图宏的使用</h2><p>和蓝图函数的使用方法一致。</p><h2 id="4-自定义流程控制"><a href="#4-自定义流程控制" class="headerlink" title="4.自定义流程控制"></a>4.自定义流程控制</h2><p>除了蓝图提供给我们的条件语句和循环语句等流程控制语句外，我还可以使用宏编写自己的流程控制，因为宏可以有多个输入和输出引脚，使用方法就是使用宏的形式定义自己的流程控制逻辑，通过不同的输入给予不同输出，即可达到自定义流程控制的目的。</p><h1 id="十二、事件"><a href="#十二、事件" class="headerlink" title="十二、事件"></a>十二、事件</h1><p>除了UE4蓝图中给我们提供大量的预定义事件，我也可以自定义事件。</p><h2 id="1-事件的定义"><a href="#1-事件的定义" class="headerlink" title="1.事件的定义"></a>1.事件的定义</h2><p>事件的定义也很简单，在All Actions for this Buleprint中选择Add Custom Event，便可以创建一个自定义事件的入口，之后通过这个入口实现事件的内部逻辑，一个事件便定义完成。</p><h2 id="2-事件的调用"><a href="#2-事件的调用" class="headerlink" title="2.事件的调用"></a>2.事件的调用</h2><p>事件调用必须通过实现这个事件的蓝图类才可以对其中的事件进行调用。如：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224450.png"></p><p>Event Blueprint为实现自定义事件的蓝图类；</p><p>Print Str为自定义事件。</p><h2 id="3-事件调度器"><a href="#3-事件调度器" class="headerlink" title="3.事件调度器"></a>3.事件调度器</h2><p>事件调度器的创建与使用请阅读目录：十七、蓝图类的通信/3.使用事件调度器进行通信</p><h1 id="十三、蓝图模块"><a href="#十三、蓝图模块" class="headerlink" title="十三、蓝图模块"></a>十三、蓝图模块</h1><p>蓝图中可以将一个复杂了逻辑处理合并成一个节点模块，从而简化整体的执行流复杂度，使蓝图的执行流变得简单明了。我们可以将需要合并的执行流多选选中然后右键，即可在Organization栏中通过Collapse Nodes选项来合并执行流。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224454.png"></p><p>除了将执行流合并成节点外，蓝图还提供将多个执行流合并成一个函数或一个宏的功能。合并好的模块也可以在Organizition/Expand Node进行模块分离。</p><h1 id="十四、角色控制"><a href="#十四、角色控制" class="headerlink" title="十四、角色控制"></a>十四、角色控制</h1><h2 id="1-为角色添加跟随相机"><a href="#1-为角色添加跟随相机" class="headerlink" title="1.为角色添加跟随相机"></a>1.为角色添加跟随相机</h2><p>相对U3D来说，UE4的相机跟随要简单得多，UE4中直接将相机设置成了蓝图类的组件，当蓝图类时Player时，即可实现相机对Player的跟随了。</p><p>相机跟随需要通过一个物理组件<code>Spring Arm</code>来链接相机和Player，将相机附着在Spring Arm下，即可在Spring Arm的作用下实现相机跟随。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224458.png"></p><h2 id="2-为角色添加控制器"><a href="#2-为角色添加控制器" class="headerlink" title="2.为角色添加控制器"></a>2.为角色添加控制器</h2><p>在UE4的游戏制作过程中，我们不难发现当我们运行游戏时，在世界大纲中多出了很多东西，如下图：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224502.png"></p><p>其实，UE4为我们提供很多已经预制好的必须品，如上图的PlayerController(角色控制器)、PlayerCameraMenager(角色相机管理器)等。也就是说不可以直接使用UE4预制给我们的角色控制器来控制我们的Player，而不需要自己再去为Player蓝图配置角色控制器了，我们只需将Player的细节面板上的Auto Possess Player设置成Player0即可，Player0即表示本地角色。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224505.png"></p><p>需要注意的是，对于角色控制更优的方式是使用<code>Player Start</code>组件去持有Player蓝图类，再通过Player Controller来控制Player Start达到控制角色的目的。</p><h2 id="3-自定义游戏模式"><a href="#3-自定义游戏模式" class="headerlink" title="3.自定义游戏模式"></a>3.自定义游戏模式</h2><p>在我们创建一个UE4工程后，UE4会启用UE4默认的游戏模式<code>GameModeBase</code>，GameModeBase就控制着Player Controller、PlayerCameraMenager、PlayerState等运行时UE4动态生成的一些游戏物体，我们可以通过启用我们自定义的游戏模式来设置这些游戏物体按自己的定义的规则来生成运行。</p><p>游戏模式也是一个蓝图类，创建游戏模式就是创建蓝图类，只是这个蓝图类需要继承自GameModeBase类，继承自GameModeBase类的蓝图就是一个游戏模式蓝图。不过在我们第一此=次打开游戏模式蓝图时，UE4会将游戏模式蓝图识别成一个普通蓝图，而进入普通蓝图的编辑模式，可能是bug吧，此时我们只需将蓝图关闭，再打开一次，UE4便可以识别出游戏模式蓝图了。</p><p>游戏模式蓝图中可以定义自己的游戏模式规则，比如我们可以通过修改Spectator Class选项为自定义的游戏物体，这样在游戏运行时，UE4将不再生成DefaulPawn，而是会生成我们指定的游戏物体。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224510.png"></p><p>配置好游戏模式后我们还需要让当前项目使用我们自定义的游戏模式，通过Seettings -&gt;Project Settings-&gt;Project/Maps&amp;Modes-&gt;Dfault GameModes，选择我们自己的配置的游戏模式即可让当前项目启用我们自己定义的游戏模式了</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224513.png"></p><h2 id="4-操控角色控制器"><a href="#4-操控角色控制器" class="headerlink" title="4.操控角色控制器"></a>4.操控角色控制器</h2><p>我们要操控角色控制器就需要配置键盘按键映射，配置好的键盘映射会以函数的形式加入蓝图脚本组件集中。</p><p>我们在Seettings -&gt;Project Settings-&gt;Engine/Input-&gt;Bindings/Axis Mappings设置键盘映射并可以配置映射的值，</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224518.png"></p><p>配置好键盘映射以后便可以在蓝图脚本中使用这些函数主键来控制我们Player了，控制角色运动的方法很多，我这里以旋转力矩的方式来控制小球运动，具体的控制方法如下：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224521.png"></p><p>加入两个键盘映射函数组件(InputAxis MoveF/B,InputAxis MoveL/R)、两个添加角度力矩的组件(Add Torque in Radians,Add Torque in Radians)，但是添加角度力矩组件是需要一个控制目标的，我们需要从左侧的My Blueprint面板的Components中将需要控制的物体Player拖入脚本蓝图中，分别连接到添加角度力矩组件的Target上。</p><p>这里还需要注意的一点是，在我们为Player添加相机时，相机使用的是相对于Player的局部坐标，使用局部坐标的相机会跟随Player旋转，而使用世界坐标的相机将会固定某一个角度跟随Player移动。切换方法为：下拉Spring Arm的细节面板/Transform/Rotation的三角箭头选择切换。</p><p>并且相机默认情况下是启用了物理碰撞的，但大多数情况下我们是不需要让相机出现物理碰撞的，所以我们也应当取消相机的物理碰撞。操作方法为：取消Spring Arm的细节面板/Camera Collision/Do Collision Test选项。</p><p>当然要想比较真实的模拟出物理效果，光这样是不行的，因为默认情况下Player是没有启动物理模拟的，我们需要启用Player的细节面板/Physics/Simulate Physics选项，并且将调节Player的细节面板/Linear Damping(线性摩檫)和Player的细节面板/Angular Damping(旋转摩檫)到适当的值，应为UE4默认是没有旋转摩檫的并且，默认线性摩檫为0.01。</p><h2 id="小知识"><a href="#小知识" class="headerlink" title=" 小知识"></a><font color="Green"> 小知识</font></h2><ul><li><font color="green"> 大多数时候我们都需要勾选作用力函数组件的Acel Change选项，如：上面的Add Torque in Radians，勾选了Acel Change选项作用力组件会在作用目标物体时忽略物体的质量因素，因为存在质量影响的话，我们可能需要给一个极大的力才能推动目标物体；</font></li><li><font color="green"> 有时可能默认大小的作用力对目标物体的移动作用达不到我们理想的效果，此时可以先将作用力加倍后在传递给作用力组件，蓝图脚本组件集中提供多种多样的乘积组件，我们上面使用的是float*float组件</font>；</li></ul><h1 id="十五、触发器"><a href="#十五、触发器" class="headerlink" title="十五、触发器"></a>十五、触发器</h1><p>在游戏设计中触发器的使用是非常平凡的，而在蓝图中触发器的实现也并不复杂，我们来看一下具体操作：</p><h2 id="1-创建触发器"><a href="#1-创建触发器" class="headerlink" title="1.创建触发器"></a>1.创建触发器</h2><ul><li>蓝图模式中游戏的一切都是蓝图，触发器也不例外，所以要做一个触发器，首先我们的创建一个蓝图的壳子，并继承自Actor类</li><li>触发器还需要一个极为重要的东西就是碰撞体，当然这里的碰撞体不是具有物理碰撞的网格碰撞体，而是蓝图的物理组件集中的Box Collison，一个没有物理碰撞效果专门用于触发器的盒碰撞体，我们给蓝图类添加这个组件，一个触发器便完成了</li></ul><h2 id="2-使用触发器"><a href="#2-使用触发器" class="headerlink" title="2.使用触发器"></a>2.使用触发器</h2><p>当触发器放置于场景中，有物体进入触发器碰撞盒时，触发器便会出自动发触发Event ActorBeginOverlap时间组件，之后我们便可以进行一系列逻辑操作了。</p><h1 id="十六、蓝图类的通信"><a href="#十六、蓝图类的通信" class="headerlink" title="十六、蓝图类的通信"></a>十六、蓝图类的通信</h1><h2 id="1-使用引用进行通信"><a href="#1-使用引用进行通信" class="headerlink" title="1.使用引用进行通信"></a>1.使用引用进行通信</h2><p>两个蓝图类要想通过引用进行通信，那么其中一个蓝图类就必须拥有另一个蓝图类的引用，如何获取一个蓝图类的引用呢？</p><p>在My Blueprint/Variables栏中添加一个所需要引用的蓝图类类型的变量，勾选它的Details/Variable/Instance Editable选项，就可以在这个蓝图类的实例的Details/Default栏中看到引用变量(如果不勾选是没有default栏的)，如此便可以方便的获取另一个蓝图类的实例的引用了。</p><p>通过引用两个蓝图类之间便可以进行单向的信息传递了。即拥有引用的蓝图类可以获取所引用蓝图的传递过来的信息，反向则不行。</p><h2 id="2-使用接口进行通信"><a href="#2-使用接口进行通信" class="headerlink" title="2.使用接口进行通信"></a>2.使用接口进行通信</h2><p>使用接口进行通信的好处是可以很便利的通过同一事件让各种不同的蓝图做出不同的反应，如：当受到子弹攻击时，墙会反弹子弹，人会受伤，通过接口通信来实现这个效果就是，创建一个受到子弹攻击的接口OnTakeAttack，然后分别让墙和人都继承这个接口并实现不同的效果，如此当受到子弹攻击时，我们便可以通过Get All Actor with Interface来调用实现这些接口的Actor来做出各自的反应。</p><p>接口的实现与使用请阅读目录：九、接口。</p><h2 id="3-使用事件调度器通信"><a href="#3-使用事件调度器通信" class="headerlink" title="3.使用事件调度器通信"></a>3.使用事件调度器通信</h2><p>事件调度器的通信过程是一个调度者与一个或多个被调度者之间的通信过程，类似观察者模式的通信过程。</p><h3 id="创建事件调度器"><a href="#创建事件调度器" class="headerlink" title="创建事件调度器"></a>创建事件调度器</h3><p>使用事件调度器来进行蓝图通信，首先我们需要拥有一个事件调度器；</p><p>事件调度器只能被拥有者调用，所以我们需要在调度者蓝图上创建事件调度器，在My Blueprint/Event Dispatchers栏可以新建一个蓝图调度器，此时这个蓝图便拥有了一个事件调度器，我们可以通过拖拽事件调度器到脚本编辑视图或直接在All Actions for this Blueprint中搜索，可以对事件调度器进行事件绑定(Bind)、事件解绑(Unbind)、解绑全部事件(Unbind all)，直接为事件调度器绑定新事件(Assign)和调用事件调度器(Call)。当一个事件调度器被调用后，与这个事件调度器绑定的事件都会被调用，一次来达到信息传递的目的。</p><h3 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h3><p>调度者要事件调度器调用被调度者的事件，那么被调度者就需要向调度者的事件调度器上绑定事件，通过Bind Event to [事件调度器名]组件来绑定事件到事件调度器上。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224533.png"></p><p>Target：输入事件调度器的拥有者对象</p><p>Event：需要绑定的事件</p><p>如此一个基于事件调度器的通信机制便完成了。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【MyQSL】存储过程</title>
    <link href="/2019/10/21/%E3%80%90MyQSL%E3%80%91MyQSL%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    <url>/2019/10/21/%E3%80%90MyQSL%E3%80%91MyQSL%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="1-什么是存储过程"><a href="#1-什么是存储过程" class="headerlink" title="1.什么是存储过程"></a>1.什么是存储过程</h1><p>数据库中的存储过程有点类似编程中的函数，可以供外部环境在需要时调用，并且存储过程只需要编译一次，之后再用则无需进行在此编译。</p><h1 id="2-存储过程的创建"><a href="#2-存储过程的创建" class="headerlink" title="2.存储过程的创建"></a>2.存储过程的创建</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">delimiter &#x2F;&#x2F;<br>create procedure Test(in parameter01 int,out parameter02 varchar(45));<br>begin<br>-- 存储逻辑<br>end<br>&#x2F;&#x2F;<br>delimiter ;<br></code></pre></td></tr></table></figure><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li><strong>delimiter //</strong>:更改MySQL中语句分隔符<code>;</code>，目的就是为了将存储过程作为一个整体，使MySQL中的存储逻辑中的<code>;</code>在代码编辑阶段不被编译器识别，<code>//</code>标识在两个<code>//</code>中间的逻辑为存储逻辑，告知MySQL其中的<code>;</code>不需要解释；<font color="red"> 但是要记住，在用完<code>//</code>这个之后要记得将分隔符转回<code>;</code>,否则之后的语句也会使用<code>//</code>作为分隔符</font>。其中<code>//</code>可以是任意字符或字符串。</li><li><strong>create procedure Test(in parameter01 int , out parameter02 vachar(45))</strong>:创建一个存储过程Test，存储过程包含输入参数parameter01和输出参数parameter02，其中<code>in</code>标识输入参数，<code>out</code>标识输出参数，如果括号中不写标识in/out则默认为输入参数，其中输入参数只能用于从外界传入参数，输出参数只能用于返回结果，类似编程中的返回值。MySQL中也提供<code>inout</code>类型的参数，既可以作为输入参数使用也可以作为输出参数使用，但是不建议这么用，比较好的用法还是输入输出分开。</li><li><strong>begin end</strong>:<code>begin end</code>用来标识一个语句块，必须承兑出现，可以用在任何地方，在存储过程中逻辑写在<code>begin end</code>块内。</li></ul><h1 id="3-存储过程的使用"><a href="#3-存储过程的使用" class="headerlink" title="3.存储过程的使用"></a>3.存储过程的使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">call Test(1,@out_parameter);<br></code></pre></td></tr></table></figure><p>存储过程的使用就如同函数调用一般，传入输入参数，并使用使用变量来接收输出参数。<code>@out_parameter</code>就是用来接收输出参数的变量。</p><h1 id="4-存储逻辑"><a href="#4-存储逻辑" class="headerlink" title="4.存储逻辑"></a>4.存储逻辑</h1><p>在编写存储过程时逻辑判断语句是一定会用到的，下面列举一些常用的逻辑判断语句及其用法。</p><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>MySQL中单独的if语句和程序编程中有所不同，单独的if语句一般嵌入其他语句中一起用，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select if(exc,&#39;A&#39;,&#39;B&#39;);<br></code></pre></td></tr></table></figure><p>当exc的值为true时，输出A，否则输出B，exc可以是一个变量也可以是是一个语句，同理A，B也可以是一个变量或是一个语句。</p><h2 id="if-esle语句"><a href="#if-esle语句" class="headerlink" title="if esle语句"></a>if esle语句</h2><p>if esle语句与esle则有极大的不同，if else语句更接近编程中if esle</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">if exc1 then<br> -- 执行逻辑1;<br>elseif exc2 then<br>-- 执行逻辑2;<br>else<br>-- 执行逻辑3;<br>end if;<br></code></pre></td></tr></table></figure><p>每一个if/elseif之后都需要跟一个then才能写执行逻辑，需要注意的是，then和执行逻辑之间没有<code>;</code>分隔。if语句结束时需要使用 end if;来告知MySQLif判断语句结束。同单独的if语句一样，if else中的exc也可以是变量和语句。</p><h2 id="循环体"><a href="#循环体" class="headerlink" title="循环体"></a>循环体</h2><p>MySQL的循环体使用游标来实现，具体的我们先看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs mysql">delimiter &#x2F;&#x2F;<br>-- 使用断面名删除断面的时间戳数据，此存储过程不允许删除断面<br>create procedure DeleteSurfaceDataByName(<br>in in_surface_name varchar(32),<br>in in_time_point_start varchar(32),<br>in in_time_point_end varchar(32),<br>out run_state bool<br>)<br>begin<br>-- 判断断面是否合法<br>    if exists (select surface_no from surface_number where surface_name &#x3D; in_surface_name) then<br>    begin<br>declare num varchar(32) default null;<br>-- 游标的结束标志<br>declare done bool default false;<br>        -- 为主键id创建游标<br>declare cur cursor for select id from surface_data where surface_name &#x3D; in_surface_name;<br>        -- 将结束标志关联到游标<br>        declare continue handler for not found set done &#x3D; true;<br>        -- 打开游标<br>        open cur;<br>        -- 创建循环过程<br>        delete_loop:loop<br>        -- 从游标结果集中取值到num<br>        fetch next from cur into num;<br>-- 游标后移<br>        if done then<br>leave delete_loop;<br>end if;<br>        -- 循环语句<br>        begin<br>-- 场景1-删除当前段面中某一时段的水文数据<br>if in_time_point_start is not null and in_time_point_end is not null then<br>delete from surface_data where id &#x3D; num and ascii(time_point) &gt;&#x3D; ascii(in_time_point_start) <br>and ascii(time_point) &lt;&#x3D; ascii(in_time_point_end);<br>-- 场景2-删除当前断面中某一时刻的水文数据<br>elseif in_time_point_start is not null and in_time_point_end is null then<br>delete from surface_data where id &#x3D; num and time_point &#x3D; in_time_point_start;<br>end if;<br>end;<br>        -- 结束循环<br>        end loop;<br>        set run_state &#x3D; true;<br>end;<br>else<br>set run_state &#x3D; false;<br>end if;<br>end<br>&#x2F;&#x2F;<br>delimiter ;<br></code></pre></td></tr></table></figure><ul><li><strong>exists()</strong>:和select搭配可以判断满足where条件的selete字段在from的表中是否存在</li><li><strong>declare cur cursor for</strong>:和select语句搭配可以为select出来的结果集创建一个游标cur，而这个游标便是循环体的关键，游标就有点类似SLT中迭代器，可以逐一读取结果集中的数据。</li><li><strong>declare continue handler for not found set done = true</strong>：光有游标还是无法实现循环体的，循环体还有一个很重要的标志–结束标志，这条语句便是为游标设置循环结束标志，这条语句和前面的<code>declare done bool default false;</code>搭配使用，done便是循环结束的标志，通过这条语句将游标和循环结束标志绑定起来。</li><li><strong>open cur</strong>：上面仅仅是做好了使用循环体的前提，要想使用循环体还需要将游标打开，以便游标可以使用，open cur便是打开游标cur。</li><li><strong>delete_loop:loop</strong>:这是真正的循环体的开始，开始一个循环题delete_loop,同时需要使用<code>end loop;</code>来标识循环题结束。</li><li><strong>fetch next from cur into num</strong>:向游标cur指向的结果几种逐一读取数据到num变量中，这里要值意num变量和结果集中的数据类型要一至。</li><li>**if done then leave delete_loop end if;**：判断结束标志done，如果done等于true就继续执行循环体。</li><li>在if done then leave delete_loop end if;和end loop之间的就是每次循环执行的语句了。</li></ul><p>至此整个循环语句结束。</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【待解决】一些待解决的难题</title>
    <link href="/2019/10/10/%E3%80%90%E5%BE%85%E8%A7%A3%E5%86%B3%E3%80%91%E4%B8%80%E4%BA%9B%E5%BE%85%E8%A7%A3%E5%86%B3%E7%9A%84%E9%9A%BE%E9%A2%98/"/>
    <url>/2019/10/10/%E3%80%90%E5%BE%85%E8%A7%A3%E5%86%B3%E3%80%91%E4%B8%80%E4%BA%9B%E5%BE%85%E8%A7%A3%E5%86%B3%E7%9A%84%E9%9A%BE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>这里记录一些待解决的程序难题</p><h1 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h1><p>1.这两种内存分配的方式，有什么不一样，<br>2.初始化的s最后结果有什么不一样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">a</span> &#123;</span><br><span class="hljs-keyword">int</span> id;<br><span class="hljs-built_in">string</span> s;<br>&#125;;<br>a *ptr1 = <span class="hljs-keyword">new</span> a();<br>ptr1-&gt;s = <span class="hljs-string">&quot;hello&quot;</span>;<br>a *ptr2 = (a*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(a));<br>ptr2-&gt;s = <span class="hljs-string">&quot;hello&quot;</span>;<span class="hljs-comment">//这一句却会报异常，为什么？</span><br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h1><p>List容器中empty()判空和size()==0判空有什么不同</p><h1 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h1><p>为什么函数外的指针的值没有变化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getmemory</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *p)</span></span><br><span class="hljs-function"></span>&#123;<br>p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">100</span>];<br>strcpy_s(p,<span class="hljs-number">12</span>, <span class="hljs-string">&quot;hello world&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, p);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">char</span> *p = <span class="hljs-literal">NULL</span>;<br>getmemory(p);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, p);<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>而下面代码却可以改变</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getmemory</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **p)</span></span><br><span class="hljs-function"></span>&#123;<br>*p = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>);<br>strcpy_s(*p, <span class="hljs-number">12</span>,<span class="hljs-string">&quot;hello world&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, *p);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">char</span> *p = <span class="hljs-literal">NULL</span>;<br>getmemory(&amp;p);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, p);<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h1><p>UE4热加载</p><h1 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h1><p>UE4 delegate，UScriptStruct，UProperty</p><h1 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h1><p>寻路算法</p>]]></content>
    
    
    <categories>
      
      <category>待解决</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程序问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C++】C++中的四种个智能指针.md</title>
    <link href="/2019/10/08/%E3%80%90C++%E3%80%91C++%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E4%B8%AA%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/2019/10/08/%E3%80%90C++%E3%80%91C++%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E4%B8%AA%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>智能指针的出现的目的就是为了解决c++中出现异常安全资源管理问题，智能指针的实现原理是依据RAII机制(Resource Acquisition Is Initialization)，这是的智能指针本质上是一个对象，行为表现上是一个指针。</p><p>智能指针都是类模板使用时是必须指定类型参数的，如：<code>auto_ptr&lt;int&gt; ptr</code></p><h1 id="1-auto-ptr"><a href="#1-auto-ptr" class="headerlink" title="1.auto_ptr"></a>1.auto_ptr</h1><ul><li>auto_ptr采用所有权的模式，指针内不做引用计数，因此一个对象只能由一个auto_ptr指针所拥有，在给其他auto_ptr指针赋值时，所有权会转移</li><li>auto_ptr中使用delete来释放资源，所以auto_ptr不能指向数组，因为数组的释放使用的是delete[]</li><li>auto_ptr指针的判空使用auto_ptr.get()==NULL来判断</li></ul><p>auto_ptr是C++98中的标准，在C++11中已经被弃用。</p><p>auto_ptr由于是所有权模式，所在在auto_ptr做参数时，会转移所有权，即将函数外的auto_ptr的所有权转义给函数内的auto_ptr的所有权，如果函数内不做所有权转移的话，函数外的auto_ptr将变为空指针，而导致引用出错。如：</p><p><strong>不转移所有权</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test</span><span class="hljs-params">(<span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; apt)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; *apt &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> apt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function"><span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">1</span>))</span></span>;<br>Test(ptr);<br><span class="hljs-keyword">if</span> (ptr.get() == <span class="hljs-literal">NULL</span>)<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;NULL&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;NO NULL&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">1</span><br><span class="hljs-literal">NULL</span><br></code></pre></td></tr></table></figure><p><strong>转移所有权</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">Test</span><span class="hljs-params">(<span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; apt)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; *apt &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> apt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function"><span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">1</span>))</span></span>;<br>ptr = Test(ptr);<br><span class="hljs-keyword">if</span> (ptr.get() == <span class="hljs-literal">NULL</span>)<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;NULL&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;NO NULL&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">1</span><br><span class="hljs-literal">NO</span> <span class="hljs-literal">NULL</span><br></code></pre></td></tr></table></figure><h1 id="2-unique-ptr"><a href="#2-unique-ptr" class="headerlink" title="2.unique_ptr"></a>2.unique_ptr</h1><ul><li><p>unique_ptr是C++11中对C++98中的auto_ptr的替换与强化</p></li><li><p>unique_ptr也是使用独占所有权模式，即一个unique_ptr指针指向一个对象后，不可以在把这个对象赋予给另一个unique_ptr指针，后来出于一些考虑C++又提供了srd::move()函数来做所有权的移交，被移交所有权的unique_ptr指针会指向空，这时再使用这个指针就会报错</p></li><li><p>unique_ptr指针支持直接使用==判空，如：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; ptr;<br><span class="hljs-keyword">if</span>(ptr == <span class="hljs-literal">NULL</span>)<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;NULL&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure><p>当然unique_ptr依旧支持unique_ptr.get()==NULL来判空。</p><ul><li>当unique_ptr作为实参进行传递时，必须使用std::move()来移交所有权，这是unique_ptr的独占所有权性质决定的。如：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test</span><span class="hljs-params">(<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; apt)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; *apt &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function"><span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">1</span>))</span></span>;<br><span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; pt = move(ptr);<br>Test(<span class="hljs-built_in">std</span>::move(ptr));<br><span class="hljs-keyword">if</span> (ptr == <span class="hljs-literal">NULL</span>)<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;NULL&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;NO NULL&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-shared-ptr"><a href="#3-shared-ptr" class="headerlink" title="3.shared_ptr"></a>3.shared_ptr</h1><ul><li><p>shared_ptr指针支持一个对象被多个指针指向</p></li><li><p>shared_ptr使用计数机制来记录对象被多少个shared_ptr指针所指向，可以使用share_ptr.reset()函数来释放当前指针，对象的引用计数减一，当引用计数减为0时，释放对象资源</p></li><li><p>可以使用shared_ptr.use_count()来获取当前对象的引用计数</p></li></ul><p>我们来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test</span><span class="hljs-params">(<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; ptr)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;count_1:&quot;</span>&lt;&lt; ptr.use_count() &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">1</span>))</span></span>;<br><span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; pt = ptr;<br>Test(ptr);<br>pt.reset();<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;count_2:&quot;</span>&lt;&lt; ptr.use_count() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">if</span> (ptr == <span class="hljs-literal">NULL</span>)<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;NULL&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;NO NULL&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">count_1:3</span><br><span class="hljs-string">count_2:1</span><br><span class="hljs-literal">NO</span> <span class="hljs-literal">NULL</span><br></code></pre></td></tr></table></figure><p>咦！为什么引用计数count_1是3呢？这是因为在函数内形参<code>shared_ptr&lt;int&gt; ptr</code>也指向了同一个对象。而当函数Test结束形参指针释放，同时又使用reset()函数释放pt指针，所以count_2:1</p><h1 id="4-weak-ptr"><a href="#4-weak-ptr" class="headerlink" title="4.weak_ptr"></a>4.weak_ptr</h1><p>虽然shared_ptr使用起来更接近C的原生指针，但是当shared_ptr指针作为类成员时，可能会出现互相引用的而形成死锁，导致引用计数永远无法将为0的现象，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">shared_ptr</span>&lt;B&gt; pa;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">shared_ptr</span>&lt;A&gt; pb;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;A&gt; <span class="hljs-title">pa</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br><span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;B&gt; <span class="hljs-title">pb</span><span class="hljs-params">(<span class="hljs-keyword">new</span> B())</span></span>;<br>pa-&gt;pa = pb;<br>pb-&gt;pb = pa;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种情况是，pa是指向A类型的shared_ptr指针指向A类型对象，而pa指向的内存里面又有一个shared_ptr指针指向B类型对象，同理pb也是如此，这样就导致，当A要被释放时，要先释放B，而B要释放时又要先释放A，如此便形成了一个互相等待的死循环。weak_ptr的存在就是为了解决这种问题。</p><p>weak_ptr指针是一种弱引用，它指向对象和释放时不会引起引用计数的变化，这样便可以打破shared_ptr的这种死循环了，我们将上面的代码改成如下，就可以解死循环了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>weak_ptr&lt;B&gt; pa;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">shared_ptr</span>&lt;A&gt; pb;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;A&gt; <span class="hljs-title">pa</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br><span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;B&gt; <span class="hljs-title">pb</span><span class="hljs-params">(<span class="hljs-keyword">new</span> B())</span></span>;<br>pa-&gt;pa = pb;<br>pb-&gt;pb = pa;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPlus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法】一些牛逼轰轰的算法记录</title>
    <link href="/2019/10/08/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%B8%80%E4%BA%9B%E7%89%9B%E9%80%BC%E8%BD%B0%E8%BD%B0%E7%9A%84%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/"/>
    <url>/2019/10/08/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%B8%80%E4%BA%9B%E7%89%9B%E9%80%BC%E8%BD%B0%E8%BD%B0%E7%9A%84%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="1-判断点是否在三角形内"><a href="#1-判断点是否在三角形内" class="headerlink" title="1.判断点是否在三角形内"></a>1.判断点是否在三角形内</h1><h2 id="衍生：快速计算三角形面积"><a href="#衍生：快速计算三角形面积" class="headerlink" title="衍生：快速计算三角形面积"></a>衍生：快速计算三角形面积</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> S_FLOAT 0.00000001</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-comment">//点类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">float</span> x;<br><span class="hljs-keyword">float</span> y;<br>Point() &#123;&#125;<br>Point(<span class="hljs-keyword">float</span> x,<span class="hljs-keyword">float</span> y)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;x = x;<br><span class="hljs-keyword">this</span>-&gt;y = y;<br>&#125;<br>&#125;;<br><span class="hljs-comment">//计算三角形面积</span><br><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetTriangleSquar</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Point a, <span class="hljs-keyword">const</span> Point b, <span class="hljs-keyword">const</span> Point c)</span></span><br><span class="hljs-function"></span>&#123;<br>Point AB, BC;<br>AB.x = b.x - a.x;<br>AB.y = b.y - a.y;<br>BC.x = c.x - b.x;<br>BC.y = c.y - b.y;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">fabs</span>(AB.x*BC.y - AB.y*BC.x) / <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">//判断点是否在三角形内</span><br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">IsInTriang</span><span class="hljs-params">(Point a, Point b, Point c, Point d)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">float</span> Sabc, Sabd, Sacd, Sbcd;<br>Sabc = GetTriangleSquar(a, b, c);<br>Sabd = GetTriangleSquar(a, b, d);<br>Sacd = GetTriangleSquar(a, c, d);<br>Sbcd = GetTriangleSquar(b, c, d);<br><span class="hljs-keyword">float</span> Sums = Sabd + Sacd + Sbcd;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Sabd:&quot;</span> &lt;&lt; Sabd &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; <span class="hljs-string">&quot;Sacd:&quot;</span> &lt;&lt; Sacd &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; <span class="hljs-string">&quot;Sbcd:&quot;</span> &lt;&lt; Sbcd &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt; <span class="hljs-string">&quot;Sabc:&quot;</span>&lt;&lt;Sabc&lt;&lt;<span class="hljs-built_in">endl</span>&lt;&lt;<span class="hljs-string">&quot;Sums:&quot;</span>&lt;&lt;Sums &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">if</span> ((-S_FLOAT &lt; (Sabc - Sums) &amp;&amp; (Sabc - Sums) &lt; S_FLOAT))<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Yes&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;No&quot;</span>;<br>&#125;<br><span class="hljs-comment">//测试函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Point a(2, 2), b(0, 0), c(4, 0), d(2, 1);<br><span class="hljs-built_in">cout</span> &lt;&lt; IsInTriang(a, b, c, d) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Test();<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-PNPoly算法-判断点是否在多边形内"><a href="#2-PNPoly算法-判断点是否在多边形内" class="headerlink" title="2.PNPoly算法-判断点是否在多边形内"></a>2.PNPoly算法-判断点是否在多边形内</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">PointInPolygon</span><span class="hljs-params">(Point point, Polygon polygon)</span> </span>&#123;<br>  <span class="hljs-built_in">vector</span>&lt;Point&gt; points = polygon.getPoints();<br>  <span class="hljs-keyword">int</span> i, j, nvert = points.size();<br>  <span class="hljs-keyword">bool</span> c = <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>, j = nvert - <span class="hljs-number">1</span>; i &lt; nvert; j = i++) &#123;<br>    <span class="hljs-keyword">if</span>( ( (points[i].y &gt;= point.y ) != (points[j].y &gt;= point.y) ) &amp;&amp;<br>        (point.x &lt;= (points[j].x - points[i].x) * (point.y - points[i].y) / (points[j].y - points[i].y) + points[i].x)<br>      )<br>      c = !c;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C++】C++STL标准模板库</title>
    <link href="/2019/10/06/%E3%80%90C++%E3%80%91C++STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/"/>
    <url>/2019/10/06/%E3%80%90C++%E3%80%91C++STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="一、STL的基本概念"><a href="#一、STL的基本概念" class="headerlink" title="一、STL的基本概念"></a>一、STL的基本概念</h1><h2 id="1-什么是STL"><a href="#1-什么是STL" class="headerlink" title="1.什么是STL"></a>1.什么是STL</h2><p> STL (Standard Template Librany）标准准模板庠是惠普实验室开发的一系列软件的统称。现在主要出现在C++中，但在被引入C++之前该技木就已存在了很长一段吋间了。</p><p>STL的从广义上讲分为三类: algorithm (算法)、container (容器)和iterator (迭代器)，容器和算法通过迭代器可以进行无缝链接。几乎所有的代码都釆用了模板类和模板函数的方式,这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。在C++标准中，STL 被组织为下面的13个尖文件:<code>&lt;algorithm&gt;</code>、<code>&lt;deque&gt;</code>、<code>&lt;functional&gt;</code>、<code>&lt;iterator&gt;</code>、<code>&lt;vector&gt;</code>、<code>&lt;list&gt;</code>、 <code>&lt;map&gt;</code>、<code>&lt;memory&gt;</code>、<code>&lt;numerio&gt;</code>、<code>&lt;queue&gt;</code>、<code>&lt;set&gt;</code>、    <code>&lt;stack&gt;</code> 和<code>&lt;utility&gt;</code>。</p><p><img src="/2019/10/06/%E3%80%90C++%E3%80%91C++STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/Snipaste_2019-10-06_10-41-56.png"></p><p>我们详细的说六大组件：</p><ul><li>容器(Container)</li><li>算法(Algorithm)</li><li>迭代器(Iterator)</li><li>仿函数(Function object)</li><li>适配器(Adaptor)</li><li>空间配置器(allocator)</li></ul><h2 id="2-STL的好处"><a href="#2-STL的好处" class="headerlink" title="2.STL的好处"></a>2.STL的好处</h2><ul><li><p>STL是C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。</p></li><li><p>STL的一个重要特点是数据结构和算法的分离。尽管这是个简单的概念，但是这种分离确实使得STL变得非常通用。<br>例如，在STL 的vector容器中，可以放入元素、 基础数据类型变量、元素的地址;<br>STL的sort()函数可以用来操作vector,list等容器。</p></li><li><p>程序员可以不用思考STL具体的实现过程，只要能够熟综使用STL就OK了。这样他们就可以把精力放在程序开发的别的方面。</p></li><li><p>STL 具有高可重用性，高性能，高移植性，跨平台的优点。</p><p>  高可重用性: STL 中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。关于模板的知识，已经给大家介绍了。</p><p>高性能:如map可以高效地从十万条记录里面查找出指定的记录，因为map是采用红黑树的变体实现的。</p><p>高移植性:如在项目A上用STL编写的模块，可以直接移植到项目B上。</p><p>跨平台:如用windows的Visual Studio编写的代码可以在Mac OS的XCode上直接运行。</p></li><li><p>了解到STL的这些好处，我们知道STL无疑是最值得C++程序员骄傲的一部分。每一个C++程序员都应该好好学习STL.只有能够熟练使用STL的程序员，才是好的C++程序员。</p></li></ul><h1 id="二、容器"><a href="#二、容器" class="headerlink" title="二、容器"></a>二、容器</h1><h2 id="1-容器"><a href="#1-容器" class="headerlink" title="1.容器"></a>1.容器</h2><p>  在实际的开发过程中，数据结构本身的重要性不会逊于操作于数据结构的算法的重要性，当程序中存在着对时间要求很高的部分时，数据结构的选择就显得更加重要。</p><p>  经典的数据结构数量有限，但是我们常常重复着一些为了实现向量、链表等结构而编写的代码，这些代码都十分相似，只是为了适应不同数据的变化而在细节上有所出入。STL容器就为我们提供了这样的方便，它允许我们重复利用己有的实现构造自己的特定类型下的数据结构，通过设置-些模板，STL 容器对最常用的数据结构提供了支持，这些模板的参数允许我们指定容器中元素的数据类型，可以将我们许多重复而乏味的工作简化。</p><p>​    容器部分主要由头文件<code>&lt;vector&gt;</code>, <code>&lt;list&gt;</code>, <code>&lt;deque&gt;</code>, <code>&lt;set&gt;</code>, <code>&lt;map&gt;</code>, <code>&lt;stack&gt;</code>和<code>&lt;queue&gt;</code>组成。对于常用的一些容器和容器适配器(可以看作由其它容器实现的容器)，可以通过下表总结一:下它们和相应头文件的对应关系。</p><p><img src="/2019/10/06/%E3%80%90C++%E3%80%91C++STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/Snipaste_2019-10-06_10-41-56.png"></p><h2 id="2-容器的分类"><a href="#2-容器的分类" class="headerlink" title="2.容器的分类"></a>2.容器的分类</h2><h3 id="序列式容器-Sequence-containers"><a href="#序列式容器-Sequence-containers" class="headerlink" title="序列式容器(Sequence containers)"></a>序列式容器(Sequence containers)</h3><p>每个元素都有固定位置–取决于插入时机和地点，和元素值无关。如：vector、deque、 Iist。</p><h3 id="关联式容器-Associated-containers"><a href="#关联式容器-Associated-containers" class="headerlink" title="关联式容器(Associated containers)"></a>关联式容器(Associated containers)</h3><p>元素位置取决于特定的排序准则，和插入顺序无关。如：sset、multiset、 map、multimapu。</p><p><img src="/2019/10/06/%E3%80%90C++%E3%80%91C++STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/Snipaste_2019-10-06_14-36-13.png"></p><h2 id="3-string类"><a href="#3-string类" class="headerlink" title="3.string类"></a>3.string类</h2><h3 id="string类的本质"><a href="#string类的本质" class="headerlink" title="string类的本质"></a>string类的本质</h3><p><code>string</code>类本质上其实就是<code>char*</code>的容器，是<code>cahr*</code>的封装。</p><h3 id="string类的遍历"><a href="#string类的遍历" class="headerlink" title="string类的遍历"></a>string类的遍历</h3><p><strong>使用[]遍历：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;string_str&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length(); i++)<br><span class="hljs-built_in">cout</span> &lt;&lt; str[i];<br></code></pre></td></tr></table></figure><p><strong>使用迭代器遍历：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;string_str&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">string</span>::iteratori=str.begin();i&lt;str.end();i++)<br><span class="hljs-built_in">cout</span> &lt;&lt;*i;<br></code></pre></td></tr></table></figure><p><font color="red"> 注意这里的<code>i</code>是一个指向string::iterator类型的指针。</font></p><p><strong>使用at()遍历：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;string_str&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length(); i++)<br><span class="hljs-built_in">cout</span> &lt;&lt; str.at(i);<br></code></pre></td></tr></table></figure><p><code>at()</code>与<code>[]</code>不同的是，当访问发生越界等错误时，<code>at()</code>会自动抛出异常，而<code>[]</code>不会抛出异常而中断程序。</p><h3 id="string解封成char"><a href="#string解封成char" class="headerlink" title="string解封成char*"></a>string解封成char*</h3><p>C++为string类提供了一个专门的函数<font color="red"> <strong>str.c_str()</strong></font>，str是string类型的对象，但是需要注意的是<code>str.c_str()</code>返回的是一个<font color="red"> const char*</font>，不能再被赋值给其他非常量指针，但是我们可以直接将<code>str.c_str()</code>当作<code>char*</code>来使用，如：<code>str.c_str()[1]</code>，即通过<code>char*</code>指针访问str中的第二个元素。</p><h3 id="string类中一些常用函数"><a href="#string类中一些常用函数" class="headerlink" title="string类中一些常用函数"></a>string类中一些常用函数</h3><table><thead><tr><th></th><th>函数名</th><th>作用</th></tr></thead><tbody><tr><td>复制</td><td>str.copy(char *buf,int cout)</td><td>从字符串str中拷贝cout个字符到char数组buf中</td></tr><tr><td>连接</td><td>str.append(string strs)</td><td>将字符串strs连接到str之后，支持string和char*</td></tr><tr><td>查找</td><td>int str.find(char *strs,int index)</td><td>从字符串str中的第index索引开始查找strs子串或字符，返回查找到的第一个匹配值的索引，返回的索引也可以使用迭代器来接收</td></tr><tr><td>替换</td><td>str.replace(int index,int length,char *strs)</td><td>在字符串str中，从index索引开始用strs字符串替换length个长度的子串</td></tr><tr><td>删除</td><td>str.erase(int index,int length)</td><td>删除字符出str从index位置开始的length长度的字符</td></tr><tr><td>插入</td><td>str.insert(int index,char *strs)</td><td>从str字符串的index位置开始插入字串strs</td></tr></tbody></table><h3 id="string类中常用算法函数"><a href="#string类中常用算法函数" class="headerlink" title="string类中常用算法函数"></a>string类中常用算法函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;string_str_io_stdsfx.h_iostream&quot;</span>;<br>transform(str.begin(), str.end(), str.begin(), <span class="hljs-built_in">toupper</span>);<br><span class="hljs-built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure><p>transform算法包含在<code>#include &lt;algorithm&gt;</code>头文件中</p><p><strong>transform算法的使用：</strong></p><p><strong>原型：</strong>transform(first,last,result,op);</p><p>first是容器的首迭代器，last为容器的末迭代器，result为存放结果的容器，op为要进行操作的一元函数对象或sturct、class。</p><p><strong>代码解释：</strong>str.begin()返回一个指向str首部位置的迭代器，str.end()返回一个指向str尾部位置的迭代器，因为我们把输出结果继续存放在str中，且迭代器始于容器相联系的，所以存放结果的容器也是str.begin()，而我们对str做的操作是将小写字母装换为大写，C++提供了标准的转换函数,所以操作函数为toupper。</p><p><strong>transform算法的另一个重载形式：</strong></p><p><strong>原型：</strong>transform(first1,last1,first2,result,binary_op);</p><p>first1是第一个容器的首迭代 器，last1为第一个容器的末迭代器，first2为第二个容器的首迭代器，result为存放结果的容器，binary_op为要进行操作的二元函数 对象或sturct、class。</p><p>需要注意的是，两个容器first1和first2中的元素数量必须相等，否则会抛异常。</p><h2 id="4-vector容器"><a href="#4-vector容器" class="headerlink" title="4.vector容器"></a>4.vector容器</h2><ul><li>vector是将元素置于一个<font color="red"> <strong>动态数组</strong></font>中加以管理的容器</li><li>vector支持随机存取元素，支持索引存取（[],at()）和迭代器存取</li><li>vector在尾部添加和移除元素速度快，在中部和头部速度慢</li><li>使用vector容易需要包含<code>#include&lt;vector&gt;</code>头文件</li></ul><h3 id="vector常用方法"><a href="#vector常用方法" class="headerlink" title="vector常用方法"></a>vector常用方法</h3><table>  <tr>    <th> </th>    <th>函数</th>    <th>作用</th>  </tr>  <tr>    <td rowspan="4">读取与赋值</td>    <td>front(void)</td>    <td>获取容器首元素，既可以作左值也可以作右值</td>  </tr>  <tr>    <td>back(void)</td>    <td>获取容器尾元素，既可以作左值也可以作右值</td>  </tr>  <tr>    <td>push_back(T t)</td>    <td>在容器的尾部添加元素</td>  </tr>  <tr>    <td>pop_back(T t)</td>    <td>删除容器最后一个元素</td>   </tr>  <tr>    <td rowspan="4">只读</td>    <td>begin(void)</td>    <td>获取容器首部迭代器</td>   </tr>  <tr>    <td>end(void)</td>    <td>获取容器尾部迭代器</td>   </tr>  <tr>    <td>rbegin(void)</td>    <td>获取逆序首部迭代器，实际指向容器的尾部，只能使用vector&#60int&#62::reverse_iterator逆序迭代器接收</td>   </tr>  <tr>    <td>rend(void)</td>    <td>获取逆序尾部部迭代器，实际指向容器的首部，只能使用vector&#60int&#62::reverse_iterator逆序迭代器接收</td>   </tr>  <tr>    <td rowspan="2">删除</td>    <td>erase(iterator pos)</td>    <td>删除迭代器pos指向位置的元素</td>   </tr>  <tr>    <td>erase(iterator begin,iterator end)</td>    <td>从迭代器begin指向位置开始到end指向位置结束，区间删除元素</td>   </tr>  <tr>    <td>插入</td>    <td>insert(iterator pos,T t)</td>    <td>在pos迭代器指向的位置插入元素t，insert中的迭代器pos只能是begin()或end()否则会报错，似乎不止其他的迭代器</td>   </tr>    <td>判空</td>    <td>empty(void)</td>    <td>容器判空</td>   </table>### Vector浅析<p>vector的最重要的实现组成其实只有三个指针，上源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// CLASS TEMPLATE vector</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> _<span class="hljs-title">Ty</span>,<span class="hljs-keyword">class</span> _<span class="hljs-title">Alloc</span> =</span> allocator&lt;_Ty&gt;&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">vector</span> :</span> <span class="hljs-keyword">public</span> _Vector_alloc&lt;_Vec_base_types&lt;_Ty, _Alloc&gt;&gt;<br>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>类体这里就省略了，如果仔细看源码就会发现vector的类体里主要实现的大多只是一些供外部调用的函数而已，而vector的最底层的一些实现其实在它的基类中就已经完成了，如<code>_Vector_alloc</code>类，而<code>_Vector_alloc</code>中也没有包含最重要的三个指针，我们在vector.cpp中搜索<code>_Myfirst</code>可以发现，<code>_Myfirst</code>,<code>_Mylast</code>,<code>_Myend</code>三个指针在<code>_Vector_val</code>这个类中，而<code>_Vector_alloc</code>中包含了对<code>_Vector_val</code>的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// CLASS TEMPLATE _Vector_val</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> _<span class="hljs-title">Val_types</span>&gt;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> _<span class="hljs-title">Vector_val</span> :</span> <span class="hljs-keyword">public</span> _Container_base<br>&#123;<span class="hljs-comment">// base class for vector to hold data</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">using</span> value_type = <span class="hljs-keyword">typename</span> _Val_types::value_type;<br><span class="hljs-keyword">using</span> size_type = <span class="hljs-keyword">typename</span> _Val_types::size_type;<br><span class="hljs-keyword">using</span> difference_type = <span class="hljs-keyword">typename</span> _Val_types::difference_type;<br><span class="hljs-keyword">using</span> pointer = <span class="hljs-keyword">typename</span> _Val_types::pointer;<br><span class="hljs-keyword">using</span> const_pointer = <span class="hljs-keyword">typename</span> _Val_types::const_pointer;<br><span class="hljs-keyword">using</span> reference = value_type&amp;;<br><span class="hljs-keyword">using</span> const_reference = <span class="hljs-keyword">const</span> value_type&amp;;<br><br>_Vector_val()<br>: _Myfirst(),<br>_Mylast(),<br>_Myend()<br>&#123;<span class="hljs-comment">// initialize values</span><br>&#125;<br><br>pointer _Myfirst;<span class="hljs-comment">// pointer to beginning of array</span><br>pointer _Mylast;<span class="hljs-comment">// pointer to current end of sequence</span><br>pointer _Myend;<span class="hljs-comment">// pointer to end of array</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在vector中有两个关键的数字，<font color="red">size与capacity</font>，其中<code>size=_Mylast-_Myfirst</code>，<code>capacity=_Myend-Myfirst</code>，三个指针指向的内存位置如下：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210330094505.png"></p><p>size的计算源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">_NODISCARD size_type <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// return length of sequence</span><br><span class="hljs-keyword">return</span> (<span class="hljs-keyword">static_cast</span>&lt;size_type&gt;(<span class="hljs-keyword">this</span>-&gt;_Mylast() - <span class="hljs-keyword">this</span>-&gt;_Myfirst()));<br>&#125;<br></code></pre></td></tr></table></figure><p>capacity的计算源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">_NODISCARD size_type <span class="hljs-title">capacity</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// return current length of allocated storage</span><br><span class="hljs-keyword">return</span> (<span class="hljs-keyword">static_cast</span>&lt;size_type&gt;(<span class="hljs-keyword">this</span>-&gt;_Myend() - <span class="hljs-keyword">this</span>-&gt;_Myfirst()));<br>&#125;<br></code></pre></td></tr></table></figure><p>我们都知道vector的性能优越，而支撑着vector的优越性能的就是这两数据，size和capacity，size是vector中实际元素的个数，即vector总容量中的已用容量(used部分)，而capacity则是vector初始化时设置的总容量(等于used部分加unsed部分)，C++分配给vector的实际内存总是比定义时的要大一点，这是因为vector占用的内存是一整块连续的内存，预分配多一些内存可以降低vector之后的二次分配时的时间成本。所以capacity&gt;=size，档capacity=size时表示容易已满，若需要继续添加元素则需要整体移动vector，此时花费的成本会较高，所以种情况应尽量避免。</p><h2 id="5-deque容器"><a href="#5-deque容器" class="headerlink" title="5.deque容器"></a>5.deque容器</h2><ul><li>deque容器是一个双端数组，在双端数组的两端均可以插入和删除元素</li><li>使用deque容器需要包头文件<code>#include&lt;deque&gt;</code></li></ul><p>deque容器可以说是vector容器的升级版，deque的用法基本和vector一致，但是deque不仅提供push_back()，pop_back()还提供<font color="red"> <strong>push_front()</strong></font> 和<font color="red"> <strong>pop_front()</strong></font>。</p><h2 id="6-stack容器"><a href="#6-stack容器" class="headerlink" title="6.stack容器"></a>6.stack容器</h2><ul><li>stack容器是一个栈模型</li><li>使用stack容器需要包含头文件<code>#include&lt;stack&gt;</code></li></ul><h3 id="stack常用方法"><a href="#stack常用方法" class="headerlink" title="stack常用方法"></a>stack常用方法</h3><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>push(T t)</td><td>元素入栈顶</td></tr><tr><td>pop()</td><td>栈顶元素出栈</td></tr><tr><td>top()</td><td>获取栈顶元素</td></tr></tbody></table><h2 id="7-queue容器"><a href="#7-queue容器" class="headerlink" title="7.queue容器"></a>7.queue容器</h2><ul><li>queue容器是一个队列模型</li><li>使用queue容器需要包含头文件<code>#include&lt;queue&gt;</code></li></ul><h3 id="queue常用方法"><a href="#queue常用方法" class="headerlink" title="queue常用方法"></a>queue常用方法</h3><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>push(T t)</td><td>元素入队尾</td></tr><tr><td>pop()</td><td>队首元素出队</td></tr><tr><td>front()</td><td>获取队首元素，既可以作左值也可以作右值</td></tr><tr><td>back()</td><td>获取队尾元素，既可以作左值也可以作右值</td></tr></tbody></table><h2 id="8-list容器"><a href="#8-list容器" class="headerlink" title="8.list容器"></a>8.list容器</h2><ul><li>list容器是一个双向链表模型，可以高效的进行元素的插入和删除操作</li><li>list容器不支持随机访问，即不支持[],at()和iterator + n(如：begin()+1)等形式的访问</li><li>使用list容器需要包含头文件<code>#include&lt;list&gt;</code></li></ul><p>list容器除了不支持随机访问外，用法和deque容器的用法基本一致，除此之外list容器还提供一个<font color="red"> <strong>remove(T t)</strong></font>函数来根据元素内容删除元素</p><p>使用list容器时有一点需要注意<font color="red"> <strong>list容器在使用erase删除元素时，遵循左闭右开的原则</strong></font>，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; li;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>li.push_back(i);<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it = li.begin(); it != li.end(); it++)<br><span class="hljs-built_in">cout</span> &lt;&lt; *it;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it1 = li.begin();<span class="hljs-comment">//it1指向元素0</span><br><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it2 = li.begin();<br>it2++; it2++; it2++;<span class="hljs-comment">//此时it2指向元素3</span><br>li.erase(it1, it2);<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it = li.begin(); it != li.end(); it++)<br><span class="hljs-built_in">cout</span> &lt;&lt; *it;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">01234<br>34<br></code></pre></td></tr></table></figure><p>可以看到erase在删除0-3的元素时删除了0，1，2而没有删除3，即左闭右开。</p><h3 id="list浅析"><a href="#list浅析" class="headerlink" title="list浅析"></a>list浅析</h3><p>list在实现结构上和vector很类似，只是list比vector多了一个<code>_List_buy</code>中间层，list的实现的核心组成有两个，<code>_List_val</code>和<code>_List_node</code>前者主要与数据结构规模和头节点相关，后者主要与数据存储、prev和next相关。上<code>_List_val</code>的源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> _<span class="hljs-title">Val_types</span>&gt;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> _<span class="hljs-title">List_val</span> :</span> <span class="hljs-keyword">public</span> _Container_base<br>&#123;<span class="hljs-comment">// base class for list to hold data</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">using</span> _Nodeptr = <span class="hljs-keyword">typename</span> _Val_types::_Nodeptr;<br><br><span class="hljs-keyword">using</span> value_type = <span class="hljs-keyword">typename</span> _Val_types::value_type;<br><span class="hljs-keyword">using</span> size_type = <span class="hljs-keyword">typename</span> _Val_types::size_type;<br><span class="hljs-keyword">using</span> difference_type = <span class="hljs-keyword">typename</span> _Val_types::difference_type;<br><span class="hljs-keyword">using</span> pointer = <span class="hljs-keyword">typename</span> _Val_types::pointer;<br><span class="hljs-keyword">using</span> const_pointer = <span class="hljs-keyword">typename</span> _Val_types::const_pointer;<br><span class="hljs-keyword">using</span> reference = value_type&amp;;<br><span class="hljs-keyword">using</span> const_reference = <span class="hljs-keyword">const</span> value_type&amp;;<br><br>_List_val()<br>: _Myhead(),<br>_Mysize(<span class="hljs-number">0</span>)<br>&#123;<span class="hljs-comment">// initialize data</span><br>&#125;<br><br>_Nodeptr _Myhead;<span class="hljs-comment">// pointer to head node</span><br>size_type _Mysize;<span class="hljs-comment">// number of elements</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到list中包含了一个指向头节点的指针<code>_Myhead</code>，也就是说即使我们创建的一个空list也至少包含一个空的头节点，list使用头节点的目的就是更方便的构建容器，<code>_Mysize</code>记录的就是list的当前元素个数。</p><p>list节点_List_node`的底层数据结构是一个结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> _<span class="hljs-title">Value_type</span>,<span class="hljs-keyword">class</span> _<span class="hljs-title">Voidptr</span>&gt;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">List_node</span></span><br><span class="hljs-class">&#123;</span><span class="hljs-comment">// list node</span><br><span class="hljs-keyword">using</span> _Nodeptr = _Rebind_pointer_t&lt;_Voidptr, _List_node&gt;;<br>_Nodeptr _Next;<span class="hljs-comment">// successor node, or first element if head</span><br>_Nodeptr _Prev;<span class="hljs-comment">// predecessor node, or last element if head</span><br>_Value_type _Myval;<span class="hljs-comment">// the stored value, unused if head</span><br><br>_List_node&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> _List_node&amp;) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> _<span class="hljs-title">Alloc</span>&gt;</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> _Freenode0(_Alloc&amp; _Al, _Nodeptr _Ptr) <span class="hljs-keyword">noexcept</span><br>&#123;<br><span class="hljs-keyword">using</span> _Alnode = _Rebind_alloc_t&lt;_Alloc, _List_node&gt;;<br><span class="hljs-keyword">using</span> _Alnode_traits = allocator_traits&lt;_Alnode&gt;;<br>_Alnode _Node_alloc(_Al);<br>_Alnode_traits::destroy(_Node_alloc, _STD addressof(_Ptr-&gt;_Next));<br>_Alnode_traits::destroy(_Node_alloc, _STD addressof(_Ptr-&gt;_Prev));<br>_Alnode_traits::deallocate(_Node_alloc, _Ptr, <span class="hljs-number">1</span>);<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>_List_node</code>的核心组成就是<code>_Next</code>，<code>_Prev</code>，<code>_Myval</code>，<code>_Next</code>是下一个节点的指针，<code>_Prev</code>是指向上一个节点的指针，<code>_Myval</code>是存储数据的容器。</p><h2 id="9-priority-queue容器"><a href="#9-priority-queue容器" class="headerlink" title="9.priority_queue容器"></a>9.priority_queue容器</h2><ul><li><p><code>priority_queue</code>容器是一个具有优先级的队列，又叫优先级队列适配器，分为最大优先级队列和最小优先级队列两种</p></li><li><p>priority_queue容器是一种特殊的queue容器，所以也需要包含头文件<code>#include&lt;queue&gt;</code></p></li></ul><p>默认的定义<code>priority_queue&lt;T&gt; pr</code>的优先级队列是最大优先级队列，显示定义最小优先级队列：<code>priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt; pr</code>，<code>less</code>是一个谓词后面再学习，显示定义最大优先级队列：<code>priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; pr</code>，其中使用<code>greater</code>需要包含头文件<code>#include&lt;functional&gt;</code>。</p><p><code>priority_queue</code>容器的用法基本和<code>queue</code>一致，除此之外，<code>priority_queue</code>容器提供一个<code>top()</code>函数来获取队首元素，而<code>queue</code>容器没有这个方法。</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;,greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; pr;<br>pr.push(<span class="hljs-number">12</span>);<br>pr.push(<span class="hljs-number">4</span>);<br>pr.push(<span class="hljs-number">10</span>);<br>pr.push(<span class="hljs-number">20</span>);<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;最小元素：&quot;</span> &lt;&lt;pr.top() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">while</span> (pr.size() &gt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; pr.top() &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>;<br>pr.pop();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">最小元素：<span class="hljs-number">4</span><br><span class="hljs-number">4,10,12,20</span>,<br></code></pre></td></tr></table></figure><h2 id="10-set容器"><a href="#10-set容器" class="headerlink" title="10.set容器"></a>10.set容器</h2><ul><li><code>set</code>是一个<font color="red"><strong>集合</strong></font>容器，其中所包含的元素是<font color="red"><strong>唯一</strong></font>的，<font color="red"><strong>集合中的元素按一定的顺序排序</strong></font>，元素的插入过程是按排序规则插入，所以不能指定位置插入</li><li><code>set</code>采用红黑树变体的数据结构实现，红黑树属于平衡二叉树，在插入和删除操作上比<code>vector</code>容器速度更快</li><li><code>set</code>容器不支持[]和at()来存取元素</li><li><font color="red"><strong>set不支持直接修改容器中的元素</strong></font>，因为元素是自动排序的，如果希望修改一个元素值，就必须删除这个元素再插入新元素</li><li>要使用<code>set</code>容器需要包含头文件<code>#include&lt;set&gt;</code></li></ul><h3 id="set容器的基本特性"><a href="#set容器的基本特性" class="headerlink" title="set容器的基本特性"></a>set容器的基本特性</h3><p>默认情况下，直接定义的set容器采用最小优先排序，和priority_queue容器恰好相反，<code>set&lt;T&gt; se</code>就是隐式的<code>set&lt;T,less&lt;T&gt;&gt; se</code>，定义最大优先排序的set容器需要显示定义：<code>set&lt;T,greater&lt;T&gt;&gt; se</code>。</p><p>我们来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">string</span>,greater&lt;<span class="hljs-built_in">string</span>&gt;&gt; se;<span class="hljs-comment">//采用最大优先排序</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<span class="hljs-comment">//生成随机字符串元素</span><br>&#123;<br><span class="hljs-keyword">int</span> tmp = rand();<br><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">while</span> (str.length()&lt;=<span class="hljs-number">3</span>)<br>&#123;<br><span class="hljs-keyword">if</span>(tmp &gt;= <span class="hljs-number">97</span> &amp;&amp; tmp &lt;= <span class="hljs-number">122</span>)<br>str += tmp;<br>tmp = rand();<br>&#125;<br>se.insert(str);<br>&#125;<br>se.insert(<span class="hljs-string">&quot;strs&quot;</span>);<span class="hljs-comment">//插入相同的字符串元素</span><br>se.insert(<span class="hljs-string">&quot;strs&quot;</span>);<br>se.insert(<span class="hljs-string">&quot;strs&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">string</span>, greater&lt;<span class="hljs-built_in">string</span>&gt;&gt;::iterator it = se.begin(); it != se.end(); it++)<br><span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">wqye</span><br><span class="hljs-symbol">vfep</span><br><span class="hljs-symbol">strs</span><br><span class="hljs-symbol">omsk</span><br><span class="hljs-symbol">kfnm</span><br><span class="hljs-symbol">cdsb</span><br></code></pre></td></tr></table></figure><p>可以看到，容器里的字符串确实按照字符串的比较规则按从大到小的顺序排列着，并且无论我们插入多少个相同的元素，在容器内只会存储一个相同的元素值。</p><p>值得注意的是：</p><p><code>set</code>容器只提供了<code>insert(T t)</code>函数来插入元素。</p><h3 id="自定义元素的排序"><a href="#自定义元素的排序" class="headerlink" title="自定义元素的排序"></a>自定义元素的排序</h3><p>自定义类作元素可能会出现类中有多个字段，而我们需要其中的某一个字段来作为关键字在<code>set</code>容器中排序，要实现这样的行为，我们就需要用到<font color="red"><strong>仿函数</strong></font>了。</p><h4 id="什么是仿函数？"><a href="#什么是仿函数？" class="headerlink" title="什么是仿函数？"></a>什么是仿函数？</h4><p>仿函数实质上就是一个做了<code>()</code>重载的结构体，因为重载了<code>()</code>使用起来类似函数，所以称之为仿函数。</p><p>我们来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">string</span> name;<br><span class="hljs-keyword">int</span> age;<br><span class="hljs-keyword">bool</span> isStudent;<br>Student(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> name, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> age, <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> isStudent)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;age = age;<br><span class="hljs-keyword">this</span>-&gt;name = name;<br><span class="hljs-keyword">this</span>-&gt;isStudent = isStudent;<br>&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AgeSort</span>//仿函数</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Student &amp;lift, <span class="hljs-keyword">const</span> Student &amp;right)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> (lift.age &lt; right.age);<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">set</span>&lt;Student, AgeSort&gt; se;<br><span class="hljs-function">Student <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;Alian&quot;</span>, <span class="hljs-number">23</span>, <span class="hljs-literal">true</span>)</span></span>;<br><span class="hljs-function">Student <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-string">&quot;Blank&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-literal">true</span>)</span></span>;<br><span class="hljs-function">Student <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-string">&quot;Cary&quot;</span>, <span class="hljs-number">43</span>, <span class="hljs-literal">false</span>)</span></span>;<br><span class="hljs-function">Student <span class="hljs-title">s4</span><span class="hljs-params">(<span class="hljs-string">&quot;Davel&quot;</span>, <span class="hljs-number">23</span>, <span class="hljs-literal">true</span>)</span></span>;<br>se.insert(s1); se.insert(s2);<br>se.insert(s3); se.insert(s4);<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">set</span>&lt;Student, AgeSort&gt;::iterator it = se.begin(); it != se.end(); it++)<br><span class="hljs-built_in">cout</span> &lt;&lt; it-&gt;name &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; it-&gt;age &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; it-&gt;isStudent &lt;&lt; <span class="hljs-built_in">endl</span>;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Blank</span>   <span class="hljs-number">20</span>      <span class="hljs-number">1</span><br><span class="hljs-attribute">Alian</span>   <span class="hljs-number">23</span>      <span class="hljs-number">1</span><br><span class="hljs-attribute">Cary</span>    <span class="hljs-number">43</span>      <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>其中<code>AgeSort</code>就是仿函数，它的比较关键字是<code>Student.age</code>，所以<code>set</code>容器对象se会以age作为排序关键字，其实我们之前使用的<code>less&lt;&gt;</code>和<code>greater&lt;&gt;</code>也是反函数，只不过是C++预定义好的仿函数。</p><p>细心的朋友可能会发现，我们插入的s4对象居然不再容器里！！！这是因为set容器中的元素具有唯一性，而set容器是通过关键字来识别元素的，所当碰到关键字相同的元素时，set只会存储一个元素。</p><p>那么这种情况该怎么解决呢？答案是set容器没有办法解决这种情况，如果有出现这种情况，就不能使用set容器而改用multiset容器。</p><p>在后面的算法模块我们详细介绍仿函数。</p><h3 id="set常用函数"><a href="#set常用函数" class="headerlink" title="set常用函数"></a>set常用函数</h3><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>find(T t)</td><td>查找元素t，返回指向t元素的迭代器，查找失败返回指向set.end()的迭代器</td></tr><tr><td>count(T t)</td><td>返回容器中元素t的个数，值要么是0，要么是1</td></tr><tr><td>lower_bound(T t)</td><td>返回一个指向&gt;=t元素的迭代器，如果t存在则指向t，如果t不存在则指向t后面的一个元素</td></tr><tr><td>upper_bound(T t)</td><td>返回一个指向&gt;t元素的迭代器，即t元素后面的一个元素</td></tr><tr><td>equal_range(T t)</td><td>返回一个包含两个set类型的迭代器的对组pair&lt;set<T>::iterator,set<T>::iterator&gt;第一个迭代器指向t元素，第二个迭代器指向t后面的一个元素，如果t不存在，则两个迭代器都指向t后面的一个元素</T></T></td></tr></tbody></table><h3 id="小知识"><a href="#小知识" class="headerlink" title=" 小知识"></a><font color="blue"> 小知识</font></h3><p><font color="blue"> 事实上容器中的<code>insert</code>函数是有返回值的，<code>insert</code>的返回值是一个对组(pair)类型的泛型<code>pair&lt;set&lt;T&gt;::iterator, bool&gt;</code>的对象，<code>pair</code>是一个只有两个字段的模板，我们可以直接定义<code>pair&lt;set&lt;T&gt;::iterator, bool&gt;</code>类型对象来接收<code>insert</code>函数的返回值，如：</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">pair</span>&lt;<span class="hljs-built_in">set</span>&lt;Student,AgeSort&gt;::iterator, <span class="hljs-keyword">bool</span>&gt; pait=se.insert(s1);<br></code></pre></td></tr></table></figure><p><font color="blue"> 我们可以通过<code>pair.first</code>和<code>pair.second</code>来访问对组中的两个元素，通过<code>pair.first</code>来访问对组中的第一个元素<code>set&lt;Student,AgeSort&gt;::iterator</code>类型的迭代器，通过<code>pair.first-&gt;first</code>，和<code>pair.first-&gt;second</code>可以访问迭代器所指向的容器元素，我们通过<code>pair.second</code>来访问对组中的第二个元素，bool型的元素记录的是insert函数插入是否成功，如果插入成功则记录true，否则记录false。</font></p><h2 id="11-multiset容器"><a href="#11-multiset容器" class="headerlink" title="11.multiset容器"></a>11.multiset容器</h2><ul><li><code>multiset</code>容器可以说是set容器的升级版，multiset容器支持多个相同键值的元素的存储，所以要使用<code>multiset</code>需要包含头文件<code>#include&lt;set&gt;</code></li></ul><p>multiset的用法和set一致。</p><h2 id="12-map容器"><a href="#12-map容器" class="headerlink" title="12.map容器"></a>12.map容器</h2><ul><li><code>map</code>是标准的关联式容器，一个<code>map</code>元素是一个键值对(key,value),<code>map</code>提供基于键值的快速检索能力</li><li><code>map</code>中<font color="red"><code> key</code>值是唯一的</font></li><li><code>map</code>容器中的元素也是按一定顺序排列的，元素插入过程是按排序规则插入的，所以不能指定位置插入</li><li><code>map</code>容器的具体实现也是采用红黑二叉树变体的平衡二叉树的数据结构，在插入和删除的操作上比<code>vector</code>更快</li><li>与<code>set</code>不同的是<code>map</code>支持直接存取<code>key</code>值对应的<code>value</code>，也支持[]操作符</li><li>要使用<code>map</code>容器就需要包含头文件<code>#include&lt;map&gt;</code></li></ul><h3 id="map的元素插入"><a href="#map的元素插入" class="headerlink" title="map的元素插入"></a>map的元素插入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>&gt; ma;<br><span class="hljs-comment">//方法一</span><br>ma.insert(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;pair&quot;</span>));<br>ma.insert(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;pair_02&quot;</span>));<br><span class="hljs-comment">//方法二</span><br>ma.insert(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;make_pair&quot;</span>));<br>ma.insert(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;make_pair_02&quot;</span>));<br><span class="hljs-comment">//方法三</span><br>ma.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>&gt;::value_type(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;value_type&quot;</span>));<br>ma.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>&gt;::value_type(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;value_type_02&quot;</span>));<br><span class="hljs-comment">//方法四</span><br>ma[<span class="hljs-number">4</span>] = <span class="hljs-string">&quot;map&quot;</span>;<br>ma[<span class="hljs-number">4</span>] = <span class="hljs-string">&quot;map_02&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>&gt;::iterator it = ma.begin(); it != ma.end(); it++)<br><span class="hljs-built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="hljs-built_in">endl</span>;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>      pair<br><span class="hljs-symbol">2 </span>      make_pair<br><span class="hljs-symbol">3 </span>      value_type<br><span class="hljs-symbol">4 </span>      map_02<br></code></pre></td></tr></table></figure><p>上面四种方法都可以向map容器里添加元素，但是四者中也有一些微小的区别，前面三种方法在插入相同键值时，只会保存第一存储的结果，之后插入相同键值的元素时都会插入失败，而第四种方法则是后面赋值的元素覆盖前面赋值的元素。</p><p>map似乎没办法来指定是从大到小排序或是从小到大排序</p><p>map除了元素的形式不同，在其他方面map的用法基本和set一致</p><h2 id="13-multimap容器"><a href="#13-multimap容器" class="headerlink" title="13.multimap容器"></a>13.multimap容器</h2><p><code>multimap</code>容器和<code>multiset</code>容器一样，是<code>map</code>容器的升级版，支持一个键对应多个值，所以<code>multimap</code>的一个重要应用场景就是数据分组。</p><h2 id="14-容器在使用过程必须要注意的地方"><a href="#14-容器在使用过程必须要注意的地方" class="headerlink" title="14.容器在使用过程必须要注意的地方"></a>14.容器在使用过程必须要注意的地方</h2><p><font color="red"> 因为在将元素添加到容器里时，C++执行的是容器的默认的拷贝构造函数，将元素拷贝到容器里，这个过程是一个浅拷贝，既然是浅拷贝就会面临浅拷贝的两次内存释放的问题，尤其是类元素，所以在添加一些具有指针字段的元素到容器里时，一定在类里定义一个深拷贝的拷贝构造函数和=的重载函数。</font></p><h2 id="15-各个容器的比较"><a href="#15-各个容器的比较" class="headerlink" title="15.各个容器的比较"></a>15.各个容器的比较</h2><table><thead><tr><th></th><th>vector</th><th>deque</th><th>list</th><th>set</th><th>multiset</th><th>map</th><th>multimap</th></tr></thead><tbody><tr><td>内存结构</td><td>单端数组</td><td>双端数组</td><td>双向链表</td><td>二叉树</td><td>二叉树</td><td>二叉树</td><td>二叉树</td></tr><tr><td>随机存取</td><td>是</td><td>是</td><td>否</td><td>否</td><td>否</td><td>对key而言是</td><td>否</td></tr><tr><td>元素检索</td><td>慢</td><td>慢</td><td>非常慢</td><td>快</td><td>快</td><td>对key而言快</td><td>对key而言快</td></tr><tr><td>快速安插移除</td><td>尾端</td><td>头尾两端</td><td>任何位置</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><h1 id="三、算法"><a href="#三、算法" class="headerlink" title="三、算法"></a>三、算法</h1><h2 id="1-算法"><a href="#1-算法" class="headerlink" title="1.算法"></a>1.算法</h2><p>​    函数库对数据类型的选择对其可重用性起着至关重要的作用。举例来说，一个求方根的函数，在使用浮点数作为其参数类型的情况下的可重用性肯定比使用整型作为它的参数类性要高。而C++通过模板的机制允许推迟对某些类型的选择，直到真正想使用模板或者说对模板进行特化的时候，STL就利用了这一点提供了相当多的有用算法。它是在一个有效的框架中完成这些算法的–可以将所有的类型划分为少数的几类，然后就可以在模版的参数中使用一种类型替换掉同一种类中的其他类型。</p><p>  STL提供了大约100个实现算法的模版函数，比如算法for_ each 将为指定序列中的每一个元素调用指定的函数，stable_ _sort 以你所指定的规则对序列进行稳定性排序等等，这样一-来,只要熟悉了STL之后，许多代码可以被大大的化简，只需要通过调用一-两个算法模板，就可以完成所需要的功能并大大地提升效率。</p><p>  算法部分主要由头文件<code>&lt;algorithm&gt;</code>, <code>&lt;numeric&gt;</code>和<code>&lt;functional&gt;</code>组成。<code>&lt;algorithm&gt;</code>是所 有STL头文件中最大的一个(尽管它很好理解)，它是由一大堆模版函数组成的，可以认为每个函数在很大程度上都是独立的，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等等。<code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。<code>&lt;functional&gt;</code>中则定义了一些模板类，用以声明函数对象。</p><h2 id="2-算法的分类"><a href="#2-算法的分类" class="headerlink" title="2.算法的分类"></a>2.算法的分类</h2><h3 id="非可变序列算法"><a href="#非可变序列算法" class="headerlink" title="非可变序列算法"></a>非可变序列算法</h3><p>计数算法：count,count_if等 </p><p>搜索算法：search,find,find_if,find_list_of等</p><p>比较算法：equal,mismatch,lexicographical_compare等</p><h3 id="可变排序算法"><a href="#可变排序算法" class="headerlink" title="可变排序算法"></a>可变排序算法</h3><p>删除算法：remove,remove_if,remove_copy等</p><p>修改算法：for_each,transform等</p><p>排序算法：sort,stable_sort,partial_sort等</p><h2 id="3-仿函数"><a href="#3-仿函数" class="headerlink" title="3.仿函数"></a>3.仿函数</h2><h2 id="4-一些常用的算法模板"><a href="#4-一些常用的算法模板" class="headerlink" title="4.一些常用的算法模板"></a>4.一些常用的算法模板</h2><h3 id="find算法"><a href="#find算法" class="headerlink" title="find算法"></a>find算法</h3><p><strong>原型:</strong><code>iterator find(iterator begin,iterator end,T t)</code></p><p>在容器的begin迭代器所指向的位置开始到end所指向的位置结束，查找元素t，如果找到了，则返回指向t的迭代器。</p><h1 id="四、迭代器"><a href="#四、迭代器" class="headerlink" title="四、迭代器"></a>四、迭代器</h1><h2 id="1-迭代器"><a href="#1-迭代器" class="headerlink" title="1.迭代器"></a>1.迭代器</h2><p>​    迭代器从作用上来说是最基本的部分，可是理解起来比前两者都要费力一些。软件设计有一个基本原则，所有的问题都可以通过引进一个间接层来简化，这种简化在 STL中就是用迭代器来完成的。概括来说，迭代器在STL中用来将算法和容器联系起来，起着一种黏和剂的作用。几乎STL提供的所有算法都是通过送代器存取元素序列进行工作的，每一个容器都定义了其本身所专有的选代器，用以存取容器中的元素。</p><p>​    迭代器部分主要由头文件<code>&lt;utility&gt;</code>,<code>&lt;iterator&gt;</code>和<code>&lt;memory&gt;</code>组成。<code>&lt;utility&gt;</code>是-一个很小的头文件，它包括了贯穿使用在STL中的几个模板的声明，<code>&lt;iterator&gt;</code>中提供 了迭代器使用的许多方法，而对于<code>&lt;memory&gt;</code>的描述则十分的困难，它以不同寻常的方式为容器中的元素分配存储空间，同时也为某些算法执行期间产生的临时对象提供机制,<code>&lt;memory&gt;</code>中的主要部分是模板类<code>alocator</code>,它负责产生所有容器中的默认分配器。</p><h2 id="2-迭代器的基本原理"><a href="#2-迭代器的基本原理" class="headerlink" title="2.迭代器的基本原理"></a>2.迭代器的基本原理</h2><ul><li><p>迭代器是一个“可遍历STL容器内全部或部分元素”的对象</p></li><li><p>迭代器指出容器中的一个特定位置</p></li><li><p>迭代器就如同一个指针</p></li><li><p>迭代器提供对一个容器中的对象的访问方法，并且可以定义了容器中对象的范围</p></li></ul><h2 id="3-迭代器的分类"><a href="#3-迭代器的分类" class="headerlink" title="3.迭代器的分类"></a>3.迭代器的分类</h2><p><strong>输入迭代器</strong>:也有叫法称之为“只读迭代器”，它从容器中读取元素，只能一次读入一个元素向前移动，只支持一遍算法，同一个输入迭代器不能两遍遍历一个序列。</p><p><strong>输出迭代器</strong>:也有叫法称之为“只写迭代器”，它往容器中写入元素，只能一次写入一个元素向前移动，只支持一遍算法，同一个输出迭代器不能两遍遍历一个序列。</p><p><strong>正向迭代器</strong>:组合输入送代器和输出迭代器的功能,还可以多次解析一个迭代器指定的位置，可以对一个值进行多次读/写。</p><p><strong>双向达代器</strong>:组合正向迭代器的功能，还可以通过-操作符向后移动位置。</p><p><strong>随机访问送代器</strong>:组合双向送代器的功能，还可以向前向后跳过任意个位置，可以直接访问容器中任何位置的元素。</p><h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPlus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C++】C++函数模板的实现机制剖析</title>
    <link href="/2019/10/03/%E3%80%90C++%E3%80%91C++%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%89%96%E6%9E%90/"/>
    <url>/2019/10/03/%E3%80%90C++%E3%80%91C++%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="函数模板的实现机制剖析"><a href="#函数模板的实现机制剖析" class="headerlink" title="函数模板的实现机制剖析"></a>函数模板的实现机制剖析</h1><p>要剖析函数模板的实现机制，我们要先了解程序的编译过程，这里以gcc为例</p><p><img src="/2019/10/03/%E3%80%90C++%E3%80%91C++%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%89%96%E6%9E%90/Snipaste_2019-10-03_16-51-51.png"></p><p>这里对下面代码进行剖析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;stdafx.h&quot;</span><span class="hljs-comment">//这是VS的固有头文件</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">(T a,T b)</span></span><br><span class="hljs-function"></span>&#123;<br>a = a + b;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;我是函数模板&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Fun(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>Fun(<span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>);<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>打开控制台，使用命令生成汇编文件(当然环境变量里需要有g++编译器的路径才能这样使用，具体操作放在文末)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">g++ -S 1.cpp -o 1.s<br></code></pre></td></tr></table></figure><p>我们来查看汇编文件</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><code class="hljs pascal">.file&quot;C++.cpp&quot;<br>.lcomm __ZStL8__ioinit,<span class="hljs-number">1</span>,<span class="hljs-number">1</span><br>.def___main;.scl<span class="hljs-number">2</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>.section .rdata,&quot;dr&quot;<br>LC2:<br>.ascii &quot;pause\0&quot;<br>.text<br>.globl_main<br>.def_main;.scl<span class="hljs-number">2</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>_main:<br>LFB1062:<br>.cfi_startproc<br>pushl%ebp<br>.cfi_def_cfa_offset <span class="hljs-number">8</span><br>.cfi_offset <span class="hljs-number">5</span>, -<span class="hljs-number">8</span><br>movl%esp, %ebp<br>.cfi_def_cfa_register <span class="hljs-number">5</span><br>andl$-<span class="hljs-number">16</span>, %esp<br>subl<span class="hljs-number">$16</span>, %esp<br>call___main<span class="hljs-comment">//--------------进入main函数</span><br>movl<span class="hljs-number">$2</span>, <span class="hljs-number">4</span>(%esp)<br>movl<span class="hljs-number">$1</span>, (%esp)<br>call__Z3FunIiEvT_S0_<span class="hljs-comment">//-----第一次调用函数模板</span><br>fldlLC0<br>fstpl<span class="hljs-number">8</span>(%esp)<br>fldlLC1<br>fstpl(%esp)<br>call__Z3FunIdEvT_S0_<span class="hljs-comment">//-----第二次调用函数模板</span><br>movl$LC2, (%esp)<br>call_system<br>movl<span class="hljs-number">$0</span>, %eax<br>leave<br>.cfi_restore <span class="hljs-number">5</span><br>.cfi_def_cfa <span class="hljs-number">4</span>, <span class="hljs-number">4</span><br>ret<br>.cfi_endproc<br>LFE1062:<br>.section .rdata,&quot;dr&quot;<br>LC4:<br>.ascii &quot;\316\322\312\307\272\257\312\375\304\243\260\345\0&quot;<br>.section.text$_Z3FunIiEvT_S0_,&quot;x&quot;<br>.linkonce discard<br>.globl__Z3FunIiEvT_S0_<br>.def__Z3FunIiEvT_S0_;.scl<span class="hljs-number">2</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>__Z3FunIiEvT_S0_:<span class="hljs-comment">//------------第一次调用时函数模板的具体实现</span><br>LFB1063:<br>.cfi_startproc<br>pushl%ebp<br>.cfi_def_cfa_offset <span class="hljs-number">8</span><br>.cfi_offset <span class="hljs-number">5</span>, -<span class="hljs-number">8</span><br>movl%esp, %ebp<br>.cfi_def_cfa_register <span class="hljs-number">5</span><br>subl<span class="hljs-number">$24</span>, %esp<br>movl<span class="hljs-number">12</span>(%ebp), %eax<br>addl%eax, <span class="hljs-number">8</span>(%ebp)<br>movl$LC4, 4(%esp)<br>movl$__ZSt4cout, (%esp)<br>call__ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc<br>movl$__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_, (%esp)<br>movl%eax, %ecx<br>call__ZNSolsEPFRSoS_E<br>subl<span class="hljs-number">$4</span>, %esp<br>nop<br>leave<br>.cfi_restore <span class="hljs-number">5</span><br>.cfi_def_cfa <span class="hljs-number">4</span>, <span class="hljs-number">4</span><br>ret<br>.cfi_endproc<br>LFE1063:<br>.section.text$_Z3FunIdEvT_S0_,&quot;x&quot;<br>.linkonce discard<br>.globl__Z3FunIdEvT_S0_<span class="hljs-comment">//-第二次调用时函数模板的具体实现</span><br>.def__Z3FunIdEvT_S0_;.scl<span class="hljs-number">2</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>__Z3FunIdEvT_S0_:<br>LFB1064:<br>.cfi_startproc<br>pushl%ebp<br>.cfi_def_cfa_offset <span class="hljs-number">8</span><br>.cfi_offset <span class="hljs-number">5</span>, -<span class="hljs-number">8</span><br>movl%esp, %ebp<br>.cfi_def_cfa_register <span class="hljs-number">5</span><br>subl<span class="hljs-number">$40</span>, %esp<br>movl<span class="hljs-number">8</span>(%ebp), %eax<br>movl%eax, -<span class="hljs-number">16</span>(%ebp)<br>movl<span class="hljs-number">12</span>(%ebp), %eax<br>movl%eax, -<span class="hljs-number">12</span>(%ebp)<br>movl<span class="hljs-number">16</span>(%ebp), %eax<br>movl%eax, -<span class="hljs-number">24</span>(%ebp)<br>movl<span class="hljs-number">20</span>(%ebp), %eax<br>movl%eax, -<span class="hljs-number">20</span>(%ebp)<br>fldl-<span class="hljs-number">16</span>(%ebp)<br>faddl-<span class="hljs-number">24</span>(%ebp)<br>fstpl-<span class="hljs-number">16</span>(%ebp)<br>movl$LC4, 4(%esp)<br>movl$__ZSt4cout, (%esp)<br>call__ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc<br>movl$__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_, (%esp)<br>movl%eax, %ecx<br>call__ZNSolsEPFRSoS_E<br>subl<span class="hljs-number">$4</span>, %esp<br>nop<br>leave<br>.cfi_restore <span class="hljs-number">5</span><br>.cfi_def_cfa <span class="hljs-number">4</span>, <span class="hljs-number">4</span><br>ret<br>.cfi_endproc<br>LFE1064:<br>.text<br>.def___tcf_0;.scl<span class="hljs-number">3</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>___tcf_0:<br>LFB1074:<br>.cfi_startproc<br>pushl%ebp<br>.cfi_def_cfa_offset <span class="hljs-number">8</span><br>.cfi_offset <span class="hljs-number">5</span>, -<span class="hljs-number">8</span><br>movl%esp, %ebp<br>.cfi_def_cfa_register <span class="hljs-number">5</span><br>subl<span class="hljs-number">$8</span>, %esp<br>movl$__ZStL8__ioinit, %ecx<br>call__ZNSt8ios_base4InitD1Ev<br>leave<br>.cfi_restore <span class="hljs-number">5</span><br>.cfi_def_cfa <span class="hljs-number">4</span>, <span class="hljs-number">4</span><br>ret<br>.cfi_endproc<br>LFE1074:<br>.def__Z41__static_initialization_and_destruction_0ii;.scl<span class="hljs-number">3</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>__Z41__static_initialization_and_destruction_0ii:<br>LFB1073:<br>.cfi_startproc<br>pushl%ebp<br>.cfi_def_cfa_offset <span class="hljs-number">8</span><br>.cfi_offset <span class="hljs-number">5</span>, -<span class="hljs-number">8</span><br>movl%esp, %ebp<br>.cfi_def_cfa_register <span class="hljs-number">5</span><br>subl<span class="hljs-number">$24</span>, %esp<br>cmpl<span class="hljs-number">$1</span>, <span class="hljs-number">8</span>(%ebp)<br>jneL8<br>cmpl<span class="hljs-number">$65535</span>, <span class="hljs-number">12</span>(%ebp)<br>jneL8<br>movl$__ZStL8__ioinit, %ecx<br>call__ZNSt8ios_base4InitC1Ev<br>movl$___tcf_0, (%esp)<br>call_atexit<br>L8:<br>nop<br>leave<br>.cfi_restore <span class="hljs-number">5</span><br>.cfi_def_cfa <span class="hljs-number">4</span>, <span class="hljs-number">4</span><br>ret<br>.cfi_endproc<br>LFE1073:<br>.def__GLOBAL__sub_I_main;.scl<span class="hljs-number">3</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>__GLOBAL__sub_I_main:<br>LFB1075:<br>.cfi_startproc<br>pushl%ebp<br>.cfi_def_cfa_offset <span class="hljs-number">8</span><br>.cfi_offset <span class="hljs-number">5</span>, -<span class="hljs-number">8</span><br>movl%esp, %ebp<br>.cfi_def_cfa_register <span class="hljs-number">5</span><br>subl<span class="hljs-number">$24</span>, %esp<br>movl<span class="hljs-number">$65535</span>, <span class="hljs-number">4</span>(%esp)<br>movl<span class="hljs-number">$1</span>, (%esp)<br>call__Z41__static_initialization_and_destruction_0ii<br>leave<br>.cfi_restore <span class="hljs-number">5</span><br>.cfi_def_cfa <span class="hljs-number">4</span>, <span class="hljs-number">4</span><br>ret<br>.cfi_endproc<br>LFE1075:<br>.section.ctors,&quot;w&quot;<br>.align <span class="hljs-number">4</span><br>.long__GLOBAL__sub_I_main<br>.section .rdata,&quot;dr&quot;<br>.align <span class="hljs-number">8</span><br>LC0:<br>.long-<span class="hljs-number">1717986918</span><br>.long<span class="hljs-number">1070176665</span><br>.align <span class="hljs-number">8</span><br>LC1:<br>.long-<span class="hljs-number">1717986918</span><br>.long<span class="hljs-number">1069128089</span><br>.ident&quot;GCC: (i686-posix-dwarf-rev0, Built by MinGW-W64 project) 5.3.0&quot;<br>.def_system;.scl<span class="hljs-number">2</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>.def__ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc;.scl<span class="hljs-number">2</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>.def__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_;.scl<span class="hljs-number">2</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>.def__ZNSolsEPFRSoS_E;.scl<span class="hljs-number">2</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>.def__ZNSt8ios_base4InitD1Ev;.scl<span class="hljs-number">2</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>.def__ZNSt8ios_base4InitC1Ev;.scl<span class="hljs-number">2</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>.def_atexit;.scl<span class="hljs-number">2</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br></code></pre></td></tr></table></figure><p>可以看到，在汇编码中编译器将模板<code>void Fun(T a,T b)</code>分别针对类型<code>int</code>和类型<code>float</code>进行了两次具体实现，这不是和没有使用模板，直接写两个函数一样么？没错就是一样的，只是C++将这个工作交从程序员手里移交给了编译器来做。</p><p>事实上C++对函数模板进行了<font color="red">两次编译</font>，第一次编译仅仅生成一个函数头，第二次编译则是在函数调用时根据模板的类型参数列表具体的实现这个模板对应的类型的函数实例，注意这里是根据类型参数列表来实现，而不是根据调用次数，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">Fun(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>Fun(<span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>);<br></code></pre></td></tr></table></figure><p>编译器实现两个模板实例<code>int</code>和<code>float</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">Fun(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>Fun(<span class="hljs-number">3</span> ,<span class="hljs-number">4</span>);<br>Fun(<span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>);<br></code></pre></td></tr></table></figure><p>编译器还是实现两个模板实例<code>int</code>和<code>float</code></p><p>由此可以看出</p><p><font color="red"> 编译器并不是把函数模板处理成能够处理任意类的函数</font></p><p><font color="red">编译器将函数模板根据具体类型产生不同的函数</font></p><p><font color="red">编译器会对函数模板进行两次编译，在申明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。</font></p><p>g++命令的使用</p><p>首先电脑里要有g++这个软件，我这里使用的是Qt里集成的g++软件</p><p><img src="/2019/10/03/%E3%80%90C++%E3%80%91C++%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%89%96%E6%9E%90/Snipaste_2019-10-03_19-57-21.png"></p><p>然后右键我的电脑–&gt;属性–&gt;高级环境设置–&gt;环境变量–&gt;系统变量/Path–&gt;编辑</p><p><img src="/2019/10/03/%E3%80%90C++%E3%80%91C++%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%89%96%E6%9E%90/Snipaste_2019-10-03_20-07-41.png"></p><p>再然后新建–&gt;将g++.exe所在的路径拷贝到新建的环境变量中</p><p><img src="/2019/10/03/%E3%80%90C++%E3%80%91C++%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%89%96%E6%9E%90/Snipaste_2019-10-03_20-08-21.png"></p><p>测试一下，win+r–&gt;cmd–&gt;任意目录键入g++</p><p><img src="/2019/10/03/%E3%80%90C++%E3%80%91C++%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%89%96%E6%9E%90/Snipaste_2019-10-03_20-12-24.png"></p><p>可以看到系统没有提示无此命令，说明配置成功</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPlus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C】C的typedef的妙用</title>
    <link href="/2019/10/03/%E3%80%90C%E3%80%91C%E7%9A%84typedef%E7%9A%84%E5%A6%99%E7%94%A8/"/>
    <url>/2019/10/03/%E3%80%90C%E3%80%91C%E7%9A%84typedef%E7%9A%84%E5%A6%99%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="1-自定义数组类型"><a href="#1-自定义数组类型" class="headerlink" title="1.自定义数组类型"></a>1.自定义数组类型</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">typedef int (Array)[5];<br></code></pre></td></tr></table></figure><p><code>Array</code>是一个类型为<code>int</code>长度为5的数组类型，即定义一个<code>Array a;</code>那么a就是一个类型为int长度为5的数组，所以a的使用方法和数组一致。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">typedef int(Array)[5];<br>Array a;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>,j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>a[i] = i;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,&quot;</span>, a[j]);<br></code></pre></td></tr></table></figure><h1 id="2-自定义指向数组的指针类型"><a href="#2-自定义指向数组的指针类型" class="headerlink" title="2.自定义指向数组的指针类型"></a>2.自定义指向数组的指针类型</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">typedef char(*Arrayptr)[8];<br></code></pre></td></tr></table></figure><p><code>Arrayptr</code>是一个指向<code>char</code>类型的长度为8的数组的指针类型，此类型的指针只能指向<code>char</code>类型的长度为8的数组。且每一次指针移步，移动的距离是1*8=8字节。</p><p>需要注意的是<code>()</code>不能省略，否则定义就会变义。</p><p>除了自定义指针类型来指向一个固定的数组外，C还可以直接定义一个指向固定数组的指针变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> (*p)[<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><p><code>p</code>就是一个指向类型为整型且长度为5的数组的指针变量。</p><h1 id="3-自定义函数类型"><a href="#3-自定义函数类型" class="headerlink" title="3.自定义函数类型"></a>3.自定义函数类型</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(Funptr)</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;<span class="hljs-comment">//函数类型</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Fun1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fun2</span><span class="hljs-params">(Funptr *p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, p(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Funptr *p = &amp;Fun1;<br>Fun2(p);<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Funptr</code>是一个指向返回值为<code>int</code>参数列表为<code>int,int</code>的函数的类型，通过<code>Funptr</code>函数类型的指针可以将返回值为<code>int</code>参数列表为<code>int,int</code>的函数当作参数来使用，使函数的调用更为灵活。</p><p>除了定义函数类型可以达到这种效果，我们还可以直接定义指向函数的指针类型来实现函数参数化，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*Funptr)</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Fun1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fun2</span><span class="hljs-params">(Funptr p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, p(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Funptr p = &amp;Fun1;<br>Fun2(p);<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的效果和定义函数类型是一样的。</p><p>当然我们还可以直接定义一个指向函数的指针变量，来实现同样的效果，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Fun1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fun2</span><span class="hljs-params">(Funptr p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, p(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span>(*p)(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) = &amp;Fun1;<br>Fun2(p);<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们还可以这么做，一样能达到相同的效果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Fun1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fun2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*ptr)(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b))</span><span class="hljs-comment">//直接定义函数指针的形参</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ptr(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Fun2(&amp;Fun1);<span class="hljs-comment">//直接传递函数地址</span><br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>搞了那么多似乎函数指针只是把函数的调用弄得更复杂了而已，除了把函数当作参数来使用似乎没有什么作用了，真的是如此吗？</p><p><font color="red"> 如果我们仔细观察，会发现函数指针将函数的调用和函数的实现分隔开来了，即函数指针提前规定好了函数的实现标准，这样只要后来者按照这个标准来实现函数，可以不用修改前人的代码，就能实现函数的完美的调用，这一作用在具体的项目迭代中是及其出众的。</font></p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C++】C++面向对象模型初探</title>
    <link href="/2019/10/01/%E3%80%90C++%E3%80%91C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%88%9D%E6%8E%A2/"/>
    <url>/2019/10/01/%E3%80%90C++%E3%80%91C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%88%9D%E6%8E%A2/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="1-成员的分开存储"><a href="#1-成员的分开存储" class="headerlink" title="1.成员的分开存储"></a>1.成员的分开存储</h1><p>C++通过将类的成员分开存储的方式来实现面向对象</p><table><thead><tr><th>成员</th><th>存储位置</th></tr></thead><tbody><tr><td>普通成员变量</td><td>栈区，与struct变量有相同的内存布局和字节对齐方式</td></tr><tr><td>静态成员变量</td><td>全局数据区，如此便可以使用类名和类所有的对象都可以访问</td></tr><tr><td>成员函数</td><td>代码段，包括静态成员函数和非静态成员函数</td></tr><tr><td>虚函数</td><td>虚函数表指针(vfptr)存放在栈区，其指向的虚函数表有自身的内存存储空间</td></tr></tbody></table><h1 id="2-C-类的内存分布"><a href="#2-C-类的内存分布" class="headerlink" title="2.C++类的内存分布"></a>2.C++类的内存分布</h1><p>要想更好的了解这些，我们还需了解C++类的内存分布</p><p><img src="/2019/10/01/%E3%80%90C++%E3%80%91C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%88%9D%E6%8E%A2/Snipaste_2019-10-02_09-07-09.png"></p><h2 id="Stack："><a href="#Stack：" class="headerlink" title="Stack："></a><strong>Stack：</strong></h2><p>栈，存放Automatic Variables，按内存地址由高到低方向生长，其最大大小由编译时确定，速度快，但自由性差，最大空间不大。保存程序中的局部变量。</p><h2 id="Heap："><a href="#Heap：" class="headerlink" title="Heap："></a><strong>Heap：</strong></h2><p>堆，自由申请的空间，按内存地址由低到高方向生长，其大小由系统内存/虚拟内存上限决定，速度较慢，但自由性大，可用空间大。 动态分配的内存在调用malloc（）或者相关函数产生，在调用free()时释放，由程序员决定而不是一系列规则规定内存持续时间，因此内存块可在一个函数中创建，在另一个函数中释放。由于这点，动态内存分配容易导致堆区内存碎片化。</p><h2 id="Data："><a href="#Data：" class="headerlink" title=".Data："></a><strong>.Data：</strong></h2><p> 存放程序中<font color="red"> 已经初始化的非零全局变量。静态分配。</font></p><p>data又可分为读写（RW）区域和只读（RO）区域。 </p><ul><li>RO段保存常量所以也被称为<code>.constdata</code> eg const数据</li><li>RW段则是普通非常全局变量，静态变量就在其中</li></ul><h2 id="Bss："><a href="#Bss：" class="headerlink" title=".Bss："></a><strong>.Bss：</strong></h2><p>存放程序中<strong>未初始化</strong>的和零值全局变量。静态分配，在程序开始时通常会被清零。</p><h2 id="Text："><a href="#Text：" class="headerlink" title=".Text："></a><strong>.Text：</strong></h2><p>也称为代码段(Code)，用来存放程序执行代码，同时也可能会包含一些常量(如一些字符串常量等）。该段内存为静态分配，只读(某些架构可能允许修改)。<br>这块内存是共享的,当有多个相同进程(Process)存在时，共用同一个text段。</p><hr><p>普通成员变量存储在栈区，使得每一个类的对象都拥有各自独立的普通成员变量。</p><p>静态成员变量存储在全局数据区，是的每一个类的对象都共享一份静态</p><p>成员变量。</p><h1 id="3-this指针"><a href="#3-this指针" class="headerlink" title="3.this指针"></a>3.this指针</h1><p>那么，存放在代码段的成员函数是怎么区分调用对象的呢？</p><p>事实上，<font color="red"> C++为每一个函数都隐式定义了一个函数所属类类型的指针形参–this，而this指针永远指向调用函数的对象</font>，如此函数便可以识别调用自身的是类的哪个对象了。</p><p>这里有一点要注意，<font color="red"> C++并没有为静态成员函数定义this指针，如此，静态成员函数被所有的对象共享</font>。</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h1><p>通过成员的分开存储和普通成员函数的<code>this指针</code>C++便可以识别各个不同的对象，如此便实现了面向对象。</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPlus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【shell】shell基础</title>
    <link href="/2019/09/30/%E3%80%90shell%E3%80%91shell%E5%9F%BA%E7%A1%80/"/>
    <url>/2019/09/30/%E3%80%90shell%E3%80%91shell%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>由于本文内有大量的markdwon转义未处理，导致远程同步不通过，所以本文引入外部ULR预览</p><p><a href="https://blog.csdn.net/qq_39108291/article/details/101797244">https://blog.csdn.net/qq_39108291/article/details/101797244</a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C++】C++高级</title>
    <link href="/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/"/>
    <url>/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="一、类"><a href="#一、类" class="headerlink" title="一、类"></a>一、类</h1><h2 id="1-浅拷贝与深拷贝"><a href="#1-浅拷贝与深拷贝" class="headerlink" title="1.浅拷贝与深拷贝"></a>1.浅拷贝与深拷贝</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p><font color="red"> C++在进行浅拷贝时，只拷贝栈区的内存空间，不拷贝堆区的内存空间，即浅拷贝只拷贝非指针的成员变量和指针本身，而不拷贝指针所指向的堆区的内容。</font></p><p>我们代码1.1为例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//代码1.1</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Obj</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>Obj(<span class="hljs-keyword">char</span> *tp)<br>&#123;<br>len = <span class="hljs-built_in">strlen</span>(tp);<br>p = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(len + <span class="hljs-number">1</span>);<br>strcpy_s(p, len+<span class="hljs-number">1</span>, tp);<br>&#125;<br>~Obj()<br>&#123;<br><span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">free</span>(p);<br>p = <span class="hljs-literal">NULL</span>;<br>len = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; *p &lt;&lt; *(p + <span class="hljs-number">1</span>) &lt;&lt; *(p + <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">char</span> *p;<br><span class="hljs-keyword">int</span> len;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">text</span><span class="hljs-params">(Obj &amp;obj)</span></span><br><span class="hljs-function"></span>&#123;<br>Obj obj2 = obj;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Obj <span class="hljs-title">obj1</span><span class="hljs-params">(<span class="hljs-string">&quot;asd&quot;</span>)</span></span>;<br>text(obj1);<br>obj1.Show();<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们作一个图示：</p><p><img src="/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/Git\Blog\source_posts\【C++】C++高级\Snipaste_2019-10-01_16-21-15.png"></p><p>​    我们没有自定义Obj类的拷贝构造函数，所以当代码执行到<code>Obj obj2 = obj1;</code>时，编译器将调用默认的拷贝构造函数，然而，<font color="red"> 编译器默认的拷贝构造函数是一个浅拷贝</font>，所以新创建的对象obj2没有自己的堆区空间，obj2.p指向的是obj1.p所指向的内存地址。</p><p>​    上面的代码编译是通不过的，<font color="red"> 原因在于，对象析构时，同一个内存地址<code>0x0001</code>被对象obj1和obj2一起析构了两次</font>。当代码执行完<code>test(obj1)</code>时，对象obj2被析构，指针obj2.p所指向的内存地址<code>0x0001</code>被释放，所以当代码执行到<code>obj1.Show()</code>时，使用了已经被释放掉的内存<code>0x0001</code>地址，从而导致运行错误。</p><p>​    <font color="green"> <strong>这里我有一个疑问，既然浅拷贝在拷贝有指针的对象时，会出现两次析构而出错，所以浅拷贝只能拷贝没有指针成员的对象，那么浅拷贝和深拷贝似乎没有什么区别了，那么浅拷贝存在的意义是什么呢？</strong></font></p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>C++没有提供给开发者预定义的深拷贝方法，所以要想使用深拷贝，我们需要字写一个拷贝构造函数。</p><p>深拷贝可以解决上面遇到的浅拷贝的问题，因为，<font color="red"> 深拷贝会申请一新的内存空间用于存放拷贝过来的内容，即深拷贝拷贝对象的所有成员，包括指针所指向的内存空间也会一起被拷贝，被拷贝过来的指针会指向一个新的内存地址</font>。</p><p><img src="/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/Snipaste_2019-10-01_16-52-53.png"></p><h3 id="定义深拷贝构造函数"><a href="#定义深拷贝构造函数" class="headerlink" title="定义深拷贝构造函数"></a>定义深拷贝构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//代码1.2</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Obj</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>Obj(<span class="hljs-keyword">char</span> *tp)<br>&#123;<br>len = <span class="hljs-built_in">strlen</span>(tp);<br>p = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(len + <span class="hljs-number">1</span>);<br>strcpy_s(p, len+<span class="hljs-number">1</span>, tp);<br>&#125;<br>    <span class="hljs-comment">//------------------------------</span><br>    <span class="hljs-comment">//拷贝构造函数--深拷贝</span><br>Obj(<span class="hljs-keyword">const</span> Obj &amp;obj)<br>&#123;<br>len = obj.len;<br>p = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(len + <span class="hljs-number">1</span>);<br>strcpy_s(p, len + <span class="hljs-number">1</span>, obj.p);<br>&#125;<br>    <span class="hljs-comment">//------------------------------</span><br>~Obj()<br>&#123;<br><span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">free</span>(p);<br>p = <span class="hljs-literal">NULL</span>;<br>len = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; *p &lt;&lt; *(p + <span class="hljs-number">1</span>) &lt;&lt; *(p + <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">char</span> *p;<br><span class="hljs-keyword">int</span> len;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当一个类中定义了拷贝构造函数，则在对象拷贝时，编译器就不会在调用默认的拷贝构造函数转而调用自定义的拷贝构造函数，当我们把代码1.1中类的定义改为代码1.2中类的定义后，程序就可以正常执行了。</p><p><font color="red">使用深拷贝时，我们还需要注意下面的情况：</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Obj <span class="hljs-title">obj1</span><span class="hljs-params">(<span class="hljs-string">&quot;asd&quot;</span>)</span></span>;<br><span class="hljs-function">Obj <span class="hljs-title">obj3</span><span class="hljs-params">(<span class="hljs-string">&quot;fgh&quot;</span>)</span></span>;<br>obj3 = obj1;<br></code></pre></td></tr></table></figure><p>此时，在<code>obj3=obj1;</code>处依旧调用默认的拷贝构造函数，这里我们要弄清楚<code>obj3=obj1</code>和<code>Obj obj3 = obj1</code>之间的区别，<code>obj3=obj1</code>是将<font color="red">obj1赋值给obj3</font>，<code>=</code>赋值与拷贝构造函数没有什么关联，<code>=</code>在赋值时是C++编译器自己调用默认的拷贝构造函数—浅拷贝，和类中有无定义深拷贝无关；而<code>Obj obj3=obj1</code>则是<font color="red">使用obj1来构造obj3</font>，此时如果类中定义了深拷贝构造函数，就会使用深拷贝。要解决这个问题，就需要显示重载<code>=</code>运算符了。</p><h3 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a><font color="blue"><strong>小知识</strong></font></h3><ul><li><font color="blue">在定义拷贝构造函数时，必须使用引用传递，否则会出现无限拷贝的情况，因为，如果我们使用传值传递的话，在传递对象到拷贝构造函数时，又会调用拷贝构造函数将实参拷贝给形参，而这个过程又会将对象传递给拷贝构造函数，从而在此调用拷贝构造函数将实参拷贝给形参，如此无限循环</font></li><li><font color="blue">拷贝构造函数只能有一个参数，且必须是自身类的引用，否则编译器将识别被普通构造函数</font></li></ul><h2 id="2-初始化参数列表"><a href="#2-初始化参数列表" class="headerlink" title="2.初始化参数列表"></a>2.初始化参数列表</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>我们以下面的代码1.3来说明初始化参数列表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>A(<span class="hljs-keyword">int</span> a)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">int</span> a;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span> :<br>B(<span class="hljs-keyword">int</span> i)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;i = i;<br>&#125;<br><span class="hljs-keyword">int</span> i;<br>A a;<br><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">B <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">错误C2512“<span class="hljs-keyword">A</span>”: 没有合适的默认构造函数可用<br></code></pre></td></tr></table></figure><p>​    这个问题就在于，在类B中组合了一个A类的成员，编译器在构造B类对象时，同时会构造一个A类对象作为B类的成员，然而，因为A类自定义了一个有参的构造函数，所以在构造A类时，编译器不会使用默认构造函数，而是使用自定义的有参构造函数，问题就出在这里，编译器在构造A类时，没有参数传递到A类的有参构造函数中。初始化参数列表就是用于解决这种问题的。</p><p>​    需要说明的是，如果A类中没有自定义有参的构造函数，则在B类构造对象时编译器自动调用A类的默认构造函数构造A类对象成员，就不会报错。</p><p>​    初始化参数列表可以让我们在构造B类对象时，根据参数列表来构造不同的A类成员。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>初始化参数列表的使用如下面的<code>B(int i):a1(1),a2(2,&quot;asd&quot;)</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>A(<span class="hljs-keyword">int</span> a)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;构造小A&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>A(<span class="hljs-keyword">int</span> a, <span class="hljs-built_in">string</span> str)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br><span class="hljs-keyword">this</span>-&gt;str = str;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;构造大A&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>~A()<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;析构A&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">int</span> a;<br><span class="hljs-built_in">string</span> str;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span> :<br>B(<span class="hljs-keyword">int</span> i):a1(<span class="hljs-number">1</span>),a2(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;asd&quot;</span>)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;i = i;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;构造B&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>~B()<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;析构B&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-keyword">int</span> i;<br>A a1;<br>A a2;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">B <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; b.a1.str &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; b.a2.str &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>test();<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dns">构造小<span class="hljs-keyword">A</span><br>构造大<span class="hljs-keyword">A</span><br>构造B<br><br>asd<br>析构B<br>析构<span class="hljs-keyword">A</span><br>析构<span class="hljs-keyword">A</span><br></code></pre></td></tr></table></figure><p>​    值得注意的是<font color="red"> A类对象的构造顺序不是由初始化参数列表的顺序决定的，而是由对象的申明的前后顺序决定的</font>，如：<code>B(int i):a1(1),a2(2,&quot;asd&quot;)</code>和<code>B(int i):a2(2,&quot;asd&quot;),a1(1)</code>的构造顺序是一样的，但是当我们将类B中组合的A类对象的申明顺序改为如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span> :<br>B(<span class="hljs-keyword">int</span> i):a1(<span class="hljs-number">1</span>),a2(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;asd&quot;</span>)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;i = i;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;构造B&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>~B()<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;析构B&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-keyword">int</span> i;<br>A a2;<br>A a1;<br>&#125;;<br></code></pre></td></tr></table></figure><p>则构造顺序就变为“先构造a2再构造a1”了。</p><p><font color="red"> 析构的顺序和构造的顺序相反。</font></p><h3 id="小知识-1"><a href="#小知识-1" class="headerlink" title=" 小知识"></a><font color="blue"> 小知识</font></h3><ul><li><font color="blue"> 当一个类中组合了其他的类对象作为成员时，拷贝构造函数也必须使用初始化参数列表，来构造对象成员然后拷贝</font></li></ul><h2 id="3-匿名对象的生命周期"><a href="#3-匿名对象的生命周期" class="headerlink" title="3.匿名对象的生命周期"></a>3.匿名对象的生命周期</h2><h3 id="什么是匿名对象"><a href="#什么是匿名对象" class="headerlink" title="什么是匿名对象"></a>什么是匿名对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++">calss A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> a;<br>A(<span class="hljs-keyword">int</span> a)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的语句<code>A(1)</code>创建的就是一个匿名临时的对象，<font color="red"> 需要注意，如果一个类只有无参的构造函数，那么这个类将无法构建匿名对象</font>，匿名对象的生命周期就只在创建匿名对象的这条语句内，如果我们不使用一个对象来接收这个匿名对象，那么匿名对象会在语句结束时被销毁，当我们使用<code>A a = A(1);</code>不会出现匿名对象拷贝到类B对象b的情况，这种语句已经被C++优化成了类B的构造语句。说这么多其实匿名对象没什么卵用。</p><h2 id="4-new和delete"><a href="#4-new和delete" class="headerlink" title="4.new和delete"></a>4.new和delete</h2><p>1.new和delete的用法</p><p><code>new</code>可以为<strong>基础类型</strong>、<strong>数组</strong>、<strong>类</strong>分配内存空间，<code>new</code>分配的内存空间都分配在<strong>堆</strong>上。随意<code>new</code>出来的内存空间必须使用一个指针来指向，不能使用同类型的变量来接收，也禁止不接受。</p><p><strong>new 基础类型</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;<br><span class="hljs-keyword">delete</span> p;<br></code></pre></td></tr></table></figure><p><strong>new 数组</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">delete</span>[] p;<br></code></pre></td></tr></table></figure><p><strong>new 类</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//C++</span><br>A *p = <span class="hljs-keyword">new</span> A();<br><span class="hljs-keyword">delete</span> p;<br><span class="hljs-comment">//C</span><br>A *pc = (A*)<span class="hljs-built_in">malloc</span>(A);<br><span class="hljs-built_in">free</span>(pc);<br></code></pre></td></tr></table></figure><h3 id="new-delete和malloc-free的区别"><a href="#new-delete和malloc-free的区别" class="headerlink" title="new delete和malloc free的区别"></a><code>new delete</code>和<code>malloc free</code>的区别</h3><ul><li><p>在基础类型和基础类型数组方面<code>new delete</code>和<code>malloc free</code>几乎没有什么区别</p></li><li><p><code>new</code>不仅会分配内存还会调用构造函数，而<code>malloc</code>只会分配内存</p></li><li><p><code>delete</code>会调用析构函数来销毁对象，而<code>free</code>只是单纯的释放内存</p></li></ul><h3 id="小知识-2"><a href="#小知识-2" class="headerlink" title=" 小知识"></a><font color="blue"> <strong>小知识</strong></font></h3><p><font color="blue"> <code>new delete</code>和<code>malloc free</code>是可以穿插使用的，即<code>new</code>可以和<code>free</code>搭配使用，<code>malloc</code>可以和<code>delete</code>搭配使用。</font></p><h1 id="二、继承"><a href="#二、继承" class="headerlink" title="二、继承"></a>二、继承</h1><p>继承这边主要分析一下<code>虚继承</code></p><h2 id="1-虚继承"><a href="#1-虚继承" class="headerlink" title="1.虚继承"></a>1.虚继承</h2><p>虚继承的出现主要是为解决如下的继承关系中的二义性问题</p><p><img src="/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/Snipaste_2019-10-02_15-50-39.png" alt="图1"></p><p>当我们的类的继承过程中出现这种继承关系时，我们需要使类B和类C分别虚继承类A来解决二义性，具体操作如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>   <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> a;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> :</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> b;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> :</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> c;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> :</span> <span class="hljs-keyword">public</span> B,C<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> d;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    D d;<br>    d.a = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有一点要注意，虚继承的应用场景有限，虚继承只能解决这种情况：</p><p><img src="/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/Snipaste_2019-10-02_15-50-39.png"></p><p>而不能解决这种情况：</p><p><img src="/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/Snipaste_2019-10-02_16-10-55.png"></p><h2 id="2-继承中的static关键字"><a href="#2-继承中的static关键字" class="headerlink" title="2.继承中的static关键字"></a>2.继承中的static关键字</h2><p><font color="red"> 类中的静态成员变量被类的所有对象共享，同时也被类的派生类的所有对象共享。</font></p><h1 id="三、多态"><a href="#三、多态" class="headerlink" title="三、多态"></a>三、多态</h1><p>​    在C++的几个特性中，封装、继承和抽象都相对好理解，而多态则不太好理解，这里就说说C++的多态。</p><h2 id="1-多态分两种："><a href="#1-多态分两种：" class="headerlink" title="1.多态分两种："></a>1.多态分两种：</h2><p>​    静态多态：静态多态指的就是函数重载和运算符重载。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;动物&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;在叫&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> :</span> <span class="hljs-keyword">public</span> Animal<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;狗&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;在叫&quot;</span> &lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-built_in">string</span> <span class="hljs-keyword">operator</span>+(Animal animal,Dog dog)<br>&#123;<br><span class="hljs-keyword">return</span> animal.name + <span class="hljs-string">&quot;是&quot;</span> + dog.name + <span class="hljs-string">&quot;的父类&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Run</span><span class="hljs-params">(Animal animal)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; animal.name &lt;&lt;<span class="hljs-string">&quot;在跑&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Run</span><span class="hljs-params">(Dog dog)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; dog.name &lt;&lt; <span class="hljs-string">&quot;在跑&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Animal animal;<br>Dog dog;<br>Run(animal);<br>Run(dog);<br><span class="hljs-built_in">cout</span>&lt;&lt;animal+dog&lt;&lt;<span class="hljs-built_in">endl</span>;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    动态多态：动态多态则是通过继承和虚函数实现标签相同的函数因为传入不同的对象来实现不同的功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;动物&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;在叫&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> :</span> <span class="hljs-keyword">public</span> Animal<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;狗&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;在叫&quot;</span> &lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span><span class="hljs-params">(Animal *animal)</span></span><br><span class="hljs-function"></span>&#123;<br>animal-&gt;speak();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Animal animal;<br>Dog dog;<br>Speak(&amp;animal);<br>Speak(&amp;dog);<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    动态多态中只能用父类对象的指针或引用来指向子类或自身对象。</p><h2 id="2-多态的实现原理"><a href="#2-多态的实现原理" class="headerlink" title="2.多态的实现原理"></a>2.多态的实现原理</h2><p>​    C++多态的实现依赖于类的虚函数表，当一个类中定义了虚函数，那么这个类就拥有的了一个记录这个虚函数入口地址的虚函数表，子类继承父类时也会继承父类的虚函数表，当子类重写父类的虚函数时，则子类的虚函数入口地址将覆盖父类的地址，如此当子类对象调用此函数时则从子类的虚函数表中寻找入口地址，当父类的对象调用此函数时则从父类的虚函数表中寻找入口地址。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">当类创建虚函数时，编译器会在类中生成一个虚函数表<br>虚函数表是一个存储类成员函数指针的数据结构<br>虚函数表有编译器自动生成和维护<br>虚成员函数会被编译器放入虚函数表中<br>存在虚函数时，每一个对象中都会拥有一个指向虚函数表的虚函数表指针<span class="hljs-comment">(vptr)</span><br></code></pre></td></tr></table></figure><p>简单来说，多态实现的条件有三：</p><ul><li><p>要有继承</p></li><li><p>要有虚函数重写</p></li><li><p>要有父类指针(或引用)指向子类对象</p></li></ul><h2 id="3-纯虚函数和抽象类"><a href="#3-纯虚函数和抽象类" class="headerlink" title="3.纯虚函数和抽象类"></a>3.纯虚函数和抽象类</h2><p>​    纯虚函数的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>​    定义了纯虚函数的类就被成为抽象类，C++引入纯虚函数和抽象类的概念就是为了更好的使用多态，抽象类不能实例化对象，这个特性就规范了继承这个抽象类的子类必须重写父类的虚函数，因为如果继承了抽象类的子类不重写父类的虚函数，那么子类也是一个抽象类，子类便也不能实例化对象，如此便规范了多态实现，防止当子类很多时，出现某个子类在编写时忘记重写父类的虚函数，而导致这个子类没有实现多态。</p><h2 id="4-虚析构函数和纯虚析构函数"><a href="#4-虚析构函数和纯虚析构函数" class="headerlink" title="4.虚析构函数和纯虚析构函数"></a>4.虚析构函数和纯虚析构函数</h2><ul><li>虚析构函数的定义：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">virtual</span> ~Animal();<br></code></pre></td></tr></table></figure><ul><li>纯虚析构函数的定义：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">virtual</span> ~Animal() = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//纯虚析构函数必须要有申明也要有实现</span><br>Animal：：~Animal()<br>&#123;<br>    <span class="hljs-comment">//代码实现</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果子类在堆区中定义了数据，那么我们使用父类指针或引用来使用多态时，父类指针或引用是无法寻找到子类在堆区中的数据并释放的。C++引入虚析构函数和纯虚析构函数就是为了解决此类问题。</p><p>​    我们来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>Animal()<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;这是Animal的构造函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>~Animal()<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;这是Animal的析构函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> :</span> <span class="hljs-keyword">public</span> Animal<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> *p;<br>Dog()<br>&#123;<br>p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;这是Dog的构造函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>~Dog()<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;这是Dog的析构函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;释放堆区的p&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">delete</span> p;<br>p = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Animal *animal = <span class="hljs-keyword">new</span> Dog();<br><span class="hljs-keyword">delete</span> animal;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">这是<span class="hljs-keyword">Animal</span>的构造函数<br>这是Dog的构造函数<br>这是<span class="hljs-keyword">Animal</span>的析构函数<br></code></pre></td></tr></table></figure><p>可以看到，delete animal后并没有调用Dog的析构函数，释放子类Dog在堆区申请的空间。这样便出现了内存泄漏。</p><p>此时虚析构函数和纯虚析构函数便可以起作用了，我们再看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>Animal()<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;这是Animal的构造函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">virtual</span> ~Animal()<span class="hljs-comment">//把父类的析构函数改为虚析构函数</span><br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;这是Animal的析构函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> :</span> <span class="hljs-keyword">public</span> Animal<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> *p;<br>Dog()<br>&#123;<br>p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;这是Dog的构造函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>~Dog()<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;这是Dog的析构函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;释放堆区的p&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">delete</span> p;<br>p = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Animal *animal = <span class="hljs-keyword">new</span> Dog();<br><span class="hljs-keyword">delete</span> animal;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​    输出结果：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">这是<span class="hljs-keyword">Animal</span>的构造函数<br>这是Dog的构造函数<br>这是Dog的析构函数<br>释放堆区的p<br>这是<span class="hljs-keyword">Animal</span>的析构函数<br></code></pre></td></tr></table></figure><p>​    如此便可以释放子类Dog在堆区申请的空间了，纯虚析构函数和虚析构函数的作用是一样，只是纯虚析构函数有一个和纯虚函数一样的特性，即定义了纯虚析构函数的类也属于抽象类，纯虚析构函数必须实现，如果不实现所有继承了拥有纯虚析构函数的抽象类的派生类都属于抽象类。需要注意的是，因为纯虚析构函数的特性，纯虚析构函数的实现就必须在类外实现了。</p><h2 id="5-重载、重写、重定义"><a href="#5-重载、重写、重定义" class="headerlink" title="5.重载、重写、重定义"></a>5.重载、重写、重定义</h2><p><strong>重载</strong></p><p>重载发生在一个类的内部，拥有相同函数名，相同返回值而参数列表不同的函数之间互为重载关系。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><font color="red"> 只有相同函数名而参数列表不同的函数才是重载，函数名相同参数列表也相同而返回值不同的函数在C++中是不允许的。</font></p><p><strong>重写</strong></p><p>重写发生在基类和派生类之间，基类中定义虚函数(纯虚函数)，派生类中定义和虚函数拥有<strong>相同函数名，相同参数列表和相同返回值</strong>的函数，这种情况下发生函数重写。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> :</span> <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-comment">//重写A类的fun函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;&#125;<span class="hljs-comment">//重定义一个新函数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//这种情况C++不允许</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>重定义</strong></p><p>重定义也是发生在基类和派生类之间，派生类拥有与基类函数名相同，返回值相同，而参数列表不同的函数，此时发生重定义。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> :</span> <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;&#125;<span class="hljs-comment">//发生重定义</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><font color="red"> 派生类中可以重定义基类的任何函数，包括虚函数和纯虚函数。</font></p><h2 id="6-父类指针和子类指针步长不一致问题"><a href="#6-父类指针和子类指针步长不一致问题" class="headerlink" title="6.父类指针和子类指针步长不一致问题"></a>6.父类指针和子类指针步长不一致问题</h2><p>问题出现的场景是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> a;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> :</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> b;<br>B(<span class="hljs-keyword">int</span> b)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;b = b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A *a = <span class="hljs-literal">NULL</span>;<br>B *b = <span class="hljs-literal">NULL</span>;<br>B <span class="hljs-built_in">array</span>[<span class="hljs-number">2</span>]&#123; B(<span class="hljs-number">1</span>),B(<span class="hljs-number">2</span>) &#125;;<br>a = <span class="hljs-built_in">array</span>;<br>b = <span class="hljs-built_in">array</span>;<br>a-&gt;print();<br>b-&gt;print();<br>a++; b++;<br>a-&gt;print();<span class="hljs-comment">//这一步会出现异常</span><br>b-&gt;print();<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>即父类指针a和子类指针b都指向一个子类对象数组，于是我们可以通过指针++的自增运算来逐步访问数组元素，问题就出在这，使用<code>sizeof()</code>计算两个类的大小分别得出，sizeof(A)=8;sizeof(B)=20;这就导致A类指针a每一次移步时只移动了8个字节，这个距离还远远没有达到下一个元素的首地址，所以访问会出错，这是因为指针每次移步移动的距离是指针类型的空间大小，如：A类大小为8，所以A类指针每移步一次走8个字节。</p><p>可能会有疑问，为什么类B的大小是20？</p><p>我们可以算一算，类B继承至类A所以类A中拥有的成员变量，类B也拥有，占8字节，这8字节分别是int变量4字节和虚函数表指针4字节；类B自身定义了一个int变量占4字节，由于类B重写了类A的虚函数，所以类B也拥有一个自己的虚函数表指针，占4字节；类B虚继承了类A，在这个过程中，C++编译器会给类B增加一个属性，占4字节，于是，<strong>8+4+4+4+4=20</strong>。</p><hr><h1 id="四、泛型编程"><a href="#四、泛型编程" class="headerlink" title="四、泛型编程"></a>四、泛型编程</h1><h2 id="1-函数模板"><a href="#1-函数模板" class="headerlink" title="1.函数模板"></a>1.函数模板</h2><h3 id="函数模板的基本语法"><a href="#函数模板的基本语法" class="headerlink" title="函数模板的基本语法"></a>函数模板的基本语法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//---------------函数模板</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-comment">//告诉编译器我要开始泛型编程了，遇到T不要报错</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">(T &amp;a,T &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>T t = a;<br>a = b;<br>b = t;<br>&#125;<br><span class="hljs-comment">//----------------</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">char</span> a = <span class="hljs-number">97</span>,b = <span class="hljs-number">102</span>;<br>Fun(a, b);<span class="hljs-comment">//自动推导类型调用</span><br><span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">string</span> x = <span class="hljs-string">&quot;xxx&quot;</span>, y = <span class="hljs-string">&quot;yyy&quot;</span>;<br>Fun&lt;<span class="hljs-built_in">string</span>&gt;(x, y);<span class="hljs-comment">//显示类型调用</span><br><span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-built_in">endl</span>;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="当函数模板遇到函数重载"><a href="#当函数模板遇到函数重载" class="headerlink" title="当函数模板遇到函数重载"></a>当函数模板遇到函数重载</h3><p>当函数模板遇到函数重载准许下面4条原则</p><ul><li>函数模板可以像普通函数一样被重载</li><li>C++编译器优先考虑普通函数</li><li>如果函数模板可以产生一个更好的匹配，那么选择函数模板</li><li>可以通过模板的空实参列表的语法限定编译器只通过函数模板匹配</li></ul><p>我们来看一个例子，逐一分析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">(T a,T b)</span></span><br><span class="hljs-function"></span>&#123;<br>a = a + b;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;我是函数模板&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1,<span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">(T1 a,T2 b)</span></span><br><span class="hljs-function"></span>&#123;<br>T1 x = a;<br>T2 y = b;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;我是函数模板重载&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;我是普通函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fun2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Fun(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>Fun(<span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>);<br>Fun(<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">1</span>);<br>Fun&lt;&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>Fun2(<span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>);<br>Fun2(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">3</span>);<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">我是普通函数<br>我是函数模板<br>我是函数模板重载<br>我是函数模板<br>0,0<br>97,3<br></code></pre></td></tr></table></figure><p><strong>分析：</strong></p><ul><li><code>Fun(1,2)</code>:有完全匹配的普通函数，所以调用<code>void Fun(int a, int b)</code></li><li><code>Fun(0.1,0.2)</code>:虽然普通函数<code>void Fun(int a, int b)</code>可以像<code>void Fun2(int a, int b)</code>一样进行隐式类型转换调用，倒是<code>Fun()</code>函数有更好的重载函数<code>void Fun(T1 a,T2 b)</code>模板匹配所以编译器优先调用<code>void Fun(T1 a,T2 b)</code></li><li><code>Fun(&#39;c&#39;,1)</code>:编译器能找到匹配的函数模板重载<code>void Fun(T1 a,T2 b)</code>所以优先调用函数模板</li><li><code>Fun&lt;&gt;(1,2)</code>:使用了空参数列表，告诉编译器只匹配函数模板，即使代码段中有能完美匹配的普通函数，也只调用函数模板</li></ul><h2 id="2-类模板"><a href="#2-类模板" class="headerlink" title="2.类模板"></a>2.类模板</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-comment">//定义</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TemplateA</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>TemplateA(T a)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintA</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>T a;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test</span><span class="hljs-params">(TemplateA&lt;<span class="hljs-keyword">int</span>&gt; &amp;a)</span><span class="hljs-comment">//类模板作形参</span></span><br><span class="hljs-function"></span>&#123;<br>a.PrintA();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">TemplateA&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">//使用</span><br><span class="hljs-function">TemplateA&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-string">&quot;str&quot;</span>)</span></span>;<br><span class="hljs-function">TemplateA&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-literal">true</span>)</span></span>;<br>Test(a);<br>b.PrintA();<br>c.PrintA();<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">a:</span><span class="hljs-number">1</span><br><span class="hljs-symbol">a:</span>str<br><span class="hljs-symbol">a:</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>类模板的定义和函数模板的定义类似</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>类模板的使用必须显示的确定模板的类型参数，如：<code>TemplateA&lt;string&gt; b(&quot;str&quot;)</code></p><h3 id="类模板作参数"><a href="#类模板作参数" class="headerlink" title="类模板作参数"></a>类模板作参数</h3><p>类模板作参数也必须显示的确定模板那的类型参数，如：</p><p><code>void Test(TemplateA&lt;int&gt; &amp;a)</code>以便编译器为形参确定内存空间。</p><h3 id="类模板派生普通类"><a href="#类模板派生普通类" class="headerlink" title="类模板派生普通类"></a>类模板派生普通类</h3><p>类模板也可以被继承，但是在继承时需要显示确定模板的类型参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TemplateA</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>TemplateA(T a)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintA</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>T a;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> :</span> <span class="hljs-keyword">public</span> TemplateA&lt;<span class="hljs-keyword">int</span>&gt;<span class="hljs-comment">//类模板派生普通类</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>B(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) :TemplateA(a)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;b = b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintB</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;b:&quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">int</span> b;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">B <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>b.PrintA();<br>b.PrintB();<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="模板类派生模板类"><a href="#模板类派生模板类" class="headerlink" title="模板类派生模板类"></a>模板类派生模板类</h3><p>模板类不仅可以派生普通类，还可以派生模板类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TemplateA</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>TemplateA(T a)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintA</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>T a;<br>&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1,<span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TemplateB</span> :</span> <span class="hljs-keyword">public</span> TemplateA&lt;T2&gt;<span class="hljs-comment">//类模板派生类模板</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>TemplateB(T2 a, T1 b) :TemplateA(a)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;b = b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintB</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;b:&quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>T1 b;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>TemplateB&lt;string,char&gt; b(&#x27;A&#x27;, &quot;TemplateB&quot;);<br>b.PrintA();<br>b.PrintB();<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">a:</span>A<br><span class="hljs-symbol">b:</span>TemplateB<br></code></pre></td></tr></table></figure><h3 id="类模板的主要作用"><a href="#类模板的主要作用" class="headerlink" title="类模板的主要作用"></a>类模板的主要作用</h3><p>类模板的主要作用就是将数据结构的表示和算法不受包含的元素类型的影响，即类模板将元素类型和数据结构算法分离开来了，使数据结构和算法成为真正意义上的数据结构和算法，如：链表不再因为<code>int</code>类型而定义一个<code>int</code>类型的链表，因<code>string</code>类型而定义一个<code>string</code>类型的链表，而是定义一个链表可以通用于所有类型。</p><h1 id="五、异常处理"><a href="#五、异常处理" class="headerlink" title="五、异常处理"></a>五、异常处理</h1><h2 id="1-异常的基本语法"><a href="#1-异常的基本语法" class="headerlink" title="1.异常的基本语法"></a>1.异常的基本语法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Try</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;除数不能等于0，抛出异常&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">throw</span> y;<span class="hljs-comment">//这里必须指明抛出异常的数据类型，否则程序无法处理异常，只能使用这个类型的变量，x和y的效果是一样的，不能直接抛出int，即这样是不行的throw int</span><br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;x/y=&quot;</span> &lt;&lt; x / y &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Try(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>Try(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">try</span><br>&#123;<br>Test1();<br>&#125;<br><span class="hljs-keyword">catch</span> (<span class="hljs-keyword">char</span> e)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;处理char异常&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">catch</span>(...)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;无法处理的异常继续往上抛&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">throw</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">try</span><br>&#123;<br>Test2();<br>&#125;<br><span class="hljs-keyword">catch</span>(<span class="hljs-keyword">int</span> e)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;处理int异常&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">catch</span> (...)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;处理其他异常&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-symbol">x</span>/<span class="hljs-symbol">y</span>=<span class="hljs-number">0</span><br>除数不能等于<span class="hljs-number">0</span>，抛出异常<br>无法处理的异常继续往上抛<br>处理int异常<br></code></pre></td></tr></table></figure><ul><li>异常的抛出是可以跨函数的，如上面的代码，在<code>Try</code>函数里抛出的异常可以在<code>mian</code>函数中处理，中间跨过了<code>Test1</code>，<code>Test2</code>两个函数</li><li>如果在一个函数内捕捉到异常但是却无法处理可以通过<code>throw</code>继续向上抛，直至main函数，如上面代码，<code>Test2</code>捕捉到异常但是没有处理继续向上抛给了main函数，如果main函数还是没有处理，则会直接中断程序</li><li>C++使用<code>cacth(...)</code>来捕捉其他没有捕捉到的异常，如上面代码，main函数中只捕捉了int类型的异常，如果出现其他类型的异常则有<code>cacth(...)</code>来捕捉</li><li>异常处理是按照类型匹配来处理的，即<code>throw</code>的int类型的异常只有<code>cacth(int e)</code>能够接收得到，否则就只能使用<code>cacth(...)</code>来接收未知异常</li></ul><h2 id="2-C-异常处理的特性"><a href="#2-C-异常处理的特性" class="headerlink" title="2.C++异常处理的特性"></a>2.C++异常处理的特性</h2><p>​    C++的异常处理具有跨函数性，这使得<font color="red"> 异常引发</font>和<font color="red"> 异常处理</font>分离开来，这样下层函数可以不用过多的在一异常处理，而把重点放在问题的逻辑处理上，异常处理可以由上层调用者专门来处理。</p><h2 id="3-异常接口申明"><a href="#3-异常接口申明" class="headerlink" title="3.异常接口申明"></a>3.异常接口申明</h2><p><strong>不抛出任何异常：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Try</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span><span class="hljs-comment">//异常接口申明</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;除数不能等于0，抛出异常&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">throw</span> x;<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;x/y=&quot;</span> &lt;&lt; x / y &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>只能抛出列表中类型的异常：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Try</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> <span class="hljs-title">throw</span><span class="hljs-params">(<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>*)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;除数不能等于0，抛出异常&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">throw</span> x;<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;x/y=&quot;</span> &lt;&lt; x / y &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>可以抛出任何异常：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Try</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;除数不能等于0，抛出异常&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">throw</span> x;<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;x/y=&quot;</span> &lt;&lt; x / y &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过经过测试，三份代码无论是否写throw都是可以抛出并处理异常的，似乎这个语法没什么卵用，可能C++11摒弃了这种用法，但是考虑到兼容保留这个语法。</p><h2 id="4-异常接收的3种方式"><a href="#4-异常接收的3种方式" class="headerlink" title="4.异常接收的3种方式"></a>4.异常接收的3种方式</h2><h3 id="普通形参"><a href="#普通形参" class="headerlink" title="普通形参"></a>普通形参</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>A() &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;构造A&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<br>A(<span class="hljs-keyword">const</span> A &amp;a) &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;拷贝A&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<br>~A() &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;析构A&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Try</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A a;<br><span class="hljs-keyword">throw</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">try</span><br>&#123;<br>Try();<br>&#125;<br><span class="hljs-keyword">catch</span>(A e)<span class="hljs-comment">//使用普通形参</span><br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;处理int异常&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns">构造<span class="hljs-keyword">A</span><br>拷贝<span class="hljs-keyword">A</span><br>拷贝<span class="hljs-keyword">A</span><br>析构<span class="hljs-keyword">A</span><br>处理int异常<br>析构<span class="hljs-keyword">A</span><br>析构<span class="hljs-keyword">A</span><br></code></pre></td></tr></table></figure><p>可以看到a被拷贝两次，第一次从<code>A a</code>拷贝到<code>throw a</code>，第二次从<code>throw a</code>拷贝到<code>catch(A e)</code>，可以看出如果使用普通形参来接收异常，异常变量会由异常抛出处拷贝到异常接收处。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>将上面代码的<code>catch(A e)</code>改为<code>catch(A &amp;e)</code></p><p><strong>输出结果：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">构造<span class="hljs-keyword">A</span><br>拷贝<span class="hljs-keyword">A</span><br>析构<span class="hljs-keyword">A</span><br>处理int异常<br>析构<span class="hljs-keyword">A</span><br></code></pre></td></tr></table></figure><p>可以看到只拷贝了一次，即从<code>A a</code>拷贝到<code>throw a</code>。</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>上面代码应该修改为如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>A() &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;构造A&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<br>A(<span class="hljs-keyword">const</span> A &amp;a) &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;拷贝A&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<br>~A() &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;析构A&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Try</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A *a = <span class="hljs-keyword">new</span> A();<span class="hljs-comment">//对象必须创建在堆区，函数结束对象就会被销毁，而无法通过指针传递到catch中</span><br><span class="hljs-keyword">throw</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">try</span><br>&#123;<br>Try();<br>&#125;<br><span class="hljs-keyword">catch</span>(A *e)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;处理int异常&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">delete</span> e;<span class="hljs-comment">//需要手动释放堆区的内存</span><br>&#125;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">构造<span class="hljs-keyword">A</span><br>处理int异常<br>析构<span class="hljs-keyword">A</span><br></code></pre></td></tr></table></figure><p>可以看到使用指针完全不需要拷贝，但是却需要消耗堆区的内存且容易造成内存泄露。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的来说，最优的方式还是使用引用。</p><h2 id="5-继承在异常处理中的应用"><a href="#5-继承在异常处理中的应用" class="headerlink" title="5.继承在异常处理中的应用"></a>5.继承在异常处理中的应用</h2><p>在实际的项目中我们处理的异常并不是一些基础的数据类型，大多都是开发者的自定义类，这种情况在捕捉异常的时候就相当麻烦，尽管有些异常处理起来程序基本一致，但是却要将每一种异常一一捕捉并一一处理，下面的代码我们来模拟一下这种情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>//<span class="hljs-title">A</span>类实现输入一个范围在0-10的奇数</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>A(<span class="hljs-keyword">int</span> a) <br>&#123;<br><span class="hljs-keyword">if</span> (a % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span>)<span class="hljs-keyword">throw</span> LtZero();<br><span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">10</span>)<span class="hljs-keyword">throw</span> GtTen();<br><span class="hljs-keyword">else</span> num = a;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> Even();<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">int</span> num;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LtZero</span>//专门处理异常的异常类</span><br><span class="hljs-class">&#123;</span>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GtTen</span></span><br><span class="hljs-class">&#123;</span>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Even</span></span><br><span class="hljs-class">&#123;</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">try</span> &#123; <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>; &#125;<br><span class="hljs-keyword">catch</span> (LtZero &amp;lz) &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;输入的数小于0&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<br><span class="hljs-keyword">catch</span> (GtTen &amp;gt) &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;输入的数大于10&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<br><span class="hljs-keyword">catch</span> (Even &amp;ev) &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;输入的数是偶数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<br><span class="hljs-keyword">catch</span> (...) &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;其他异常&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到我们的异常处理模块相当繁杂，在实际开发项目中异常的数量远远不止上面模拟的三种，可能多达上百种或则更多，这是异常的处理将变得十分繁杂，那么如何处理呢？</p><p>可能心细的读者会发现，我们在处理异常时使用了专门的异常处理类，而类是可以继承的，于是乎，继承在异常处理中的作用就体现出来了。</p><p>我们再来看一份优化后的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>//<span class="hljs-title">A</span>类实现输入一个范围在0-10的奇数</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>A(<span class="hljs-keyword">int</span> a) <br>&#123;<br><span class="hljs-keyword">if</span> (a % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span>)<span class="hljs-keyword">throw</span> LtZero();<br><span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">10</span>)<span class="hljs-keyword">throw</span> GtTen();<br><span class="hljs-keyword">else</span> num = a;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> Even();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Even</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintErro</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span>&lt;&lt; <span class="hljs-string">&quot;输入的数是偶数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LtZero</span>:</span><span class="hljs-keyword">public</span> Even<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintErro</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;输入的数小于0&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GtTen</span>:</span><span class="hljs-keyword">public</span> Even<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintErro</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;输入的数大于10&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">int</span> num;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">try</span> &#123; <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>; &#125;<br><span class="hljs-keyword">catch</span> (A::Even e) &#123; e.PrintErro(); &#125;<br><span class="hljs-keyword">catch</span> (...) &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;其他异常&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到我们的异常处理模块使用多态，繁杂程度被大幅缩水了，而我们的异常处理被集中在了异常处理类中，有时，如果我们的异常处理只对某一个类有效也是可以直接将异常处理类定义在抛出类里面的。</p><h2 id="6-标准异常库"><a href="#6-标准异常库" class="headerlink" title="6.标准异常库"></a>6.标准异常库</h2><p>C++提供一些标准的异常库，头文件为：#include<stdexcep></stdexcep></p><h1 id="六、标准IO流"><a href="#六、标准IO流" class="headerlink" title="六、标准IO流"></a>六、标准IO流</h1><h2 id="1-标准IO流流程"><a href="#1-标准IO流流程" class="headerlink" title="1.标准IO流流程"></a>1.标准IO流流程</h2><p><img src="/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/Snipaste_2019-10-06_10-03-47.png"></p><h2 id="2-标准输入流"><a href="#2-标准输入流" class="headerlink" title="2.标准输入流"></a>2.标准输入流</h2><table><thead><tr><th>标准函数</th><th>作用</th></tr></thead><tbody><tr><td>cin</td><td>cin&gt;&gt;操作支持任何基本类型的输入，但是遇到空格则结束读取</td></tr><tr><td>cin.get(char chr)</td><td>从缓冲区中读取一个字符到chr中，因为C++定义的cin.get(char)中会返回一个函数自身的引用，所以此函数支持链式编程，即cin.get(a).get(b).get(c);b表示依次从缓冲区中读取三个字符到a，b，c中</td></tr><tr><td>cin.get(char* buf,int cout)</td><td>从缓冲区中读取cout个字符到buf数组中，因为函数似乎会在数组末尾添加点什么，所以实际读取的字符数量是cout-1个，此函数也支持链式编程</td></tr><tr><td>cin.get(char* buf,int cout,char chr)</td><td>从缓冲区中读取cout个字符到buf数组中，如果碰到字符chr则结束读取</td></tr><tr><td>cin.getline(char buf,int cout)</td><td>从缓冲区中读取cout个字符到buf数组中</td></tr><tr><td>cin.ignore(int num)</td><td>忽略缓冲区当前读取指针开始的num个字符再读取</td></tr><tr><td>cin.peek()</td><td>判断缓冲区中是否有数据，如果有则返回第一个字符，如果没有则阻塞程序</td></tr><tr><td>cin.putback(char chr)</td><td>将读取出来的字符再返存回缓冲区，只能读取一个字符</td></tr></tbody></table><h2 id="3-标准输出流"><a href="#3-标准输出流" class="headerlink" title="3.标准输出流"></a>3.标准输出流</h2><table><thead><tr><th>标准函数</th><th>作用</th></tr></thead><tbody><tr><td>cout</td><td>输出缓冲区内容，支持任何基本类型数据的输出</td></tr><tr><td>cout.flush(void)</td><td>刷新缓冲区，无视系统繁忙，强制输出缓冲区的字符，语法和cout一样“cout.flush()&lt;&lt;buf&lt;&lt;endl;”</td></tr><tr><td>cout.put(char chr)</td><td>在标准输出设备输出指针的当前位置插入字符chr，语法和cout一致</td></tr><tr><td>cout.write(char *chr,int cout)</td><td>输出*chr所指向空间中cout个数量的字符，即使越界也会继续输出，语法和cout一致</td></tr><tr><td>cout.width(int num)</td><td>输出num个字节宽度的字符，一般配合cout.fill(char chr)和其他cout函数一起使用</td></tr><tr><td>cout.fill(char chr)</td><td>配合cout.width(int num)和其他cout一起使用，在输出的num宽度的字符中将cout函数没有填充完的字符用chr填充</td></tr><tr><td>cout.setf(标记)</td><td>格式化cout输出，标记种类很多，具体的可以查阅资料，配合cout函数一起使用</td></tr></tbody></table><h2 id="4-文件IO流"><a href="#4-文件IO流" class="headerlink" title="4.文件IO流"></a>4.文件IO流</h2><p>​    文件操作相对来说比较简单，总的来说就是5个步骤，即</p><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><ul><li><p>​    包含头文件<font color="red">#include<ftream></ftream></font></p></li><li><p>​    创建流对象</p></li><li><p>​    打开文件</p></li><li><p>​    读写文件</p><p>​    <font color="red">需要注意的是C++中文件写的方式是使用符号“&lt;&lt;”，如：fout &lt;&lt; “文件内容”&lt;&lt;endl;</font></p><p>​    <font color="red">同理文件读也可以使用“&gt;&gt;”来读。</font></p></li><li><p>​    关闭文件</p><p><strong>文件写</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ofstream fout;<br>fout.open(<span class="hljs-string">&quot;文件测试.txt&quot;</span>, ios::out);<br>fout &lt;&lt; <span class="hljs-string">&quot;姓名：张三&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>fout &lt;&lt; <span class="hljs-string">&quot;性别：男&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>fout.close();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>test();<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    <strong>输出结果：</strong>    </p><p><img src="/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/Snipaste_2019-09-14_16-29-43.png"></p><h3 id="4种文件读的方式"><a href="#4种文件读的方式" class="headerlink" title="4种文件读的方式"></a>4种文件读的方式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ifstream fin;<br>fin.open(<span class="hljs-string">&quot;文件测试.txt&quot;</span>, ios::in);<br><span class="hljs-keyword">if</span> (!fin.is_open())<span class="hljs-comment">//文件读需要多添加一步判断文件是否打开成功的步骤</span><br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;文件打开失败&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">char</span> str[<span class="hljs-number">1024</span>];<br><span class="hljs-built_in">string</span> strs;<br><span class="hljs-keyword">char</span> chr;<br><span class="hljs-comment">//第一中方式</span><br><span class="hljs-comment">//while (fin &gt;&gt; str)//操作符&quot;&gt;&gt;&quot;每次只能读取一行数据，读到文件尾“EOF”时结束</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment">//第二种方式</span><br><span class="hljs-comment">//while (fin.getline(str, 50))//ifstream::getline(char *str,int num);这个函数只支持字符数组，参数num指的是需要读取的字节数</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment">//第三种方式</span><br><span class="hljs-comment">//while (getline(fin, strs))//与第二种方式不同的是，这个getline函数是全局的，且只支持输出到string类型的对象中</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//cout &lt;&lt; strs &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment">//第四中方式</span><br><span class="hljs-keyword">while</span> ((chr = fin.get()) != EOF)<span class="hljs-comment">//get()函数每次只能读取一个字符</span><br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; chr ;<br>&#125;<br>fin.close();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>test();<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="文件的打开模式"><a href="#文件的打开模式" class="headerlink" title="文件的打开模式"></a>文件的打开模式</h3><p>​    C++提供6中文件的打开方式</p><table><thead><tr><th>打开方式</th><th>解释</th></tr></thead><tbody><tr><td>ios::in</td><td>以读的形式打开</td></tr><tr><td>ios::out</td><td>以写的形式打开，会覆盖源文件</td></tr><tr><td>ios::ate</td><td>以写的形式打开并初始文件位置：文件尾，会覆盖源文件</td></tr><tr><td>ios::app</td><td>以追加的方式打开文件</td></tr><tr><td>ios::trunc</td><td>如果文件存在先删除再创建</td></tr><tr><td>ios::binary</td><td>以二进制的形式打开</td></tr></tbody></table><h3 id="读写二进制文件"><a href="#读写二进制文件" class="headerlink" title="读写二进制文件"></a>读写二进制文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;张三&quot;</span>;<br><span class="hljs-built_in">string</span> sex = <span class="hljs-string">&quot;男&quot;</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ofstream fout;<br>fout.open(<span class="hljs-string">&quot;二进制文件测试.txt&quot;</span>, ios::out | ios::binary);<br>Person p;<br>fout.write((<span class="hljs-keyword">char</span> *)&amp;p, <span class="hljs-keyword">sizeof</span>(Person));<span class="hljs-comment">//注意这里使用ofstream::write()来写</span><br>fout.close;<br><br>ifstream fin;<br>fin.open(<span class="hljs-string">&quot;二进制文件测试.txt&quot;</span>, ios::in | ios::binary);<br><span class="hljs-keyword">if</span> (!fin.is_open())<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;文件打开错误&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>Person pin;<br>fin.read((<span class="hljs-keyword">char</span> *)&amp;pin, <span class="hljs-keyword">sizeof</span>(Person));<span class="hljs-comment">//注意这里使用ofstream::read()来读</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;姓名：&quot;</span> &lt;&lt; pin.name &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;性别：&quot;</span> &lt;&lt; pin.sex &lt;&lt; <span class="hljs-built_in">endl</span>;<br>fin.close();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>test();<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPlus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C++】C++中的四种类型转换</title>
    <link href="/2019/09/12/%E3%80%90C++%E3%80%91C++%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/"/>
    <url>/2019/09/12/%E3%80%90C++%E3%80%91C++%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>C++提供四种类型转换：const_cast、static_cast、dynamic_cast、reinterpret_cast</p><h1 id="1-const-cast"><a href="#1-const-cast" class="headerlink" title="1.const_cast"></a>1.const_cast</h1><p>​    const_cast的存在主要就是针对const字段，C++提供const_cast的目的就是为了消除const字段的const属性，让const字段也可以修改。</p><p>​    const_cast的用法：</p><p>​        const_cast只能将常指针转换为非常指针，不能直接将常字段转换为非常字段，只能通过指针类间接的修改常字段所在的内存的内容。</p><p>​        例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>* n = &amp;a;<br><span class="hljs-keyword">int</span>* m = <span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">int</span>*&gt;(n) ;<br>*m = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>​    最终的输出结果：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-attr">a</span> = <span class="hljs-number">1</span>,*<span class="hljs-attr">n</span> = <span class="hljs-number">2</span>,*<span class="hljs-attr">m</span> = <span class="hljs-number">2</span><br>&amp;<span class="hljs-attr">a=n=m</span><br></code></pre></td></tr></table></figure><p>​        奇怪，指针n，m的确指向了地址&amp;a，之中的内容的确也修改成了2，可为什么字段a的值依旧是1？</p><p>​        经过多方查阅资料和自己的试验，原来对于常字段在预编译的过程中编译器就会给常字段预定义为初始化的值，类似宏定义一般，尽管内存的内容被改变了，但是常字段的值依旧被预定义为初始化的值。</p><p>​        但是，我就疑问了，既然const_cast就是用来修改const字段的，可是只是改变了其内存的值，字段的值依旧没变，那么程序里使用该字段的地方的值依旧没有改变，如此const_cast似乎没有达到想要的结果。</p><p>​        $\color{red}{不过const_cast似乎可以修改const标识的结构体对象中没有再用const标识的字段，也可以修改用const标识的类对象中没有用const标识的公有字段，但是在结构体或类中用const标识的字段就不能再修改了。}$</p><p><img src="/2019/09/12/%E3%80%90C++%E3%80%91C++%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/Snipaste_2019-09-12_10-44-16.png"></p><h1 id="2-static-cast"><a href="#2-static-cast" class="headerlink" title="2.static_cast"></a>2.static_cast</h1><p>​    static_cast类型转换的用法几乎和C中的基本类型转换的用法一致，而C++的static_cast类型转换增加了类型检查，在安全性上较C要强。</p><p>​    static_cast支持所有类型之间的转换包括类，对于类在继承过程中的类型转换有两点是需要注意的，</p><p>一、static_cast类型转换在上行转换是安全的，在下行转换是不安全，（上行转换：从子类转换到父类，下行转换：从父类转换到子类），</p><p>二、static_cast类型转换在类的转换中因该使用指针转换，即通过指针间接的实现转换，直接对类的对象进行转换类型会被裁剪，并且在下行转换中不使用指针会报错。</p><p><img src="/2019/09/12/%E3%80%90C++%E3%80%91C++%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/Snipaste_2019-09-12_11-51-30.png"></p><h1 id="3-dynamic-cast"><a href="#3-dynamic-cast" class="headerlink" title="3.dynamic_cast"></a>3.dynamic_cast</h1><p>​    dynamic_cast类型转换用于类之间的上下行转换，与static_cast不同的是，dynamic_cast类型转换无论上下行都具有类型检查，都可以进行安全的类型转换。上行转换dynamic_cast与static_cast完全一致，下行转换dynamic_cast比static_cast更安全。</p><p>​    dynamic_cast的具体使用场景就是将父类指针转换成子类指针，但是使用条件就是只能用于含有虚函数的类，因为dynamic_cast的内部机制就是利用虚函数表里的类型信息来判断一个父类指针是否指向一个子类对象，转换失败会抛出bad_cast异常，并返回null。</p><h1 id="4-reinterpret-cast"><a href="#4-reinterpret-cast" class="headerlink" title="4.reinterpret_cast"></a>4.reinterpret_cast</h1><p>​    reinterpret_cast类型转换只能对指针进行操作，reinterpret_cast类型转换提供的是一种更底层的转换模式–比特位上的重新解释，即对某一类型的内存地址的比特位以另一种类型来解释，这可能不好理解，在这放一张图来辅助理解。</p><p><img src="/2019/09/12/%E3%80%90C++%E3%80%91C++%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/Snipaste_2019-09-12_16-32-44.png"></p><p>​    p是指向字符串的char类型指针，i是指向整型的指针，i = reinterpret_cast&lt;int*&gt;(p)则将p所指向的内存里的比特位以int类型来重新解释并复制到i所指向的内存地址上，于是在输出 *i 时，输出的是一个整型的数值。</p><p>reinterret_cast可以说是一个安全的强制类型转换了。 </p><p>​    至于为什么cout&lt;&lt;p时不是输出的p所指向的地址而是地址里的内容，我始终没有弄明白，不过不影响对reinterpret_cast类型转换的理解。</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPlus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C++】普通全局变量、静态全局变量、普通局部变量与静态局部变量</title>
    <link href="/2019/09/11/%E3%80%90C++%E3%80%91%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E9%9D%99%E6%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/"/>
    <url>/2019/09/11/%E3%80%90C++%E3%80%91%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E9%9D%99%E6%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="1-普通全局变量"><a href="#1-普通全局变量" class="headerlink" title="1.普通全局变量"></a>1.普通全局变量</h1><p>​    普通全局变量是定义在函数和类外的或由extern标识或直接定义没有static标识的变量。</p><p>​    各个类型的变量之间最主要的区别就是作用域的不同了，普通全局变量的作用域在整个源程序中，全局变量对整个源程序中都是可见的，无论源程序是由单个文件还是多个文件组成，普通全局变量具有external链接属性，所以普通全局变量在整个源程序的各个文件中都可以被引用。</p><h1 id="2-静态全局变量"><a href="#2-静态全局变量" class="headerlink" title="2.静态全局变量"></a>2.静态全局变量</h1><p>​    静态全局变量是定义在函数和类外的由static标识的变量。</p><p>​    静态全局变量具有文件作用域，具有internal链接属性，只能在定义的文件中使用，在其他文件中可以定义同名的变量，而全局变量则不行，这里要注意静态全局变量与类静态全局变量是不同的，类静态全局变量受到类权限限制，不同的访问权限就之间决定了类静态全局变量的作用域，类全局变量的使用与类一致，能使用类的地方就能使用类全局变量。</p><p>​    关于普通全局变量和静态全局变量的区别，我一直没有弄得很清楚，我有在网上查阅很多bolg，大家的说法都出奇的一致，我上面写的也是在查阅很多blog后总结的，但是我实际测试时，普通全局变量和静态全局变量似乎都可以被其他文件使用，并且 在其他文件中定义静态全局变量似乎也没有报错，没有弄明白这个其他文件指的是什么文件。</p><p><img src="/2019/09/11/%E3%80%90C++%E3%80%91%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E9%9D%99%E6%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/Snipaste_2019-09-11_21-36-28.png"></p><p><img src="/2019/09/11/%E3%80%90C++%E3%80%91%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E9%9D%99%E6%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/Snipaste_2019-09-11_21-36-38.png"></p><h1 id="3-普通局部变量"><a href="#3-普通局部变量" class="headerlink" title="3.普通局部变量"></a>3.普通局部变量</h1><p>​    普通局部变量是定义在函数内的没有static标识的变量。</p><p>​    普通局部变量具有块作用域，生命周期从定义开始到跳出函数结束，普通局部变量每次使用都会初始化一次。</p><h1 id="4-静态局部变量"><a href="#4-静态局部变量" class="headerlink" title="4.静态局部变量"></a>4.静态局部变量</h1><p>​    静态局部变量的作用于和普通局部变量一致，但是静态局部变量的内存地址在函数结束后不会被销毁，且会保存赋值结果，静态局部变量和静态全局变量一样会一直驻留在静态区，静态局部变量只会初始化一次，在下一次函数被调用时不会再初始化而是直接调用。</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPlus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C#】C#两种二维数组的区别</title>
    <link href="/2019/09/11/%E3%80%90C#%E3%80%91C#%E4%B8%A4%E7%A7%8D%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2019/09/11/%E3%80%90C#%E3%80%91C#%E4%B8%A4%E7%A7%8D%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>C#支持两种二维数组的定义方式（以int数组为例）：</p><h1 id="1-普通数组"><a href="#1-普通数组" class="headerlink" title="1.普通数组"></a>1.普通数组</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span>[,] array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><p>这种方式形式上较为简便，要注意的是new之后的[]里面是一定要注明数组大小的，不注明会报错，也就是说这种方式定义的数组是确定大小的。</p><p>数组的赋值：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span>[,] array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-多播数组"><a href="#2-多播数组" class="headerlink" title="2.多播数组"></a>2.多播数组</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span>[][] array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">2</span>][];<br></code></pre></td></tr></table></figure><p>这种方式需要注明行数，列数不能注明，注明会报错，这种方式定义的是一个函数确定而列数不确定的不确定大小的数组。</p><p>数组的赋值：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span>[][] array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">2</span>][]&#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;&#125;<br></code></pre></td></tr></table></figure><p>两种二维数组是不能兼容的，即使用方式1定义的二维数组不能使用方式2来使用，反之亦然。</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Lua】Lua基础</title>
    <link href="/2019/09/09/%E3%80%90Lua%E3%80%91Lua%E5%9F%BA%E7%A1%80/"/>
    <url>/2019/09/09/%E3%80%90Lua%E3%80%91Lua%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://img-blog.csdnimg.cn/2019090916141255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190909161442706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>参考博文：<a href="https://www.cnblogs.com/cjswwdz/p/5634442.html">https://www.cnblogs.com/cjswwdz/p/5634442.html</a></p><p>XMind源文件：<a href="https://github.com/Goulandis/XMinds-2019.8.27/tree/master/Lua">https://github.com/Goulandis/XMinds-2019.8.27/tree/master/Lua</a></p><p>学习地址：<a href="https://www.bilibili.com/video/av50685253?from=search&amp;seid=12754355294240767428">https://www.bilibili.com/video/av50685253?from=search&amp;seid=12754355294240767428</a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lua</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Unity3d】Space</title>
    <link href="/2019/08/25/%E3%80%90Unity3d%E3%80%91Space/"/>
    <url>/2019/08/25/%E3%80%90Unity3d%E3%80%91Space/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="/2019/08/25/%E3%80%90Unity3d%E3%80%91Space/Unity3d_Space.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity3d</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Unity3d】Lightmap</title>
    <link href="/2019/08/25/%E3%80%90Unity3d%E3%80%91Lightmap/"/>
    <url>/2019/08/25/%E3%80%90Unity3d%E3%80%91Lightmap/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="/2019/08/25/%E3%80%90Unity3d%E3%80%91Lightmap/Unity_Lightmap.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity3d</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【计算机网络】网络游戏基础</title>
    <link href="/2019/08/25/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%9F%BA%E7%A1%80/"/>
    <url>/2019/08/25/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="/2019/08/25/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%9F%BA%E7%A1%80.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序编程高级</title>
    <link href="/2019/08/25/%E3%80%90%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E3%80%91%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7/"/>
    <url>/2019/08/25/%E3%80%90%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E3%80%91%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="/2019/08/25/%E3%80%90%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E3%80%91%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程序编程原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【计算机网络】物联网通信基础</title>
    <link href="/2019/08/25/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E7%89%A9%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/"/>
    <url>/2019/08/25/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E7%89%A9%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="/2019/08/25/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E7%89%A9%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/%E7%89%A9%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【QT】 Qt基础</title>
    <link href="/2019/08/25/%E3%80%90Qt%E3%80%91Qt%E5%9F%BA%E7%A1%80/"/>
    <url>/2019/08/25/%E3%80%90Qt%E3%80%91Qt%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>﻿<img src="https://img-blog.csdnimg.cn/20190825185005696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux基础</title>
    <link href="/2019/08/25/%E3%80%90Linux%E3%80%91Linux%E5%9F%BA%E7%A1%80/"/>
    <url>/2019/08/25/%E3%80%90Linux%E3%80%91Linux%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><center>Linux学习笔记</center><h1 id="l-pwd：查看当前所在路"><a href="#l-pwd：查看当前所在路" class="headerlink" title="l  pwd：查看当前所在路"></a>l  <strong>pwd</strong>：查看当前所在路</h1><p>命令格式：命令 -选项 -参数（目录）</p><p>命令：</p><p>ls：查看当前路径下的文件</p><p>选项：</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td><strong>-d</strong></td><td>只查看当前目录的信息</td></tr><tr><td><strong>-l</strong></td><td>查看详细信息</td></tr><tr><td><strong>-a</strong></td><td>显示所有文件（包含隐藏文件）</td></tr><tr><td><strong>-h</strong></td><td>显示文件大小</td></tr></tbody></table><p>例：ls -l     命令 -选项</p><p>选项可以组合：ls -a -l/ls -al：查看所有文件的详细信息</p><p>ls -al /etc/   命令 -选项 -参数 ：查看etc目录下的所有文件的详细信息</p><h1 id="l-cd-：-路径切换"><a href="#l-cd-：-路径切换" class="headerlink" title="l  cd ： 路径切换"></a>l  <strong>cd</strong> <strong>：</strong> <strong>路径切换</strong></h1><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>“**-**”</td><td>返回到之前目录</td></tr><tr><td>“**..**”</td><td>返回上一级目录（“.”当前目录，“..”上一级目录）</td></tr><tr><td>“**~**”</td><td>到用户所在的家目录（家目录：用户所在目录，如windowsC盘的用户目录）</td></tr></tbody></table><p>touch ：cd到临时目录tmp下可创建新文件    touch 文件名</p><h1 id="l-Linux目录结构"><a href="#l-Linux目录结构" class="headerlink" title="l  Linux目录结构"></a>l  <strong>Linux目录结构</strong></h1><table><thead><tr><th>文件名</th><th>作用</th></tr></thead><tbody><tr><td>/boot</td><td>linux启动时，需要的文件</td></tr><tr><td>/dve</td><td>设备文件</td></tr><tr><td>/etc</td><td>配置文件</td></tr><tr><td>/home</td><td>用户家目录</td></tr><tr><td>/media</td><td>媒体文件</td></tr><tr><td>/mnt</td><td>挂载文件</td></tr><tr><td>/opt</td><td>第三方软件</td></tr><tr><td>/proc</td><td>虚拟化文件</td></tr><tr><td>/root</td><td>管理员的家目录</td></tr><tr><td>/run</td><td>远程文件</td></tr><tr><td>/srv</td><td>压缩过的文件</td></tr><tr><td>/sys</td><td>系统文件</td></tr><tr><td>/usr</td><td>安装的软件，</td></tr><tr><td>/var</td><td>可变数据、日志</td></tr><tr><td>/tmp</td><td>临时文件</td></tr><tr><td>/usr/bin</td><td>普通用户可以使用的命令</td></tr><tr><td>/usr/sbin</td><td>超级用户可以使用的命令</td></tr><tr><td>/usr/lib</td><td>32位库文件</td></tr><tr><td>/usr/lib64</td><td>64位库文件</td></tr></tbody></table><h1 id="l-Linux文件处理"><a href="#l-Linux文件处理" class="headerlink" title="l  Linux文件处理"></a>l  <strong>Linux文件处理</strong></h1><h2 id="文件类型判断："><a href="#文件类型判断：" class="headerlink" title="文件类型判断："></a><strong>文件类型判断：</strong></h2><p>-ls -l</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811223714.png" alt="img"></p><table><thead><tr><th>文件以“_”开头</th><th>文件类型</th></tr></thead><tbody><tr><td>“d”</td><td>目录</td></tr><tr><td>“-”</td><td>文件</td></tr><tr><td>“l”</td><td>链接文件（类似win中快捷方式）</td></tr><tr><td>“b”</td><td>设备文件，提供存储接口的设备</td></tr><tr><td>“c”</td><td>设备文件，提供串行结合口的设备—键盘</td></tr></tbody></table><h2 id="文件处理："><a href="#文件处理：" class="headerlink" title="文件处理："></a><strong>文件处理：</strong></h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811223801.png" alt="img"></p><p>cp            cp abc a：复制abc并命名为a/多文件复制：cp a abc goulandis/：复制a、abc到goulandis下</p><p>mv            mv 文件1 文件2：将文件1更名为文件2/mv 文件1（文件2 ….） 目录：将文件移动到目录下                 </p><p>rm             rm -f 文件1 （文件2…）：强制删除</p><p>mkdir       mkdir -p （要创建的）目录1/（要创建的）目录2：创建目录1并在目录1下创建目录2</p><h2 id="查看文件："><a href="#查看文件：" class="headerlink" title="查看文件："></a><strong>查看文件：</strong></h2><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><strong>cat/**</strong>路径**</td><td>查看文件</td></tr><tr><td>nl</td><td>显示的时候，顺便出现行号</td></tr><tr><td>tac</td><td>从最后一行开始显示</td></tr><tr><td>head</td><td>显示文件前10行 -n：设置行数</td></tr><tr><td>tail</td><td>显示文件尾10行 -n：设置行数</td></tr><tr><td>wc</td><td>显示文件行数，数字，字节</td></tr><tr><td>more</td><td>一页一页翻动</td></tr><tr><td><strong>less</strong></td><td>一页一页翻动</td></tr></tbody></table><table><thead><tr><th><strong>cat**</strong>和tac**<strong>选项</strong></th><th>作用</th></tr></thead><tbody><tr><td>-A</td><td>整合命令-vET（整合-v、-E、-T）</td></tr><tr><td>-b</td><td>列出行号，但是空白行不标志行号</td></tr><tr><td>-E</td><td>将结尾的断行字符（$）显示出来</td></tr><tr><td>-n</td><td>列出行号，空白行也会标志出来</td></tr><tr><td>-T</td><td>将tab键以^I显示</td></tr><tr><td>-v</td><td>列出一些看不出来的字符</td></tr><tr><td>&lt;区分大小写&gt;</td><td></td></tr></tbody></table><table><thead><tr><th><strong>nl**</strong>的选项**</th><th></th><th></th></tr></thead><tbody><tr><td>总选项</td><td>分选项</td><td>作用</td></tr><tr><td>b</td><td>ba</td><td>无论是否有空，都列出行号</td></tr><tr><td>bt</td><td>如果有空行，则不列出行号（默认）</td><td></td></tr><tr><td>n</td><td>nln</td><td>行号在屏幕最左方</td></tr><tr><td>nrn</td><td>行号在屏幕最右方，前面不加0</td><td></td></tr><tr><td>nrz</td><td>行号在屏幕最右方，前面加0</td><td></td></tr><tr><td>w</td><td></td><td>缩进多少位</td></tr></tbody></table><table><thead><tr><th><strong>more**</strong>的选项**</th><th>作用</th></tr></thead><tbody><tr><td>空格</td><td>向下翻一页</td></tr><tr><td>回车</td><td>向下翻一行</td></tr><tr><td>/字符串</td><td>搜索</td></tr><tr><td>:f</td><td>立刻显示文件名和行数</td></tr><tr><td>b</td><td>翻到第一页</td></tr><tr><td>q</td><td>离开</td></tr></tbody></table><table><thead><tr><th><strong>less**</strong>的选项**</th><th>作用</th></tr></thead><tbody><tr><td><strong>空格</strong></td><td>向下翻动一行</td></tr><tr><td><strong>回车</strong></td><td>向下翻动一页</td></tr><tr><td><strong>pagedown</strong></td><td>向下翻动一页</td></tr><tr><td><strong>pageup</strong></td><td>向上翻动一页</td></tr><tr><td><strong>n</strong></td><td>重复前一个搜索（操作：n）</td></tr><tr><td><strong>N</strong></td><td>反向重复前一个搜索（操作：shift+n）</td></tr><tr><td><strong>q</strong></td><td>退出</td></tr></tbody></table><table><thead><tr><th>head和tail的选项</th><th>作用</th></tr></thead><tbody><tr><td>-n</td><td>指定显示几行，默认10行</td></tr><tr><td>日志文件路径（/var/log/messages）</td><td>查看日志</td></tr></tbody></table><table><thead><tr><th>wc的选项</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>只显示字节</td></tr><tr><td>-w</td><td>只显示字数，一个字被定义为空白、跳格、换行字符、分隔字符串</td></tr><tr><td>-l</td><td>只显示行</td></tr></tbody></table><table><thead><tr><th><strong>Vim编辑器操作命令</strong></th><th>作用</th></tr></thead><tbody><tr><td><strong>i</strong></td><td>插入</td></tr><tr><td><strong>esc</strong></td><td>退出</td></tr><tr><td><strong>u</strong></td><td>撤销</td></tr><tr><td><strong>x</strong></td><td>删除</td></tr><tr><td><strong>v</strong></td><td>选择文本</td></tr><tr><td><strong>y</strong></td><td>复制</td></tr><tr><td><strong>yy</strong></td><td>复制当前行</td></tr><tr><td><strong>dd</strong></td><td>删除光标所在行</td></tr><tr><td><strong>p</strong></td><td>粘贴</td></tr><tr><td><strong>:w</strong></td><td>保存</td></tr><tr><td><strong>:wq</strong></td><td>保存并退出</td></tr><tr><td><strong>:q**</strong>！**</td><td>强制退出</td></tr></tbody></table><h2 id="软链接："><a href="#软链接：" class="headerlink" title="软链接："></a><strong>软链接：</strong></h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811223809.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811223812.png" alt="img"></p><h2 id="硬链接："><a href="#硬链接：" class="headerlink" title="硬链接："></a><strong>硬链接：</strong></h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811223815.png"></p><p>ls -I ：查看Inode编号</p><h1 id="l-关机操作"><a href="#l-关机操作" class="headerlink" title="l  关机操作"></a>l  <strong>关机操作</strong></h1><table><thead><tr><th>sync</th><th>数据同步写入磁盘</th></tr></thead><tbody><tr><td><strong>shutdown</strong></td><td>常用关机指令</td></tr><tr><td>reboot、halt、poweroff</td><td>重启，关机</td></tr></tbody></table><table><thead><tr><th>shutdown的指令</th><th>作用</th></tr></thead><tbody><tr><td>-t</td><td>添加秒数。几秒后关机</td></tr><tr><td>-k</td><td>不是真关机，二十发出警告信息</td></tr><tr><td><strong>-r</strong></td><td>在系统服务都停止后，重启</td></tr><tr><td><strong>-h</strong></td><td>在系统服务都停止后，关机</td></tr><tr><td>-f</td><td>关闭，并且开机一个后强行略过磁盘检查</td></tr><tr><td>-F</td><td>重启后强制进行磁盘检查</td></tr><tr><td>-c</td><td>取消已经在进行的shutdown指令内容</td></tr><tr><td></td><td>shutdown -h now    现在马上停止服务并关机   shutdown -h 12：00       在12：00时刻停止服务并关机   shutdown -h +10     十分钟以后停止服务并关机   shutdown -r now     现在马上停止服务并重启   shutdown -r +30 ‘the system will reboot’       先发一个警告信息“the system will reboot”，系统将要在30分钟后重启   shutdown -k now ‘the system will reboot’     现在马上发出一个警告信息“the system will reboot”</td></tr></tbody></table><h1 id="l-Linux文件权限"><a href="#l-Linux文件权限" class="headerlink" title="l  Linux文件权限"></a>l  <strong>Linux文件权限</strong></h1><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811223822.png" alt="img"></p><table><thead><tr><th>权限</th><th>连接</th><th>所有者</th><th>所属组</th><th>容量（默认单位B）</th><th>修改日期</th><th>文件名</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th><strong>文件的权限</strong></th><th></th></tr></thead><tbody><tr><td>r、w、x ： 读、写、执行，没有权限就是-</td><td></td></tr><tr><td>第一组rwx</td><td>文件所有者的权限</td></tr><tr><td>第二组rwx</td><td>文件所属组的权限</td></tr><tr><td>第三组rwx</td><td>文件其他人的权限</td></tr></tbody></table><table><thead><tr><th><strong>目录的权限</strong></th><th></th></tr></thead><tbody><tr><td>r</td><td>具有读取目录的结构列表的权限，可以查看目录下有哪些文件</td></tr><tr><td>w</td><td>该权限对于目录来说是很大的</td></tr><tr><td>1</td><td>可以在该目录下新建新的文件和目录</td></tr><tr><td>2</td><td>可以删除已存在的文件和目录</td></tr><tr><td>3</td><td>将已存在的文件和目录重命名</td></tr><tr><td>4</td><td>移动该目录内的文件和目录的位置</td></tr><tr><td>X</td><td>是否可以进入该目录</td></tr></tbody></table><table><thead><tr><th><strong>文件权限的修改</strong></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>命令</td><td>命令作用</td><td>格式</td><td>选项</td><td>选项作用</td><td></td></tr><tr><td>chown</td><td>修改文件的拥有者，前提是要有该拥有者</td><td>chown 拥有者   文件/目录</td><td>-R</td><td>递归修改</td><td></td></tr><tr><td>chgrp</td><td>修改文件所属组，前提是要有该组</td><td></td><td>-R</td><td>递归修改</td><td></td></tr><tr><td>chmod</td><td>修改拥有者和所属组的权限</td><td></td><td></td><td></td><td></td></tr><tr><td>加减法</td><td>chmod    u/g/o+/-/=r/w/x 123：   将文件1213给用户/组/其他人加/减/赋予一个读/写/执行权限</td><td></td><td></td><td></td><td></td></tr><tr><td>数字法</td><td>r=4    w=2  x=1 ： chmod  632 123 ：   将文件123给用户赋予r和w权限，给组赋予wx权限，给其他人赋予w权限</td><td></td><td></td><td></td><td></td></tr><tr><td>chown -R goulandis 123 ： 将123目录下的所有文件包括目录本身的拥有者修改为goulandis</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p><strong>默认权限：</strong></p><p>umask      查看当前用户的umask权限       </p><p>umask –(选项) ：临时修改默认权限</p><p>/etc/bashrc ： 永久修改默认权限（通过修改脚本文件实现）</p><p>umask的选项说明</p><p>0022         拿走的权限</p><p>​         第一个数字表示特殊权限</p><p>​         022=rwxr-xr-x ：不拿走用户的权限、拿走用户组的w权限、拿走其他用户的w权限</p><p>目录无法拿走x权限</p><p>普通用户umask值 0002</p><p>root用户umask值 0022</p><h2 id="文件的特殊权限"><a href="#文件的特殊权限" class="headerlink" title="文件的特殊权限:"></a><strong>文件的特殊权限:</strong></h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811223827.png" alt="img"></p><p>当s出现在拥有者的x权限的位置时，表示拥有者有SUID的权限（Set UID）</p><p>当s出现在用户组的x权限的位置时，表示用户组有SGID的权限（Set GID）</p><p>当s出现在其他人的x权限的位置时，表示其他人有SBIT的权限（Sticky Bit）</p><table><thead><tr><th>SUID</th><th>临时获取文件拥有者的权限—–只能针对文件</th></tr></thead><tbody><tr><td>SGID</td><td>可以作用于目录，也可以作用于文件</td></tr><tr><td>作用于文件 ： 和SUID作用一样</td><td></td></tr><tr><td>作用与目录 ： 继承父级目—–目录会不停的继承，下级目录会一直继承父级目录的权限值</td><td></td></tr><tr><td>SBIT</td><td>只有文件的拥有者才能删除修改该目录下的文件—–只能针对目录</td></tr><tr><td>S和T有大小写之分   大写 ： 没有x权限   小写 ： 有x权限</td><td></td></tr><tr><td>数字法 ：SUID=4、SGID=2、SBIT=1</td><td></td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811223832.png" alt="img"></p><h1 id="l-Linux进程"><a href="#l-Linux进程" class="headerlink" title="l  Linux进程"></a>l  <strong>Linux进程</strong></h1><p>进程 ：已经启动的可执行程序的运行实例</p><p>PID : 进程的ID（每一个进程都有唯一的PID）</p><p>PPID ： 父进程的ID</p><p>任何一个进程都可以创建紫进程</p><table><thead><tr><th>ｐｓ　：　查看当前的进程情况</th><th></th></tr></thead><tbody><tr><td>选项</td><td>作用</td></tr><tr><td>－ａｕｘ／ａｕｘ</td><td>列出所有进程</td></tr><tr><td>－ｅｆ</td><td>列出所有进程</td></tr><tr><td>－ｌ</td><td>列出和当前用户有关的进程</td></tr><tr><td>－ｕ</td><td>查看某一用户的进程</td></tr><tr><td>－ｔｏｐ</td><td>实时查看进程状况</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811223836.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#高级</title>
    <link href="/2019/08/25/%E3%80%90C#%E3%80%91C#%E9%AB%98%E7%BA%A7/"/>
    <url>/2019/08/25/%E3%80%90C#%E3%80%91C#%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20190825170050917.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190825170113521.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20190825170131207.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#中级</title>
    <link href="/2019/08/25/%E3%80%90C#%E3%80%91C#%E4%B8%AD%E7%BA%A7/"/>
    <url>/2019/08/25/%E3%80%90C#%E3%80%91C#%E4%B8%AD%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<p>﻿<img src="https://img-blog.csdnimg.cn/20190825154217891.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C++】C++进阶</title>
    <link href="/2019/08/23/%E3%80%90C++%E3%80%91C++%E8%BF%9B%E9%98%B6/"/>
    <url>/2019/08/23/%E3%80%90C++%E3%80%91C++%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="1-C-介绍"><a href="#1-C-介绍" class="headerlink" title="1.C++介绍"></a>1.C++介绍</h1><p>​    C语言作为结构化和模块化语言适合规模较小的程序，对于大规模的复杂程序，能够高度抽象和建模的C++则更加适合，C++是C语言的加强版，以C语言为基础，并且完全兼容C语言的特性。<br><img src="https://img-blog.csdnimg.cn/20190623193001260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="2-C-对C语言的增强语法"><a href="#2-C-对C语言的增强语法" class="headerlink" title="2.C++对C语言的增强语法"></a>2.C++对C语言的增强语法</h1><p>​    2.1.命名空间<br>​    2.2.引用<br>​    2.3.函数与运算符的重载<br>​    2.4.面向对象的特性<br>​    2.5.泛型编程<br>​    2.6.异常处理<br>​    2.7.标准模板库<br>下面笔者就者7个特性进行详细说明：</p><h1 id="3-命名空间"><a href="#3-命名空间" class="headerlink" title="3.命名空间"></a>3.命名空间</h1><p>​    命名空间是C++提供的一种解决不同文件互相调用时符号名字冲突的方法，一个命名空间就是一个作用域，在不同的命名空间下允许相同的名字符号代表不同的实体。</p><h2 id="3-1命名空间的定义"><a href="#3-1命名空间的定义" class="headerlink" title="3.1命名空间的定义"></a>3.1命名空间的定义</h2><p><img src="https://img-blog.csdnimg.cn/20190623200228628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>        注意：命名空间的声明要在类和函数的外面定义，并且没有分号结束。</p><h2 id="3-2-命名空间成员的引用"><a href="#3-2-命名空间成员的引用" class="headerlink" title="3.2.命名空间成员的引用"></a>3.2.命名空间成员的引用</h2><p>命名空间名::成员名<br>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//1.cpp</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> namesapce <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">namespace</span> A &#123;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mian</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>,b = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; add(a,b)&lt;&lt;<span class="hljs-string">&quot;  &quot;</span>&lt;&lt;A::add(a,b)&lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br><span class="hljs-keyword">return</span>(a + b);<br>&#125;<br><br><span class="hljs-comment">//2.cpp</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">namespace</span> A &#123;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br><span class="hljs-keyword">return</span>(a + b)；<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>命名空间的声明方式，我们需要用到命名空间中的什么方法就在{}内加入什么方法的声明，当然直接使用“using namespace A”来声明A命名空间也是可以的，但是这种命名方法会将A命名空间下的所有方法都作声明，包括我们可能没有使用的方法，当工程很大时，这种做法会导致代码臃肿。</p><p>在很多人编程的时候，如果各程序员之间不一直进行密切的交流，极容易出现变量名或方法名类名等相同的情况，这样    在多文档联合编译时，编译器会无法区分同名符号而报错，而命名空间就很好的解决了这种问题，我们为各个文档都定义一个唯一的命名空间，这样即使是相同符号也可以通过命名空间唯一标识了，命名空间的出现极大的改善了多人编程的困处。</p><h2 id="3-3-命名空间的别名"><a href="#3-3-命名空间的别名" class="headerlink" title="3.3.命名空间的别名"></a>3.3.命名空间的别名</h2><p>命名空间是可以另起别命的，别命是已定义的命名空间的可代替的名字，一个命名空间可以有很多个别名，所有的别命和命名空间原名可以互换使用<br>别命的定义：namespace 别命 = 命名空间原名;<br>    <img src="https://img-blog.csdnimg.cn/2019062320111766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="3-4-命名空间的成员类型"><a href="#3-4-命名空间的成员类型" class="headerlink" title="3.4.命名空间的成员类型"></a>3.4.命名空间的成员类型</h2><p>命名空间的成员类型可以是变量、常量、函数、结构体、联合体、枚举、类、嵌套的命名空间</p><h2 id="3-5-全局命名空间"><a href="#3-5-全局命名空间" class="headerlink" title="3.5.全局命名空间"></a>3.5.全局命名空间</h2><p>在全局作用域中定义的命名空间，大多数命名空间都属于全局命名空间。即自定义的命名空间是全局命名空间的扩张和细分。全局命名空间是隐式声明的，它存在于每一个程序中。<br>由于全局命名空间是隐含的，它没有名字，所以使用“::成员名字”引用全局命名空间。</p><h2 id="3-6-匿名命名空间"><a href="#3-6-匿名命名空间" class="headerlink" title="3.6.匿名命名空间"></a>3.6.匿名命名空间</h2><p>匿名命名空间与全局命名空间类似，也没有名字，但是匿名命名空间定义在局部作用域，不能用于多文件编译。<br>匿名命名空间可以直接使用变量名引用成员。</p><h1 id="4-引用"><a href="#4-引用" class="headerlink" title="4.引用"></a>4.引用</h1><h2 id="4-1-什么是引用？"><a href="#4-1-什么是引用？" class="headerlink" title="4.1.什么是引用？"></a>4.1.什么是引用？</h2><p>引用即别命，是某一个变量或对象的别命，绑定一个引用到一个变量或对象，即引用初始化，之后对引用的操作完全等价于对与其绑定的变量或对象的操作。</p><h2 id="4-2-引用的定义"><a href="#4-2-引用的定义" class="headerlink" title="4.2.引用的定义"></a>4.2.引用的定义</h2><p>类型 &amp;引用名 = 目标变量名;<br>需要注意的是：</p><ul><li>&amp;不是求地址运算符，而是起标志作用</li><li>引用的类型必须和其所绑定的变量类型相同</li><li>声明应用的同时必须对其初始化，否则系统会报错</li><li>引用相当于变量或对象的别命，因此不可将已绑定的引用再绑定其他变量或对象，也不可将一个引用绑定另一个引用。</li></ul><h2 id="4-3-引用与指针的区别"><a href="#4-3-引用与指针的区别" class="headerlink" title="4.3.引用与指针的区别"></a>4.3.引用与指针的区别</h2><ul><li><p>占用存储空间上：<br>引用占用一个地址空间，本地计算机的一个地址空间是多少位，引用就占多少位的地址空间。<br>而指针除了占用一个地址空间外，还占用一个数据空间用于存储其指向的变量或对象的地址。</p></li><li><p>在操作上：<br>引用声明的同时必须对其初始化，且初始化后引用不可更改，引用不能为空。如：int &amp;a ;是错误的用法，正确的用法应该是：int &amp;a = b;<br>指针的声明可以在任何时候初始化，且指针在后续操作中可以变更其指向的变量或对象，指针可以为空。</p></li><li><p>存储内容上<br>“sizeof引用”得到的是引用所指向的变量或对象的大小<br>“sizeof指针”得到的是指针本身的大小</p></li><li><p>层级上<br>引用只能有一级，引用不可以再指向引用<br>指针理论上对级数没有限制</p></li><li><p>可以将引用理解为不可更改的指针，即：类型* const 指针变量</p></li></ul><h2 id="4-4-对数组的引用"><a href="#4-4-对数组的引用" class="headerlink" title="4.4.对数组的引用"></a>4.4.对数组的引用</h2><p>类型 （&amp;引用名）[数组下标] = 数组名;<br>如：对int a[3]数组的引用为int (&amp;quote)[3] = a;即将引用名替换成数组名。<br>这里要注意，“()”是不能省略的，因为如果省略()，则会改变优先级，变成int &amp;(quote[3]) = a;而出现语法错误。</p><h2 id="4-5-对指针的引用"><a href="#4-5-对指针的引用" class="headerlink" title="4.5.对指针的引用"></a>4.5.对指针的引用</h2><p>类型* &amp;引用名 = 指针名;<br>如：int* &amp;quote = p;</p><h2 id="4-6-引用的作用"><a href="#4-6-引用的作用" class="headerlink" title="4.6.引用的作用"></a>4.6.引用的作用</h2><p>引用既可以作为别命使用，还可以作为函数的参数、函数的返回值使用。<br>需要注意的是，引用作为函数的返回值时不能返回局部变量的引用。<br>至此，我可能提出这样的疑问：引用能做的事指针也能做，引用不能做的事指针还能做，那么C++么什么要引入“引用”这个概念呢？<br>这是因为，指针的操作太过于强大，正因如此对指针的使用存在一定的风险，所谓“收益与风险并存”，在很多高版本的编译器中已经不能再操作指针了，如VS2015，而C++之所以还保留着指针，是因为指针的魅力无比诱人，尽管有风险却不愿意就此抛弃。<br>引用的另一个用处我们举一个例子来说明<br>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add_1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> b)</span></span>&#123;<br>b++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add_2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;c)</span></span>&#123;<br>c++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mian</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> &amp;a = a;<br><span class="hljs-built_in">cout</span>&lt;&lt;add_1(a)&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;add_2(&amp;a)&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们的输出结果是：1 2，为什么呢?因为普通的参数传递，传递的是参数的拷贝，如add_1我们对b++，实际进行运算的是形参b，而实参a却没有发生运算，所以cout&lt;&lt;add_1(a)输出1，而如果传递引用的话，我们在函数add_2中对引用的操作实质上就是对a进行运算，因为&amp;a就是a。</p><h2 id="4-7-常引用"><a href="#4-7-常引用" class="headerlink" title="4.7.常引用"></a>4.7.常引用</h2><p>const 类型 &amp;引用名 = 目标变量名<br>常引用可以引用常量也可以引用变量，常引用不允许通过引用对其绑定的变量或对象进行修改。</p><h2 id><a href="#" class="headerlink" title></a><img src="https://img-blog.csdnimg.cn/2019062512243728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></h2><h1 id="5-函数重载"><a href="#5-函数重载" class="headerlink" title="5.函数重载"></a>5.函数重载</h1><h2 id="5-1-C-重载的实现"><a href="#5-1-C-重载的实现" class="headerlink" title="5.1.C++重载的实现"></a>5.1.C++重载的实现</h2><p>从本质上来说，C++之所以能实现函数的重载是因为C++编译器对函数名的处理方法进行了优化，我们来对比一下C语言编译器和C++编译器对函数名的编译</p><ul><li><p>C语言编译器<br>对函数 int add(int a);编译后的名字为：add</p></li><li><p>C++编译器<br>对函数int add(int a);编译后的名字为：addi，对int add(int a,float b);编译后的名字为：addij，C++编译器使用函数名和参数类型的共同组合成编译后函数的唯一标识，即可实现函数的重载。</p></li></ul><h2 id="5-2-重载的定义"><a href="#5-2-重载的定义" class="headerlink" title="5.2.重载的定义"></a>5.2.重载的定义</h2><p>重载就是在相同的声明域中函数名相同而参数列表不同，通过函数的参数表唯一标识的函数。</p><h2 id="5-3-函数的默认参数"><a href="#5-3-函数的默认参数" class="headerlink" title="5.3.函数的默认参数"></a>5.3.函数的默认参数</h2><p>C++可以使用默认参数，即在函数声明时为参数提供一个默认值，当函数调用时没有指定这个参数的值时，编译器会自动使用默认值替换。<br><img src="https://img-blog.csdnimg.cn/20190625221621705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>需要注意的是，默认参数只能放在声明或定义处，能放在声明处就放在声明处。如果某个参数是默认参数，那么其后的参数也必须都是默认参数，如：<code>int add(int a = 1,int b,int c);</code>编译器将报错，而<code>int add(int a,int b = 1,int c = 2);</code>则不会报错，因为参数在传递的时候是从左到右的，首先使用无默认参数的参数列表，当遇到没有传入实参的形参时开始使用默认参数的参数列表。使用默认参数的情况仅限于用在没有没有重载冲突的函数上，如：重载add函数，<code>int add()&#123;...&#125; int add(int a = 1,int b = 2)&#123;...&#125;</code>,此时调用add();将调用不带参数的add()函数。<br><img src="https://img-blog.csdnimg.cn/20190625222013457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="5-4-内联函数"><a href="#5-4-内联函数" class="headerlink" title="5.4.内联函数"></a>5.4.内联函数</h2><h3 id="5-4-1-为什么需要内联函数？"><a href="#5-4-1-为什么需要内联函数？" class="headerlink" title="5.4.1.为什么需要内联函数？"></a>5.4.1.为什么需要内联函数？</h3><p>在程序执行的过程中，当碰到函数调用时，系统要将程序当前状态保存到栈中，同时跳转到函数代码处执行函数体，此过程需要占用时间和空间，是的程序执行效率低下。当然我们声明一个内联函数只是建议编译器将此函数作为内联函数，但是编译器有自己的判断算法，在编译时编译器会自行判断我们声明的内联函数是否值得变为内联函数，以保证主程序体不会过于臃肿，所以我们声明的内联函数不一定会成为内联函数。</p><h3 id="5-4-2-内联函数的定义"><a href="#5-4-2-内联函数的定义" class="headerlink" title="5.4.2.内联函数的定义"></a>5.4.2.内联函数的定义</h3><p>inline 返回值类型 函数名(参数列表){函数体;} </p><h3 id="5-4-3-内联函数是一种用空间换时间的措施，通常只有较短的函数才定义为内联函数。"><a href="#5-4-3-内联函数是一种用空间换时间的措施，通常只有较短的函数才定义为内联函数。" class="headerlink" title="5.4.3.内联函数是一种用空间换时间的措施，通常只有较短的函数才定义为内联函数。"></a>5.4.3.内联函数是一种用空间换时间的措施，通常只有较短的函数才定义为内联函数。</h3><h1 id="6-new和delete运算符"><a href="#6-new和delete运算符" class="headerlink" title="6.new和delete运算符"></a>6.new和delete运算符</h1><h2 id="6-1-new运算符"><a href="#6-1-new运算符" class="headerlink" title="6.1.new运算符"></a>6.1.new运算符</h2><p>new运算符的功能是在堆区分配内存，通过new运算符获得的内存空间都处于堆上。delete运算符的功能正好与new相反，delete运算符的功能是释放new运算符的在堆区创建的内存，new运算符与delete运算符最好是配套出现，即使用new运算符创建了内存就一定要用delete运算符在不需要的时候此内存的时候将其释放，为什么呢？因为堆区的内存是不会随着程序结束而释放的，堆区的内存只要在操作系统关闭时才会释放，所以如果不手动释放new运算符在堆区创建的内存，则会造成大量无用数据占据着堆区内存，当堆区内存被占满时这会出现系统无堆区内存可用而出现系统死机。</p><h2 id="6-2-new-delete运算符的使用"><a href="#6-2-new-delete运算符的使用" class="headerlink" title="6.2.new/delete运算符的使用"></a>6.2.new/delete运算符的使用</h2><p>new &lt;数据类型&gt; (参数)<br>delete &lt;对象指针&gt;/delete &lt;对象数组指针&gt;<br><img src="https://img-blog.csdnimg.cn/201907121654256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="6-3-那么C-的new-delete与C语言的malloc-free有什么区别呢？"><a href="#6-3-那么C-的new-delete与C语言的malloc-free有什么区别呢？" class="headerlink" title="6.3.那么C++的new/delete与C语言的malloc/free有什么区别呢？"></a>6.3.那么C++的new/delete与C语言的malloc/free有什么区别呢？</h2><ul><li>它们都是动态管理内存的入口</li><li>malloc/free是C/C++标准库函数，而new/delete是C++操作符</li><li>malloc/free只是动态分分配/释放内存空间，而new/delete除了分配内存空间还会调用构造/析构函数进行初始化/清理（清理成员）</li><li>malloc/free需要手动计算类型大小且返回值为void，而new/delete可以自行计算类型大小返回对应类型的指针</li><li>new/delete在底层是调用了malloc/free的。可以认为是C++对malloc/free的封装</li><li>malloc/free申请空间后需要判空，new/delete则不需要</li><li>new直接跟类型，malloc跟字节数。<br>new/delete和malloc/free的区别是C++企业招聘时特别喜欢考的一项</li></ul><h1 id="7-程序的内存空间"><a href="#7-程序的内存空间" class="headerlink" title="7.程序的内存空间"></a>7.程序的内存空间</h1><h2 id="7-1-指针的内存操作"><a href="#7-1-指针的内存操作" class="headerlink" title="7.1.指针的内存操作"></a>7.1.指针的内存操作</h2><ul><li>指针不仅可以可以指向变量还可以指向函数</li><li>有new运算符在堆区创建的内存空间由位于栈区的指针确定入口</li></ul><p><img src="https://img-blog.csdnimg.cn/20190712165857369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>说到这，我们有必要了解一下计算机程序的内存结构，供程序运行的内存空间分为：堆区、栈区、.data段、.bss段、.ro段、.txt段，我使用一张图来说明<br><img src="https://img-blog.csdnimg.cn/20190712170749180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="8-面向对象编程的特点"><a href="#8-面向对象编程的特点" class="headerlink" title="8.面向对象编程的特点"></a>8.面向对象编程的特点</h1><p><img src="https://img-blog.csdnimg.cn/2019071310135053.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="9-C-中的类"><a href="#9-C-中的类" class="headerlink" title="9.C++中的类"></a>9.C++中的类</h1><h2 id="9-1-类的定义"><a href="#9-1-类的定义" class="headerlink" title="9.1.类的定义"></a>9.1.类的定义</h2><p><img src="https://img-blog.csdnimg.cn/2019071310150942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="9-2-访问权限"><a href="#9-2-访问权限" class="headerlink" title="9.2.访问权限"></a>9.2.访问权限</h2><ul><li>C++为类的成员添加了三种访问权限<br>public–公有成员：权限最高，在public修饰下的成员是类的外部接口，可以被类的成员函数和对象直接访问</li><li>protected–保护成员：权限居中，可以被类的成员函数和其派生类的成员函数直接访问，但不能被类的对象和派生类的对象直接访问。</li><li>private–私有成员：权限最低，只能通过类的成员函数访问。</li></ul><h2 id="9-3-类的成员"><a href="#9-3-类的成员" class="headerlink" title="9.3.类的成员"></a>9.3.类的成员</h2><ul><li>成员变量：类的成员变量用以描述一个对象的属性信息，与一般的变量声明相同，但类的成员变量只能在类的声明体中定义，类的成员变量一般在类的构造函数中初始化，但这不是必须的。</li><li>成员函数：用来描述一个对象的行为动作，与一般的函数声明相同，但只能放在类的声明体中声明，成员函数可以在类内实现也可以在类外实现，但在类内实现则形成内联的成员函数，会使类变得冗杂，所以成员函数的实现最好在类外实现，类成员函数可以重载和带默认参数。</li></ul><h2 id="9-4-类的成员函数与成员变量的声明与实现"><a href="#9-4-类的成员函数与成员变量的声明与实现" class="headerlink" title="9.4.类的成员函数与成员变量的声明与实现"></a>9.4.类的成员函数与成员变量的声明与实现</h2><p><img src="https://img-blog.csdnimg.cn/20190713104139644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="9-5-struct和class的区别"><a href="#9-5-struct和class的区别" class="headerlink" title="9.5.struct和class的区别"></a>9.5.struct和class的区别</h2><ul><li>C++对struct关键字扩展了其功能，和class的功能几乎等价</li><li>struct的成员默认访问权限是public，而class是private</li></ul><h2 id="9-6-this指针"><a href="#9-6-this指针" class="headerlink" title="9.6.this指针"></a>9.6.this指针</h2><ul><li>this指针是一个特殊的指针，指向对象的自身的首地址</li><li>每一个对象的成员函数都有一个this指针，指向调用的对象，如果要引用整个对象则通过*this引用</li><li>this指针仅能在类的内部使用，即只能在类的声明体或成员函数中使用</li></ul><h2 id="9-7-static关键字"><a href="#9-7-static关键字" class="headerlink" title="9.7.static关键字"></a>9.7.static关键字</h2><h3 id="9-7-1-static修饰的成员变量–静态成员变量"><a href="#9-7-1-static修饰的成员变量–静态成员变量" class="headerlink" title="9.7.1.static修饰的成员变量–静态成员变量"></a>9.7.1.static修饰的成员变量–静态成员变量</h3><ul><li>static修饰的变量存储在静态变量区</li><li>在类中static关键字修饰的变量被此类的所有对象共享，即所有对象共享这一个变量</li><li>static修饰的变量必须在类外初始化，不可以在定义的时候直接初始化</li><li>static修饰的公有成员变量可以直接通过类名来访问，没有staic修饰的成员变量只能通过对象才能访问<br><img src="https://img-blog.csdnimg.cn/20190713105202141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h3 id="9-7-2-static修饰的成员函数–静态成员函数"><a href="#9-7-2-static修饰的成员函数–静态成员函数" class="headerlink" title="9.7.2.static修饰的成员函数–静态成员函数"></a>9.7.2.static修饰的成员函数–静态成员函数</h3><ul><li>static修饰的成员函数也可以直接通过类名访问</li><li>静态成员函数只能访问静态成员变量</li></ul><h3 id="9-7-3-类的静态与非静态部分"><a href="#9-7-3-类的静态与非静态部分" class="headerlink" title="9.7.3.类的静态与非静态部分"></a>9.7.3.类的静态与非静态部分</h3><ul><li>静态部分只属于类，与类一起存放在内存的静态区，被所有对象共享</li><li>非静态部分属于对象，每个对象都有自己的非静态部分，互不影响</li><li>静态部分只能直接访问静态部分，非静态部分可以访问所有部分</li><li>那么为什么静态部分只能直接访问静态部分，而非静态部分却可以访问所有部分呢？<br>那是因为，非静态成员变量/函数是属于对象的，只能通过对象来访问，而静态部分是属于类的，使用静态部分时</li></ul><p>没有确定对象的存在，所以不能确定静态部分应该访问哪个对象的非静态部分，而静态部分是属于类的，所有对象共享，所以通过对象使用非静态部分时，可以访问静态部分。<br>思导图：<br><img src="https://img-blog.csdnimg.cn/20190623192350471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190712170853343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPlus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Unity3d】游戏截屏</title>
    <link href="/2019/08/23/%E3%80%90Unity3d%E3%80%91%E6%B8%B8%E6%88%8F%E6%88%AA%E5%B1%8F/"/>
    <url>/2019/08/23/%E3%80%90Unity3d%E3%80%91%E6%B8%B8%E6%88%8F%E6%88%AA%E5%B1%8F/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer">﻿<p>在Unity3d中游戏截屏操作比较简单，主要使用通过Application类下的CaptureScreenhot方法实现：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (Input.<span class="hljs-constructor">GetKeyDown(KeyCode.P)</span>) &#123;<br>            Application.<span class="hljs-constructor">CaptureScreenshot(<span class="hljs-string">&quot;截图&quot;</span> +<span class="hljs-params">screenhotNom</span>+<span class="hljs-string">&quot;.jpg&quot;</span>)</span>;<br>            screenhotNom++;<span class="hljs-comment">//截图序号</span><br>        &#125;<br></code></pre></td></tr></table></figure><p>截取的图片以设计者规定名字存储在与exe文件一起生成的的Data文件下，没有导出的项目直接存储到工程文件夹下<br><img src="https://img-blog.csdnimg.cn/20190622155156312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity3d</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Unity3d】简单的存档与读档</title>
    <link href="/2019/08/23/%E3%80%90Unity3d%E3%80%91%E5%AD%98%E6%A1%A3%E4%B8%8E%E8%AF%BB%E6%A1%A3/"/>
    <url>/2019/08/23/%E3%80%90Unity3d%E3%80%91%E5%AD%98%E6%A1%A3%E4%B8%8E%E8%AF%BB%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer">﻿<p>在Unity3d中，游戏的存档与读档主要由PlayerPrefs类来完成，在Windows下PlayerPrefs存档主要存储在注册表中，路径为HKCU\Software[company name][product name] ，这里的company name和product name由作者自己确定，在Edit-&gt;Project Settings-&gt;Player中可以设置<br><img src="https://img-blog.csdnimg.cn/20190622143530421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>PlayerSettings视图<br><img src="https://img-blog.csdnimg.cn/20190622143747327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>那么如何设计游戏存档呢？<br>以笔者个人的经验而言，在游戏设计之初，我们就应该想好需要存档的数据，为需要保存的数据或状态设计可供读取的状态标志，以便以后在设计存档时，提供给PlayerPrefs类的方法使用。<br>PlayerPrefs类提供如下方法供设计者使用<br><img src="https://img-blog.csdnimg.cn/20190622144312778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到，PlayerPrefs类中没有提供对bool型数据的存储方法，由此可以看出为需要保存的数据或状态设计可供读取的状态标志的重要性，否则那些由bool型数据确定的状态将无法被存档。<br><img src="https://img-blog.csdnimg.cn/20190622151126795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下面给一段示例代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    * inventory.charge--int--能量电池数量</span><br><span class="hljs-comment">    * inventory.playerTransform--float--玩家位置</span><br><span class="hljs-comment">    * talk.yeshu--int--man的任务进度</span><br><span class="hljs-comment">    * talk.wyeshu--int--women的任务进度</span><br><span class="hljs-comment">     */</span><br>   void game<span class="hljs-constructor">Save()</span> &#123;<br>       PlayerPrefs.<span class="hljs-constructor">SetInt(<span class="hljs-string">&quot;charge&quot;</span>, <span class="hljs-params">inventory</span>.<span class="hljs-params">charge</span>)</span>;<br>       PlayerPrefs.<span class="hljs-constructor">SetInt(<span class="hljs-string">&quot;yeshu&quot;</span>, <span class="hljs-params">talk</span>.<span class="hljs-params">yeshu</span>)</span>;<br>       PlayerPrefs.<span class="hljs-constructor">SetInt(<span class="hljs-string">&quot;wyeshu&quot;</span>, <span class="hljs-params">talk</span>.<span class="hljs-params">wyeshu</span>)</span>;<br>       PlayerPrefs.<span class="hljs-constructor">SetFloat(<span class="hljs-string">&quot;playerPosition.x&quot;</span>, <span class="hljs-params">inventory</span>.<span class="hljs-params">playerTransform</span>.<span class="hljs-params">position</span>.<span class="hljs-params">x</span>)</span>;<br>       PlayerPrefs.<span class="hljs-constructor">SetFloat(<span class="hljs-string">&quot;playerPosition.y&quot;</span>, <span class="hljs-params">inventory</span>.<span class="hljs-params">playerTransform</span>.<span class="hljs-params">position</span>.<span class="hljs-params">y</span>)</span>;<br>       PlayerPrefs.<span class="hljs-constructor">SetFloat(<span class="hljs-string">&quot;playerPosition.z&quot;</span>, <span class="hljs-params">inventory</span>.<span class="hljs-params">playerTransform</span>.<span class="hljs-params">position</span>.<span class="hljs-params">z</span>)</span>;<br>       PlayerPrefs.<span class="hljs-constructor">Save()</span>;<br>   &#125;<br>   void game<span class="hljs-constructor">Read()</span> &#123;<br>       <span class="hljs-keyword">if</span> (PlayerPrefs.<span class="hljs-constructor">HasKey(<span class="hljs-string">&quot;charge&quot;</span>)</span>)<span class="hljs-comment">//存档读取的一般方式</span><br>           inventory.charge = PlayerPrefs.<span class="hljs-constructor">GetInt(<span class="hljs-string">&quot;charge&quot;</span>)</span>;<br>       <span class="hljs-keyword">if</span> (PlayerPrefs.<span class="hljs-constructor">HasKey(<span class="hljs-string">&quot;yeshu&quot;</span>)</span>)<br>           talk.yeshu = PlayerPrefs.<span class="hljs-constructor">GetInt(<span class="hljs-string">&quot;yehsu&quot;</span>)</span>;<br>       <span class="hljs-keyword">if</span> (PlayerPrefs.<span class="hljs-constructor">HasKey(<span class="hljs-string">&quot;wyeshu&quot;</span>)</span>)<br>           talk.wyeshu = PlayerPrefs.<span class="hljs-constructor">GetInt(<span class="hljs-string">&quot;wyeshu&quot;</span>)</span>;<br>       <span class="hljs-keyword">if</span> (PlayerPrefs.<span class="hljs-constructor">HasKey(<span class="hljs-string">&quot;playerPosition.x&quot;</span>)</span>)<br>           x = PlayerPrefs.<span class="hljs-constructor">GetFloat(<span class="hljs-string">&quot;playerPosition.x&quot;</span>)</span>;<br>       <span class="hljs-keyword">if</span> (PlayerPrefs.<span class="hljs-constructor">HasKey(<span class="hljs-string">&quot;playerPosition.y&quot;</span>)</span>)<br>           y = PlayerPrefs.<span class="hljs-constructor">GetFloat(<span class="hljs-string">&quot;playerPosition.y&quot;</span>)</span>;<br>       <span class="hljs-keyword">if</span> (PlayerPrefs.<span class="hljs-constructor">HasKey(<span class="hljs-string">&quot;playerPosition.z&quot;</span>)</span>)<br>           z = PlayerPrefs.<span class="hljs-constructor">GetFloat(<span class="hljs-string">&quot;playerPosition.z&quot;</span>)</span>;<br>       inventory.playerTransform.position = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Vector3(<span class="hljs-params">x</span>, <span class="hljs-params">y</span>, <span class="hljs-params">z</span>)</span>;<br><br>   &#125;<br></code></pre></td></tr></table></figure><p>那么对于已经产生的注册表我们如何查看呢？<br>在Windows下通过注册表编辑器查看注册表，通过Win+R将呼出“运行”，输入“regedit”即可打开注册表编辑器在HKCU\Software[company name][product name] 路径下即可找到我们已经生成的注册表<br><img src="https://img-blog.csdnimg.cn/20190622151747405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity3d</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Unity3d】Animation</title>
    <link href="/2019/08/23/%E3%80%90Unity3d%E3%80%91Animation/"/>
    <url>/2019/08/23/%E3%80%90Unity3d%E3%80%91Animation/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>﻿1.总索引<br><img src="https://img-blog.csdnimg.cn/2019061314131628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>1.1.视图简介<br><img src="https://img-blog.csdnimg.cn/20190520144632375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190520143240580.png" alt="在这里插入图片描述"><br>2.动画分类<br><img src="https://img-blog.csdnimg.cn/20190613141413854.png" alt="在这里插入图片描述"></p><p>2.1.普通动画<br><img src="https://img-blog.csdnimg.cn/20190613141551260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    2.2.人物角色动画<br>    <img src="https://img-blog.csdnimg.cn/20190613141959166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    2.2.1.人物角色动画的导入<br>    <img src="https://img-blog.csdnimg.cn/20190613142213379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>+大图导向<br>    -骨骼映射视图的打开 <img src="https://img-blog.csdnimg.cn/20190531125401236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    -骨骼映射视图和骨骼映射表的修改<img src="https://img-blog.csdnimg.cn/20190531125301603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>-三种动画的导入方式<br><img src="https://img-blog.csdnimg.cn/20190613142757765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">-模型导入注意事项<br><img src="https://img-blog.csdnimg.cn/20190613142937598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190531130631610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    <img src="https://img-blog.csdnimg.cn/20190531130654193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2.3.IK动画<br><img src="https://img-blog.csdnimg.cn/20190613143849254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2.4.TimeLine<br><img src="https://img-blog.csdnimg.cn/20190613143939800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>+大图导向<br>    -存储<br>    <img src="https://img-blog.csdnimg.cn/20190613144055967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    -Playable Track<br>    <img src="https://img-blog.csdnimg.cn/20190613144133197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.AnimatorController(状态机)<br><img src="https://img-blog.csdnimg.cn/20190613144259619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.1.状态机的打开方式<br><img src="https://img-blog.csdnimg.cn/20190613144350891.png" alt="在这里插入图片描述"><br>3.2.Animator视图简介<br><img src="https://img-blog.csdnimg.cn/20190613144502456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.3.作用<br><img src="https://img-blog.csdnimg.cn/20190613144550261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.4.精细控制<br><img src="https://img-blog.csdnimg.cn/20190613144641944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>+大图导向<br><img src="https://img-blog.csdnimg.cn/20190613144744729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.5.混合树<br><img src="https://img-blog.csdnimg.cn/201906131452528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.5.1.四种2D混合树<br><img src="https://img-blog.csdnimg.cn/20190613145340965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.5.2.大图导向<br> -混合树的创建<br> <img src="https://img-blog.csdnimg.cn/20190613145440631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> -1D混合树Inspector<br> <img src="https://img-blog.csdnimg.cn/20190613144953557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> -2D混合树Inspector<br> <img src="https://img-blog.csdnimg.cn/20190613145057715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.6.Avatar Mask骨骼遮罩<br><img src="https://img-blog.csdnimg.cn/20190613145729200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4.MacthTarget场景动画匹配技术<br><img src="https://img-blog.csdnimg.cn/20190613145909634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4.1.核心方法<br><img src="https://img-blog.csdnimg.cn/20190613150056658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4.2.MacthTarget函数细述<br><img src="https://img-blog.csdnimg.cn/20190613150207340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4.3.难点<br><img src="https://img-blog.csdnimg.cn/20190613150430468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>+大图导向<br><img src="https://img-blog.csdnimg.cn/2019061315050794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>5.相机运动<br><img src="https://img-blog.csdnimg.cn/20190613150709467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>+大图导向<br><img src="https://img-blog.csdnimg.cn/20190613150735692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>6.学习过程中遇到的问题<br><img src="https://img-blog.csdnimg.cn/20190613150827535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>7.函数方法<br><img src="https://img-blog.csdnimg.cn/20190613150913675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>8.动画的Inspector<br><img src="https://img-blog.csdnimg.cn/20190613151018312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity3d</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【计算机图形学】多边形填充算法</title>
    <link href="/2019/08/23/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E3%80%91%E5%A4%9A%E5%8F%98%E5%BD%A2%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/"/>
    <url>/2019/08/23/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E3%80%91%E5%A4%9A%E5%8F%98%E5%BD%A2%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>首先对于如下的多边形：</p><p><img src="https://img-blog.csdnimg.cn/20190618080545123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="1-有效边表填充算法"><a href="#1-有效边表填充算法" class="headerlink" title="1.有效边表填充算法"></a>1.有效边表填充算法</h1><h2 id="1-1-有效边表填充算法分为如下几个步骤："><a href="#1-1-有效边表填充算法分为如下几个步骤：" class="headerlink" title="1.1.有效边表填充算法分为如下几个步骤："></a><strong>1.1.有效边表填充算法分为如下几个步骤</strong>：</h2><p>​    1.1.1.将多边形所有的边分别与扫描线1计算交点，得到交点集，与扫描线计算的边没有顺序要求。<br>​    1.1.2.将点集按标x的大小递增排序，得到有序点集。<br>​    1.1.3.将有序点集两两配对，得到对应的像素区间。<br>​    1.1.4.将像素区间内的像素填充颜色，至此第一条扫描线上处于多边形内的的像素填充完毕。<br>​    1.1.5.扫描线标号加1，重复以上步骤，直至到最后一条扫描线。<br>​    如：对于扫描线3（y=3）与多边形所有的边计算交点，得到与P3P4交于点（4.5，3），与P3P2交于点（2.4，3），与P5P6交于点（8.8，3），与P5P4交于点（7，3）。<br>​    圆整处理得到点集（5，3）、（2，3）、（9，3）、（7，3）。<br>​    递增排序得到有序点集（2，3）、（5，3）、（7，3）、（9，3）。<br>​    两两配对得到扫描线3上的填充像素区间[2，5]、[7，9]。<br>​    填充区间内的所有像素。<br>​    得到如图所示的填充效果：<br><img src="https://img-blog.csdnimg.cn/20190617115850448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>全部填充得到如下效果：<br><img src="https://img-blog.csdnimg.cn/20190617115915999.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-2-至此我们发现如下疑问："><a href="#1-2-至此我们发现如下疑问：" class="headerlink" title="1.2.至此我们发现如下疑问："></a><strong>1.2.至此我们发现如下疑问：</strong></h2><p>​    1.2.1.像素填充的多边形面积大于多边形实际面积。<br>​    可能上图不太明显，我们举一个明显一点的例子，如下正方形：<br><img src="https://img-blog.csdnimg.cn/20190617115935411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们填充后的效果为：<br><img src="https://img-blog.csdnimg.cn/20190617115949648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>​    而正方形的实际面积是4，在显示器上一个像素为一面积，正方形应该占4个像素点，而实际却占了9个像素点，对于这种问题，有效边表填充算法采用“左闭右开”，“下闭上开”的原则进行像素点的填充，按照此原则，正方形的填充效果如下：<br><img src="https://img-blog.csdnimg.cn/20190617120002618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>1.2.1.对于点集（1，3）、（1，8）它们分别为扫描线1与P3P2、P3P4、P5P4、P5P6的交点，而在实际计算中它们仍只是两个点，如果处理不当，计算机可能会两两配对得到区间（3，8）而填充到错误的像素区间。<br>对于此问题，有效边表填充算法采用分类连接点进行处理。<br>有效边表填充算法将多边形的各个连接点分为三类连接点：</p><h3 id="普通连接点："><a href="#普通连接点：" class="headerlink" title="+普通连接点："></a><strong>+普通连接点：</strong></h3><p>​    连接点所在的两条边分别处于其所在的扫描线的上方和下方，如P2点。</p><h3 id="局部最低点："><a href="#局部最低点：" class="headerlink" title="+局部最低点："></a><strong>+局部最低点：</strong></h3><p>​    连接点所在的两条边都处于其所在的扫描线的上方，如P3、P5点。</p><h3 id="局部最高点："><a href="#局部最高点：" class="headerlink" title="+局部最高点："></a><strong>+局部最高点：</strong></h3><p>​    连接点所在的两条边都处于其所在的扫描线的下方，如：P4、P1、P6点。<br>​    在填充开始前，有效边填充算法先对多边形所有的连接点进行分类，判断其在点集中的数量。<br>有效边填充算法采用如下原则对多边形的连接点进行处理：</p><h3 id="1-2-2-普通连接点的处理原则"><a href="#1-2-2-普通连接点的处理原则" class="headerlink" title="1.2.2.普通连接点的处理原则"></a><strong>1.2.2.普通连接点的处理原则</strong></h3><p>​    以P2为例，根据“下闭上开”原则，对于P3P2上的点P2不予填充，P2P1上的点P2需要填充，P2点只填充1次，顾在扫描线7的填充像素点集中P2点的个数记为1，即可以不处理。</p><h3 id="1-2-3-局部最低点的处理原则"><a href="#1-2-3-局部最低点的处理原则" class="headerlink" title="1.2.3.局部最低点的处理原则"></a><strong>1.2.3.局部最低点的处理原则</strong></h3><p>​    以P3为例，根据“下闭上开”原则，对于P3P2上的点P3需要填充，P3P4上的点P3也需要填充，P3填充2次，扫描线1的填充像素点集中，再添加一个P3点，使其中有两个P3点，在像素点集中将P3点的个数记为2，P5点进行同样的处理，这样当算法进行两两配对时，得到的像素区间为[3，3]、[5，5]，如此即可避免出现[3，8]的点集区间，解决此类情况的填充错误。</p><h2 id="1-2-4-局部最高点的处理原则"><a href="#1-2-4-局部最高点的处理原则" class="headerlink" title="1.2.4.局部最高点的处理原则"></a><strong>1.2.4.局部最高点的处理原则</strong></h2><p>​    以P1点为例，根据“下闭上开”原则，对于P2P1上的P1点不予填充，P0P1上的P1点也不予填充，P1填充0次，扫描线12的像素填充点集中P1点的个数记为0，即从点集中删除P1点，这样的处理符合多边形整体的“下闭上开”原则。<br>至此，多边形的有效边表填充算法的填充原理已经完成。<br>但是，我们在填充多边形之前还需要进行一项很重要的工作——根据多边形计算其有效边表，首先我们要了解什么是有效边。<br><strong>有效边</strong>：多边形与当前扫描线相交的边称为有效边，有效边的引入可以有效的避免扫描边与多边形的所有的边进行交点计算，提高算法的效率。<br><strong>有效边表</strong>：有效边按与扫描线交点x坐标递增顺序存放的链表。<br><strong>有效边表节点结构</strong>：<br><img src="https://img-blog.csdnimg.cn/20190618080124847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>示例：扫描线1的有效边表如下：<br><img src="https://img-blog.csdnimg.cn/20190618081306344.png" alt="在这里插入图片描述"><br><strong>桶表</strong>：有效边表按扫描线自增顺序存放的表，可以是链表，也可以是顺序表。<br><strong>桶表的结构</strong>：<br>​    如：多边形P0-P6的桶表为：<br><img src="https://img-blog.csdnimg.cn/20190618082918644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>​    有效边表可以有效的减少计算量，提升多边形的填充效率，如所有的扫描线中，计算机只需要计算扫描线1、扫描线7和扫描线8，且扫描线1只需和边P2P3、P3P4、P4P5、P5P6计算交点，而无需与所有边计算交点，有效边填充算法是目前最有效的多边形填充算法之一。<br>至此，多边形的有效边填充算法全部完成。</p><h1 id="2-边缘填充算法"><a href="#2-边缘填充算法" class="headerlink" title="2.边缘填充算法"></a>2.边缘填充算法</h1><h2 id="2-1-算法原理："><a href="#2-1-算法原理：" class="headerlink" title="2.1.算法原理："></a><strong>2.1.算法原理：</strong></h2><p>​    先计算多边形每条边与扫描线的交点，然后将交点右侧的所有像素颜色全部取补色。</p><h2 id="2-2-补色的定义："><a href="#2-2-补色的定义：" class="headerlink" title="2.2.补色的定义："></a><strong>2.2.补色的定义：</strong></h2><p>​    对于黑白图像，白色的补色为黑色，黑色补色为白色，对于彩色图像，前景色取补就是将前景色置为背景色，背景色取补就是将背景声置为前景色。<br>示例：<br><img src="https://img-blog.csdnimg.cn/20190618092226427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>​    边缘填充算法的填充效率受到右侧填充像素的数量影响，当多边形靠近屏幕左侧时，计算机将填充大量无用像素，大大降低的算法的性能，浪费了系统资源。<br>于是有人提出这样的改进：首先在进行多边形填充之前，先扫描一遍多边形，得出多边形的包围盒，并在适当的位置加入一条栅栏。<br>包围盒：包围多边形的最小矩形。</p><h2 id="2-3-加入包围盒和栅栏的边缘填充算法原理："><a href="#2-3-加入包围盒和栅栏的边缘填充算法原理：" class="headerlink" title="2.3.加入包围盒和栅栏的边缘填充算法原理："></a><strong>2.3.加入包围盒和栅栏的边缘填充算法原理：</strong></h2><p>​    每次填充前先判断当前边在栅栏的左侧还是右侧，若在左侧，则取补边以右，栅栏以左的像素；若在右侧，则取补边以右，栅栏以左的像素。<br>示例：<br><img src="https://img-blog.csdnimg.cn/20190621084324207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>​    可以看出，加入包围盒和栅栏的边缘填充算法极大的减少了需要填充像素的数量，对填充效率的提升是显著的。<br>​    观察边缘填充算法的两幅图，我们是可以察觉到的，边缘填充算法，对多边形的顶点与边的填充不甚理想，边缘填充算法没有给定具体填充时，直线上的点是否包含在填充范围内，笔者试过两种情况的对比——填充时包含直线上的点和填充时不包含直线上的点，得出的结果，多边形的顶点与边的填充都不理想，但是，填充时包含直线上的点的填充方法的最总结果，使多边形在整体上满足“左闭右开”，“下闭上开”原则，顾才用此方法作图。然而，边缘填充算法的填充原理是没有考虑边界的，即多边形的所有像素都填充为一个颜色，无论多边形内部还是多边形的边和顶点，在实际填充效果中，多边形所有像素都填充为一个颜色的填充方式，顶点和边对整体的效果不大，即可以忽略，所以边缘填充算法依旧是效率极高的填充算法之一。</p><h1 id="3-种子填充算法"><a href="#3-种子填充算法" class="headerlink" title="3.种子填充算法"></a>3.种子填充算法</h1><p>3.1.种子填充算法是区域填充算法中的一种，种子填充算法分为：四邻接点种子填充算法和八邻接点种子填充算法。<br>在此之前，我们需要了解一些概念：</p><h3 id="3-1-1-四邻接点："><a href="#3-1-1-四邻接点：" class="headerlink" title="3.1.1.四邻接点："></a><strong>3.1.1.四邻接点：</strong></h3><p>​    任易一个种子像素，其左右上下这四个像素成为这个种子像素的四邻接点。<br><img src="https://img-blog.csdnimg.cn/20190621092132813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-1-2-八邻接点："><a href="#3-1-2-八邻接点：" class="headerlink" title="3.1.2.八邻接点："></a><strong>3.1.2.八邻接点：</strong></h3><p>​    任易一个种子像素，其左右上下及左上、右下、右上、左上这八个像素成为这个种子像素的八邻接点。<br><img src="https://img-blog.csdnimg.cn/20190621092334685.png" alt="在这里插入图片描述"></p><h3 id="3-1-3-四连通域："><a href="#3-1-3-四连通域：" class="headerlink" title="3.1.3.四连通域："></a><strong>3.1.3.四连通域：</strong></h3><p>​    多边形中能被四邻接点遍历填充的区域。</p><h3 id="3-1-4-八连通域："><a href="#3-1-4-八连通域：" class="headerlink" title="3.1.4.八连通域："></a><strong>3.1.4.八连通域：</strong></h3><p>​    多边形中能被八邻接点遍历填充的区域。<br><img src="https://img-blog.csdnimg.cn/20190621094757411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-1-5-四连通边界："><a href="#3-1-5-四连通边界：" class="headerlink" title="3.1.5.四连通边界："></a><strong>3.1.5.四连通边界：</strong></h3><p><img src="https://img-blog.csdnimg.cn/20190621094925910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-1-6-八连通边界："><a href="#3-1-6-八连通边界：" class="headerlink" title="3.1.6.八连通边界："></a><strong>3.1.6.八连通边界：</strong></h3><p><img src="https://img-blog.csdnimg.cn/20190621095031628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="3-2-适用场景："><a href="#3-2-适用场景：" class="headerlink" title="3.2.适用场景："></a><strong>3.2.适用场景：</strong></h2><p>​    区域填充算法适用于多边形的边界与内部使用不同的填充色的场景。</p><h2 id="3-3-多边形边界的颜色："><a href="#3-3-多边形边界的颜色：" class="headerlink" title="3.3.多边形边界的颜色："></a><strong>3.3.多边形边界的颜色：</strong></h2><p>​    边界的颜色由绘制多边形时的画笔确定。</p><h2 id="3-4-多边形内部的颜色填充步骤"><a href="#3-4-多边形内部的颜色填充步骤" class="headerlink" title="3.4.多边形内部的颜色填充步骤"></a><strong>3.4.多边形内部的颜色填充步骤</strong></h2><p>​    3.4.1.在多边形内部任易选择一个像素作为种子像素。<br>​    3.4.2.将种子像素入栈。<br>​    3.4.3.如果栈不为空，则将栈顶元素出栈。<br>​    3.4.4.按填充色绘制出栈像素。<br>​    3.4.5.按四邻接点（左、上、右、下）（或八邻接点（左、左上、上、右上、右、右下、下、左下））顺序搜索与出栈像素相邻的4（或8）个像素，若该像素的颜色不是填充色并且也不是边界色，则把该像素入栈，否则丢弃该像素。<br>​    不难想象，当多边形的面积极大时，入栈的像素像素将是巨量，有的像素可能即是一个像素的邻接点又是另一个像素的邻接点，以致部分像素入栈多次，此情况下填充过程将大量占用栈存储空间，甚至过量占用空间，致使栈空间不足，导致其他程序无空间可用，如此既不能完成填充，又会造成空间溢出，甚至系统崩溃，所以种子填充算法的缺点极为严重。</p><h2 id="3-5-改进——扫描种子填充算法"><a href="#3-5-改进——扫描种子填充算法" class="headerlink" title="3.5.改进——扫描种子填充算法"></a><strong>3.5.改进——扫描种子填充算法</strong></h2><p>​    3.5.1.在多边形内部选择一个像素作为种子像素。<br>​    3.5.2.将种子像素入栈。<br>​    3.5.3.若栈不为空，则将栈顶元素出栈<br>​    3.5.4.沿出栈像素所在扫描线，对出栈像素左右像素依次填充，直至遇到边界像素为止。<br>​    3.5.5.记录该区间的范围，将最左端的像素记为Xl，将最右端的像素记为Xr。<br>​    3.5.6.检查与当前扫描线相邻的上下两条扫描线中在区间[Xl，Xr]里的有关像素是否全为边界像素或以填充像素，若存在非边界且未填充的像素，则把区间最右端像素取作种子像素入栈。<br>​    扫描种子填充像素每次只将区间最右端的像素入栈，极大的减少了入栈像素，不仅减少了栈空间的占用，还有效的提高了填充效率和填充速度。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
