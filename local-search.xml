<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【UE4】 文件系统</title>
    <link href="/2022/01/27/%E3%80%90UE4%E3%80%91UE4%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/01/27/%E3%80%90UE4%E3%80%91UE4%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>先来看一下UE4文件系统的类组成情况：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127135722.png"></p><p>我们一个个类来看。</p><p>这里面类组成大致可以分为三大类：</p><ul><li>物理文件类：UE4封装的在各个平台下直接对文件进行操作的类，主要是IPhysicalPlatformFile及其子类；</li><li>包装文件类：UE4封装的对特定情况的文件进行操作的类，如对pak包的处理，包装文件类不会直接对文件进行操作，而是通过其持有的底层对象来进行文件操作，包装文件类持有的底层对象也可以是另一个包装文件类，这样一层层的持有对象，各个类就链接成了一条链，当链头接收到要处理的文件若自己能处理则直接处理，若自己无法处理则抛给自己持有的底层对象，底层对象重复这个操作直到有一个对象可以处理则停止，这条链的链尾就是一个物理文件对象，这就是UE4文件系统的责任链模式。包装文件类主要包括继承自IPlatformFile的除IPhysicalPlatformFile类及其子类以外的其他类；</li><li>平台文件管理器：FPlatformFileManager用于管理注册的平台文件类及其组成的文件操作链。</li></ul><p>参考博客:</p><p><a href="https://bajiaobujie.github.io/2019/04/25/2019-04-25-UE4%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%EF%BC%88%E4%B8%89%EF%BC%89FPakPlatformFile%E7%9B%B8%E5%85%B3/#more">芭蕉不解的博客</a>、<a href="https://zhuanlan.zhihu.com/p/35925797">FlyingTree</a>、<a href="https://www.cnblogs.com/shiroe/p/14803859.html">代码质疑人生</a>、<a href="https://blog.csdn.net/KKsuser/article/details/111659209">Khcys_</a>、<a href="https://dhbloo.github.io/2020/09/07/UE4-FileSystem/#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%88%9B%E5%BB%BA">dhb</a></p><a id="more"></a><h1 id="一、IPlatformFile"><a href="#一、IPlatformFile" class="headerlink" title="一、IPlatformFile"></a>一、IPlatformFile</h1><p>IPlatformfile是文件类的基类，是一个UE4预定义的C++接口，是一个顶层类不继承任何类，所以IPlatformFile类及其子类均不支持反射和垃圾回收，也就是说这些类的指针管理需要我们自己手动管理，析构时需要手动delete对象，以防内存泄漏。</p><p>作为基类IPlatformFile的主要作用是用于文件操作链中的多态和提供一些通用方法与属性，如:初始化，判断文件是否存在，读取、写入、移动、删除、拷贝文件等等，其中需要注意的是<code>virtual bool Initialize(IPlatformFile* Inner, const TCHAR* CmdLine) = 0;</code>在IPlatformfile类中是一个纯虚函数，在子类使用其作初始化时，对于包装文件类来说，第一个参数是他所指向的下一个文件类对象。对于物理文件类，第一个参数只能是空的; 第二个参数是命令行，部分文件类会从这里去解析一些参数。</p><h1 id="二、IPhysicalPlatformFile"><a href="#二、IPhysicalPlatformFile" class="headerlink" title="二、IPhysicalPlatformFile"></a>二、IPhysicalPlatformFile</h1><p>IPhysicalPlatformFile是物理文件类的基类，对SetLowerLevel函数进行了屏蔽，使其子类都无法访问SetLowerLevel函数，因为对于文件操作链来说，链尾一定是一个物理文件类，所以不需要再设置底层对象。</p><p>源码相当简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Common base for physical platform File I/O Interface</span><br><span class="hljs-comment">**/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CORE_API</span> <span class="hljs-title">IPhysicalPlatformFile</span> :</span> <span class="hljs-keyword">public</span> IPlatformFile<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//~ Begin IPlatformFile Interface</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">ShouldBeUsed</span><span class="hljs-params">(IPlatformFile* Inner, <span class="hljs-keyword">const</span> TCHAR* CmdLine)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Initialize</span><span class="hljs-params">(IPlatformFile* Inner, <span class="hljs-keyword">const</span> TCHAR* CmdLine)</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> IPlatformFile* <span class="hljs-title">GetLowerLevel</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetLowerLevel</span><span class="hljs-params">(IPlatformFile* NewLowerLevel)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function"></span>&#123;<br>check(<span class="hljs-literal">false</span>); <span class="hljs-comment">// can&#x27;t override wrapped platform file for physical platform file</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">const</span> TCHAR* <span class="hljs-title">GetName</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> IPlatformFile::GetPhysicalTypeName();<br>&#125;<br><span class="hljs-comment">//~ End IPlatformFile Interface</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在源码中IPhysicalPlatformFile::GetLowerLevel直接返回了一个nullptr。</p><p>查看FWindowsPlatformFile在UE4.26中的源码发现FWindowsPlatformFile.h是一个空的头文件，而整个FWindowsPlatformFile类都被定义在FWindowsPlatformFile.cpp中，这就谢绝了我们以常规的方式使用FWindowsPlatformFile这些类了，FAndriodPlatformFile类更是找都找不到，UE4这么做的意图已经很明显了，UE4是不想让开发者直接使用这些底层类的，这也是为什么UE4要提供一个FPlatformFileManager类的原因。</p><h1 id="三、FPlatformFileManager"><a href="#三、FPlatformFileManager" class="headerlink" title="三、FPlatformFileManager"></a>三、FPlatformFileManager</h1><p>PLatformFileManager类就是用UE4用于文件系统的跨平台用的，在引擎的主循环的FEngineLoop::PreInit函数中会调用FEngineLoop::PreInitPreStartupScreen，然后通过LaunchCheckForFileOverride函数检测是否需要设置当前文件系统，不需要设置则将引擎的文件系统设置成默认物理文件系统，如果需要设置则根据配置设置对应的文件系统，并将这个文件类的LowerLevel设置成对应的物理文件系统。</p><p>FPlatformFileManager提供GetPlatformFile函数返回一个IPlatformFile指针，通过多态来调用接口的具体实现，可以忽略掉底层不同平台类的文件操作实现，从而达到跨平台的效果。</p><p>IPlatformFile的文件操作依然是比较底层的操作，如IPlatformFile::OpenRead和IPlatformFile::OpenWrite函数返回的都是一个IFileHandle文件操作句柄，通过这个句柄才能对文件做跟底层的读写，如IFileHandle::Read和IFileHandle::Write函数都是直接读写的字节码。</p><p>IPlatformFile主要是提供对文件的整体操作，如移动、删除、拷贝、读取与设置文件属性，寻找文件，判断文件是否存在，获取文件大小，同时也提供对文件夹层面的操作，如创建、删除、复制、遍历文件夹等等。</p><p>而对于常规文件的读写UE4提供了一个更高层的类FileHelper来操作，对目录路径的操作UE4提供了FPaths，对配置文件的操作UE4提供了GConfig，读取Json文件UE4提供了内置的Json读写工具链。这些我们后面再看，先把IPlatformFile的子类过完。</p><h1 id="四、FPakPlatformFile"><a href="#四、FPakPlatformFile" class="headerlink" title="四、FPakPlatformFile"></a>四、FPakPlatformFile</h1><p>在IPlatFormFile派生的所有的包装文件类当中FPakPlatformFile是最重要也是最常用的，FPakPlatformFile是UE4专门用于Pak文件读取的包装文件类。</p><h2 id="1-什么是Pak文件"><a href="#1-什么是Pak文件" class="headerlink" title="1.什么是Pak文件"></a>1.什么是Pak文件</h2><p>pak文件，又称pak包，是UE4用于更新资源(包括热更新)的一种文件格式，UE4将多个文件合并到一个pak文件中，通过pak文件来更新资源，pak文件不仅能够装载UE4的资源文件，如：uasset、umap等，也能够装载非资源文件，如：xml、json、txt等，除了文件，pak文件还可以包含一些额外的信息，如：pak文件的加密情况，pak的版本等等。</p><p>要想对pak文件进行操作，我们首先要先获取pak文件。</p><p>pak文件的生成分为两步，烘培与打包。</p><h2 id="2-Cook资源-烘焙资源"><a href="#2-Cook资源-烘焙资源" class="headerlink" title="2.Cook资源(烘焙资源)"></a>2.Cook资源(烘焙资源)</h2><h3 id="为什么要烘焙资源"><a href="#为什么要烘焙资源" class="headerlink" title="为什么要烘焙资源"></a>为什么要烘焙资源</h3><p>由于程序运行的平台多种多样，而不同平台有着各自的资源格式，所以在创建Pak文件之前必须先烘焙对应平台的资源才行，UE4提供UE4Editor-Cmd.exe工具来提供资源烘焙，UE4Editor-Cmd.exe可以直接在cmd命令。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;引擎路径&gt;\Engine\Binaries\Win64\UE4Editor-Cmd.exe &lt;项目路径&gt;\RobotEngine.uproject <span class="hljs-attribute">-run</span>=Cook  <span class="hljs-attribute">-TargetPlatform</span>=&lt;平台类型&gt; -fileopenlog -unversioned <span class="hljs-attribute">-abslog</span>=&lt;日志输出路径&gt; -stdout -CrashForUAT -unattended -NoLogTimes  -UTF8Output<br></code></pre></td></tr></table></figure><p>烘培完的资源会存储在<code>&lt;项目文件夹&gt;/Saved/Cooked/&lt;对应的平台名称&gt;/&lt;项目名称&gt;/Content/&lt;对应的目录&gt;</code></p><h3 id="烘焙所支持的平台类型"><a href="#烘焙所支持的平台类型" class="headerlink" title="烘焙所支持的平台类型"></a>烘焙所支持的平台类型</h3><p>UE4的资源烘焙自持目前大部分主流平台：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127135749.png"></p><p>当然，如果我们只需要烘焙Windows平台的资源，UE4直接提供了烘焙按钮</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127135758.png"></p><h2 id="2-Pak文件的打包"><a href="#2-Pak文件的打包" class="headerlink" title="2.Pak文件的打包"></a>2.Pak文件的打包</h2><p>UE4提供了一个创建Pak文件的工具—UnrealPak.exe供我们使用，我们可以直接从cmd命令行运行UnrealPak.exe来对指定文件创建Pak包。</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">&lt;引擎路径&gt;<span class="hljs-symbol">\E</span>ngine<span class="hljs-symbol">\B</span>inaries<span class="hljs-symbol">\W</span>in64<span class="hljs-symbol">\U</span>nrealPak.exe &lt;pak文件路径&gt; -Create=&lt;项目路径&gt;<span class="hljs-symbol">\R</span>obotEngine<span class="hljs-symbol">\S</span>aved<span class="hljs-symbol">\C</span>ooked<span class="hljs-symbol">\A</span>ndroid_ASTC<span class="hljs-symbol">\R</span>obotEngine<span class="hljs-symbol">\C</span>ontent<span class="hljs-symbol">\C</span>omps<span class="hljs-symbol">\&lt;</span>cook资源文件所在的文件夹&gt; -compress<br></code></pre></td></tr></table></figure><p>这里有几点需要注意，pak文件路径是我们要存放创建出来的pak文件的路径，如：D:\PAK\mypak.pak，cook资源文件所在文件夹即cook后的uasset文件所在目录，切记不是文件路径，因为目录下可以包含多个资源文件，其中Andriod_ASTC是对应平台类型的文件夹，需要实际根据cook的平台选择对应的文件夹。</p><p><code>-compress</code>表示文件打包pak时进行压缩。</p><p>UnrealPak可以封装一个指定文件到Pak文件中，也可以封装一个指定文件夹下的所有文件到Pak文件中，还可以封装一个文件下中指定的多个文件夹和文件的组合到Pak文件中。</p><p>比如：</p><h3 id="指定单个目录打包Pak"><a href="#指定单个目录打包Pak" class="headerlink" title="指定单个目录打包Pak"></a>指定单个目录打包Pak</h3><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">D:<span class="hljs-symbol">\U</span>E_4.26_SourceCode<span class="hljs-symbol">\U</span>nrealEngine-4.26<span class="hljs-symbol">\E</span>ngine<span class="hljs-symbol">\B</span>inaries<span class="hljs-symbol">\W</span>in64<span class="hljs-symbol">\U</span>nrealPak.exe D:<span class="hljs-symbol">\U</span>E4<span class="hljs-symbol">\P</span>aks<span class="hljs-symbol">\P</span>akActor.pak -create=D:<span class="hljs-symbol">\U</span>E4<span class="hljs-symbol">\U</span>nkown<span class="hljs-symbol">\U</span>nkown<span class="hljs-symbol">\C</span>onfig -compress<br></code></pre></td></tr></table></figure><h3 id="指定多个目录和文件的组合打包Pak"><a href="#指定多个目录和文件的组合打包Pak" class="headerlink" title="指定多个目录和文件的组合打包Pak"></a>指定多个目录和文件的组合打包Pak</h3><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">D:<span class="hljs-symbol">\U</span>E_4.26_SourceCode<span class="hljs-symbol">\U</span>nrealEngine-4.26<span class="hljs-symbol">\E</span>ngine<span class="hljs-symbol">\B</span>inaries<span class="hljs-symbol">\W</span>in64<span class="hljs-symbol">\U</span>nrealPak.exe D:<span class="hljs-symbol">\U</span>E4<span class="hljs-symbol">\P</span>aks<span class="hljs-symbol">\P</span>akActor.pak -create=D:<span class="hljs-symbol">\U</span>E4<span class="hljs-symbol">\U</span>nkown<span class="hljs-symbol">\U</span>nkown<span class="hljs-symbol">\C</span>onfig<span class="hljs-symbol">\A</span>.txt -compress<br></code></pre></td></tr></table></figure><p>txt文件中目录和文件的组合格式如下：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">D:<span class="hljs-symbol">\G</span>oulandis<span class="hljs-symbol">\U</span>E4<span class="hljs-symbol">\P</span>aks<span class="hljs-symbol">\P</span>aks_0104143216 <br>D:<span class="hljs-symbol">\G</span>oulandis<span class="hljs-symbol">\U</span>E4<span class="hljs-symbol">\P</span>aks<span class="hljs-symbol">\P</span>aks_0104145559<br>D:<span class="hljs-symbol">\G</span>oulandis<span class="hljs-symbol">\U</span>E4<span class="hljs-symbol">\P</span>aks<span class="hljs-symbol">\J</span>son.json<br></code></pre></td></tr></table></figure><p>路径与路径之间必须用换行符隔开，如果存在不可用路径则文件打包失败。</p><h3 id="指定单个文件打包Pak"><a href="#指定单个文件打包Pak" class="headerlink" title="指定单个文件打包Pak"></a>指定单个文件打包Pak</h3><p>由于-create=只能接文件和目录，若是目录，则打包目录下的所有文件进Pak包，如果接的是文件，则会读取文件内容，将文件中的内容当作要打包的路径，所以直接指定文件路径的指令形式是无法打包单个文件的，因此我们还是需要使用文本来指定单个文件的路径的形式来打包单个文件。</p><p>-create可以读取常用的文本格式，如txt，ini，json等，只要里面内容符合格式要求即可读取。</p><h3 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a><font color="green">小知识</font></h3><p>当我们在打包引用程序的时候勾选Edit\Project Setting\Packaging\Use Pak File</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127135809.png"></p><p>则打包出来的资源将全部封装进一个独立的Pak包里面，pak包保存在<code>&lt;程序目录&gt;/&lt;项目名称&gt;/Content/Paks/</code>目录下，如果不勾选那么资源路径情况和编辑时一样，并且打包出来的资源也依旧是.uasset资源。由于pak文件可以加密而uasset不能加密，所以将资源封装进pak文件中有利于程序的安全性。</p><h2 id="3-Pak文件的挂载"><a href="#3-Pak文件的挂载" class="headerlink" title="3.Pak文件的挂载"></a>3.Pak文件的挂载</h2><p>首先我们需要明白一个机制，就是UE挂载Pak文件，仅仅是引擎内部注册一个Pak挂载点对应的文件夹，这样当引擎去寻找资源的时候就知道有这么一个地址可以去搜索资源，而在实际的物理文件中这个文件夹是不存在的，由此可以知晓，Pak文件挂载之后并不能直接使用Pak文件中资源，因为资源仍然是一个虚拟文件夹下的物理文件，还未加载到内存中。</p><p>然后创建一个类作为挂载代码的载体，这个载体可以AActor也可以是UObject，甚至可以是自定义的C++类。这里我使用一个UObject类来作为载体。</p><p>先上源码，后面再做解析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;IPlatformFilePak.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;GenericPlatform/GenericPlatformFile.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;UObject/NoExportTypes.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;PakExpand.generated.h&quot;</span></span><br><br>UCLASS(Blueprintable,BlueprintType)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UNKOWN_API</span> <span class="hljs-title">UPakExpand</span> :</span> <span class="hljs-keyword">public</span> UObject<br>&#123;<br>GENERATED_BODY()<br><span class="hljs-keyword">private</span>:<br>FPakPlatformFile* HandlePakPlatform;<br>IPlatformFile* HandleOriginPlatform;<br>FPlatformFileManager* PlatformFileManager;<br><span class="hljs-keyword">private</span>:<br>~UPakExpand();<br><span class="hljs-keyword">public</span>:<br>UPakExpand();<br>UFUNCTION(BlueprintCallable,Category=<span class="hljs-string">&quot;PakExpand&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Mount</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString PakFilePath)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//.cpp</span><br>UPakExpand::~UPakExpand()<br>&#123;<br>    PlatformFileManager = <span class="hljs-literal">nullptr</span>;<br>    HandleOriginPlatform = <span class="hljs-literal">nullptr</span>;<br>    HandlePakPlatform = <span class="hljs-literal">nullptr</span>;<br>&#125;<br>UPakExpand::UPakExpand()<br>&#123;<br>    <span class="hljs-comment">//获取平台文件链接管理器</span><br>    PlatformFileManager = &amp;FPlatformFileManager::Get();<br>    <span class="hljs-comment">//获取平台I/O接口，用于操作平台文件</span><br>    HandleOriginPlatform = &amp;PlatformFileManager-&gt;GetPlatformFile();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">UPakExpand::Mount</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString PakFilePath)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//判断文件时候是pak文件</span><br>    <span class="hljs-keyword">if</span> (!PakFilePath.EndsWith(<span class="hljs-string">&quot;.pak&quot;</span>))<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;  <br>    <span class="hljs-keyword">if</span> (!HandlePakPlatform)<br>    &#123;<br>        <span class="hljs-comment">//创建Pak平台文件系统</span><br>        HandlePakPlatform = <span class="hljs-keyword">new</span> FPakPlatformFile();<br>    &#125;<br>    <span class="hljs-comment">//使用平台接口初始化Pak文件平台包装器</span><br>    HandlePakPlatform-&gt;Initialize(HandleOriginPlatform, TEXT(<span class="hljs-string">&quot;&quot;</span>));<br>    <span class="hljs-comment">//将PakPlatformFile设置到最顶层，查找文件时优先查找PakPlatformFile内的文件</span><br>    PlatformFileManager-&gt;SetPlatformFile(*HandlePakPlatform);<br>    <span class="hljs-comment">//判断文件是否存在</span><br>    <span class="hljs-keyword">if</span> (!HandleOriginPlatform-&gt;FileExists(*PakFilePath))<br>    &#123; <br>        PlatformFileManager-&gt;SetPlatformFile(*HandleOriginPlatform);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">//创建pak对象</span><br>    TSharedPtr&lt;FPakFile&gt; PakFile = MakeShareable&lt;FPakFile&gt;(<span class="hljs-keyword">new</span> FPakFile(HandlePakPlatform, *PakFilePath, <span class="hljs-literal">false</span>));<br>    <span class="hljs-keyword">if</span> (!PakFile)<br>    &#123;<br>        PlatformFileManager-&gt;SetPlatformFile(*HandleOriginPlatform);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;   <br>    <span class="hljs-comment">//获取pak文件的无后缀文件名</span><br>    FString PakName = GetPakFileName(PakFilePath);<br>    TArray&lt;FString&gt; ExistPakFiles;<br>    <span class="hljs-comment">//查询已挂载的所有pak包名称</span><br>    HandlePakPlatform-&gt;GetMountedPakFilenames(ExistPakFiles);<br>    <span class="hljs-comment">//判断当前pak包是否已挂载</span><br>    <span class="hljs-keyword">if</span> (ExistPakFiles.Find(PakFilePath) &gt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        PlatformFileManager-&gt;SetPlatformFile(*HandleOriginPlatform);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    int32 Pos = PakFile-&gt;GetMountPoint().Find(<span class="hljs-string">&quot;Content/&quot;</span>);<br>    FString MountPoint = PakFile-&gt;GetMountPoint().RightChop(Pos);<br>    MountPoint = FPaths::ProjectDir() + MountPoint;<br>    PakFile-&gt;SetMountPoint(*MountPoint);<br>    <span class="hljs-comment">//使用pak包记录的挂载点挂载pak包</span><br>    <span class="hljs-keyword">if</span> (!HandlePakPlatform-&gt;Mount(*PakFilePath, <span class="hljs-number">0</span>, *PakFile-&gt;GetMountPoint()))<br>    &#123;<br>        PlatformFileManager-&gt;SetPlatformFile(*HandleOriginPlatform);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    PlatformFileManager-&gt;SetPlatformFile(*HandleOriginPlatform);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有一些类和函数需要说明一下：</p><ul><li>IPlatformFile：这是UE4对文件操作的最基础的类，定义了对文件进行操作的相关方法，UE4自己单独封装一个文件操作类而不是直接用C++的文件操作，是UE4为了提供平台的可移植性才建立这么一个更高层的I/O接口；</li><li>FPakPlatformFile：这个类是UE4对pak文件操作的一个封装类，派生与IPlatformFile类；</li><li>FPlatformFileManager：这个类是UE4用于获取不同平台的物理文件的封装，Get()方法是获取类自身的实例，GetPlatformFile()方法是获取文件操作链的链头，如果没有找到则返回nullptr；</li><li>Initialize()：初始化接口，第一个参数为FPakPlatformFile类指向的下一个文件类对象，我们这里是需要指向当前平台，第二参数是一个命令行，部分文件类会从这里解析一些参数，我们这里没有命令，所以用空字符串；</li><li>SetPlatformFile()：可以理解为想UE4文件系统设置Initialize()初始化的配置；</li><li>GetMountedPakFilenames()：获取已经挂载过的pak文件，参数为一个FString数组；</li><li>GetMountPoint()：获取pak文件的挂载点，这个挂载点是直接存储在pak文件中的，pak文件的结构具体将<a href="https://zhuanlan.zhihu.com/p/333857439">弘竣的开发笔记</a>；</li><li>RightChop()：返回字符串指定位置右侧的字符串；</li><li>SetMountPoint()：设置挂载点，pak文件的挂载必须得有挂载点，否则UE4就无法找到pak文件，挂载点就是pak文件在UE4中上级目录；</li><li>Mount()：挂载pak文件；</li></ul><p>这里有一点需要注意的是，PlatformFileManager-&gt;SetPlatformFile(*HandlePakPlatform);设置文件系统不可以在构造函数中执行否则打包会报错。</p><p>到这里一个pak文件的挂载就完成了。</p><h3 id="里面的一些坑"><a href="#里面的一些坑" class="headerlink" title="里面的一些坑"></a>里面的一些坑</h3><p>在网上搜了相当多的UE4pak挂载的文章，里面大多数使用共享指针来指向FPakPlatformFile，我在UE4.26中在未勾选Edit\Project Setting\Packaging\Use Pak File的情况下，不会有任何问题，但是在勾选了的情况下会在退出游戏时报：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127135820.png"></p><p>具体原因暂不清楚，所以我上面的源码一律没有使用共享指针，而是选择了C++指针，自己去管理指针。</p><h2 id="4-Pak文件的加载"><a href="#4-Pak文件的加载" class="headerlink" title="4.Pak文件的加载"></a>4.Pak文件的加载</h2><h3 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h3><p>想要加载Pak文件中的资源进入内存我们就只能使用C++的方式来加载，我以加载一个AActor为例，先上源码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">AActor* <span class="hljs-title">UPakExpand::SpawnActorFromPak</span><span class="hljs-params">(FString ClassRef, FTransform Transform, <span class="hljs-keyword">bool</span>&amp; Result)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!HandlePakPlatform)<br>    &#123;<br>        Result = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    PlatformFileManager-&gt;SetPlatformFile(*HandlePakPlatform);<br>    UClass* uclass = StaticLoadClass(AActor::StaticClass(), <span class="hljs-literal">NULL</span>, *ClassRef);<br>    <span class="hljs-keyword">if</span> (!uclass)<br>    &#123;<br>        Result = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    AActor* Actor = GetWorld()-&gt;SpawnActor(uclass,&amp;Transform);<br>    <span class="hljs-keyword">if</span> (!Actor)<br>    &#123;<br>        Result = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;   <br>    <span class="hljs-keyword">if</span> (!HandleOriginPlatform)<br>    &#123;<br>        Result = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    PlatformFileManager-&gt;SetPlatformFile(*HandleOriginPlatform);<br>    Result = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> Actor;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>PlatformFileManager-&gt;SetPlatformFile(*HandlePakPlatform);将文件系统切换到Pak文件系统，这样才能读取到Pak包中的资源，因为引擎默认使用的是物理文件系统，而Pak包挂载的不是物理文件，所以使用物理文件系统是无法读取到Pak文件内的资源的。</li><li>PlatformFileManager-&gt;SetPlatformFile(*HandleOriginPlatform);将文件系统切换回原来的文件系统，实际上切不切回去是没有影响的，因为SetPlatformFile是在当前的文件操作链的链头再加一个操作节点，然后以这个新的操作节点作为文件操作链的链头，当加载资源时会从操作链的链头开始搜索资源，当然，当我们不需要再加载Pak包中的资源时，切回去可以使操作链少一个节点，资源的寻找速度会更快一点，所以这里我还是切回去。</li></ul><h3 id="里面的一些坑-1"><a href="#里面的一些坑-1" class="headerlink" title="里面的一些坑"></a>里面的一些坑</h3><p>这里有一点是需要注意的，前面有说过挂载只是在引擎内部注册了一个虚拟文件夹，这个文件夹在实际的物理目录中是不存在的，所以如果我们在编辑状态下直接使用要打成Pak文件的这些资源，在挂载了Pak之后引擎依然是找不到这些资源的，原因我猜是编辑状态下使用资源保存的路径应该是封装整个程序资源的Pak文件的路径即这个Pak文件：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127135826.png"></p><p>这里面有一个比较隐晦的状况，就是如果我们打包的时候不排除需要Pak的文件夹，也就是说打包的时候把需要Pak的文件一并打进Unkown-WindowsNoEditor.pak这个Pak文件中，在实际运行的效果是，资源是可以被加载的，这是因为引擎加载的资源是Unkown-WindowsNoEditor.pak中的资源，而非我们自己挂载的Pak包中的资源，我们可通过修改Pak包中的资源内容，重新运行来证明这个问题。而如果我们把需要打Pak的文件夹不打包进Unkown-WindowsNoEditor.pak中，那么资源就识别不出来了。如果资源只是在Pak包自己内部使用则没有这个问题。</p><p>我们通过一个例子也许会更好理解一些。</p><p><strong>第一步：</strong></p><p>在Content文件夹下创建一个需要Pak的文件夹命名为DLCs，在里面创建两个资源，给Pak包外部使用的PakActor和给Pak包内部使用的PakWidget。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127135830.png"></p><p>两个资源的内部情况如下：</p><p><strong>PakActor：</strong></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127135835.png"></p><p>在PakActor中去创建PakWidget，注意这里是直接在编辑状态下去加载PakWidget，并且PakWidget和PakActor在同一个文件夹下，即将来打Pak包后，两个资源在同一个Pak包中。</p><p>PrintDebugLog是自己封装的一个打印日志的函数。</p><p><strong>PakWidget：</strong></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127135910.png"></p><p><strong>第二步：</strong></p><p>在另一个文件夹下去创建一个GameInstance，使用GameInstance去挂载并加载资源，这里我创建一个名为UnkGameInstance的GameInstance，并放在Content/GamePlay文件夹下，蓝图内容如下：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127135915.png"></p><p>这里我们先使用在编辑状态下直接使用UE4原生API<code>SpawnActorFromClass</code>来加载PakActor，</p><p>好，现在我们不排除Content/DLCs文件夹，在Project Setting/Packaging/Packaging/Directories to never cook项不添加文件夹，勾选Use Pak File。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127135920.png"></p><p>然后打一个Windows程序出来，然后把Content/DLCs文件夹打一个Pak包出来，我这里命名为PakActor.pak，并将Pak包放入程序目录/Content/DLCs/目录下。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127135929.png"></p><p>可以看到在勾选了UsePakFile时引擎自动生成了一个Paks文件夹下的<code>&lt;项目名&gt;-&lt;平台类型&gt;.pak</code>的文件，我这里是Unkown-WindowsNoEditor.pak文件，而DLCs文件夹是没有的，所以我们要自己创建一个，并把打包出来的Pak文件放进去，需要注意的是Pak文件的命名需要和加载时的名称要一致。</p><p>然后我们跑起来看一下。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127135933.png"></p><p>PakActor和PakWidget资源是加载出来了的，此时我们无法分辨加载的到底是Unkown-WindowsNoEditor.pak中的资源还是PakActor.pak中的资源，因为在两个pak包中都存在一份/Game/DLCs/PakActor.uasset和/Game/DLCs/PakWidget.uasset资源。</p><p>为了识别资源是哪个Pak包中的，有两种方式验证，先看第一种</p><p>现在我们修改一下PakActor蓝图的打印的内容：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127135937.png"></p><p>把this is PakActor修改成this is PakActor2，然后再打一个Pak包出来，同样命名为PakActor.pak并放到Content/DLCs/目录下替换掉之前的pak包，然后我们再跑一次看看，打印内容有没有变化。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127135942.png"></p><p>可以看到，打印的内容依旧是this is PakActor，这说明加载到PakActor不是PakActor.pak中的资源而是Unkown-WindowsNoEditor.pak中的资源，因为我们没有重新打包程序，所以Unkown-WindowsNoEditor.pak中的PakActor.uasset打印依然是this is PakActor，而PakActor.pak中PakActor.uasset打印已经修改成了this is PakActor2。</p><p>为了严谨起见，我们再用第二种方式验证一遍。</p><p>现在我们在打包时不把Content/DLCs/文件夹打进Unkown-WindowsNoEditor.pak中，在Project Setting/Packaging/Packaging/Directories to never cook项中把Content/DLCs/添加进去。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127135946.png"></p><p>然后我们再打包来跑一次看看。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127135950.png"></p><p>可以看到没有任何打印出来，并且PakWidget也没有加载出来，我们再看一下日志，日志存储在<code>&lt;程序目录&gt;/&lt;项目名称&gt;/Saved/Logs/</code>目录下。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127135955.png"></p><p>日志打印了PakActor is not valid这说明PakActor未识别到，由于此时Unkown-WindowsNoEditor.pak中不包含PakActor.uasset资源，只有PacActor.pak中包含，所以可以验证在编辑状态下使用Pak中的资源引擎保存的路径和实际Pak挂载的路径是不一致的(尽管匹配到物理路径上两者是一样的，个人猜想编辑状态下使用的是物理路径，而挂载使用的是虚拟路径，纯个人猜想)。</p><p>好，现在我们换一种方式来加载Pak包中的资源，使用前面我们封装好的UPakExpand::SpawnActorFromPak函数，通过C++的方式来加载，我们重新修改一下UnkGameInstance的蓝图内容。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127140009.png"></p><p>重新打一个包出来，这一次我们依旧不把Content/DLCs/文件夹打进Unkown-WindowsNoEditor.pak，重新打一份程序，再跑一次看看。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127140017.png"></p><p>可以看到，我们对PakActor的修改也生效了，嗯，这就是这个坑的解释。</p><h2 id="5-Pak文件的加密"><a href="#5-Pak文件的加密" class="headerlink" title="5.Pak文件的加密"></a>5.Pak文件的加密</h2><p>UE提供了UnrealPak工具提供了对Pak文件的加密功能，通过Project Settings/Crypto/Encryption/Generate New Encryption Key可以自动生成用于加密Pak文件的密钥，并且这些配置信息会保存在<code>&lt;项目目录&gt;/Config/DefaultCrypto.ini</code>文件中。</p><h3 id="使用预定义文件加密Pak文件"><a href="#使用预定义文件加密Pak文件" class="headerlink" title="使用预定义文件加密Pak文件"></a>使用预定义文件加密Pak文件</h3><p>在我们对项目进行了打包操作后，UE会根据Project Settings/Crypto/Encryption/中配置生成一个&lt;项目目录&gt;/Saved/Cooked/&lt;平台名称&gt;/&lt;项目名称&gt;/Metadata/Crypto.json文件，这个文件使用Json的格式保存了配置中的信息，以便UnrealPak使用。具体加密指令如下：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">D:<span class="hljs-symbol">\U</span>E_4.26_SourceCode<span class="hljs-symbol">\U</span>nrealEngine-4.26<span class="hljs-symbol">\E</span>ngine<span class="hljs-symbol">\B</span>inaries<span class="hljs-symbol">\W</span>in64<span class="hljs-symbol">\U</span>nrealPak.exe D:<span class="hljs-symbol">\U</span>E4<span class="hljs-symbol">\P</span>aks<span class="hljs-symbol">\P</span>akActor.pak -create=D:<span class="hljs-symbol">\U</span>E4<span class="hljs-symbol">\U</span>nkown<span class="hljs-symbol">\U</span>nkown<span class="hljs-symbol">\S</span>aved<span class="hljs-symbol">\C</span>ooked<span class="hljs-symbol">\W</span>indowsNoEditor<span class="hljs-symbol">\U</span>nkown<span class="hljs-symbol">\C</span>ontent<span class="hljs-symbol">\D</span>LCs -encrypt -encryptindex -compress -cryptokeys=D:<span class="hljs-symbol">\U</span>E4<span class="hljs-symbol">\U</span>nkown<span class="hljs-symbol">\U</span>nkown<span class="hljs-symbol">\S</span>aved<span class="hljs-symbol">\C</span>ooked<span class="hljs-symbol">\W</span>indowsNoEditor<span class="hljs-symbol">\U</span>nkown<span class="hljs-symbol">\M</span>etadata<span class="hljs-symbol">\C</span>rypto.json<br></code></pre></td></tr></table></figure><ul><li>-encrypt : 加密Pak文件；</li><li>-encryptindex : 加密索引，解包时不提供Key无法解包，如果不使用这个参数，解包时就不需要Key也可以解包；</li><li>-compress : 对Pak文件数据进行压缩；</li><li>-cryptokeys : 指向加密需要的带密钥的Json文件；</li></ul><p>更多指令可以参考<a href="https://www.cnblogs.com/shiroe/p/14803859.html">代码质疑人生</a>的这篇博客。</p><p>按理说在Project Settings/Crypto/Encryption/中应该可以对-encrypt和-encryptindex参数进行配置，且在Crypto.json中也都有字段存储，但是似乎在使用UnrealPak打包时依旧需要手动指定，否则加密无效。</p><h3 id="使用自定义文件加密Pak"><a href="#使用自定义文件加密Pak" class="headerlink" title="使用自定义文件加密Pak"></a>使用自定义文件加密Pak</h3><p>-cryptokeys除了可以读取UE打包时自动生成的json文件中的密钥来加密Pak，也可以使用自定义的json文件来加密Pak，只需要json中有一个<code>EncryptionKey</code>对象，对象中有一个<code>Key</code>字段即可，如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br><span class="hljs-attr">&quot;EncryptionKey&quot;</span>:<br>&#123;<br><span class="hljs-attr">&quot;Key&quot;</span>:<span class="hljs-string">&quot;xlTq7RXTF5yhLRkoJd8m9tQMdjxsalROP6DycVf+UNc=&quot;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Json可以有其他的自定义字段。</p><h2 id="6-Pak文件的解密"><a href="#6-Pak文件的解密" class="headerlink" title="6.Pak文件的解密"></a>6.Pak文件的解密</h2><h3 id="使用UnrealPak解密"><a href="#使用UnrealPak解密" class="headerlink" title="使用UnrealPak解密"></a>使用UnrealPak解密</h3><p>使用UnrealPak解密基本和加密是反着来的，当然加密和解密必须使用同一个Key，否者解密会失败。</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">D:<span class="hljs-symbol">\U</span>E_4.26_SourceCode<span class="hljs-symbol">\U</span>nrealEngine-4.26<span class="hljs-symbol">\E</span>ngine<span class="hljs-symbol">\B</span>inaries<span class="hljs-symbol">\W</span>in64<span class="hljs-symbol">\U</span>nrealPak.exe D:<span class="hljs-symbol">\U</span>E4<span class="hljs-symbol">\P</span>aks<span class="hljs-symbol">\P</span>akActor.pak -Extract D:<span class="hljs-symbol">\U</span>E4<span class="hljs-symbol">\P</span>aks<span class="hljs-symbol">\P</span>akContent -cryptokeys=D:<span class="hljs-symbol">\U</span>E4<span class="hljs-symbol">\U</span>nkown<span class="hljs-symbol">\U</span>nkown<span class="hljs-symbol">\S</span>aved<span class="hljs-symbol">\C</span>ooked<span class="hljs-symbol">\W</span>indowsNoEditor<span class="hljs-symbol">\U</span>nkown<span class="hljs-symbol">\M</span>etadata<span class="hljs-symbol">\C</span>rypto.json<br></code></pre></td></tr></table></figure><p>这个指令会把Pak中的文件全部解包成源文件。</p><h3 id="挂载时解密"><a href="#挂载时解密" class="headerlink" title="挂载时解密"></a>挂载时解密</h3><p>在代码中解密Pak包需要用到UE内置的FPakEncryptionKeyDelegate委托，且UE在FCoreDelegates类中已经预制了FPakEncryptionKeyDelegate的对象，可以通过FCoreDelegates::GetPakEncryptionKeyDelegate()函数获取。在UE通过Mount挂载Pak包是会判断Pak有没有加密，如果加密了则使用委托调用绑定的解密函数来获取密钥进而对Pak文件进行密钥验证。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//Mount重载，解密挂载</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">UPakExpand::Mount</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString PakFilePath, <span class="hljs-keyword">const</span> FString CryptoJsonPath)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (CryptoJsonPath.IsEmpty())<br>    &#123;<br>        <span class="hljs-keyword">return</span> Mount(PakFilePath);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        SetEncryptJsonPath(CryptoJsonPath);<br>        <span class="hljs-comment">//UE4预制委托，当挂载Pak包的时候自动调用</span><br>        FCoreDelegates::GetPakEncryptionKeyDelegate().BindUObject(<span class="hljs-keyword">this</span>, &amp;UPakExpand::UnEncrypt);<br>        <span class="hljs-keyword">return</span> Mount(PakFilePath);<br>    &#125;   <br>&#125;<br><span class="hljs-comment">//设置存储密钥的文件路径，之所以要专门设置密钥文件的路径，是因为GetPakEncryptionKeyDelegate()返回的委托是一个返回值为空，参数为uint8*的委托，无法直接往UnEncrypt函数传入文件路径</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UPakExpand::SetEncryptJsonPath</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString CryptoJsonPath)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (FPaths::FileExists(CryptoJsonPath))<br>    &#123;<br>        EncryptJsonPath = CryptoJsonPath;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//读取json文件</span><br><span class="hljs-function">FString <span class="hljs-title">UPakExpand::ReadEncryptKeyStrFromJson</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!FPaths::FileExists(EncryptJsonPath))<br>    &#123;<br>        <span class="hljs-keyword">return</span> FString(TEXT(<span class="hljs-string">&quot;&quot;</span>));<br>    &#125;<br>    FString JsonStr;<br>    FFileHelper::LoadFileToString(JsonStr, *EncryptJsonPath);<br>    TSharedPtr&lt;FJsonObject&gt; JsonObject = MakeShareable(<span class="hljs-keyword">new</span> FJsonObject());<br>    TSharedRef&lt;TJsonReader&lt;&gt;&gt; JsonReader = TJsonReaderFactory&lt;&gt;::Create(JsonStr);<br>    FString KeyStr;<br>    <span class="hljs-keyword">if</span> (FJsonSerializer::Deserialize(JsonReader, JsonObject))<br>    &#123;<br>        TSharedPtr&lt;FJsonObject&gt; EncryptionKey = JsonObject-&gt;GetObjectField(TEXT(<span class="hljs-string">&quot;EncryptionKey&quot;</span>));<br>        KeyStr = EncryptionKey-&gt;GetStringField(TEXT(<span class="hljs-string">&quot;Key&quot;</span>));<br>        <span class="hljs-keyword">return</span> KeyStr;<br>    &#125;<br>    <span class="hljs-keyword">return</span> FString(TEXT(<span class="hljs-string">&quot;&quot;</span>));<br>&#125;<br><span class="hljs-comment">//密钥转码将ascii码下表现为字符串的密钥转换成二进制码</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UPakExpand::UnEncrypt</span><span class="hljs-params">(uint8* Key)</span></span><br><span class="hljs-function"></span>&#123;<br>    FString KeyStr = ReadEncryptKeyStrFromJson();  <br>    TArray&lt;uint8&gt; KeyBase64Ary;<br>    FBase64::Decode(KeyStr, KeyBase64Ary);<br>    FMemory::Memcpy(Key, KeyBase64Ary.GetData(), FAES::FAESKey::KeySize);<br>&#125;<br></code></pre></td></tr></table></figure><p>Pak文件的解密实际上也不难，我们对第三小节Pak挂载的Mount函数进行函数重载，再挂载Pak文件之前先对Pak文件进行解密，这里之所以使用文件的形式来加载密钥而不是直接将密钥定义再代码里是为了更灵活的使不同的Pak包可以使用不同的密钥来加密解密。</p><h2 id="7-Pak加载的优先级"><a href="#7-Pak加载的优先级" class="headerlink" title="7.Pak加载的优先级"></a>7.Pak加载的优先级</h2><p>当同一份资源同时存在于两个pak文件中时，就涉及到资源加载的优先级问题了。</p><h3 id="目录优先级"><a href="#目录优先级" class="headerlink" title="目录优先级"></a>目录优先级</h3><p>我们可以直接从源码入手</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">int32 <span class="hljs-title">FPakPlatformFile::GetPakOrderFromPakFilePath</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString&amp; PakFilePath)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (PakFilePath.StartsWith(FString::Printf(TEXT(<span class="hljs-string">&quot;%sPaks/%s-&quot;</span>), *FPaths::ProjectContentDir(), FApp::GetProjectName())))<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (PakFilePath.StartsWith(FPaths::ProjectContentDir()))<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (PakFilePath.StartsWith(FPaths::EngineContentDir()))<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (PakFilePath.StartsWith(FPaths::ProjectSavedDir()))<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>源码的注释是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* Hardcode default load ordering of game main pak -&gt; game content -&gt; engine content -&gt; saved dir</span><br><span class="hljs-comment">* would be better to make this config but not even the config system is initialized here so we can&#x27;t do that</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> int32 <span class="hljs-title">GetPakOrderFromPakFilePath</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString&amp; PakFilePath)</span></span>;<br></code></pre></td></tr></table></figure><p>UE会在游戏启动时自动挂载某些目录下的Pak文件，分别是&lt;项目目录&gt;/Content/Paks，&lt;引擎目录&gt;/Content/Paks，&lt;项目目录&gt;/Saved/Paks</p><p>这里的项目目录和引擎目录均是打包后游戏根目录下的项目目录和引擎目录。</p><p>三者满足优先级：<code>&lt;项目目录&gt;/Content/Paks</code>  &gt;  <code>&lt;引擎目录&gt;/Content/Paks</code>  &gt;  <code>&lt;项目目录&gt;/Saved/Paks</code>，其中最高优先级为游戏主Pak包，即在&lt;项目目录&gt;/Content/Paks/目录下以项目名开头，由引擎打包出来的Pak文件。</p><p>但是我在实际测试中发现实际加载顺序不是这样的，具体原因未知。</p><p>我分别在三个目录下放入一个内容相同而名字不同的三个Pak文件，通过日志看看挂载顺序：</p><p>Pak位置情况：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127140030.png"></p><p>Pak加载日志，exe运行后会在/游戏根目录/Saved/Logs/目录下生成运行日志，其中<code>项目名称.log</code>为最新的日志：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127140034.png"></p><p>可以看到，位于&lt;项目目录&gt;/Saved/Paks/PakActor_3.pak最先加载，而游戏主Pak包/&lt;项目目录&gt;/Content/Paks/Unkown-WindowsNoEditor.pak第二加载，/&lt;项目目录&gt;/Content/Paks/PakActor_1.pak第三加载，/&lt;引擎目录&gt;/Content/Paks/PakActor_2.pak最后加载。</p><p>加载顺序似乎有出入，目前未找到原因，不过一般不影响正常游戏流程。</p><h3 id="二级优先级"><a href="#二级优先级" class="headerlink" title="二级优先级"></a>二级优先级</h3><p>在满足目录优先级的情况下，UE还增加了Pak文件名以<code>_P.pak</code>结尾的二级优先级，如：Pak_P.pak的优先级就要高于Pak.pak，而Pak_1_P.pak的优先级又高于Pak_P.pak，Pak_2_P.pak高于Pak_1_P.pak，以此类推。来实践验证一下。</p><p>前面有说过，在PakActor蓝图中创建了一个黑色的PakWidget界面，现在把PakWidget界面设置成白色，然后再打一个包，重命名为“PakActor_1_P.pak”，一并放入Content/DLCs目录下，这里还需要对挂载做一点改动，即把DLCs目录下的Pak文件都挂载起来，所以我们往UPakExpaned类中新增一个函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">TArray&lt;FString&gt; <span class="hljs-title">UPakExpand::GetAllPakFromDir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString Dir, <span class="hljs-keyword">bool</span>&amp; Result)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">FString <span class="hljs-title">PakDir</span><span class="hljs-params">(FPaths::ProjectContentDir() + Dir + TEXT(<span class="hljs-string">&quot;/&quot;</span>))</span></span>;<br>    IFileManager&amp; FileManager = IFileManager::Get();<br>    TArray&lt;FString&gt; ResultList;<br>    <span class="hljs-keyword">if</span> (FileManager.DirectoryExists(*PakDir))<br>    &#123;<br>        TArray&lt;FString&gt; PakList;      <br>        FileManager.FindFiles(PakList, *PakDir,TEXT(<span class="hljs-string">&quot;*.pak&quot;</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; PakList.Num(); i++)<br>        &#123;<br>            <span class="hljs-function">FString <span class="hljs-title">PakFilePath</span><span class="hljs-params">(PakDir + PakList[i])</span></span>;<br>            ResultList.Add(PakFilePath);<br>        &#125;<br>        Result = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ResultList.Num() &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        Result = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ResultList;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后再UnkGameInstance中对挂载步骤进行改进：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127140041.png"></p><p>Mount节点的CryptoJsonPath参数可以忽略，这是用来解密加密Pak包的。</p><p>Pak包位置：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127140047.png"></p><p>好，运行一下试试</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127140050.png"></p><p>可以看到加载的PakActor已经是PakActor_1_P.pak中的资源了。</p><h2 id="8-以DLC的形式进行资源更新"><a href="#8-以DLC的形式进行资源更新" class="headerlink" title="8.以DLC的形式进行资源更新"></a>8.以DLC的形式进行资源更新</h2><p>DLC的形式与pak包的形式不同的只在于pak包的生成方式，pak包是直接使用命令行烘培和打包的，而DLC则是使用的ProjectLauncher，最终资源都是以pak包的形式下载到本地，只是pak的形式需要我们手动写C++代码挂载，而DLC的形式将pak文件放到指定文件夹内可自动挂载并加载。</p><p>用DLC的形式需要配置两个ProjectLauncher，一个为打包本地的ProjectLauncher，一个为打包DLC的ProjectLauncher，具体配置方法见<a href="http://mingchuan.wang/2016/09/20/UE4-DLC/">wmc的一篇博文</a>。</p><h1 id="五、FCachedReadPlatformFile"><a href="#五、FCachedReadPlatformFile" class="headerlink" title="五、FCachedReadPlatformFile"></a>五、FCachedReadPlatformFile</h1><p>FCachedReadPlatformFile实现了文件的预读写逻辑，FCachedReadPlatformFile对IPlatformFile的修改主要是在OpenRead和OpenWrite的返回值中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">virtual</span> IFileHandle*<span class="hljs-title">OpenRead</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Filename, <span class="hljs-keyword">bool</span> bAllowWrite)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function"></span>&#123;<br>IFileHandle* InnerHandle=LowerLevel-&gt;OpenRead(Filename, bAllowWrite);<br><span class="hljs-keyword">if</span> (!InnerHandle)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FCachedFileHandle(InnerHandle, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> IFileHandle*<span class="hljs-title">OpenWrite</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Filename, <span class="hljs-keyword">bool</span> bAppend = <span class="hljs-literal">false</span>, <span class="hljs-keyword">bool</span> bAllowRead = <span class="hljs-literal">false</span>)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function"></span>&#123;<br>IFileHandle* InnerHandle=LowerLevel-&gt;OpenWrite(Filename, bAppend, bAllowRead);<br><span class="hljs-keyword">if</span> (!InnerHandle)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FCachedFileHandle(InnerHandle, bAllowRead, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>二者的返回值不再是IFileHanle而是其子类FCachedFileHandle，预读逻辑就在FCachedFileHandle中，每次预读64k的数据到一个缓存块，这个类应该是给一些为做预读取优化的平台使用的，而像Windows和PS4这些平台本身就对文件读取做了预读取的平台，UE是默认启用FCachedReadPlatformFile的，即在文件的责任链中是没有FCachedReadPlatformFile节点的，当然我们也可以通过可通过<code>NoCachedReadFile</code>参数和<code>CachedReadFile</code>参数强行关闭或启用。</p><p>个人认为，FCachedReadPlatformFile的使用就是将FCachedReadPlatformFile设置进责任链中，在读取文件时上层抛到FCachedReadPlatformFile时就进行预读取处理。实践验证由于我是Windows平台还想到什么好的验证方法，也就没验证了。</p><h1 id="六、FLoggedPlatformFile"><a href="#六、FLoggedPlatformFile" class="headerlink" title="六、FLoggedPlatformFile"></a>六、FLoggedPlatformFile</h1><p>FLoggedPlatformFile包装类会把每一次对文件的操作都通过UE_LOG使用LogPlatformFile打印到日志中去，使用方法也是将FLoggedPlatformFile对象设置进责任链中，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UPakExpand::ReadFile</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString FilePath)</span></span><br><span class="hljs-function"></span>&#123;<br>    TSharedPtr&lt;FLoggedPlatformFile&gt; LoggedPlatformFile = MakeShareable(<span class="hljs-keyword">new</span> FLoggedPlatformFile());<br>    IPlatformFile&amp; PlatformFile = FPlatformFileManager::Get().GetPlatformFile();<br>    LoggedPlatformFile-&gt;Initialize(PlatformFile, TEXT(<span class="hljs-string">&quot;&quot;</span>));<br>    FPlatformFileManager::Get().SetPlatformFile(*LoggedPlatformFile);<br>    FString FileData;<br>    FFileHelper::LoadFileToString(FileData, *FilePath);<br>    FileData = TEXT(<span class="hljs-string">&quot;this is write data&quot;</span>);<br>    FFileHelper::SaveStringToFile(FileData, *FilePath);<br>    FPlatformFileManager::Get().SetPlatformFile(*PlatformFile);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在UnkGameInstance中调用，运行，打开日志搜索LogPlatformFile：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127140100.png"></p><p>可以看到对文件的读写关闭等操作多被打印进了日志中。</p><h1 id="七、FPlatformFileOpenLog"><a href="#七、FPlatformFileOpenLog" class="headerlink" title="七、FPlatformFileOpenLog"></a>七、FPlatformFileOpenLog</h1><p>FPlatformFileOpenLog包装类的功能、用法和FLoggedPlatformFile类似，FPlatformFileOpenLog类只会记录文件的打开历史，并且在编辑器模式下运行使用单独的EditorOpenOrder.log文件保存，在非Shipping版本的游戏包中使用GameOpenOrder.log文件保存，在Shipping版本的有游戏包中不能使用。在编辑模式下的EditorOpenOrder.log文件保存在&lt;项目目录&gt;\Build\Windows\FileOpenOrder，在Game模式下的GameOpenOrder.log文件保存在&lt;游戏目录&gt;\Build\WindowsNoEditor\FileOpenOrder下。</p><p>现在我们把上面的ReadFile函数修改一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UPlatformFileExpand::ReadFile</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString FilePath)</span></span><br><span class="hljs-function"></span>&#123;<br>    TSharedPtr&lt;FPlatformFileOpenLog&gt; PlatformFileOpenLog = MakeShareable(<span class="hljs-keyword">new</span> FPlatformFileOpenLog());<br>    IPlatformFile&amp; PlatformFile = FPlatformFileManager::Get().GetPlatformFile();<br>    PlatformFileOpenLog-&gt;Initialize(PlatformFile, TEXT(<span class="hljs-string">&quot;&quot;</span>));<br>    FPlatformFileManager::Get().SetPlatformFile(*PlatformFileOpenLog);<br>    FString FileData;<br>    FFileHelper::LoadFileToString(FileData, *FilePath);<br>    DEBUGLOG(FEnumSet::DebugLogType::Log, (TEXT(<span class="hljs-string">&quot;Read file data:&quot;</span>) + FileData));<br>    FileData = TEXT(<span class="hljs-string">&quot;this is write data&quot;</span>);<br>    FFileHelper::SaveStringToFile(FileData, *FilePath);<br>    FPlatformFileManager::Get().SetPlatformFile(*PlatformFile);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后打开</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127140105.png"></p><p>不过后面的数字代表什么意思，暂时还没弄明白，无论重启多少次exe，或在一次启动中打开多次同一文件，后面的数字始终是1。</p><h1 id="八、FNetworkPlatformFile、FCookedIterativeNetworkFile和FStreamingNetworkPlatformFile"><a href="#八、FNetworkPlatformFile、FCookedIterativeNetworkFile和FStreamingNetworkPlatformFile" class="headerlink" title="八、FNetworkPlatformFile、FCookedIterativeNetworkFile和FStreamingNetworkPlatformFile"></a>八、FNetworkPlatformFile、FCookedIterativeNetworkFile和FStreamingNetworkPlatformFile</h1><h2 id="1-FNetworkPlatformFile"><a href="#1-FNetworkPlatformFile" class="headerlink" title="1.FNetworkPlatformFile"></a>1.FNetworkPlatformFile</h2><p>这三个包装文件类都是用于实现网络文件的读取功能，当UE要打开某个文件，而文件却不存在时，则先查看是否连接了文件服务器，连接了则从文件服务器下载文件到本地然后再打开。</p><p>源码中的描述是：用于将低级文件系统重定向到服务器的包装器。</p><p>FCookedIterativeNetworkFile和FStreamingNetworkPlatformFile的初始化函数和前面的包装文件类有所不同：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">InitializeInternal</span><span class="hljs-params">(IPlatformFile* Inner, <span class="hljs-keyword">const</span> TCHAR* HostIP)</span> <span class="hljs-keyword">override</span></span>;<br></code></pre></td></tr></table></figure><p>不仅要指定下层文件类对象，还要指定服务器端口地址，HostIP可以使用<code>tcp://</code>开头指定tcp通信协议，使用<code>http://</code>指定http通信协议，不指定则默认使用tcp，同时可以使用<code>+</code>号分隔来指定多个Host地址，初始化后UE会将本地文件与服务器文件做出映射，以便在本地没有找到文件时能快速的找到服务器中对应的文件，同时在Tick函数中会通过PerformHeartbeat函数监测服务器文件的更新，使本地文件与服务器文件保持一致。</p><p>三者具有优先级，优先级为：FStreamingNetworkPlatformFile<code>&gt;</code>FCookedIterativeNetworkFile<code>&gt;</code>FNetworkPlatformFile</p><p>且在Shipping版本中被禁止使用。</p><p>不是所有的目录下的文件都会在没读取到时去文件服务器下载，在源码中有一个LocalDirectories数组记录着只会进行本地读取的目录：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Save and Intermediate directories are always local</span><br>LocalDirectories.Add(FPaths::EngineDir() / TEXT(<span class="hljs-string">&quot;Binaries&quot;</span>));<br>LocalDirectories.Add(FPaths::EngineIntermediateDir());<br>LocalDirectories.Add(FPaths::ProjectDir() / TEXT(<span class="hljs-string">&quot;Binaries&quot;</span>));<br>LocalDirectories.Add(FPaths::ProjectIntermediateDir());<br>LocalDirectories.Add(FPaths::ProjectSavedDir() / TEXT(<span class="hljs-string">&quot;Backup&quot;</span>));<br>LocalDirectories.Add(FPaths::ProjectSavedDir() / TEXT(<span class="hljs-string">&quot;Config&quot;</span>));<br>LocalDirectories.Add(FPaths::ProjectSavedDir() / TEXT(<span class="hljs-string">&quot;Logs&quot;</span>));<br>LocalDirectories.Add(FPaths::ProjectSavedDir() / TEXT(<span class="hljs-string">&quot;Sandboxes&quot;</span>));<br></code></pre></td></tr></table></figure><p>分别是引擎目录下的Binaries，Intermediate目录，项目目录下的Binaries，Intermediate，Saved/Backup，Saved/Config，Saved/Logs，Saved/SandBoxes目录。</p><h2 id="2-FCookedIterativeNetworkFile"><a href="#2-FCookedIterativeNetworkFile" class="headerlink" title="2.FCookedIterativeNetworkFile"></a>2.FCookedIterativeNetworkFile</h2><p>FCookedIterativeNetworkFile在FNetworkPlatformFile的基础上增加了，本地Pak文件绕过网络访问的机制，如在某次更新中有些Pak文件未做修改，可以不更新，尽管服务器中这些Pak文件的版本号更高了，但是由于内容未做更改所以可以使用FCookedIterativeNetworkFile直接绕过更新。</p><h2 id="3-FStreamingNetworkPlatformFile"><a href="#3-FStreamingNetworkPlatformFile" class="headerlink" title="3.FStreamingNetworkPlatformFile"></a>3.FStreamingNetworkPlatformFile</h2><p>FStreamingNetworkPlatformFile在FNetworkPlatformFile的基础上实现了对服务器的流式访问，和FNetworkPlatformFile不能对服务器文件进行修改不同，FStreamingNetworkPlatformFile可以直接修改服务器上的文件，FStreamingNetworkPlatformFile对文件的访问操作均是直接操作的服务器文件。</p><p>这里引用<a href="https://dhbloo.github.io/2020/09/07/UE4-FileSystem/#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%88%9B%E5%BB%BA">dhb</a>大佬博客的一段原话：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl">打开文件的<span class="hljs-function"><span class="hljs-title">OpenRead</span>()、<span class="hljs-title">OpenWrite</span>()函数使用<span class="hljs-title">SendOpenMessage</span>()通知服务器打开文件，服务器会返回一个文件的句柄<span class="hljs-variable">ID</span>，后续对该文件的操作以这个句柄<span class="hljs-variable">ID</span>作为标识。在接口配套定义的<span class="hljs-variable">FStreamingNetworkFileHandle</span>文件句柄中，<span class="hljs-title">Read</span>()、<span class="hljs-title">Write</span>()等操作都被转换到对服务器发送消息，分别在<span class="hljs-title">SendReadMessage</span>()与<span class="hljs-title">SendWriteMessage</span>()中。这样，对文件的读取实时从服务器获得（每次网络传输以<span class="hljs-number">64</span><span class="hljs-variable">KB</span>的块为单位进行，进行缓存），而对文件的写入则实时发送到服务器。</span><br></code></pre></td></tr></table></figure><h1 id="九、FSandboxPlatformFile"><a href="#九、FSandboxPlatformFile" class="headerlink" title="九、FSandboxPlatformFile"></a>九、FSandboxPlatformFile</h1><h2 id="1-什么是沙盒"><a href="#1-什么是沙盒" class="headerlink" title="1.什么是沙盒"></a>1.什么是沙盒</h2><p>FSandboxPlatformFile是UE实现的一个简单的沙盒机制，首先我们需要了解什么是沙盒：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">沙盒机制是内存空间访问的一种安全机制，一个应用程序被分配到专属于自己的存储空间，程序只能在自己的空间中访问内存，不可以越过边界访问外部内存，这个区域就叫沙盒。<br></code></pre></td></tr></table></figure><h2 id="2-FSandboxPlatformFile的使用"><a href="#2-FSandboxPlatformFile的使用" class="headerlink" title="2.FSandboxPlatformFile的使用"></a>2.FSandboxPlatformFile的使用</h2><p>FSandboxPLatformFile的使用需要在.Build.cs中添加<code>SandBoxFile</code>模块，且FSandboxPlatformFile的构造函数不是公有的，需要使用FSandboxPLatformFile::Create函数来创建TUniquePtr指针来使用。</p><p>关于FSandboxPlatformFile的使用网上的资料几乎为零，在官方文档也只找到了类的描述，没办法还得自己上手撸源码。</p><p>首先先上一段自己写的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UPlatformFileExpand::ReadFile</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString FilePath)</span></span><br><span class="hljs-function"></span>&#123;<br>    TUniquePtr&lt;FSandboxPlatformFile&gt; SandboxPlatformFile = FSandboxPlatformFile::Create(<span class="hljs-literal">true</span>);<br>    IPlatformFile&amp; PlatformFile = FPlatformFileManager::Get().GetPlatformFile();<br>    SandboxPlatformFile-&gt;Initialize(&amp;PlatformFileTmp, TEXT(<span class="hljs-string">&quot;-Sandbox=Unique&quot;</span>));<br>    SandboxPlatformFile-&gt;SetSandboxEnabled(<span class="hljs-literal">true</span>);<br>    FPlatformFileManager::Get().SetPlatformFile(*SandboxPlatformFile);<br>    FString FileData;<br>    FFileHelper::LoadFileToString(FileData, *FilePath);<br>    FPlatformFileManager::Get().SetPlatformFile(PlatformFile);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Initialize：FSandboxPlatformFile的初始化需要添加命令行参数，<code>-sandbox=</code>，看源码可以看出UE提供多种沙盒类型：</li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FSandboxPlatformFile::Initialize</span><span class="hljs-params">(IPlatformFile* Inner, <span class="hljs-keyword">const</span> TCHAR* CmdLine)</span></span><br><span class="hljs-function"></span>&#123;<br>FString CommandLineDirectory;<br>FParse::Value( CmdLine, TEXT(<span class="hljs-string">&quot;-Sandbox=&quot;</span>), CommandLineDirectory);<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">if</span> (LowerLevel != <span class="hljs-literal">NULL</span> &amp;&amp; !CommandLineDirectory.IsEmpty())<br>&#123;<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">if</span>( CommandLineDirectory == TEXT(<span class="hljs-string">&quot;User&quot;</span>) )<br>&#123;<br><span class="hljs-comment">// Special case - platform defined user directory will be used</span><br>SandboxDirectory = FPlatformProcess::UserDir();<br>SandboxDirectory += TEXT(<span class="hljs-string">&quot;My Games/&quot;</span>);<br>SandboxDirectory += TEXT( <span class="hljs-string">&quot;UE4/&quot;</span> );<br>bSandboxIsAbsolute = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( CommandLineDirectory == TEXT(<span class="hljs-string">&quot;Unique&quot;</span>) )<br>&#123;<br><span class="hljs-keyword">const</span> FString Path = FPaths::GetRelativePathToRoot() / TEXT(<span class="hljs-string">&quot;&quot;</span>);<br>SandboxDirectory = FPaths::ConvertToSandboxPath( Path, *FGuid::NewGuid().ToString() );<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (CommandLineDirectory.StartsWith(TEXT(<span class="hljs-string">&quot;..&quot;</span>)))<br>&#123;<br><span class="hljs-comment">// for relative-specified directories, just use it directly, and don&#x27;t put into FPaths::ProjectSavedDir()</span><br>SandboxDirectory = CommandLineDirectory;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( FPaths::IsDrive( CommandLineDirectory.Mid( <span class="hljs-number">0</span>, CommandLineDirectory.Find(TEXT(<span class="hljs-string">&quot;/&quot;</span>), ESearchCase::CaseSensitive) ) ) == <span class="hljs-literal">false</span> ) <br>&#123;<br><span class="hljs-keyword">const</span> FString Path = FPaths::GetRelativePathToRoot() / TEXT(<span class="hljs-string">&quot;&quot;</span>);<br>SandboxDirectory = FPaths::ConvertToSandboxPath( Path, *CommandLineDirectory );<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>SandboxDirectory = CommandLineDirectory;<br>bSandboxIsAbsolute = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>  -Sandbox=可以指定<code>User</code>，<code>Unique</code>，<code>..</code>，<code>自定义目录</code>等参数。</p><ul><li><p><code>User</code>：在用户用户目录下创建沙盒目录，如：C:/Users/admin/Documents/My Games/UE4/Unkown/GitToken.txt</p></li><li><p><code>Unique</code>：在项目目录/Saved目录下使用唯一的编码创建沙盒目录，如：D:/UE4/Unkown/Unkown/Saved/Sandboxes/260659334D930AEACA179EB8977A20F8/Unkown/GitToken.txt</p></li><li><p><code>..</code>：在引擎目录/Binaries目录下创建沙盒目，如：D:/UnrealEngine-4.26/Engine/Binaries/Unkown/GitToken.txt</p></li><li><p><code>自定义参数</code>：使用在自定义目录下作为沙盒目录，如：D:/UESandbox/Unkown/GitToken.txt</p><p><font color="red"> 需要注意的是，这里所说的沙盒目录在实际物理文件夹下是不存在的，这里的目录只是作为一个安全边界来使用。</font></p></li><li><p>FPlatformFileManager::Get().SetPlatformFile(PlatformFile)：这里之所以要把责任链的链头还原回去是因为如果我不设置回去会导致崩溃，<font color="red">这里就有一个疑问了，既然必须要用的时候把沙盒添加到链头，用完了有必须还原回去，那么在还原回去之后，文件依然可以使用非沙盒模式去读取，所以这里使用沙盒又有什么意义呢？</font></p></li></ul><h2 id="3-FSandboxPlatformFile的原理"><a href="#3-FSandboxPlatformFile的原理" class="headerlink" title="3.FSandboxPlatformFile的原理"></a>3.FSandboxPlatformFile的原理</h2><p>FSandboxPlatformFile的核心就是ConvertToSandboxPath()<code>、</code>ConvertFromSandboxPath()，在访问文件时FSandboxPlatformFile会直接将访问文件的路径替换为沙盒路径来使用，使程序处于沙盒模式下无法通过非沙盒路径读写文件。</p><h1 id="十、FPlatformFileReadStats和FProfiledPlatformFile"><a href="#十、FPlatformFileReadStats和FProfiledPlatformFile" class="headerlink" title="十、FPlatformFileReadStats和FProfiledPlatformFile"></a>十、FPlatformFileReadStats和FProfiledPlatformFile</h1><p>FPlatformFileReadStats用于记录文件读取的速度，FProfiledPlatformFile用于记录文件操作得速度，不过这两个类在4.26中似乎已经废弃了，在源码中搜索不到这个类，官方文档也是个404页面。</p><h1 id="十一、FFileHelper"><a href="#十一、FFileHelper" class="headerlink" title="十一、FFileHelper"></a>十一、FFileHelper</h1><p>FFileHelper是UE最顶的文本文件处理类了，提供一系列接口用于处理文本文件，最神奇的是FFileHelper是一个结构体。</p><ul><li><p>BufferToString：从缓冲中读取内容到字符串，适用于比较大的文本，无法一次性把文本都读取到字符串时，使用缓冲分批读取；</p></li><li><p>LoadFileToArray：以二进制的形式一次性加载文本全部内容到一个unit8数组；</p></li><li><p>LoadFileToString：以字符串的形式一次性加载文本的全部内容到一个字符串中；</p></li><li><p>LoadFileToStringArray：以字符串的形式按行加载文本到FString数组中，数组中每一个元素存储文本中一行的文本；</p></li><li><p>LoadFileToStringArrayWithPredicate：以字符串的形式同时使用谓词对文本进行筛选后再加载到FString数组中，数组中每一个元素存储文本中一行的文本；</p><p>按照C++的用法，函数指针既可以指向一个Lambda表达式也是可以指向一个实际的函数的，指向实际的函数时只能使用静态函数；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//使用Lambda表达式</span><br>FFileHelper::LoadFileToStringArrayWithPredicate(Result, *FilePath, [](<span class="hljs-keyword">const</span> FString&amp; Item) &#123;<span class="hljs-keyword">return</span> Item.Contains(TEXT(<span class="hljs-string">&quot;Sandbox&quot;</span>)); &#125;);<br><br><span class="hljs-comment">//使用实际函数</span><br>TFunction&lt;<span class="hljs-keyword">bool</span>(<span class="hljs-keyword">const</span> FString&amp;)&gt; Fun = UPlatformFileExpand::Filter;<br>FFileHelper::LoadFileToStringArrayWithPredicate(Result, *FilePath, Fun);<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Filter</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString&amp; Item)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> Item.Contains(TEXT(<span class="hljs-string">&quot;Sandbox&quot;</span>));<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><ul><li><p>SaveArrayToFile：有两个中类型的重载，一个传入<code>TArrayView&lt;const uint8&gt;</code>类型的参数，一个是传入<code>TArray64&lt;uint8&gt;</code>类型的参数，二者都是TArray的变种，使用方法和TArray基本一致，只是内部构造可能有些不同；</p></li><li><p>SaveStringToFile：把字符串保存到文本文件，可以在字符转中使用<code>\n</code>来对写入的内容进行换行；</p></li><li><p>SaveStringArrayToFile：将String数组元素按行写入到文本文件，一个元素对应一行；</p></li><li><p>CreateBitmap：创建一个bmp图片，其中FColor*参数需要使用一个C++数组；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">FColor color[<span class="hljs-number">20</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>&#123;<br>    color[i] = FColor::Red;<br>&#125;<br>FFileHelper::CreateBitmap(*FilePath, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>, color);<br></code></pre></td></tr></table></figure></li><li><p>GenerateNextBitmapFilename、GenerateDateTimeBasedBitmapFilename：这两个函数从源码来看就是创建一个指定后缀的唯一的文件来存储位图文件，但是并没有创建实际的文件，没搞懂使用来干嘛的；</p></li><li><p>LoadANSITextFileToStrings：专门用来加载ANSI编码的文件；</p></li><li><p>IsFilenameValidForSaving：判断文件是否可用。</p></li></ul><h1 id="十二、FPaths"><a href="#十二、FPaths" class="headerlink" title="十二、FPaths"></a>十二、FPaths</h1><p>FPaths是UE专门用于处理文件路径的封装类，一般文件访问都绕不开FPaths，FPath记录着各种常用的项目、引擎等的目录。</p><ul><li><p>提供路径的接口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs c++">DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;LaunchDir:&quot;</span>) + FPaths::LaunchDir()));<br><span class="hljs-comment">//&gt; LaunchDir:D:\Goulandis\UE4\Unkown\Unkown\Intermediate\ProjectFiles/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;EngineDir:&quot;</span>) + FPaths::EngineDir()));<br><span class="hljs-comment">//&gt; EngineDir:../../../Engine/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;EngineUserDir:&quot;</span>) + FPaths::EngineUserDir()));<br><span class="hljs-comment">//&gt; EngineUserDir:../../../Engine/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;EngineVersionAgnosticUserDir:&quot;</span>) + FPaths::EngineVersionAgnosticUserDir()));<br><span class="hljs-comment">//&gt; EngineVersionAgnosticUserDir:../../../Engine/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;EngineContentDir:&quot;</span>) + FPaths::EngineContentDir()));<br><span class="hljs-comment">//&gt; EngineContentDir:../../../Engine/Content/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;EngineConfigDir:&quot;</span>) + FPaths::EngineConfigDir()));<br><span class="hljs-comment">//&gt; EngineConfigDir:../../../Engine/Config/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;EngineEditorSettingsDir:&quot;</span>) + FPaths::EngineEditorSettingsDir()));<br><span class="hljs-comment">//&gt; EngineEditorSettingsDir:../../../Engine/Saved/Config/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;EngineIntermediateDir:&quot;</span>) + FPaths::EngineIntermediateDir()));<br><span class="hljs-comment">//&gt; EngineIntermediateDir:../../../Engine/Intermediate/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;EngineSavedDir:&quot;</span>) + FPaths::EngineSavedDir()));<br><span class="hljs-comment">//&gt; EngineSavedDir:../../../Engine/Saved/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;EnginePluginsDir:&quot;</span>) + FPaths::EnginePluginsDir()));<br><span class="hljs-comment">//&gt; EnginePluginsDir:../../../Engine/Plugins/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;EngineDefaultLayoutDir:&quot;</span>) + FPaths::EngineDefaultLayoutDir()));<br><span class="hljs-comment">//&gt; EngineDefaultLayoutDir:../../../Engine/Config/Layouts/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;EngineProjectLayoutDir:&quot;</span>) + FPaths::EngineProjectLayoutDir()));<br><span class="hljs-comment">//&gt; EngineProjectLayoutDir:../../../../../Goulandis/UE4/Unkown/Unkown/Config/Layouts/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;EngineUserLayoutDir:&quot;</span>) + FPaths::EngineUserLayoutDir()));<br><span class="hljs-comment">//&gt; EngineUserLayoutDir:../../../Engine/Saved/Config/Layouts/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;EnterpriseDir:&quot;</span>) + FPaths::EnterpriseDir()));<br><span class="hljs-comment">//&gt; EnterpriseDir:D:/UE_4.26_SourceCode/UnrealEngine-4.26/Enterprise/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;EnterprisePluginsDir:&quot;</span>) + FPaths::EnterprisePluginsDir()));<br><span class="hljs-comment">//&gt; EnterprisePluginsDir:D:/UE_4.26_SourceCode/UnrealEngine-4.26/Enterprise/Plugins/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;EnterpriseFeaturePackDir:&quot;</span>) + FPaths::EnterpriseFeaturePackDir()));<br><span class="hljs-comment">//&gt; EnterpriseFeaturePackDir:D:/UE_4.26_SourceCode/UnrealEngine-4.26/Enterprise/FeaturePacks/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;EnginePlatformExtensionsDir:&quot;</span>) + FPaths::EnginePlatformExtensionsDir()));<br><span class="hljs-comment">//&gt; EnginePlatformExtensionsDir:../../../Engine/Platforms/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;ProjectPlatformExtensionsDir:&quot;</span>) + FPaths::ProjectPlatformExtensionsDir()));<br><span class="hljs-comment">//&gt; ProjectPlatformExtensionsDir:../../../../../Goulandis/UE4/Unkown/Unkown/Platforms/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;RootDir:&quot;</span>) + FPaths::RootDir()));<br><span class="hljs-comment">//&gt; RootDir:D:/UE_4.26_SourceCode/UnrealEngine-4.26/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;ProjectDir:&quot;</span>) + FPaths::ProjectDir()));<br><span class="hljs-comment">//&gt; ProjectDir:../../../../../Goulandis/UE4/Unkown/Unkown/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;ProjectUserDir:&quot;</span>) + FPaths::ProjectUserDir()));<br><span class="hljs-comment">//&gt; ProjectUserDir:../../../../../Goulandis/UE4/Unkown/Unkown/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;ProjectContentDir:&quot;</span>) + FPaths::ProjectContentDir()));<br><span class="hljs-comment">//&gt; ProjectContentDir:../../../../../Goulandis/UE4/Unkown/Unkown/Content/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;ProjectConfigDir:&quot;</span>) + FPaths::ProjectConfigDir()));<br><span class="hljs-comment">//&gt; ProjectConfigDir:../../../../../Goulandis/UE4/Unkown/Unkown/Config/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;ProjectSavedDir:&quot;</span>) + FPaths::ProjectSavedDir()));<br><span class="hljs-comment">//&gt; ProjectSavedDir:../../../../../Goulandis/UE4/Unkown/Unkown/Saved/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;ProjectIntermediateDir:&quot;</span>) + FPaths::ProjectIntermediateDir()));<br><span class="hljs-comment">//&gt; ProjectIntermediateDir:../../../../../Goulandis/UE4/Unkown/Unkown/Intermediate/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;ShaderWorkingDir:&quot;</span>) + FPaths::ShaderWorkingDir()));<br><span class="hljs-comment">//&gt; ShaderWorkingDir:C:/Users/admin/AppData/Local/Temp/UnrealShaderWorkingDir/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;ProjectPluginsDir:&quot;</span>) + FPaths::ProjectPluginsDir()));<br><span class="hljs-comment">//&gt; ProjectPluginsDir:../../../../../Goulandis/UE4/Unkown/Unkown/Plugins/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;ProjectModsDir:&quot;</span>) + FPaths::ProjectModsDir()));<br><span class="hljs-comment">//&gt; ProjectModsDir:../../../../../Goulandis/UE4/Unkown/Unkown/Mods/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;ProjectPersistentDownloadDir:&quot;</span>) + FPaths::ProjectPersistentDownloadDir()));<br><span class="hljs-comment">//&gt; ProjectPersistentDownloadDir:../../../../../Goulandis/UE4/Unkown/Unkown/Saved/PersistentDownloadDir</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;SourceConfigDir:&quot;</span>) + FPaths::SourceConfigDir()));<br><span class="hljs-comment">//&gt; SourceConfigDir:../../../../../Goulandis/UE4/Unkown/Unkown/Config/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;GeneratedConfigDir:&quot;</span>) + FPaths::GeneratedConfigDir()));<br><span class="hljs-comment">//&gt; GeneratedConfigDir:../../../../../Goulandis/UE4/Unkown/Unkown/Saved/Config/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;SandboxesDir:&quot;</span>) + FPaths::SandboxesDir()));<br><span class="hljs-comment">//&gt; SandboxesDir:../../../../../Goulandis/UE4/Unkown/Unkown/Saved/Sandboxes</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;ProfilingDir:&quot;</span>) + FPaths::ProfilingDir()));<br><span class="hljs-comment">//&gt; ProfilingDir:../../../../../Goulandis/UE4/Unkown/Unkown/Saved/Profiling/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;ScreenShotDir:&quot;</span>) + FPaths::ScreenShotDir()));<br><span class="hljs-comment">//&gt; ScreenShotDir:../../../../../Goulandis/UE4/Unkown/Unkown/Saved/Screenshots/Windows/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;BugItDir:&quot;</span>) + FPaths::BugItDir()));<br><span class="hljs-comment">//&gt; BugItDir:../../../../../Goulandis/UE4/Unkown/Unkown/Saved/BugIt/Windows/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;VideoCaptureDir:&quot;</span>) + FPaths::VideoCaptureDir()));<br><span class="hljs-comment">//&gt; VideoCaptureDir:../../../../../Goulandis/UE4/Unkown/Unkown/Saved/VideoCaptures/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;ProjectLogDir:&quot;</span>) + FPaths::ProjectLogDir()));<br><span class="hljs-comment">//&gt; ProjectLogDir:../../../../../Goulandis/UE4/Unkown/Unkown/Saved/Logs/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;AutomationDir:&quot;</span>) + FPaths::AutomationDir()));<br><span class="hljs-comment">//&gt; AutomationDir:../../../../../Goulandis/UE4/Unkown/Unkown/Saved/Automation/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;AutomationTransientDir:&quot;</span>) + FPaths::AutomationTransientDir()));<br><span class="hljs-comment">//&gt; AutomationTransientDir:../../../../../Goulandis/UE4/Unkown/Unkown/Saved/Automation/Tmp/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;AutomationReportsDir:&quot;</span>) + FPaths::AutomationReportsDir()));<br><span class="hljs-comment">//&gt; AutomationReportsDir:../../../../../Goulandis/UE4/Unkown/Unkown/Saved/Automation/Reports/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;AutomationLogDir:&quot;</span>) + FPaths::AutomationLogDir()));<br><span class="hljs-comment">//&gt; AutomationLogDir:../../../../../Goulandis/UE4/Unkown/Unkown/Saved/Automation/Logs/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;CloudDir:&quot;</span>) + FPaths::CloudDir()));<br><span class="hljs-comment">//&gt; CloudDir:../../../../../Goulandis/UE4/Unkown/Unkown/Saved/Cloud/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;GameDevelopersDir:&quot;</span>) + FPaths::GameDevelopersDir()));<br><span class="hljs-comment">//&gt; GameDevelopersDir:../../../../../Goulandis/UE4/Unkown/Unkown/Content/Developers/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;GameUserDeveloperFolderName:&quot;</span>) + FPaths::GameUserDeveloperFolderName()));<br><span class="hljs-comment">//&gt; GameUserDeveloperFolderName:admin</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;GameUserDeveloperDir:&quot;</span>) + FPaths::GameUserDeveloperDir()));<br><span class="hljs-comment">//&gt; GameUserDeveloperDir:../../../../../Goulandis/UE4/Unkown/Unkown/Content/Developers/admin/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;DiffDir:&quot;</span>) + FPaths::DiffDir()));<br><span class="hljs-comment">//&gt; DiffDir:../../../../../Goulandis/UE4/Unkown/Unkown/Saved/Diff/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;GameAgnosticSavedDir:&quot;</span>) + FPaths::GameAgnosticSavedDir()));<br><span class="hljs-comment">//&gt; GameAgnosticSavedDir:../../../Engine/Saved/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;EngineSourceDir:&quot;</span>) + FPaths::EngineSourceDir()));<br><span class="hljs-comment">//&gt; EngineSourceDir:../../../Engine/Source/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;GameSourceDir:&quot;</span>) + FPaths::GameSourceDir()));<br><span class="hljs-comment">//&gt; GameSourceDir:../../../../../Goulandis/UE4/Unkown/Unkown/Source/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;FeaturePackDir:&quot;</span>) + FPaths::FeaturePackDir()));<br><span class="hljs-comment">//&gt; FeaturePackDir:D:/UE_4.26_SourceCode/UnrealEngine-4.26/FeaturePacks/</span><br>DEBUGLOG(FEnumSet::DebugLogType::Warning, (TEXT(<span class="hljs-string">&quot;GetProjectFilePath:&quot;</span>) + FPaths::GetProjectFilePath()));<br><span class="hljs-comment">//&gt; GetProjectFilePath:../../../../../Goulandis/UE4/Unkown/Unkown/Unkown.uproject</span><br></code></pre></td></tr></table></figure></li><li><p>GetExtension：获取文件的后缀，不带<code>.</code>；</p></li><li><p>GetCleanFilename：获取带后缀的文件名，不包含路径；</p></li><li><p>GetBaseFilename：获取不带后缀的文件名，不包含路径；</p></li><li><p>GetPath：只获取路径；</p></li><li><p>GetPathLeaf：获取路径中的叶子节点，即路径中最后一个节点，如：D:\UE4\A.txt，则获取到A.txt，D:\UE4\，则获取到UE4；</p></li><li><p>ChangeExtension：当文件有后缀时，改变文件的后缀，否则直接退出；</p></li><li><p>SetExtension：无论文件有没有后缀都为为文件设置一个新的后缀；</p></li><li><p>FileExists：判断文件是否存在；</p></li><li><p>DirectoryExists：判断文件夹是否存在;</p></li><li><p>IsDrive：判断路径是否是根目录，路径中只有<code>C:</code>这种形式才被认定为根目录，<code>:</code>之后不能跟任何东西；</p></li><li><p>IsRelative：判断路径是否是相对路径，路径不能以<code>\</code>或<code>/</code>开头，否则会被认定为False；</p></li><li><p>NormalizeFilename：格式化路径，会将路径中的所有<code>\</code>替换为<code>/</code>；</p></li><li><p>IsSamePath：判断两个路径是否一样；</p></li><li><p>IsUnderDirectory：判断路径是否在某个指定目录下；</p></li><li><p>NormalizeDirectoryName：格式化目录，和NormalizeFilename类似；</p></li><li><p>RemoveDuplicateSlashes：删除路径中重复<code>/</code>；</p></li><li><p>CreateStandardFilename：把UE的相对路径转换成绝对路径，如上面的所示，由于FPaths获取的路径几乎都是<code>../../</code>这种形式，有的时候我们可能需要绝对路径，就可以使用这个函数来转换。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">DEBUGLOG(FEnumSet::DebugLogType::Warning, FPaths::CreateStandardFilename(FPaths::GetProjectFilePath()));<br><span class="hljs-comment">//&gt; GetProjectFilePath: D:/Goulandis/UE4/Unkown/Unkown/Unkown.uproject</span><br></code></pre></td></tr></table></figure></li><li><p>MakeStandardFilename：效果和CreateStandardFilename一致，只是CreateStandardFilename使用返回值返回路径，MakeStandardFilename直接传入引用，从参数返回；</p></li><li><p>MakePlatformFilename：这个函数好像没什么卵用，从源码上看就是跟格式化路劲好像没啥区别；</p></li><li><p>MakePathRelativeTo：传入两个路径，其中参数一为FString&amp;，参数二为const TCHAR*，如果二者是同一路径下的，那么将参数一的路径转化为相对于参数二的相对路径，如：参数一为：D:/UE/Content/A.txt，参数二为：D:/UE/B.txt，那么经过转换，参数将变成：Content/A.txt；如果二者路径不一致，则不做转换；</p></li><li><p>ConvertRelativePathToFull：这个函数似乎也是和CreateStandardFilename和MakeStandardFilename的作用是一样的，估计是历史遗留原因吧，很多重复功能的函数；</p></li><li><p>ConvertToSandboxPath：将路径转换为沙盒路径；</p></li><li><p>ConvertFromSandboxPath：将沙盒路径转为平台路径；</p></li><li><p>CreateTempFilename：创建临时文件，需要指定路径，可选文件名前缀和文件名后缀，函数会根据设置的路径、前缀、后缀生成一个随机名称的临时文件，如果没有指定后缀，默认使用.tmp，如果没有指定前缀，默认使用无前缀的随机数作为文件名；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">DEBUGLOG(FEnumSet::DebugLogType::Warning, FPaths::CreateTempFilename(TEXT(<span class="hljs-string">&quot;D:/Unkwon/Content/&quot;</span>,TEXT(<span class="hljs-string">&quot;Temp_&quot;</span>))));<br><span class="hljs-comment">//&gt; D:/Unkwon/Content/Temp_684BF44044F4C6356EFEC8BA14E6B32B.tmp</span><br></code></pre></td></tr></table></figure></li><li><p>GetInvalidFileSystemChars：获取操作系统规定的所有在路径中使用后是无效字符的字符串；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">DEBUGLOG(FEnumSet::DebugLogType::Warning, FPaths::GetInvalidFileSystemChars());<br><span class="hljs-comment">//&gt; /?:&amp;\*&quot;&lt;&gt;|%#@^</span><br></code></pre></td></tr></table></figure></li><li><p>MakeValidFileName：去除路径中的无效字符后，返回一个可用的路径；</p></li><li><p>ValidatePath：判断路径的组成字符中是否包含了操作系统规定的无效字符；</p></li><li><p>Split：将一个文件路径拆分成路径、不带后缀的文件名和后缀三部分；</p></li><li><p>Combine：这是一个可变参数的函数，将传入的参数组合成一个路径格式；</p><p><font color="green"><strong>小知识:</strong></font></p><p>这里涉及到了UE的可变参数，实际上就是C++11中的可变参数模板，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... STR&gt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UPlatformFileExpand::FuncTest</span><span class="hljs-params">(STR... Strs)</span></span><br><span class="hljs-function"></span>&#123;<br>    TCHAR* Str[] = &#123; Strs... &#125;;<br>    <span class="hljs-keyword">for</span> (TCHAR* Item : Str)<br>    &#123;<br>        UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;%s&quot;</span>), Item);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>STR是一个可变参数包，可以接收任意类型的任意数量的参数，只是传进来的参数需要自行进行处理，否则可能会因为参数类型不符而导致编译失败。</p><p>其中参数可以通过数组初始化的形式来使用数组接收参数包中的参数，当前提是需要提前对参数类型做处理，否者初始化就会失败，这种方式应该是UE自己实现的，C++中读取参数使用的是va_arg，va_start,va_end,va_list等来获取可变参数。</p></li><li><p>TearDown：释放所有FPaths所暂用的内存，由于FPaths类在程序开始由引擎自动初始化，其中保存了大量的路径字符串，如果不需要再用到FPaths了也可以直接把这部分内存释放出来。</p></li></ul><h1 id="十三、GConfig"><a href="#十三、GConfig" class="headerlink" title="十三、GConfig"></a>十三、GConfig</h1><p>GConfig是一个定义在CoreGlobals.cpp中一个全局FConfigCacheIni*变量，可以在UEC++中的任何地方使用，FConfigCacheIni是UE专门用来处理缓存在内存中的配置文件的类，其中涉及到FConfigFile、FConfigSection、FConfigValue类。</p><p>UE使用FConfigValue来封装配置文件中<code>=</code>号后面的内容，FConfigValue是一个结构体；使用一个<code>TPair&lt;FName,FConfigValue&gt;</code>来封装一行内容，其中TPair的Key就是一行中的Key，Value就是一行中的Value；使用FConfigSection来封装一个块的内容，FConfigSection是一个<code>TMultiMap&lt;FName,FConfigValue&gt;</code>的Map；使用FConfigFile来封装一个配置文件，FConfigFile是一个<code>TMap&lt;FString,FConfigSection&gt;</code>的Map。</p><h2 id="FConfigCacheIni"><a href="#FConfigCacheIni" class="headerlink" title="FConfigCacheIni"></a>FConfigCacheIni</h2><ul><li><p>DisableFileOperations和EnableFileOperations：这两个是相对的函数，具体是干什么的至今没搞懂；</p></li><li><p>AreFileOperationsDisabled：判断是DisableFileOperations状态还是EnableFileOperations状态；</p></li><li><p>IsReadyForUse：判断ini文件是否已经加载好了，GConfig在加载ini文件时，会把ini文件内容加载到一个FConfigFile类对象中，FConfigFile类才是直接对ini文件进行操作的类；</p></li><li><p>Parse1ToNSectionOfStrings：用于读取读取ini文件的二级键值，并用一个<code>TMap&lt;FString,TArray&lt;FStting&gt;&gt;&amp;</code>作为参数返回；如：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[TEXT]</span><br><span class="hljs-attr">AA</span>=T1<br><span class="hljs-attr">BB</span>=Y1<br><span class="hljs-attr">BB</span>=Y2<br><span class="hljs-attr">AA</span>=T2<br><span class="hljs-attr">BB</span>=Y3<br><span class="hljs-attr">AA</span>=W1<br><span class="hljs-attr">BB</span>=Y4<br><span class="hljs-attr">BB</span>=Y5<br><span class="hljs-attr">BB</span>=Y6<br></code></pre></td></tr></table></figure><p>其中AA=T1为一级键值，在T1下游两个二级键值BB=Y1，BB=Y2，以此类推，一级键值AA=T2下有一个二级键值BB=Y3，一级键值AA=W1下有三个二级键值BB=Y4，BB=Y5，BB=Y6。</p><p>Parse1ToNSectionOfStrings参数，其中Section为要读取的块的名称，KeyOne为一级键值名称，KeyN为二级键值名称，只能支持到二级键值。</p></li><li><p>Parse1ToNSectionOfNames：和Parse1ToNSectionOfStrings的效果一样只是使用FName替换了FString；</p></li><li><p>FindConfigFile：在已加载的配置文件中通过文件路径寻找FConfigFile类型的配置文件对象，只有已加载到内存中的配置文件才能被找到；</p></li><li><p>Find：Find的功能和FindConfigFile一样，只是新增了一个bool参数，指定在没有找到对象时是否创建一个；</p></li><li><p>FindConfigFileWithBaseName：使用不包含路径的文件名寻找加载到内存中FConfigFile对象；</p></li><li><p>Flush：清除指定的已加载到内存中的FConfigFile对象；</p></li><li><p>LoadFile：加载一个配置文件到一个FConfigFile对象并存储在内存中；</p></li><li><p>SetFile：为一个指定的配置文件设定一个新的FConfigFile对象，UE加载所有的配置文件使用了一个Map来在内存中存储，Map使用配置文件的全路径来作为Key，使用对应FConfigFile对象来作为Value；</p></li><li><p>UnloadFile：从内存中移除指定的FConfigFile对象；</p></li><li><p>Detach：这个函数着实是没弄明白是干什么的；</p></li><li><p>DoesSectionExist：判断指定块是否存在；</p></li><li><p>GetConfigFilenames：获取所有已加载到内存中的配置文件的名称，使用一个<code>TArray&lt;FString&gt;</code>数组存储；</p></li><li><p>GetSectionNames：获取所有的已加载到内存中的指定的配置文件的块的键值，使用一个<code>TArray&lt;FString&gt;</code>数组存储；</p></li><li><p>Exit：退出FConfigCacheIni，清除所有加载到内存的FConfigFile对象；</p></li><li><p>GetMaxMemoryUsage：获取FConfigCachIni的做大内存使用量；</p></li><li><p>ForEachEntry：遍历指定块的所有行，通过传入的FKeyValueSink委托绑定操作函数；</p></li><li><p>Factory：创建一个FConfigChechIni实例；</p></li><li><p>InitializeConfigSystem：创建GConfig实例，加载标准的全局ini文件；</p></li><li><p>GetDestIniFilename：这个函数会根据平台的类型给定标准的ini文件在不同平台中的名称；</p></li><li><p>LoadGlobalIniFile：加载ini文件，并把生成的FConfigFile配置到GConfig以便使用；</p></li><li><p>LoadLocalIniFile：加载ini文件，但不把生成的FConfigFile配置到GConfig；</p></li><li><p>LoadExternalIniFile：从指定的配置文件文件夹中加载配置文件，可以使用直接使用不带后缀的文件名加载；</p></li><li><p>SaveCurrentStateForBootstrap：将当前的FConfigCacheIni中的所有配置项存储到指定的配置文件中；</p></li><li><p>ini文件操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetString</span><span class="hljs-params">( <span class="hljs-keyword">const</span> TCHAR* Section, <span class="hljs-keyword">const</span> TCHAR* Key, FString&amp; Value, <span class="hljs-keyword">const</span> FString&amp; Filename )</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetText</span><span class="hljs-params">( <span class="hljs-keyword">const</span> TCHAR* Section, <span class="hljs-keyword">const</span> TCHAR* Key, FText&amp; Value, <span class="hljs-keyword">const</span> FString&amp; Filename )</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetSection</span><span class="hljs-params">( <span class="hljs-keyword">const</span> TCHAR* Section, TArray&lt;FString&gt;&amp; Result, <span class="hljs-keyword">const</span> FString&amp; Filename )</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetString</span><span class="hljs-params">( <span class="hljs-keyword">const</span> TCHAR* Section, <span class="hljs-keyword">const</span> TCHAR* Key, <span class="hljs-keyword">const</span> TCHAR* Value, <span class="hljs-keyword">const</span> FString&amp; Filename )</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetText</span><span class="hljs-params">( <span class="hljs-keyword">const</span> TCHAR* Section, <span class="hljs-keyword">const</span> TCHAR* Key, <span class="hljs-keyword">const</span> FText&amp; Value, <span class="hljs-keyword">const</span> FString&amp; Filename )</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">RemoveKey</span><span class="hljs-params">( <span class="hljs-keyword">const</span> TCHAR* Section, <span class="hljs-keyword">const</span> TCHAR* Key, <span class="hljs-keyword">const</span> FString&amp; Filename )</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">EmptySection</span><span class="hljs-params">( <span class="hljs-keyword">const</span> TCHAR* Section, <span class="hljs-keyword">const</span> FString&amp; Filename )</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">EmptySectionsMatchingString</span><span class="hljs-params">( <span class="hljs-keyword">const</span> TCHAR* SectionString, <span class="hljs-keyword">const</span> FString&amp; Filename )</span></span>;<br><span class="hljs-function">FString <span class="hljs-title">GetStr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section, <span class="hljs-keyword">const</span> TCHAR* Key, <span class="hljs-keyword">const</span> FString&amp; Filename )</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetInt</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR* Key,int32&amp; Value,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetFloat</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR* Key,<span class="hljs-keyword">float</span>&amp; Value,<span class="hljs-keyword">const</span> FString&amp;Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetDouble</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR*Section,<span class="hljs-keyword">const</span> TCHAR* Key,<span class="hljs-keyword">double</span>&amp; Value,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetBool</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR* Key,<span class="hljs-keyword">bool</span>&amp; Value,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function">int32 <span class="hljs-title">GetArray</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR*Section,<span class="hljs-keyword">const</span> TCHAR* Key,TArray&lt;FString&gt;&amp; out_Arr,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function">int32 <span class="hljs-title">GetSingleLineArray</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR* Key,TArray&lt;FString&gt;&amp; out_Arr,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetColor</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR* Key,FColor&amp;Value,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetVector2D</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR* Key,FVector2D&amp; Value,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetVector</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR* Key,FVector&amp; Value,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetVector4</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR* Key,FVector4&amp; Value,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetRotator</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR* Key,FRotator&amp;Value,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetInt</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR* Key,int32Value,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetFloat</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR* Key,<span class="hljs-keyword">float</span> Value,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetDouble</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR*Section,<span class="hljs-keyword">const</span> TCHAR* Key,<span class="hljs-keyword">double</span>Value,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetBool</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR* Key,<span class="hljs-keyword">bool</span>Value,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetArray</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR*Key,<span class="hljs-keyword">const</span> TArray&lt;FString&gt;&amp; Value,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetSingleLineArray</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR* Key,<span class="hljs-keyword">const</span> TArray&lt;FString&gt;&amp; In_Arr,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetColor</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR* Key,FColor Value,<span class="hljs-keyword">const</span> FString&amp;Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetVector2D</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR* Key,FVector2D Value,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetVector</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR* Key,FVector Value,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetVector4</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR* Key,<span class="hljs-keyword">const</span> FVector4&amp; Value,<span class="hljs-keyword">const</span> FString&amp; Filename)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetRotator</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCHAR* Section,<span class="hljs-keyword">const</span> TCHAR* Key,FRotator Value,<span class="hljs-keyword">const</span> FString&amp;Filename)</span></span>;<br></code></pre></td></tr></table></figure><h1 id="十四、FJsonObject"><a href="#十四、FJsonObject" class="headerlink" title="十四、FJsonObject"></a>十四、FJsonObject</h1></li></ul><p>UE提供FJsonObject来对json文件进行操作，同时提供一整套的json操作工具链，如：FJsonValue，FJsonReader，FJsonSerializer，FJsonWriter，FJsonTypes等。</p><p>详细使用请查看<a href="https://goulandis.github.io/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%AF%BB%E5%86%99Json%E6%96%87%E4%BB%B6/">这里</a>。</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE4】UE4GamePlay框架</title>
    <link href="/2021/12/08/%E3%80%90UE4%E3%80%91UE4GamePlay%E6%A1%86%E6%9E%B6/"/>
    <url>/2021/12/08/%E3%80%90UE4%E3%80%91UE4GamePlay%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>这篇博文主要记录一些自己在学习GamePlay的过程中一些心得记录，最开始使用的是UE5源码学习，后来不知道不小心改了啥，UE5源码崩了，就换回了UE4.26所以源码部分可能会有一部分来自UE5有一部分来自UE4，会有点出入。</p><a id="more"></a><p>参考博客：<a href="https://docs.unrealengine.com/en-US/index.html">UE4官方文档</a>、<a href="https://zhuanlan.zhihu.com/p/22813908">大钊</a>、<a href="https://zhuanlan.zhihu.com/p/67055774">南京周润发</a>、<a href="https://blog.csdn.net/qq_29523119/article/details/84981218">带带大师兄</a>、<a href="https://www.cnblogs.com/yblackd/p/13819045.html">yblackd</a>、<a href="https://blog.csdn.net/qq_36409711/article/details/78889074">董国政</a>、 <a href="https://www.cnblogs.com/AnKen/p/7897076.html">Ken_An</a>、<a href="https://zhuanlan.zhihu.com/p/393346131">张悟基</a>、<a href="https://zhuanlan.zhihu.com/p/166547096">paprika</a></p><h1 id="一、整体框架"><a href="#一、整体框架" class="headerlink" title="一、整体框架"></a>一、整体框架</h1><p>首先来看一下整体框架：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210226143303.png"></p><p><font color="red"> 红色部分为主体，从右往左为组合关系，至上而下为派生关系。</font></p><p>在整个UE宇宙的构成中，UEngine就类似化学元素，UObject就类似物质，物质通过演化便衍生出了物体—AActor和UActorComponent，AActor继续演化就出现了生物APawn，人—ACharacter，于是世界便有了信息—AInfo，规则—AGameMode，大量的物体、生物组合在一起便形成了大陆—ULevel，不同的大陆组合在一起便形成了世界—UWorld，世界有着自己的信息—FWorldContext和客观规律—UGameInstance。</p><p>而在UE这个宇宙有很多个Word，如编辑时的World，编辑时运行的World，运行时的World等等，查看源码就可知道UE宇宙有五大世界。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> EWorldType<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Type</span></span><br><span class="hljs-class">&#123;</span><br>None,<span class="hljs-comment">// An untyped world, in most cases this will be the vestigial worlds of streamed in sub-levels</span><br>Game,<span class="hljs-comment">// The game world</span><br>Editor,<span class="hljs-comment">// A world being edited in the editor</span><br>PIE,<span class="hljs-comment">// A Play In Editor world</span><br>Preview,<span class="hljs-comment">// A preview world for an editor tool</span><br>Inactive<span class="hljs-comment">// An editor world that was loaded but not currently being edited in the level editor</span><br>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先我们先了解一下这些类的具体作用，然后再细致的了解各个类。</p><h2 id="1-UEngine"><a href="#1-UEngine" class="headerlink" title="1.UEngine"></a>1.UEngine</h2><p>UEngine类是UE的基础，UEngine提供一些最底层的交互—与操作系统的交互，而根据不同的运行模式UE与操作系统的交互模式又有少许不同，所以UEngine又派生出了UGameEngine和UEditerEngine来负责不同运行模式下的交互模式。</p><p>其中有一个很重要的全局指针GEngine，通过GEngine可以访问各种UE的全局资源，同时GEngine还提供多线程访问能力。</p><p>关于UEngine的资料实在是太少了，官方文档中对UEngine的描述也就一句话，对UEngine的理解也就止步于此了。</p><h2 id="2-UObject"><a href="#2-UObject" class="headerlink" title="2.UObject"></a>2.UObject</h2><p>UObject是构成UE世界最基础的物质，所以UObject提供供UE世界运行的最基本的功能：</p><ul><li>Garbage collection：垃圾收集</li><li>Reference updating：引用自动更新</li><li>Reflection：反射</li><li>Serialization：序列化</li><li>Automatic updating of default property changes：自动检测默认变量的更改</li><li>Automatic property initialization：自动变量初始化</li><li>Automatic editor integration：和虚幻引擎编辑器的自动交互</li><li>Type information available at runtime：运行时类型识别</li><li>Network replication：网络复制</li></ul><p>在之后再深入浅出的讲解各个功能。</p><h2 id="3-AActor"><a href="#3-AActor" class="headerlink" title="3.AActor"></a>3.AActor</h2><p>AActor是派生自UObject的一个及其重要的类，AActor在UObject的基础上再进一步提供了：</p><ul><li>Replication：网络复制</li><li>Spawn：动态创建</li><li>Tick：每帧运行</li></ul><p>Replicatoin使AActor有了分裂复制的生育能力，Spawn使AActor在UE世界中出生，在UE4世界中死去，Tick使AActor有了心跳，AActor便组成了丰富多彩的UE世界。</p><p>AActor拥有一个庞大的子孙族群，ALevelScriptActor、ANavigationObjectBase、APawn、AController、AInfo这些都是AActor的直系后代，而这些后代也都各自拥有自己的庞大分支族群，构成了UE世界中最强大的种族AActor。</p><h3 id="ALevelScriptActor"><a href="#ALevelScriptActor" class="headerlink" title="ALevelScriptActor"></a>ALevelScriptActor</h3><p>ALevelScriptActor在官方文档中的表述就是ULevelScriptBlueprint生成的类的基类，通过名称我们就很容易联想到关卡蓝图，没错ULevelScriptBlueprint就是我们最常用的关卡蓝图，ULevelScriptBlueprint继承自UObject，所以ULevelScriptBlueprint的子类是一个多继承的虚继承类，而ALevelScriptActor就为其提供AActor的能力。</p><p>在官方文档中有提及默认关卡蓝图是可以通过DefualtGame.ini配置文件替换成自定义关卡蓝图的，具体使用方法在后面在探讨。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210309211442.png"></p><h3 id="ANavigationObjectBase"><a href="#ANavigationObjectBase" class="headerlink" title="ANavigationObjectBase"></a>ANavigationObjectBase</h3><p>ANavigationObjectBase的资料实在是少的可怜，就连官方文档也是没有一个字的描述，源码也是相当简单，总共就70行，由ANavigationObjectBase是APlayerState的基类，和它继承的接口INavAgentInterface可以猜测ANavigationObjectBase应该和网络复制有关，具体细节留到以后更熟悉UE4了再深入探讨吧。</p><h3 id="APlayerStart"><a href="#APlayerStart" class="headerlink" title="APlayerStart"></a>APlayerStart</h3><p>APlayerStart的作用就是记录APawn在游戏开始时生成的Position与Rotation信息，UE设计APlayerStart的初忠就是想让游戏的关卡设十师和场景设计师的工作分离开来，也就解耦合。那么，如果Level中不存在APlayerStart ，APawn 会出生在哪是呢？答案是世界原点(0，0，0)</p><h3 id="APawn"><a href="#APawn" class="headerlink" title="APawn"></a>APawn</h3><p>APawn在AActor的基础上再度添加了：</p><ul><li>被Controller控制</li><li>PhysicsCollision：物理碰撞</li><li>MovementInput：移动响应接口</li></ul><p>等能力，有了MovementInput接口APawn就拥有了可运动的能力，这里UE的逻辑划分十分精妙，UE将一个可运动的物体巧妙地划分成了APwan和AController，APawn重点表现在物体，而这个物体具备运动能力，但是自身不具备运动技巧；而AController这是控制APawn运动地大脑，用来控制APawn如何运动，如果把APawn比作是提线木偶，那么AController就是控制木偶运动地线。</p><p>到了APawn这一代，AActor的衍化之旅开始衍化出现于玩家间交互的能力，而这之中的佼佼者便是ACharacter。</p><h3 id="ACharacter"><a href="#ACharacter" class="headerlink" title="ACharacter"></a>ACharacter</h3><p>ACharacter是APwan的特化加强版，在UE世界中可以称之为“人”，ACharacter是一个专门为人形角色定制的APawn，自带CharacterMovement组件，可以使人形角色像人一样行走。</p><h3 id="ADefaultPawn"><a href="#ADefaultPawn" class="headerlink" title="ADefaultPawn"></a>ADefaultPawn</h3><p>最初始的APawn使最基本的APawn类，只提供APawn的一些基本能力，而没有提供支持这些能力的组件，而在具体实际使用情况中我们使用的APawn应该还需要组合一些其他的能力，以适应不同的场景，如：我们知道APawn可以运动，但在实际场景中我们是要确定这个APawn是因该直立行走还是爬行，是用轮子行驶还是用翅膀飞行，APawn在玩家眼里应该长什么样子，是人还是蛇，是因该左球形碰撞还是应该做方形碰撞，这些都是APawn不具备的能力，这时ADefaultPawn便出现了，ADefaultPawn自带DefualtPawnMovement、CollisionComponent、StaticMeshCompnent三件套，为ADefaultPawn提供了默认的场景表现。</p><h3 id="ASpectatorPawn"><a href="#ASpectatorPawn" class="headerlink" title="ASpectatorPawn"></a>ASpectatorPawn</h3><p>在游戏中存在一种特殊的玩家—观战玩家，这类玩家不需要具体表现形式，只需要一些相机的漫游能力，于是ASpectatorPawn出现了，ASpectatorPawn继承自ADefaultPawn，ASpectatorPawn提供了一个基本的USpectatorPawnMovement（不带重力漫游），并关闭了StaticMesh的显示，碰撞也设置到了“Spectator”通道。</p><h3 id="AController"><a href="#AController" class="headerlink" title="AController"></a>AController</h3><p>AController就是控制APawn运动的大脑了，ACtroller负责处理一些直接与玩家交互的控制逻辑，AController是从AActor派生的与APawn同级的子类，在UE的设计中，在同一时刻一个AController和一个APawn之间是1:1的关系，AController可以在多个APawn之间通过Possess/UnPossess切换。AController有两种控制APawn的方式，一种是AController直接附在APawn的身上控制APawn的移动，如驾驶汽车，一种是以上帝的视角控制APawn的移动，如控制第三人称的角色。</p><h3 id="APlayerController"><a href="#APlayerController" class="headerlink" title="APlayerController"></a>APlayerController</h3><p>APlayerController是由AController派生出来专门用于负责玩家交互逻辑的AController，APlayerController提供了：</p><ul><li>Camera管理</li><li>Input输入响应</li><li>UPlayer关联</li><li>HUD显示</li><li>Level切换</li><li>Voice音源监听</li></ul><p>这些能力。</p><h3 id="AAIController"><a href="#AAIController" class="headerlink" title="AAIController"></a>AAIController</h3><p>在一个游戏中有玩家控制的角色也可以有NPC，那么NPC的行动逻辑有谁来控制呢？答案就是AAIController，AAIController与APlayerController完全不同，因为一个NPC不要管理Camera，不需要响应玩家的输入，不需要关联UPlayer，不需要显示HUD，不需要监听音源，只有Level切换可能会在少数情况下需要，那么AAIController因该做什么呢？UE为它设计的是这些事：</p><ul><li>Navigation：自动寻路</li><li>AI Component：用于启动运行行为树，使用黑板数据</li><li>Task系统：让AI去完成一些任务</li></ul><p>当然一个游戏中是至少需要一个APlayerController的，但是可以没有AAIController。</p><h3 id="AInfo"><a href="#AInfo" class="headerlink" title="AInfo"></a>AInfo</h3><p>AInfo是一些数据保存类的基类，AInfo不需要运动和碰撞，也不需要物理表现，仅仅只是保存数据，所以UE在AInfo中将这些功能都隐藏了，之所以不直接继承自UObject，而继承自AActor是因为游戏数据是需要具备网络复制的能力的，而UObject不具备这个能力</p><h3 id="AWordSettings"><a href="#AWordSettings" class="headerlink" title="AWordSettings"></a>AWordSettings</h3><p>AWordSetting继承自AInfo用来配置和保存一些Level配置，主要用于配置Level的GameMode信息，光照信息，导航系统，声音系统，LOD系统，物理加速度等关卡信息。由此可以知道一个Level对应一个AWordSetting，但是一个AWordSetting可以应用在多个Level上。</p><h3 id="AGameMode"><a href="#AGameMode" class="headerlink" title="AGameMode"></a>AGameMode</h3><p>AGameMode就是用于配置AWorldSetting中的GameMode属性的。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210310162744.png"></p><p>在UE的设计中AGameMode就是游戏世界的逻辑，及整个游戏的玩法规则，而在实际情况中一个游戏既可以只有一个玩法也可以有多种玩法规则，所以AWordSetting与AGameMode的对应关系也是一个AWorldSetting只能对应一个AGameMode，而一个AGameMode可以对应多个AWorldSetting。那么AGameMode应该负责哪些逻辑呢？UE是这么规定的：</p><ul><li>Class登记：记录GameMode中各种类的信息</li><li>Spawn：创建Pawn和PlayerController等</li><li>游戏进度：游戏暂停重启的逻辑</li><li>过场动画逻辑</li><li>多人游戏的步调同步</li></ul><h3 id="AGameState"><a href="#AGameState" class="headerlink" title="AGameState"></a>AGameState</h3><p>AGameState用于保存游戏数据，如任务进度，游戏活动等。</p><h3 id="APlayerState"><a href="#APlayerState" class="headerlink" title="APlayerState"></a>APlayerState</h3><p>APlayerState是一个用于存储玩家状态的类，在一个游戏客户端，尤其是网络游戏客户端中是可以存在多个APlayerState对象的，不同的APlayerState保存不同玩家的状态，同时APlayerState也可以存在于服务器中。APlayerState的生命周期为一整个Level的生命周期。</p><p>到这是AActor家族下的几个重要成员的基本功能我们便有了一个大概的了解了，这里我们来捋一下这些成员之间的关系和在UE世界中的地位。<br><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208141236.jpeg" alt="Alt"></p><h2 id="4-UActorComponent"><a href="#4-UActorComponent" class="headerlink" title="4.UActorComponent"></a>4.UActorComponent</h2><p>UActorComponent是UE向U3D看齐的一个产物，虽然UE世界有了Actor就有了形形色色的物体生物，但是不同的生物拥有不同的技能，而同一个Actor可以会某个技能也可以不会，这种概念使用组合的方式组合到Actor下是最理想的，于是Component便出现了，UActorComponent直接继承自UObject，与AActor同级，Component既可以嵌套在Actor下，也可以嵌套在其他的Component下，但是需要注意的是，UActorComponent这一级是不提供互相嵌套的能力的，只有到其子类USceneComponent一级才提供互相嵌套能力。</p><h3 id="USceneComponent"><a href="#USceneComponent" class="headerlink" title="USceneComponent"></a>USceneComponent</h3><p>USceneComponent主要提供两大能力，一是Transform，二是SceneComponent的互相嵌套。一般我们直接在Level里创建的Actor都会默认带有一个SceneComponent组件。</p><h3 id="UPrimitiveComponent"><a href="#UPrimitiveComponent" class="headerlink" title="UPrimitiveComponent"></a>UPrimitiveComponent</h3><p>UPrimitiveComponent主要提供Actor用于物体渲染和碰撞相关的基础能力。</p><h3 id="UMeshComponent"><a href="#UMeshComponent" class="headerlink" title="UMeshComponent"></a>UMeshComponent</h3><p>UMeshComponent由UPrimitiveComponent派生而来，主要提供具体的渲染显示方面的能力。</p><h3 id="UChildActorComponent"><a href="#UChildActorComponent" class="headerlink" title="UChildActorComponent"></a>UChildActorComponent</h3><p>从名字就可以窥探其功能一二了，UChildComponent在Actor中主要用于链接Actor与Component，提供Component和Actor的嵌套能力。</p><h2 id="5-ULevel"><a href="#5-ULevel" class="headerlink" title="5.ULevel"></a>5.ULevel</h2><p>ULevel可以看作是UE世界的大陆，是AActor的容器，前面提到的ALevelScriptActor便是ULevel默认带有的关卡蓝图，在这个关卡蓝图中编写便是这块大陆的逻辑，同时ULevel也默认带有一个AWorldSetting。</p><h2 id="6-UWorld"><a href="#6-UWorld" class="headerlink" title="6.UWorld"></a>6.UWorld</h2><p>在UE中所有的ULevel互相联系就构成了一个UWorld，ULevel构建UWorld的方式有两种，一种是以SubLevel的形式，像关卡流一样，一个关卡链接下一个关卡，来组成UWorld，一种是每一个ULevel就是这个大地图的UWorld中的一块地图，ULevel之间以相对位置衔接在一起，构成一个大地图来组成这个UWorld。无论是那种构成形式，在一个UWorld中都有一个PersistentLevel，PersistenetLevel就是主Level，是玩家最初始的出生地，这里用的是最初始而不是游戏开始，是因为，现在很多在游戏开始时玩家的出点可能不是PersistentLevel而是上一次玩家离线时的位置。</p><h2 id="7-FWorldContext"><a href="#7-FWorldContext" class="headerlink" title="7.FWorldContext"></a>7.FWorldContext</h2><p>FWorldContext不对开发者公开，是UE内部用来处理引擎UWorld上下文的类，比如当我们从编辑状态的EditorWorld点击播放切换到PIEWorld即运行状态时，这个过程中EditorWorld到PIEWorld之间的信息交换就是通过FWorldContext实现的。可以说FWorldContext处理的是UWorld级的通信。</p><h2 id="8-UGameInstance"><a href="#8-UGameInstance" class="headerlink" title="8.UGameInstance"></a>8.UGameInstance</h2><p>UGameInstance可以说是凌驾于所有AActor、UActorComponent、ULevel、UWorld之上的类，通常情况下一个Game中应该只有一个，这里的Game是UEngine中提到的所有World的总和，当然这不是绝对的，对于更高层次的开发者，UE也是提供了多个UGameInstance协同的扩展的。UGameInstance的生命周期就是从游戏进程启动到游戏进程结束。</p><p>所以UGameInstance主要处理：</p><ul><li>UWorld、ULevel之间的切换</li><li>UPlayer的创建，这里的UPlayer又和前面的APlayerController有所不同，这一点在后面再介绍。</li><li>全局配置</li><li>GameMode的切换</li></ul><h2 id="9-UNetDriver"><a href="#9-UNetDriver" class="headerlink" title="9.UNetDriver"></a>9.UNetDriver</h2><p>从名字就可以略知一二，UNetDriver是UE处理网络同步相关的类，UNetDriver中有两个主要的成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UNetConnection</span>* <span class="hljs-title">ServerConnection</span>;</span><br>TArray&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UNetConnection</span>*&gt;</span> ClientConnections;<br></code></pre></td></tr></table></figure><p>ServerConnection是客户端到服务器的连接，ClientConnections数组是服务器到客户端群的连接的数组。而在UNetConnnection中又有一个很重要的成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">TMap&lt;TWeakObjectPtr&lt;AActor&gt;,<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UActorChannel</span>*&gt;</span> ActorChannels<br></code></pre></td></tr></table></figure><p>ActorChannels是在服务器与客户端完成连接后用于实现Actor同步的对象。</p><h2 id="10-UPlayer"><a href="#10-UPlayer" class="headerlink" title="10.UPlayer"></a>10.UPlayer</h2><p>UPlayer即玩家，ULevel可以切换，UWorld可以交替，但是尽管ULevel、UWorld如何变换，玩家还是那个玩家，所以UPlayer是和UGameInstance同一级别的存在，在整个GamePlay架构中UPlayer主要以GameModeBase中的一个属性出现。</p><p>在一个单机游戏中UPlayer是唯一的存在，但是在一个网络联级游戏中，表示同一实体的UPlayer即存在于玩家本地的客户端中，同时也存在于其他玩家的多个客户端中，那么玩家的输入就既要作用于本地的APawn上，同时在其他玩家的客户端中的表示这个实体的APawn也要做出响应的反应，于是UE便将UPlayer又派生出了两个子类，ULocalPlayer和UNetConnection。其中ULocalPlayer就是处理本地客户端的输入逻辑的类。</p><h3 id="UNetConnection"><a href="#UNetConnection" class="headerlink" title="UNetConnection"></a>UNetConnection</h3><p>UNetConnection就是处理其他玩家在本地客户端中的APawn的类，所以UNetConnection也是一个玩家。</p><h2 id="11-USaveGame"><a href="#11-USaveGame" class="headerlink" title="11.USaveGame"></a>11.USaveGame</h2><p>前面提到了AGameState是一个保存游戏数据的类，这个保存是一个临时保存，所以当游戏程序关闭之后AGameState中数据也就不存在了，而USaveGame就是用来保存存档的类，USaveGame提供游戏数据永久性保存，我们只需要往USaveGame中添加我们要保存的属性字段，就可以直接调用USaveGame的接口直接将游戏数据序列化保存到本地文件中，相当的方便。</p><p>花了这么长的篇幅也就简要的介绍了一下GamePlay的整体框架，总共由这11个类组成，说起来不多，但是里面的门道却是相当深奥，这需要在以后的使用中慢慢学习消化。</p><p>那么接下来就开始各个类的详细使用学习了。</p><h1 id="二、UObject"><a href="#二、UObject" class="headerlink" title="二、UObject"></a>二、UObject</h1><p>首先我们来看UObject提供的功能：</p><ul><li>Garbage collection：垃圾收集</li><li>Reference updating：引用自动更新</li><li>Reflection：反射</li><li>Serialization：序列化</li><li>Automatic updating of default property changes：自动检测默认变量的更改</li><li>Automatic property initialization：自动变量初始化</li><li>Automatic editor integration：和虚幻引擎编辑器的自动交互</li><li>Type information available at runtime：运行时类型识别</li><li>Network replication：网络复制</li></ul><h2 id="1-垃圾回收"><a href="#1-垃圾回收" class="headerlink" title="1.垃圾回收"></a>1.垃圾回收</h2><p>首先我们来研究研究UE4是如何进行垃圾回收的。</p><p>这里推荐两位大佬的博客：<a href="https://zhuanlan.zhihu.com/p/67055774">带带大师兄</a>、<a href="https://blog.csdn.net/qq_29523119/article/details/84981218">南京周润发</a></p><p>可以配合着看。</p><p>由于C++不提供GC功能，所有UE自己实现了一套GC功能，使用的也是最经典的<code>标记-清理</code>垃圾回收方式。</p><h3 id="GC的过程"><a href="#GC的过程" class="headerlink" title="GC的过程"></a>GC的过程</h3><p>UEGC分为来两个阶段，第一个阶段UE从根集合开始遍历，遍历所有可达对象，于是UE就知道了哪些对象还在被引用，哪些对象已经不可被引用了。第二阶段UE会逐步的清理这些不可达对象，形式为分帧分批清理，为什么要这么做呢？想想我们卸载一次性Level时的感受就知道了，分批处理可以保证我们在使用UE时的顺滑而不卡顿。</p><p>UEGC的主要函数是在UObjectGlobals.h头文件中CollectGarbage函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CollectGarbage</span><span class="hljs-params">(EObjectFlags KeepFlags, <span class="hljs-keyword">bool</span> bPerformFullPurge)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// No other thread may be performing UObject operations while we&#x27;re running</span><br>AcquireGCLock();<br><br><span class="hljs-comment">// Perform actual garbage collection</span><br>CollectGarbageInternal(KeepFlags, bPerformFullPurge);<br><br><span class="hljs-comment">// Other threads are free to use UObjects</span><br>ReleaseGCLock();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到GC的整体流程很自然的划分成了三个阶段，获取GC锁、执行CollectGarbageInternal和释放GC锁。使用锁的原因是UEGC是多线程的，为了防止在GC的过程中对象被其他线程访问，以保证异步加载的稳定。而CollectGarbageInternal函数则进行垃圾回收和对象标记与清理，两个参数KeepFlags表示这些被标记的对象无论是否被引用都将被保留，bPerformFullPurge表示GC时进行全清理还是分帧分批清理。</p><p>那么GC又是如何进行对象标记的呢？还是看源码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * Deletes all unreferenced objects, keeping objects that have any of the passed in KeepFlags set</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @paramKeepFlagsobjects with those flags will be kept regardless of being referenced or not</span><br><span class="hljs-comment"> * @parambPerformFullPurgeif true, perform a full purge after the mark pass</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CollectGarbageInternal</span><span class="hljs-params">(EObjectFlags KeepFlags, <span class="hljs-keyword">bool</span> bPerformFullPurge)</span></span><br><span class="hljs-function"></span>&#123;<br>SCOPE_TIME_GUARD(TEXT(<span class="hljs-string">&quot;Collect Garbage&quot;</span>));<br>SCOPED_NAMED_EVENT(CollectGarbageInternal, FColor::Red);<br>CSV_EVENT_GLOBAL(TEXT(<span class="hljs-string">&quot;GC&quot;</span>));<br>CSV_SCOPED_TIMING_STAT_EXCLUSIVE(GarbageCollection);<br><br>FGCCSyncObject::Get().ResetGCIsWaiting();<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(WITH_CODE_GUARD_HANDLER) &amp;&amp; WITH_CODE_GUARD_HANDLER</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CheckImageIntegrityAtRuntime</span><span class="hljs-params">()</span></span>;<br>CheckImageIntegrityAtRuntime();<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>DECLARE_SCOPE_CYCLE_COUNTER( TEXT( <span class="hljs-string">&quot;CollectGarbageInternal&quot;</span> ), STAT_CollectGarbageInternal, STATGROUP_GC );<br>STAT_ADD_CUSTOMMESSAGE_NAME( STAT_NamedMarker, TEXT( <span class="hljs-string">&quot;GarbageCollection - Begin&quot;</span> ) );<br><br><span class="hljs-comment">// We can&#x27;t collect garbage while there&#x27;s a load in progress. E.g. one potential issue is Import.XObject</span><br>check(!IsLoading());<br><br><span class="hljs-comment">// Reset GC skip counter</span><br>GNumAttemptsSinceLastGC = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// Flush streaming before GC if requested</span><br><span class="hljs-keyword">if</span> (GFlushStreamingOnGC)<br>&#123;<br><span class="hljs-keyword">if</span> (IsAsyncLoading())<br>&#123;<br>UE_LOG(LogGarbage, Log, TEXT(<span class="hljs-string">&quot;CollectGarbageInternal() is flushing async loading&quot;</span>));<br>&#125;<br>FGCCSyncObject::Get().GCUnlock();<br>FlushAsyncLoading();<br>FGCCSyncObject::Get().GCLock();<br>&#125;<br><br><span class="hljs-comment">// Route callbacks so we can ensure that we are e.g. not in the middle of loading something by flushing</span><br><span class="hljs-comment">// the async loading, etc...</span><br>FCoreUObjectDelegates::GetPreGarbageCollectDelegate().Broadcast();<br>GLastGCFrame = GFrameCounter;<br><br>&#123;<br><span class="hljs-comment">// Set &#x27;I&#x27;m garbage collecting&#x27; flag - might be checked inside various functions.</span><br><span class="hljs-comment">// This has to be unlocked before we call post GC callbacks</span><br>FGCScopeLock GCLock;<br><br>UE_LOG(LogGarbage, Log, TEXT(<span class="hljs-string">&quot;Collecting garbage%s&quot;</span>), IsAsyncLoading() ? TEXT(<span class="hljs-string">&quot; while async loading&quot;</span>) : TEXT(<span class="hljs-string">&quot;&quot;</span>));<br><br><span class="hljs-comment">// Make sure previous incremental purge has finished or we do a full purge pass in case we haven&#x27;t kicked one</span><br><span class="hljs-comment">// off yet since the last call to garbage collection.</span><br><span class="hljs-keyword">if</span> (GObjIncrementalPurgeIsInProgress || GObjPurgeIsRequired)<br>&#123;<br>IncrementalPurgeGarbage(<span class="hljs-literal">false</span>);<br>FMemory::Trim();<br>&#125;<br>check(!GObjIncrementalPurgeIsInProgress);<br>check(!GObjPurgeIsRequired);<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> VERIFY_DISREGARD_GC_ASSUMPTIONS</span><br><span class="hljs-comment">// Only verify assumptions if option is enabled. This avoids false positives in the Editor or commandlets.</span><br><span class="hljs-keyword">if</span> ((GUObjectArray.DisregardForGCEnabled() || GUObjectClusters.GetNumAllocatedClusters()) &amp;&amp; GShouldVerifyGCAssumptions)<br>&#123;<br>DECLARE_SCOPE_CYCLE_COUNTER(TEXT(<span class="hljs-string">&quot;CollectGarbageInternal.VerifyGCAssumptions&quot;</span>), STAT_CollectGarbageInternal_VerifyGCAssumptions, STATGROUP_GC);<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> StartTime = FPlatformTime::Seconds();<br>VerifyGCAssumptions();<br>VerifyClustersAssumptions();<br>UE_LOG(LogGarbage, Log, TEXT(<span class="hljs-string">&quot;%f ms for Verify GC Assumptions&quot;</span>), (FPlatformTime::Seconds() - StartTime) * <span class="hljs-number">1000</span>);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-comment">// Fall back to single threaded GC if processor count is 1 or parallel GC is disabled</span><br><span class="hljs-comment">// or detailed per class gc stats are enabled (not thread safe)</span><br><span class="hljs-comment">// Temporarily forcing single-threaded GC in the editor until Modify() can be safely removed from HandleObjectReference.</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> bForceSingleThreadedGC = !FApp::ShouldUseThreadingForPerformance() || !FPlatformProcess::SupportsMultithreading() ||<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> PLATFORM_SUPPORTS_MULTITHREADED_GC</span><br>(FPlatformMisc::NumberOfCores() &lt; <span class="hljs-number">2</span> || GAllowParallelGC == <span class="hljs-number">0</span> || PERF_DETAILED_PER_CLASS_GC_STATS);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span><span class="hljs-comment">//PLATFORM_SUPPORTS_MULTITHREADED_GC</span></span><br><span class="hljs-literal">true</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span><span class="hljs-comment">//PLATFORM_SUPPORTS_MULTITHREADED_GC</span></span><br><br><span class="hljs-comment">// Perform reachability analysis.</span><br>&#123;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> StartTime = FPlatformTime::Seconds();<br>FRealtimeGC TagUsedRealtimeGC;<br>            <span class="hljs-comment">//-----------------------------------------------------------</span><br>TagUsedRealtimeGC.PerformReachabilityAnalysis(KeepFlags, bForceSingleThreadedGC);<br>            <span class="hljs-comment">//-----------------------------------------------------------</span><br>UE_LOG(LogGarbage, Log, TEXT(<span class="hljs-string">&quot;%f ms for GC&quot;</span>), (FPlatformTime::Seconds() - StartTime) * <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-comment">// Reconstruct clusters if needed</span><br><span class="hljs-keyword">if</span> (GUObjectClusters.ClustersNeedDissolving())<br>&#123;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> StartTime = FPlatformTime::Seconds();<br>GUObjectClusters.DissolveClusters();<br>UE_LOG(LogGarbage, Log, TEXT(<span class="hljs-string">&quot;%f ms for dissolving GC clusters&quot;</span>), (FPlatformTime::Seconds() - StartTime) * <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-comment">// Fire post-reachability analysis hooks</span><br>FCoreUObjectDelegates::PostReachabilityAnalysis.Broadcast();<br><br>&#123;<br>FGCArrayPool::Get().ClearWeakReferences(bPerformFullPurge);<br><br>GatherUnreachableObjects(bForceSingleThreadedGC);<br><br><span class="hljs-keyword">if</span> (bPerformFullPurge || !GIncrementalBeginDestroyEnabled)<br>&#123;<br>UnhashUnreachableObjects(<span class="hljs-comment">/**bUseTimeLimit = */</span> <span class="hljs-literal">false</span>);<br>FScopedCBDProfile::DumpProfile();<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Set flag to indicate that we are relying on a purge to be performed.</span><br>GObjPurgeIsRequired = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// Reset purged count.</span><br>GPurgedObjectCountSinceLastMarkPhase = <span class="hljs-number">0</span>;<br>GObjCurrentPurgeObjectIndexResetPastPermanent = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">// Perform a full purge by not using a time limit for the incremental purge. The Editor always does a full purge.</span><br><span class="hljs-keyword">if</span> (bPerformFullPurge || GIsEditor)<br>&#123;<br>IncrementalPurgeGarbage(<span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (bPerformFullPurge)<br>&#123;<br>ShrinkUObjectHashTables();<br>&#125;<br><br><span class="hljs-comment">// Destroy all pending delete linkers</span><br>DeleteLoaders();<br><br><span class="hljs-comment">// Trim allocator memory</span><br>FMemory::Trim();<br>&#125;<br><br><span class="hljs-comment">// Route callbacks to verify GC assumptions</span><br>FCoreUObjectDelegates::GetPostGarbageCollect().Broadcast();<br><br>STAT_ADD_CUSTOMMESSAGE_NAME( STAT_NamedMarker, TEXT( <span class="hljs-string">&quot;GarbageCollection - End&quot;</span> ) );<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我在PerformReachabilityAnalysis函数处做了标记，GC时UE就是通过这个函数进行对象标记的，PerformReachabilityAnalysis函数会做多线程实时的分析对象的引用关系，然后标记出可达与不可达对象。标记是如何进行的还得深入到PerformReachabilityAnalysis函数，再上源码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Performs reachability analysis.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param KeepFlagsObjects with these flags will be kept regardless of being referenced or not</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PerformReachabilityAnalysis</span><span class="hljs-params">(EObjectFlags KeepFlags, <span class="hljs-keyword">bool</span> bForceSingleThreaded = <span class="hljs-literal">false</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>LLM_SCOPE(ELLMTag::GC);<br><br>SCOPED_NAMED_EVENT(FRealtimeGC_PerformReachabilityAnalysis, FColor::Red);<br>DECLARE_SCOPE_CYCLE_COUNTER(TEXT(<span class="hljs-string">&quot;FRealtimeGC::PerformReachabilityAnalysis&quot;</span>), STAT_FArchiveRealtimeGC_PerformReachabilityAnalysis, STATGROUP_GC);<br><br><span class="hljs-comment">/** Growing array of objects that require serialization */</span><br>FGCArrayStruct* ArrayStruct = FGCArrayPool::Get().GetArrayStructFromPool();<br>TArray&lt;UObject*&gt;&amp; ObjectsToSerialize = ArrayStruct-&gt;ObjectsToSerialize;<br><br><span class="hljs-comment">// Reset object count.</span><br>GObjectCountDuringLastMarkPhase.Reset();<br><br><span class="hljs-comment">// Make sure GC referencer object is checked for references to other objects even if it resides in permanent object pool</span><br><span class="hljs-keyword">if</span> (FPlatformProperties::RequiresCookedData() &amp;&amp; FGCObject::GGCObjectReferencer &amp;&amp; GUObjectArray.IsDisregardForGC(FGCObject::GGCObjectReferencer))<br>&#123;<br>ObjectsToSerialize.Add(FGCObject::GGCObjectReferencer);<br>&#125;<br><br>&#123;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> StartTime = FPlatformTime::Seconds();<br>MarkObjectsAsUnreachable(ObjectsToSerialize, KeepFlags, bForceSingleThreaded);<br>UE_LOG(LogGarbage, Verbose, TEXT(<span class="hljs-string">&quot;%f ms for Mark Phase (%d Objects To Serialize&quot;</span>), (FPlatformTime::Seconds() - StartTime) * <span class="hljs-number">1000</span>, ObjectsToSerialize.Num());<br>&#125;<br><br>&#123;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> StartTime = FPlatformTime::Seconds();<br>PerformReachabilityAnalysisOnObjects(ArrayStruct, bForceSingleThreaded);<br>UE_LOG(LogGarbage, Verbose, TEXT(<span class="hljs-string">&quot;%f ms for Reachability Analysis&quot;</span>), (FPlatformTime::Seconds() - StartTime) * <span class="hljs-number">1000</span>);<br>&#125;<br>        <br><span class="hljs-comment">// Allowing external systems to add object roots. This can&#x27;t be done through AddReferencedObjects</span><br><span class="hljs-comment">// because it may require tracing objects (via FGarbageCollectionTracer) multiple times</span><br>FCoreUObjectDelegates::TraceExternalRootsForReachabilityAnalysis.Broadcast(*<span class="hljs-keyword">this</span>, KeepFlags, bForceSingleThreaded);<br><br>FGCArrayPool::Get().ReturnToPool(ArrayStruct);<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> UE_BUILD_DEBUG</span><br>FGCArrayPool::Get().CheckLeaks();<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>首先前面的宏暂时可以忽略掉，</p><p>第一步，<code>FGCArrayStruct* ArrayStruct = FGCArrayPool::Get().GetArrayStructFromPool();</code>UE将UObject的所有的强引用和弱引用都存储大ArrayStruct数据结构中，FGCArrayPool是UEGC的主要执行类</p><p>第二步，<code>TArray&lt;UObject*&gt;&amp; ObjectsToSerialize = ArrayStruct-&gt;ObjectsToSerialize;</code>分离UObject的强引用到ObjectsToSerialize 数组中。</p><p>这是FGCArrayStruct结构体的源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FGCArrayStruct</span></span><br><span class="hljs-class">&#123;</span><br>TArray&lt;UObject*&gt; ObjectsToSerialize;<br>TArray&lt;UObject**&gt; WeakReferences;<br>&#125;;<br></code></pre></td></tr></table></figure><p>ObjectsToSerialize存储强引用，WeakReferences存储弱引用。</p><p>第三步，<code>GObjectCountDuringLastMarkPhase.Reset();</code>重置对象的引用计数。</p><p>第四步，通过一个if判断标记可达对象，于是可达对象与不可达对象就被标记出来了，接下来便是GC清理。</p><h3 id="GC的触发"><a href="#GC的触发" class="headerlink" title="GC的触发"></a>GC的触发</h3><p>UE的GC发生在游戏线程上，支持多线程GC，和大多数主流语言的GC一样支持自动触发和手动触发。</p><p><strong>手动触发</strong></p><p>手动触发UE也提供了两种方式，其一是通过C++函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">GEngine-&gt;ForceGarbageCollection();<br></code></pre></td></tr></table></figure><p>这里需要注意的是<code>GEngine</code>在<code>Engine.h</code>头文件下。</p><p>手动触发的使用场景一般是在卸载某些资源后，手动触发GC回收这些资源在使用过程中的无用对象。</p><p>其二是蓝图节点：</p><p><img src="https://img-blog.csdnimg.cn/6ab594d5e4154b8585510ce4e8816e1d.png#pic_center"></p><p>手动调用这两个函数，UE会跳过GC算法，在下一次Tick时直接进行GC。</p><p><font color="red"> 这里有一点需要注意，在大多数情况下，手动GC一般只能回收NewObject函数创建的对象，而UWorld()-&gt;SpawnActor函数创建的对象无论如何调用都无法销毁，这是因为，当UE创建一个Actor之后在UWorld中就已经保存了这个Actor的引用，所以无论我们如何释放Actor的引用，这个Actor的引用计数都不会归零，所以要销毁一个Actor还是需要通过Actor-&gt;Destroy()函数。</font></p><p>我们可以个一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//AACtor.cpp</span><br>AActor1::AActor1()<br>&#123;<br>PrimaryActorTick.bCanEverTick = <span class="hljs-literal">true</span>;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Actor1 Created&quot;</span>));<br>&#125;<br><br>AActor1::~AActor1()<br>&#123;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Actor1 Destryed&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//AMyActor.h</span><br>UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">INSIDEUE4_API</span> <span class="hljs-title">AMyActor2</span> :</span> <span class="hljs-keyword">public</span> AActor<br>&#123;<br>GENERATED_BODY()<br><br><span class="hljs-keyword">public</span>:<br>AMyActor2();<br>AActor1 *a;<span class="hljs-comment">//注意这里没有加UPROPERTY()宏</span><br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Tick</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime)</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//AMyActor2</span><br>AMyActor2::AMyActor2()<br>&#123;<br>PrimaryActorTick.bCanEverTick = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AMyActor2::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br>a = UWorld()-&gt;SpawnActor&lt;AActor1&gt;();<br>a = <span class="hljs-literal">NULL</span>;<br>GEngine-&gt;ForceGarbageCollection();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AMyActor2::Tick</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime)</span></span><br><span class="hljs-function"></span>&#123;<br>Super::Tick(DeltaTime);<br>&#125;<br></code></pre></td></tr></table></figure><p>OutputLog:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-attr">LogTemp:</span> <span class="hljs-attr">Warning:</span> Actor1 Created<br></code></pre></td></tr></table></figure><p>可以看到使用UWorld()-&gt;SpawnActor创建的Actor即使手动强制GC也没有被回收，因为这个Actor是可达对象。</p><p><strong>自动触发</strong></p><p>要想UE自动触发的GC能能够回收我们创建的对象，那么我们创建的对象就必须继承自UObject，至于加不加UPROPERTY()宏似乎不影响GC的回收，如下面的测试结果，还是以上面的例子为例，把BeginPlay函数改为如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//AMyActor2</span><br>AMyActor2::AMyActor2()<br>&#123;<br>PrimaryActorTick.bCanEverTick = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AMyActor2::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br>a = NewObject&lt;AActor1&gt;();<br>a = <span class="hljs-literal">NULL</span>;<br>GEngine-&gt;ForceGarbageCollection();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AMyActor2::Tick</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime)</span></span><br><span class="hljs-function"></span>&#123;<br>Super::Tick(DeltaTime);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们将MyActor2拖入场景中，运行，OutputLog输出，可以找到下面两句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">LogTemp: Warning: Actor1 Created<br><br>LogTemp: Warning: Actor1 Destryed<br></code></pre></td></tr></table></figure><p>可以看到，没有使用UPROPERTY()宏的变量a依旧在手动GC时被回收了，这里为了效果明显点使用了手动强制回收，其实使用自动GC也是一样的。</p><p><font color="green">这里有提个疑问：</font></p><p>当我们在一个继承自UObject的类组合一个继承自UObject的对象，如果在这个对象定义前没有使用UPROPERTY()宏，那么在Play后UE会调用一次这个对象的析构函数，但是这个对象依然可以被使用，而如果在定义这个对象前使用了UPROPERTY()宏，那么这对象将和组合类被析构时一起被析构。疑问为什么UE会调用一次被组合对象的析构且析构后依然可以使用这个对象。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//UMyObject.cpp</span><br>UMyObject::UMyObject()<br>&#123;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;UMyObject Created&quot;</span>));<br>&#125;<br><br>UMyObject::~UMyObject()<br>&#123;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;UMyObject Destoryed&quot;</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UMyObject::Fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;UMyObject&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//AMyActor2.h</span><br>UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">INSIDEUE4_API</span> <span class="hljs-title">AMyActor2</span> :</span> <span class="hljs-keyword">public</span> AActor<br>&#123;<br>GENERATED_BODY()<br><br><span class="hljs-keyword">public</span>:<br>AMyActor2();<br>UPROPERTY()<br>UMyObject* obj;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Tick</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime)</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//AMyActor2.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AMyActor2::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br>obj = NewObject&lt;UMyObject&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><p>使用UPROPERTY()宏的输出结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//在点击Play后输出结果</span><br>LogTemp: Warning: AMyActor2 Created<br>LogTemp: Warning: UMyObject Created<br><span class="hljs-comment">//再点击Stop后输出结果</span><br>LogTemp: Warning: UMyObject Destoryed<br>LogTemp: Warning: AMyActor2 Destroyed<br></code></pre></td></tr></table></figure><p>不使用UPROPERTY()宏的输出结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//在点击Play后输出结果</span><br>LogTemp: Warning: AMyActor2 Created<br>LogTemp: Warning: UMyObject Created<br>LogTemp: Warning: UMyObject Destoryed<br><span class="hljs-comment">//再点击Stop后输出结果</span><br>LogTemp: Warning: AMyActor2 Destroyed<br></code></pre></td></tr></table></figure><p>很明显在Play后UMyObject对象的析构函数被调用了，但是此时如果继续访问UMyObject里的成员依旧可以访问。</p><h3 id="TWeakObjectPtr、TWeakPtr（既保存引用又可GC）"><a href="#TWeakObjectPtr、TWeakPtr（既保存引用又可GC）" class="headerlink" title="TWeakObjectPtr、TWeakPtr（既保存引用又可GC）"></a>TWeakObjectPtr、TWeakPtr（既保存引用又可GC）</h3><p>有时我们可能需要在一个类里面临时保存一些对象，但是一旦保存了引用，就需要手动释放才能保证这些对象可以被GC自动回收，关于这个方面UE也贴心的为我们提供了<font color="red"> TWeakObjectPtr</font>指针，当然，这也是C++弱指针的UE魔改办罢了，使用这个指针既可以引用对象，但是又不会造成引用计数+1。可以通过一个例子很好的看出来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//AACtor1.cpp</span><br>AActor1::AActor1()<br>&#123;<br>PrimaryActorTick.bCanEverTick = <span class="hljs-literal">true</span>;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Actor1 Created&quot;</span>));<br>&#125;<br><br>AActor1::~AActor1()<br>&#123;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Actor1 Destryed&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//AMyActor2</span><br>UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">INSIDEUE4_API</span> <span class="hljs-title">AMyActor2</span> :</span> <span class="hljs-keyword">public</span> AActor<br>&#123;<br>GENERATED_BODY()<br><br><span class="hljs-keyword">public</span>:<br>AMyActor2();<br>AActor1* a;<br>TWeakObjectPtr&lt;AActor1&gt; p;<br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Tick</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime)</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//AMyActor2.cpp/BeginPlay()</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AMyActor2::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br>a = NewObject&lt;AActor1&gt;();<br>p = a;<br>a = <span class="hljs-literal">NULL</span>;<br>GEngine-&gt;ForceGarbageCollection();<br>&#125;<br></code></pre></td></tr></table></figure><p>OutputLog:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-attr">LogTemp:</span> <span class="hljs-attr">Warning:</span> Actor1 Created<br><br><span class="hljs-attr">LogTemp:</span> <span class="hljs-attr">Warning:</span> Actor1 Destryed<br></code></pre></td></tr></table></figure><p>可以看到，AActor1对象依旧被强制回收了。</p><p>而TWeakPtr则对于自定义类的弱指针。</p><p><font color="red">注意：弱指针不可以被用来作为TSet或TMap的Key，因为一个对象被GC时无法通知一个容器的Key，但是可以用来作为容器的Value。</font></p><h3 id="TSharedPtr、TSharedRef（自定义类的GC）"><a href="#TSharedPtr、TSharedRef（自定义类的GC）" class="headerlink" title="TSharedPtr、TSharedRef（自定义类的GC）"></a>TSharedPtr、TSharedRef（自定义类的GC）</h3><p>自定义类的GC，UE也贴心的提供了<font color="red"> TSharedPtr和TSharedRef</font>对象来为自定义类支持GC，TSharedPtr本质上是一个被封装过的指针，使用形式上依然保留指针的风格。</p><p><font color="red"> 创建TSharedPtr指针指向一个自定义类时，需要使用<code>MakeShareable()</code>函数，如：</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">TSharedPtr&lt;UMyObject&gt; p = MakeShareable(NewObject&lt;UMyObject&gt;());<br>TSharedPtr&lt;FActor&gt; f = MakeShareable(<span class="hljs-keyword">new</span> FActor());<br></code></pre></td></tr></table></figure><p>TSharedPtr和TSharedRef都可以为自定义类提供GC功能，二者的区别只在于TSharedPtr可以为null，而SharedRef不可以。我在网上查询发现有三种方法构建TSharedRef，分别为：</p><p>第一种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">TSharedRef&lt;FActor&gt; <span class="hljs-title">ref</span><span class="hljs-params">(<span class="hljs-keyword">new</span> FActor())</span></span>;<br></code></pre></td></tr></table></figure><p>第二种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">TSharedRef&lt;FActor&gt; ref = MakeShared&lt;FActor&gt;(<span class="hljs-keyword">new</span> FActor());<br></code></pre></td></tr></table></figure><p>第三种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">TSharedPtr&lt;FActor&gt; ptr = MakeShareable&lt;FActor&gt;(<span class="hljs-keyword">new</span> FActor());<br>TSharedRef&lt;FActor&gt; ref = ptr.ToSharedRef();<br></code></pre></td></tr></table></figure><p>其中第二种方法在编写时没有任何问题但在编译时无法通过，并提示：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">The TSharedRef() <span class="hljs-function"><span class="hljs-keyword">constructor</span> <span class="hljs-title">is</span> <span class="hljs-title">for</span> <span class="hljs-title">internal</span> <span class="hljs-title">usage</span> <span class="hljs-title">only</span> <span class="hljs-title">for</span> <span class="hljs-title">hot</span>-<span class="hljs-title">reload</span> <span class="hljs-title">purposes</span>. <span class="hljs-title">Please</span> <span class="hljs-title">do</span> <span class="hljs-title">NOT</span> <span class="hljs-title">use</span> <span class="hljs-title">it</span>.</span><br></code></pre></td></tr></table></figure><p>使用的编译环境为：UE4.22 + VS2017</p><h3 id="FGCObject（在自定义类中控制UObject对象的GC）"><a href="#FGCObject（在自定义类中控制UObject对象的GC）" class="headerlink" title="FGCObject（在自定义类中控制UObject对象的GC）"></a>FGCObject（在自定义类中控制UObject对象的GC）</h3><p>当我们在一个自定义类中组合一个UObject对象时，如果不做特殊处理也会出现GC触发中发现的疑问，在自定义类没有被析构时，UObject的对象的析构函数就被调用了，但是对象依然可以被使用。目前没有发现这种情况会导致什么样的后果，但是作为一个合格的UE程序还是应该尽量避免这种情况的发生，那么在一个自定义类中组合一个UObject对象，应该如何控制UObject对象的GC呢？</p><p>UE4提供了一个叫做<font color="red">FGCObject</font>的类，位于<font color="red">GCObject.h</font>头文件中，我们需要使自定义类继承自FGCObject类，然后再实现AddReferencedObjects函数，并在函数中通过Collector.AddReferencedObject()函数将所有的UObject对象UE4自动管理即可。</p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">INSIDEUE4_API</span> <span class="hljs-title">FActor</span> :</span> FGCObject<br>&#123;<br><span class="hljs-keyword">public</span>:<br>FActor();<br>~FActor();<br>UMyObject* obj;<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddReferencedObjects</span><span class="hljs-params">(FReferenceCollector&amp; Collector)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function"></span>&#123;<br>Collector.AddReferencedObject(obj);<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后，UObject对象就会在FActor对象析构时才被析构。</p><h2 id="2-序列化"><a href="#2-序列化" class="headerlink" title="2.序列化"></a>2.序列化</h2><h3 id="FObjectWriter和FObjectReader序列化对象到文件和从文件读取"><a href="#FObjectWriter和FObjectReader序列化对象到文件和从文件读取" class="headerlink" title="FObjectWriter和FObjectReader序列化对象到文件和从文件读取"></a>FObjectWriter和FObjectReader序列化对象到文件和从文件读取</h3><p>FObjectWriter可以将对象数据序列化为二进制流，然后配合FFileHelper将流写入文件即可实现对象状态存储到文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOperatActor::SaveObject</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>USerializationObj* obj= NewObject&lt;USerializationObj&gt;();<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;OldStr:%s&quot;</span>), *obj-&gt;str);<br>obj-&gt;str = TEXT(<span class="hljs-string">&quot;OperatActor&quot;</span>);<br>TArray&lt;uint8&gt; bytes;<br>FObjectWriter(obj, bytes);<br>FFileHelper::SaveArrayToFile(bytes, *FString(<span class="hljs-string">&quot;D:\\Goulandis\\UE4\\MyProject\\obj.txt&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>配合FFileHelper将文件中的对象状态读入字节数组，FObjectReader就可以将字节数组中的对象状态写入新的对象中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">USerializationObj* <span class="hljs-title">AOperatActor::LoadObject</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>USerializationObj* newObj = NewObject&lt;USerializationObj&gt;();<br>TArray&lt;uint8&gt; bytes;<br>FFileHelper::LoadFileToArray(bytes, *FString(<span class="hljs-string">&quot;D:\\Goulandis\\UE4\\MyProject\\obj.txt&quot;</span>));<br><span class="hljs-function">FObjectReader <span class="hljs-title">reader</span><span class="hljs-params">(newObj, bytes)</span></span>;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;NewStr:%s&quot;</span>), *newObj-&gt;str);<br><span class="hljs-keyword">return</span> newObj;<br>&#125;<br></code></pre></td></tr></table></figure><p>看一下运行结果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142748.png"></p><p>可以看到，新创建的USerializationObj对象的状态是被修改过后的状态。</p><p>Actor的使用方式和UObject是一样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOperatActor::SaveActor</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ASerializationActor* actor = GetWorld()-&gt;SpawnActor&lt;ASerializationActor&gt;();<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;OldStr:%s&quot;</span>), *actor-&gt;str);<br>actor-&gt;str = TEXT(<span class="hljs-string">&quot;NewActor&quot;</span>);<br>TArray&lt;uint8&gt; bytes;<br>FObjectWriter(actor, bytes);<br>FFileHelper::SaveArrayToFile(bytes, *FString(<span class="hljs-string">&quot;D:\\Goulandis\\UE4\\MyProject\\actor.txt&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ASerializationActor * <span class="hljs-title">AOperatActor::LoadActor</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ASerializationActor* actor = GetWorld()-&gt;SpawnActor&lt;ASerializationActor&gt;();<br>TArray&lt;uint8&gt; bytes;<br>FFileHelper::LoadFileToArray(bytes, *FString(<span class="hljs-string">&quot;D:\\Goulandis\\UE4\\MyProject\\actor.txt&quot;</span>));<br><span class="hljs-function">FObjectReader <span class="hljs-title">reader</span><span class="hljs-params">(actor,bytes)</span></span>;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;NewStr:%s&quot;</span>), *actor-&gt;str);<br><span class="hljs-keyword">return</span> actor;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142724.png"></p><h2 id="3-反射"><a href="#3-反射" class="headerlink" title="3.反射"></a>3.反射</h2><p>在使用UE4的反射时有一个基础概念是必须要清楚的，即UE4的反射系统是建立在一整套的宏的设计上的，也就是说，想要一个类、属性、方法、枚举、结构体等支持UE4的反射，那么类必须加UCLASS宏标识，属性必须加UPROPERTTY宏标识，方法必须加UFUNCTION宏标识，枚举必须加UENUM宏标识，结构体必须加USTRUCT宏标识，如果不加这些宏来标识对应的目标，那么这些目标对于UE4的反射系统来说就是不可见的。</p><h3 id="搜索所有的Object"><a href="#搜索所有的Object" class="headerlink" title="搜索所有的Object"></a>搜索所有的Object</h3><p>C++本身的反射系统RTTI相当薄弱，所以UE在C++的基础上借助UObject自己实现了一套反射系统，同时借鉴了C#的长处提供了一系列反射用的系统函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">TArray&lt;UObject*&gt; result;<br>GetObjectsOfClass(UClass::StaticClass(), result);   <span class="hljs-comment">//获取所有的class和interface</span><br>GetObjectsOfClass(UEnum::StaticClass(), result);   <span class="hljs-comment">//获取所有的enum</span><br>GetObjectsOfClass(UScriptStruct::StaticClass(), result);   <span class="hljs-comment">//获取所有的struct</span><br></code></pre></td></tr></table></figure><h3 id="运行时创建对象"><a href="#运行时创建对象" class="headerlink" title="运行时创建对象"></a>运行时创建对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOperatActor::FindSerializationObj</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>UClass* uclass = FindObject&lt;UClass&gt;(ANY_PACKAGE, TEXT(<span class="hljs-string">&quot;SerializationObj&quot;</span>));<br>USerializationObj* obj = Cast&lt;USerializationObj&gt;(uclass-&gt;GetDefaultObject());<br>obj-&gt;PrintStr();<br>&#125;<br></code></pre></td></tr></table></figure><p>UE4提供FindObject模板函数来搜索指定的类的类型信息，返回的类型元素据通过UClass类型对象存储，UClass对象就是UE4专门用来存储元数据的类型，UClass中提供了大量的方法来操作元数据，<a href="https://docs.unrealengine.com/en-US/API/Runtime/CoreUObject/UObject/UClass/index.html">UClass</a>，这里使用GetDefaultObject函数调用默认的构造函数创建SerializationObj类型的对象，需要注意的是GetDefaultObject返回的是一个UObject对象，所以需要使用Cast来做类型转换。</p><h3 id="遍历对象内所有的属性、函数"><a href="#遍历对象内所有的属性、函数" class="headerlink" title="遍历对象内所有的属性、函数"></a>遍历对象内所有的属性、函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOperatActor::Foreach</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>UClass* uclass = FindObject&lt;UClass&gt;(ANY_PACKAGE, TEXT(<span class="hljs-string">&quot;SerializationObj&quot;</span>));<br>USerializationObj* obj = Cast&lt;USerializationObj&gt;(uclass-&gt;GetDefaultObject());<br>    UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;UProprty Start&quot;</span>));<br><span class="hljs-keyword">for</span> (TFieldIterator&lt;UProperty&gt; i(obj-&gt;GetClass()); i; ++i)<br>&#123;<br>UProperty* up = *i;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;UProperty:%s&quot;</span>), *up-&gt;GetName());<br>&#125;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;UProprty End&quot;</span>));<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;UFunction Start&quot;</span>));<br><span class="hljs-keyword">for</span> (TFieldIterator&lt;UFunction&gt; i(obj-&gt;GetClass()); i; ++i)<br>&#123;<br>UFunction* uf = *i;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;UFunction:%s&quot;</span>), *uf-&gt;GetName());<br>&#125;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;UFunction End&quot;</span>));<br>&#125;<br><br></code></pre></td></tr></table></figure><p>USerializationObj头文件内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">UCLASS(BlueprintType)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROJECT_API</span> <span class="hljs-title">USerializationObj</span> :</span> <span class="hljs-keyword">public</span> UObject<br>&#123;<br>GENERATED_BODY()<br><span class="hljs-keyword">public</span>:<br>UPROPERTY(BlueprintReadWrite)<br>FString str = <span class="hljs-string">&quot;Init String&quot;</span>;<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br><br>USerializationObj();<br>UFUNCTION()<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintStr</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>输出：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142713.png"></p><p><font color="red">注意：</font></p><ul><li><font color="red">对于<code>UClass* uclass = FindObject&lt;UClass&gt;(ANY_PACKAGE, TEXT(&quot;SerializationObj&quot;));</code>需要注意的是UClass不能使用智能指针来装载，如：<code>TSharedPtr&lt;UClass&gt; uclass = MakeShared(FindObject&lt;UClass&gt;(ANY_PACKAGE,TEXT(&quot;SerializationObje&quot;)))</code>，使用智能指针在编译阶段和运行阶段都没有问题，但是结束运行时会导致引擎崩溃（直接启动的引擎会崩溃，通过vs启动的引擎会报异常），根据崩溃的提示，原因视乎和GC有关，具体原因未明。</font></li><li><font color="red"><code>for (TFieldIterator&lt;UProperty&gt; i(obj-&gt;GetClass()); i; ++i)</code>的i的构造参数是UClass类型，而GetClass函数是一个实例函数，所以要取得一个类的UClass数据就不得不提供一个它的实例</font></li></ul><p>此外由于静态变量无法被UPROPERTY宏标识，所以static属性对于UE4的反射系统来说也是不可见的，使用<code>for (TFieldIterator&lt;UProperty&gt; i(obj-&gt;GetClass()); i; ++i)</code>遍历属性是可以发现其中没有静态属性的。</p><h3 id="遍历类的继承的所有接口"><a href="#遍历类的继承的所有接口" class="headerlink" title="遍历类的继承的所有接口"></a>遍历类的继承的所有接口</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOperatActor::Foreach</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    UClass* uclass = FindObject&lt;UClass&gt;(ANY_PACKAGE, TEXT(<span class="hljs-string">&quot;SerializationObj&quot;</span>));<br>USerializationObj* obj = Cast&lt;USerializationObj&gt;(uclass-&gt;GetDefaultObject());<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Interfaces Start&quot;</span>));<br><span class="hljs-keyword">for</span> (FImplementedInterface&amp; i : obj-&gt;GetClass()-&gt;Interfaces)<br>&#123;<br>UClass* inter = i.Class;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Interface:%s&quot;</span>), *inter-&gt;GetName());<br>&#125;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Interfaces End&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>USerializationObj头文件内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">UCLASS(BlueprintType)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROJECT_API</span> <span class="hljs-title">USerializationObj</span> :</span> <span class="hljs-keyword">public</span> UObject,<span class="hljs-keyword">public</span> ITestInterface1,<span class="hljs-keyword">public</span> ITestInterface2<br>&#123;<br>GENERATED_BODY()<br><span class="hljs-keyword">public</span>:<br>UPROPERTY(BlueprintReadWrite)<br>FString str = <span class="hljs-string">&quot;Init String&quot;</span>;<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br><br>USerializationObj();<br>UFUNCTION()<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintStr</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142435.png" alt="、"></p><h3 id="遍历枚举"><a href="#遍历枚举" class="headerlink" title="遍历枚举"></a>遍历枚举</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++">UENUM()<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">TestEnum</span></span><br><span class="hljs-class">&#123;</span><br>A,<br>B,<br>C<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOperatActor::Foreach</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Enum Start&quot;</span>));<br>UEnum* enumClass = StaticEnum&lt;TestEnum&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; enumClass-&gt;NumEnums() - <span class="hljs-number">1</span>; i++)<br>&#123;<br>FString enumStr = enumClass-&gt;GetValueAsString(TestEnum(enumClass-&gt;GetValueByIndex(i)));<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Enum:%s&quot;</span>), *enumStr);<br>&#125;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Enum End&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142430.png"></p><h3 id="遍历元数据"><a href="#遍历元数据" class="headerlink" title="遍历元数据"></a>遍历元数据</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOperatActor::Foreach</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    UClass* uclass = FindObject&lt;UClass&gt;(ANY_PACKAGE, TEXT(<span class="hljs-string">&quot;SerializationObj&quot;</span>));<br>USerializationObj* obj = Cast&lt;USerializationObj&gt;(uclass-&gt;GetDefaultObject());<br>    UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Meta Start&quot;</span>));<br>UMetaData* meta = obj-&gt;GetOutermost()-&gt;GetMetaData();<br>TMap&lt;FName, FString&gt;* keyValues = meta-&gt;GetMapForObject(obj);<br><span class="hljs-keyword">if</span> (keyValues != <span class="hljs-literal">nullptr</span> &amp;&amp; keyValues-&gt;Num() &gt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">for</span> (TPair&lt;FName, FString&gt; p : *keyValues)<br>&#123;<br>FString key = p.Key.ToString();<br>FString vuale = p.Value;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Meta:Key=%s,Value=%s&quot;</span>),*key,*vuale);<br>&#125;<br>&#125;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Meta End&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="red">需要注意的是，一个对象的UMetaData数据不能直接获取，而需要通过GetOutermost函数获取这个对象的UPakage对象再通过UPakage对象的GetMetaData函数来获取，由于UE4使用<code>TMap&lt;FName,FString&gt;</code>的数据结构来存储元数据，所以我们通过UMetaData对象的GetMapForObject函数获取的元数据需要使用一个<code>TMap&lt;FName,FString&gt;来存储，而TMap的元素又是一个TPair，所以遍历时可以使用一个范围for循环并使用</code>TPair&lt;FName,FString&gt;<code>结构来存储取出的</code>TMap&lt;FName,FString&gt;<code>元素。</code></font></p><p>对于元素据暂时没有深入去研究，总之如果我们只创建一个UObject类并且只往里面添加一些属性和函数，类的元数据都是空的，尝试过向UCLASS和UPROPERTY宏中添加meta内容，元数据依旧是空的，所以在使用<code>TMap&lt;FName,FString&gt;</code>时最好先判空。</p><p><font color="red">这里有一个坑，就是UE_LOG不能打印FName类型的字符串，FName类型字符串必须通过ToString函数转换成FString才能被UE_LOG打印，更坑的是直接打印FName时，在编写代码时编辑器不会报错，只有在编译时才会报错。</font></p><h3 id="遍历继承关系"><a href="#遍历继承关系" class="headerlink" title="遍历继承关系"></a>遍历继承关系</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOperatActor::Foreach</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;SuperClass Start&quot;</span>));<br>TArray&lt;FString&gt; className;<br>className.Add(obj-&gt;GetClass()-&gt;GetName());<br>UClass* super = obj-&gt;GetClass()-&gt;GetSuperClass();<br><span class="hljs-keyword">while</span> (super)<br>&#123;<br>className.Add(super-&gt;GetName());<br>super = super-&gt;GetSuperClass();<br>&#125;<br>FString superClassStr = FString::Join(className, TEXT(<span class="hljs-string">&quot;-&gt;&quot;</span>));<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;SuperClass:%s&quot;</span>), *superClassStr);<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;SuperClass End&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142403.png"></p><p>将UClass换成UStruct最终效果也是一样的，因为UClass继承自UStruct。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOperatActor::Foreach</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;SuperClass Start&quot;</span>));<br>TArray&lt;FString&gt; className;<br>className.Add(obj-&gt;GetClass()-&gt;GetName());<br>UStruct* super = obj-&gt;GetClass()-&gt;GetSuperUStruct();<br><span class="hljs-keyword">while</span> (super)<br>&#123;<br>className.Add(super-&gt;GetName());<br>super = super-&gt;GetSuperUStruct();<br>&#125;<br>FString superClassStr = FString::Join(className, TEXT(<span class="hljs-string">&quot;-&gt;&quot;</span>));<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;SuperClass:%s&quot;</span>), *superClassStr);<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;SuperClass End&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="遍历所有的子类"><a href="#遍历所有的子类" class="headerlink" title="遍历所有的子类"></a>遍历所有的子类</h3><p>首先为USerializationObj类创建两个子类：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142357.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">oid <span class="hljs-title">AOperatActor::Foreach</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;DerivedClass Start&quot;</span>));<br>TArray&lt;UClass*&gt; res;<br>GetDerivedClasses(USerializationObj::StaticClass(), res, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">for</span> (UClass* uc : res)<br>&#123;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;SubClass:%s&quot;</span>),*uc-&gt;GetName());<br>&#125;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;DerivedClass End&quot;</span>));   <br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142332.png"></p><h3 id="动态操作实例属性"><a href="#动态操作实例属性" class="headerlink" title="动态操作实例属性"></a>动态操作实例属性</h3><p>UE4提供了一个通过名字来动态获取属性的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOperatActor::Invoke</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    UClass* uclass = FindObject&lt;UClass&gt;(ANY_PACKAGE, TEXT(<span class="hljs-string">&quot;SerializationObj&quot;</span>));<br>USerializationObj* obj = Cast&lt;USerializationObj&gt;(uclass-&gt;GetDefaultObject());<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;FindPropertyByName Start&quot;</span>));<br>UProperty* upro = obj-&gt;GetClass()-&gt;FindPropertyByName(FName(TEXT(<span class="hljs-string">&quot;str&quot;</span>)));<br>FString* str = upro-&gt;ContainerPtrToValuePtr&lt;FString&gt;(obj);<br>check(str);<br>*str = TEXT(<span class="hljs-string">&quot;UProperty FString&quot;</span>);<br>obj-&gt;PrintStr();<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;FindPropertyByName End&quot;</span>));<br>&#125;<br><br></code></pre></td></tr></table></figure><p>SerializationObj类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">UCLASS(BlueprintType,meta=(DiaplayName=<span class="hljs-string">&quot;Obj&quot;</span>))<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROJECT_API</span> <span class="hljs-title">USerializationObj</span> </span><br><span class="hljs-class">&#123;</span><br>GENERATED_BODY()<br><span class="hljs-keyword">public</span>:<br>UPROPERTY(BlueprintReadWrite,meta=(EditCondition=<span class="hljs-string">&quot;bCanNamePropertyShow&quot;</span>))<br>FString str = <span class="hljs-string">&quot;Init String&quot;</span>;<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span>:<br>    UPROPERTY()<br>FString priStr = TEXT(<span class="hljs-string">&quot;Private String&quot;</span>);<br><span class="hljs-keyword">public</span>:<br>USerializationObj();<br>UFUNCTION()<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintStr</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142327.png"></p><p><code>UClass::FindPropertyByName()</code>函数可以通过名字来访问调用对象中的属性，而FindPropertyByName()返回的也不是直接可用的属性，而是包含这个属性信息的UProperty类，然后通过<code>UProperty::ContainerPtrToValuePtr()</code>函数可以获取这个属性的指针，通过这个指针即可修改属性的值了。这个方法可直接修改实例中的任何属性，在测试修改const属性时发现了一个问题，即被UPROPERTY宏修饰的属性如果加上const那么程序将无法编译通过</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142323.png"></p><p>除此之外也可通过遍历属性的方法来获取想要的属性，同样支持任何保护级</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOperatActor::Invoke</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    UClass* uclass = FindObject&lt;UClass&gt;(ANY_PACKAGE, TEXT(<span class="hljs-string">&quot;SerializationObj&quot;</span>));<br>USerializationObj* obj = Cast&lt;USerializationObj&gt;(uclass-&gt;GetDefaultObject());<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Private Property Start&quot;</span>));<br><span class="hljs-keyword">for</span> (TFieldIterator&lt;UProperty&gt; i(obj-&gt;GetClass()); i; ++i)<br>&#123;<br>UProperty* up = *i;<br><span class="hljs-keyword">if</span> (up-&gt;GetName() == TEXT(<span class="hljs-string">&quot;priStr&quot;</span>))<br>&#123;<br>FString* priStr = up-&gt;ContainerPtrToValuePtr&lt;FString&gt;(obj);<br>check(priStr);<br>*priStr = TEXT(<span class="hljs-string">&quot;UProperty PrivateString&quot;</span>);<br>obj-&gt;PrintPrivateStr();<br>&#125;<br>&#125;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Private Property End&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>当然直接通过指针来操作属性在安全性上是不够的，大多数时候我们可能只是需要属性的一份值拷贝就够了，所以UE4针对FString类型的属性提供了两个更安全的操作函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOperatActor::Invoke</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    UClass* uclass = FindObject&lt;UClass&gt;(ANY_PACKAGE, TEXT(<span class="hljs-string">&quot;SerializationObj&quot;</span>));<br>USerializationObj* obj = Cast&lt;USerializationObj&gt;(uclass-&gt;GetDefaultObject());<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;ExportTextItem Start&quot;</span>));<br>FString outStr;<br>UProperty* outUpro = obj-&gt;GetClass()-&gt;FindPropertyByName(FName(TEXT(<span class="hljs-string">&quot;str&quot;</span>)));<br>outUpro-&gt;ExportTextItem(outStr, outUpro-&gt;ContainerPtrToValuePtr&lt;FString*&gt;(obj), <span class="hljs-literal">nullptr</span>, (UObject<br>*)obj, PPF_None);<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;OutStr:%s&quot;</span>),*outStr);<br>outStr = TEXT(<span class="hljs-string">&quot;NewFString&quot;</span>);<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;OutStr:%s&quot;</span>), *outStr);<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;OutStr:%s&quot;</span>), *obj-&gt;str);<br>FString inStr = TEXT(<span class="hljs-string">&quot;NewFString&quot;</span>);<br>outUpro-&gt;ImportText(*inStr, outUpro-&gt;ContainerPtrToValuePtr&lt;FString*&gt;(obj), PPF_None, obj);<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;InStr:%s&quot;</span>), *obj-&gt;str);<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;ExportTextItem End&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142316.png"></p><p><code>UProperty::ExportTextIte</code>函数返回的是一个FString，而非FString*，所以获取到的是一份FString的拷贝，可以看到我们对outStr做修改是不会影响到到obj中的str的，同时UE4也提供拷贝设值<code>UProperty::ImportText</code>函数，将inStr的值拷贝赋值到obj的str中，之后obj的str的值就发生了变化。</p><h3 id="动态调用实例函数"><a href="#动态调用实例函数" class="headerlink" title="动态调用实例函数"></a>动态调用实例函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOperatActor::InvokeFunction</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;InvokeFunction Start&quot;</span>));<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fun_Params</span></span><br><span class="hljs-class">&#123;</span><br>FString pam1;<br><span class="hljs-keyword">bool</span> pam2;<br>FString ret;<br>&#125;;<br>UClass* uclass = FindObject&lt;UClass&gt;(ANY_PACKAGE, TEXT(<span class="hljs-string">&quot;SerializationObj&quot;</span>));<br>USerializationObj* obj = Cast&lt;USerializationObj&gt;(uclass-&gt;GetDefaultObject());<br>UFunction* fun = obj-&gt;FindFunctionChecked(<span class="hljs-string">&quot;ExcternalInvokeFun&quot;</span>);<br>Fun_Params pams;<br>pams.pam1 = TEXT(<span class="hljs-string">&quot;Invoke ExcternalInvokeFun&quot;</span>);<br>pams.pam2 = <span class="hljs-literal">true</span>;<br>obj-&gt;ProcessEvent(fun, &amp;pams);<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;InvokeFunction:ret=%s&quot;</span>), *pams.ret);<br>UFunction* fun_none = obj-&gt;FindFunctionChecked(<span class="hljs-string">&quot;PrintStr&quot;</span>);<br>obj-&gt;ProcessEvent(fun_none, <span class="hljs-literal">nullptr</span>);<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;InvokeFunction End&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>SerializationObj头文件内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++">UCLASS(BlueprintType,meta=(DiaplayName=<span class="hljs-string">&quot;Obj&quot;</span>))<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROJECT_API</span> <span class="hljs-title">USerializationObj</span> :</span> <span class="hljs-keyword">public</span> UObject,<span class="hljs-keyword">public</span> ITestInterface1,<span class="hljs-keyword">public</span> ITestInterface2<br>&#123;<br>GENERATED_BODY()<br><span class="hljs-keyword">public</span>:<br>UPROPERTY(BlueprintReadWrite,meta=(EditCondition=<span class="hljs-string">&quot;bCanNamePropertyShow&quot;</span>))<br>FString str = <span class="hljs-string">&quot;Init String&quot;</span>;<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">static</span> FString staticStr;<br><span class="hljs-keyword">private</span>:<br>UPROPERTY()<br>FString priStr = TEXT(<span class="hljs-string">&quot;Private String&quot;</span>);<br><span class="hljs-keyword">public</span>:<br>USerializationObj();<br>UFUNCTION()<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintStr</span><span class="hljs-params">()</span></span>;<br>UFUNCTION()<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintPrivateStr</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>;<br>UFUNCTION()<br><span class="hljs-function">FString <span class="hljs-title">ExcternalInvokeFun</span><span class="hljs-params">(FString pam1, <span class="hljs-keyword">bool</span> pam2)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142309.png"></p><p>事实上真正通过反射调用函数的方法是：<code>ProcessEvent</code>，而有参函数和无参函数的调用又有所区别，首先需要通过<code>UObject::FindFunctionChecked</code>函数通过函数名获取函数的元数据信息存储到UFunction类中，无参函数的调用就可以直接通过<code>ProcessEvent(UFunction*,nullptr)</code>来调用了，第一个参数是存储了指定函数元数据信息的UFunction，由于没有参数所以传入函数参数的第二个参数直接设为nullptr即可。</p><p>而对于有参数有返回值的函数调用，则需要提前创建好存储函数参数和返回值的结构体，如上面例子中Fun_Params，名字可以随意取，但是结构体的成员类型、数量和顺序必须和对应的gen.cpp文件中UE4为这个函数创建的存储函数参数信息的结构体一直，我们可以看一下这个结构体的结构，位置在：项目根目录\Intermediate\Build\Win64\UE4Editor\Inc\MyProject\SerializationObj.gen.cpp，我这里类的名字是SerializationObj，所以文件叫SerializationObj.gen.cpp。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SerializationObj_eventExcternalInvokeFun_Parms</span></span><br><span class="hljs-class">&#123;</span><br>FString pam1;<br><span class="hljs-keyword">bool</span> pam2;<br>FString ReturnValue;<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后对应函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">FString <span class="hljs-title">USerializationObj::ExcternalInvokeFun</span><span class="hljs-params">(FString pam1, <span class="hljs-keyword">bool</span> pam2)</span></span><br><span class="hljs-function"></span>&#123;<br>FString ret = TEXT(<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-keyword">if</span> (pam2)<br>&#123;<br>ret = pam1 + TEXT(<span class="hljs-string">&quot;_True&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>ret = pam1 + TEXT(<span class="hljs-string">&quot;_False&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>结构体的成员和函数的参数列表类型和顺序一一对应的，最后一个成员固定名字为ReturnValue用于存储函数的返回值。</p><p>所以我们在调用有参有返回值的函数时需要创建一个对应这种结构的结构体，使用这个结构体的变量来传递参数和接收返回值，如上面例子中的：pams。</p><p>相较于C#中Invoke函数，将参数和返回值直接装箱至object中，UE4却没有办法这么做，因为UE4的UObject系统和原生C++可以算是两套系统，UE4的UObject没办法像C#那样将所有的类型都装箱到UObject中，索性把装箱的操作直接交给开发者做了，所以才有创建存储参数返回值的结构体的步骤。</p><h3 id="C-通过反射调用蓝图函数和事件"><a href="#C-通过反射调用蓝图函数和事件" class="headerlink" title="C++通过反射调用蓝图函数和事件"></a>C++通过反射调用蓝图函数和事件</h3><p>由于蓝图函数和事件在编译后也是以UFunction的元数据存储的，所以通过反射是可以实现C++调用蓝图函数和事件的。</p><p>首先创建一个继承自Actor的蓝图MyBlueprint，并在蓝图中新增函数PrintStr和自定义事件PrintWorld：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142302.png"></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142257.png"></p><p>然后在C++中增加调用蓝图函数和事件的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOperatActor::InvokeBPFunction</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (TActorIterator&lt;AActor&gt; bpActor(GetWorld()); bpActor; ++bpActor)<br>&#123;<br><span class="hljs-keyword">if</span> (bpActor-&gt;GetName() == TEXT(<span class="hljs-string">&quot;MyBlueprint&quot;</span>))<br>&#123;<br><span class="hljs-keyword">for</span> (TFieldIterator&lt;UFunction&gt; bpFun(bpActor-&gt;GetClass()); bpFun; ++bpFun)<br>&#123;<br><span class="hljs-keyword">if</span> (bpFun-&gt;HasAnyFunctionFlags(FUNC_BlueprintEvent) &amp;&amp; bpFun-&gt;HasAnyFunctionFlags(FUNC_BlueprintCallable) &amp;&amp; bpFun-&gt;GetName() == TEXT(<span class="hljs-string">&quot;PrintStr&quot;</span>))<br>&#123;<br>UFunction* fun = *bpFun;<br>uint8* buff = <span class="hljs-keyword">static_cast</span>&lt;uint8*&gt;(FMemory_Alloca(fun-&gt;ParmsSize));<br>FFrame frame = FFrame(*bpActor, fun, buff);<br>fun-&gt;Invoke(*bpActor, frame, buff);<br>&#125;<br><span class="hljs-keyword">if</span> (bpFun-&gt;HasAnyFunctionFlags(FUNC_BlueprintEvent) &amp;&amp; bpFun-&gt;HasAnyFunctionFlags(FUNC_BlueprintCallable) &amp;&amp; bpFun-&gt;GetName() == TEXT(<span class="hljs-string">&quot;PrintWorld&quot;</span>))<br>&#123;<br>UFunction* fun = *bpFun;<br>uint8* buff = <span class="hljs-keyword">static_cast</span>&lt;uint8*&gt;(FMemory_Alloca(fun-&gt;ParmsSize));<br>FFrame frame = FFrame(*bpActor, fun, buff);<br>fun-&gt;Invoke(*bpActor, frame, buff);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们逐行分析：</p><p><code>for (TActorIterator&lt;AActor&gt; bpActor(GetWorld()); bpActor; ++bpActor)</code>，遍历Level中所有的Actor，这里有一个坑，就是GetWorld()必须使用Actor自身的GetWorld()函数，不能使用GEngine-&gt;GetWorld()，否则运行时会提示资源被占用；</p><p><code>if (bpActor-&gt;GetName() == TEXT(&quot;MyBlueprint&quot;))</code>，找到我们需要的蓝图；</p><p><code>for (TFieldIterator&lt;UFunction&gt; bpFun(bpActor-&gt;GetClass()); bpFun; ++bpFun)</code>，遍历蓝图中的所有的函数和事件，蓝图函数和事件在底层元数据都是以UFunction的形式存储的，所以遍历的时候可以同时遍历函数和事件；</p><p><code>if (bpFun-&gt;HasAnyFunctionFlags(FUNC_BlueprintEvent) &amp;&amp; bpFun-&gt;HasAnyFunctionFlags(FUNC_BlueprintCallable) &amp;&amp; bpFun-&gt;GetName() == TEXT(&quot;PrintStr&quot;))</code>，找到蓝图中名字为PrintStr的函数HasAnyFunctionFlags()函数用于判断当前函数是否拥有某个标记，如：FUNC_BlueprintEvent—函数时蓝图事件，FUNC_BlueprintCallable—函数是蓝图可调用函数即蓝图函数；</p><p><code>UFunction* fun = *bpFun;</code>获取函数的元素据存储到UFunction中；</p><p><code>uint8* buff = static_cast&lt;uint8*&gt;(FMemory_Alloca(fun-&gt;ParmsSize));</code>，为函数栈申请内存空间，FMemory_Alloca申请自动内存的宏，fun-&gt;ParmsSize函数的总变量大小；</p><p><code>FFrame frame = FFrame(*bpActor, fun, buff);</code>，创建函数栈；</p><p><code>fun-&gt;Invoke(*bpActor, frame, buff);</code>，通过函数栈执行函数</p><p>这种方式调用蓝图函数虽然很灵活方便，但是效率实在堪忧，能不用还是尽量别用吧。</p><h3 id="C-通过子类重写调用蓝图函数"><a href="#C-通过子类重写调用蓝图函数" class="headerlink" title="C++通过子类重写调用蓝图函数"></a>C++通过子类重写调用蓝图函数</h3><p>通过C++父类申明函数，蓝图子类实现函数，C++父类调用函数的方式也可以实现C++调用蓝图函数，虽然这种方式不属于反射的范畴了，不过想起来了还是记录一下吧。</p><p>首先对于C++类AOperActor创建一个给蓝图来实现的函数BPPrint</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROJECT_API</span> <span class="hljs-title">AOperatActor</span> :</span> <span class="hljs-keyword">public</span> AActor<br>&#123;<br>GENERATED_BODY()<br><br><span class="hljs-keyword">public</span>:<br>AOperatActor();<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Tick</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime)</span> <span class="hljs-keyword">override</span></span>;<br>UFUNCTION(BlueprintImplementableEvent)<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BPPrint</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p><font color="red">这里需要注意的是，如果需要用蓝图子类来实现父类函数的话，这个函数必须是public权限，且需要标识BlueprintImplementableEvent，这个标识符会告诉UE4这个函数可以在蓝图中被当作事件来使用，并且会对这个函数进行默认实现，也就是实现一个空函数体，这就是为什么即使我们不在子类里实现这个函数直接调用也不会报错的原因。</font></p><p>然后我们创建一个继承自AOperator类的蓝图类并在蓝图类里实现BPPrint函数</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142244.png"></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142240.png"></p><p>这里实现BPPrint函数的方式有两个，一个是直接右键搜索BPPrint就像调用事件一样，直接调出实现，另一个是在Function中重写BPPrint，最终的结果和表现形式是一样的。</p><p>然后最关键的一点就是，OperatorActorInherit这个实现了BPPrint函数的蓝图类必须要在场景中函数调用才能生效，我们在AOperatorActor类的BeginPlay函数中调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOperatActor::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br>BPPrint();<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142234.png"></p><p>我这里选择使用一个Actor来做C++通过继承调用蓝图函数的例子而不是Object，也正是因为实现函数的蓝图必须在场景里调用才生效，而Object是不能存在于场景中的。</p><p>上面说到蓝图VM会为被BlueprintImplementableEvent标识的函数生成默认实现，事实上UE4也提供了函数的自定义默认实现的，即使用<code>BlueprintNativeEvent</code>标识就可以自定义函数的默认实现了，且必须要实现，否则编译不能通过，更重要的是函数名还有所变化，如：我们要自定义BPPrint的默认实现，那么BPPrint的实现应该如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOperatActor::BPPrint_Implementation</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>GEngine-&gt;AddOnScreenDebugMessage(<span class="hljs-number">-1</span>, <span class="hljs-number">5.f</span>, FColor::Red, FString::Printf(TEXT(<span class="hljs-string">&quot;BPPrint&quot;</span>)));<br>&#125;<br></code></pre></td></tr></table></figure><p>后缀<code>_Implementation</code>是必须要加的，否则编译无法通过。</p><p>此时如果我们不在子类中重写这个函数那么调用是默认调用父类的函数实现，如果我们在子列中重写这个函数的实现那么调用的就是子类的函数实现了。如：</p><p>不在子类中重写：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142228.png"></p><p>在子类中重写：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142223.png"></p><p>这里有一个问题，就是父类的实现会被多调用一次，原因未知。</p><p>除了通过重写父类函数然后直接通过调用父类函数的形式在C++中调用子类的蓝图函数的调用方式外，UE4还提供了直接通过函数名字来调用子类的任意函数的接口：</p><h3 id="C-通过CallFunctionByNameWithArguments调用蓝图函数"><a href="#C-通过CallFunctionByNameWithArguments调用蓝图函数" class="headerlink" title="C++通过CallFunctionByNameWithArguments调用蓝图函数"></a>C++通过CallFunctionByNameWithArguments调用蓝图函数</h3><p>大部分操作和前面的C++通过子类重写调用蓝图函数一样，需要一个继承自父类的蓝图子类，不同的是子类不需要重写父类的函数，父类可以直接通过CallFunctionByNameWithArguments接口使用函数名调用子类蓝图中任意函数。</p><p>子类蓝图中的PrintHello函数</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142207.png"></p><p>注意这个函数是直接由子类创建的。</p><p>然后就可以直接在父类里调用了，我这里直接在BeginePlay里调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AOperatActor::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br>FString cmd = FString::Printf(TEXT(<span class="hljs-string">&quot;PrintHello HHHHHH&quot;</span>));<br>FOutputDeviceDebug de;<br>CallFunctionByNameWithArguments(*cmd, de, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208142131.png"></p><p><font color="red">这里有几点需要注意，FString::Printf中的字符串使用空格隔开，一个字符串为要调用的函数名，之后的字符串为参数，各个参数之间也是用空格隔开，FOutputDeviceDebug来自头文件OutputDeviceDebug.h</font></p><p>当然CallFunctionByNameWithArguments接口也有通过子类重写来调用蓝图的方式一样需要通过子类来调用蓝图，所以一样需要这个子类蓝图要存在于场景中，否则调用一样无效，所以有一样的局限性，就是只支持Actor类型。</p><h1 id="三、AActor"><a href="#三、AActor" class="headerlink" title="三、AActor"></a>三、AActor</h1><h2 id="1-Actor网络同步"><a href="#1-Actor网络同步" class="headerlink" title="1.Actor网络同步"></a>1.Actor网络同步</h2><p>Actor的网络同步可以参考<a href="https://goulandis.github.io/2021/08/11/%E3%80%90UE5%E3%80%91UE5%20Dedicated%20Server%E4%B8%93%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5/">另一篇博文</a>的第三节</p><h2 id="2-GameMode"><a href="#2-GameMode" class="headerlink" title="2.GameMode"></a>2.GameMode</h2><h3 id="GameMode的执行过程"><a href="#GameMode的执行过程" class="headerlink" title="GameMode的执行过程"></a>GameMode的执行过程</h3><p>这里引用Ken_An大佬总结的一张精髓图片</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127141200.png"></p><p>GameMode只运行在服务器当中，对于单机游戏来说，由于UE4的服务器代码和客户端代码是一体的所以单机游戏本身可以算是自己的服务器，对网络游戏来说，GameMode只存在于服务器当中，在客户端中只拥有GameMode的一些副本，GameMode存在于ULevel中，当游戏切换Level时，当前GameMode会随着Level的切换而被销毁，并在新的Level加载之后产生新的GameMode。</p><p>GameMode的创建到Pawn的生成过程：</p><ul><li><p>游戏进程开始运行，此时UE创建GameInstance，GameInstance初始化WorldSetting中设置的GameMode，事实上在UE创建GameInstance时还创建UEngine和UWorld；</p></li><li><p>UE调用UGameEngine::Start函数，Start函数调用UEngine::Browse函数，再由Browse函数调用UEngine::LoadMap函数，由LoadMap函数来加载Map，创建新的World，并调用AGameInstance::CreateGameModeForURL创建GameMode；</p></li><li><p>SetGameMode函数主要是确保GameMode只能在Server端创建，并调用AGameInstance::CreateGameModeForURL函数创建GameMode，而CreateGameModeForURL就是实际直接调用SpawnActor创建GameMode的函数了；</p></li><li><p>CreateGameModeForURL函数会去读取WorldSetting的配置，并配置到新创建GameMode中；</p></li><li><p>Client发送连接请求：Client通过ClientTravel函数向服务器请求连接；</p></li><li><p>Server处理Client的请求连接：如果Server接受Client的连接，则发送配置的Server Default Map给Client；</p></li><li><p>Client加载地图成功之后，Server调用AGameModeBase::PreLogin函数，如果Server不想某个Client接入游戏，可以在PreLogin中拒绝；</p></li><li><p>如果Server接受Client加入游戏，则调用AGameModeBase::Login，如果不接受则不调用：每当有一个Client加入游戏，Login函数就会创建一个PlayerController并复制一份到对应的Client中替换Client的本地PlayerController，此时Client和Server就通过PlayerController建立起了通信连接，RPC调用就生效了，但是按官方的说法此时调用RPC还是不安全的，应该在AGameModeBase::PostLogin函数执行完之后再调用；</p><p><font color="green">疑问：按照官方的说法，PreLogin在Login之前调用，且源码中也是一个公有的虚函数，我在自定义的GameMode中重写的PreLogin函数在游戏运行时并没有调用而重写的Login和PostLogin会调用，关于这方面的资料实在是太过于匮乏，目前尚不知道原因何在。</font></p></li><li><p>PostLogin调用HandleStartingNewPlayer：HandleStartingNewPlayer函数是可以被蓝图重写的；</p></li><li><p>HandleStartingNewPlayer调用RestartPlayer：RestartPlayer为蓝图可调用函数，但UE不允许RestartPlayer函数被蓝图重写，允许被C++重写；</p></li><li><p>RestartPlayer函数会通过FindPlayerStart函数为将要Spawn的Pawn选取出生位置，然后调用RestartPlayerAtPlayerStart函数在在指定位置生成Pawn；</p></li><li><p>RestartPlayerAtPlayerStart则会调用SpawnDefaultPawnFor函数实际生成Pawn并设置生成位置，然后提供InitStartSpot函数在引擎认为完成Pawn的生成之前来调整Pawn的出生位置，InitStartSpot在源码中是一个空函数，可以被蓝图重写，然后RestartPlayerAtPlayerStart会调用FinishRestartPlayer函数来设置Controller的朝向，并通知引擎确认Pawn的生成；</p></li><li><p>SpawnDefaultPawnFor函数也是一个蓝图可重写函数，会初始化Pawn生成的Transform，然后调用SpawnDefaultPawnAtTransform函数在指定的Transform生成Pawn；</p></li><li><p>SpawnDefaultPawnAtTransform函数则是实际调用SpawnActor函数来创建Pawn的最底层函数了，SpawnDefaultPawnAtTransform也是一个蓝图可重写函数；</p><p>至此从GameMode生成到Pawn的生成过程就结束了。</p></li></ul><h3 id="AGameMode与AGameModeBase"><a href="#AGameMode与AGameModeBase" class="headerlink" title="AGameMode与AGameModeBase"></a>AGameMode与AGameModeBase</h3><p>AGameMode继承自AGameModeBase，AGameModeBase提供基础的游戏玩法规则，角色控制链中各种类的注册，游戏进度的暂停与重启，过场动画等，而AGameMode则在AGameModeBase的基础上加上了多人联机匹配的机制，如AGameMode提供了联机时的各种状态(等待加入，等待准备，游戏中等等)，当游戏中的玩家断开连接时，AGameMode提供挂起玩家并存储玩家状态，待玩家重返游戏时恢复的机制。根据<a href="https://docs.unrealengine.com/4.27/zh-CN/InteractiveExperiences/Framework/GameMode/">官方文档</a>中描述AGameMode的产生在AGameModeBase之前，而AGameModeBase是在UE4.14之后才加入的，目的是在AGameMode上面再添加一个层级，以便UE4后续对GameMode的扩展。这些功能都在AGameMode的源码中有所反应，如下面截取的部分源码片段：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">*...</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/** What match state we are currently in */</span><br>UPROPERTY(Transient)<br>FName MatchState;<br><br><span class="hljs-comment">/** Updates the match state and calls the appropriate transition functions */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetMatchState</span><span class="hljs-params">(FName NewState)</span></span>;<br><br><span class="hljs-comment">/** Overridable virtual function to dispatch the appropriate transition functions before GameState and Blueprints get SetMatchState calls. */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnMatchStateSet</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/** Implementable event to respond to match state changes */</span><br>UFUNCTION(BlueprintImplementableEvent, Category=<span class="hljs-string">&quot;Game&quot;</span>, meta=(DisplayName=<span class="hljs-string">&quot;OnSetMatchState&quot;</span>, ScriptName=<span class="hljs-string">&quot;OnSetMatchState&quot;</span>))<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">K2_OnSetMatchState</span><span class="hljs-params">(FName NewState)</span></span>;<br><br><span class="hljs-comment">// Games should override these functions to deal with their game specific logic</span><br><br><span class="hljs-comment">/** Called when the state transitions to WaitingToStart */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HandleMatchIsWaitingToStart</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/** Returns true if ready to Start Match. Games should override this */</span><br>UFUNCTION(BlueprintNativeEvent, Category=<span class="hljs-string">&quot;Game&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ReadyToStartMatch</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/** Called when the state transitions to InProgress */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HandleMatchHasStarted</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/** Returns true if ready to End Match. Games should override this */</span><br>UFUNCTION(BlueprintNativeEvent, Category=<span class="hljs-string">&quot;Game&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ReadyToEndMatch</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/** Called when the map transitions to WaitingPostMatch */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HandleMatchHasEnded</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/** Called when the match transitions to LeavingMap */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HandleLeavingMap</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/** Called when the match transitions to Aborted */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HandleMatchAborted</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">*...</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="4-GameState"><a href="#4-GameState" class="headerlink" title="4.GameState"></a>4.GameState</h2><p>按照官方的说法GameState是用来保存游戏全局数据的，如任务进度，NPC状态等，GameState在服务器产生并会备份一份到所有的客户端，并且GameState对所有客户端可见，与PlayerState相对，PlayerState用于保存客户端自身的状态。GameState有GameMode创建。</p><p>只有服务器上GameState在状态发生改变时才会自行同步备份到所有的客户端，客户端的GameState副本自身不会自行同步GameState的状态到Server，如一个客户端触发了一个NPC的状态，修改了这个客户端中GameState备份的NPC状态，这个GameState备份不会将修改过的状态同步的服务器和其他的客户端，但如果修改状态的逻辑在服务器中执行，修改的GameState时服务器上的GameState，则这个状态的修改会自行同步到所有的客户端，所以对GameState的修改应该在服务器中进行。</p><p>GameState属于GameMode配置的一部分所以会跟随着GameMode的产生而产生，销毁而销毁。</p><h3 id="GameState的创建过程"><a href="#GameState的创建过程" class="headerlink" title="GameState的创建过程"></a>GameState的创建过程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AGameModeBase::PreInitializeComponents</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::PreInitializeComponents();<br><br>FActorSpawnParameters SpawnInfo;<br>SpawnInfo.Instigator = GetInstigator();<br>SpawnInfo.ObjectFlags |= RF_Transient;<span class="hljs-comment">// We never want to save game states or network managers into a map</span><br><br><span class="hljs-comment">// Fallback to default GameState if none was specified.</span><br><span class="hljs-keyword">if</span> (GameStateClass == <span class="hljs-literal">nullptr</span>)<br>&#123;<br>UE_LOG(LogGameMode, Warning, TEXT(<span class="hljs-string">&quot;No GameStateClass was specified in %s (%s)&quot;</span>), *GetName(), *GetClass()-&gt;GetName());<br>GameStateClass = AGameStateBase::StaticClass();<br>&#125;<br><br>UWorld* World = GetWorld();<br>GameState = World-&gt;SpawnActor&lt;AGameStateBase&gt;(GameStateClass, SpawnInfo);<br>World-&gt;SetGameState(GameState);<br><span class="hljs-keyword">if</span> (GameState)<br>&#123;<br>GameState-&gt;AuthorityGameMode = <span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// Only need NetworkManager for servers in net games</span><br>AWorldSettings* WorldSettings = World-&gt;GetWorldSettings();<br>World-&gt;NetworkManager = WorldSettings-&gt;GameNetworkManagerClass ? World-&gt;SpawnActor&lt;AGameNetworkManager&gt;(WorldSettings-&gt;GameNetworkManagerClass, SpawnInfo) : <span class="hljs-literal">nullptr</span>;<br><br>InitGameState();<br>&#125;<br></code></pre></td></tr></table></figure><p>在GameMode构造的时候会初始化GameState的类型为AGameStateBase，GameMode在AGameModeBase::PreInitializeComponents函数中通过SpawnInfo来确定GameMode指定的GameState类型，然后调用SpawnActor创建GameState对象，然后调用InitGameState配置GameState的一些属性。</p><p>在AGameModeBase::InitGameState中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AGameModeBase::InitGameState</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>GameState-&gt;GameModeClass = GetClass();<br>GameState-&gt;ReceivedGameModeClass();<br><br>GameState-&gt;SpectatorClass = SpectatorClass;<br>GameState-&gt;ReceivedSpectatorClass();<br>&#125;<br></code></pre></td></tr></table></figure><p>GameState获取了当前GameMode对象的引用和当前SpectatorPawn的对象，SpectatorPawn是旁观者类。</p><h2 id="5-PlayerState"><a href="#5-PlayerState" class="headerlink" title="5.PlayerState"></a>5.PlayerState</h2><p>和GameState相对PlayerState用于保存玩家数据，和GameState一样PlayerState也首先在Server中生成并同步副本到所的Client中，一个Client的当前Level中会保存所有加入这局游戏的玩家的PlayerState。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127141227.png"></p><p>如，我们有三个玩家加入游戏，那么在运行时Level下就出现了三个PlayerState。</p><p>PlayerSate存在于Controller和Pawn中，Controller保存PlayerState的源对象，Pawn保存PlayerState的引用，即PlayerState的生命周期跟着Controller走，这也比较符合PlayerState的定位，PlayerState保存的是玩家数据而不是角色数据，因为一局游戏中一个玩家可以操控多个角色。</p><p>和GameState一样，PlayerState也在Server中的PlayerSate状态发生变化时会自动同步状态到所有客户端中对应的PlayerState副本，而Client中PlayerState副本状态发生改变时不会自动同步到Server，所以对PlayerState的修改也应该在服务器中进行。</p><h3 id="PlayerState的创建过程"><a href="#PlayerState的创建过程" class="headerlink" title="PlayerState的创建过程"></a>PlayerState的创建过程</h3><ul><li>GameMode在Login函数中调用SpawnPlayerController函数；</li><li>SpawnPlayerController会根据配置情况调用不通的函数来创建PlayerController；</li><li>PlayerController调用PostInitializeComponents函数进行初始化，PostInitializeComponents是APlayerController继承自AActor的函数，在Actor所有组件初始化后初始化自己时调用；</li><li>PostInitializeComponents函数调用InitPlayerState函数创建PlayerState实例，InitPlayerState函数是APlayerController继承自AController的函数；</li><li>InitPlayerState函数通过SpawnInfo确定创建的PlayerState的类型，然后调用SpawnActor创建PlayerState实例。</li></ul><h2 id="6-WorldSettings"><a href="#6-WorldSettings" class="headerlink" title="6.WorldSettings"></a>6.WorldSettings</h2><p>WorldSettings的资料着实是太少太少了，连官方论坛中都很少提及，官方文档也就了了一句话，WorldSettings主要做的就是对游戏世界的一系列配置，如：大地图的动态加载与卸载，世界光照，声音系统，边界检查，导航系统，AI系统，世界重力模拟等等，具体的一些选项功能可以查看<a href="https://blog.csdn.net/jiangdengc/article/details/57421143">Im-JC</a>的博文。</p><p>WorldSettings是蓝图不可见的，如果我们需要动态的获取WorldSettings里的一些配置则需要通过GetActorsWithClass来获取。</p><p>默认WorldSettings是可以更换的，在ProjectSettings/Engine/GeneralSetttings/DefualtClass下</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127141336.png"></p><p>可以看到不仅WorldSettings可以配置，GameViewportClient、LocalPlayer、LevelScriptActor，PhysicsCollisionHandler等都可以自定义配置，UE是真的强大，连关卡蓝图、UI显示，物理碰撞等都给予了我们自定义能力。</p><p>我们在编辑器中打开的WorldSettings视图并不是WorldSettings，而是由WorldSettings提供一个可视化编辑界面。</p><h3 id="WorldSettings的创建过程"><a href="#WorldSettings的创建过程" class="headerlink" title="WorldSettings的创建过程"></a>WorldSettings的创建过程</h3><p>在UE源码中好一阵找，发现WorldSettings的创建有四个地方，分别是</p><p><strong>UEditorLevelUtils::AddLevelToWorld_Internal</strong></p><p><strong>UEditorEngine::CreateTransLevelMoveBuffer</strong></p><p><strong>UWorld::RepairWorldSettings</strong></p><p><strong>UWorld::InitializeNewWorld</strong></p><p>UEditorLevelUtils和UEditorEngine都是和编辑器相关的，不在GamePlay的框架内，这里就不讨论了，我们重点看一下UWorld中的。</p><p>InitializeNewWorld函数是实际创建WorldSettings的地方，而RepairWorldSettings按照源码的解释就是用于确保游戏中切实有一个可用的WorldSettings的功能函数，RepairWorldSettings在UWorld::PostLogin时被调用。</p><ul><li>GameInstance在InitializeStandalone中调用UWorld::CreateWorld函数；</li><li>UWorld::CreateWorld函数调用InitializeNewWorld来创建WorldSettings；</li><li>UWorld::InitializeNewWorld函数就是实际创建WorldSettings的函数，InitializeNewWorld会先读取ProjectSettings中的WorlSettings的配置，如果配置了则创建对应的WorldSettings类实例，否则创建默认的WorldSettings实例。</li></ul><h2 id="7-ALevelScriptActor"><a href="#7-ALevelScriptActor" class="headerlink" title="7.ALevelScriptActor"></a>7.ALevelScriptActor</h2><p>ALevelScriptActor就是我们常说的关卡蓝图，ALevelScriptActor是一个在关卡中的隐藏Actor，在Level列表里是看不到的。</p><h3 id="自定义关卡蓝图"><a href="#自定义关卡蓝图" class="headerlink" title="自定义关卡蓝图"></a>自定义关卡蓝图</h3><p>既然关卡蓝图也是一个Actor那么理论上关卡蓝图也是可以自定义的，经过一番研究UE4还真提供了自定义关卡蓝图的功能。</p><p>ALevelScriptActor不是一个蓝图类，所以我们直接去创建蓝图是找不到一个ALevelScriptActor基类可供继承的，所以我们只能先用C++去创建一个继承自ALevelScriptActor的自定义C++类，然后再修改关卡蓝图的父类为自定义的ALevelScriptActor类。</p><p>这里我创建了一个LSPLevelScriptActor类并重写了BeginPlay函数，在BeginPlay函数里只打印一串字符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Engine/LevelScriptActor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;LSPLevelScriptActor.generated.h&quot;</span></span><br><br>UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LSPTETRISCLIENT_API</span> <span class="hljs-title">ALSPLevelScriptActor</span> :</span> <span class="hljs-keyword">public</span> ALevelScriptActor<br>&#123;<br>GENERATED_BODY()<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//.cpp</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;LSPLevelScriptActor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Engine.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ALSPLevelScriptActor::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    GEngine-&gt;AddOnScreenDebugMessage(<span class="hljs-number">-1</span>, <span class="hljs-number">10</span>, FColor::Red, <span class="hljs-string">&quot;LSPLevelScriptActor::BeginPlay&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然后我们打开想要自定义关卡蓝图的关卡，并打开关卡蓝图，在ClassSettings/ClassOptions/ParentClass设置成为自定义的LSPLevelScriptActor，那么当我们运行BeginPlay事件时，就会在屏幕上打印LSPLevelScriptActor::BeginPlay</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127141439.png"></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127141443.png"></p><h2 id="8-APlayerController"><a href="#8-APlayerController" class="headerlink" title="8.APlayerController"></a>8.APlayerController</h2><p>APlayController与AIController相对，专用于给玩家操作的角色控制器，在AGameMode章节有说过APlayerController是由AGameModeBase::Login函数创建。APlayerController在游戏运行时是不可视的，主要负责接收外部输入，如鼠标键盘、游戏手柄等，并根据输入按一定的逻辑来控制与其绑定的APwan。APlayerController可以通过Possess函数来获取一个APawn的控制权，也可以通过UnPossess函数还放弃一个APawn的控制权。</p><p>在UE4的设计里，APwan和APlayerController都是可以接收外部输入的，如InputAxis事件既可以放在APawn里对APwan进行控制，也可以APlayerController里对指定APawn进行控制，那么二者对外部输入的处理有什么不同呢？事实上，APlayerController在逻辑上的层级要高于APawn的，也就是说外部输入要先进入APlayerController再由APlayerController传递给APawn，这就使得APlayController可以对APawn的输入进行拦截。</p><p>既然APawn和APlayerController都可以接收外部输入，那么对输入逻辑的处理应该放在APawn里还是放在APlayerController里呢？</p><p>个人理解是人应该放在APawn里，为什么呢？因为在一个游戏里，同一个玩家是可以操作多种类型的角色的，如GTA5里面，玩家既可以控制人型角色，也可以开各种车辆，还可以还飞机。各种角色对接收的输入和对输入的处理都是不一样的，如当玩家按下键盘s时，如果APawn是一个人，那么角色应该向后走，如果APawn是一辆车，那么角色应该减速，如果APawn是一个架飞机，那么角色因该下降。这么多中不同的对同一输入的处理不因该由一个APlayerController来出来，而是将之拆分到不同的APawn中处理。</p><h3 id="输入顺序"><a href="#输入顺序" class="headerlink" title="输入顺序"></a>输入顺序</h3><p>UE4里可以接收输入的有4种类，APlayController、APawn、ALevelScriptActor和普通Actor</p><p>Actor只要设置EnableInput或AutoReceiveInput就可以接收输入了</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127141515.png"></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127141519.png"></p><p>UE4的可接收输入对象的输入优先级：</p><p>Actor&gt;APlayerController&gt;ALevelScriptActor&gt;APawn</p><h3 id="输入栈"><a href="#输入栈" class="headerlink" title="输入栈"></a>输入栈</h3><p>UE4对输入的接收有一个输入栈的概念，在游戏一开始时，UE4会对所有的可接收输入的对象进行入栈处理，UE4通过入栈顺序来对可接收输入对象的输入优先级进行分级，先直接上一段源码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">APlayerController::BuildInputStack</span><span class="hljs-params">(TArray&lt;UInputComponent*&gt;&amp; InputStack)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// Controlled pawn gets last dibs on the input stack</span><br>    <span class="hljs-comment">//获取当前控制的APawn</span><br>APawn* ControlledPawn = GetPawnOrSpectator();<br><span class="hljs-keyword">if</span> (ControlledPawn)<br>&#123;<br><span class="hljs-keyword">if</span> (ControlledPawn-&gt;InputEnabled())<br>&#123;<br><span class="hljs-comment">// Get the explicit input component that is created upon Pawn possession. This one gets last dibs.</span><br>            <span class="hljs-comment">//获取APawn的输入组件</span><br><span class="hljs-keyword">if</span> (ControlledPawn-&gt;InputComponent)<br>&#123;<br>                <span class="hljs-comment">//首先将APawn的输入组件入栈</span><br>InputStack.Push(ControlledPawn-&gt;InputComponent);<br>&#125;<br><br><span class="hljs-comment">// See if there is another InputComponent that was added to the Pawn&#x27;s components array (possibly by script).</span><br><span class="hljs-keyword">for</span> (UActorComponent* ActorComponent : ControlledPawn-&gt;GetComponents())<br>&#123;<br>UInputComponent* PawnInputComponent = Cast&lt;UInputComponent&gt;(ActorComponent);<br><span class="hljs-keyword">if</span> (PawnInputComponent &amp;&amp; PawnInputComponent != ControlledPawn-&gt;InputComponent)<br>&#123;<br>InputStack.Push(PawnInputComponent);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// LevelScriptActors are put on the stack next</span><br>    <span class="hljs-comment">//将拥有输入的关卡蓝图入栈</span><br><span class="hljs-keyword">for</span> (ULevel* Level : GetWorld()-&gt;GetLevels())<br>&#123;<br>ALevelScriptActor* ScriptActor = Level-&gt;GetLevelScriptActor();<br><span class="hljs-keyword">if</span> (ScriptActor)<br>&#123;<br><span class="hljs-keyword">if</span> (ScriptActor-&gt;InputEnabled() &amp;&amp; ScriptActor-&gt;InputComponent)<br>&#123;<br>InputStack.Push(ScriptActor-&gt;InputComponent);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//将PlayerController自身入栈</span><br><span class="hljs-keyword">if</span> (InputEnabled())<br>&#123;<br>InputStack.Push(InputComponent);<br>&#125;<br><br><span class="hljs-comment">// Components pushed on to the stack get priority</span><br>    <span class="hljs-comment">//将拥有输入的Actor入栈，CurrentInputStach会保存所有拥有InputComponent组件的Actor的InputComponent组件的引用</span><br><span class="hljs-keyword">for</span> (int32 Idx=<span class="hljs-number">0</span>; Idx&lt;CurrentInputStack.Num(); ++Idx)<br>&#123;<br>UInputComponent* IC = CurrentInputStack[Idx].Get();<br><span class="hljs-keyword">if</span> (IC)<br>&#123;<br>InputStack.Push(IC);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>CurrentInputStack.RemoveAt(Idx--);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了验证输入优先级，我创建了一个具有APawn，APlayerController，具有输入的ALevelScriptActor，具有输入的Actor的关卡。</p><p>我在APawn中加入了前后左右滚动的事件InputAxisMoveForward和InputAxisMoveRight，同时在APlayerController，ALevelScriptActor，Actor中分别都加入一个InputAxisMoveRight，且只进行文字打印操作。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127142056.png"></p><p>先来直接看一下结果</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127142103.gif"></p><p>可以看到字符串的输出顺序为Actor Input-&gt;Controller Input-&gt;ServerMap Input-&gt;APawn Input</p><p>此时键盘输入依旧会一次从栈顶的Actor一直传递到栈底的APawn，但是APawn的InputAxisMoveRight已经被其上层的InputComponent截断，所以APawn只能进行前后移动而无法左右移动。</p><h3 id="输入流程"><a href="#输入流程" class="headerlink" title="输入流程"></a>输入流程</h3><p>先上一张从张悟基大佬哪里盗来的流程图。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127142148.png"></p><ul><li><p>在UE4LaunchEngineLoop.h文件中有一个专门处理引擎循环的类FEngineLoop，UE4在FEngineLoop::Tick()函数中处理每帧获取设备输入，主要处理逻辑。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">FSlateApplication&amp; SlateApp = FSlateApplication::Get();<br>&#123;              QUICK_SCOPE_CYCLE_COUNTER(STAT_FEngineLoop_Tick_PollGameDeviceState);<br>SlateApp.PollGameDeviceState();<br> &#125;<br></code></pre></td></tr></table></figure><p>其中使用了大量的宏，以本小菜的水平当前还看不懂😬，只知道逻辑是在这里处理的。</p></li><li><p>UE4使用FSlateApplication类来将各种各样的硬件输入转化为固定的对应响应事件，如FSlateApplication::OnControllerButtonReleased()函数就是专门处理按键释放的函数，既可以处理手柄按钮释放，也可以处理键盘按键释放。</p><p>在UE4中有一个GenericApplication类是专门做平台处理的接口，在FSlateApplication的基类FSlateApplicationBase中就保存了一个GenericApplication的实例指针。GenericApplication中的函数都是虚函数，GenericApplication类会根据不同平台生成对应的子类的实例，FSlateApplication会根据不同的平台去做不同的输入处理，如在PC平台上就会调用在更底层的输入处理中调用FSlateApplication::OnControllerButtonReleased()函数将键盘释放转化为ProcessKeyUpEvent事件，在PS4平台中同样在更底层的输入处理中调用FSlateApplication::OnControllerButtonReleased()函数将按钮释放转化为ProcessKeyUpEvent事件。</p><p>关于GenericApplication的资料实在找不到，这里纯是个人理解。</p></li><li><p>到这一步，UE4就将各种各种各样的平台输入统一到几个输入处理事件中了，这里以键盘按键释放为例，继续往下走，键盘按键释放操作被映射到ProcessKeyUpEvent事件中，ProcessKeyUpEvent事件主要就做一件事，就是将输入优先传入UMG中，判断UMG中是否有对这个按键操作进行了监听，如果监听了，则将输入传入到UMG中，而输入是否继续传入到World中由UMG决定，如果没有监听则直接将输入传递到World中。</p><p>这里需要注意的是，UMG不能直接对键盘进行监听也不能对AxisInput进行监听，只能监听ActionInput。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208141930.png"></p><p>其中<font color="red">Consume</font>参数就决定了输入是否继续往下传递。</p></li><li><p>如果输入继续往下传递，这时输入会进入到UGameViewportClient中，UGameViewportClient中有对应输入类型的处理函数，通过这些函数将输入传递给PlayerControlelr，Actor、PlayerController、LevelScriptActor、Pawn才能接收到输入，这里输入会按照PlayerController的输入栈来传递输入事件。</p><p><font color="red">这里的资料也是少得可怜，至于输入到底是如何从FSlateApplication传递到UGameViewportClient中的始终未得其解。</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//UGameViewportClient.h</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">InputKey</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FInputKeyEventArgs&amp; EventArgs)</span> <span class="hljs-keyword">override</span></span>;<br>UE_DEPRECATED(<span class="hljs-number">4.21</span>, <span class="hljs-string">&quot;Use the new InputKey(const FInputKeyEventArgs&amp; EventArgs) function.&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">InputKey</span><span class="hljs-params">(FViewport* InViewport, int32 ControllerId, FKey Key, EInputEvent Event, <span class="hljs-keyword">float</span> AmountDepressed = <span class="hljs-number">1.f</span>, <span class="hljs-keyword">bool</span> bGamepad = <span class="hljs-literal">false</span>)</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">final</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">InputAxis</span><span class="hljs-params">(FViewport* Viewport, int32 ControllerId, FKey Key, <span class="hljs-keyword">float</span> Delta, <span class="hljs-keyword">float</span> DeltaTime, int32 NumSamples=<span class="hljs-number">1</span>, <span class="hljs-keyword">bool</span> bGamepad=<span class="hljs-literal">false</span>)</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">InputChar</span><span class="hljs-params">(FViewport* Viewport,int32 ControllerId, TCHAR Character)</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">InputTouch</span><span class="hljs-params">(FViewport* Viewport, int32 ControllerId, uint32 Handle, ETouchType::Type Type, <span class="hljs-keyword">const</span> FVector2D&amp; TouchLocation, <span class="hljs-keyword">float</span> Force, FDateTime DeviceTimestamp, uint32 TouchpadIndex)</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">InputMotion</span><span class="hljs-params">(FViewport* Viewport, int32 ControllerId, <span class="hljs-keyword">const</span> FVector&amp; Tilt, <span class="hljs-keyword">const</span> FVector&amp; RotationRate, <span class="hljs-keyword">const</span> FVector&amp; Gravity, <span class="hljs-keyword">const</span> FVector&amp; Acceleration)</span> <span class="hljs-keyword">override</span></span>;<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>在PlayerController中也有处理UGameViewportClient传入的输入类型的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//APlayerController.h</span><br><span class="hljs-comment">/** Handles a key press */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">InputKey</span><span class="hljs-params">(FKey Key, EInputEvent EventType, <span class="hljs-keyword">float</span> AmountDepressed, <span class="hljs-keyword">bool</span> bGamepad)</span></span>;<br><br><span class="hljs-comment">/** Handles a touch screen action */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">InputTouch</span><span class="hljs-params">(uint32 Handle, ETouchType::Type Type, <span class="hljs-keyword">const</span> FVector2D&amp; TouchLocation, <span class="hljs-keyword">float</span> Force, FDateTime DeviceTimestamp, uint32 TouchpadIndex)</span></span>;<br><br>UE_DEPRECATED(<span class="hljs-number">4.20</span>, <span class="hljs-string">&quot;InputTouch now takes a Force&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">InputTouch</span><span class="hljs-params">(uint32 Handle, ETouchType::Type Type, <span class="hljs-keyword">const</span> FVector2D&amp; TouchLocation, FDateTime DeviceTimestamp, uint32 TouchpadIndex)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> InputTouch(Handle, Type, TouchLocation, <span class="hljs-number">1.0f</span>, DeviceTimestamp, TouchpadIndex);<br>&#125;<br><br><span class="hljs-comment">/** Handles a controller axis input */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">InputAxis</span><span class="hljs-params">(FKey Key, <span class="hljs-keyword">float</span> Delta, <span class="hljs-keyword">float</span> DeltaTime, int32 NumSamples, <span class="hljs-keyword">bool</span> bGamepad)</span></span>;<br><br><span class="hljs-comment">/** Handles motion control */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">InputMotion</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FVector&amp; Tilt, <span class="hljs-keyword">const</span> FVector&amp; RotationRate, <span class="hljs-keyword">const</span> FVector&amp; Gravity, <span class="hljs-keyword">const</span> FVector&amp; Acceleration)</span></span>;<br></code></pre></td></tr></table></figure><p>而Actor、ScriptLeveActor、PlayerController、Pawn则创建各自的InputComponent组件压入PalyerController的输入栈来接收PlayerController的输入，收到输入则去执行绑定的响应函数。</p></li></ul><h3 id="Actor在C-中接收输入"><a href="#Actor在C-中接收输入" class="headerlink" title="Actor在C++中接收输入"></a>Actor在C++中接收输入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AActor_Acom::BindAxis</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    EnableInput(GWorld-&gt;GetFirstPlayerController());<br>    InputComponent-&gt;BindAction(<span class="hljs-string">&quot;ActorInputO&quot;</span>,EInputEvent::IE_Pressed, <span class="hljs-keyword">this</span>, &amp;AActor_Acom::PrintText);<br>&#125;<br></code></pre></td></tr></table></figure><p>和在蓝图中差不多，也需要先Actor接收输入，需要注意的是要获取当前的PlayerController需要使用GWorld，而绑定事件的InputComponent-&gt;BindAction只能绑定ActionInput，且必须是在ProjectSettings/Input中注册过的才行。</p><h2 id="9-APawn"><a href="#9-APawn" class="headerlink" title="9.APawn"></a>9.APawn</h2><p>APawn在整个UPlayer-&gt;APlayerController-&gt;APawn的控制链中主要负责角色的物理表现和与角色相关的输入响应。</p><p>关于APawn好像也没啥可看的，网上关于APawn的资料几乎没有，具体的深入研究等之后在进行吧。</p><h1 id="四、UGameInstance"><a href="#四、UGameInstance" class="headerlink" title="四、UGameInstance"></a>四、UGameInstance</h1><p>GameInstance可以理解为UE虚拟的游戏进程，双击exe游戏开始，GameInstance创建，结束游戏，杀死进程，GameInstance销毁，所以GameInstance的生命周期就是一个游戏的游玩过程。</p><p>GameInstance虽说是单例，但是UE并没有规定一个游戏里只能存在一个GameInstance，只是由UE存储的GameInstance实例只有一个，且必定是ProjectSetting中配置的GameInstance类型。</p><p>GameInstance在各个端之间是互相独立且互不通信的，像Server中的GameInstance和Client中的GameInstance是两个互相独立的实例，且二者没有能力直接通信，因为UE就没有给予GameInstance网络通信的能力。</p><h3 id="哪些逻辑应该写在GameInstance中"><a href="#哪些逻辑应该写在GameInstance中" class="headerlink" title="哪些逻辑应该写在GameInstance中"></a>哪些逻辑应该写在GameInstance中</h3><ul><li><p>保存跨关卡的全局数据</p><p>由于GameState和PlayerState的实例都会随着Level的切换而被销毁，所以一些需要跨关卡存在的数据就需要使用GameInstance来保存了。</p></li><li><p>一些需要全局使用UI</p><p>由于UE的UI是使用Widget来实现的，在使用UI时需要先CreateWidget，然后将widget实例AddToViewport，所以一些需要全局使用的UI如：背包，人物属性等UI的逻辑就可以写在GameInstance中，以避免跳转关卡时重新初始化这些实例。</p></li><li><p>Level切换</p><p>虽然OpenLevel这些关卡切换的实现在UGameEngine中，GameEngine是比GameInstance更高一级的存在，一般而言我们很少使用到GameEngine，除非是针对编辑器的开发，所以将关切切换的逻辑写在GameInstance中更合理。</p></li><li><p>与服务器的连接，TCP，HTTP等逻辑</p><p>因为GameInstance作为一个全局实例，可以很方便的在各个地方获取，这就方便了服务器的重连，和资源下载。</p></li></ul><h3 id="GameInstance的创建过程"><a href="#GameInstance的创建过程" class="headerlink" title="GameInstance的创建过程"></a>GameInstance的创建过程</h3><p>其实在<strong>GameMode的执行过程</strong>中已经有所体现，事实上当我们双击exe运行游戏进程时，第一个创建出来的实例不是GameInstance，而是GameEngine。</p><ul><li><p>游戏进程启动，创建GameEngine；</p></li><li><p>GameEngine调用Init函数，读取ProjectSetting中配置的GameInstance的类型，</p><p>判断是否配置了GameInstance类型，是则创建对应类型的GameInstance实例，否则创建默认的GameInstance实例；</p></li><li><p>调用GameInstance的初始化函数，创建FWorldContext，通过FWorldContext创建UWorld，再通过UWorld，GameInstance就可以创建GameMode了。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UGameEngine::Init</span><span class="hljs-params">(IEngineLoop* InEngineLoop)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//... </span><br><br>    FSoftClassPath GameInstanceClassName = GetDefault&lt;UGameMapsSettings&gt;()-&gt;GameInstanceClass;<br>    UClass* GameInstanceClass = (GameInstanceClassName.IsValid() ? LoadObject&lt;UClass&gt;(<span class="hljs-literal">NULL</span>, *GameInstanceClassName.ToString()) : UGameInstance::StaticClass());<br>    <span class="hljs-keyword">if</span> (GameInstanceClass == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>UE_LOG(LogEngine, Error, TEXT(<span class="hljs-string">&quot;Unable to load GameInstance Class &#x27;%s&#x27;. Falling back to generic UGameInstance.&quot;</span>), *GameInstanceClassName.ToString());<br>GameInstanceClass = UGameInstance::StaticClass();<br>&#125;<br>GameInstance = NewObject&lt;UGameInstance&gt;(<span class="hljs-keyword">this</span>, GameInstanceClass);<br>GameInstance-&gt;InitializeStandalone();<br>    <br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="五、UPlayer"><a href="#五、UPlayer" class="headerlink" title="五、UPlayer"></a>五、UPlayer</h1><p>UPlayer就是UE虚拟出来的玩家，在一个多人游戏中玩家有两类，自己和别人，所以UPlayer也随之派生出两个子类，ULoaclPlayer和UNetConnection，ULocalPlayer就是自己，UNetConnection就是别人。</p><h2 id="UPlayer的绑定"><a href="#UPlayer的绑定" class="headerlink" title="UPlayer的绑定"></a>UPlayer的绑定</h2><ul><li><p>在FSeamlessTravelHandler::Tick()函数中调用了GameMode-&gt;PostSeamlessTravel();</p></li><li><p>PostSeamlessTravel函数主要是创建一个GameSession和调用HandleSeamlessTravelPlayer来为APlayerController设置UPlayer。</p></li><li><p>HandleSeamlessTravelPlayer()函数调用SwapPlayerControllers()函数来为APlayerController设置UPlayer，在SwapPlayerControllers最终使用APlayerController::SetPlayer()函数设置UPlayer。</p></li></ul><h1 id="六、UEngine"><a href="#六、UEngine" class="headerlink" title="六、UEngine"></a>六、UEngine</h1><p>UEngine下有两个主要的子类，UGameEngine和UEditorEngine，UGameEngine是游戏运行时的UEngine实例，UEditorEngine是UE编辑器实例，UEngine在Engine.h中用GEngine全局变量保存。</p><p>UEngine是整个游戏开始的最初是的入口，主要负责做一些顶层类的初始化工作，如初始化负责渲染和输入UGameViewportClient，负责记录World信息的FWorldContext，负责管理音频的FAudioDeviceManager，配置默认的UEngine，负责模块管理的FModuleManager，负责资产管理的UAssetManager，对一些配置文件的加载，如Engine.ini。</p><p>关于UEngine::Init函数，看了一下源码，UE5相较于UE4修改还挺大的。</p><h2 id="自定义引擎类"><a href="#自定义引擎类" class="headerlink" title="自定义引擎类"></a>自定义引擎类</h2><p>UE4的一大好处就是极度自由，UE4除了提供自定义GamePlay框架里的各种类，连自定义引擎类的能力都提供了，由于引擎类有两种UGameEngine和UEditorEngine，所以自定引擎类也分两种，继承自UGameEngine的类只能用于Game模式，继承自UEditorEngine的类只能用于Editor模式，由于UEditorEngine在除了自己魔改UE的情况一般不会修改，所以我们只看UGameEngine就行了。</p><p>首先我们创建一个继承自UGameEngine的ULSPGameEngine类，我们可以在类里面重载基类函数或新增自定义函数来扩展自己的引擎类，我这里就不进行扩展了，然后打开项目目录下的/Config/DefaultEngine.ini文件，在<font color="red">[/Script/Engine.Engine]</font>栏将<font color="red">GameEngine=/Script/Engine.Engine</font>改成自己的引擎类，<font color="red">GameEngine=/Script/LSPTetrisClient.LSPGameEngine</font>，其中LSPTetrisClient是模块名称，LSPGameEngine是自定义引擎类的名称，如果没有这一行就自己加一行进去。怎么看自己的项目模块名称呢？在.uproject文件下，默认模块的名字就是自己项目的模块名称。</p><p>到这一步自定义引擎类就设置完毕了，要然配置文件生效我们要编译一下并重启引擎，让引擎重新去读取DefaultEngine.ini文件。</p><p>那么怎么检测自定义引擎类是否生效了呢？</p><p>这里我在GameInstance里加了一个函数来检测。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ULSPTetrisGameInstance::Print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>UGameEngine* LSPEngine = Cast&lt;ULSPGameEngine&gt;(GEngine);<br><span class="hljs-keyword">if</span> (LSPEngine)<br>&#123;<br>LSPEngine-&gt;AddOnScreenDebugMessage(<span class="hljs-number">-1</span>, <span class="hljs-number">10</span>, FColor::Red, TEXT(<span class="hljs-string">&quot;GEngine is LSPGameEngine&quot;</span>));<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>GEngine-&gt;AddOnScreenDebugMessage(<span class="hljs-number">-1</span>, <span class="hljs-number">10</span>, FColor::Red, TEXT(<span class="hljs-string">&quot;GEngine is GameEngine 1&quot;</span>));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>把这个函数暴露给蓝图，然后在关卡蓝图中调用。先看一下PIE模式下的运行结果：</p><p><img src="https://img-blog.csdnimg.cn/98c6be086a9140659828406e1a41bbf1.png?x-oss-process=type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAR291bGFuZGlz,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"></p><p>可以看到ULSPGameEngine并未生效，这是因为GameEngine只在Game模式下才起作用，UE会根据不同的运行模式来生成不同UEngine，现在我们打个包出来再看下结果：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e0612b1fb9c800069e17fdf2a5e07c5b.png#pic_center"></p><p>可以看到ULSPGameEngine生效了。</p><h1 id="七、UWorld"><a href="#七、UWorld" class="headerlink" title="七、UWorld"></a>七、UWorld</h1><p>UWorld在UE4源码中的描述是这样的</p><ul><li>World 是代表地图或沙箱的顶级对象，Actor 和组件将在其中存在并被渲染。</li><li>一个世界可以是一个单一的持久化关卡，带有一个可选的流媒体关卡列表，这些关卡通过体积和蓝图函数加载和卸载或者它可以是一组按世界构成组织的关卡。</li><li>在独立游戏中，通常只有一个世界存在，除非在目的地和当前世界都存在的无缝区域过渡期间。</li><li>在编辑器中存在许多世界：正在编辑的关卡、每个 PIE 实例、每个具有交互式渲染视口的编辑器工具等等。</li></ul><p>UWorld中存在一个ULevel数组用于保存World下的多个Level。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">...<br><span class="hljs-comment">/** Array of levels currently in this world. Not serialized to disk to avoid hard references. */</span><br>UPROPERTY(Transient)<br>TArray&lt;TObjectPtr&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ULevel</span>&gt;</span>&gt; Levels;<br>...<br></code></pre></td></tr></table></figure><p>UWolrld是一个相当庞大的类，它管理相当大数量的世界配置和世界信息，如：关卡列表、角色控制器列表、相机列表、玩家数量、音频管理器列表、世界时间，玩家控制器的数量、世界重力、世界物理模拟属性等等，也提供着大量的世界基础能力，如：加载或卸载关卡、向永久性关卡中流式添加或卸载关卡，世界的暂停与重置，AI系统的管理，添加和移除Pawn等等。</p><p>一般来说一个游戏只会存在一个UWorld，并且UWorld如同UEngine一样在UWorld.h中也使用一个全局变量GWorld来存储，在一般的Actor中我们可以同过GetWorld()函数来获取GWorld。</p><h2 id="UWorld的创建"><a href="#UWorld的创建" class="headerlink" title="UWorld的创建"></a>UWorld的创建</h2><ul><li><p>首先由UGameInstance::InitializeStandalone函数调用UWorld::CreateWorld函数来创建一个World，同时会将自身的引用传递给UWorld，还会将创建出来UWorld配置给WorldContext；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UGameInstance::InitializeStandalone</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FName InPackageName, UPackage* InWorldPackage)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// Creates the world context. This should be the only WorldContext that ever gets created for this GameInstance.</span><br>WorldContext = &amp;GetEngine()-&gt;CreateNewWorldContext(EWorldType::Game);<br>WorldContext-&gt;OwningGameInstance = <span class="hljs-keyword">this</span>;<br><br><span class="hljs-comment">// In standalone create a dummy world from the beginning to avoid issues of not having a world until LoadMap gets us our real world</span><br>UWorld* DummyWorld = UWorld::CreateWorld(EWorldType::Game, <span class="hljs-literal">false</span>, InPackageName, InWorldPackage);<br>DummyWorld-&gt;SetGameInstance(<span class="hljs-keyword">this</span>);<br>WorldContext-&gt;SetCurrentWorld(DummyWorld);<br><br>Init();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>UWorld::CreateWorld函数则是实际调用NewObject创建UWorld的函数，同时会为新创建出来的World配置一系列参数，并将新的World添加进UEngine中存储，最主要的就是调用UWorld::InitializeNewWorld函数来加载项目设置里配置的默认地图；</p></li><li><p>UWorld::InitializeNewWorld函数会创建PersistentLevel，并将当前UWorld对象设置成PersistentLevel，同时也会对PersistentLevel进行一些列的配置操作，然后调用UWorld::InitWorld函数来初始化世界；</p></li><li><p>UWorld::InitWorld函数就是UWolrd的初始化函数了，InitWorld会根据WorldSetting初始化World，初始化寻路系统、AI系统、物理碰撞，物理重力，Brush系统，为当前世界配置PersistentLevel。</p></li></ul><h1 id="八、ULevel"><a href="#八、ULevel" class="headerlink" title="八、ULevel"></a>八、ULevel</h1><p>ULevel的概念就是关卡，ULevel会保存其所属的UWorld的引用。ULevel的组成与其他的.uasset资源还有点不一样，因为ULevel又其下的所有Actor，ULevel专有LevelScriptActor，同时又有各种光照烘培信息，所以ULevel在UE中使用.umap的格式存储，而我们进行光照烘培后产生的对应的UMapBuildDataRegistry文件则是专门用于存储烘培信息的。</p><h2 id="1-初始Level的创建"><a href="#1-初始Level的创建" class="headerlink" title="1.初始Level的创建"></a>1.初始Level的创建</h2><ul><li>默认地图的加载首先由UEngine::Start函数拉起，UEngine::Start函数只做了一件事，通过UEngine中保存的GameInstance引用调用UGameInstance::StartGameInstance函数；</li><li>UGameInstance::StartGameInstance会去读取默认的地图设置，并获取需要默认加载地图名称，然后将地图名称传递给UEngine::Browse函数；</li><li>UEngine::Browse就是具体调用LoadMap函数加载地图的函数了。</li></ul><h2 id="2-使用蓝图加载umap资源"><a href="#2-使用蓝图加载umap资源" class="headerlink" title="2.使用蓝图加载umap资源"></a>2.使用蓝图加载umap资源</h2><p>蓝图加载关卡有两种反式，一种是OpenLevel一种是LoadLevelInstance，OpenLevel是关闭当前关卡进入指定关卡，而LoadLevelInstance则是将指定关卡作为SubLevel，当前关卡作为PersistentLevel，将SubLevel挂载到PersistentLevel下，二者均可以直接通过关卡的名字加载关卡。</p><h2 id="3-使用C-加载umap资源"><a href="#3-使用C-加载umap资源" class="headerlink" title="3.使用C++加载umap资源"></a>3.使用C++加载umap资源</h2><p>这里我就直接在GameInstance中编写逻辑了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UMyGameInstance::AddStreamingLevel</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">bool</span> loadSucess = <span class="hljs-literal">false</span>;<br>    ULevelStreamingDynamic* ls=ULevelStreamingDynamic::LoadLevelInstance(GetWorld(), FString(<span class="hljs-string">&quot;SubOneMap&quot;</span>), FVector(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), FRotator(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), loadSucess);<br>    GetWorld()-&gt;AddStreamingLevel(ls);<br>    ls-&gt;SetShouldBeLoaded(<span class="hljs-literal">true</span>);<br>    ls-&gt;SetShouldBeVisible(<span class="hljs-literal">true</span>);<br>    GetWorld()-&gt;UpdateLevelStreaming();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-使用LevelStreamingVolume加载关卡"><a href="#4-使用LevelStreamingVolume加载关卡" class="headerlink" title="4.使用LevelStreamingVolume加载关卡"></a>4.使用LevelStreamingVolume加载关卡</h2><p>除了上面两种关卡手动加载的方式，UE还提供使用LevelStreamingVolume触发器来自动触发关卡加载，LevelStreamingVolume类似一个触发器，LevelStreaming会检测进入其中的PlayerController，如果发现有PlayerController进入则自动加载指定的关卡，当检测到触发区域不存在PlayerController了，则自动卸载对应关卡。</p><p>LevelStreamingVolume的关卡加载也是基于PersistentLevel进行的，所有的LevelStreamingVolume都应该存在与PersistentLevel中，需要加载的SubLevel都应该预先挂载到PersistentLevel上，这样我们就可以在Window/Levels/SummonsLevelDetails的LevelDetails面板中在InspectLevel中选择要加载的关卡，我这里叫SubOneMap，然后在LevelStreaming/StreamingVolumes中绑定PersistentLevel中的LevelStreamingVolume，这样一个LevelStreamingVolume就和一个关卡绑定了。这里StreamingVolumes是一个数组，所以</p><p><img src="https://img-blog.csdnimg.cn/ef363f96d6e442739bf68fa84fb601d5.png?x-oss-process=type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAR291bGFuZGlz,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"></p><p>现在我们来部署一个场景试试效果：</p><p>首先在主关卡和子关卡中分别布置如下场景。</p><p><img src="https://img-blog.csdnimg.cn/ef363f96d6e442739bf68fa84fb601d5.png?x-oss-process=type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAR291bGFuZGlz,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"></p><p><img src="https://img-blog.csdnimg.cn/df8febdbd5434a63aaba4aad3e29543a.png?x-oss-process=type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAR291bGFuZGlz,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"></p><p>其中子关卡是可以不需要关照的，因为主关卡中已经存在光照了。</p><p>然后按照上面所说的方式，将子关卡挂载到主关卡下，设置好子关卡在主关卡中的位置，并绑定LevelStreaminVolume。运行来看一下效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20211208141641.gif"></p><h1 id="九、FWorldContext"><a href="#九、FWorldContext" class="headerlink" title="九、FWorldContext"></a>九、FWorldContext</h1><p>根据官方文档的描述，FWorldContext用于处理World的切换，同时也保存着World的信息，在UE中UWorld的切换流程是先销毁当前World然后加载下一个Wolrd，因此前一个World的信息就可以通过FWolrdContext传递到后一个World，FWorldContext有UEngine统一管理，且不对外公开。而对不同的UEngine，FWorldContext的数量是不定的，在GameEngine中FWorldContext是唯一的，而中EditorEngine一定存在一个管理编辑器World的FWorldContext，同时可能存在多个管理PIEWorld的FWorldContext，在UE的逻辑中编辑器也是一个World。</p><p>源码中对于FWorldContext的描述是这样的：</p><ul><li>在引擎级别处理 UWorlds 的上下文。当引擎带来和破坏世界时，我们需要一种方法来保持世界属于什么。</li><li>WorldContexts 可以被认为是一个轨道。默认情况下，我们有 1 个轨道用于加载和卸载关卡。添加第二个上下文就是添加第二个轨道；世界继续生存的另一条轨道。</li><li>对于 GameEngine，将有一个 WorldContext，直到我们决定支持多个同步世界。</li><li>对于 EditorEngine，EditorWorld 可能有一个 WorldContext，PIE World 可能有一个 WorldContext。</li><li>FWorldContext 提供了一种管理“当前 PIE UWorld*”的方法以及连接/旅行到新世界的状态。</li><li>FWorldContext 应该保留在 UEngine 类的内部。外部代码不应保留指针或尝试直接管理 FWorldContext。</li><li>外部代码仍然可以处理 UWorld<em>，并将 UWorld</em>s 传递给引擎级函数。引擎代码可以查找给定 UWorld* 的相关上下文。</li><li>为方便起见，FWorldContext 可以维护指向 UWorld<em>s 的外部指针。例如，PIE 可以将 UWorld</em> UEditorEngine::PlayWorld 与 PIE 世界上下文联系起来。如果 PIE UWorld 发生变化，UEditorEngine::PlayWorld 指针将自动更新。这是通过 AddRef() 和 SetCurrentWorld() 完成的。</li></ul><p>纯机翻，看看就行。</p><h2 id="FWorldContext的创建过程"><a href="#FWorldContext的创建过程" class="headerlink" title="FWorldContext的创建过程"></a>FWorldContext的创建过程</h2><ul><li>在第四节中已经说明过，FWorldContext是由UGameInstance::InitializeStandalone函数调用UEngine::CreateNewWorldContext函数来创建的；</li><li>而UEngine::CreateNewWorldContext函数就是直接new FWorldContext对象的地方，FWorldContext是一个C++结构体，所以UE直接new在了堆上。</li></ul><p>FWorldContext由UE内部管理，对开发者来说是不需要接触的，所以暂时也不需要过深入的了解，只需知道FWorldContext是个什么，干什么的就可以了，以后有时间再去深入了解吧。</p><h1 id="十、USaveGame"><a href="#十、USaveGame" class="headerlink" title="十、USaveGame"></a>十、USaveGame</h1><p>前面已经提到过USaveGame是UE封装好的一个用于持久化保存游戏数据的类，在源码中的描述是这样的：</p><ul><li>此类充当可用于保存游戏状态的保存游戏对象的基类。</li><li>当您创建自己的保存游戏子类时，您将为要保存的信息添加成员变量。</li><li>然后当你想保存游戏时，使用 CreateSaveGameObject 创建这个对象的实例，填写数据，并使用 SaveGameToSlot，提供一个插槽名称。</li><li>要加载游戏，您只需使用 LoadGameFromSlot，然后从结果对象中读取数据。</li></ul><p>而且有意思的是USaveGame是一个空类，贴一下源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">UCLASS(abstract, Blueprintable, BlueprintType)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ENGINE_API</span> <span class="hljs-title">USaveGame</span> :</span> <span class="hljs-keyword">public</span> UObject<br>&#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *@see UGameplayStatics::CreateSaveGameObject</span><br><span class="hljs-comment"> *@see UGameplayStatics::SaveGameToSlot</span><br><span class="hljs-comment"> *@see UGameplayStatics::DoesSaveGameExist</span><br><span class="hljs-comment"> *@see UGameplayStatics::LoadGameFromSlot</span><br><span class="hljs-comment"> *@see UGameplayStatics::DeleteGameInSlot</span><br><span class="hljs-comment"> */</span><br><br>GENERATED_UCLASS_BODY()<br>&#125;;<br></code></pre></td></tr></table></figure><p>这是因为，USaveGame只负责存储游戏数据，即我们可以通过在USaveGame类中创建变量来保存游戏中的数据，将这些游戏数据保存到USaveGame中，然后通过一下方法就可以对USaveGame中的游戏数据进行持久化保存和读取了：</p><ul><li>   UGameplayStatics::CreateSaveGameObject：创建USaveGame类</li><li>   UGameplayStatics::SaveGameToSlot：将USaveGame类序列化保存到磁盘中的.sav文件中</li><li>   UGameplayStatics::DoesSaveGameExist：判断磁盘中默认保存目录下是否存在对应的指定槽位名称的.sav文件</li><li>   UGameplayStatics::LoadGameFromSlot：加载指定槽位名称的.sav文件并返回反序列化后的USaveGame对象</li><li>   UGameplayStatics::DeleteGameInSlot：删除指定槽位名称的.sav文件</li><li>   UGameplayStatics::AsyncSaveGameToSlot：异步地将USaveGame类序列化保存到磁盘中的.sav文件中</li><li>   UGameplayStatics::AsyncLoadGameFromSlot：异步地加载指定槽位名称的.sav文件并返回反序列化后的USaveGame对象</li></ul><p>用法也是非常简单，就没什么好说地了。需要了解的是，我们在编辑器中跑游戏的时候，USaveGame会把.sav文件保存到/项目文件夹/Saved/SaveGame/文件夹下，.sav文件的名字就是保存时的槽位名字，一个.sav文件就是一个存档，当游戏被打包后，.sav文件则存放在/项目目录/Saved/SaveGames/文件夹下</p><h1 id="十一、UActorCompoent"><a href="#十一、UActorCompoent" class="headerlink" title="十一、UActorCompoent"></a>十一、UActorCompoent</h1><p>关于Compoent比较细致一点的文章，网上也是少之又少，只好继续自己撸源码了。</p><p>根据官方文档的说法就是，UE将Actor除基本功能以外的其他功能都拆分成了一个个的UActorComponent了，如负责移动的MovementComponent、负责接收输入的InputComponent、负责物理动画的PhysicalAnimationComponent、负责场景坐标的ScneCompnent、负责模型显示的MeshComponent等等，连是时间线也有一个专门TimeLineComponent负责。</p><p>Compoent对于Actor来说是一种扩展，且Component是能挂载在Actor下，那么一个Component如何挂载到一个Actor下呢？</p><h2 id="1-Compoent挂载"><a href="#1-Compoent挂载" class="headerlink" title="1.Compoent挂载"></a>1.Compoent挂载</h2><h3 id="编辑模式挂载与卸载"><a href="#编辑模式挂载与卸载" class="headerlink" title="编辑模式挂载与卸载"></a>编辑模式挂载与卸载</h3><p>编辑模式直接手动挂载，UE会自动为我们注册组件。卸载直接删除就好。</p><h3 id="蓝图动态挂载与卸载"><a href="#蓝图动态挂载与卸载" class="headerlink" title="蓝图动态挂载与卸载"></a>蓝图动态挂载与卸载</h3><p>蓝图提供<code>Add Component by Class</code>节点来动态的添加组件，同时提供<code>DestroyComponent</code>节点来卸载组件，需要注意的是DestroyComponent节点是一个UActorComponent的一个虚函数。</p><p>已知在4.26中预设了Add Component by Class节点，在4.23中没有。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127144846.png"></p><h3 id="C-动态挂载与卸载"><a href="#C-动态挂载与卸载" class="headerlink" title="C++动态挂载与卸载"></a>C++动态挂载与卸载</h3><p>当我们创建一个C++组件，UE会自动在UClass中添加一个BlueprintSpawnableComponent元数据，这个元数据就是使C++组件可以直接在编辑器里使用，直接在编辑器里添加这个组件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROJECT_API</span> <span class="hljs-title">UAcom_Actor_CPP</span> :</span> <span class="hljs-keyword">public</span> UActorComponent<br>&#123;<br>GENERATED_BODY()<br>&#125;<br></code></pre></td></tr></table></figure><p>C++挂载组件有两种方式，一种是在构造函数中挂载，一种是在运行时挂载，在构造函数中挂载和直接在编辑器中挂载是一样的，都属于编辑时挂载。</p><p><strong>在构造函时挂载</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">AActor_Acom::AActor_Acom()<br>&#123;<br>PrimaryActorTick.bCanEverTick = <span class="hljs-literal">true</span>;<br>    UAcom_Actor_CPP* acom = CreateDefaultSubobject&lt;UAcom_Actor_CPP&gt;(TEXT(<span class="hljs-string">&quot;Acom_Actor_CPP_Contruct&quot;</span>));<br>    AddInstanceComponent(acom);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在运行时挂载</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AActor_Acom::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br>    UAcom_Actor_CPP* acom = NewObject&lt;UAcom_Actor_CPP&gt;(<span class="hljs-keyword">this</span>,TEXT(<span class="hljs-string">&quot;Acom_Actor_CPP_BeginePaly&quot;</span>));<br>    acom-&gt;RegisterComponent();<br>&#125;<br></code></pre></td></tr></table></figure><p>那么二者有什么区别内？</p><p>首先构造时挂载的组件我们在Actor的Details面板中是可以看见组件的，而运行时挂载的组件我们是看不到的，<font color="red">这就意味着构造时挂载的组件我们可以在编辑时和运行时编辑组件的暴露给蓝图的内容，而运行时挂载则对开发者完全不透明。</font></p><p>其次在构造时挂载组件我们需要再手动注册组件，因为CreateDefaultSubobject函数已经对组件进行了注册，需要注意的是CreateDefaultSubobject函数只能在构造函数中使用，在构造函数之外使用会直接导致异常中断，这是因为在CreateDefaultSubobject的源码中直接规定了CreateDefaultSubobject只能在构造函数中使用，否者直接中断。至于AddInstanceComponent函数则是将新创建出来的组件添加到Actor组件列表中，如果不添加进去，尽管Actor也会创建一个新的组件，但是在Actor的Details面板中也看不到组件信息了。而在运行时挂载则需要对组件进行注册，即RegisterComponent，否则Actor只是在堆区创建了一个UObject，却没有把组件添加进World也没有挂载到Actor上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">UObject* <span class="hljs-title">UObject::CreateDefaultSubobject</span><span class="hljs-params">(FName SubobjectFName, UClass* ReturnType, UClass* ClassToCreateByDefault, <span class="hljs-keyword">bool</span> bIsRequired, <span class="hljs-keyword">bool</span> bIsTransient)</span></span><br><span class="hljs-function"></span>&#123;<br>FObjectInitializer* CurrentInitializer = FUObjectThreadContext::Get().TopInitializer();<br>UE_CLOG(!CurrentInitializer, LogObj, Fatal, TEXT(<span class="hljs-string">&quot;No object initializer found during construction.&quot;</span>));<br>UE_CLOG(CurrentInitializer-&gt;Obj != <span class="hljs-keyword">this</span>, LogObj, Fatal, TEXT(<span class="hljs-string">&quot;Using incorrect object initializer.&quot;</span>));<br><span class="hljs-keyword">return</span> CurrentInitializer-&gt;CreateDefaultSubobject(<span class="hljs-keyword">this</span>, SubobjectFName, ReturnType, ClassToCreateByDefault, bIsRequired, bIsTransient);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>卸载组件</strong></p><p>UE提供了UActorComponent::UnregisterComponent函数来取消组件注册，取消注册的同时也会销毁组件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AActor_Acom::Unregister</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    acom-&gt;UnregisterComponent();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-UActorComponent"><a href="#2-UActorComponent" class="headerlink" title="2.UActorComponent"></a>2.UActorComponent</h2><p>由于从UActorComponent派生出来的子类数量相当庞大，所以只重点看几个基类，UActorComponent、USeneComponent、UPrimitiveComponent、UChildActorComponent我们一个个的来看。</p><p>首先我们来看看它们的UML：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127144840.png"></p><p>可以看到UActorComponent是直接继承自UObject的Component的基类，而UE预定义的几个Component类都派生自UActorComponent的子类USeneComponent。</p><p>UActorComponent主要提供一些通用的接口，如ResgisterComponent，UnresgisterComponent，TickComponent，BingePlay，EndPlay，InitializeComponent，UninitializeComponent，SetActive，GetWorld等等。</p><h2 id="3-USceneComponent"><a href="#3-USceneComponent" class="headerlink" title="3.USceneComponent"></a>3.USceneComponent</h2><p>USceneComponent组件为Actor提供在World中Transform功能，包括三维坐标，旋转角和缩放，相对坐标能力。</p><p>并且由于USceneComponent具有相对坐标的能力所以USceneComponent可以进行组件嵌套，同时USceneComponent提供GetChildrenComponent函数来获取嵌套在USceneComponent下的所有组件，同时提供AttachToComponent函数用于去嵌入某个组件下。</p><h3 id="USceneComponent的C-动态动态嵌套"><a href="#USceneComponent的C-动态动态嵌套" class="headerlink" title="USceneComponent的C++动态动态嵌套"></a>USceneComponent的C++动态动态嵌套</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AActor_Acom::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br>    acom = NewObject&lt;UAcom_Scene_CPP&gt;(<span class="hljs-keyword">this</span>, TEXT(<span class="hljs-string">&quot;Acom_Scene_CPP_BeginePaly&quot;</span>));<br>    acom-&gt;RegisterComponent();<br>    UAcom_Scene_CPP* acomChild = NewObject&lt;UAcom_Scene_CPP&gt;(<span class="hljs-keyword">this</span>, TEXT(<span class="hljs-string">&quot;Acom_Scene_CPP_Child&quot;</span>));<br>    acomChild-&gt;RegisterComponent();<br>    acomChild-&gt;AttachToComponent(acom,FAttachmentTransformRules::SnapToTargetIncludingScale,FName(<span class="hljs-string">&quot;Acom_Scene_CPP_Child_1&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>UE提供了AttachToComponent方法来见过一个USceneComponent嵌套进另一个USceneComponent中。<font color="red">需要注意的是，AttachToCpmponent函数无法再构造函数中使用，否则直接编译不过。</font></p><p>事实上UE提供了AttachTo和AttachToComponent两个函数来进行USceneComponent的嵌套，AttachTo时已经过时的方法，在源码的标注的是4.12的时候就已经弃用了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">UE_DEPRECATED(<span class="hljs-number">4.12</span>, <span class="hljs-string">&quot;This function is deprecated, please use AttachToComponent instead.&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">USceneComponent::AttachTo</span><span class="hljs-params">(class USceneComponent* Parent, FName InSocketName, EAttachLocation::Type AttachType = EAttachLocation::KeepRelativeOffset , <span class="hljs-keyword">bool</span> bWeldSimulatedBodies = <span class="hljs-literal">false</span>)</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">USceneComponent::AttachToComponent</span><span class="hljs-params">(USceneComponent* Parent, <span class="hljs-keyword">const</span> FAttachmentTransformRules&amp; AttachmentRules, FName SocketName)</span></span><br></code></pre></td></tr></table></figure><p>而AttachToComponent中新增了一个必须输入的参数—FAttachmentTransformRules，这是一个结构体，总共有四个对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/** Rules for attaching components */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ENGINE_API</span> <span class="hljs-title">FAttachmentTransformRules</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-comment">/** Various preset attachment rules. Note that these default rules do NOT by default weld simulated bodies */</span><br><span class="hljs-keyword">static</span> FAttachmentTransformRules KeepRelativeTransform;<br><span class="hljs-keyword">static</span> FAttachmentTransformRules KeepWorldTransform;<br><span class="hljs-keyword">static</span> FAttachmentTransformRules SnapToTargetNotIncludingScale;<br><span class="hljs-keyword">static</span> FAttachmentTransformRules SnapToTargetIncludingScale;<br><br>FAttachmentTransformRules(EAttachmentRule InRule, <span class="hljs-keyword">bool</span> bInWeldSimulatedBodies)<br>: LocationRule(InRule)<br>, RotationRule(InRule)<br>, ScaleRule(InRule)<br>, bWeldSimulatedBodies(bInWeldSimulatedBodies)<br>&#123;&#125;<br><br>FAttachmentTransformRules(EAttachmentRule InLocationRule, EAttachmentRule InRotationRule, EAttachmentRule InScaleRule, <span class="hljs-keyword">bool</span> bInWeldSimulatedBodies)<br>: LocationRule(InLocationRule)<br>, RotationRule(InRotationRule)<br>, ScaleRule(InScaleRule)<br>, bWeldSimulatedBodies(bInWeldSimulatedBodies)<br>&#123;&#125;<br><br><span class="hljs-comment">/** The rule to apply to location when attaching */</span><br>EAttachmentRule LocationRule;<br><br><span class="hljs-comment">/** The rule to apply to rotation when attaching */</span><br>EAttachmentRule RotationRule;<br><br><span class="hljs-comment">/** The rule to apply to scale when attaching */</span><br>EAttachmentRule ScaleRule;<br><br><span class="hljs-comment">/** Whether to weld simulated bodies together when attaching */</span><br><span class="hljs-keyword">bool</span> bWeldSimulatedBodies;<br>&#125;;<br></code></pre></td></tr></table></figure><p>FAttachmentTransformRules参数描述了子组件嵌入父组件是的坐标与缩放规则：</p><ul><li>KeepRelativeTransform：嵌入的子组件使用其父组件的相对坐标；</li><li>KeepWorldTransform：嵌入的子组件保持自己的世界坐标；</li><li>SnapToTargetNotIncludeingScale：使用(0,0,0)的相对坐标并重置Scaleda到(1,1,1)；</li><li>SnapToTargetIncludeingScale：使用(0,0,0)的相对坐标但不重置Scale到(1,1,1)；</li></ul><h3 id="USceneComponent的蓝图动态嵌套"><a href="#USceneComponent的蓝图动态嵌套" class="headerlink" title="USceneComponent的蓝图动态嵌套"></a>USceneComponent的蓝图动态嵌套</h3><p>UE蓝图提供了两个接口来嵌套USceneComponent，AttachActorToComponent和Attach ComponentToComponent。</p><p>AttachActorToComponent是直接将子USceneComponent嵌套到Actor的RootComponent下；</p><p>Attach ComponentToComponent则是将子USceneComponent嵌套到指定的USceneComponent下。</p><h2 id="4-UPrimitiveComponent"><a href="#4-UPrimitiveComponent" class="headerlink" title="4.UPrimitiveComponent"></a>4.UPrimitiveComponent</h2><p>UPrimitiveComponent是一系列可视组件的基类，如碰撞体相关的ShepeComponent、BoxComponent等，与渲染相关的StaticMeshComponent、ModelComponent等，工具相关的ArrowComponent、SplineComponent等，与场景相关的BrushComponent、LandscapeComponent等。</p><p>UPrimitiveComponent直接继承自USceneComponent所以也拥有坐标相关的能力，在此之上UPrimitiveComponent还提供了物理碰撞和渲染相关的能力，按照源码注释的说法就是：</p><ul><li>PrimitiveComponents 是包含或生成某种几何体的场景组件，通常用于渲染或用作碰撞数据。</li><li>对于各种类型的几何体，有几个子类，但目前最常见的ShapeComponents（Capsule、Sphere、Box）、StaticMeshComponent 和 SkeletalMeshComponent。</li><li>ShapeComponents 生成用于碰撞检测但不渲染的几何体，而 StaticMeshComponents 和 SkeletalMeshComponents 包含渲染的预构建几何体，但也可用于碰撞检测。</li></ul><p><font color="red">值得注意的是，UPrimitiveComponent默认是不开启Tick的，所以我们如果想要TickComponent函数就需要在构造函数中手动打开<code>PrimaryComponentTick.bCanEverTick = true;</code></font></p><p>UPrimitiveComponent的基本能力已经不在GamePlay范畴，这里就不继续深入了，以后有时间再深入了解。</p><h2 id="5-UChildActorComponent"><a href="#5-UChildActorComponent" class="headerlink" title="5.UChildActorComponent"></a>5.UChildActorComponent</h2><p>UChildActorComponent是专门用于Actor嵌套子Actor功能的组件，UChildActorComponent在注册时和其他组件有些不同，因为UChildActorComponent会在注册时自动创建一个Actor，在销毁时也会将Actor一并销毁，所以如果我们在组件注册时未设定UChildActorComponent绑定的Actor类型，UChildActorComponent会创建默认的AActor，只有绑定了Actor类型才会去创建指定类型的Actor。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UChildActorComponent::CreateChildActor</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>AActor* MyOwner = GetOwner();<br><span class="hljs-keyword">if</span> (MyOwner &amp;&amp; !MyOwner-&gt;HasAuthority())<br>&#123;<br>AActor* ChildClassCDO = (ChildActorClass ? ChildActorClass-&gt;GetDefaultObject&lt;AActor&gt;() : <span class="hljs-literal">nullptr</span>);<br><span class="hljs-comment">//...</span><br>    &#125;<br>DestroyChildActor();<br><span class="hljs-keyword">if</span>(ChildActorClass != <span class="hljs-literal">nullptr</span>)<br>&#123;<br><span class="hljs-comment">//...</span><br>ChildActor = World-&gt;SpawnActor(ChildActorClass, &amp;Location, &amp;Rotation, Params);<br><span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在运行时创建"><a href="#在运行时创建" class="headerlink" title="在运行时创建"></a>在运行时创建</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AActor_Acom::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br>    acom = NewObject&lt;UAcom_Child_CPP&gt;(<span class="hljs-keyword">this</span>, TEXT(<span class="hljs-string">&quot;Acom_Child_CPP_BeginePlay&quot;</span>));   <br>    TSubclassOf&lt;ACubeActor&gt; cube = ACubeActor::StaticClass();<br>    acom-&gt;SetChildActorClass(cube);<br>    acom-&gt;RegisterComponent();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在构造时创建"><a href="#在构造时创建" class="headerlink" title="在构造时创建"></a>在构造时创建</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">AActor_Acom::AActor_Acom()<br>&#123;<br>PrimaryActorTick.bCanEverTick = <span class="hljs-literal">true</span>;<br>    acom = CreateDefaultSubobject&lt;UAcom_Child_CPP&gt;(TEXT(<span class="hljs-string">&quot;Acom_Child_CPP_Contruct&quot;</span>));  <br>    TSubclassOf&lt;ACubeActor&gt; cube = ACubeActor::StaticClass();<br>    acom-&gt;SetChildActorClass(cube);<br>    AddInstanceComponent(acom); <br>&#125;<br></code></pre></td></tr></table></figure><p>和PtimitiveComponent一样UChildActorComponent也默认不开启Tick。</p><h1 id="十三、总结"><a href="#十三、总结" class="headerlink" title="十三、总结"></a>十三、总结</h1><p>最后来总结一下整个GamePlay的初始化流程，这张图是基于UE4.26来制作的，所以与前面的UE5源码的流程可能会有点出入：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20220127144919.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Git】Git操作手册</title>
    <link href="/2021/08/11/%E3%80%90Git%E3%80%91Git%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/"/>
    <url>/2021/08/11/%E3%80%90Git%E3%80%91Git%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><a id="more"></a><h2 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">&lt;仓库地址&gt;</span><br></code></pre></td></tr></table></figure><h2 id="查看当前分支"><a href="#查看当前分支" class="headerlink" title="查看当前分支"></a>查看当前分支</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git branch</span><br></code></pre></td></tr></table></figure><h2 id="查看所有分支"><a href="#查看所有分支" class="headerlink" title="查看所有分支"></a>查看所有分支</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git branch -a</span><br></code></pre></td></tr></table></figure><h2 id="切换本地分支"><a href="#切换本地分支" class="headerlink" title="切换本地分支"></a>切换本地分支</h2><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">git checkout <span class="hljs-attribute">&lt;本地分支名&gt;</span><br></code></pre></td></tr></table></figure><h2 id="下载远程分支到本地分支"><a href="#下载远程分支到本地分支" class="headerlink" title="下载远程分支到本地分支"></a>下载远程分支到本地分支</h2><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">git checkout -b <span class="hljs-attribute">&lt;本地分支名&gt;</span> <span class="hljs-attribute">&lt;远程分支名&gt;</span><br></code></pre></td></tr></table></figure><p>远程分支名一般为<code>origin/远程仓库名</code></p><h2 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h2><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">git branch -D <span class="hljs-attribute">&lt;本地分支名&gt;</span><br></code></pre></td></tr></table></figure><h2 id="新建本地分支"><a href="#新建本地分支" class="headerlink" title="新建本地分支"></a>新建本地分支</h2><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">git branch <span class="hljs-attribute">&lt;新分支名&gt;</span><br></code></pre></td></tr></table></figure><h2 id="提交本地分支到仓库"><a href="#提交本地分支到仓库" class="headerlink" title="提交本地分支到仓库"></a>提交本地分支到仓库</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> &lt;分支名&gt;<br></code></pre></td></tr></table></figure><h2 id="查看本地仓库修改状态"><a href="#查看本地仓库修改状态" class="headerlink" title="查看本地仓库修改状态"></a>查看本地仓库修改状态</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git status</span><br></code></pre></td></tr></table></figure><h2 id="清除本地所有修改-未add"><a href="#清除本地所有修改-未add" class="headerlink" title="清除本地所有修改(未add)"></a>清除本地所有修改(未add)</h2><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">git clean -df .<br></code></pre></td></tr></table></figure><h2 id="查看提交日志"><a href="#查看提交日志" class="headerlink" title="查看提交日志"></a>查看提交日志</h2><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">git <span class="hljs-keyword">log</span> <span class="hljs-variable">&lt;文件路径&gt;</span><br></code></pre></td></tr></table></figure><p>加文件路径则查看指定文件的提交日志，不加则查看所有的提交日志</p><h2 id="查看所有文件的修改"><a href="#查看所有文件的修改" class="headerlink" title="查看所有文件的修改"></a>查看所有文件的修改</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git diff</span><br></code></pre></td></tr></table></figure><h2 id="查看指定文件的修改"><a href="#查看指定文件的修改" class="headerlink" title="查看指定文件的修改"></a>查看指定文件的修改</h2><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">git diff <span class="hljs-attribute">&lt;文件路径&gt;</span><br></code></pre></td></tr></table></figure><h2 id="还原所有文件的修改"><a href="#还原所有文件的修改" class="headerlink" title="还原所有文件的修改"></a>还原所有文件的修改</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git checkout</span><br></code></pre></td></tr></table></figure><h2 id="还原指定文件的修改"><a href="#还原指定文件的修改" class="headerlink" title="还原指定文件的修改"></a>还原指定文件的修改</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git checkout &lt;文件路径&gt;<span class="hljs-regexp">//</span>多个文件之间用空格隔开<br></code></pre></td></tr></table></figure><h2 id="Add指定文件"><a href="#Add指定文件" class="headerlink" title="Add指定文件"></a>Add指定文件</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">git <span class="hljs-keyword">add</span><span class="bash"> &lt;文件路径&gt;</span><br></code></pre></td></tr></table></figure><p>多文件用空格隔开</p><h2 id="回退Add的操作"><a href="#回退Add的操作" class="headerlink" title="回退Add的操作"></a>回退Add的操作</h2><p>有时我们会直接<code>git add .</code>可能会将我们不想往上传的文件给add了，此时可以使用</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">git reset <span class="hljs-attribute">&lt;文件路径&gt;</span><br></code></pre></td></tr></table></figure><p>单独的git reset是回退所有add操作，git reset &lt;文件路径&gt;可以指定回退某一个文件，多文件用空格隔开。</p><h2 id="撤销Commit"><a href="#撤销Commit" class="headerlink" title="撤销Commit"></a>撤销Commit</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard HEAD^</span><br></code></pre></td></tr></table></figure><p>HEAD指向当前节点的指针，HEAD^指向前一个结点的指针</p><h2 id="查看Commit提交"><a href="#查看Commit提交" class="headerlink" title="查看Commit提交"></a>查看Commit提交</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">git <span class="hljs-keyword">show</span><br></code></pre></td></tr></table></figure><h2 id="添加Fork仓库"><a href="#添加Fork仓库" class="headerlink" title="添加Fork仓库"></a>添加Fork仓库</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">git <span class="hljs-keyword">add</span><span class="bash"> upstrem &lt;Fork仓库路径&gt;</span><br></code></pre></td></tr></table></figure><h2 id="同步Fork仓库到本地"><a href="#同步Fork仓库到本地" class="headerlink" title="同步Fork仓库到本地"></a>同步Fork仓库到本地</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git pull upstream</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作手册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE5】UE5 Dedicated Server专用服务器与网络同步</title>
    <link href="/2021/08/11/%E3%80%90UE5%E3%80%91UE5%20Dedicated%20Server%E4%B8%93%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5/"/>
    <url>/2021/08/11/%E3%80%90UE5%E3%80%91UE5%20Dedicated%20Server%E4%B8%93%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>这篇文章是个人在学习UE4的网络同步方面的内容的一些记录，因为UE5出来了，顺带也一起熟悉熟悉UE5，所以也就直接使用UE5来实践了。说句实在话，UE4网络同步这块确实挺难的，我自己在网上搜索的博客的内容要么停留在很浅层面只搭建一个ds服务器，要么就直接深入源码去剖析UE4的网络机制，处在中间层面的内容少之又少，不得不自己好一阵研究，强烈推荐这几位博主的博文，我在学习的过程中也从中受益匪浅。</p><p> <a href="https://www.cnblogs.com/AnKen/p/7897076.html">Ken_An</a>、<a href="https://blog.ch-wind.com/ue4-multiplayer-and-network-overview/">风蚀之月</a>、 <a href="https://blog.csdn.net/weixin_37864449/article/details/89096536">刘东无敌</a>还有我师傅推荐给我的一本<a href="https://cedric-neukirchen.net/Downloads/Compendium/UE4_Network_Compendium_by_Cedric_eXi_Neukirchen.pdf">关于UE4网络的PDF</a>。</p><a id="more"></a><hr><h1 id="一、什么是Dedicated-Server"><a href="#一、什么是Dedicated-Server" class="headerlink" title="一、什么是Dedicated Server"></a>一、什么是Dedicated Server</h1><p>UE5除了<strong>Nanite</strong>和<strong>Lumen</strong>两个比较大的技术改动之外，其他的部分实际上和UE4基本是一致的，所以虽说使用的是UE5来搭建Dedicated Server，实际操作和UE4没什么区别。</p><p>事实上UE5有提供两种服务器Dedicated Server和Listen Server，Dedicated Server是专用服务器，服务器和客户端是剥离开来的，而Listen Server则是类似局域网联机一般的，使用其中某一个客户端作为服务器的模式。</p><p>这里就谈到游戏网络同步的方式了，游戏网络同步的方式一般分为两种方式，P2P和C/S，P2P即每一台客户端之间互相直连，这种方式的同步极为复杂，对联机游戏来说基本已经淘汰了。C/S即经典的客户端/服务器模式，C/S又可细分为两种，一种是由一个客户端做主机，其他的客户端连接这个主机来进行网络同步，主机即拥有服务器功能也拥有客户端功能，这种模式多用于局域网联机，这种模式中每一个客户端都可以成为主机；一种是单独剥离服务器的功能，服务端只处理服务器相关的业务，所有的客户端都通过连接服务器来进行网络同步，同时客户端只留下客户端相关的业务，这就是网游中最常用的模式了。</p><p>首先我们需要明确一个认知—UE5的客户端代码和服务器代码是一体的，即两端的代码实际上是混杂在一起的。我们经常听到一种说法叫“前后端分离”，就是服务器干服务器的，客户端干客户端的，二者各为两个工程互不干扰，互相之间通过TCP或者UDP进行通信。而UE5的模式则是客户端和服务器不分离，同在一个工程之中，互相之间的代码使用宏来区分。两种方式各有各的好处。</p><p>我们这里要学习的ds服务器就是从这个一体的工程中单独剥离出来的一个服务器，为什么要剥离呢？如果不剥离，网络同步就变成了C/S模式的第一种情况了，但是大多数情况下服务器是不需要场景渲染，人物控制这些客户端业务的，剥离出来可以减轻服务器的运行压力。</p><p>Dedicated Server服务器简称ds服务器，是UE5用于解决FPS同步问题的一种专用服务器，UE5在UDP上自己做了一层根据游戏特点专门优化的网络协议(epic不愧是fps起家的😂)，专门用于ds通信，ds服务器的一大特点就是客户端和服务器共享一份代码，因为高性能的同步需要各种客户端预测和回溯的方法，可以很好的解决同步延迟问题。但是UE5ds服务器承载量不高，不适合用于需要连接大量客户端的场景。</p><hr><h1 id="二、搭建DS服务器"><a href="#二、搭建DS服务器" class="headerlink" title="二、搭建DS服务器"></a>二、搭建DS服务器</h1><p>暂时我们先搭一个最简单的，只有客户端连接功能的ds服务器，后面我们再慢慢迭代的往里面加功能。</p><h2 id="1-使用源码编译UE5引擎"><a href="#1-使用源码编译UE5引擎" class="headerlink" title="1.使用源码编译UE5引擎"></a>1.使用源码编译UE5引擎</h2><h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><p><a href="https://github.com/EpicGames/UnrealEngine/releases/tag/5.0.0-early-access-1">直接zip下载</a></p><p><a href="https://github.com/EpicGames/UnrealEngine">git克隆</a></p><p>git clone记得要切换分支到ue5-early-access这是抢先体验版的源码。</p><h3 id="下载依赖项"><a href="#下载依赖项" class="headerlink" title="下载依赖项"></a>下载依赖项</h3><p>运行Setup.bat，要下载挺多东西的，得等一段时间。</p><h3 id="生成VS工程文件"><a href="#生成VS工程文件" class="headerlink" title="生成VS工程文件"></a>生成VS工程文件</h3><p>运行GenerateProjectFiles.bat生成VS工程文件</p><p>需要注意的是，UE5只支持VS2019，所以编译源码之前得先把VS2019安装好。</p><p>这时有可能会报路径过长的错误，只需要把引擎剪贴到盘符根目录去就行了。</p><p>跑完之后工程目录下就会出现一个UE5.sln文件，使用VS2019打开即可编译了。</p><h2 id="2-为什么需要使用源码编译的UE5"><a href="#2-为什么需要使用源码编译的UE5" class="headerlink" title="2.为什么需要使用源码编译的UE5"></a>2.为什么需要使用源码编译的UE5</h2><p>因为我们编译ds服务器需要使用<code>Development Server</code>模式编译，而使用epic启动器下载的UE5创建的工程没有这个模式，只有自己使用源码编译的UE5创建的工程才有这个模式</p><h2 id="3-编译DS服务器"><a href="#3-编译DS服务器" class="headerlink" title="3.编译DS服务器"></a>3.编译DS服务器</h2><p>如果用UE5创建C++工程报.net版本过低，就去VS把对应的.net版本下下来即可。</p><p>我们需要分别为Server端，Client端和过渡时分别创建一个默认地图，所以我们创建三个地图</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210802213953.png"></p><p>然后再Project Setting/Map&amp;Mod中分别如下配置</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809225937.png"></p><p>在关卡蓝图的tick事件上分别编写一些字符串打印，以便后面观察地图的切换。</p><p>我这里直接打印了地图名字：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210802213959.png"></p><p>顺带提一句，如果创建工程时不是创建的C++工程，而是空工程或者纯蓝图工程则需要随便创建一个C++类来打开VS工程。</p><p>据说如果不创建一个C++类就直接去编译ds可能编译不过，我这里是直接创建了一个GameInstance再编译的，所以也就没有碰到这个问题，想想UE5应该把这个bug解决了吧，如果碰到了这个问题就去创建一个类再编译吧。</p><p>在VS里把编译模式更换成Development Server，然后手动添加一个xx.Target.cs文件，目前内容比较简单，我们只需要拷贝一份UE5自动生成xxEditor.Target.cs文件更名为xxServer.Target.cs，然后把里面的Editor字样都换成Server就可以了。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnrealBuildTool;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LSPTetrisClientServerTarget</span> : <span class="hljs-title">TargetRules</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LSPTetrisClientServerTarget</span>(<span class="hljs-params"> TargetInfo Target</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">Target</span>)</span><br><span class="hljs-function"></span>&#123;<br>Type = TargetType.Editor;<br>DefaultBuildSettings = BuildSettingsVersion.V2;<br>ExtraModuleNames.AddRange( <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123; <span class="hljs-string">&quot;LSPTetrisClient&quot;</span> &#125; );<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们手动将文件添加到工程里。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210802214005.png"></p><p>最后编译，编译事件比较长，需要耐心等待一下，编译完之后我们就可以在工程目录<code>Binaries\Win64</code>下看到编译出来的exe文件了。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809225931.png"></p><p>如果编译出来没有的话，就重新选择一下<code>Switch Unreal Engine version</code>，然后再编译。</p><p>此时的exe还是不能运行的，因为它需要依赖一些客户端的代码，所以需要等客户端打包出来之后，放到客户端的文件夹下运行。</p><h2 id="4-打包客户端"><a href="#4-打包客户端" class="headerlink" title="4.打包客户端"></a>4.打包客户端</h2><p>把VS编译模式更改成Development Editor，可以直接从vs启动引擎，也可以通过uproject启动引擎，然后打包工程，顺带一提，UE5把打包选项更换到了这个位置</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210802214045.png"></p><p>到这一步就可以把之前编译出来的ds服务器的exe拷贝到打包出来的客户端目录里了<code>..\Binaries\Windows\LSPTetrisClient\Binaries\Win64</code>。</p><p>直接双击启动ds服务器，服务器是没有界面的，会直接在后台运行，如果想要关闭，就得去任务管理器关闭了，想要有界面有两种方式启动，其一，通过cmd启动，给exe传入log参数</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">start</span> LSPTetrisClientServer.exe -<span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p>如果没有进入xxServer.exe所在文件夹记得使用绝对路径；</p><p>其二，为xxServer.exe创建快捷方式，在右键/属性/快捷方式/目标，后面加-log，需要用空格隔开，通过快捷方式启动。</p><h2 id="5-客户端连接ds服务器"><a href="#5-客户端连接ds服务器" class="headerlink" title="5.客户端连接ds服务器"></a>5.客户端连接ds服务器</h2><p>启动ds服务器，再启动客户端，这里我在局域网里用两台电脑测试，做服务器的主机ip为10.14.32.50，做客户端的主机ip为10.14.99.156。</p><p>将打出来的包拷贝到另一台电脑里，如果直接运行<code>Windows\LSPTetrisClient\Binaries\Win64</code>下的客户端exe，提示缺少dll无法运行的话，UE5还在包的根目录贴心的准备了一个安装运行环境的exe，双击把环境安装好就可以运行了。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210802214056.png"></p><p><strong>测试结果：</strong></p><p>启动ds服务器时，可以看到服务器加载了默认的ServerMap</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210802214103.png"></p><p>然后我们再另一台电脑上启动客户端，此时客户端加载了在项目中配置的默认地图</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210802214112.png"></p><p>由于我们没有在地图中加任何Actor，所以地图是一片黑，后面我们再往里面加东西，我们也没有写连接ds的逻辑，所以这里我们使用控制台来连接ds，在客户端窗口按下<code>~</code>这个键，输入</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">open</span> <span class="hljs-number">10.14</span><span class="hljs-number">.32</span><span class="hljs-number">.50</span><span class="hljs-comment">//这是我的运行ds服务器主机的IP</span><br></code></pre></td></tr></table></figure><p>然后我们就可以看到客户端同步到服务器的地图了</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210802214120.png"></p><p>并且在ds服务器中也能看到有客户端连接进来</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210802214127.png"></p><h2 id="6-实现人物同步"><a href="#6-实现人物同步" class="headerlink" title="6.实现人物同步"></a>6.实现人物同步</h2><p>现在我们开始迭代下一个版本，最基础的人物控制的同步。首先向工程中添加第三人称模板进来。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210802214134.png"></p><p>这时可能会添加不了或者添加进去了有一些东西找不到，这是因为我们在编译引擎时只编译了引擎没有编译Programs下面那一堆的东西，直接再编译一次整个解决方案就好了。</p><h3 id="向场景中添加内容"><a href="#向场景中添加内容" class="headerlink" title="向场景中添加内容"></a>向场景中添加内容</h3><p>现在我们的场景还是一片黑，因为我们的场景里面啥都没有，打开预设面板</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210802214141.png"></p><p>搜索<code>BP_Sky_Sphere</code>和<code>DirectionalLight</code>，将天空球和平行光添加到场景里，现在场景就变成了我们熟悉的界面了。分别把ClientMap和ServerMap都布置好，TransitionMap就不需要了，ServerMap里面还需要添加一个Plane以便人物生成之后有地方站立，和一个PlayerStart控制人物的生成位置。</p><h3 id="编写连接ds服务器的逻辑"><a href="#编写连接ds服务器的逻辑" class="headerlink" title="编写连接ds服务器的逻辑"></a>编写连接ds服务器的逻辑</h3><p>然后我们在GameInstance里面编写连接ds服务器的逻辑，逻辑也很简单，直接调用一个内置api就好了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ULSPTetrisGameInstance::ConnectDs</span><span class="hljs-params">(FString ip)</span></span><br><span class="hljs-function"></span>&#123;<br>GetWorld()-&gt;GetFirstPlayerController()-&gt;ClientTravel(ip, TRAVEL_Absolute); <br>&#125;<br></code></pre></td></tr></table></figure><p>ClientTravel是PlayerController里的一个函数，所以需要先通过World获取PlayerController来调用。</p><p>ClientTravel有四种连接模式，我们这里使用绝对网址即IP，其他的模式可以直接去<a href="https://docs.unrealengine.com/4.26/en-US/API/Runtime/Engine/Engine/ETravelType/">官方文档</a>了解。</p><p>然后我们再创建一个UMG来输入IP地址并可以点击登录。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210802214151.png"></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210802214200.png"></p><p>SetFullscreenMode设置游戏以窗口模式运行。</p><p>然后UMG的创建就直接放在ClientMap的关卡蓝图里了。</p><p>然后我们再重新编译一个ds服务器和客户端，如果没有更改服务器相关的代码是不需要重新编译ds服务器的，这里保险起见我还是都重新编了一个。</p><h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210804155737.gif"></p><p>机器有点不行，跑起来卡卡的。</p><hr><h1 id="三、Actor同步"><a href="#三、Actor同步" class="headerlink" title="三、Actor同步"></a>三、Actor同步</h1><h2 id="1-普通Actor的网络同步"><a href="#1-普通Actor的网络同步" class="headerlink" title="1.普通Actor的网络同步"></a>1.普通Actor的网络同步</h2><p>使用第三人称模板之所以这么容易就把人物同步给实现了，是因为里面很多设置模板都已经给我们设置好了，那么现在我们继续迭代，实现我们自定义的Actor的网络同步。</p><p>比如我们按下E键在角色前方创建一个物理方块，如何将这个物理方块从创建到掉落的整个过程在所有客户端同步？</p><p>首先我们为方块创建一个出生点，我在人物下面添加一个Sphere组件，去除Sphere的staticmesh使它不显示，然后将相对位置移动到人物前上方用于作为生成方块的位置，</p><p>然后我们创建一个Actor，命名为Cube，给与一个cube的static mesh，给予一个box collision组件，box collision和static mesh都要勾选Simulate Physics和Mass给与Cube物理效果和重力效果。最重要的一步——–勾选Replication/Replicates，使Cube可以在各个客户端之间复制，否则Actor是无法进行同步的。</p><p>在Cube里只做一件事，就是生成后3秒自动销毁，给一个自定义事件执行销毁逻辑，并在构造函数里调用。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210802215840.png" alt="image-20210802215806819"></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210802215842.png" alt="image-20210802215735373"></p><p>然后我们在ThridPersonCharacter中也添加一个自定义事件，用于执行创建Cube的逻辑，然后在按键E的检测事件中调用这个事件。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210802220241.png" alt="image-20210802220238583"></p><h3 id="蓝图的属性复制"><a href="#蓝图的属性复制" class="headerlink" title="蓝图的属性复制"></a>蓝图的属性复制</h3><p>为什么一定要将Cube的创建封装在一个自定义事件里？因为只有自定义事件才可以选择是事件的执行位置。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210802220405.png" alt="image-20210802220402817"></p><ul><li>Not Replicated：不进行网络复制；</li><li>Multicast：由服务器调用，在服务器和所有客户端执行；</li><li>Run on Server：在客户端中调用，在服务器中执行；</li><li>Run on owning Client：只在有所有权的客户端执行，执行结果不会同步到其他客户端。</li></ul><h3 id="执行效果"><a href="#执行效果" class="headerlink" title="执行效果"></a>执行效果</h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210804155737.gif"></p><p>这里加了一个人物触碰时更改cube颜色的效果，以便同步时显示的更明显。</p><h3 id="Actor的所有权—ROLE"><a href="#Actor的所有权—ROLE" class="headerlink" title="Actor的所有权—ROLE"></a>Actor的所有权—ROLE</h3><p>UE将Actor的控制权分成了三类，分别是：</p><ul><li><p>ROLE_None：这个None就是我们平常理解的None，不属于下面三种的都是None</p></li><li><p>ROLE_Authority：服务器拥有所有Actor的控制权，即所有的Actor在服务器端的控制权都是ROLE_Authority</p></li><li><p>ROLE_AutonomousProxy：客户端对本地Actor拥有这个控制权</p></li><li><p>ROLE_SimulatedProxy：客户端对网络Actor，即其他端的Actor，拥有这个控制权</p></li></ul><p>这个三个属性是UE设计Actor时就为Actor设计好的固有属性，可以用于判断一个Actor所在位置，因为UE的服务器代码和客户端代码是一体的，所以Actor设计这个属性是十分必要的。</p><p>我们可以用一个示例来具体观摩一下，我们将项目继续迭代，现在我们在角色的头顶添加一个TextRender，然后把GetLocalRole的控制权名称设置到TextRender上。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809225948.png"></p><p>然后运行起来</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809225951.png"></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809230015.png"></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809230012.png"></p><p>可以看到，在服务器端的窗口上所有的人物都显示的是ROLE_Authority，而在两个客户端的窗口上只有自己控制的人物显示ROLE_AutonomousProxy，其他的都显示ROLE_SimulatedProxy，尽管其中有一个人物是服务器生成的，但对于这个客户端来说它也属于其他端的Actor。</p><h2 id="2-自定义Pawn的网络同步"><a href="#2-自定义Pawn的网络同步" class="headerlink" title="2.自定义Pawn的网络同步"></a>2.自定义Pawn的网络同步</h2><p>关于自定义Pawn的网络同步，在网上的资料简直少得可怜，项目迭代到这里，也是磕磕绊绊搞了好一阵子。</p><p>这里为了和第三人称模板完全脱离关系，我们创建一些自己的GamePlay。</p><ul><li>创建一个自己的GameMode：LSPGameMode</li><li>创建一个自己的PlayerController：LSPPlayerController</li><li>创建一个自己的可控制的Pawn：Ball</li></ul><p>然后把GameMode换成LSPGameMode，把LSPGameMode的PlayerControllerClass换成LSPPlayerController，把DefaultPawnClass换成Ball。</p><h3 id="实现一个可控制滚动的Pawn"><a href="#实现一个可控制滚动的Pawn" class="headerlink" title="实现一个可控制滚动的Pawn"></a>实现一个可控制滚动的Pawn</h3><p>这里推荐跟着UE4中的Rolling模板来做，在UE5中这个模板已经被移除了。</p><p>Pawn的结构</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809230019.png"></p><p>这里为了看起来滚动明显一点就给了一个Cube的Mesh。</p><p>Pawn的蓝图</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809230245.png"></p><p>这里PlayerController的硬件输入配置还是沿用第三人称模板预定义好的那些配置。</p><p>这里单独把角色控制封装在一个事件里也是为了让控制Pawn滚动的蓝图跑在服务器上，这样服务器才能把一个客户端的运动同步到其他的客户端。</p><p>这里Speed和JumpImpulse的值要给大一点，否则滚跳起来没什么效果。</p><p>在实现可滚动的方块时，出现了摄像机和方块一起滚动的问题，这是我们需要把SpringArm下的这些勾都取消掉。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809230039.png"></p><p>到这里一个可控制的滚动方块就成了，下面是运行效果</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809230039.png"></p><p>然后打包客户端，按理来说ds服务器是不需要再编译了的，因为服务器也是用的客户端的代码，编译出来的exe也就是提供一个服务器的入口，如果不行的话建议也再编译一次服务器。</p><h3 id="运行效果-1"><a href="#运行效果-1" class="headerlink" title="运行效果"></a>运行效果</h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809230136.gif"></p><h1 id="四、Actor的属性同步"><a href="#四、Actor的属性同步" class="headerlink" title="四、Actor的属性同步"></a>四、Actor的属性同步</h1><h2 id="1-简单属性的同步"><a href="#1-简单属性的同步" class="headerlink" title="1.简单属性的同步"></a>1.简单属性的同步</h2><p>前面我们都是停留在角色移动的网络同步上，而实际游戏中除了最基础移动同步外，还有很多其他的属性数据也需要同步，比如当某一个客户端的角色换了一个皮肤之后，其他的客户端里这个角色也应该同步显示新的皮肤。</p><p>如果要实现客户端的属性发生改变的同时属性值同步到其他客户端中，我们需要铭记两点：</p><ul><li>属性的Replication应勾选Replicated或RepNotify；</li><li>修改属性的代码或蓝图必须运行在服务器上。</li></ul><p><strong>Actor的Replication</strong></p><p>Replication是任何派生于UObject的类的变量的固有属性，用于标识这个变量是否允许网络同步。在蓝图中Replication属性有三种可选值</p><ul><li>None：属性不允许网络同步；</li><li>Replication：属性允许网络同步；</li><li>RepNotify：属性允许网络同步，同时绑定一个回调函数，属性发生变化时回调，在蓝图中回调函数会自动创建在FUNCTION中并以<code>OnRep_</code>开头，以属性名结尾，如属性pos的回调函数为<code>OnRep_pos</code>。</li></ul><p>现在我们继续迭代项目，我们在自定义Pawn中添加一个整型变量Time，这里我选择将Time的Repliction属性设置成RepNotify，以便Time发生变化时修改TextRender的Text。然后在Pawn中添加一个TextRender用于显示Time的值，我们把TextRender放在SpringArm下，这样文字就不会跟着方块滚动。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809230154.png"></p><p>然后在Ball中添加如下蓝图：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809230159.png"></p><p>这里要注意的一点就是Time值得修改要运行在服务器上，所以SetTime节点我用来一个运行在服务器上的自定义事件封装。</p><p>OnRep_Time函数</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809230207.png"></p><p>Client Widget的蓝图</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809230210.png"></p><p>这里使用的是Editable Text并添加了一个On Text Commited事件，这个事件在输入完成后按下Enter键触发。</p><p>然后我们跑起来看一下效果，为了方便起见，这里我就直接使用Listen Server模式来运行了</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809230214.gif"> </p><h2 id="1-复杂属性的同步"><a href="#1-复杂属性的同步" class="headerlink" title="1.复杂属性的同步"></a>1.复杂属性的同步</h2><p>按理来说，将属性的Replication设置为Replicated或RepNotify，然后在服务器上修改属性值，属性就应该由服务器广播到所有客户端同步，然而我在测试同步一个UObject类作为Actor的属性时，发现仅仅通过上面的步骤无法在所有的客户端同步这个属性。如果将修改操作封装在一个Run on Server事件中，那么只有服务器中对应的Actor的值被修改了却没有同步到其他的客户端，如果将修改操作封装在一个Multicast事件中，则只有在服务器中做的修改才会被同步。我这里通过两层封装解决了这个问题，至于这个问题具体是什么原因造成的，暂时还没弄明白。</p><p>具体迭代步骤：</p><p>创建一个继承至UObject的类—BallData用于存储自定义Pawn—Ball的数据。</p><p>在BallData中创建一个FString类型的数组—SpeekStr，初始化三组数据，并设置Replication为Replicated。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809235321.png"></p><p>在Ball中创建一个BallData类型的变量，设置Replication为Replicated。</p><p>在Ball中增加如下蓝图</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809235324.png"></p><p>我在BeginPlay中构建BallData对象，并启动每3秒读取一次数组值的循环事件。</p><p>这里我们要同步的是BallData类型变量Data中的SpeekStr数组，对数组的元素增加操作我使用两成封装，第一层直接将操作封装在一个Multicast事件中，然后将Multicast事件封装在一个Run on Server事件中，这样MultiSpeek将运行在服务器中，然后再有服务器调用广播事件AddSpeek，将对数组的元素增加操作广播到所有的客户端中。</p><p>执行效果</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210809235352.gif"></p><h1 id="五、C-中的网络同步"><a href="#五、C-中的网络同步" class="headerlink" title="五、C++中的网络同步"></a>五、C++中的网络同步</h1><p>C++的网络同步在函数层面主要就是UFUNCTION宏的三个参数Server、Client和NetMulticast，而在变量层面主要UPROPERTY宏的参数Replicated。</p><p>一般情况下我们的网络同步都是在Actor中进行，这里我直接深一个层次，在继承自UObject的UActorComponent组件中来进行网络同步。其实大部分操作和Actor基本是一样的，只有一小部分的区别。</p><p>这里我创建一个继承自UActorComponent的组件UChatComponent，并把ChatComponent组件添加到Ball身上。</p><p>然后我这里先上一份源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//ChatComponent.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Components/TextRenderComponent.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Blueprint/UserWidget.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Components/ActorComponent.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ChatComponent.generated.h&quot;</span></span><br><br><br>UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LSPTETRISCLIENT_API</span> <span class="hljs-title">UChatComponent</span> :</span> <span class="hljs-keyword">public</span> UActorComponent<br>&#123;<br>GENERATED_BODY()<br><br><span class="hljs-keyword">public</span>:<br>UChatComponent();<br>UPROPERTY(Replicated)<br><span class="hljs-keyword">int</span> cubeCount = <span class="hljs-number">0</span>;<br>UPROPERTY(ReplicatedUsing = OnRep_cubeCountTotal, EditAnywhere, BlueprintReadWrite)<br><span class="hljs-keyword">int</span> cubeCountTotal = <span class="hljs-number">20</span>;<br>UPROPERTY(EditAnywhere,BlueprintReadWrite)<br>FColor TextColor = FColor(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">private</span>:<br>APlayerController* playerPtr;<br>UClass* Cube;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TickComponent</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)</span> <span class="hljs-keyword">override</span></span>;<br><br>UFUNCTION(Server,Reliable)<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SpwanCube</span><span class="hljs-params">()</span></span>;<br>UFUNCTION(Client,Reliable,BlueprintCallable)<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SwitchTextRenderColor</span><span class="hljs-params">()</span></span>;<br>UFUNCTION(NetMulticast, Reliable)<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">NetMulticastSetTextRenderColor</span><span class="hljs-params">(UTextRenderComponent* textRender)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GetLifetimeReplicatedProps</span><span class="hljs-params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span></span>;<br>    UFUNCTION()<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRep_cubeCountTotal</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//ChatComponent.cpp</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Replication/ChatComponent.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;InputCoreTypes.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Net/UnrealNetwork.h&quot;</span></span><br><br>UChatComponent::UChatComponent()<br>&#123;<br>PrimaryComponentTick.bCanEverTick = <span class="hljs-literal">true</span>;<br>SetIsReplicated(<span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UChatComponent::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br>playerPtr = GetWorld()-&gt;GetFirstPlayerController();<br>Cube = LoadClass&lt;AActor&gt;(<span class="hljs-literal">NULL</span>, TEXT(<span class="hljs-string">&quot;Blueprint&#x27;/Game/Map/Cube.Cube_C&#x27;&quot;</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UChatComponent::TickComponent</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)</span></span><br><span class="hljs-function"></span>&#123;<br>Super::TickComponent(DeltaTime, TickType, ThisTickFunction);<br><br><span class="hljs-keyword">if</span> (playerPtr-&gt;IsInputKeyDown(EKeys::LeftMouseButton))<br>&#123;<br>SpwanCube();<br>&#125;<br>SwitchTextRenderColor();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UChatComponent::SwitchTextRenderColor_Implementation</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (GetWorld()-&gt;IsServer())<br>&#123;<br><span class="hljs-keyword">if</span> (cubeCount &gt;= cubeCountTotal)<br>&#123;<br>cubeCount = <span class="hljs-number">0</span>;<br>TArray&lt;UTextRenderComponent*&gt; comps;<br>GetOwner()-&gt;GetComponents(comps);<br><span class="hljs-keyword">if</span> (comps.Num() != <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>UTextRenderComponent* textRender = comps[<span class="hljs-number">0</span>];<br>NetMulticastSetTextRenderColor(textRender);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UChatComponent::SpwanCube_Implementation</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (Cube &amp;&amp; GetWorld())<br>&#123;<br>GetWorld()-&gt;SpawnActor&lt;AActor&gt;(Cube, GetOwner()-&gt;GetActorTransform());<br>cubeCount++;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UChatComponent::NetMulticastSetTextRenderColor_Implementation</span><span class="hljs-params">(UTextRenderComponent* textRender)</span></span><br><span class="hljs-function"></span>&#123;<br>textRender-&gt;SetTextRenderColor(TextColor);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UChatComponent::GetLifetimeReplicatedProps</span><span class="hljs-params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function"></span>&#123;<br>Super::GetLifetimeReplicatedProps(OutLifetimeProps);<br>DOREPLIFETIME(UChatComponent, cubeCount);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UChatComponent::OnRep_cubeCountTotal</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (cubeCountTotal &gt;= <span class="hljs-number">40</span>)<br>&#123;<br>FString msg = FString::FromInt(cubeCountTotal);<br>GEngine-&gt;AddOnScreenDebugMessage(<span class="hljs-number">-1</span>, <span class="hljs-number">5</span>, FColor::Red, *msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面我们一行一行的来解析</p><h2 id="1-UNFUNCTION-Server-Reliable"><a href="#1-UNFUNCTION-Server-Reliable" class="headerlink" title="1.UNFUNCTION(Server, Reliable)"></a>1.UNFUNCTION(Server, Reliable)</h2><p>Server表示这个函数在客户端调用在服务器执行，和前面的Run on Server蓝图事件对应。</p><h2 id="2-UFUNCTION-Client-Reliable"><a href="#2-UFUNCTION-Client-Reliable" class="headerlink" title="2.UFUNCTION(Client, Reliable)"></a>2.UFUNCTION(Client, Reliable)</h2><p>Client表示这个函数在服务器调用在拥有这个Actor或UObject的客户端执行，函数执行的结果只在执行函数的客户端显示，不会同步到其他的客户端，和前面的Run on owning Client蓝图事件对应。</p><h2 id="3-UFUNCTION-NetMulticast-Reliable"><a href="#3-UFUNCTION-NetMulticast-Reliable" class="headerlink" title="3.UFUNCTION(NetMulticast, Reliable)"></a>3.UFUNCTION(NetMulticast, Reliable)</h2><p>NetMulticast表示这个函数在服务器调用并在服务器和所有与服务器连接并拥有这个Actor或Object的客户端上执行，和前面的Multicast蓝图事件对应。</p><h2 id="4-Reliable"><a href="#4-Reliable" class="headerlink" title="4.Reliable"></a>4.Reliable</h2><p>Server，Client和Multicast都需要搭配Reliable使用，否则编译无法通过，Reliable表示函数可以在网络空间进行复制，并会忽略带宽或网络错误而被确保送达，这保证了RPC的安全性。</p><h2 id="5-RPC函数的实现"><a href="#5-RPC函数的实现" class="headerlink" title="5.RPC函数的实现"></a>5.RPC函数的实现</h2><p>当一个函数被标识了Server，Client或Multicast宏后，函数的实现就和普通函数不一样了，函数实现的函数名和函数定义的函数名发生了变化，函数实现的函数名需要加一个<code>_Implementation</code>后缀，否则编译会报错。</p><h2 id="6-重写GetLifetimeReplicatedProps函数"><a href="#6-重写GetLifetimeReplicatedProps函数" class="headerlink" title="6.重写GetLifetimeReplicatedProps函数"></a>6.重写GetLifetimeReplicatedProps函数</h2><p>在UE5中，Actor是默认拥有网络同步能力的，但是UObject没有默认拥有网络同步，所以如果我们不重写GetLifetimeReplicatedProps函数，尽管成员函数标识了Server，Client或NetMulticast宏，UObject也依旧不具备网络同步的能力。</p><h2 id="7-DOREPLIFETIME"><a href="#7-DOREPLIFETIME" class="headerlink" title="7.DOREPLIFETIME"></a>7.DOREPLIFETIME</h2><p>除了<code>DOREPLIFETIME</code>宏UE5还有一个<code>DOREPLIFETIME_CONDITION</code>宏，二者的实机作用都是一样的，都是用于注册属性的条件复制的，当我们类里的变量</p><p>这里我在BeginPlay里加载了一个在前面第三节创建的Cube蓝图类，然后在SpawnCube函数中实现Cube的创建过程，这样Cube的创建过程就跑在了服务器上，而Cube勾选了Replicated，这样Cube的创建过程就可以通过服务器同步到所有的客户端中了。</p><p>然后我在SwitchTextRenderColor函数中修改Ball下面的UTextRenderComponent组件的字体颜色。由于SwitchTextRenderColor是在服务器调用在客户端执行，所以函数里面使用了<code>GetWorld()-&gt;IsServer()</code>来判断执行端是否是服务器，如果不做判断的话，函数会在服务器上调用但是却会在所有拥有UChatComponent组件的Ball上执行，而我要的效果是当服务器中Ball发射了超过20个Cube时只修改服务器上的Ball的Textrender的字体颜色，并把这个效果同步到其他客户端中对应的Ball上。</p><p>所以我在SwitchTextRenderColor中有调用了一个NetMulticast函数NetMulticastSetTextRenderColor以将这个执行结果的变化同步到其他的客户端中。</p><p>我们来看一下效果</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811223042.gif"></p><p>可以看到只有在服务器中Ball执行的时候颜色才会发生变化，并将变化同步到了所有的客户算中。</p><p>这里在UI里加了一个可以更改cubeCountTotal值的蓝图，和颜色修改后自动恢复过来的蓝图，蓝图比较简单就不贴出来了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【UE4】UE4在网页里展示虚拟形象</title>
    <link href="/2021/08/05/%E3%80%90UE4%E3%80%91UE4%E5%9C%A8%E7%BD%91%E9%A1%B5%E9%87%8C%E5%B1%95%E7%A4%BA%E8%99%9A%E6%8B%9F%E5%BD%A2%E8%B1%A1/"/>
    <url>/2021/08/05/%E3%80%90UE4%E3%80%91UE4%E5%9C%A8%E7%BD%91%E9%A1%B5%E9%87%8C%E5%B1%95%E7%A4%BA%E8%99%9A%E6%8B%9F%E5%BD%A2%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>参考博客：<a href="https://zhuanlan.zhihu.com/p/235547851">吾爱豆</a></p><a id="more"></a><h1 id="一、通过UMG来展示角色"><a href="#一、通过UMG来展示角色" class="headerlink" title="一、通过UMG来展示角色"></a>一、通过UMG来展示角色</h1><p>在UE4中使用UMG来展示角色的原理主要通过UE4提供的一个<code>SceneCapture2D</code>相机来捕捉场景中的画面，搭配<code>Render Target</code>将捕捉到的画面显示到贴图上，然后将贴图制作成材质，将材质运用到UMG中就可以了，当然也不一定非得要将贴图制作成材质再给UMG使用，贴图也是可以直接给UMG使用的，只是我们后面还需要在材质里对贴图做一些处理，所以这里就直接把贴图做成材质了。</p><p>首先像场景中添加一个SceneCapture2D，并把它位置设置到角色前，设置到自己想要的效果就行了。</p><p>然后再创建一个Render Target，在SceneCapture2D的Details/Scene Capture/Texture Target下把目标贴图设置成我们新建的Render Target，这样Render Target就可以接收到SceneCapture2D捕捉到的画面了。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210805215100.png"></p><p>然后创建一个Material，双击打开材质界面，把材质的Matrial Domain设置成User Interface，把Blend Mode设置成Translucent，Translucent是后面过滤背景用的，现在先设置好。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210805215107.png"></p><p>把RenderTarget直接拖进材质界面，会自动生成一个Texture Sample节点，然后把节点连接到材质。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210805215111.png"></p><p>然后我们需要创建一个UMG来展示角色，创建一个UserWidget，添加一个Image用于展示角色。把Image的Brush/Image设置成我们创建的材质，于是人物就出来了。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210805215115.png"></p><p>运行出来的效果就是这样的</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210805215119.gif"></p><p>这里我给人物加了一点动画。</p><h1 id="二、过滤不需要的背景"><a href="#二、过滤不需要的背景" class="headerlink" title="二、过滤不需要的背景"></a>二、过滤不需要的背景</h1><p>从上面的运行结果可以看到，效果还是不错的，只是我想要角色，而不想要地板和天空球，怎么办呢？</p><p>SceneCapture2D提供了一种渲染模式Use ShowOnly List，意思是只渲染我们添加到列表里的Actor，我们把SceneCapture2D的Scene Capture/Primitive Render Mode换成Use ShowOnly List模式，然后再Show Only Actors下添加我们要显示的角色，这里Capture Source要设置成SceneColor(HDR) in RGB，Inv Opacity in A，in A表示颜色模式是带透明度的，这个设置是过滤背景的关键，没有透明度信息的话，就没办法过滤背景了。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210805215123.png"></p><p>到这一步我们运行场景的话，效果就是这样的。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210805215127.png"></p><p>可以看到Image上已经没有显示Palne和天空了，但是不渲染的部分都是黑色的，怎么办呢？这就需要用的材质了，打开我们之前创建的Material，添加一个OneMinus节点，设置到透明度上。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210805215131.png"></p><p>然后我们再运行，效果是这样的。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210805215135.png"></p><p>可以看到Image中出人物的部分已经完全变透明了。</p><h1 id="三、设置网页图层"><a href="#三、设置网页图层" class="headerlink" title="三、设置网页图层"></a>三、设置网页图层</h1><p>既然小已经达成了，我们就可以把人物嵌入到网页里了。</p><p>这里我们需要自定义一个WebBrowser控件，具体的操作可以看我的<a href="https://goulandis.github.io/2021/05/14/%E3%80%90UE4%E3%80%91UE4%E5%86%85%E5%B5%8CWeb%E5%8F%8A%E4%B8%8EWeb%E9%80%9A%E4%BF%A1/">另一篇博文</a>。</p><p>做好之后，就可以直接Palette里搜索到我们自定的WebBrowser了，拖两个到UMG中，然后在蓝图中分别给两个WebBrowser加载两个网页。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210805215139.png"></p><p>现在运行，网页会把我们的角色给遮挡住，我们要的效果是角色夹在两个网页之间，这就需要我们自己手动调整三个图层的前后位置了。</p><p>只需要把显示角色Image的Slot/ZOrder的值设置在两个WebBrowser之间就可以了，这个值默认为0，值越大表示图层越高，高图层会覆盖低图层。</p><p>然后我们看一下效果。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210805215142.gif"></p><p>然后具体角色想要在网页上达到什么效果就自己灵活调整了。如果觉得角色太暗，可以在场景中为角色打个灯光。</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【日记】来深圳两个月了</title>
    <link href="/2021/07/14/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E6%9D%A5%E6%B7%B1%E5%9C%B3%E4%B8%A4%E4%B8%AA%E6%9C%88%E4%BA%86/"/>
    <url>/2021/07/14/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E6%9D%A5%E6%B7%B1%E5%9C%B3%E4%B8%A4%E4%B8%AA%E6%9C%88%E4%BA%86/</url>
    
    <content type="html"><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3 id="encrypt-message">这里不可以看哦！</h3><link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"> <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css"> <script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <script src="//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js"></script> <div id="security"> <div> <div class="input-group"> <input type="text" class="form-control" aria-label="Enter the password." id="pass"/> <div class="input-group-btn"> <button type="button" class="btn btn-default" onclick="decryptAES()">Decrypt</button> </div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
    
    
    <categories>
      
      <category>日记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大事件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE4】UE4实现自定义框选</title>
    <link href="/2021/05/14/%E3%80%90UE4%E3%80%91UE4%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A1%86%E9%80%89/"/>
    <url>/2021/05/14/%E3%80%90UE4%E3%80%91UE4%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A1%86%E9%80%89/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>要在UE4中实现自定义框选功能，首先我们来分析一下顶顶一框选插件需要些什么模块？</p><ul><li>绘制模块</li><li>显示模块</li><li>计算模块</li></ul><p>嗯，大概分这么三个模块，好，现在我们一个个模块来分析实现。首先分析实现一下显示模块。</p><a id="more"></a><p><font color="green">提示：</font></p><p><font color="green">如果功能需要打包成插件，请先浏览第四章</font></p><h1 id="一、显示模块"><a href="#一、显示模块" class="headerlink" title="一、显示模块"></a>一、显示模块</h1><p>首先我们需要做一些准备</p><h2 id="1-创建Wedgit作为显示载体"><a href="#1-创建Wedgit作为显示载体" class="headerlink" title="1.创建Wedgit作为显示载体"></a>1.创建Wedgit作为显示载体</h2><p>UE4绘制直线的方式很多，这里我使用DrawLine在RenderTarget里绘制，绘制的实现放在后面说。</p><p>然后我们需要让自定义框选的线显示在屏幕上，那么使用<code>wedgit</code>来显示是比较理想的，所以我们来创建一个widget，命名为<code>CustomSelectUI</code>，并为CustomSelectUI添加一个<code>image</code>作为显示的载体，命名为Background。</p><h2 id="2-创建Material作为RenderTarget的显示载体"><a href="#2-创建Material作为RenderTarget的显示载体" class="headerlink" title="2.创建Material作为RenderTarget的显示载体"></a>2.创建Material作为RenderTarget的显示载体</h2><p>光一个image也是无法显示我们绘制的线的，因为我们的线是画在RenderTarget里的，而image没法直接使用RenderTarget，所以我们还需要创建一个Material来承载RenderTarget。这里创建一个Material命名为Mat_Paint。</p><h2 id="3-为Material创建一个Texture"><a href="#3-为Material创建一个Texture" class="headerlink" title="3.为Material创建一个Texture"></a>3.为Material创建一个Texture</h2><p>创建的Texture是有讲究的，Texture必须是存黑色的即RPG(0,0,0)，然后分辨率可自定义。这里我使用PS制作了一个纯黑的PNG图片，并设置分辨率为2048x2048，并导入到UE4生成Texture，并命名为Mat_Transparent_Max。<br><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180719.png" alt="在这里插入图片描述"></p><p>使用纯黑色的原因在第四小节说明。</p><h2 id="4-实现Material的作用"><a href="#4-实现Material的作用" class="headerlink" title="4.实现Material的作用"></a>4.实现Material的作用</h2><p>Material出来作为RenerTarget的载体外，还有设置笔刷的颜色，以及使背景透明的作用。</p><p>先来看一下Mat_Paint的蓝图</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180725.png" alt="在这里插入图片描述"></p><p>首先将Mat_Paint节点的<code>Details/Material/Material Domain</code>更换为User Interface，即将Material改为Material Interface。</p><p>并未Mat_Paint添加一个Texture，将之前创建的Mat_Transparent_Max拖入Mat_Paint中，右键节点选择Convert to Parameter将节点参数化，并取名<code>RT_Texture</code>，这是为了后面动态设置做的准备。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180731.png" alt="在这里插入图片描述"></p><p>然后将RT_Texture连接到Mat_Paint中的Opacity上，Opacity节点是Material控制材质透明度的接口，在Opacity中RGB(0,0,0)表示全透明，RGB(1,1,1)表示不透明，即纯黑色表示全透明，纯白色表示不透明，这就是为什么我们需要一张纯黑色的Texture的原因。因为我们需要一个透明的材质赋予image这样我们才能看到Wedgit后面的场景，使场景不会被我们的image遮挡。</p><p>然后创建一个Constant3Vector，并且也将其参数化，命名为PaintColor，这为之后修改画笔颜色预留接口。将PaintColor连接到Mat_Paint的Final Color上。Final Color接口控制着材质最终显示的颜色。</p><p>到这里，擦材质我们就做好了。</p><h2 id="5-显示"><a href="#5-显示" class="headerlink" title="5.显示"></a>5.显示</h2><p>这里我在CustomSelectUI构造时为Background添加Mat_Paint动态材质。我们来看一下蓝图</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180738.png" alt="在这里插入图片描述"></p><ul><li>RenderMat变量是Material Instance Dynamic类型用于存储动态创建的Mat_Paint，方便之后使用；</li><li>LineLinearColor变量是LinearColor类型，用于设置画笔颜色</li></ul><p>到这里显示部分就完成了。</p><h1 id="二、绘制模块"><a href="#二、绘制模块" class="headerlink" title="二、绘制模块"></a>二、绘制模块</h1><h2 id="1-获取鼠标在屏幕中的位置坐标"><a href="#1-获取鼠标在屏幕中的位置坐标" class="headerlink" title="1.获取鼠标在屏幕中的位置坐标"></a>1.获取鼠标在屏幕中的位置坐标</h2><p>线的绘制我使用DrawLine函数根据鼠标点击的点来绘制点与点之间的直线，绘制模块最终要的两个步骤就是获取鼠标点击的屏幕上的点和根据点集绘制多边形。</p><p>实现获取鼠标在屏幕上的位置，这里我们需要重写两个函数，OnMouseButtonUp和OnMouseButtonDown,我们来看一下蓝图。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180748.png" alt="在这里插入图片描述"></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180754.png" alt="在这里插入图片描述"></p><ul><li><p>MouseDown用于标识鼠标的按下与抬起，true表示按下，false表示抬起。</p></li><li><p>Setup控制是否开始绘制。</p></li><li><p>IsFirstPoint标识第一个点与其余点。</p></li><li><p>PolygonPoints是存储鼠标点击的点的数组，启动绘制之后鼠标每点击一次变向数组中添加一个Vector2D元素。</p></li><li><p>CurrentPoint存储鼠标当前点击的屏幕坐标。</p></li><li><p>StartPoint存储绘制直线的起点的屏幕坐标。</p></li><li><p>MousePositionAdaptDPI是自己封装的获取鼠标屏幕坐标的函数，之所以封装是为例修改方便。</p></li></ul><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180801.png" alt="在这里插入图片描述"></p><p>到此，获取鼠标的屏幕坐标就实现了，接下来要根据鼠标点击确定的点集PolygonPoints绘制直线。</p><h2 id="2-绘制直线"><a href="#2-绘制直线" class="headerlink" title="2.绘制直线"></a>2.绘制直线</h2><p>再绘制直线之前，需要做一些准备工作，即创建直线绘制的载体RenderTarget并用之前创建好的RenderMat承载，然后将RenderMat绑定到Background上显示。这里我绑定到Setup按钮的OnClicked事件下。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180807.png" alt="在这里插入图片描述"></p><ul><li><p>CreateCanvasRenderTarget2D函数负责创建RenderTarget，RenderTarget可以直接使用引擎默认的，也可以自己创建自定义的，这里我使用引擎默认的。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180812.png" alt="在这里插入图片描述"></p><p>Width和Height控制着RenderTarget的长宽比例，超出这个比例的部分屏幕将无法绘制，如：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180820.png" alt="在这里插入图片描述"></p><p>红框部分的屏幕比例就是1920：1080，超出着部分的屏幕将无法绘制，当然在全屏运行的情况下不会出现这种问题。出现这个问题是因为我的计算机屏幕尺寸就是1920：1080，运行时，UE4的实际运行窗口是蓝色部分，很明显由于windows菜单栏和UE运行窗口的菜单栏占据了屏幕的部分像素，所以UE的实际运行窗口是蓝色部分，其比例显然不是1920：1080，所以超出部分就没办法绘制了。这个RenderTarget的比例可以根据自己的实际需求更改。</p></li><li><p>SetupCustomSelect函数负责绘制的启动与关闭</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180828.png" alt="在这里插入图片描述"><br>准备工作结束后便可以开始绘制直线了，直线的绘制放在Tick函数下，每帧绘制。</p></li></ul><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180834.png" alt="在这里插入图片描述"></p><ul><li><p>LineThickness控制直线绘制时的粗细程度。</p></li><li><p>StartPaint是具体的直线绘制函数。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180840.png" alt="在这里插入图片描述"></p><p>其中RenderColor必须设置纯白色，只有这样绘制出来的直线才是不透明的。</p></li></ul><p><font color="red">绘制直线这里有一点需要注意，即需要设置我们Background的锚点为左上角，因为RenderTarget的原点在左上角，只有这样鼠标点击的位置才会和绘制的位置匹配，否则会出现位置偏移的问题。</font></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180848.png" alt="在这里插入图片描述"></p><h2 id="3-清除绘制内容"><a href="#3-清除绘制内容" class="headerlink" title="3.清除绘制内容"></a>3.清除绘制内容</h2><p>考虑到会有绘制出错的情况，所以添加一个清除绘制内容的功能。清除绘制内容原理比较简单，只需要清除RenderTarget缓存和PolygonPoints点击即可。</p><p>这里我绑定在Delete按钮的OnClicked事件下。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180854.png" alt="在这里插入图片描述"></p><h2 id="4-结束绘制"><a href="#4-结束绘制" class="headerlink" title="4.结束绘制"></a>4.结束绘制</h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180859.png" alt="在这里插入图片描述"></p><p>结束绘制之后就要开始计算框选内容了，SureSelect函数负责这方面的实现，计算后面讲解。</p><p>结束绘制之后需要将最后一个点和第一个点连接来，确保多边形是一个封闭的多边形。EndPaint函数负责这个功能的实现。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180904.png" alt="在这里插入图片描述"></p><h1 id="三、计算"><a href="#三、计算" class="headerlink" title="三、计算"></a>三、计算</h1><p>计算这里需要用到C++了，在蓝图的SureSelect函数里调用C++的计算函数。</p><p>创建一个继承自Actor的C++类，并命名为CustomSelectActor，下面贴出C++源码：</p><p><code>.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LeastPointNum 4</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ActorSamplingPoints 9</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Runtime/Engine/Classes/Kismet/GameplayStatics.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Engine/World.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;GameFramework/Actor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;EngineUtils.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;GameFramework/PlayerController.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;GameFramework/Actor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CustomSelectActor.generated.h&quot;</span></span><br><br>USTRUCT()<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FBoxPointSet</span></span><br><span class="hljs-class">&#123;</span><br>GENERATED_USTRUCT_BODY()<br><span class="hljs-keyword">public</span>:<br>TArray&lt;FVector2D&gt; points;<br>FBoxPointSet()<br>&#123;<br>points.Init(FVector2D(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">9</span>);<br>&#125;<br>&#125;;<br><br>UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CUSTOMSELECT_API</span> <span class="hljs-title">ACustomSelectActor</span> :</span> <span class="hljs-keyword">public</span> AActor<br>&#123;<br>GENERATED_BODY()<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">const</span> FVector BoundsPointMapping[<span class="hljs-number">8</span>] =<br>&#123;<br>FVector(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<br>FVector(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>),<br>FVector(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>),<br>FVector(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>),<br>FVector(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<br>FVector(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>),<br>FVector(<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>),<br>FVector(<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>)<br>&#125;;<br><br><span class="hljs-keyword">protected</span>:<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-keyword">public</span>:<br>ACustomSelectActor();<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Tick</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime)</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GetMax</span><span class="hljs-params">(TArray&lt;FVector2D&gt;&amp; points, <span class="hljs-keyword">float</span>&amp; max_x, <span class="hljs-keyword">float</span>&amp; max_y, <span class="hljs-keyword">int</span>&amp; len)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GetMin</span><span class="hljs-params">(TArray&lt;FVector2D&gt;&amp; points, <span class="hljs-keyword">float</span>&amp; min_x, <span class="hljs-keyword">float</span>&amp; min_y, <span class="hljs-keyword">int</span>&amp; len)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SpwanVertArr</span><span class="hljs-params">(TArray&lt;FVector2D&gt;&amp; polygonPoints, TArray&lt;<span class="hljs-keyword">float</span>&gt;&amp; vertx, TArray&lt;<span class="hljs-keyword">float</span>&gt;&amp; verty, <span class="hljs-keyword">int</span>&amp; len)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">PNPoly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nvert, TArray&lt;<span class="hljs-keyword">float</span>&gt; vertx, TArray&lt;<span class="hljs-keyword">float</span>&gt; verty, <span class="hljs-keyword">float</span> testx, <span class="hljs-keyword">float</span> testy)</span></span>;<br>UFUNCTION(BlueprintImplementableEvent)<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ProjectWorldLocationToWidgetPosition</span><span class="hljs-params">(APlayerController* player_ctrl, FVector worldLocation, FVector2D&amp; screenPosition)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GetFBoxPointsSet</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;FBoxPointSet&gt;&amp; fboxPointsArr,</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;AActor*&gt;&amp; actorArr,</span></span><br><span class="hljs-function"><span class="hljs-params">TSubclassOf&lt;AActor&gt;&amp; classFilter,</span></span><br><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span>&amp; bIncludeNonCollidingComponents,</span></span><br><span class="hljs-function"><span class="hljs-params">APlayerController* player_ctrl)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GetActorsRefByPointsSet</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;AActor*&gt;&amp; outActors,</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;<span class="hljs-keyword">float</span>&gt;&amp; vertx,</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;<span class="hljs-keyword">float</span>&gt;&amp; verty,</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;FBoxPointSet&gt;&amp; fboxPointsArr,</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;AActor*&gt;&amp; actorArr,</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;FVector2D&gt;&amp; polygonPoints,</span></span><br><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span>&amp; len)</span></span>;<br>UFUNCTION(BlueprintCallable, Category = <span class="hljs-string">&quot;CustomSelect&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CustomSelect</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;AActor*&gt;&amp; outActors,</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;FVector2D&gt; polygonPoints,</span></span><br><span class="hljs-function"><span class="hljs-params">TSubclassOf&lt;AActor&gt; classFilter,</span></span><br><span class="hljs-function"><span class="hljs-params">APlayerController * player_ctrl,</span></span><br><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span> bIncludeNonCollidingComponents)</span></span>;<br>UFUNCTION(BlueprintCallable, Category = <span class="hljs-string">&quot;CustomSelect&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">CompuePolygonArea</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TArray&lt;FVector2D&gt; polygonPoints)</span></span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p><code>.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CustomSelectActor.h&quot;</span></span><br><br>ACustomSelectActor::ACustomSelectActor()<br>&#123;<br>PrimaryActorTick.bCanEverTick = <span class="hljs-literal">false</span>;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ACustomSelectActor::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::BeginPlay();<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ACustomSelectActor::Tick</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime)</span></span><br><span class="hljs-function"></span>&#123;<br>Super::Tick(DeltaTime);<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ACustomSelectActor::GetMax</span><span class="hljs-params">(TArray&lt;FVector2D&gt;&amp; points, <span class="hljs-keyword">float</span>&amp; max_x, <span class="hljs-keyword">float</span>&amp; max_y, <span class="hljs-keyword">int</span>&amp; len)</span></span><br><span class="hljs-function"></span>&#123;<br>max_x = points[<span class="hljs-number">0</span>].X;<br>max_y = points[<span class="hljs-number">0</span>].Y;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (max_x &lt; points[i].X)<br>&#123;<br>max_x = points[i].X;<br>&#125;<br><span class="hljs-keyword">if</span> (max_y &lt; points[i].Y)<br>&#123;<br>max_y = points[i].Y;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ACustomSelectActor::GetMin</span><span class="hljs-params">(TArray&lt;FVector2D&gt;&amp; points, <span class="hljs-keyword">float</span>&amp; min_x, <span class="hljs-keyword">float</span>&amp; min_y, <span class="hljs-keyword">int</span>&amp; len)</span></span><br><span class="hljs-function"></span>&#123;<br>min_x = points[<span class="hljs-number">0</span>].X;<br>min_y = points[<span class="hljs-number">0</span>].Y;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (min_x &gt; points[i].X)<br>&#123;<br>min_x = points[i].X;<br>&#125;<br><span class="hljs-keyword">if</span> (min_y &gt; points[i].Y)<br>&#123;<br>min_y = points[i].Y;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ACustomSelectActor::SpwanVertArr</span><span class="hljs-params">(TArray&lt;FVector2D&gt;&amp; polygonPoints, TArray&lt;<span class="hljs-keyword">float</span>&gt;&amp; vertx, TArray&lt;<span class="hljs-keyword">float</span>&gt;&amp; verty, <span class="hljs-keyword">int</span>&amp; len)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br>vertx.Add(polygonPoints[i].X);<br>verty.Add(polygonPoints[i].Y);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ACustomSelectActor::PNPoly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nvert, TArray&lt;<span class="hljs-keyword">float</span>&gt; vertx, TArray&lt;<span class="hljs-keyword">float</span>&gt; verty, <span class="hljs-keyword">float</span> testx, <span class="hljs-keyword">float</span> testy)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">bool</span> ret = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = nvert - <span class="hljs-number">1</span>; i &lt; nvert; j = i++)<br>&#123;<br><span class="hljs-keyword">if</span> (((verty[i] &gt; testy) != (verty[j] &gt; testy)) &amp;&amp; (testx &lt; (vertx[j] - vertx[i]) * (testy - verty[i]) / (verty[j] - verty[i]) + vertx[i]))<br>&#123;<br>ret = !ret;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ACustomSelectActor::GetFBoxPointsSet</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;FBoxPointSet&gt;&amp; fboxPointsArr,</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;AActor*&gt;&amp; actorArr,</span></span><br><span class="hljs-function"><span class="hljs-params">TSubclassOf&lt;AActor&gt;&amp; classFilter,</span></span><br><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span>&amp; bIncludeNonCollidingComponents,</span></span><br><span class="hljs-function"><span class="hljs-params">APlayerController * player_ctrl)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (TActorIterator&lt;AActor&gt; Itr(GWorld-&gt;GetWorld(), classFilter); Itr; ++Itr)<br>&#123;<br>AActor* EachActor = *Itr;<br><span class="hljs-keyword">const</span> FBox EachActorBounds = Cast&lt;AActor&gt;(EachActor)-&gt;GetComponentsBoundingBox(bIncludeNonCollidingComponents);<br><span class="hljs-keyword">const</span> FVector BoxCenter = EachActorBounds.GetCenter();<br><span class="hljs-keyword">const</span> FVector BoxExtents = EachActorBounds.GetExtent();<br><span class="hljs-function">FBox2D <span class="hljs-title">ActorBox2D</span><span class="hljs-params">(ForceInit)</span></span>;<br>fboxPointsArr.Add(FBoxPointSet());<br><span class="hljs-keyword">for</span> (uint8 BoundsPointItr = <span class="hljs-number">0</span>; BoundsPointItr &lt; <span class="hljs-number">8</span>; BoundsPointItr++)<br>&#123;<br>FVector2D ScreenPos;<br><span class="hljs-keyword">if</span> (ProjectWorldLocationToWidgetPosition(player_ctrl, BoxCenter + (BoundsPointMapping[BoundsPointItr] * BoxExtents), ScreenPos))<br>&#123;<br>ActorBox2D += ScreenPos;<br>fboxPointsArr[i].points[BoundsPointItr + <span class="hljs-number">1</span>] = ScreenPos;<br>&#125;<br>&#125;<br>fboxPointsArr[i].points[<span class="hljs-number">0</span>] = ActorBox2D.GetCenter();<br>actorArr.Add(EachActor);<br>i++;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ACustomSelectActor::GetActorsRefByPointsSet</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;AActor*&gt;&amp; outActors,</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;<span class="hljs-keyword">float</span>&gt;&amp; vertx,</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;<span class="hljs-keyword">float</span>&gt;&amp; verty,</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;FBoxPointSet&gt;&amp; fboxPointsArr,</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;AActor*&gt;&amp; actorArr,</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;FVector2D&gt;&amp; polygonPoints,</span></span><br><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span>&amp; len)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> fboxlen = fboxPointsArr.Num();<br><span class="hljs-keyword">int</span> pointslen = polygonPoints.Num();<br><span class="hljs-keyword">float</span> max_x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">float</span> max_y = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">float</span> min_x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">float</span> min_y = <span class="hljs-number">0</span>;<br>GetMax(polygonPoints, max_x, max_y, len);<br>GetMin(polygonPoints, min_x, min_y, len);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; fboxlen; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; ActorSamplingPoints; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (fboxPointsArr[i].points[j].X&lt;min_x || fboxPointsArr[i].points[j].X&gt;max_x ||<br>fboxPointsArr[i].points[j].Y&lt;min_y || fboxPointsArr[i].points[j].Y&gt;max_y)<br>&#123;<br><span class="hljs-keyword">break</span>;<br>j = ActorSamplingPoints;<br>&#125;<br><span class="hljs-keyword">if</span> (PNPoly(len, vertx, verty, fboxPointsArr[i].points[j].X, fboxPointsArr[i].points[j].Y))<br>&#123;<br>outActors.Add(actorArr[i]);<br>j = ActorSamplingPoints;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ACustomSelectActor::CustomSelect</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;AActor*&gt;&amp; outActors,</span></span><br><span class="hljs-function"><span class="hljs-params">TArray&lt;FVector2D&gt; polygonPoints,</span></span><br><span class="hljs-function"><span class="hljs-params">TSubclassOf&lt;AActor&gt; classFilter,</span></span><br><span class="hljs-function"><span class="hljs-params">APlayerController * player_ctrl,</span></span><br><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span> bIncludeNonCollidingComponents)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> len = polygonPoints.Num();<br><span class="hljs-keyword">if</span> (len &lt; LeastPointNum)<br>&#123;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Polygon has too few points&quot;</span>));<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>TArray&lt;<span class="hljs-keyword">float</span>&gt; vertx;<br>TArray&lt;<span class="hljs-keyword">float</span>&gt; verty;<br>SpwanVertArr(polygonPoints, vertx, verty, len);<br>TArray&lt;AActor*&gt; actorArr;<br>TArray&lt;FBoxPointSet&gt; fboxPointsArr;<br>GetFBoxPointsSet(fboxPointsArr, actorArr, classFilter, bIncludeNonCollidingComponents, player_ctrl);<br>GetActorsRefByPointsSet(outActors, vertx, verty, fboxPointsArr, actorArr, polygonPoints, len);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">ACustomSelectActor::CompuePolygonArea</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TArray&lt;FVector2D&gt; polygonPoints)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> point_num = polygonPoints.Num();<br><span class="hljs-keyword">if</span> (point_num &lt; <span class="hljs-number">3</span>)<br>&#123;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;The area is not polygon!&quot;</span>));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<br>&#125;<br><span class="hljs-keyword">double</span> s = polygonPoints[<span class="hljs-number">0</span>].Y * (polygonPoints[point_num - <span class="hljs-number">1</span>].X - polygonPoints[<span class="hljs-number">1</span>].X);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; point_num; ++i)<br>s += polygonPoints[i].Y * (polygonPoints[i - <span class="hljs-number">1</span>].X - polygonPoints[(i + <span class="hljs-number">1</span>) % point_num].X);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">fabs</span>(s / <span class="hljs-number">2.0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p><code>BoundsPointMapping[8]</code>用于确定场景中Actor的边界盒子的8个点。</p></li><li><p>结构体FBoxPointSet是用来存储采样点集的数据结构，这里我取Actor边界盒子的8个点加中点一共9个点作为采样点集。</p></li><li><p>GetMax和GetMin计算多边形点集的横纵坐标的最大值和最小值。</p></li><li><p>SpawnVertArr负责将多边形点集分成横坐标点集和纵坐标点集。</p></li><li><p>PNPoly函数使用PNPoly算法判断一个点是否在多边形内部。</p></li><li><p>ProjectWorldLocationToWidgetPosition函数是一个由C++父类声明，由蓝图子类实现的函数，负责将场景中的Actor的边界盒子的点的空间坐标投影到屏幕坐标。之所以使用这种方式是因为ProjectWorldLocationToWidgetPosition蓝图节点没有C++版本，而必须使用ProjectWorldLocationToWidgetPosition蓝图节点的原因是ProjectWorldLocationToWidgetPosition蓝图节点投影出来的坐标会根据屏幕尺寸变化而自动适应，其他的空间坐标转屏幕坐标的蓝图节点在非全屏与全屏下会出现位置偏移。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180923.png" alt="在这里插入图片描述"><br>所以这里需要创建一个继承自CustomSelectActor的蓝图子类来重写ProjectWorldLocationToWidgetPosition函数。</p></li><li><p>GetFBoxPointsSet函数负责获取世界中所有Actor的采样点集。</p></li><li><p>GetActorsRefByPointsSet函数负责使用PNPoly函数取在多边形内部的Actor的引用。</p></li><li><p>CustomSelect函数否则暴漏给蓝图提供数据输入输出的接口。</p></li><li><p>CompuePolygonArea函数负责计算多边形的面积，目前还有一些问题，暂时不用理睬。</p></li></ul><p>至此多边形框选功能就完全实现了。来看一下效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180929.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180935.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180942.png" alt="在这里插入图片描述"></p><h1 id="四、将功能包成UE4插件"><a href="#四、将功能包成UE4插件" class="headerlink" title="四、将功能包成UE4插件"></a>四、将功能包成UE4插件</h1><p>如果需要将功能打包成插件，那么就需要将CustomSelectActor的C++类创建在插件里。</p><h2 id="1-创建一个空插件"><a href="#1-创建一个空插件" class="headerlink" title="1.创建一个空插件"></a>1.创建一个空插件</h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180952.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180958.png" alt="在这里插入图片描述"></p><p>创建之后需要在VS中编一下项目，然后关闭引擎，重新打开项目，以便引擎重新加载dll文件，因为插件不属于引擎的一部分，所以引擎没办法直接热加载插件内容。</p><h2 id="2-在插件文件夹下创建C-类"><a href="#2-在插件文件夹下创建C-类" class="headerlink" title="2.在插件文件夹下创建C++类"></a>2.在插件文件夹下创建C++类</h2><p>我们需要将CustomSelectActor类创建在插件文件夹下，创建好空插件后，再创建C++类时可以选择创建文件夹。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514181004.png" alt="在这里插入图片描述"><br>然后按一、二、三的步骤实现功能即可。</p><h2 id="3-打包插件"><a href="#3-打包插件" class="headerlink" title="3.打包插件"></a>3.打包插件</h2><p>进入插件管理点集打包</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514181009.png" alt="在这里插入图片描述"><br>至此插件就打包好了。</p><p>参考博客：<br><a href="https://blog.csdn.net/weixin_36369675/article/details/88419361">https://blog.csdn.net/weixin_36369675/article/details/88419361</a><br><a href="https://www.cnblogs.com/anningwang/p/7581545.html">https://www.cnblogs.com/anningwang/p/7581545.html</a><br><a href="https://www.cnblogs.com/TenosDoIt/p/4047211.html">https://www.cnblogs.com/TenosDoIt/p/4047211.html</a></p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE4】UE4基于Spline的测距功能</title>
    <link href="/2021/05/14/%E3%80%90UE4%E3%80%91UE4%E5%9F%BA%E4%BA%8ESpline%E7%9A%84%E6%B5%8B%E8%B7%9D%E5%8A%9F%E8%83%BD/"/>
    <url>/2021/05/14/%E3%80%90UE4%E3%80%91UE4%E5%9F%BA%E4%BA%8ESpline%E7%9A%84%E6%B5%8B%E8%B7%9D%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="基于Spline的测距功能插件"><a href="#基于Spline的测距功能插件" class="headerlink" title="基于Spline的测距功能插件"></a>基于Spline的测距功能插件</h1><a id="more"></a><h1 id="一、功能分析"><a href="#一、功能分析" class="headerlink" title="一、功能分析"></a>一、功能分析</h1><p>这里首先分析一下整个插件的功能部件</p><ul><li><p>SplineActor—基于Spline的线条显示模块</p></li><li><p>Ranging—对整个插件功能的整体控制</p></li><li><p>DistancePanel—距离显示UI</p></li><li><p>Point—线上的点，集成DistancePanel</p></li><li><p>FunLib—高复用函数集合</p><p>资产状况：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174241.png" alt="在这里插入图片描述"></p></li></ul><p>由于使用屏幕坐标转世界坐标的方式实现测距功能可能及其复杂，所以这里使用比较直观简便的三维Spline来实现测距功能。</p><h1 id="二、制作线上的点Point"><a href="#二、制作线上的点Point" class="headerlink" title="二、制作线上的点Point"></a>二、制作线上的点Point</h1><h2 id="1-Point的结构分析"><a href="#1-Point的结构分析" class="headerlink" title="1.Point的结构分析"></a>1.Point的结构分析</h2><p>Point是一个拥有StaticMesh和WedgitComponent组件的Actor，StaticMesh我这里使用Shape，Materials是自己做的一个发光材质。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174247.png" alt="在这里插入图片描述"></p><h2 id="2-MeshMeterial材质"><a href="#2-MeshMeterial材质" class="headerlink" title="2.MeshMeterial材质"></a>2.MeshMeterial材质</h2><p>Materials蓝图：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174258.png" alt="在这里插入图片描述"></p><h2 id="3-Point核心函数实现"><a href="#3-Point核心函数实现" class="headerlink" title="3.Point核心函数实现"></a>3.Point核心函数实现</h2><p>Point主要实现一个函数两个事件</p><ul><li>函数ShowDistance—负责距离显示</li><li>事件InitFontInfo—负责获取初始字体信息</li><li>事件ShowText—控制距离是否显示</li></ul><p>在构造函数需要记录DistancePanel的初始位置信息和初始字体信息。</p><p>ConstructScript：记录DistancePanel的初始位置信息和初始字体信息</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174305.png" alt="在这里插入图片描述"></p><p>InitFontInfo：记录字体的初始信息</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174317.png" alt="在这里插入图片描述"></p><p>ShowText：设置显示字体的大小。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174323.png" alt="在这里插入图片描述"></p><p>Tick函数：SetActorRotation设置点上的文字跟随摄像机旋转使之始终面向摄像机，GetMouseLocation-&gt;SetActorLocation-&gt;ShowText当SureLocation为false时即未确定点的位置时设置点跟随鼠标移动，当点跟随鼠标移动时不显示距离。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174329.png" alt="在这里插入图片描述"></p><ul><li>FontInfo：是一个SlateFontInfoStructure结构体用于设置距离显示的字体样式。</li><li>SureLocation：bool变量，确认点是否已经确定了位置坐标，当点没有确定位置坐标时，点将跟随鼠标移动。</li><li>InitScale3D：Vector变量，保存DistancePanel的初始大小。</li><li>SureAdsorb：bool变量，控制闭环吸附，当为true时，起点具有吸附功能，可以将终点吸附到起点位置实现闭环。</li></ul><p>ShowDistance：将输入的距离信息显示出来。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174336.png" alt="在这里插入图片描述"></p><p>至此点的设计完毕。</p><h1 id="三、用于显示的Widget"><a href="#三、用于显示的Widget" class="headerlink" title="三、用于显示的Widget"></a>三、用于显示的Widget</h1><p>创建一个UserWidget命名为DistancePanel，DistancePanel比较简单，CanvasPanel下就一个Text即可，只有一个函数UpdateTextScale，然后在EventConstruct中记录Text的初始大小。</p><p>EventConstruct：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174342.png" alt="在这里插入图片描述"></p><p>UpdateTextScale：更新Text的大小，使Text跟随摄像机距离地板的远近变大变小，以保证Text的大小在视野中保持不变。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174347.png" alt="在这里插入图片描述"></p><h1 id="三、使用Spline制作线段"><a href="#三、使用Spline制作线段" class="headerlink" title="三、使用Spline制作线段"></a>三、使用Spline制作线段</h1><h2 id="1-SplineActor结构分析"><a href="#1-SplineActor结构分析" class="headerlink" title="1.SplineActor结构分析"></a>1.SplineActor结构分析</h2><p>Spline是UE4的样条线组件，Spline是一组点和线的集合，但是Spline的点和线只有在编辑模式下可见，在运行模式下不可见，Spline可以通过选中其中的点按下Alt键并拖动鼠标来添加新的点。</p><p>我们需要一个Actor作为Spline的载体，创建一个Actor命名为Spline。Spline的组件结构为：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174354.png" alt="在这里插入图片描述"></p><ul><li>StaticMesh：使用Shape和自定义的材质，这个Mesh作为起点使用。</li><li>Spline：样条线组件，此Actor的核心组件。</li><li>Sphere：球型触发器，用于起点吸附。</li></ul><h2 id="2-在编辑模式下实现Spline编辑"><a href="#2-在编辑模式下实现Spline编辑" class="headerlink" title="2.在编辑模式下实现Spline编辑"></a>2.在编辑模式下实现Spline编辑</h2><p>在编辑模式下实现样条线的编辑需要在构造函数中实现下面的逻辑：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174403.png" alt="在这里插入图片描述"></p><p>核心函数分析：</p><ul><li><p>AddSplineMeshComponent：这是一个自定义的封装函数，作用就是提高复用率，</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174410.png" alt="在这里插入图片描述"></p></li></ul><p>  StaticMesh决定线的样式，Meterial决定线的颜色；</p><ul><li><p>AttachToMeshComponent：将添加的SplineMeshComponent组件设置StaticMesh为父节点；</p></li><li><p>Set Start and End：函数根据Get LocationandTangentatSplinePoint函数获取的起点和终点的位置和切角，将生成的SplineMeshComponent组件附着在上面。</p></li></ul><p>这样我们的Spline样条线就被设置成了我们设定的模样，并且在运行时可见。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174417.png" alt="在这里插入图片描述"></p><h2 id="3-运行时动态添加Spline的点"><a href="#3-运行时动态添加Spline的点" class="headerlink" title="3.运行时动态添加Spline的点"></a>3.运行时动态添加Spline的点</h2><p>由于在运行模式下无法像在编辑模式下通过Alt键拖动点来添加Spline的点，所以我们需要通过蓝图来实现。这项功能封装在AddPoint函数中。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174423.png" alt="在这里插入图片描述"></p><p>AddPoint函数通过输入的坐标位置动态生成Spline的点</p><ul><li>AddSplinePoint：向Spline中添加新的点；</li><li>SpawnActorPoint：目的是在Spline的生成的新点的位置处生成一个具象化的Point；</li><li>Sequence的的Then0分支作用是当生成一个新的Point时，确定上一个Point的位置坐标；</li><li>PointArray是一个Point类型的数组，用于存储生成的Point的引用，SplineMeshComponentArray是一个SplineMeshComponent类型的数组，用于存储生成的SplineMeshComponent组件的引用，两个数组的作用是方便之后对Point和SplineMeshComponent的操作。</li><li>AddSplineMeshComponent、AttachToComponent和SetSartandEnd函数作用和构造函数中一样；</li><li>UpddateTotaldistance函数用于更新距离显示，具体实现在后面介绍。</li></ul><p>AddPoint函数在AddPointEvent事件中调用。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174433.png" alt="在这里插入图片描述"></p><ul><li>GetMouseLocation是FunLib库中的一个函数负责获取鼠标坐在的屏幕坐标转换成空间坐标。</li></ul><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174439.png" alt="在这里插入图片描述"></p><h2 id="4-实时更新样条线"><a href="#4-实时更新样条线" class="headerlink" title="4.实时更新样条线"></a>4.实时更新样条线</h2><p>实时更新样条线的功能封装在UpdateCurrentSplinePoint函数中。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174446.png" alt="在这里插入图片描述"></p><p>UpdateCurrentSplinePoint函数在SplineActor的Tick函数中调用，每帧删除前一个Spline的点，在新的坐标位置下添加一个新的Spline的点，由于Point是跟随鼠标移动的，所以通过这个操作在宏观上的表现就是Spline的点在跟随鼠标一点，之所以使用这种方式，是因为Spline中的点似乎没办法直接修改位置。</p><p>每帧设置好位置之后再重新渲染一遍Mesh组件，就达到如下效果了：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174453.gif" alt="在这里插入图片描述"></p><p>这样在运行状态下编辑Spline样条线就制作完成了。</p><h1 id="四、实时更新距离"><a href="#四、实时更新距离" class="headerlink" title="四、实时更新距离"></a>四、实时更新距离</h1><p>实时更新距离的功能封装在UpdateTotalDistance函数下。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174502.png" alt="在这里插入图片描述"></p><ul><li>Ranging变量就是Ranging类型，存储Ranging的引用，在重新计算总距离前先将存储中距离的变量TotalDistance清零；</li><li>然后一次取PointArray中的Point来计算Point与Point之间的距离，0号索引的Point较为特殊需要与其他索引的Point分开计算，因为0号索引的Point需要与SplineActor的位置计算距离；</li><li>ShowDistance函数封装在Point类中，负责将输入的距离显示出来。</li></ul><p>显示总距离专门创建了一个DistancePanel来显示。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514174508.png" alt="在这里插入图片描述"></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180451.png" alt="在这里插入图片描述"></p><ul><li>HiddenTotalDistance控制总距离是否显示。</li></ul><p>到这里基本的功能就基本实现了，下面实现一些必要的附加功能。</p><h1 id="五、封装Ranging类"><a href="#五、封装Ranging类" class="headerlink" title="五、封装Ranging类"></a>五、封装Ranging类</h1><p>由于SplineActor类是插件的核心类，不宜对外开放调用接口，且SplineActor类自身拥有Mesh，直接拖入场景中会显示Mesh，效果不佳，所以在SplineActor之外再封装一成没有Mesh的Ranging是十分必要的，有Ranging类提供对外调用的接口。</p><p>Ranging类的封装函数和变量：<br><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180459.png" alt="在这里插入图片描述"></p><ul><li><p>SetupRanging：启动测距，在鼠标所在位置生成SplineActor；</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180504.png" alt="在这里插入图片描述"></p></li></ul><ul><li>AddPoint：封装SplineActor中的AddPointEvent事件；</li></ul><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180511.png" alt="在这里插入图片描述"></p><ul><li>EndRanging：结束测距，封装ActorSpline的DeleteLastPoint函数，函数的具体实现在之后介绍；</li></ul><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180516.png" alt="在这里插入图片描述"></p><ul><li><p>Remove：删除所有的点线，封装SplineActor的RemoveAllPoint函数，函数的具体实现在之后介绍；</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180522.png" alt="在这里插入图片描述"></p></li></ul><ul><li><p>SplineActor：存储SplineActor的引用；</p></li><li><p>TotalDistance：存储总距离的值；</p></li><li><p>DistanceUint：显示总距离时的单位；</p></li><li><p>K：存储SplineActor中DistancePanel随相机距离变化大小的变化倍率；我这里设定的值为0.0002。</p></li></ul><p>文字随相机距离变化的函数实现封装在Ranging的UpdeteDistancePanelScale事件中，事件在Ranging的Tick函数中调用。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180542.png" alt="在这里插入图片描述"></p><h1 id="六、保持Point的DistancePanel组件的大小不变"><a href="#六、保持Point的DistancePanel组件的大小不变" class="headerlink" title="六、保持Point的DistancePanel组件的大小不变"></a>六、保持Point的DistancePanel组件的大小不变</h1><p>为了保证观感效果，Point的显示距离的DistancePanel组件的大小应该跟随相机的远近保持保持一定的大小，以保证相机贴近地面时，文字不会过大，相机原理地面时文字不过过小而看不见。</p><p>实现原理就在Ranging的UpdateDistancePanelScale事件中。</p><h1 id="七、返回上一步功能"><a href="#七、返回上一步功能" class="headerlink" title="七、返回上一步功能"></a>七、返回上一步功能</h1><p>当我们确定点的位置时会出现位置确定错误的情况，所以返回上一步的功能也是十分必要的，具体实现在SplineActor的DeleteLastPoint函数中。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180550.png" alt="在这里插入图片描述"></p><p>原理是移除上一个Spline的点和其匹配的Point、SplineMeshComponent并删除数组中对应的元素，然后更新一次距离，如果剩下最后一个点时，再撤回就直接将SplineActor删除并把显示总距离的DistancePanel移除，防止再创建SplineActor时再生成一个DiatancePanel而出现两个DistancePanel。</p><h1 id="八、移除所有的点"><a href="#八、移除所有的点" class="headerlink" title="八、移除所有的点"></a>八、移除所有的点</h1><p>当测距完成后需要清除所有的点，所以此功能也是必要的，具体实现在SplineActor的RemoveAllPoint中。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180557.png" alt="在这里插入图片描述"></p><h1 id="九、起点吸附功能"><a href="#九、起点吸附功能" class="headerlink" title="九、起点吸附功能"></a>九、起点吸附功能</h1><p>起点吸附是为了实现闭环。具体实现在SplineActor的EventActorBeginOverlap事件中。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180603.png" alt="在这里插入图片描述"></p><p>原理就是当SplineActor的Sphere触发器检测到Point时将此Point的坐标设置到起点的坐标处。</p><h1 id="九、整体效果预览"><a href="#九、整体效果预览" class="headerlink" title="九、整体效果预览"></a>九、整体效果预览</h1><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514180609.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【BAT】BATWindows自动脚本同步GitHUb远程仓库</title>
    <link href="/2021/05/14/%E3%80%90BAT%E3%80%91BATWindows%E8%87%AA%E5%8A%A8%E8%84%9A%E6%9C%AC%E5%90%8C%E6%AD%A5GitHUb%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
    <url>/2021/05/14/%E3%80%90BAT%E3%80%91BATWindows%E8%87%AA%E5%8A%A8%E8%84%9A%E6%9C%AC%E5%90%8C%E6%AD%A5GitHUb%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><a id="more"></a><p>Windows自动脚本，我已自动同步GitHub仓库为例。</p><p>先上源码，可以直接用TXT写，然后将文件后缀改为.bat。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">start &quot;C:\Windows\System32\cmd.exe&quot;<br>G:<br>cd Git\Temp<br>git add .<br>git commit -m &quot;From Auto Updata&quot;<br>git push<br>pause<br>taskkill /f /im cmd.exe<br></code></pre></td></tr></table></figure><ul><li>start “C:\Windows\System32\cmd.exe”：打开Windows CMD控制台</li><li>G：切换到G盘，因为我的Git仓库放在G盘</li><li>cd Git\Temp：进入远程仓库所在的文件夹Temp，我的远程仓库放在G:/Goulandis/Git/Temp文件夹下</li><li><code>git add .</code>到<code>git push</code>是git同步远程仓库的命令</li><li>pause：pause命令用于暂停命令继续执行，本例中可有可无，这里加上主要是为了方便查看执行过程</li><li>taskkill /f /im cmd.exe：自动关闭CMD</li></ul><p>将文件后缀改为.bat之后，再将文件放入G:Goulandis(这是我电脑的路径)，这是根据cd Git\Temp决定的，我的Git文件夹就在G:Goulandis文件夹下，所以我将脚本放在G:Goulandis文件夹下，当然若觉得麻烦，也可直接将脚本放在Temp文件下，也就是仓库的.git文件夹所在的文件夹下，这时就不需要进行盘符和文件夹切换了，即上面代码中第二第三行删除。</p><p>双击运行，测试一下执行效果：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171713.png"></p><p>如果自动脚本很多的话，有一种更便捷的方法，就是专门为自动脚本创建一个文件夹，然后将其路径添加进环境变量中</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BAT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE4】UE4使用蓝图动态修改粒子参数</title>
    <link href="/2021/05/14/%E3%80%90UE4%E3%80%91UE4%E4%BD%BF%E7%94%A8%E8%93%9D%E5%9B%BE%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E7%B2%92%E5%AD%90%E5%8F%82%E6%95%B0/"/>
    <url>/2021/05/14/%E3%80%90UE4%E3%80%91UE4%E4%BD%BF%E7%94%A8%E8%93%9D%E5%9B%BE%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E7%B2%92%E5%AD%90%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><a id="more"></a><p>如果对UE4联级粒子P_Water系统比较熟悉的可能对动态修改粒子参数不陌生。</p><p>UE4的联级粒子系统大部分的模块都拥有一个<font color="red"> Distribution</font>子栏，其中可以选择如下模式</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171010.png"></p><p>其中<font color="red"> Distribution Vector Particle Parameter</font>就是参数模式，选择之后Distribution栏会变成这样</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171019.png"></p><p>其中Parameter Name就是参数的名字，在蓝图调用参数时需要用到。Min Input、Max Input、Min Output、Max Output分别限制参数的的最小输入、最大输入、最小输出、最大输出。</p><p>UE4的粒子系统提供8中类型的参数供外部控制：</p><ul><li>Actor Parameters</li><li>Auto Attachment Parameters</li><li>Color Parameters</li><li>Float Parameters</li><li>Float Rand Parameters</li><li>Material Parameters</li><li>Vector Parameters</li><li>Vector Rand Parameters</li></ul><p>8中参数类型的用法是一样的，这里我们以Vector Parameters，用以修改粒子的发射速度Initial Velocity为例。</p><p>首先将Initial Velocity模块的的Velocity/Start Velocity/Distribution选择Distribution Vector Particle Parameter模式，在Parameter Name栏设置参数名字为WaterSpeed，再设置好输入输出限制。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171025.png"></p><p>然后就可以在蓝图中使用这个参数了，首先打开关卡蓝图，我这里创建一个专门的函数SetWaterSpeed用来修改这个参数，蓝图脚本如下：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171031.png"></p><p>P_Water是放在场景中的粒子系统，获取粒子系统的ParticleSystemComponent粒子系统组件，这样就可以通过Set Vector Parameter函数来获取组上指定名字的参数了，由于Set Vector Parameter是按名字来获取参数的，所以同一种类型参数尽量不要重名。</p><p>然后进行函数调用。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171037.png"></p><p>测试一下粒子发射速度是否改变</p><p>初始状态</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171043.png"></p><p>按下Up键后</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171051.png"></p><p>按下Down键后</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171059.png"></p><p>目前尚未找到如何读取粒子系统的参数的方法。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE4】UE4内嵌Web及与Web通信</title>
    <link href="/2021/05/14/%E3%80%90UE4%E3%80%91UE4%E5%86%85%E5%B5%8CWeb%E5%8F%8A%E4%B8%8EWeb%E9%80%9A%E4%BF%A1/"/>
    <url>/2021/05/14/%E3%80%90UE4%E3%80%91UE4%E5%86%85%E5%B5%8CWeb%E5%8F%8A%E4%B8%8EWeb%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><a id="more"></a><p>UE4嵌入Web及UE4到Web的通信，我使用UE 4.22.3版本，以UE4嵌入ECharts并与ECharts通信为例。</p><h1 id="一、自定义WebBrowser"><a href="#一、自定义WebBrowser" class="headerlink" title="一、自定义WebBrowser"></a>一、自定义WebBrowser</h1><p>UwebBrowser是UE4自带的用于浏览Web的插件类，为了后面进行UE4与Web的通信，所以这里我们需要自定义一个UWebBrowser类。</p><h2 id="1-创建自定义WebBrowser类"><a href="#1-创建自定义WebBrowser类" class="headerlink" title="1.创建自定义WebBrowser类"></a>1.创建自定义WebBrowser类</h2><p>在C++ Classes中右键创建一个自己的继承自widget类的C++类–MyWebBrowser。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170722.png"></p><h2 id="2-编写自定义WebBrowser"><a href="#2-编写自定义WebBrowser" class="headerlink" title="2.编写自定义WebBrowser"></a>2.编写自定义WebBrowser</h2><p>然后在VS中搜索WebBrowser.cpp和WebBrowser.h这是UE4自带的WebBrowser类，虽说是写一个自定义的WebBrowser，但是我们的自定义的WebBrowser在功能上基本和UE4自带的webBrowser一致，所以我们只需将UE4自带的WebBrowser中的代码拷贝到我们自己的MyWebBrowser中稍作修改即可。</p><p>当然拷贝时不是全盘拷贝，只需拷贝如下WebBrowser.h中虚线以下的部分拷贝到我们的MyWebBrowser.h中。有时可能出现FOnUrlChanged和FOnBeforePopup报错，等VS反应一下就好了，有时可以直接编译，报红也是可以编译通过的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*WebBrowser.h*/</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Components/Widget.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;WebBrowser.generated.h&quot;</span></span><br><br>UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WEBBROWSERWIDGET_API</span> <span class="hljs-title">UWebBrowser</span> :</span> <span class="hljs-keyword">public</span> UWidget<br>&#123;<br>    <span class="hljs-comment">/*--------------------------------------------------------------------------------------*/</span><br>GENERATED_UCLASS_BODY()<br><br><span class="hljs-keyword">public</span>:<br>DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnUrlChanged, <span class="hljs-keyword">const</span> FText&amp;, Text);<br>DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnBeforePopup, FString, URL, FString, Frame);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Load the specified URL</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param NewURL New URL to load</span><br><span class="hljs-comment"> */</span><br>UFUNCTION(BlueprintCallable, Category=<span class="hljs-string">&quot;Web Browser&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoadURL</span><span class="hljs-params">(FString NewURL)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Load a string as data to create a web page</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param Contents String to load</span><br><span class="hljs-comment"> * @param DummyURL Dummy URL for the page</span><br><span class="hljs-comment"> */</span><br>UFUNCTION(BlueprintCallable, Category=<span class="hljs-string">&quot;Web Browser&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoadString</span><span class="hljs-params">(FString Contents, FString DummyURL)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Executes a JavaScript string in the context of the web page</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* @param ScriptText JavaScript string to execute</span><br><span class="hljs-comment">*/</span><br>UFUNCTION(BlueprintCallable, Category = <span class="hljs-string">&quot;Web Browser&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ExecuteJavascript</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString&amp; ScriptText)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Get the current title of the web page</span><br><span class="hljs-comment"> */</span><br>UFUNCTION(BlueprintCallable, Category=<span class="hljs-string">&quot;Web Browser&quot;</span>)<br><span class="hljs-function">FText <span class="hljs-title">GetTitleText</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Gets the currently loaded URL.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* @return The URL, or empty string if no document is loaded.</span><br><span class="hljs-comment">*/</span><br>UFUNCTION(BlueprintCallable, Category = <span class="hljs-string">&quot;Web Browser&quot;</span>)<br><span class="hljs-function">FString <span class="hljs-title">GetUrl</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br><br><span class="hljs-comment">/** Called when the Url changes. */</span><br>UPROPERTY(BlueprintAssignable, Category = <span class="hljs-string">&quot;Web Browser|Event&quot;</span>)<br>FOnUrlChanged OnUrlChanged;<br><br><span class="hljs-comment">/** Called when a popup is about to spawn. */</span><br>UPROPERTY(BlueprintAssignable, Category = <span class="hljs-string">&quot;Web Browser|Event&quot;</span>)<br>FOnBeforePopup OnBeforePopup;<br><br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-comment">//~ Begin UWidget interface</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SynchronizeProperties</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-comment">// End UWidget interface</span><br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ReleaseSlateResources</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> bReleaseChildren)</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> WITH_EDITOR</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">const</span> FText <span class="hljs-title">GetPaletteCategory</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-comment">/** URL that the browser will initially navigate to. The URL should include the protocol, eg http:// */</span><br>UPROPERTY(EditAnywhere, Category=Appearance)<br>FString InitialURL;<br><br><span class="hljs-comment">/** Should the browser window support transparency. */</span><br>UPROPERTY(EditAnywhere, Category=Appearance)<br><span class="hljs-keyword">bool</span> bSupportsTransparency;<br><br><span class="hljs-keyword">protected</span>:<br>TSharedPtr&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SWebBrowser</span>&gt;</span> WebBrowserWidget;<br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-comment">// UWidget interface</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> TSharedRef&lt;SWidget&gt; <span class="hljs-title">RebuildWidget</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-comment">// End of UWidget interface</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HandleOnUrlChanged</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FText&amp; Text)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">HandleOnBeforePopup</span><span class="hljs-params">(FString URL, FString Frame)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>WebBrowser.cpp则是全盘拷贝到我们的MyWebBrowser.cpp中，然后将所有的UWebBrowser修改为UMyWebBrowser，将#include “WebBrowser.h”改为我们自己的#include “MyWebBrowser.h”即可。</p><p>这里需要注意，有时会因为引擎位置不同导致#include “SWebBrowser.h”头文件打不开，此时我们需要给SWebBrowser.h一个路径即可，如：#include “Runtime/WebBrowser/Public/SWebBrowser.h”。</p><p>然后如下的代码中的Experimental，可以改也可以不改，这段代码主要控制我们自定义的MyWebBrowser显示在UI的Palette中的分栏位置，这里我都改为My。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> WITH_EDITOR</span><br><br><span class="hljs-function"><span class="hljs-keyword">const</span> FText <span class="hljs-title">UWebBrowser::GetPaletteCategory</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> LOCTEXT(<span class="hljs-string">&quot;Experimental&quot;</span>, <span class="hljs-string">&quot;Experimental&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>然后就可以编译了。</p><h2 id="3-完整代码"><a href="#3-完整代码" class="headerlink" title="3.完整代码"></a>3.完整代码</h2><p>这里贴出完整代码，供参考。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*MyWebBrowser.h*/</span><br><br><span class="hljs-comment">// Fill out your copyright notice in the Description page of Project Settings.</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Components/Widget.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;MyWebBrowser.generated.h&quot;</span></span><br><br>UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WEBTEST_API</span> <span class="hljs-title">UMyWebBrowser</span> :</span> <span class="hljs-keyword">public</span> UWidget<br>&#123;<br>GENERATED_UCLASS_BODY()<br><br><span class="hljs-keyword">public</span>:<br>DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnUrlChanged, <span class="hljs-keyword">const</span> FText&amp;, Text);<br>DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnBeforePopup, FString, URL, FString, Frame);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Load the specified URL</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param NewURL New URL to load</span><br><span class="hljs-comment"> */</span><br>UFUNCTION(BlueprintCallable, Category = <span class="hljs-string">&quot;Web Browser&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoadURL</span><span class="hljs-params">(FString NewURL)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Load a string as data to create a web page</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param Contents String to load</span><br><span class="hljs-comment"> * @param DummyURL Dummy URL for the page</span><br><span class="hljs-comment"> */</span><br>UFUNCTION(BlueprintCallable, Category = <span class="hljs-string">&quot;Web Browser&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoadString</span><span class="hljs-params">(FString Contents, FString DummyURL)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Executes a JavaScript string in the context of the web page</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* @param ScriptText JavaScript string to execute</span><br><span class="hljs-comment">*/</span><br>UFUNCTION(BlueprintCallable, Category = <span class="hljs-string">&quot;Web Browser&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ExecuteJavascript</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString&amp; ScriptText)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Get the current title of the web page</span><br><span class="hljs-comment"> */</span><br>UFUNCTION(BlueprintCallable, Category = <span class="hljs-string">&quot;Web Browser&quot;</span>)<br><span class="hljs-function">FText <span class="hljs-title">GetTitleText</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Gets the currently loaded URL.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* @return The URL, or empty string if no document is loaded.</span><br><span class="hljs-comment">*/</span><br>UFUNCTION(BlueprintCallable, Category = <span class="hljs-string">&quot;Web Browser&quot;</span>)<br><span class="hljs-function">FString <span class="hljs-title">GetUrl</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br><br><span class="hljs-comment">/** Called when the Url changes. */</span><br>UPROPERTY(BlueprintAssignable, Category = <span class="hljs-string">&quot;Web Browser|Event&quot;</span>)<br>FOnUrlChanged OnUrlChanged;<br><br><span class="hljs-comment">/** Called when a popup is about to spawn. */</span><br>UPROPERTY(BlueprintAssignable, Category = <span class="hljs-string">&quot;Web Browser|Event&quot;</span>)<br>FOnBeforePopup OnBeforePopup;<br><br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-comment">//~ Begin UWidget interface</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SynchronizeProperties</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-comment">// End UWidget interface</span><br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ReleaseSlateResources</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> bReleaseChildren)</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> WITH_EDITOR</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">const</span> FText <span class="hljs-title">GetPaletteCategory</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-comment">/** URL that the browser will initially navigate to. The URL should include the protocol, eg http:// */</span><br>UPROPERTY(EditAnywhere, Category = Appearance)<br>FString InitialURL;<br><br><span class="hljs-comment">/** Should the browser window support transparency. */</span><br>UPROPERTY(EditAnywhere, Category = Appearance)<br><span class="hljs-keyword">bool</span> bSupportsTransparency;<br><br><span class="hljs-keyword">protected</span>:<br>TSharedPtr&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SWebBrowser</span>&gt;</span> WebBrowserWidget;<br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-comment">// UWidget interface</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> TSharedRef&lt;SWidget&gt; <span class="hljs-title">RebuildWidget</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-comment">// End of UWidget interface</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HandleOnUrlChanged</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FText&amp; Text)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">HandleOnBeforePopup</span><span class="hljs-params">(FString URL, FString Frame)</span></span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*MyWebBrowser.cpp*/</span><br><br><span class="hljs-comment">// Fill out your copyright notice in the Description page of Project Settings.</span><br><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;MyWebBrowser.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Runtime/WebBrowser/Public/SWebBrowser.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Widgets/Layout/SBox.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Widgets/Text/STextBlock.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Async/TaskGraphInterfaces.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;UObject/ConstructorHelpers.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> WITH_EDITOR</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Materials/MaterialInterface.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Materials/MaterialExpressionMaterialFunctionCall.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Materials/MaterialExpressionTextureSample.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Materials/MaterialExpressionTextureSampleParameter2D.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Materials/MaterialFunction.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Factories/MaterialFactoryNew.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;AssetRegistryModule.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;PackageHelperFunctions.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOCTEXT_NAMESPACE <span class="hljs-meta-string">&quot;WebBrowser&quot;</span></span><br><br><span class="hljs-comment">/////////////////////////////////////////////////////</span><br><span class="hljs-comment">// UWebBrowser</span><br><br>UMyWebBrowser::UMyWebBrowser(<span class="hljs-keyword">const</span> FObjectInitializer&amp; ObjectInitializer)<br>: Super(ObjectInitializer)<br>&#123;<br>bIsVariable = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UMyWebBrowser::LoadURL</span><span class="hljs-params">(FString NewURL)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (WebBrowserWidget.IsValid())<br>&#123;<br><span class="hljs-keyword">return</span> WebBrowserWidget-&gt;LoadURL(NewURL);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UMyWebBrowser::LoadString</span><span class="hljs-params">(FString Contents, FString DummyURL)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (WebBrowserWidget.IsValid())<br>&#123;<br><span class="hljs-keyword">return</span> WebBrowserWidget-&gt;LoadString(Contents, DummyURL);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UMyWebBrowser::ExecuteJavascript</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString&amp; ScriptText)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (WebBrowserWidget.IsValid())<br>&#123;<br><span class="hljs-keyword">return</span> WebBrowserWidget-&gt;ExecuteJavascript(ScriptText);<br>&#125;<br>&#125;<br><br><span class="hljs-function">FText <span class="hljs-title">UMyWebBrowser::GetTitleText</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (WebBrowserWidget.IsValid())<br>&#123;<br><span class="hljs-keyword">return</span> WebBrowserWidget-&gt;GetTitleText();<br>&#125;<br><br><span class="hljs-keyword">return</span> FText::GetEmpty();<br>&#125;<br><br><span class="hljs-function">FString <span class="hljs-title">UMyWebBrowser::GetUrl</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (WebBrowserWidget.IsValid())<br>&#123;<br><span class="hljs-keyword">return</span> WebBrowserWidget-&gt;GetUrl();<br>&#125;<br><br><span class="hljs-keyword">return</span> FString();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UMyWebBrowser::ReleaseSlateResources</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> bReleaseChildren)</span></span><br><span class="hljs-function"></span>&#123;<br>Super::ReleaseSlateResources(bReleaseChildren);<br><br>WebBrowserWidget.Reset();<br>&#125;<br><br><span class="hljs-function">TSharedRef&lt;SWidget&gt; <span class="hljs-title">UMyWebBrowser::RebuildWidget</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (IsDesignTime())<br>&#123;<br><span class="hljs-keyword">return</span> SNew(SBox)<br>.HAlign(HAlign_Center)<br>.VAlign(VAlign_Center)<br>[<br>SNew(STextBlock)<br>.Text(LOCTEXT(<span class="hljs-string">&quot;Web Browser&quot;</span>, <span class="hljs-string">&quot;Web Browser&quot;</span>))<br>];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>WebBrowserWidget = SNew(SWebBrowser)<br>.InitialURL(InitialURL)<br>.ShowControls(<span class="hljs-literal">false</span>)<br>.SupportsTransparency(bSupportsTransparency)<br>.OnUrlChanged(BIND_UOBJECT_DELEGATE(FOnTextChanged, HandleOnUrlChanged))<br>.OnBeforePopup(BIND_UOBJECT_DELEGATE(FOnBeforePopupDelegate, HandleOnBeforePopup));<br><br><span class="hljs-keyword">return</span> WebBrowserWidget.ToSharedRef();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UMyWebBrowser::SynchronizeProperties</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::SynchronizeProperties();<br><br><span class="hljs-keyword">if</span> (WebBrowserWidget.IsValid())<br>&#123;<br><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UMyWebBrowser::HandleOnUrlChanged</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FText&amp; InText)</span></span><br><span class="hljs-function"></span>&#123;<br>OnUrlChanged.Broadcast(InText);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">UMyWebBrowser::HandleOnBeforePopup</span><span class="hljs-params">(FString URL, FString Frame)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (OnBeforePopup.IsBound())<br>&#123;<br><span class="hljs-keyword">if</span> (IsInGameThread())<br>&#123;<br>OnBeforePopup.Broadcast(URL, Frame);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">// Retry on the GameThread.</span><br>TWeakObjectPtr&lt;UMyWebBrowser&gt; WeakThis = <span class="hljs-keyword">this</span>;<br>FFunctionGraphTask::CreateAndDispatchWhenReady([WeakThis, URL, Frame]()<br>&#123;<br><span class="hljs-keyword">if</span> (WeakThis.IsValid())<br>&#123;<br>WeakThis-&gt;HandleOnBeforePopup(URL, Frame);<br>&#125;<br>&#125;, TStatId(), <span class="hljs-literal">nullptr</span>, ENamedThreads::GameThread);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> WITH_EDITOR</span><br><br><span class="hljs-function"><span class="hljs-keyword">const</span> FText <span class="hljs-title">UMyWebBrowser::GetPaletteCategory</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> LOCTEXT(<span class="hljs-string">&quot;My&quot;</span>, <span class="hljs-string">&quot;My&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-comment">/////////////////////////////////////////////////////</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> LOCTEXT_NAMESPACE</span><br><br></code></pre></td></tr></table></figure><h1 id="二、嵌入Web页面"><a href="#二、嵌入Web页面" class="headerlink" title="二、嵌入Web页面"></a>二、嵌入Web页面</h1><p>我们创建的MyWebBrowser继承自Widget属于UI范畴，所以Web显示操作属于UI操作。</p><h2 id="1-创建Web嵌入所用UI"><a href="#1-创建Web嵌入所用UI" class="headerlink" title="1.创建Web嵌入所用UI"></a>1.创建Web嵌入所用UI</h2><p>在Content Browser中右键/User Interface/Widget Buleprint，创建UI蓝图，这里我命名为WebBrowser。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170745.png"></p><p>打开WebBrowser，如果上面代码都编译通过了，那么在UI的Palette中应该会有一My栏，栏中有一个My Web Browser控件，这就是我们创建的自定义WebBrowser。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170752.png"></p><p>将My Web Browser拖入Hierachy中的Canvas Panel中并调整好大小。</p><h2 id="2-显示UI"><a href="#2-显示UI" class="headerlink" title="2.显示UI"></a>2.显示UI</h2><p>打开关卡蓝图，写入如下蓝图脚本：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170758.png"></p><p>注意，Class中填入的是我们刚创建的UI蓝图webBrowser。</p><h2 id="3-嵌入Web"><a href="#3-嵌入Web" class="headerlink" title="3.嵌入Web"></a>3.嵌入Web</h2><p>在UI蓝图webBrowser的Graph中写入如下蓝图脚本，在New URL中下入<a href="http://www.baidu.com用以测试./">www.baidu.com用以测试。</a></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170806.png"></p><p>运行测试</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170812.png"></p><p>测试通过。</p><h1 id="三、UE4到Web通信"><a href="#三、UE4到Web通信" class="headerlink" title="三、UE4到Web通信"></a>三、UE4到Web通信</h1><p>UE4到Web的通信，这里以UE4到ECharts的通信为例，首先到ECharts官网下载一个自己喜欢的图表源码到本地。</p><p>ECharts官网： <a href="https://www.echartsjs.com/zh/index.html">https://www.echartsjs.com/zh/index.html</a> </p><p>我以折线图为例</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170819.png"></p><p>ECharts上手较为简单，官方有5分钟快速上手教程，有详尽的API解释，这里不多累赘。</p><p>这里以使用UE4设置折线图Y轴的最大值和最小值为例。</p><h2 id="1-通信前的准备"><a href="#1-通信前的准备" class="headerlink" title="1.通信前的准备"></a>1.通信前的准备</h2><p>UE4到Web的通信需要通过SWebBrowser类的一个函数来绑定通信对象，然后通过这个对象进行数据通信。</p><p>首先我们需要定义一个函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">UFUNCTION(BlueprintCallable, Category = <span class="hljs-string">&quot;Web Browser&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UMyWebBrowser::BindUObject</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString &amp; Name, UObject * Object, <span class="hljs-keyword">bool</span> bIsPermanent)</span></span>;<br></code></pre></td></tr></table></figure><p>函数调用SWebBrowser类里的<code>void SWebBrowser::BindUObject(const FString &amp; Name, UObject * Object, bool bIsPermanent);</code>函数实现通信中介的创建。</p><p>这里要注意BindUObject函数需要暴露给蓝图调用。</p><p>函数实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UMyWebBrowser::BindUObject</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FString &amp; Name, UObject * Object, <span class="hljs-keyword">bool</span> bIsPermanent)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (WebBrowserWidget.IsValid())<br>&#123;<br>WebBrowserWidget-&gt;BindUObject(Name, Object, bIsPermanent);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-创建通信对象与数据传递方法"><a href="#2-创建通信对象与数据传递方法" class="headerlink" title="2.创建通信对象与数据传递方法"></a>2.创建通信对象与数据传递方法</h2><p>然后再在WebBrowser的Graph的蓝图脚本中添加BindUObject的调用创建通信中介对象。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170828.png"></p><p>其中Name中填写的就是通信中介对象的名字，名字可以自定义，这里命的名字在Web中调用时用的对象名，中介对象就是Self，即当前Widget对象。</p><p>UE4到Web的通信是Web主动调用UE4的方法，通信的数据则是这个方法的返回值，Web可以获取到这个返回值，通过这个对象中的这个方法的返回值即可达到数据通信的目的。</p><p>在WebBrowser的My Blueprint/Functions中添加两个用于数据传递的方法，GetMin和GetMax。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170833.png"></p><p><font color="red">这里要注意，用于数据传递的方法的返回值的名字必须是<code>ReturnValue</code>否则数据无法传递。</font></p><p>之后就可以在Web中操作通过obj这个对象操作这些函数来获取UE4里的Min和Max变量了。</p><p>这里贴出Web源码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;meta charset=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;<br>    &lt;!-- 引入 echarts.js --&gt;<br>&lt;script src=<span class="hljs-string">&quot;C:/Users/Administrator/Desktop/ECharts/echarts.min.js&quot;</span>&gt;&lt;/script&gt;<br>    &lt;script src=<span class="hljs-string">&quot;C:/Users/Administrator/Desktop/ECharts/jquery.min.js&quot;</span>&gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body style = <span class="hljs-string">&quot;background-color:#d8d8d8&quot;</span>&gt;<br>    &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt;<br>&lt;div id=<span class="hljs-string">&quot;main&quot;</span> style=<span class="hljs-string">&quot;width: 1000px;height:450px;position:1px; top:1px;&quot;</span>&gt;CHART&lt;/div&gt;<br>&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;<br>         <br><span class="hljs-keyword">var</span> myChart = echarts.init(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;main&quot;</span>));<br><span class="hljs-keyword">var</span> x = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>,<span class="hljs-number">17</span>,<span class="hljs-number">18</span>,<span class="hljs-number">19</span>,<span class="hljs-number">20</span>,<span class="hljs-number">20</span>,<span class="hljs-number">22</span>,<span class="hljs-number">23</span>,<span class="hljs-number">24</span>,<span class="hljs-number">25</span>,<span class="hljs-number">26</span>,<span class="hljs-number">27</span>,<span class="hljs-number">28</span>,<span class="hljs-number">29</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">32</span>,<span class="hljs-number">33</span>,<span class="hljs-number">34</span>,<span class="hljs-number">35</span>,<span class="hljs-number">36</span>,<span class="hljs-number">37</span>,<span class="hljs-number">38</span>,<span class="hljs-number">39</span>,<span class="hljs-number">40</span>];<br><span class="hljs-keyword">var</span> y = [];<br><br><span class="hljs-keyword">var</span> y_min = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">var</span> y_max = <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Set</span>(<span class="hljs-params"></span>)</span>&#123;<br>option = &#123;<br>tooltip :<br>&#123;<br>trigger : <span class="hljs-string">&#x27;axis&#x27;</span>,<br><span class="hljs-comment">//十字锚点</span><br>axisPointer:<br>&#123;<br>type: <span class="hljs-string">&#x27;cross&#x27;</span>,<br>animation: <span class="hljs-literal">false</span>,<br>label: &#123;<span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&#x27;#505765&#x27;</span>&#125;,<br>lineStyle : &#123;<span class="hljs-attr">type</span> : <span class="hljs-string">&#x27;dashed&#x27;</span>&#125;<br>&#125;<br>&#125;,<br>xAxis: &#123;<span class="hljs-attr">data</span>: x&#125;,<br>yAxis: <br>&#123;<br>splitLine: &#123;<span class="hljs-attr">show</span>: <span class="hljs-literal">false</span> &#125;,<br>min : y_min,<br>max : y_max<br>&#125;,<br>dataZoom: [<br>&#123;<span class="hljs-attr">startValue</span>: <span class="hljs-string">&#x27;2014-06-01&#x27;</span>&#125;, <br>&#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;inside&#x27;</span>&#125;<br>],<br>series: &#123;<br>type: <span class="hljs-string">&#x27;line&#x27;</span>,<br>data: y<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SetYMinAndMax</span>(<span class="hljs-params"></span>)</span>&#123;<br>ue.obj.getmin().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ReturnValue</span>)</span>&#123;<br>y_min = ReturnValue;<br>&#125;);<br>ue.obj.getmax().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ReturnValue</span>)</span>&#123;<br>y_max = ReturnValue;<br>&#125;);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AddData</span>(<span class="hljs-params"></span>)</span>&#123;<br>y.push(<span class="hljs-built_in">Math</span>.random());<br>&#125;<br><br>SetYMinAndMax();<br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>AddData();<br><span class="hljs-built_in">Set</span>();<br>myChart.setOption(option);<br>&#125;,<span class="hljs-number">1000</span>);<br>    &lt;/script&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>其中SetYMinAndMax函数便是UE4与Web的数据通信。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SetYMinAndMax</span>(<span class="hljs-params"></span>)</span>&#123;<br>ue.obj.getmin().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ReturnValue</span>)</span>&#123;<br>y_min = ReturnValue;<br>&#125;);<br>ue.obj.getmax().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ReturnValue</span>)</span>&#123;<br>y_max = ReturnValue;<br>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="red">这里还需要注意，ue.obj.getmin()和ue.obj.getmax()必须使用小写，否则也无法通信，其次匿名函数function(ReturnValue)的参数名也必须为ReturnValue不可更改，否则数据依然无法传递。</font></p><p>然后测试一下数据传递是否正确。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170845.png"></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514170850.png"></p><p>可以看到Y轴的最大值由1改为了Max变量的值2。数据传递成功。</p><p>上面的Web程序要运行还需要两个文件<code>echarts.min.js</code>和<code>jquery.min.js</code>，文件放在：</p><p>这是B站上的视频教程：<a href="https://www.bilibili.com/video/av47212309">https://www.bilibili.com/video/av47212309</a></p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE4】UE4角色控制</title>
    <link href="/2021/05/14/%E3%80%90UE4%E3%80%91UE4%E8%A7%92%E8%89%B2%E6%8E%A7%E5%88%B6/"/>
    <url>/2021/05/14/%E3%80%90UE4%E3%80%91UE4%E8%A7%92%E8%89%B2%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><a id="more"></a><h1 id="一、UE4的角色控制框架"><a href="#一、UE4的角色控制框架" class="headerlink" title="一、UE4的角色控制框架"></a>一、UE4的角色控制框架</h1><p>做角色控制之前，我们首先要了解UE4的角色控制框架，了解引擎是如何控制角色移动和做出各种骚姿势的。</p><h2 id="1-Pawn"><a href="#1-Pawn" class="headerlink" title="1.Pawn"></a>1.Pawn</h2><p>Pawn类就是UE4里可用于操控的游戏物体，Pawn类继承自Actor拥有Actor的所有特性，并且Pawn还带有</p><ul><li>Controller：可以被操控；</li><li>PhysicsCollision：物理碰撞；</li><li>MovementInput：事件响应，大多数情况下用于键盘输入事件响应。</li></ul><h2 id="2-Character"><a href="#2-Character" class="headerlink" title="2.Character"></a>2.Character</h2><p>Character就是我们即将要使用的类，Character继承自Pawn，也拥有可操控性，物理碰撞和事件响应，除此之外，Character还拥有CapsuleComponent(椭圆碰撞体)，ArrowComponent(角色正面方向)，Mesh。我们向Mesh上添加模型，Character便拥有了可显示的网格。</p><p>当然Pawn派生的还有defaultPawn,SpectatorPawn，这里就不探讨了。</p><h2 id="3-Controller"><a href="#3-Controller" class="headerlink" title="3.Controller"></a>3.Controller</h2><p>Controller也派生自Actor，是与Pawn平级的类，Controller负责控制Pawn及Pawn的派生类，但Controller一般负责高层面的控制，如角色切换，多角色控制等，而Pawn和Character负责处理角色自身的简单控制逻辑，如角色的移动，跑，蹲，跳等运动逻辑。</p><p>由于Controller是独立Pawn存在的，所以Controller可以独立存在与World中，如：上帝视角。</p><p>一个Controller可以控制多个Pawn，一个Pawn也可以被多个Controller控制。</p><p>但是一个Pawn要想被控制就必须关联至少一个Controller，否则尽管在Pawn中编写了控制逻辑，我们依然无法操控Pawn。</p><h1 id="二、角色控制"><a href="#二、角色控制" class="headerlink" title="二、角色控制"></a>二、角色控制</h1><p>与U3D的角色控制一样，在UE4中进行角色控制前也需要进行按键的映射注册。</p><h2 id="1-注册按键映射"><a href="#1-注册按键映射" class="headerlink" title="1.注册按键映射"></a>1.注册按键映射</h2><p>在<code>Project Settings/Input/Bindings</code>下，有一个Action Mappings(行为映射)和一个Axis Mappings(轴映射)，Action Mappings是与角色三维坐标轴无关的映射，一般用于触发角色的行为，如：跳，蹲，拾取等行为，并且UE4还为Action Mappings封装好了组合键，在U3D中，组合键的逻辑是需要我们自己写的。Axis Mappings是与角色三维坐标轴有关的映射，一般用于触发角色的移动与视角控制。</p><p><font color="red"> 我们将映射注册好之后，UE4会自动按照我们的命名创建触发事件蓝图，这个在后面详细讲解</font>。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171219.png"></p><p>这里详细说一下视角控制，视角控制一般使用鼠标来控制(当然也可以使用键盘，只是大多数情况下使用鼠标)，所有我们使用的映射是Mouse Y和Mouse X，我们用一张图来理解Mouse Y和Mouse X的方向：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171226.png"></p><p>Mouse Y就是鼠标的Y轴，Mouse X就是鼠标的X轴。</p><h2 id="2-使用角色蓝图编写控制逻辑"><a href="#2-使用角色蓝图编写控制逻辑" class="headerlink" title="2.使用角色蓝图编写控制逻辑"></a>2.使用角色蓝图编写控制逻辑</h2><p>首先我们创建一个继承自Character的蓝图类，然后为Character中添加SpringArm组件并在SpringArm组件下添加Camera组件，SpringArm组件是专门为Camera服务的组件，用于连接Mesh和Camera，可以对Camera进行一些操作，如相机偏移等。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171233.png"></p><p>然后向Mesh中添加我们需要的模型，一个Character基本组件就搭建好了</p><p>然后我们就可以在Character蓝图类的Event Graph中编写控制逻辑了。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171240.png"></p><p>Input Axis MoveForword，Input Axis MoveRight，Input Axis LookUp，Input Axis Turn都是UE4按照我们注册按键映射时的名字为我们创建好的事件，当我们按下对应的键时事件就会被触发。</p><p>UE4使用MovementComponent封装好了Pawn的移动实现，Character中也自带有一个CharacterMovement，我们只需要向组件中添加输入就可以使角色移动了，Add Movement Input函数就是用于MovementComponent组件输入的函数，我们只需要传给Add Movement Input函数移动方向和值就可以使角色按照我们规定的方向移动，移动方向的获取，UE4也封装好了Get Forward Vector(正前方)和Get Right Vector(正右方)来获取某一个轴上的正前与正右的方向矢量，Get Control Rotation函数可以获取角色当前的方向矢量，而角色的前后左右移动是在Z轴的垂直面，即XY平面上移动，所以我们需要获取Z轴的正前正右的方向矢量，我们可以使用Break将角色当前的方向矢量拆开成xyz三个标量，只拿Z轴的值再使用Make封装成矢量，这样Get Forward Vector和Get Right Vector所拿到就是Z轴的正前方与正右方了。</p><p>而角色的视角转向，UE4使用的是 Controller Yaw，Controller Pitch，Controller Roll来控制的，Controller Yaw控制的是角色的上下方向的视角旋转，Controller Pitch控制的是角色的左右方向的视角旋转，Controller Roll控制的是角色的前后方向的视角旋转，和MoveComponent一样UE4也提供Add Controller Yaw Input，Add Controller Pitch Input，Add Controller Roll Input分别为三者传值。我们只需要将映射对应的值输入给三个函数即可实现角色视角的旋转控制了，然后勾选SpringArm的Details/Camera Settings/Use Pawn Controller Rotation，将视角旋转控制应用到相机上，这样角色就可以通过鼠标进行视角控制了。</p><h2 id="3-关联角色控制器"><a href="#3-关联角色控制器" class="headerlink" title="3.关联角色控制器"></a>3.关联角色控制器</h2><p>UE4的角色控制框架规定了，我们必须为角色关联一个Controller才可以对角色进行控制。</p><p>在角色的Details/Input/Auto Receive Input选项中可以切换控制器，UE4为我们封装好了一个Controller–Player 0，我们选择Player 0就可以对角色进行控制了。其他的Palyer 1，Player 2等是用于其他的用途的，我们这里不探讨。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171247.png"></p><h1 id="三、配置骨骼动画"><a href="#三、配置骨骼动画" class="headerlink" title="三、配置骨骼动画"></a>三、配置骨骼动画</h1><p>完成以上步骤，我们的角色就可以在场景中自由自动了，但是这个移动只是纯移动，并不带有移动动画，要想移动更真实，我们还需要为角色配置骨骼动画。</p><p>需要注意的是不是什么动画都可以往角色身上套的，只有和角色骨骼相匹配的动画才可以被角色使用，如果我们想要使用某些动画，我们就需要设置模型的骨骼为这些动画配套的骨骼。</p><h2 id="1-配置骨骼"><a href="#1-配置骨骼" class="headerlink" title="1.配置骨骼"></a>1.配置骨骼</h2><p>在导入模型的时候就可以为模型选定骨骼，选定好骨骼的模型导入工程后就不能在更换骨骼了，想要更换骨骼就需要重新导入。这里我们使用UE4自带的骨骼。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171254.png"></p><p>还有一步是为模型添加物理资产，在模型视图的Asset Details/Physics/Physics Asset选择与骨骼动画配套的物理资产，至于这个物理资产具体是干什么的这里不深究。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171300.png"></p><h2 id="2-混合空间"><a href="#2-混合空间" class="headerlink" title="2.混合空间"></a>2.混合空间</h2><p>如上图，我们可以看到一个Blend Space和一个Bland Space 1D，这是UE4专门用来处理某一类动画混合的模块。Blend Space是二维混合空间，可以混合两个方向上的动作，比如，向前前后是一个方向，向左向右是一个方向，Blend Space就可以混合这两个方向的所有动作；而Blend Space 1D则只能混合一个方向上的动作。</p><p>这里我们需要为角色前后左右两个方向上的移动添加动作，所以选择Blend Space。打开混合空间</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171307.png"></p><p>在动作混合视图中UE4已经为我们预设好了很多骨骼动画，横轴与纵轴的名字要命名规范，因为这两个轴的名字会作为混合空间的参数，从外界传值进来的。横轴纵轴的最大值最小值和分割数都可以根据自己的实际需求设置。</p><p>Preview Base Pose是用来设置关键帧姿势的，有的骨骼动画直接包含了姿势动作，Preview Base Pose会自动赋值，有的骨骼动画只包含了动作，这时就需要我们手动赋予姿势了，如我们后面需要用到的扭头的动画。</p><p>然后添加上我们需要的动画即可，当Speed变化时，角色的动画会在Idle-Walk-Run之间切换，当Deriction变化时，角色的动画会在Left和Right之间切换。</p><h2 id="3-动画蓝图"><a href="#3-动画蓝图" class="headerlink" title="3.动画蓝图"></a>3.动画蓝图</h2><p>Animation Blueprint是UE4封装的专门用于管理动画的类，Animation Blueprint可以管理骨骼动画的混合空间也可以直接管理骨骼动画。</p><p>在Content Browser中右键选择Animation/Animation Blueprint，然后Parent Class选择父类为AnimInstance，Target Skeletion选择我们角色应用的骨骼，就可以创建一个管理我们选定的骨骼动画的管理蓝图了。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171314.png"></p><p>进入动画蓝图，在Anim  Graph视图，我们可以看见一个Final Animation Pose节点，这是UE4封装好的处理角色最终要显示的动画的模块，右键添加添加一个状态机。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171320.png"></p><p>双击状态机，进入状态机里，右键添加一个状态并命名为Idle_Walk_Run。一个状态机可以管理多个状态。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171328.png"></p><p>双击进入状态，在右侧Asset Browser中选择我们配置好的混合空间，并在左侧MyBlueprint/Variables中添加两个变量Speed和Deriction分别给混合空间的横轴Speed和纵轴Deriction赋值。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171335.png"></p><p>然后在动画蓝图的Event Graph中编写逻辑为Speed和Deriction变量赋值。</p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171341.png" style="zoom:200%;"><p>直接看到角色移动的控制逻辑，UE4为我们封装好了Caculate Deriction来计算角色的移动方向，我们只需要使用Get Velocity和GetActorRotation获取角色的速度矢量和旋转方向赋值给Calculate Deriction既可以了，速度矢量的模，UE4也封装好了VectorLength来计算。</p><p>最后在角色蓝图的Mesh的Details/Animation中将Animation Mode设置成Use Animation Blueprint，将Anim Class设置成我们创建的动画蓝图，这样我们的动画就可以应用到我们的角色上了。</p><h1 id="四、多动画管理"><a href="#四、多动画管理" class="headerlink" title="四、多动画管理"></a>四、多动画管理</h1><p>我们的游戏角色一般不可能只有移动的动画，一般还会有其他的动画，如拾取，下蹲等，这时我们就需要进行多动画混合空间的管理了。</p><p>多动画管理有两类，一类是与角色移动动画同级的混合动画，在一个时刻是能播放一个动画，二者不兼容，如下蹲，一类是可以在角色移动动画播放的同时也可以播放的混合动画，在一个时刻两个动画都可以播放，二者兼容，如角色站立时扭头。</p><h2 id="1-不兼容的同级动画管理"><a href="#1-不兼容的同级动画管理" class="headerlink" title="1.不兼容的同级动画管理"></a>1.不兼容的同级动画管理</h2><p>按照第三步，我们也可以创建一个Blend Space来混合下蹲动画。当然如果下蹲动画只有一个，就没必要使用Blend Space了，可以直接使用动画蓝图来管理动画。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171351.png"></p><p>同样，我们创建一个状态机Crouch，在状态机里配置下蹲动画。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171400.png"></p><p>需要注意的是，下蹲动画的横轴和纵轴也需要命名为Speed和Deriction，因为我们的下蹲移动使用的也是前后左右两个方向来控制动画。</p><p>然后在动画蓝图的Anim Graph中添加一个Blend Poses by bool来管理移动与下蹲动画，并创建一个bool值来判断动画的执行</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171406.png"></p><p>Is Crouch为true时走True Pose,为False时走False Pose，并且可以设置两个分支的动画过度时间。</p><p>然后就是在Event Graph中编写下蹲动画的控制逻辑。如步骤三中逻辑控制图的下蹲控制逻辑，UE4甚至封装好了下蹲判断，Is Crouching，可以直接判断角色当前是否处于下蹲状态，直接将这个状态赋值给IsCrouch变量，然后使用Get MoveMen Component给Is Crouching传值。</p><p>当然如果我们有更多的不兼容动画需要管理，UE4也为我们提供了Blend Poses by int来管理</p><h2 id="2-可兼容动画管理"><a href="#2-可兼容动画管理" class="headerlink" title="2.可兼容动画管理"></a>2.可兼容动画管理</h2><p>可兼容的动画的混合就不是使用Blend Space来混合了，而是使用Aim Offset来混合。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171413.png"></p><p>一般可兼容的动画使用的是关键帧，即只有动画没有姿势，我们需要将动画应用到某一姿势上去，如上图应用到Idle上的Idle的扭头动作。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171419.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE4】UE4Socket编程</title>
    <link href="/2021/05/14/%E3%80%90UE4%E3%80%91UE4Socket%E7%BC%96%E7%A8%8B/"/>
    <url>/2021/05/14/%E3%80%90UE4%E3%80%91UE4Socket%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><a id="more"></a><h1 id="一、基于C-的服务器"><a href="#一、基于C-的服务器" class="headerlink" title="一、基于C++的服务器"></a>一、基于C++的服务器</h1><p>当然服务器也是可以使用UE4写的，不过对于一般的不需要UI的服务器来说，直接使用C++控制台程序编写要方便得多。</p><h2 id="1-所需头文件和静态库"><a href="#1-所需头文件和静态库" class="headerlink" title="1.所需头文件和静态库"></a>1.所需头文件和静态库</h2><p><code>#include &lt;winsock.h&gt;</code></p><p><code>#pragma comment(lib &quot;ws2_32.lib&quot;)</code></p><p><font color="red"> 需要注意的是，winsock.h是Windows环境使用的头文件，对于其他的环境需要使用其他的头文件，如在Linux下使用的是socket.h。</font></p><p>有的时候也是用winsock2.h，winsockt2.h是winsockt.h的升级版，一个文件中不可同时存在winsockt.h和winsockt2.h，因为winsockt2.h中有重定义winsockt.h中的内容。</p><h2 id="2-创建套接字"><a href="#2-创建套接字" class="headerlink" title="2.创建套接字"></a>2.创建套接字</h2><p><strong>Server.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;winsock.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> comment(lib, <span class="hljs-meta-string">&quot;ws2_32.lib&quot;</span>)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Server</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>WSADATA wsd;<span class="hljs-comment">//存放套接字的属性，如：版本信息等</span><br>SOCKET serverSocket;<br>SOCKET clientSocket;<br>SOCKADDR_IN serverAddr;<span class="hljs-comment">//用于设置套接字使用的地址类型，端口和</span><br><br>Server(<span class="hljs-keyword">int</span> port);<br>~Server();<br><br><span class="hljs-function">SOCKET <span class="hljs-title">ClientListen</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Receive</span><span class="hljs-params">(SOCKET clientSocket)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>创建套接字</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++">Server::Server(<span class="hljs-keyword">int</span> port)<br>&#123;<br><span class="hljs-comment">//打开2.2版本的套接字，注册套接字</span><br><span class="hljs-keyword">if</span> (WSAStartup(MAKEWORD(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), &amp;wsd) != <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;初始化套接字动态库错误&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//创建套接字，AF_INET--使用Inter使用，SOCK_STREAM--使用流式传输，IPPROTO_TCP--使用TCP连接</span><br>serverSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);<br><span class="hljs-keyword">if</span> (serverSocket == INVALID_SOCKET)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;套接字创建失败&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>WSACleanup();<span class="hljs-comment">//注销套接字</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>serverAddr.sin_family = AF_INET;<span class="hljs-comment">//配置地址类型为InterIP</span><br>serverAddr.sin_port = htons(port);<span class="hljs-comment">//配置占用端口</span><br>serverAddr.sin_addr.S_un.S_addr = INADDR_ANY;<span class="hljs-comment">//接受任何IP类型</span><br><span class="hljs-comment">//将IP和端口与套接字绑定</span><br><span class="hljs-keyword">int</span> ret = bind(serverSocket, (LPSOCKADDR)&amp;serverAddr, <span class="hljs-keyword">sizeof</span>(SOCKADDR_IN));<br><span class="hljs-keyword">if</span> (ret == SOCKET_ERROR)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;套接字绑定失败&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>closesocket(serverSocket);<span class="hljs-comment">//关闭套接字</span><br>WSACleanup();<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其间也可以加一个版本判断，判断注册的套接字是否是2.2版本的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (LOBYTE(wsd.wVersion != <span class="hljs-number">2</span> || HIBYTE(wsd.wVersion) != <span class="hljs-number">2</span>))<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;套接字版本错误，需要打开2.2版本的套接字&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>WSACleanup();<br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-套接字监听"><a href="#3-套接字监听" class="headerlink" title="3.套接字监听"></a>3.套接字监听</h2><p>C++没有提供专门的异步套接字监听方法，如果不想使用阻塞的方式，即同步方式监听套接字的话，就需要通过线程来实现异步监听了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">SOCKET <span class="hljs-title">Server::ClientListen</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> ret = listen(serverSocket, SOMAXCONN);<span class="hljs-comment">//开启套接字监听，SOMAXCONN--监听队列设为最大</span><br><span class="hljs-keyword">if</span> (ret == SOCKET_ERROR)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;监听时发生错误&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>closesocket(serverSocket);<br>WSACleanup();<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br>sockaddr_in clientAddr;<span class="hljs-comment">//用于存储接收到的客户端的地址信息</span><br><span class="hljs-keyword">int</span> clientAddrLen = <span class="hljs-keyword">sizeof</span>(clientAddr);<br>    <span class="hljs-comment">//接受serverSocket缓冲区里clientAddrlen长度的内容，即一个套接字</span><br>SOCKET clientSocket = accept(serverSocket, (sockaddr FAR*)&amp;clientAddr, &amp;clientAddrLen);<br><span class="hljs-keyword">if</span> (clientSocket == INVALID_SOCKET)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;接受客户端时发生错误&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>closesocket(serverSocket);<br>WSACleanup();<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;接受到客户端&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> clientSocket;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-接受消息"><a href="#4-接受消息" class="headerlink" title="4.接受消息"></a>4.接受消息</h2><p>获取到客户端的套接字后，就可以就收客户端发送过来的消息了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Server::Receive</span><span class="hljs-params">(SOCKET clientSocket)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">char</span> receiveBuff[<span class="hljs-number">50</span>];<span class="hljs-comment">//接受消息内容缓冲数组</span><br>    <span class="hljs-comment">//接受消息</span><br>recv(clientSocket, receiveBuff, <span class="hljs-built_in">strlen</span>(receiveBuff), <span class="hljs-number">0</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, receiveBuff);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-发送消息"><a href="#5-发送消息" class="headerlink" title="5.发送消息"></a>5.发送消息</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Server::Send</span><span class="hljs-params">(SOCKET clientSocket, <span class="hljs-keyword">char</span> * sendBuff)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//发送sendBuff发送消息数组钟的内容到clientSocket套接字</span><br>send(clientSocket, sendBuff, <span class="hljs-built_in">strlen</span>(sendBuff) + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二、GameMode与GameInstance"><a href="#二、GameMode与GameInstance" class="headerlink" title="二、GameMode与GameInstance"></a>二、GameMode与GameInstance</h1><p>由于UE4在换关卡的时候会删除世界大纲中的上一关卡中的所有的内容，所以对于需要在整个游戏运行期间都必须工作的套接字来说，需要在一个从游戏开始运行到游戏程序关闭都存在的场所中工作，这个场所就是GameInstance，而使用自定义GameInstance需要用到GameMode，所以在写UE4客户端套接字之前，我们有必要先了解GameInstance和GameMode。</p><h2 id="1-GameInstance"><a href="#1-GameInstance" class="headerlink" title="1.GameInstance"></a>1.GameInstance</h2><p>要了解GameInstance，首先我们要对UE的引擎结构有一点点的了解。</p><p>UE的宇宙是由UEngine这个创世神管理的各个World组成的，每个World就是一个个平行世界，编辑模式是一个World，运行模式是一个World，而每个World又由各个Level组成，每个Level又由各个Actor组成，而每个Actor拥有各种不同Component从而形成了各式各样的Actor，于是多姿多彩的UE世界便展开了，而GameInstance就是凌驾于World之上的存在。</p><p><font color="red"> GameInstance的生命周期就是整个游戏进程的生命周期，从游戏开始到游戏程序关闭，并且GameInstance在整个游戏进程中只存在一个对象，即单例，就如名字一般</font>。所以任何凌驾于Level和World之上的逻辑都应该在GameInstance中保存和实现，比如游戏网络连接，因为Level在切换时UE4会清空上一个Level在世界大纲中所有内容，然后加载下一个Level的内容，此时如果把游戏网络连接的逻辑放在Level或World中，这些逻辑就会被清空，在上一个Level内容被清空到下一个Level中重新加载网络连接逻辑的期间游戏会处于网络孤立状态。在游戏运行期间World在任意时刻其实都是是唯一的，为什么网络连接的逻辑不能放在World中，而要放在GameInstance中呢?这是因为UE在加载新的Level时，其实是在销毁前一个World，创建了一个新的World。但是World依然只有一个。</p><p><strong>使用GameInstance</strong></p><p>使用GameInstance的方法很简单，就是创建一个类继承自UGameInstance的子类，这个子类就继承到了GameInstance的所有属性了。</p><p>但是GameInstance不存在于世界大纲中该如何执行在其中实现的逻辑代码呢？这就是我们接下来要来了解的GameMode的事了。</p><h2 id="2-GameMode"><a href="#2-GameMode" class="headerlink" title="2.GameMode"></a>2.GameMode</h2><p>首先我们需要知道什么是GameMode，在UE4里GameMode是对应World层存在的，UE4给予GameMode的职责就是处理与实现游戏逻辑，即游戏的玩法，这里我们要区分GameMode与LevelBlueptint，LevelBlueprint是对应Level存在在，每一个Level有且只有一个LevelBlueprint，而GameMode是对应World存在的，每一个World有且只有一个GameMode，但是一个UE4游戏中是可以有多个GameMode，就像一个游戏可以有多种规则玩法一样。</p><p>在UE4里GameInstance里的内容可以被全局调用，那么我们为什么要使用GameMode来实现网络连接而不是用更易理解的LevelBlueprint呢？这是因为GameMode提供了内容在拥有不同GameMode的World中迁移的能力，加以大多数游戏一般只有一中游戏规则，即一个GameMode，所以在GameMode中做网络连接的逻辑是较为恰当的。</p><p><strong>使用GameMode</strong></p><p>GameMode实质上是一个继承自GameModeBase的蓝图类，我们只需创建一个继承自GameModeBase的GameMode，就可以在GameMode中编写蓝图脚本调用C++函数来实现游戏逻辑了，为什么在GameMode中只进行函数调用呢？因为如果所有的代码逻辑都在GameMode中实现就会显得GameMode过于臃肿，所以GameMode一般进行函数调用，而函数的实现则在C++类中处理。</p><p>至此，客户端的网络部分的代码逻辑在什么地方编写就基本确定了。</p><h1 id="三、UE4客户端"><a href="#三、UE4客户端" class="headerlink" title="三、UE4客户端"></a>三、UE4客户端</h1><h2 id="1-前提准备"><a href="#1-前提准备" class="headerlink" title="1.前提准备"></a>1.前提准备</h2><ul><li><p>UE4编写网络模块的逻辑需要在.Build.cs文件里添加两个模块<font color="red"> “Sockets”, “Networking”</font>；</p></li><li><p>创建一个继承自UGameInstance的类作为网络部分的代码实现模块；</p></li><li><p>创建一个继承自GameModeBase的GameMode，并在Settings/Project Settings/Maps&amp;Mode下设置项目默认的GameMode和GameInstance。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210514171635.png"></p></li></ul><h2 id="2-连接服务器"><a href="#2-连接服务器" class="headerlink" title="2.连接服务器"></a>2.连接服务器</h2><p><strong>.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;FReceiveThread.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Runtime/NEtworking/Public/Networking.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Engine/GameInstance.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ServerConnector.generated.h&quot;</span></span><br><br>UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYGAME_API</span> <span class="hljs-title">UServerConnector</span> :</span> <span class="hljs-keyword">public</span> UGameInstance<br>&#123;<br>GENERATED_BODY()<br><span class="hljs-keyword">private</span>:<br><br>FSocket *connectSocket;<br>FIPv4Address ip;<br>TSharedPtr&lt;FReceiveThread&gt; receiveThread;<br><br><span class="hljs-keyword">public</span>:<br><br>FString msg;<br><br><span class="hljs-keyword">public</span>:<br>UServerConnector() &#123;&#125;<br><span class="hljs-comment">//create socket and connect server</span><br>UFUNCTION(BlueprintCallable,Category=<span class="hljs-string">&quot;ClientSocket&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ServerConnect</span><span class="hljs-params">(FString ip,int32 port)</span></span>;<br><span class="hljs-comment">//send message to server</span><br>UFUNCTION(BlueprintCallable, Category = <span class="hljs-string">&quot;ClientSocket&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Send</span><span class="hljs-params">(FString msg)</span></span>;<br><span class="hljs-comment">//receive message from server</span><br>UFUNCTION(BlueprintCallable, Category = <span class="hljs-string">&quot;ClientSocket&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Receive</span><span class="hljs-params">()</span></span>;<br><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>连接Server</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">UServerConnector::ServerConnect</span><span class="hljs-params">(FString ip, int32 port)</span></span><br><span class="hljs-function"></span>&#123;<br>FIPv4Address::Parse(ip,<span class="hljs-keyword">this</span>-&gt;ip);<span class="hljs-comment">//将字符串表示的ip转换成点分十进制的ip</span><br>    <span class="hljs-comment">//创建服务器套接字地址，PLATFROM_SOCKTSUBSYSTEM--选择当前系统的套接字</span><br>TSharedPtr&lt;FInternetAddr&gt; addr = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateInternetAddr();<br>addr-&gt;SetIp(<span class="hljs-keyword">this</span>-&gt;ip.Value);<span class="hljs-comment">//向套接字地址绑定服务器ip</span><br>addr-&gt;SetPort(port);<span class="hljs-comment">//向套接字地址绑定服务器端口</span><br>    <span class="hljs-comment">//创建客户端套接字，NAME_Stream--使用流式传输，Default--套接字描述，false使用TCP，Ture使用UDP连接</span><br>connectSocket = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateSocket(NAME_Stream, TEXT(<span class="hljs-string">&quot;Default&quot;</span>), <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">if</span> (!connectSocket-&gt;Connect(*addr))<span class="hljs-comment">//连接服务器</span><br>&#123;<br>UE_LOG(LogTemp, Error, TEXT(<span class="hljs-string">&quot;ServerConnector.cpp:Connect Failed&quot;</span>));<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>UE_LOG(LogTemp, Error, TEXT(<span class="hljs-string">&quot;Connect Succeed&quot;</span>));<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-发送消息"><a href="#3-发送消息" class="headerlink" title="3.发送消息"></a>3.发送消息</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">UServerConnector::Send</span><span class="hljs-params">(FString msg)</span></span>&#123;    <span class="hljs-comment">//将字符串形式的消息转换成TCHAR*类型，因为二进制流的转换只支持TCHAR类型TCHAR *seriallizedChar = msg.GetCharArray().GetData();int32 size = FCString::Strlen(seriallizedChar) + 1;//计算消息的内存大小int32 sent = 0;//这一行是Send函数的格式要求，提供给Send内部使用的参数    //将消息转化成二进制流并向服务器发送消息if (!connectSocket-&gt;Send((uint8*)TCHAR_TO_UTF8(seriallizedChar), size, sent))&#123;UE_LOG(LogTemp, Error, TEXT(&quot;Message Send Failly&quot;));return false;&#125;UE_LOG(LogTemp, Error, TEXT(&quot;Message Send Successlly&quot;));return true;&#125;</span><br></code></pre></td></tr></table></figure><h2 id="4接受消息"><a href="#4接受消息" class="headerlink" title="4接受消息"></a>4接受消息</h2><p>接受消息就需要使用到UE4线程了，那么首先我们就需要了解UE4线程。</p><p>在UE4中线程就是一个继承自FRunnable的类，我们创建这个类的对象的同时就开启了线程，<font color="red"> 要注意的是继承自FRunnable的类是一个自定义类，即以F开头的类，并且自定义类在UE4的内容浏览器中是不显示的</font>。</p><p><strong>需要包含的头文件</strong></p><ul><li><p>#include “Runnable.h”</p></li><li><p>#include “RunnableThread.h”</p><p>或者我们也可以直接只包含#include “ThreadingBase.h”头文件，ThreadingBase.h里面就已经包含了线程所需要的所有的头文件</p></li></ul><h3 id="h"><a href="#h" class="headerlink" title=".h"></a><strong>.h</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CoreMinimal.h&quot;</span>#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Runnable.h&quot;</span>#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;RunnableThread.h&quot;</span>#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Networking.h&quot;</span><span class="hljs-comment">//#include &quot;ThreadingBase.h&quot;class MYGAME_API FReceiveThread : public FRunnable&#123;private:FRunnableThread* thread = nullptr;bool threadRuning;FSocket* socket;//需要读取消息的线程public:FString msg;private:virtual uint32 Run() override;virtual void Stop() override;public:FReceiveThread(FSocket* socket);~FReceiveThread();;&#125;;</span></span><br></code></pre></td></tr></table></figure><p><strong>.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;FReceiveThread.h&quot;</span>FReceiveThread::FReceiveThread(FSocket* socket)&#123;this-&gt;socket = socket;thread = FRunnableThread::Create(this, TEXT(<span class="hljs-meta-string">&quot;ReceiveThread&quot;</span>), 0);threadRuning = true;&#125;uint32 FReceiveThread::Run()&#123;<span class="hljs-meta-keyword">if</span> (!socket) return 0;TArray<span class="hljs-meta-string">&lt;uint8&gt; buff;int32 readType = 0;while (threadRuning)&#123;buff.Init(0, 1024u);socket-&gt;Recv(buff.GetData(), buff.Num(), readType);msg = FString(ANSI_TO_TCHAR(reinterpret_cast&lt;const char*&gt;(buff.GetData())));UE_LOG(LogTemp, Error, TEXT(&quot;%s&quot;), *msg);&#125;return 1;&#125;void FReceiveThread::Stop()&#123;threadRuning = false;if (thread) thread-&gt;WaitForCompletion();&#125;FReceiveThread::~FReceiveThread()&#123;threadRuning = false;delete thread;thread = NULL;&#125;</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C++】C++11新特性</title>
    <link href="/2021/03/17/%E3%80%90C++%E3%80%91C++11%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2021/03/17/%E3%80%90C++%E3%80%91C++11%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><a id="more"></a><h1 id="一、auto类型推导"><a href="#一、auto类型推导" class="headerlink" title="一、auto类型推导"></a>一、auto类型推导</h1><p>auto这个关键字其实在C++11之前就已经存在了，在C++98中的auto关键字的作用是指明变量的存储类型，与static相对，在比较老C++书籍中可以找得到相关内容，只是在我们的实际编程中基本上被忽略，这是因为我们在创建变量时默认的存储类型就是auto—自动存储类型的，不需要显示表示，只有在需要声明静态变量时才会显示表示static，以指明变量的存储类型为静态存储类型。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>这里a和b的存储类型都是auto类型。</p><p>在C++11之后，C++标准摒弃了C++98的auto关键字的用法，将auto关键字的功能换成了自动类型推导，就和现在大多数脚本语言中的var一样。</p><p><font color="red"> 需要注意的是，在自动类型推导中，小数会被默认推导成double类型而不是float。</font></p><p>auto的出现并不意味着C++变成了弱类型语言，auto在程序中仅仅只起到占位符的作用，在编译期间它才会被替换成具体的类型，所以在运行时类型依然是明确的。</p><p><font color="red">auto关键字支持多变量声明，但是同时声明的变量必须是同一类型的，否则会出现编译不通过的错误。</font>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> a = <span class="hljs-number">1</span>,b = <span class="hljs-number">1.1</span>;<br></code></pre></td></tr></table></figure><p>这种情况会报错。</p><p><font color="red"> 在声明auto变量时，必须对变量进行初始化。</font>这种情况是语法错误：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> a,b;<br></code></pre></td></tr></table></figure><h2 id="auto、指针与引用"><a href="#auto、指针与引用" class="headerlink" title="auto、指针与引用"></a>auto、指针与引用</h2><p>先来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">auto</span> *p1 = &amp;a;<br><span class="hljs-keyword">auto</span> p2 = &amp;a;<br><span class="hljs-keyword">auto</span> p3 = p1;<br><span class="hljs-keyword">auto</span> &amp;r1 = a;<br><span class="hljs-keyword">auto</span> r2 = r1;<br><br><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(p1).name() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(p2).name() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(p3).name() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(r1).name() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(r2).name() &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *<br><span class="hljs-keyword">int</span> *<br><span class="hljs-keyword">int</span> *<br><span class="hljs-keyword">int</span><br><span class="hljs-keyword">int</span><br></code></pre></td></tr></table></figure><p>可以看到<font color="red">auto推导出了指针类型，却忽略了&amp;类型</font>，这一点是需要注意的。</p><h2 id="auto与const"><a href="#auto与const" class="headerlink" title="auto与const"></a>auto与const</h2><p>还是先来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">auto</span> c1 = a;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> c2 = a;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> *p = &amp;a;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;r1 = a;<br><span class="hljs-keyword">auto</span> &amp;r2 = r1;<br><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(c1).name() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(c2).name() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(p).name() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(r1).name() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(r2).name() &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span><br><span class="hljs-keyword">int</span><br><span class="hljs-keyword">int</span> <span class="hljs-keyword">const</span> *<br><span class="hljs-keyword">int</span><br><span class="hljs-keyword">int</span><br></code></pre></td></tr></table></figure><p>可以看到除了指针类型，其他的都被推导成了int类型，我们再在上面的代码中加一些代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">auto</span> c1 = a;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> c2 = a;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> *p = &amp;a;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;r1 = a;<br><span class="hljs-keyword">auto</span> &amp;r2 = r1;<br><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(c1).name() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(c2).name() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(p).name() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(r1).name() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(r2).name() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br><span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>;<br>c1 = <span class="hljs-number">2</span>;<br>c2 = <span class="hljs-number">2</span>;<br>p = b;<br>r1 = <span class="hljs-number">2</span>;<br>r2 = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>当我们添加了这段代码之后，除了<code>c1=2</code>，其他的行都会报语法错误，所以尽c2，r1，r2被推导为int类型，但是const的约束依旧存在，但是c1没有报语法错误，也就是说c1实际上是非const类型，即<code>auto c1 = a</code>，在默认情况下auto将c1推导为非常量，如果需要设置为常量则需要显示标识const。</p><p>关于<code>typeid().name()</code> 有一点很迷，就是在C++的语法中，只有常量指针类型在类型名上带有const，如上面的int const *，而其他的无论是指针常量、常量引用在类型上都是忽略const的，但是在我们把一个变量常量的地址赋予一个非常量指针时，则会报：</p><p><img src="/2021/03/17/%E3%80%90C++%E3%80%91C++11%E6%96%B0%E7%89%B9%E6%80%A7/%E3%80%90UE4%E3%80%91UE4GamePlay%E6%9E%B6%E6%9E%84%5CSnipaste_2021-03-18_14-34-58.png"></p><p>在网上没有找到相关的解析，推测在C++语法上是只有常量指针类型带有const，没有其他的带有const的类型的，而出现上面的提示十有八九是编辑器做的，而非C++本身的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>auto的作用是类型推导，本质是占位符，在编译阶段，编译器会将正确的类型替换到auto位置上；</li><li>auto可以和任何类型搭配，包括指针与引用；</li><li>在声明auto变量时必须对uto变量初始化；</li><li>auto关键字可以用作函数返回值类型。</li></ul><h1 id="二、decltype类型推导"><a href="#二、decltype类型推导" class="headerlink" title="二、decltype类型推导"></a>二、decltype类型推导</h1><p>由于auto的使用在有些方面上收到限制，比如，声明auto变量时必须对变量进行初始化，而在实际使用时，可能没法进行初始化，于是decltype就出现了，decltype也是C++的一个关键字。</p><p>decltype通过表达式来推导类型，表达式可以是一个变量、常量、或者函数，使用形式为<code>decltype(exp),exp为表达式</code>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* a)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> *a * <span class="hljs-number">0.2f</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">decltype</span>(fun(&amp;b)) a;<br>&#125;<br></code></pre></td></tr></table></figure><p>和auto一样decltype也可以用作函数返回值类型。</p><h2 id="decltype与auto的区别"><a href="#decltype与auto的区别" class="headerlink" title="decltype与auto的区别"></a>decltype与auto的区别</h2><ul><li>auto关键字声明的变量必须初始化，decltype不需要；</li><li>auto在类中只能用于定义静态成员，decltype可以用于任何成员；</li><li>decltype的使用上比auto更灵活；</li><li>auto更具初始值来推导类型，decltype根据表达式来推导类型。</li></ul><h1 id="三、返回类型后置语法"><a href="#三、返回类型后置语法" class="headerlink" title="三、返回类型后置语法"></a>三、返回类型后置语法</h1><p>有时候我们写函数需要用到函数参数来推导，由于C++的返回值是前置语法，所以返回值是无法使用函数参数的，于是便有了返回值类型后置语法，先看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span> U&gt;<br>auto fun(T a,U b)-&gt;decltype(a+b)<br>&#123;<br><span class="hljs-keyword">return</span> a+b;<br>&#125;<br></code></pre></td></tr></table></figure><p>返回值类型后置语法可以将decltype使用参数推导出的类型赋予auto中，所以在这个语法中auto，decltype是必不可少的。</p><p>我们仔细思考后会发现好像直接这样使用也是可以达到最终效果的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">fun</span><span class="hljs-params">(T a,U b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a+b;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么返回值后置类型语法的作用又是什么呢？事实上我们在多想一下就会明白，<code>auto fun(T a,U b)-&gt;decltype(a+b)</code>语法把auto的类型限制在decltype(a+b)的推导类型的范围内了，而auto fun(T a,U b)中auto是可以为任何类型的。但是在大多数使用场景下似乎还是没什么区别。</p><p>到这里只有一句感叹，C++在类型推导上相较于主流脚本语言的类型推导还是薄弱了很多很多。</p><h1 id="四、左值与右值"><a href="#四、左值与右值" class="headerlink" title="四、左值与右值"></a>四、左值与右值</h1>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPlus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Python】Python学习笔记</title>
    <link href="/2021/02/04/%E3%80%90Python%E3%80%91Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/02/04/%E3%80%90Python%E3%80%91Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><center><font size="6"><strong>Python基础</strong></font></center><a id="more"></a><h1 id="一、中文编码、注释与标准文档"><a href="#一、中文编码、注释与标准文档" class="headerlink" title="一、中文编码、注释与标准文档"></a>一、中文编码、注释与标准文档</h1><h2 id="1-中文编码"><a href="#1-中文编码" class="headerlink" title="1.中文编码"></a>1.中文编码</h2><p>若只需要在单个文件中指定中文编码，只需在文件开始处添加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># _*_ coding: UTF-8 _*_</span><br></code></pre></td></tr></table></figure><p>即可。</p><p>如果要在整个工程里设置中文编码，则需要在编辑器中设置工程的编码为UTF-8。</p><h2 id="2-单行注释"><a href="#2-单行注释" class="headerlink" title="2.单行注释"></a>2.单行注释</h2><p>python使用<code>#</code>来接单行注释</p><h2 id="3-多行注释"><a href="#3-多行注释" class="headerlink" title="3.多行注释"></a>3.多行注释</h2><p>python使用<code>&#39;&#39;&#39;</code>或<code>&quot;&quot;&quot;</code>（三个单引号或三个双引号）来包含多行注释</p><p>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这是单行注释</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">这是使用三个单引号的</span><br><span class="hljs-string">多行注释</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">这是使用三个双引号的</span><br><span class="hljs-string">多行注释</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h2 id="4-标准文档"><a href="#4-标准文档" class="headerlink" title="4.标准文档"></a>4.标准文档</h2><p><a href="https://docs.python.org/zh-cn/3.7/library/index.html">官方文档</a></p><h1 id="二、标识符与代码块"><a href="#二、标识符与代码块" class="headerlink" title="二、标识符与代码块"></a>二、标识符与代码块</h1><h2 id="1-标识符规则"><a href="#1-标识符规则" class="headerlink" title="1.标识符规则"></a>1.标识符规则</h2><ul><li>python标识符大小写敏感。</li><li>python中以下划线开头的标识符有特殊的含义，以单下划线开头的标识符代表不能直接访问的类属性，需要通过类提供的接口进行访问，不能用from xxx import *导入，如：_value。</li><li>以双下划线开头的标识符代表类的私有成员，如：<code>__value</code>。</li><li>以双下划线开头和结尾的标识符代表python里特殊方法的专用标识符，如：<code>__init__()</code>代表类的构造函数。</li></ul><h2 id="2-保留字符"><a href="#2-保留字符" class="headerlink" title="2.保留字符"></a>2.保留字符</h2><table><thead><tr><th align="center"></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">and</td><td align="center">exec</td><td align="center">not</td></tr><tr><td align="center">assert</td><td align="center">finally</td><td align="center">or</td></tr><tr><td align="center">break</td><td align="center">for</td><td align="center">pass</td></tr><tr><td align="center">class</td><td align="center">from</td><td align="center">print</td></tr><tr><td align="center">continue</td><td align="center">global</td><td align="center">raise</td></tr><tr><td align="center">def</td><td align="center">if</td><td align="center">return</td></tr><tr><td align="center">del</td><td align="center">import</td><td align="center">try</td></tr><tr><td align="center">elif</td><td align="center">in</td><td align="center">while</td></tr><tr><td align="center">else</td><td align="center">is</td><td align="center">with</td></tr><tr><td align="center">except</td><td align="center">lambda</td><td align="center">yield</td></tr></tbody></table><h2 id="3-代码块"><a href="#3-代码块" class="headerlink" title="3.代码块"></a>3.代码块</h2><p>python与C系列语言最大的不同就是python没有了<code>&#123;&#125;</code>囊括的代码块，而采用了<font color="red">缩进</font>来表示代码块，即在一个代码块中的代码采用同等数量的数量的缩进，缩进的数量按空格的数量计算，采用同一缩进量的代码属于同一格代码块。</p><p>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> ture:<br>    a = <span class="hljs-number">1</span><br>    b = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><code>a=1;</code>与<code>b=2</code>同属于if语句的代码块中。</p><h3 id="python空行规范"><a href="#python空行规范" class="headerlink" title="python空行规范"></a>python空行规范</h3><ul><li><p>类与其他代码块之间需要空两行</p></li><li><p>方法体与其他代码块之间需要空一行</p></li><li><p>全局函数与其他代码块之间需要空两行</p><p>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><br>    names = <span class="hljs-string">&#x27;aa&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, age, name</span>):</span><br>        self.age = age<br>        self.name = name<br>        addr = <span class="hljs-string">&#x27;beijing&#x27;</span><br>        names = <span class="hljs-string">&quot;bb&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">GetName</span>(<span class="hljs-params">self</span>):</span><br>        self.sex = <span class="hljs-string">&#x27;female&#x27;</span><br>        print(<span class="hljs-string">&#x27;my name is &#x27;</span> + self.names)<br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">PP</span>():</span><br>        print(names)<br>    <br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">OO</span>(<span class="hljs-params">cls</span>):</span>       <br>        print(cls.names)<br><br><br>p = Person(<span class="hljs-number">18</span>, <span class="hljs-string">&#x27;lusa&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul><h2 id="4-多行语句"><a href="#4-多行语句" class="headerlink" title="4.多行语句"></a>4.多行语句</h2><p>由于python即使用了<code>;</code>来分割同行的不同语句，同时通过新行来结束上一句语句，所以如果代码需要换行的话需要使用<font color="red"> <code>\</code></font>来分割多行。</p><p>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = b \<br>+ c \<br>    + d<br></code></pre></td></tr></table></figure><p><font color="green"> <strong>例外</strong>：包括在<code>[]</code>、<code>()</code>、<code>&#123;&#125;</code>中的语句换行不需要使用<code>\</code>。</font></p><h1 id="三、变量及数据结构"><a href="#三、变量及数据结构" class="headerlink" title="三、变量及数据结构"></a>三、变量及数据结构</h1><p>python支持</p><ul><li>Numbers-数字</li><li>String-字符串</li><li>List-列表</li><li>Tuple-原表</li><li>Dictionary-字典</li></ul><p>几种数据类型。</p><h2 id="1-Numbers"><a href="#1-Numbers" class="headerlink" title="1.Numbers"></a>1.Numbers</h2><p>其中Numbers又分为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph LR;<br>Numbers---int---有符号整型;<br>Numbers---long---长整型-使用小写l或大写L表示;<br>Numbers---float---浮点型;<br>Numbers---complex---复数-使用a+bj表示或complex函数生成;<br></code></pre></td></tr></table></figure><p>需要注意的是python不支持double。</p><p><font color="red"> long在python3.x以后被移除。</font></p><h2 id="2-String"><a href="#2-String" class="headerlink" title="2.String"></a>2.String</h2><p><font color="red">使用Python字符串时首先需要明确一点，就是Python不支持单字符，在Python中单字符也被当作字符串使用。</font></p><p>Python的字符串可以使用<code>&#39;</code>,<code>&quot;</code>,<code>&#39;&#39;&#39;</code>,<code>&quot;&quot;&quot;</code>来标识字符串，有单引号和双引号来表示字符串就够了，那么为什么Python要使用三单引号<code>&#39;&#39;&#39;</code>和三双引号<code>&quot;&quot;&quot;</code>来标识字符串呢？</p><h3 id="39-39-39-和-quot-quot-quot-的优点"><a href="#39-39-39-和-quot-quot-quot-的优点" class="headerlink" title="&#39;&#39;&#39;和&quot;&quot;&quot;的优点"></a><code>&#39;&#39;&#39;</code>和<code>&quot;&quot;&quot;</code>的优点</h3><p>要想直观的了解三单引号和三双引号的优点，我们首先使用C#字符串来写一个SQL语句</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">string</span> sql=<span class="hljs-string">&quot;select xm as 姓名,xb as 性别 from db_table where xm = @xm and xb = @xb and (bm like &#x27;%666&#x27; or bm like &#x27;666%&#x27;) order by grade &gt; 90 desc&quot;</span>;<br>OleDbCommand cmd = <span class="hljs-keyword">new</span> OleDbCommand();<br>cmd.CommandText = sql;<br>cmd.Parameters.AddWithValue(<span class="hljs-string">&quot;@xm&quot;</span>, txtName.Text);<br>cmd.Parameters.AddWithValue(<span class="hljs-string">&quot;@xb&quot;</span>, txtSex.Text);<br>cmd.Connection = conn;<br>conn.Open();<br>cmd.ExecuteNonQuery();<br></code></pre></td></tr></table></figure><p>我们再使用Python写一句同样的SQL语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Python">sql = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">select xm as 姓名,xb as 性别 from db_table </span><br><span class="hljs-string">where xm = &#x27;&#123;0&#125;&#x27; and xb = &#123;1&#125; and (bm like &#x27;%666&#x27; or bm like &#x27;666%&#x27;) </span><br><span class="hljs-string">order by grade &gt; 90 desc</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>.<span class="hljs-built_in">format</span>(txtName.Text,txtSex.Text)<br>cuesor = conn.cursor()<br>cursor.execute(sql)<br>cursor.close()<br></code></pre></td></tr></table></figure><p>有没有发现Python在写sql字符串时十分优雅呢？尤其是在写很长的sql语句时这个效果尤为突出，得益于Python三引号字符串的可换行支持，Python的sql可以在传参的同时保留sql的优雅格式，极大的提高了sql的可阅读性。</p><p>python的字符串是不可变的，当我们对字符串进行操作时，python都会生成新的字符串，而不会在旧的字符串的基础上进行修改。</p><ul><li>与C系列语言对字符串的操作有些差异的是python使用<code>*</code>来重复字符串，如：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;a&#x27;</span><br>str2 = <span class="hljs-built_in">str</span>*<span class="hljs-number">2</span> <span class="hljs-comment">#str2存储的是&#x27;aa&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>String支持从前索引和从后索引，从前索引的首地址索引为0，从后索引的末地址为-1</li></ul><table><thead><tr><th align="center">a</th><th align="center">b</th><th align="center">c</th><th align="center">d</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">3</td></tr><tr><td align="center">-4</td><td align="center">-3</td><td align="center">-2</td><td align="center">-1</td></tr></tbody></table><ul><li>python支持直接通过索引截取子字符串，如：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;abcd&#x27;</span><br>str2 = <span class="hljs-built_in">str</span>[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>] <span class="hljs-comment">#str2存储的是&#x27;bc&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="转移字符"><a href="#转移字符" class="headerlink" title="转移字符"></a>转移字符</h3><table><thead><tr><th>字符</th><th>说明</th></tr></thead><tbody><tr><td><code>\</code>(在行尾时)</td><td>续行符</td></tr><tr><td>\</td><td>反斜杠符号</td></tr><tr><td>&#39;</td><td>单引号</td></tr><tr><td>&quot;</td><td>双引号</td></tr><tr><td>\a</td><td>响铃</td></tr><tr><td>\b</td><td>退格(Backspace)</td></tr><tr><td>\e</td><td>转义</td></tr><tr><td>\000</td><td>空</td></tr><tr><td>\n</td><td>换行</td></tr><tr><td>\v</td><td>纵向制表符</td></tr><tr><td>\t</td><td>横向制表符</td></tr><tr><td>\r</td><td>回车</td></tr><tr><td>\f</td><td>换页</td></tr><tr><td>\oyy</td><td>八进制数，y 代表 0~7 的字符，例如：\012 代表换行</td></tr><tr><td>\xyy</td><td>十六进制数，以 \x 开头，yy代表的字符，例如：\x0a代表换行</td></tr><tr><td>\other</td><td>其它的字符以普通格式输出</td></tr></tbody></table><h3 id="两个特殊的字符串运算符"><a href="#两个特殊的字符串运算符" class="headerlink" title="两个特殊的字符串运算符"></a>两个特殊的字符串运算符</h3><table><thead><tr><th>字符</th><th>说明</th><th>实例</th></tr></thead><tbody><tr><td>r/R</td><td><font color="red">原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母<code>r</code>（可以大小写）以外，与普通字符串有着几乎完全相同的语法。</font></td><td>print(r’/n’)<br>输出结果：<br>/n</td></tr><tr><td>%</td><td>格式字符串</td><td></td></tr><tr><td>u</td><td>在字符串的前面加上一个字母u即表示创建Unicode字符串，可以通过<code>\u</code>+Unicode编码向字符串中插入任何Unicode支持的字符</td><td>print(u’a\u2201a’)<br>输出结果：<br>a⤀a</td></tr></tbody></table><h3 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><p>Python中的字符串格式化和C基本保持一致，插入整型也是用的<code>%d</code></p><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>%c</td><td>格式化字符及其ASCII码</td></tr><tr><td>%s</td><td>格式化字符串</td></tr><tr><td>%d</td><td>格式化整数</td></tr><tr><td>%u</td><td>格式化无符号整型</td></tr><tr><td>%o</td><td>格式化无符号八进制数</td></tr><tr><td>%x</td><td>格式化无符号十六进制数</td></tr><tr><td>%X</td><td>格式化无符号十六进制数（大写）</td></tr><tr><td>%f</td><td>格式化浮点数字，可指定小数点后的精度</td></tr><tr><td>%e</td><td>用科学计数法格式化浮点数</td></tr><tr><td>%E</td><td>作用同%e，用科学计数法格式化浮点数</td></tr><tr><td>%g</td><td>%f和%e的简写</td></tr><tr><td>%G</td><td>%F 和 %E 的简写</td></tr><tr><td>%p</td><td>用十六进制数格式化变量的地址</td></tr></tbody></table><h3 id="格式化操作辅助指令"><a href="#格式化操作辅助指令" class="headerlink" title="格式化操作辅助指令"></a>格式化操作辅助指令</h3><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>定义宽度或者小数点精度</td></tr><tr><td>-</td><td>用做左对齐</td></tr><tr><td>+</td><td>在正数前面显示加号( + )</td></tr><tr><td><code>&lt;sp&gt;</code></td><td>在正数前面显示空格</td></tr><tr><td>#</td><td>在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’)</td></tr><tr><td>0</td><td>显示的数字前面填充’0’而不是默认的空格</td></tr><tr><td>%</td><td>‘%%’输出一个单一的’%’</td></tr><tr><td>(var)</td><td>映射变量(字典参数)</td></tr><tr><td>m.n.</td><td>m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)</td></tr></tbody></table><h3 id="String内置函数"><a href="#String内置函数" class="headerlink" title="String内置函数"></a>String内置函数</h3><table><thead><tr><th align="left"><strong>方法</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/python/att-string-capitalize.html">string.capitalize()</a></td><td align="left">把字符串的第一个字符大写</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-center.html">string.center(width)</a></td><td align="left">返回一个原字符串居中,并使用空格填充至长度 width 的新字符串</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-count.html">string.count(str, beg=0, end=len(string))</a></strong></td><td align="left">返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-decode.html">string.decode(encoding=’UTF-8’, errors=’strict’)</a></td><td align="left">以 encoding 指定的编码格式解码 string，如果出错默认报一个 ValueError 的 异 常 ， 除非 errors 指 定 的 是 ‘ignore’ 或 者’replace’</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-encode.html">string.encode(encoding=’UTF-8’, errors=’strict’)</a></td><td align="left">以 encoding 指定的编码格式编码 string，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-endswith.html">string.endswith(obj, beg=0, end=len(string))</a></strong></td><td align="left">检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-expandtabs.html">string.expandtabs(tabsize=8)</a></td><td align="left">把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8。</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-find.html">string.find(str, beg=0, end=len(string))</a></strong></td><td align="left">检测 str 是否包含在 string 中，如果 beg 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回-1</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-format.html">string.format()</a></strong></td><td align="left">格式化字符串</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-index.html">string.index(str, beg=0, end=len(string))</a></strong></td><td align="left">跟find()方法一样，只不过如果str不在 string中会报一个异常.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-isalnum.html">string.isalnum()</a></td><td align="left">如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True,否则返回 False</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-isalpha.html">string.isalpha()</a></td><td align="left">如果 string 至少有一个字符并且所有字符都是字母则返回 True,否则返回 False</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-isdecimal.html">string.isdecimal()</a></td><td align="left">如果 string 只包含十进制数字则返回 True 否则返回 False.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-isdigit.html">string.isdigit()</a></td><td align="left">如果 string 只包含数字则返回 True 否则返回 False.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-islower.html">string.islower()</a></td><td align="left">如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-isnumeric.html">string.isnumeric()</a></td><td align="left">如果 string 中只包含数字字符，则返回 True，否则返回 False</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-isspace.html">string.isspace()</a></td><td align="left">如果 string 中只包含空格，则返回 True，否则返回 False.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-istitle.html">string.istitle()</a></td><td align="left">如果 string 是标题化的(见 title())则返回 True，否则返回 False</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-isupper.html">string.isupper()</a></td><td align="left">如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-join.html">string.join(seq)</a></strong></td><td align="left">以 string 作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-ljust.html">string.ljust(width)</a></td><td align="left">返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-lower.html">string.lower()</a></td><td align="left">转换 string 中所有大写字符为小写.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-lstrip.html">string.lstrip()</a></td><td align="left">截掉 string 左边的空格</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-maketrans.html">string.maketrans(intab, outtab])</a></td><td align="left">maketrans() 方法用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-max.html">max(str)</a></td><td align="left">返回字符串 <em>str</em> 中最大的字母。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-min.html">min(str)</a></td><td align="left">返回字符串 <em>str</em> 中最小的字母。</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-partition.html">string.partition(str)</a></strong></td><td align="left">有点像 find()和 split()的结合体,从 str 出现的第一个位置起,把 字 符 串 string 分 成 一 个 3 元 素 的 元 组 (string_pre_str,str,string_post_str),如果 string 中不包含str 则 string_pre_str == string.</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-replace.html">string.replace(str1, str2, num=string.count(str1))</a></strong></td><td align="left">把 string 中的 str1 替换成 str2,如果 num 指定，则替换不超过 num 次.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-rfind.html">string.rfind(str, beg=0,end=len(string) )</a></td><td align="left">类似于 find() 函数，返回字符串最后一次出现的位置，如果没有匹配项则返回 -1。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-rindex.html">string.rindex( str, beg=0,end=len(string))</a></td><td align="left">类似于 index()，不过是从右边开始.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-rjust.html">string.rjust(width)</a></td><td align="left">返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-rpartition.html">string.rpartition(str)</a></td><td align="left">类似于 partition()函数,不过是从右边开始查找</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-rstrip.html">string.rstrip()</a></td><td align="left">删除 string 字符串末尾的空格.</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-split.html">string.split(str=””, num=string.count(str))</a></strong></td><td align="left">以 str 为分隔符切片 string，如果 num 有指定值，则仅分隔 num+ 个子字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-splitlines.html">string.splitlines(keepends)</a></td><td align="left">按照行(‘\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-startswith.html">string.startswith(obj, beg=0,end=len(string))</a></td><td align="left">检查字符串是否是以 obj 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查.</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-strip.html">string.strip(obj)</a></strong></td><td align="left">在 string 上执行 lstrip()和 rstrip()</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-swapcase.html">string.swapcase()</a></td><td align="left">翻转 string 中的大小写</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-title.html">string.title()</a></td><td align="left">返回”标题化”的 string,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-translate.html">string.translate(str, del=””)</a></strong></td><td align="left">根据 str 给出的表(包含 256 个字符)转换 string 的字符,要过滤掉的字符放到 del 参数中</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-upper.html">string.upper()</a></td><td align="left">转换 string 中的小写字母为大写</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-zfill.html">string.zfill(width)</a></td><td align="left">返回长度为 width 的字符串，原字符串 string 右对齐，前面填充0</td></tr></tbody></table><h2 id="3-Tuple"><a href="#3-Tuple" class="headerlink" title="3.Tuple"></a>3.Tuple</h2><p>==元组类似与C#中<code>readonly List</code>，是一个只读列表，但是python的元组的元素可以是不同的类型，python用<code>()</code>来表示元组。==元组支持存储不同类型元素，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">t = (<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3.14</span>)<br></code></pre></td></tr></table></figure><p>这里的元组只读及元素不可修改</p><h3 id="创建空元组"><a href="#创建空元组" class="headerlink" title="创建空元组"></a>创建空元组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">t = ()<br></code></pre></td></tr></table></figure><h3 id="创建一个值的元组"><a href="#创建一个值的元组" class="headerlink" title=" 创建一个值的元组"></a><font color="red"> 创建一个值的元组</font></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">t = (<span class="hljs-number">12</span>,)//逗号不可省略<br></code></pre></td></tr></table></figure><p><font color="red"> 需要特别注意的是<code>,</code>不可省略，如果省略了，<code>t=(12)</code>就等于<code>t=12</code></font></p><h3 id="元组的分片操作"><a href="#元组的分片操作" class="headerlink" title="元组的分片操作"></a>元组的分片操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">t = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)<br>print(t[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>])<br><span class="hljs-comment">#输出结果为2，3</span><br></code></pre></td></tr></table></figure><p>分片操作可以批量的取元组中的数据，值不能取到3号索引，只能取到3号索引的前一位。</p><h3 id="Tuple的-和-操作"><a href="#Tuple的-和-操作" class="headerlink" title="Tuple的+和*操作"></a>Tuple的+和*操作</h3><p>和字符串一样，列表的+运算用于组合列表，列表的*运算用于重复列表，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">tu1 = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>tu2 = tu1 + tu1<br>print(tu2)<br>tu3 = tu1*<span class="hljs-number">3</span><br>print(tu3)<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]  <br></code></pre></td></tr></table></figure><h3 id="Tuple的无关分隔符"><a href="#Tuple的无关分隔符" class="headerlink" title="Tuple的无关分隔符"></a>Tuple的无关分隔符</h3><p>任意无符号对象，只要以<code>,</code>分隔，Python都将其是为元组，如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span> <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">3.14</span><br>tu = x, y = <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span><br></code></pre></td></tr></table></figure><p><code>1, 2, &#39;a&#39;, 3.14</code>，会被视为一个元组，及print打印的事实上是一个元组，tu也会被Python默认转换成一个元组，当然x，y还是可以才开使用的。</p><h3 id="Python内置元组操作函数"><a href="#Python内置元组操作函数" class="headerlink" title="Python内置元组操作函数"></a>Python内置元组操作函数</h3><table><thead><tr><th align="left">方法</th><th>描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/python/att-tuple-cmp.html">cmp(tuple1, tuple2)</a></td><td>比较两个元组元素。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-tuple-len.html">len(tuple)</a></td><td>计算元组元素个数。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-tuple-max.html">max(tuple)</a></td><td>返回元组中元素最大值。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-tuple-min.html">min(tuple)</a></td><td>返回元组中元素最小值。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-tuple-tuple.html">tuple(seq)</a></td><td>将列表转换为元组。</td></tr></tbody></table><h2 id="4-List"><a href="#4-List" class="headerlink" title="4.List"></a>4.List</h2><p>List就和C#中的List基本一致，但是python的List更灵活</p><h3 id="List初始化"><a href="#List初始化" class="headerlink" title="List初始化"></a>List初始化</h3><p>List的初始化使用<code>[]</code>，我们可以使用‘数字’、‘字符串’、‘元组’或‘列表’来初始化一个列表，列表也支持分片操作。</p><p>python的列表可以在一个列表中存储不同类型的元素。</p><p>并且提供一些基础函数</p><ul><li><p>index：从列表中找出某个元素的位置，如果有多个相同的元素，则返回第一个元素的位置，如果没有找到则抛出异常。</p></li><li><p>count：统计某个元素在列表中出现的次数。</p></li><li><p>append：列表末尾增加新的元素。</p></li><li><p>extend：将一个新列表的元素添加到原列表中。</p><p>注意到，虽然 append 和 extend 可接收一个列表作为参数，但是 append 方法是将其作为一个元素添加到列表中，而 extend 则是将新列表的元素逐个添加到原列表中。</p></li><li><p>insert：将某个元素添加到某个位置。</p></li><li><p>pop：移除列表中的一个元素（默认是最后一个），并且返回该元素的值。</p></li><li><p>remove：移除列表中的某个匹配元素，如果有多个匹配，则移除第一个。</p></li><li><p>reverse：将列表中的元素进行反转。</p></li><li><p>sort：对列表进行排序，注意该方法会改变原来的列表，而不是返回新的排序列表，另外，sort 方法的返回值是空。</p><p>如果要使用sort对列表进行排序，那么列表中元素应该保持同一类型。</p></li><li><p>clear：清空列表。</p></li></ul><h3 id="列表的集合运算"><a href="#列表的集合运算" class="headerlink" title="列表的集合运算"></a>列表的集合运算</h3><p>Python提供内置的<code>set()</code>函数来对元素集进行集合运算，set函数支持所有可迭代的对象，包括list和tuple。只要是set函数支持的对象，尽管进行运算的两个对象不是相同类型也依旧可以进行集合运算，如：</p><p><strong>取交集</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">l1 = [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-literal">True</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>l2 = (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-literal">True</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br>print(<span class="hljs-built_in">set</span>(l1) &amp; <span class="hljs-built_in">set</span>(l2))<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-number">1</span>， <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p><font color="red"> 注意：当bool值进行集合运算时会被转换成0和1，但是这个0和1不会和数字的0和1重复。</font></p><p>Python集合运算符</p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>|</td><td>取并集</td></tr><tr><td>&amp;</td><td>取交集</td></tr><tr><td>-</td><td>取差集</td></tr><tr><td>^</td><td>取对称差集</td></tr></tbody></table><p><font color="red"> 集合运算符支持<code>set()</code>函数返回的<code>set</code>集合作为运算对象。</font></p><h3 id="List的-和-操作"><a href="#List的-和-操作" class="headerlink" title="List的+和*操作"></a>List的+和*操作</h3><p>和字符串一样，列表的+运算用于组合列表，列表的*运算用于重复列表，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">li = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>li2 = li + li<br>print(li2)<br>li3 = li*<span class="hljs-number">3</span><br>print(li3)<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]  <br></code></pre></td></tr></table></figure><h3 id="Python内置列表操作函数"><a href="#Python内置列表操作函数" class="headerlink" title="Python内置列表操作函数"></a>Python内置列表操作函数</h3><table><thead><tr><th align="left">函数</th><th>描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/python/att-list-cmp.html">cmp(list1, list2)</a></td><td>比较两个列表的元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-list-len.html">len(list)</a></td><td>列表元素个数</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-list-max.html">max(list)</a></td><td>返回列表元素最大值</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-list-min.html">min(list)</a></td><td>返回列表元素最小值</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-list-list.html">list(seq)</a></td><td>将元组转换为列表</td></tr></tbody></table><h3 id="List内置函数"><a href="#List内置函数" class="headerlink" title="List内置函数"></a>List内置函数</h3><table><thead><tr><th align="left">方法</th><th>描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/python/att-list-append.html">list.append(obj)</a></td><td>在列表末尾添加新的对象</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-list-count.html">list.count(obj)</a></td><td>统计某个元素在列表中出现的次数</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-list-extend.html">list.extend(seq)</a></td><td>在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-list-index.html">list.index(obj)</a></td><td>从列表中找出某个值第一个匹配项的索引位置</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-list-insert.html">list.insert(index, obj)</a></td><td>将对象插入列表</td></tr><tr><td align="left">[list.pop(<a href="https://www.runoob.com/python/att-list-pop.html">index=-1])</a></td><td>移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-list-remove.html">list.remove(obj)</a></td><td>移除列表中某个值的第一个匹配项</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-list-reverse.html">list.reverse()</a></td><td>反向列表中元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-list-sort.html">list.sort(cmp=None, key=None, reverse=False)</a></td><td>对原列表进行排序</td></tr></tbody></table><h2 id="5-Dictionary"><a href="#5-Dictionary" class="headerlink" title="5.Dictionary"></a>5.Dictionary</h2><p>Python的字典和C#中的字典的用法基本一致，不同的时Python使用<code>&#123;&#125;</code>来创建字典，使用<code>:</code>来连接键值对，使用<code>,</code>来分割元素。如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">dic = &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-literal">True</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&quot;Py&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>: <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><p>Python自定更强大的地方在于，Python字典在一个字典里支持不同类型的键和值。</p><p><font color="red"> 字典的键只能是数字、字符串或元组类型，而值没有任何要求。</font></p><h3 id="Python内置字典操作函数"><a href="#Python内置字典操作函数" class="headerlink" title="Python内置字典操作函数"></a>Python内置字典操作函数</h3><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/python/att-dictionary-cmp.html">cmp(dict1, dict2)</a></td><td>比较两个字典元素。</td></tr><tr><td><a href="https://www.runoob.com/python/att-dictionary-len.html">len(dict)</a></td><td>计算字典元素个数，即键的总数。</td></tr><tr><td><a href="https://www.runoob.com/python/att-dictionary-str.html">str(dict)</a></td><td>输出字典可打印的字符串表示。</td></tr><tr><td><a href="https://www.runoob.com/python/att-dictionary-type.html">type(variable)</a></td><td>返回输入的变量类型，如果变量是字典就返回字典类型。</td></tr></tbody></table><h3 id="Dictionary内置函数"><a href="#Dictionary内置函数" class="headerlink" title="Dictionary内置函数"></a>Dictionary内置函数</h3><table><thead><tr><th align="left">函数</th><th>描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/python/att-dictionary-clear.html">dict.clear()</a></td><td>删除字典内所有元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-dictionary-copy.html">dict.copy()</a></td><td>返回一个字典的浅复制</td></tr><tr><td align="left">[dict.fromkeys(seq<a href="https://www.runoob.com/python/att-dictionary-fromkeys.html">, val])</a></td><td>创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-dictionary-get.html">dict.get(key, default=None)</a></td><td>返回指定键的值，如果值不在字典中返回default值</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-dictionary-has_key.html">dict.has_key(key)</a></td><td>如果键在字典dict里返回true，否则返回false</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-dictionary-items.html">dict.items()</a></td><td>以列表返回可遍历的(键, 值) 元组数组</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-dictionary-keys.html">dict.keys()</a></td><td>以列表返回一个字典所有的键</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-dictionary-setdefault.html">dict.setdefault(key, default=None)</a></td><td>和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-dictionary-update.html">dict.update(dict2)</a></td><td>把字典dict2的键/值对更新到dict里</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-dictionary-values.html">dict.values()</a></td><td>以列表返回字典中的所有值</td></tr><tr><td align="left">[pop(key<a href="https://www.runoob.com/python/python-att-dictionary-pop.html">,default])</a></td><td>删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/python-att-dictionary-popitem.html">popitem()</a></td><td>返回并删除字典中的最后一对键和值。</td></tr></tbody></table><h2 id="6-日期和时间"><a href="#6-日期和时间" class="headerlink" title="6.日期和时间"></a>6.日期和时间</h2><p>Python的日期时间函数被放在了<code>time</code>、<code>datetime</code>和<code>calender</code>模块下，这里有几个点是需要注意的</p><h3 id="time-time"><a href="#time-time" class="headerlink" title="time.time()"></a>time.time()</h3><p>time.time()函数返回的是从1970年1月1日午夜到当前时间所经过的总时长。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br>print(time.time())<br><span class="hljs-comment">#当前时间为：2021.2.6 09：51</span><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1612576137.817901</span><br></code></pre></td></tr></table></figure><h3 id="time-localtime"><a href="#time-localtime" class="headerlink" title="time.localtime()"></a>time.localtime()</h3><p>那么如何输出当前时间呢？答案就是使用<code>time.localtime(time.time())</code>来计算当前时间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br>print(time.localtime(time.time()))<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">time.struct_time(tm_year=<span class="hljs-number">2021</span>, tm_mon=<span class="hljs-number">2</span>, tm_mday=<span class="hljs-number">6</span>, tm_hour=<span class="hljs-number">9</span>, tm_min=<span class="hljs-number">51</span>, tm_sec=<span class="hljs-number">39</span>, tm_wday=<span class="hljs-number">5</span>, tm_yday=<span class="hljs-number">37</span>, tm_isdst=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>可以看到，函数返回的不是格式化的<code>2021.2.6 9:51</code>而是一个<code>struct_time</code>时间元组，什么是时间元组？</p><h3 id="时间元组"><a href="#时间元组" class="headerlink" title="时间元组"></a>时间元组</h3><p>很多Python函数用一个元组装起来的9组数字处理时间:</p><table><thead><tr><th align="left">序号</th><th align="left">字段</th><th align="left">值</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">4位数年</td><td align="left">2008</td></tr><tr><td align="left">1</td><td align="left">月</td><td align="left">1 到 12</td></tr><tr><td align="left">2</td><td align="left">日</td><td align="left">1到31</td></tr><tr><td align="left">3</td><td align="left">小时</td><td align="left">0到23</td></tr><tr><td align="left">4</td><td align="left">分钟</td><td align="left">0到59</td></tr><tr><td align="left">5</td><td align="left">秒</td><td align="left">0到61 (60或61 是闰秒)</td></tr><tr><td align="left">6</td><td align="left">一周的第几日</td><td align="left">0到6 (0是周一)</td></tr><tr><td align="left">7</td><td align="left">一年的第几日</td><td align="left">1到366 (儒略历)</td></tr><tr><td align="left">8</td><td align="left">夏令时</td><td align="left">-1, 0, 1, -1是决定是否为夏令时的旗帜</td></tr></tbody></table><p>而struct_time就是其中之一，struct_time的结构：</p><table><thead><tr><th align="left">序号</th><th align="left">属性</th><th align="left">值</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">tm_year</td><td align="left">2021</td></tr><tr><td align="left">1</td><td align="left">tm_mon</td><td align="left">1 到 12</td></tr><tr><td align="left">2</td><td align="left">tm_mday</td><td align="left">1 到 31</td></tr><tr><td align="left">3</td><td align="left">tm_hour</td><td align="left">0 到 23</td></tr><tr><td align="left">4</td><td align="left">tm_min</td><td align="left">0 到 59</td></tr><tr><td align="left">5</td><td align="left">tm_sec</td><td align="left">0 到 61 (60或61 是闰秒)</td></tr><tr><td align="left">6</td><td align="left">tm_wday</td><td align="left">0到6 (0是周一)</td></tr><tr><td align="left">7</td><td align="left">tm_yday</td><td align="left">1 到 366(儒略历)</td></tr><tr><td align="left">8</td><td align="left">tm_isdst</td><td align="left">-1, 0, 1, -1是决定是否为夏令时的旗帜</td></tr></tbody></table><h3 id="获取格式化时间"><a href="#获取格式化时间" class="headerlink" title="获取格式化时间"></a>获取格式化时间</h3><p>那么如何获取格式化时间呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">print(time.asctime(time.localtime(time.time())))<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">Sat Feb  <span class="hljs-number">6</span> <span class="hljs-number">10</span>:<span class="hljs-number">28</span>:09 <span class="hljs-number">2021</span><br></code></pre></td></tr></table></figure><p>time.localtime()返回的是一个字符串，除此之外我们看还可以使用<font color="red"><code>time.strftime()</code></font>函数来自定义时间格式化格式，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">print(time.strftime(<span class="hljs-string">&quot;%H:%M:%S %Y-%m-%d&quot;</span>, time.localtime()))<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">10</span>:<span class="hljs-number">51</span>:<span class="hljs-number">12</span> <span class="hljs-number">2021</span>-02-06<br></code></pre></td></tr></table></figure><h3 id="时间日期格式化符号"><a href="#时间日期格式化符号" class="headerlink" title="时间日期格式化符号"></a>时间日期格式化符号</h3><table><thead><tr><th>符号</th><th>描述</th></tr></thead><tbody><tr><td>%y</td><td>两位数的年份表示（00-99）</td></tr><tr><td>%Y</td><td>四位数的年份表示（000-9999）</td></tr><tr><td>%m</td><td>月份（01-12）</td></tr><tr><td>%d</td><td>月内中的一天（0-31）</td></tr><tr><td>%H</td><td>24小时制小时数（0-23）</td></tr><tr><td>%I</td><td>12小时制小时数（01-12）</td></tr><tr><td>%M</td><td>分钟数（00-59）</td></tr><tr><td>%S</td><td>秒（00-59）</td></tr><tr><td>%a</td><td>本地简化星期名称</td></tr><tr><td>%A</td><td>本地完整星期名称</td></tr><tr><td>%b</td><td>本地简化的月份名称</td></tr><tr><td>%B</td><td>本地完整的月份名称</td></tr><tr><td>%c</td><td>本地相应的日期表示和时间表示</td></tr><tr><td>%j</td><td>年内的一天（001-366）</td></tr><tr><td>%p</td><td>本地A.M.或P.M.的等价符</td></tr><tr><td>%U</td><td>一年中的星期数（00-53）星期天为星期的开始</td></tr><tr><td>%w</td><td>星期（0-6），星期天为星期的开始</td></tr><tr><td>%W</td><td>一年中的星期数（00-53）星期一为星期的开始</td></tr><tr><td>%x</td><td>本地相应的日期表示</td></tr><tr><td>%X</td><td>本地相应的时间表示</td></tr><tr><td>%Z</td><td>当前时区的名称</td></tr><tr><td>%%</td><td>%号本身</td></tr></tbody></table><h3 id="time与datetime库"><a href="#time与datetime库" class="headerlink" title="time与datetime库"></a>time与datetime库</h3><p>python处理时间处理time模块还可以使用datetime模块，那么time和datetime之间有什么区别呢？</p><p>在 Python 文档里，<code>time</code>是归类在<code>Generic Operating System Services</code>中，换句话说， 它提供的功能是更加接近于操作系统层面的。通读<a href="https://docs.python.org/2.7/library/time.html">文档</a>可知，time 模块是围绕着 Unix Timestamp 进行的。</p><p>该模块主要包括一个类 <code>struct_time</code>，另外其他几个函数及相关常量。 需要注意的是在该模块中的大多数函数是调用了所在平台<code>C library</code>的同名函数， 所以要特别注意有些函数是平台相关的，可能会在不同的平台有不同的效果。另外一点是，由于是基于Unix Timestamp，所以其所能表述的日期范围被限定在 1970 - 2038 之间，如果你写的代码需要处理在前面所述范围之外的日期，那可能需要考虑使用<code>datetime</code>模块更好。</p><p>datetime 比 time 高级了不少，可以理解为 datetime 基于 time 进行了封装，提供了更多实用的函数。</p><table><thead><tr><th>类</th><th>描述</th></tr></thead><tbody><tr><td>timedelta</td><td>主要用于计算时间跨度</td></tr><tr><td>tzinfo</td><td>时区相关</td></tr><tr><td>time</td><td>只关注时间</td></tr><tr><td>date</td><td>只关注日期</td></tr><tr><td>datetime</td><td>同时有时间和日期</td></tr></tbody></table><h3 id="calendar库"><a href="#calendar库" class="headerlink" title="calendar库"></a>calendar库</h3><p>calendar库主要用于处理日历，如：打印2021年2月的日历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">print(calendar.month(<span class="hljs-number">2021</span>, <span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">    January <span class="hljs-number">2021</span><br>Mo Tu We Th Fr Sa Su<br>             <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span><br> <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span> <span class="hljs-number">10</span><br><span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span><br><span class="hljs-number">18</span> <span class="hljs-number">19</span> <span class="hljs-number">20</span> <span class="hljs-number">21</span> <span class="hljs-number">22</span> <span class="hljs-number">23</span> <span class="hljs-number">24</span><br><span class="hljs-number">25</span> <span class="hljs-number">26</span> <span class="hljs-number">27</span> <span class="hljs-number">28</span> <span class="hljs-number">29</span> <span class="hljs-number">30</span> <span class="hljs-number">31</span><br></code></pre></td></tr></table></figure><h3 id="time库内置函数"><a href="#time库内置函数" class="headerlink" title="time库内置函数"></a>time库内置函数</h3><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/python/att-time-altzone.html">time.altzone</a></td><td align="left">返回格林威治西部的夏令时地区的偏移秒数。如果该地区在格林威治东部会返回负值（如西欧，包括英国）。对夏令时启用地区才能使用。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-time-asctime.html">time.asctime([tupletime])</a></td><td align="left">接受时间元组并返回一个可读的形式为”Tue Dec 11 18:07:14 2008”（2008年12月11日 周二18时07分14秒）的24个字符的字符串。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-time-clock.html">time.clock( )</a></td><td align="left">用以浮点数计算的秒数返回当前的CPU时间。用来衡量不同程序的耗时，比time.time()更有用。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-time-ctime.html">time.ctime([secs])</a></td><td align="left">作用相当于asctime(localtime(secs))，未给参数相当于asctime()</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-time-gmtime.html">time.gmtime([secs])</a></td><td align="left">接收时间戳（1970纪元后经过的浮点秒数）并返回格林威治天文时间下的时间元组t。注：t.tm_isdst始终为0</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-time-localtime.html">time.localtime([secs])</a></td><td align="left">接收时间戳（1970纪元后经过的浮点秒数）并返回当地时间下的时间元组t（t.tm_isdst可取0或1，取决于当地当时是不是夏令时）。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-time-mktime.html">time.mktime(tupletime)</a></td><td align="left">接受时间元组并返回时间戳（1970纪元后经过的浮点秒数）。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-time-sleep.html">time.sleep(secs)</a></td><td align="left">推迟调用线程的运行，secs指秒数。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-time-strftime.html">time.strftime(fmt[,tupletime])</a></td><td align="left">接收以时间元组，并返回以可读字符串表示的当地时间，格式由fmt决定。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-time-strptime.html">time.strptime(str,fmt=’%a %b %d %H:%M:%S %Y’)</a></td><td align="left">根据fmt的格式把一个时间字符串解析为时间元组。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-time-time.html">time.time( )</a></td><td align="left">返回当前时间的时间戳（1970纪元后经过的浮点秒数）。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-time-tzset.html">time.tzset()</a></td><td align="left">根据环境变量TZ重新初始化时间相关设置。</td></tr></tbody></table><h3 id="两个time库重要属性"><a href="#两个time库重要属性" class="headerlink" title="两个time库重要属性"></a>两个time库重要属性</h3><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><strong>time.timezone</strong></td><td align="left">属性 time.timezone 是当地时区（未启动夏令时）距离格林威治的偏移秒数（&gt;0，美洲&lt;=0大部分欧洲，亚洲，非洲）。</td></tr><tr><td align="left"><strong>time.tzname</strong></td><td align="left">属性time.tzname包含一对根据情况的不同而不同的字符串，分别是带夏令时的本地时区名称，和不带的。</td></tr></tbody></table><h3 id="calendar内置函数"><a href="#calendar内置函数" class="headerlink" title="calendar内置函数"></a>calendar内置函数</h3><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><strong>calendar.calendar(year,w=2,l=1,c=6)</strong></td><td align="left">返回一个多行字符串格式的year年年历，3个月一行，间隔距离为c。 每日宽度间隔为w字符。每行长度为21* W+18+2* C。l是每星期行数。</td></tr><tr><td align="left"><strong>calendar.firstweekday( )</strong></td><td align="left">返回当前每周起始日期的设置。默认情况下，首次载入 calendar 模块时返回 0，即星期一。</td></tr><tr><td align="left"><strong>calendar.isleap(year)</strong></td><td align="left">是闰年返回 True，否则为 False。<code>&gt;&gt;&gt; import calendar &gt;&gt;&gt; print(calendar.isleap(2000)) True &gt;&gt;&gt; print(calendar.isleap(1900)) False</code></td></tr><tr><td align="left"><strong>calendar.leapdays(y1,y2)</strong></td><td align="left">返回在Y1，Y2两年之间的闰年总数。</td></tr><tr><td align="left"><strong>calendar.month(year,month,w=2,l=1)</strong></td><td align="left">返回一个多行字符串格式的year年month月日历，两行标题，一周一行。每日宽度间隔为w字符。每行的长度为7* w+6。l是每星期的行数。</td></tr><tr><td align="left"><strong>calendar.monthcalendar(year,month)</strong></td><td align="left">返回一个整数的单层嵌套列表。每个子列表装载代表一个星期的整数。Year年month月外的日期都设为0;范围内的日子都由该月第几日表示，从1开始。</td></tr><tr><td align="left"><strong>calendar.monthrange(year,month)</strong></td><td align="left">返回两个整数。第一个是该月的星期几的日期码，第二个是该月的日期码。日从0（星期一）到6（星期日）;月从1到12。</td></tr><tr><td align="left"><strong>calendar.prcal(year,w=2,l=1,c=6)</strong></td><td align="left">相当于 **print calendar.calendar(year,w=2,l=1,c=6)**。</td></tr><tr><td align="left"><strong>calendar.prmonth(year,month,w=2,l=1)</strong></td><td align="left">相当于 <strong>print calendar.month(year,month,w=2,l=1)</strong> 。</td></tr><tr><td align="left"><strong>calendar.setfirstweekday(weekday)</strong></td><td align="left">设置每周的起始日期码。0（星期一）到6（星期日）。</td></tr><tr><td align="left"><strong>calendar.timegm(tupletime)</strong></td><td align="left">和time.gmtime相反：接受一个时间元组形式，返回该时刻的时间戳（1970纪元后经过的浮点秒数）。</td></tr><tr><td align="left"><strong>calendar.weekday(year,month,day)</strong></td><td align="left">返回给定日期的日期码。0（星期一）到6（星期日）。月份为 1（一月） 到 12（12月）。</td></tr></tbody></table><h2 id="7-set集合"><a href="#7-set集合" class="headerlink" title="7.set集合"></a>7.set集合</h2><p>python的set集合和C++的set集合的用法基本是一样的，set集合是一个无序不重复序列，python使用<code>&#123;&#125;</code>或<code>set()</code>函数来创建set集合，区别字典的地方是{}包括的元素不是键值对，需要注意的是，创建空集合只能通过set()函数。</p><h2 id="8-类型转换"><a href="#8-类型转换" class="headerlink" title="8.类型转换"></a>8.类型转换</h2><p>Python提供了大量内置类型转换函数：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>int(x <a href="https://www.runoob.com/python/python-func-int.html">,[base])</a></td><td>将x转换为一个整数</td></tr><tr><td>long(x <a href="https://www.runoob.com/python/python-func-long.html">,[base] )</a></td><td>将x转换为一个长整数</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-float.html">float(x)</a></td><td>将x转换到一个浮点数</td></tr><tr><td>complex(real <a href="https://www.runoob.com/python/python-func-complex.html">[,imag])</a></td><td>创建一个复数</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-str.html">str(x)</a></td><td>将对象 x 转换为字符串</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-repr.html">repr(x)</a></td><td>将对象 x 转换为表达式字符串</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-eval.html">eval(str)</a></td><td>用来计算在字符串中的有效Python表达式,并返回一个对象</td></tr><tr><td><a href="https://www.runoob.com/python/att-tuple-tuple.html">tuple(s)</a></td><td>将序列 s 转换为一个元组</td></tr><tr><td><a href="https://www.runoob.com/python/att-list-list.html">list(s)</a></td><td>将序列 s 转换为一个列表</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-set.html">set(s)</a></td><td>转换为可变集合</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-dict.html">dict(d)</a></td><td>创建一个字典。d 必须是一个序列 (key,value)元组。</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-frozenset.html">frozenset(s)</a></td><td>转换为不可变集合</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-chr.html">chr(x)</a></td><td>将一个整数转换为一个字符</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-unichr.html">unichr(x)</a></td><td>将一个整数转换为Unicode字符</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-ord.html">ord(x)</a></td><td>将一个字符转换为它的整数值</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-hex.html">hex(x)</a></td><td>将一个整数转换为一个十六进制字符串</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-oct.html">oct(x)</a></td><td>将一个整数转换为一个八进制字符串</td></tr></tbody></table><h1 id="四、运算符"><a href="#四、运算符" class="headerlink" title="四、运算符"></a>四、运算符</h1><h2 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1.算术运算符"></a>1.算术运算符</h2><p>Python的算术运算基本和C系列语言没什么区别，唯一的区别在于Python将C系列语言的求幂函数和取整函数直接内置到了Python的运算符里了，如：</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>**</td><td>求幂运算符，二元运算符，a**b表示求a的b次幂</td></tr><tr><td>//</td><td>取整运算符，二元运算符，a//b表示a对b取整，如9//4 = 2</td></tr></tbody></table><h2 id="2-赋值运算符"><a href="#2-赋值运算符" class="headerlink" title="2.赋值运算符"></a>2.赋值运算符</h2><p>和算数运算符一样，Python也将求幂运算和取整运算的赋值运算内置到运算符里。</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>**=</td><td>幂赋值运算符</td></tr><tr><td>//=</td><td>取整赋值运算符</td></tr></tbody></table><h2 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3.逻辑运算符"></a>3.逻辑运算符</h2><p>由于Python的底层是用C写的所有C的逻辑运算符（<code>&amp;</code>,<code>|</code>,<code>!</code>）在Python中就不能再使用了，所以Python使用（<code>and</code>,<code>or</code>,<code>not</code>）来做逻辑运算符，用法和<code>&amp;</code>,<code>|</code>,<code>!</code>一样。</p><h2 id="4-成员运算符"><a href="#4-成员运算符" class="headerlink" title="4.成员运算符"></a>4.成员运算符</h2><p>和前面一样，Python也将判断函数直接内置到运算符中了，Python成员运算符作用就是判断指定序列中是否包含某个指定元素，序列支持字符串，列表和元组。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>in</td><td>如果指定元素在指定序列中则返回True</td></tr><tr><td>not in</td><td>如果指定元素不在指定序列中则返回True</td></tr></tbody></table><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">li</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>tu = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)<br>st = “<span class="hljs-number">12345</span>”<br><span class="hljs-selector-tag">a</span> = <span class="hljs-number">1</span><br><span class="hljs-selector-tag">b</span> = ‘<span class="hljs-number">1</span>’<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(a in li)</span></span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(a not in tu)</span></span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(b in st)</span></span><br></code></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-literal">True</span><br><span class="hljs-literal">False</span><br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h2 id="5-身份运算符"><a href="#5-身份运算符" class="headerlink" title="5.身份运算符"></a>5.身份运算符</h2><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>is</td><td>判断两个对象是否来自同一引用</td></tr><tr><td>is not</td><td>判断两个对象是否不同的引用</td></tr></tbody></table><p>Pyhton的身份运算符和C#的is是不一样的，Python的is用于判断两个对象是否来引用同一引用，而C#的is则是判断某一对象是否是指定类型。</p><p>使用案例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span>  = <span class="hljs-number">1</span><br><span class="hljs-selector-tag">b</span> = a<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(a is b)</span></span><br><span class="hljs-selector-tag">b</span> = <span class="hljs-number">2</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(a is not b)</span></span><br>c = <span class="hljs-number">2</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(b is c)</span></span><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-literal">True</span><br><span class="hljs-literal">True</span><br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>这里出现了一个疑问，为什么b和c来自同一引用呢？<br>我们查看一下b和c的内存地址</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-title">id</span>(<span class="hljs-variable">b</span>))</span><br><span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-title">id</span>(<span class="hljs-variable">c</span>))</span><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">2324527120200</span><br><span class="hljs-number">2324527120200</span><br></code></pre></td></tr></table></figure><p>可以看到b和c指向了同一内存地址，原来Python在对程序优化的时候会将程序中的内容相同的常量存储到一个存储地址中。</p><h1 id="五、控制语句"><a href="#五、控制语句" class="headerlink" title="五、控制语句"></a>五、控制语句</h1><p>Python的条件语句与C系列语言最大的不同是，Python的条件语句可以不使用<code>()</code>来包含条件表达式，当然也可以是使用，大多数情况下还是建议使用（），以使代码的阅读性更高。</p><h2 id="1-if语句"><a href="#1-if语句" class="headerlink" title="1.if语句"></a>1.if语句</h2><p>当条if-else语句的用法和C系列基本一致。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">if</span> <span class="hljs-literal">True</span>:<br><span class="hljs-attribute">a</span>=1<br><span class="hljs-attribute">b</span>=1<br><span class="hljs-keyword">else</span>:<br><span class="hljs-attribute">a</span>=2<br><span class="hljs-attribute">b</span>=2<br></code></pre></td></tr></table></figure><p><font color="red"> 其中<code>:</code>是必须的</font><br>Python中比较特殊的是else if语句，在Python中使用<font color="red"> elif</font>表示。</p><h2 id="2-while循环语句"><a href="#2-while循环语句" class="headerlink" title="2.while循环语句"></a>2.while循环语句</h2><p>Python的while循环可以搭配esle使用，当循环跳出时执行else语句，个人感觉没什么实际用处。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gauss">a = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> a&lt;<span class="hljs-number">3</span>:<br><span class="hljs-keyword">print</span>(a)<br>a += <span class="hljs-number">1</span><br><span class="hljs-keyword">else</span>:<br><span class="hljs-keyword">print</span>(“循环结束”)<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">0<br>1<br>2<br>循环结束<br></code></pre></td></tr></table></figure><h2 id="3-for循环"><a href="#3-for循环" class="headerlink" title="3.for循环"></a>3.for循环</h2><p><font color="red"> 在写循环语句之前有一点是需要明确的，及根据Python的设计理念Python已经不使用自增<code>++</code>自减<code>--</code>运算符了，所以需要自增时应使用<code>a += 1</code></font></p><h3 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h3><p>for in的用法和C#的foreach一致，可以遍历任何序列，如：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">li</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> <span class="hljs-built_in">li</span>:<br><span class="hljs-built_in">print</span>(item)<br><span class="hljs-keyword">else</span>：<br><span class="hljs-built_in">print</span>(“<span class="hljs-keyword">for</span> end”)<br></code></pre></td></tr></table></figure><p>和while一样for也可以配合else使用</p><h3 id="for-in-range"><a href="#for-in-range" class="headerlink" title="for in range()"></a>for in range()</h3><p>for in range()就是不同的for循环，通过下标来遍历序列，如：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">li</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len(<span class="hljs-built_in">li</span>)):<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">li</span>[i])<br><span class="hljs-keyword">else</span>:<br><span class="hljs-built_in">print</span>(“<span class="hljs-keyword">for</span> end”)<br></code></pre></td></tr></table></figure><p><font color="red"> 需要注意实际上for in中是不包含range()的，range只是一个辅助函数，用于确定下标的范围。如果我们直接像下面那样写是会报语法错误的，如：</font></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">for</span> i in <span class="hljs-number">4</span>:<br><span class="hljs-comment">#code</span><br></code></pre></td></tr></table></figure><p>如果我们想让循环只跑4轮，应该用range(4)来确定下标范围，如：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-keyword">range</span>(<span class="hljs-number">4</span>):<br></code></pre></td></tr></table></figure><h3 id="continue、break和pass"><a href="#continue、break和pass" class="headerlink" title="continue、break和pass"></a>continue、break和pass</h3><p>Python的continue和break的用法和C系列语言基本一致，Python中新增了pass语句，pass语句就是C系列语言中<code>;</code>及空语句，一般用于空循环中维护代码的结构性。</p><h1 id="六、函数"><a href="#六、函数" class="headerlink" title="六、函数"></a>六、函数</h1><h2 id="1-函数定义"><a href="#1-函数定义" class="headerlink" title="1.函数定义"></a>1.函数定义</h2><ul><li>函数代码块以 <strong>def</strong> 关键词开头，后接函数标识符名称和圆括号**()**。</li><li>任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。</li><li><font color="red">函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</font></li><li>函数内容以冒号起始，并且缩进。</li><li><strong>return [表达式]</strong> 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。</li></ul><p>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fun</span>(<span class="hljs-params">a</span>):</span><br>    <span class="hljs-string">&quot;打印a的平方并返回&quot;</span><br>    b = a*a<br>    print(b)<br>    <span class="hljs-keyword">return</span> b<br></code></pre></td></tr></table></figure><h2 id="2-函数调用"><a href="#2-函数调用" class="headerlink" title="2.函数调用"></a>2.函数调用</h2><p><font color="red"> 在调用Python函数时有一点是需要特别注意的，由于Python是解释型语言，Python脚本在运行时是一行一行地放入解释器中进行解释的，因此Pyhton不支持函数的声明定义的分离，所有Python的函数调用必须在定义之后，否则将会报函数未定义。</font></p><h2 id="3-参数传递"><a href="#3-参数传递" class="headerlink" title="3.参数传递"></a>3.参数传递</h2><p>在讨论函数参数之前，我们需要了解两个概念：</p><ul><li><p>不可变对象：不可变对象都是不可变类型，<font color="red">Python的不可变类型有数字、字符串、元组</font>，不可变对象指向的内存地址上的内容是不可更改的，如需操作其内容Python会开辟一个新的内存地址来存储编辑后的内容。</p></li><li><p>可变对象：可变对象都是可变类型，不是不可变类型的类型都是可变类型，包括列表、字典、自定义类型等，可变类型对象指向的内存地址的内容是可更改，操作可变对象的内容时Python不会开辟新的内存，而是直接修改原地址内容。</p></li></ul><p><font color="red">函数传入不可变对象的原理和C++的传值原理是一样的，函数传入可变对象的原理和C++传址原理是一样的。</font></p><h3 id="传参原理"><a href="#传参原理" class="headerlink" title="传参原理"></a>传参原理</h3><p>由于Python的变量都是若类型的，参数也不例外，函数在定义参数时只有名字没有类型，所以Python在调用函数时，参数的传递是根据实参的顺序来给形参赋值的。</p><h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>Python的函数支持关键字传参，关键字传参的原理是指定实参来赋值指定形参，所以可以无视参数的传入顺序。如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fun</span>(<span class="hljs-params">a,b,c</span>):</span><br>    print(a+b+c)<br>fun(b = <span class="hljs-number">1</span>,c = <span class="hljs-number">2</span>,a = <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>Python的函数也支持默认参数，原理和C++一样。</p><h3 id="单-号不定长参数"><a href="#单-号不定长参数" class="headerlink" title="单*号不定长参数"></a>单*号不定长参数</h3><p>Python的不定长参数和C++则有些不同，Python使用<code>*</code>来标识不定长参数，所有形参匹配之外的参数都将存储到不定长参数中，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fun</span>(<span class="hljs-params">a,b,*c</span>):</span><br>    d = a + b<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> c:<br>        d += item<br>    print(d)<br>fun(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>在这个过程中，1被赋予a，2被赋予b，3和4被赋予c</p><p>Python支持不定长参数的单独使用，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fun</span>(<span class="hljs-params">*param</span>):</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>如果函数的参数只有一个不定长参数，那么函数传入的任何参数都会存储到不定长参数里。</p><p><font color="red"> 单<code>*</code>号不定长参数会将传入的所有参数封装在一个元组里，且单<code>*</code>号不定长参数只支持参数的顺序传入，不支持关键字传入。</font></p><p>当函数只有单<code>*</code>号不定长参数时，单<code>*</code>号不定长参数因该放在最后一个参数，如果不放在最后将会报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fun</span>(<span class="hljs-params">*c, t</span>):</span><br>    c[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">5</span><br>    print(c[<span class="hljs-number">0</span>])<br>    print(t)<br></code></pre></td></tr></table></figure><p>报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;d:\Codes\Python\MyFirstPython.py&quot;</span>, line <span class="hljs-number">9</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    fun(li, <span class="hljs-number">2</span>)<br>TypeError: fun() missing <span class="hljs-number">1</span> required keyword-only argument: <span class="hljs-string">&#x27;t&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="双-号不定长参数"><a href="#双-号不定长参数" class="headerlink" title="双*号不定长参数"></a>双*号不定长参数</h3><p>除了单<code>*</code>号不定长参数外，Python还支持双<code>*</code>号不定长参数，<font color="red"> 双<code>*</code>号不定长参数支持关键字传入，不支持顺序传入，双<code>*</code>号不定长参数会将传入的参数封装在一个字典里，其中关键字的名字存入字典的键中，关键字的值存入字典的值中。</font>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fun</span>(<span class="hljs-params">t,**d</span>):</span><br>    print(t)<br>    print(d[<span class="hljs-string">&#x27;x&#x27;</span>])<br>    print(d[<span class="hljs-string">&#x27;y&#x27;</span>])<br>fun(<span class="hljs-number">1</span>,x=<span class="hljs-number">2</span>,y=<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>当函数中同时存在单<code>*</code>号不定长参数和双<code>*</code>号不定长参数时，双<code>*</code>号不定长参数应放在最后一个参数位置，单<code>*</code>号参数应放在倒数第二个参数位置。</p><h2 id="4-匿名函数"><a href="#4-匿名函数" class="headerlink" title="4.匿名函数"></a>4.匿名函数</h2><p>Python的匿名函数的使用场景是，当函数体只由比较简单的Lambda表达式组成时才使用。匿名函数除了没有函数名，其他的和有名函数没有什么区别。如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">f = <span class="hljs-keyword">lambda</span> a,b=<span class="hljs-number">1</span>: a+b<br>print(f(<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>在lambda表达式的结构中，<code>:</code>之前的为参数，<code>:</code>号之后有且只有一条语句，这是由Python语句分割的方式决定的。从上面的例子我们还可以发现，lambda表达式支持默认参数，且自带返回值，lambda表达式将表达式的结果作为返回值，需要注意的是，lambda表达式中不能进行复制操作，否则将报语法错误。</p><h1 id="七、模块"><a href="#七、模块" class="headerlink" title="七、模块"></a>七、模块</h1><p>一个Python文件就是一个Python模块，一个Python包也是一个Python模块。</p><h2 id="1-导入模块（包）"><a href="#1-导入模块（包）" class="headerlink" title="1.导入模块（包）"></a>1.导入模块（包）</h2><h3 id="整模块导入"><a href="#整模块导入" class="headerlink" title="整模块导入"></a>整模块导入</h3><p>Python使用<code>import</code>+<code>模块名</code>来导入模块，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> MyFirstPython<br></code></pre></td></tr></table></figure><p>当我们将一个Python作为模块导入到另一个文件时，Python会在工程文件夹下的<code>__pycache</code>文件夹下生成一个模块名对应的<code>pyc</code>文件，如上面的例子则会生成一个<code>PyFirstPython.cpython-39.pyc</code>其中cpython-39为python版本号，这个文件是做什么用的呢？pyc文件是一个二进制文件，且已经经过Python加密，直接打开会显示乱码，pyc的主要作用就是加快模块的导入速度，注意这里是导入速度而非运行速度，pyc文件可以通过反编译器重新反编译成可执行的Python文件。</p><p>python支持使用<code>,</code>来分割模块，达到同时导入多个包的目的，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> MyfirstPython,MySecondPython<br></code></pre></td></tr></table></figure><h3 id="单函数导入"><a href="#单函数导入" class="headerlink" title="单函数导入"></a>单函数导入</h3><p>python除了支持整个文件的模块导入，同时也支持只导入模块中的一个函数，python使用<code>from 模块名 import 函数名</code>来从指定模块导入单个函数，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> MySecondPython <span class="hljs-keyword">import</span> fun <span class="hljs-keyword">as</span> f<br></code></pre></td></tr></table></figure><p>同时，python在导入模块或模块中的函数时可以使用<code>as</code>关键字为模块或函数起别名。</p><p>form import还可以使用<code>*</code>来达到import的效果，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> MyFirstPython <span class="hljs-keyword">import</span> * <span class="hljs-comment">#相当于import MyFirstPython</span><br></code></pre></td></tr></table></figure><h3 id="python导入模块时的路径搜索顺序"><a href="#python导入模块时的路径搜索顺序" class="headerlink" title="python导入模块时的路径搜索顺序"></a>python导入模块时的路径搜索顺序</h3><ul><li>1、当前目录</li><li>2、如果不在当前目录，Python 则搜索在 shell 变量 PYTHONPATH 下的每个目录。</li><li>3、如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/。</li></ul><h3 id="python使用导入模块的全局变量"><a href="#python使用导入模块的全局变量" class="headerlink" title="python使用导入模块的全局变量"></a>python使用导入模块的全局变量</h3><p>有一点十分不方便的就是在当前文件下无法直接使用导入模块的全局变量，只能通过为指定变量编写读写函数才能操作全局变量，这是由python的变量规则决定的。</p><h3 id="Pyhton模块打包"><a href="#Pyhton模块打包" class="headerlink" title="Pyhton模块打包"></a>Pyhton模块打包</h3><p>Python提供了多个打包工具，我使用的是python3.9内置的<code>setuptools</code>库，setuptools库中提供了一个setup函数用于打包模块，具体操作如下：</p><ul><li><p>1.在工程目录下新建一个setup.py文件，这个文件用于配置一些包的必要信息，配置信息都由关键字参数的形式传入setup函数中，具体参数信息如下;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python">setup(<br>    name=about[<span class="hljs-string">&quot;__title__&quot;</span>],  <span class="hljs-comment"># 包名称</span><br>    version=about[<span class="hljs-string">&quot;__version__&quot;</span>],  <span class="hljs-comment"># 包版本</span><br>    description=about[<span class="hljs-string">&quot;__description__&quot;</span>],  <span class="hljs-comment"># 包详细描述</span><br>    long_description=readme,   <span class="hljs-comment"># 长描述，通常是readme，打包到PiPy需要</span><br>    author=about[<span class="hljs-string">&quot;__author__&quot;</span>],  <span class="hljs-comment"># 作者名称</span><br>    author_email=about[<span class="hljs-string">&quot;__author_email__&quot;</span>],  <span class="hljs-comment"># 作者邮箱</span><br>    url=about[<span class="hljs-string">&quot;__url__&quot;</span>],   <span class="hljs-comment"># 项目官网</span><br>    packages=packages,    <span class="hljs-comment"># 项目需要的包</span><br>    data_files=file_data,   <span class="hljs-comment"># 打包时需要打包的数据文件，如图片，配置文件等</span><br>    include_package_data=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 是否需要导入静态数据文件</span><br>    python_requires=<span class="hljs-string">&quot;&gt;=3.0, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3*&quot;</span>,  <span class="hljs-comment"># Python版本依赖</span><br>    install_requires=requires,  <span class="hljs-comment"># 第三方库依赖</span><br>    zip_safe=<span class="hljs-literal">False</span>,  <span class="hljs-comment"># 此项需要，否则卸载时报windows error</span><br>    classifiers=[    <span class="hljs-comment"># 程序的所属分类列表</span><br>        <span class="hljs-string">&#x27;Development Status :: 5 - Production/Stable&#x27;</span>,<br>        <span class="hljs-string">&#x27;Intended Audience :: Developers&#x27;</span>,<br>        <span class="hljs-string">&#x27;Natural Language :: English&#x27;</span>,<br>        <span class="hljs-string">&#x27;Programming Language :: Python&#x27;</span>,<br>        <span class="hljs-string">&#x27;Programming Language :: Python :: 3&#x27;</span>,<br>        <span class="hljs-string">&#x27;Programming Language :: Python :: 3.4&#x27;</span>,<br>        <span class="hljs-string">&#x27;Programming Language :: Python :: 3.5&#x27;</span>,<br>        <span class="hljs-string">&#x27;Programming Language :: Python :: 3.6&#x27;</span>,<br>        <span class="hljs-string">&#x27;Programming Language :: Python :: 3.7&#x27;</span>,<br>        <span class="hljs-string">&#x27;Programming Language :: Python :: Implementation :: CPython&#x27;</span>,<br>        <span class="hljs-string">&#x27;Programming Language :: Python :: Implementation :: PyPy&#x27;</span><br>    ],<br>)<br></code></pre></td></tr></table></figure><p>当然这里面所有的参数都不是非必须，如果我们一个参数都不传入，则pyhton会生成一个名为<code>UNKNOW-0.0.0.tar.gz</code>的包。</p></li><li><p>2.使用cmd进入setup.py所在目录，使用<code>python setup.py sdist</code>命令之后，python会在此目录下生成一个<code>dist</code>目录和一个<code>包名.egg-info</code>目录，包名及setup函数中name指定的名称，为命名则为UNKNOWN.egg-info，这个文件夹下是一些包的详细信息文件。</p></li></ul><p>如此包便打包完成了，这中间踩了一写坑，记录一下：</p><p>使用python setup.py sdist命令无反应，然后使用python -v发现也不输出python版信息，此时打开此电脑/属性/高级系统设置/高级/环境变量，发现path中都以存在python目录，可是使用python -v就是无反应。</p><p>解决方案：在cmd下使用<code>set PATH=Python完成目录;%PATH%</code>，不知道为什么需要使用命令行配置一下系统环境才行。</p><p>当然不同的打包工具，打包过程略有不同，这里就详细展开了。</p><h1 id="八、Python的内置函数"><a href="#八、Python的内置函数" class="headerlink" title="八、Python的内置函数"></a>八、Python的内置函数</h1><h2 id="1-数学函数"><a href="#1-数学函数" class="headerlink" title="1.数学函数"></a>1.数学函数</h2><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/python/func-number-abs.html">abs()</a></td><td>返回数字的绝对值，如abs(-10) 返回 10</td></tr><tr><td><a href="https://www.runoob.com/python/func-number-cmp.html">cmp()</a></td><td>如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1</td></tr><tr><td><a href="https://www.runoob.com/python/func-number-max.html">max()</a></td><td>返回给定参数的最大值，参数可以为序列</td></tr><tr><td><a href="https://www.runoob.com/python/func-number-min.html">min()</a></td><td>返回给定参数的最小值，参数可以为序列</td></tr><tr><td><a href="https://www.runoob.com/python/func-number-pow.html">pow()</a></td><td>x^y 运算后的值，及求x的y次幂</td></tr><tr><td><a href="https://www.runoob.com/python/func-number-round.html">round(x [,n])</a></td><td>返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-sum.html">sum()</a></td><td>对序列求和</td></tr><tr><td><a href="https://www.runoob.com/python/func-number-round.html">round()</a></td><td>返回浮点数x的四舍五入值</td></tr></tbody></table><h2 id="5-反射函数"><a href="#5-反射函数" class="headerlink" title="5.反射函数"></a>5.反射函数</h2><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/python/python-func-dir.html">dir()</a></td><td>dir函数返回一个包含了一个模块里所定义的所有模块、变量和函数，dir函数只是列出名称，无其他实际意义，其中以<code>__</code>开头的是模块相关的默认属性，如：<code>__name__</code>指向模块的名字，<code>__file__</code>指向模块文件的名字，dir函数可以传入模块名称，则输出的是模块相关的信息，如果不传入参数则输出当前作用域的相关信息</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-globals.html">globals()</a></td><td>在函数内使用则返回一个包含该函数能访问的所有全局名字的字典，在函数外使用效果和在函数内使用一样</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-locals.html">locals()</a></td><td>在函数内使用则返回一个包含该函数内的全部局部名字的字典，在函数外使用效果和globals()函数一样</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-callable.html">callable()</a></td><td>检查一个对象是否是可调用的。如果返回 True，object 仍然可能调用失败；但如果返回 False，调用对象 object 绝对不会成功。</td></tr></tbody></table><h2 id="6-类型转换函数"><a href="#6-类型转换函数" class="headerlink" title="6.类型转换函数"></a>6.类型转换函数</h2><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/python/python-func-bool.html">bool()</a></td><td>将对象转换为bool类型，对于空元组和空列表将转换为false</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-float.html">float()</a></td><td>在python中没有double类型，python的float精度就已经达到了double的精度</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-int.html">int()</a></td><td>转整型</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-long.html">long()</a></td><td>转长整型</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-str.html">str()</a></td><td>将对象转换成字符串，支持任何对象</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-eval.html">eval()</a></td><td>eval函数可以用来做字符串转列表、元组和字典等，如：<code>a = eval(&#39;[1,2]&#39;)</code>、<code>b = eval(&#39;(1,2)&#39;)</code>，a是一个列表，b是一个元组，其中字典需要注意的是要使用纯字符串，如：<code>c = eavl(r&quot;&#123;&#39;a&#39;:1,&#39;b&#39;:2&#125;&quot;)</code>，c就是一个字典了，除此之外，eval函数还可以用来运行字符串命令，如：<code>eval(&#39;bool(1)&#39;)</code>，输出为<code>True</code></td></tr><tr><td><a href="https://www.runoob.com/python/att-list-list.html">list()</a></td><td>将可迭代序列(包括元组，字符串，字典等)转换成列表，如：字符串转列表<code>a = list(&#39;abc&#39;)</code>则a列表内容为<code>[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]</code>、字典转列表则会返回一个key值列表</td></tr><tr><td><a href="https://www.runoob.com/python/att-tuple-tuple.html">tuple()</a></td><td>将可迭代序列(包括元组，字符串，字典等)转换成元组，如：字符串转元组<code>a = tuple(&#39;abc&#39;)</code>则a列表内容为<code>(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;)</code>、字典转元组则会返回一个key值元组</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-dict.html">dict()</a></td><td>dict函数支持三种转换形式，其一使用关键字的形式，关键字名称为键，关键字的值为值，如：<code>a=dict(a=1,b=1)</code>则a就是字典<code>&#123;&#39;a&#39;:1,&#39;b&#39;:2&#125;</code>，其二使用zip函数的形式，zip函数将两个可迭代序列按位置打包成二元元组，dict函数则将二元元组的第一个元素作为键，第二个元素作为值创建字典，如：<code>a=dict(zip([&#39;a&#39;,&#39;b&#39;],[1,2]))</code>，其中zip函数返回值为<code>[(&#39;a&#39;,1),(&#39;b&#39;,2)]</code>，dict函数返回值为<code>&#123;&#39;a&#39;:1,&#39;b&#39;:2&#125;</code>，其三使用可迭代对象的形式，如：<code>a=dict([(&#39;a&#39;,1),(&#39;b&#39;:2)])</code>其中可迭代对象可以是任何子成员为二元序列的对象</td></tr><tr><td><a href="https://www.runoob.com/python/python-func-chr.html">chr()</a></td><td>将数字转换成对应的字符</td></tr></tbody></table><h2 id="6-其他内置函数"><a href="#6-其他内置函数" class="headerlink" title="6.其他内置函数"></a>6.其他内置函数</h2><p>详情见<a href="https://www.runoob.com/python/python-built-in-functions.html">菜鸟教程</a></p><h1 id="九、文件IO"><a href="#九、文件IO" class="headerlink" title="九、文件IO"></a>九、文件IO</h1><h2 id="1-标准输出"><a href="#1-标准输出" class="headerlink" title="1.标准输出"></a>1.标准输出</h2><p>print()在终端打印，这里需要注意的是python3已经不支持<code>print &#39;aa&#39;</code>这种打印方式了。</p><h2 id="2-标准输入"><a href="#2-标准输入" class="headerlink" title="2.标准输入"></a>2.标准输入</h2><p>input()从终端输入，有时我们会看到row_input函数或input函数接收python表达式的标准输入，这些都是ptrhon2的标准输入函数和输入特性，在python3中python只保留了一个input函数作为标准输入，且input函数不在支持python表达式的输入，而是把所有的输入当作是字符串。</p><h2 id="3-文件读写"><a href="#3-文件读写" class="headerlink" title="3.文件读写"></a>3.文件读写</h2><p>python的文件读写通过内置类型<code>file</code>类型来进行操作，而file类型对象的创建需要通过内置函数<code>open</code>来创建。</p><h3 id="open函数"><a href="#open函数" class="headerlink" title="open函数"></a>open函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">open</span>(file_name ,access_mode, buffering)<br></code></pre></td></tr></table></figure><ul><li><p>file_name：文件路径</p></li><li><p>access_mode：打开模式，默认为只读，具体模式如下：</p><table><thead><tr><th align="left">字符</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left"><code>&#39;r&#39;</code></td><td align="left">读取（默认）</td></tr><tr><td align="left"><code>&#39;w&#39;</code></td><td align="left">写入，并先截断文件</td></tr><tr><td align="left"><code>&#39;x&#39;</code></td><td align="left">排它性创建，如果文件已存在则失败</td></tr><tr><td align="left"><code>&#39;a&#39;</code></td><td align="left">写入，如果文件存在则在末尾追加</td></tr><tr><td align="left"><code>&#39;b&#39;</code></td><td align="left">二进制模式</td></tr><tr><td align="left"><code>&#39;t&#39;</code></td><td align="left">文本模式（默认）</td></tr><tr><td align="left"><code>&#39;+&#39;</code></td><td align="left">更新磁盘文件（读取并写入）</td></tr></tbody></table><p>python3以后删除了很多打开模式，只保留了上面几种，所以如果在python3环境中使用<code>+</code>打开模式就会报错。</p></li><li><p>buffering：是否寄存行，可选参数，具体取值如下：</p><table><thead><tr><th>取值</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>取0，不寄存行</td></tr><tr><td>1</td><td>取1，寄存行</td></tr><tr><td>&gt;1</td><td>取大于1的值，寄存行，且设置寄存区的缓冲大小为当前值</td></tr><tr><td>&lt;0</td><td>取小于0的值，寄存行，且设置寄存区的缓冲大小为系统默认值</td></tr></tbody></table></li><li><p>返回值：open函数打开文件，读取文件内容到内存并一个可操作文件的file类型对象。</p></li></ul><h3 id="file类型对象内置函数"><a href="#file类型对象内置函数" class="headerlink" title="file类型对象内置函数"></a>file类型对象内置函数</h3><table><thead><tr><th align="left">序号</th><th align="left">方法及描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/python3/python3-file-close.html">file.close()</a></td><td align="left">关闭文件。关闭后文件不能再进行读写操作。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-file-flush.html">file.flush()</a></td><td align="left">刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-file-fileno.html">file.fileno()</a></td><td align="left">返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-file-isatty.html">file.isatty()</a></td><td align="left">如果文件连接到一个终端设备返回 True，否则返回 False。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-file-read.html">file.read([size])</a></td><td align="left">从文件读取指定的字节数，如果未给定或为负则读取所有。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-file-readline.html">file.readline([size])</a></td><td align="left">读取整行，包括 “\n” 字符。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-file-readlines.html">file.readlines([sizeint])</a></td><td align="left">读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-file-seek.html">file.seek(offset[, whence])</a></td><td align="left">移动文件读取指针到指定位置</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-file-tell.html">file.tell()</a></td><td align="left">返回文件当前位置。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-file-truncate.html">file.truncate([size])</a></td><td align="left">从文件的首行首字符开始截断，截断文件为 size 个字符，无 size 表示从当前位置截断；截断之后后面的所有字符被删除，其中 windows 系统下的换行代表2个字符大小。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-file-write.html">file.write(str)</a></td><td align="left">将字符串写入文件，返回的是写入的字符长度。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-file-writelines.html">file.writelines(sequence)</a></td><td align="left">向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。</td></tr></tbody></table><h3 id="file类型对象内置属性"><a href="#file类型对象内置属性" class="headerlink" title="file类型对象内置属性"></a>file类型对象内置属性</h3><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">file.closed</td><td align="left">返回true如果文件已被关闭，否则返回false。</td></tr><tr><td align="left">file.mode</td><td align="left">返回被打开文件的访问模式。</td></tr><tr><td align="left">file.name</td><td align="left">返回文件的名称。</td></tr><tr><td align="left">file.softspace</td><td align="left">如果用print输出后，必须跟一个空格符，则返回false。否则返回true。</td></tr></tbody></table><h2 id="4-文件及目录操作"><a href="#4-文件及目录操作" class="headerlink" title="4.文件及目录操作"></a>4.文件及目录操作</h2><p>这里的文件操作不是对文件的内容进行增删改操作而是在文件级别进行重命名删除设置权限等操作，对文件做这些操作需要用到<code>os</code>模块，os模块提供大量的函数对文件进行操作，文件数量过多这里就不贴出来了，具体见菜鸟教程：</p><p><a href="https://www.runoob.com/python/os-file-methods.html">os文件操作函数</a></p><h1 id="十、异常"><a href="#十、异常" class="headerlink" title="十、异常"></a>十、异常</h1><h2 id="1-异常处理语句"><a href="#1-异常处理语句" class="headerlink" title="1.异常处理语句"></a>1.异常处理语句</h2><p>Python的异常处理语句是<code>try/except</code>，需要监测异常的代码放在<code>try:</code>块下，在异常发生后需要执行的代码放在<code>except:</code>块下，except后可以接异常类型也可以不接，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    a = <span class="hljs-number">1</span>/<span class="hljs-number">0</span><br><span class="hljs-keyword">except</span> ZeroDivisionError:<br>    print(<span class="hljs-string">&#x27;0不可以做除数&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-string">&#x27;没有异常&#x27;</span>)<br><span class="hljs-keyword">finally</span>:<br>    print(<span class="hljs-string">&#x27;有没有异常都会执行&#x27;</span>)<br></code></pre></td></tr></table></figure><p>可以看到，和条件语句一样try/except语句也可以接else分支，else分支在没有异常发生时执行。、</p><h2 id="2-抛出异常"><a href="#2-抛出异常" class="headerlink" title="2.抛出异常"></a>2.抛出异常</h2><p>python使用<code>raise</code>语句来抛出异常，需要注意的是，raise必须抛出一个异常类，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    a = <span class="hljs-number">1</span>/<span class="hljs-number">0</span><br><span class="hljs-keyword">except</span> ZeroDivisionError:<br>    <span class="hljs-keyword">raise</span> ZeroDivisionError(<span class="hljs-string">&#x27;0不可以做除数&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="3-标准异常"><a href="#3-标准异常" class="headerlink" title="3.标准异常"></a>3.标准异常</h2><table><thead><tr><th align="left">异常名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">BaseException</td><td align="left">所有异常的基类</td></tr><tr><td align="left">SystemExit</td><td align="left">解释器请求退出</td></tr><tr><td align="left">KeyboardInterrupt</td><td align="left">用户中断执行(通常是输入^C)</td></tr><tr><td align="left">Exception</td><td align="left">常规错误的基类</td></tr><tr><td align="left">StopIteration</td><td align="left">迭代器没有更多的值</td></tr><tr><td align="left">GeneratorExit</td><td align="left">生成器(generator)发生异常来通知退出</td></tr><tr><td align="left">StandardError</td><td align="left">所有的内建标准异常的基类</td></tr><tr><td align="left">ArithmeticError</td><td align="left">所有数值计算错误的基类</td></tr><tr><td align="left">FloatingPointError</td><td align="left">浮点计算错误</td></tr><tr><td align="left">OverflowError</td><td align="left">数值运算超出最大限制</td></tr><tr><td align="left">ZeroDivisionError</td><td align="left">除(或取模)零 (所有数据类型)</td></tr><tr><td align="left">AssertionError</td><td align="left">断言语句失败</td></tr><tr><td align="left">AttributeError</td><td align="left">对象没有这个属性</td></tr><tr><td align="left">EOFError</td><td align="left">没有内建输入,到达EOF 标记</td></tr><tr><td align="left">EnvironmentError</td><td align="left">操作系统错误的基类</td></tr><tr><td align="left">IOError</td><td align="left">输入/输出操作失败</td></tr><tr><td align="left">OSError</td><td align="left">操作系统错误</td></tr><tr><td align="left">WindowsError</td><td align="left">系统调用失败</td></tr><tr><td align="left">ImportError</td><td align="left">导入模块/对象失败</td></tr><tr><td align="left">LookupError</td><td align="left">无效数据查询的基类</td></tr><tr><td align="left">IndexError</td><td align="left">序列中没有此索引(index)</td></tr><tr><td align="left">KeyError</td><td align="left">映射中没有这个键</td></tr><tr><td align="left">MemoryError</td><td align="left">内存溢出错误(对于Python 解释器不是致命的)</td></tr><tr><td align="left">NameError</td><td align="left">未声明/初始化对象 (没有属性)</td></tr><tr><td align="left">UnboundLocalError</td><td align="left">访问未初始化的本地变量</td></tr><tr><td align="left">ReferenceError</td><td align="left">弱引用(Weak reference)试图访问已经垃圾回收了的对象</td></tr><tr><td align="left">RuntimeError</td><td align="left">一般的运行时错误</td></tr><tr><td align="left">NotImplementedError</td><td align="left">尚未实现的方法</td></tr><tr><td align="left">SyntaxError</td><td align="left">Python 语法错误</td></tr><tr><td align="left">IndentationError</td><td align="left">缩进错误</td></tr><tr><td align="left">TabError</td><td align="left">Tab 和空格混用</td></tr><tr><td align="left">SystemError</td><td align="left">一般的解释器系统错误</td></tr><tr><td align="left">TypeError</td><td align="left">对类型无效的操作</td></tr><tr><td align="left">ValueError</td><td align="left">传入无效的参数</td></tr><tr><td align="left">UnicodeError</td><td align="left">Unicode 相关的错误</td></tr><tr><td align="left">UnicodeDecodeError</td><td align="left">Unicode 解码时的错误</td></tr><tr><td align="left">UnicodeEncodeError</td><td align="left">Unicode 编码时错误</td></tr><tr><td align="left">UnicodeTranslateError</td><td align="left">Unicode 转换时错误</td></tr><tr><td align="left">Warning</td><td align="left">警告的基类</td></tr><tr><td align="left">DeprecationWarning</td><td align="left">关于被弃用的特征的警告</td></tr><tr><td align="left">FutureWarning</td><td align="left">关于构造将来语义会有改变的警告</td></tr><tr><td align="left">OverflowWarning</td><td align="left">旧的关于自动提升为长整型(long)的警告</td></tr><tr><td align="left">PendingDeprecationWarning</td><td align="left">关于特性将会被废弃的警告</td></tr><tr><td align="left">RuntimeWarning</td><td align="left">可疑的运行时行为(runtime behavior)的警告</td></tr><tr><td align="left">SyntaxWarning</td><td align="left">可疑的语法的警告</td></tr><tr><td align="left">UserWarning</td><td align="left">用户代码生成的警告</td></tr></tbody></table><h2 id="4-自定义异常"><a href="#4-自定义异常" class="headerlink" title="4.自定义异常"></a>4.自定义异常</h2><p>python的自定义异常只需要将自定义异常类继承自python标准异常类即可。</p><h1 id="十一、面向对象"><a href="#十一、面向对象" class="headerlink" title="十一、面向对象"></a>十一、面向对象</h1><p>python在设计之初就已经是一门面向对象的语言了，在python中一切皆对象，包括所有的基础类型也是对象，这使得python在创建类和对象时十分容易，但是这也导致python十分消耗内存空间，因为哪怕只创建一个整型也会消耗对于C语言的内存空间。</p><h2 id="1-定义类"><a href="#1-定义类" class="headerlink" title="1.定义类"></a>1.定义类</h2><p>和大多数语言一样，python也使用<code>class</code>关键字来标识类，使用同等量的缩进来标识类的范围，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><br>    age = <span class="hljs-number">0</span><br>    name = <span class="hljs-string">&#x27;&#x27;</span><br>    __id = <span class="hljs-number">1</span><br>    _sex = <span class="hljs-string">&#x27;female&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, age, name</span>):</span><br>        self.age = age<br>        self.name = name<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">GetName</span>(<span class="hljs-params">this</span>):</span><br>        print(<span class="hljs-string">&#x27;my name is &#x27;</span> + this.name)<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__SetId</span>():</span><br>        <span class="hljs-built_in">id</span> = 001<br><br><br>p = Person(<span class="hljs-number">18</span>, <span class="hljs-string">&#x27;lusa&#x27;</span>)<br>p.GetName()<br></code></pre></td></tr></table></figure><h2 id="2-成员变量"><a href="#2-成员变量" class="headerlink" title="2.成员变量"></a>2.成员变量</h2><h3 id="私有成员变量"><a href="#私有成员变量" class="headerlink" title="私有成员变量"></a>私有成员变量</h3><p>由于python无法使用public，private等关键字，所以python使用双下划线开头来标识私有成员变量。如上面代码中的<code>__id</code>。</p><h3 id="保护成员变量"><a href="#保护成员变量" class="headerlink" title="保护成员变量"></a>保护成员变量</h3><p>python使用单下划线开头来标识保护成员变量，如上面代码中的<code>_sex</code>。</p><h3 id="公有成员变量"><a href="#公有成员变量" class="headerlink" title="公有成员变量"></a>公有成员变量</h3><p>不带有任何前缀的变量的就是公有成员变量。</p><h2 id="3-成员函数"><a href="#3-成员函数" class="headerlink" title="3.成员函数"></a>3.成员函数</h2><h3 id="私有函数、保护函数和公有函数"><a href="#私有函数、保护函数和公有函数" class="headerlink" title="私有函数、保护函数和公有函数"></a>私有函数、保护函数和公有函数</h3><p>和变量一样，python使用双下划线来前缀来标识私有函数，用单下划线前缀来标识保护函数，无前缀函数表示公有函数。</p><h3 id="self参数"><a href="#self参数" class="headerlink" title="self参数"></a>self参数</h3><p><font color="red">与其他语言不同的是，python的函数都必须带有一个self参数，self参数的在效果上与C++的this指针很像，但是python的self参数不是类自带的，在定义函数时需要手动显示表示，且必须放在函数的第一个参数位置，self参数的名字不一定非得叫self也可以叫其他的名字，如上面代码中的GetName函数的this，但是按照python的规范建议将都是用self命名，self参数指向当前类实例，类的实例变量都必须使用self参数才能访问，直接使用是无法访问的，如：</font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><br>    age = <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, param</span>):</span><br>        age = param<br></code></pre></td></tr></table></figure><p>不通过self参数访问类的成员变量将直接报语法错误。</p><h2 id="4-类变量、实例变量和局部变量"><a href="#4-类变量、实例变量和局部变量" class="headerlink" title="4.类变量、实例变量和局部变量"></a>4.类变量、实例变量和局部变量</h2><h3 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h3><p>定义在类的内部且定义在方法体外的变量，如上面代码中age，<font color="red">类变量可以被类直接访问，也可以被实例直接访问，同时可以被实例方法和类方法方法访问，但是不可以被静态方法访问</font>。如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><br>    names = <span class="hljs-string">&#x27;aa&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, age, name</span>):</span><br>        self.age = age<br>        self.name = name<br>        addr = <span class="hljs-string">&#x27;beijing&#x27;</span><br>        names = <span class="hljs-string">&quot;bb&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">GetName</span>(<span class="hljs-params">self</span>):</span><br>        self.sex = <span class="hljs-string">&#x27;female&#x27;</span><br>        print(<span class="hljs-string">&#x27;my name is &#x27;</span> + self.names)<br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">PP</span>():</span><br>        print(names)<br>    <br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">OO</span>(<span class="hljs-params">cls</span>):</span>       <br>        print(cls.names)<br><br><br>p = Person(<span class="hljs-number">18</span>, <span class="hljs-string">&quot;lusa&quot;</span>)<br>print(p.names)<br>p.names = <span class="hljs-string">&quot;cc&quot;</span><br>p.GetName()<br>print(Person.names)<br>Person.names = <span class="hljs-string">&quot;dd&quot;</span><br>Person.OO()<br>print(p.names)<br>Person.PP()<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">aa<br>my name <span class="hljs-keyword">is</span> cc<br>aa<br>dd<br>cc<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;d:\Codes\Python\MyFirstPython.py&quot;</span>, line <span class="hljs-number">31</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    Person.PP()<br>  File <span class="hljs-string">&quot;d:\Codes\Python\MyFirstPython.py&quot;</span>, line <span class="hljs-number">16</span>, <span class="hljs-keyword">in</span> PP<br>    print(names)<br>NameError: name <span class="hljs-string">&#x27;names&#x27;</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> definedd<br></code></pre></td></tr></table></figure><p>可以看到，类变量names初始值为aa，我们的本意是在构造函数中再赋值bb但是再实际输出中names的值依旧是aa，当我们使用实例给类变量names赋值为cc时，输出GetName函数输出就变为了cc，然而直接通过类名访问的结果依旧是aa，当我们通过类名赋值names为dd时，类方法输出的结果就变为了dd，然而用实例访问的结果依旧时cc，最终运行到类的静态方法PP处则报错了，由上结果可得出结论：</p><ul><li>类在创建实例时会拷贝一份类变量到实例中，实例中类变量和类中的类变量互相独立</li><li>构造函数不可以初始化类变量，当我们在构造函数初始化一个类变量的同名变量时，实际上python初始化的是一个和类变量同名的局部变量</li><li>同一个类变量既可以被类实例访问也可以被类名直接访问，但二者内存地址时两个内存地址</li><li>静态方法不可以访问类变量</li></ul><h3 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h3><p>实例变量是定义在构造函数内部且通过self引出的变量，这两点十分重要，如果一个变量不是在构造函数里创建即使通过self引出也依旧不是实例变量，或一个变量在构造函数中创建但不是由self引出，那它也不是实例变量，而是函数的局部变量，如：上面代码中self.sex，和构造函数里的addr和names，我们是不可以使用实例访问的。</p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>在构造函数中创建的不由self引出的变量或在其他方法中创建的变量，如上面代码中GetName啊哈桑农户里的self.sex和构造函数里的addr和names</p><h2 id="5-类方法、实例方法和静态方法"><a href="#5-类方法、实例方法和静态方法" class="headerlink" title="5.类方法、实例方法和静态方法"></a>5.类方法、实例方法和静态方法</h2><p>被<code>@classmethod</code>修饰的方法就是类方法，被<code>@staticmethod</code>修饰的方法就是静态方法，除此之外其余的方法都是实例方法。类方法和静态方法也有保护级。</p><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p>类方法属于类，可以直接通过类型访问，也可以同通过实例访问，访问效果是一样的。在创建类方法时必须至少需要一个参数，一般命名为<code>cls</code>，用于python传递默认参数–类。如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@classmethod</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">OO</span>(<span class="hljs-params">cls</span>):</span><br>    print(cls.names)<br></code></pre></td></tr></table></figure><p>cls不可省略，在类方法中只能通过cls来访问类变量，且只能访问类变量。</p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>静态方法同类方法很相似，也可以被类名和实例直接访问。不同的是，静态方法不需要cls参数，python不会传递默认参数到静态方法，静态方法不可以直接访问类的任何成员。</p><h3 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h3><p>python支持方法中嵌套创建方法，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">funa</span>():</span><br>    a = <span class="hljs-number">1</span><br>    print(a)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">funb</span>():</span><br>        <span class="hljs-keyword">nonlocal</span> a<br>        a += <span class="hljs-number">1</span><br>        print(a)<br>   <br>    funb()<br><br><br>funa()<br></code></pre></td></tr></table></figure><h1 id="十二、作用域"><a href="#十二、作用域" class="headerlink" title="十二、作用域"></a>十二、作用域</h1><p>python的作用域大部分与C系列语言的作用域差不多，只是有三点比较特殊：</p><ul><li><p>python中只有类、函数、模块才会引入新的作用域，控制语句不会引入新的作用域，也就是说，在控制语句中创建的变量可以在控制语句外部被访问</p><p>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>    print(i)<br><br>print(i)<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></li><li><p>如果要在函数内部访问全局变量需要在在函数内部使用<code>global</code>申明，否则python将创建一个同名的局部变量而不是引用全局变量</p><p>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">1</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fun</span>():</span><br>    a += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>python会直接报语法错误，因为我们使用了一个未定义的局部变量，但是当我们使用global申明之后，我们访问的就是全局变量了，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">1</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fun</span>():</span><br>    <span class="hljs-keyword">global</span> a<br>    a += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p>如果要在嵌套函数中访问外层函数的变量需要使用<code>nonlocal</code>申明，否则python也会创建一个同名的局部函数，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">1</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fun</span>():</span><br>    <span class="hljs-keyword">global</span> a<br>    a += <span class="hljs-number">1</span><br>    b = <span class="hljs-number">2</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">funb</span>():</span><br>        <span class="hljs-keyword">global</span> a<br>        <span class="hljs-keyword">nonlocal</span> b<br>        b += <span class="hljs-number">1</span><br>        print(a)<br>        print(b)<br><br>    funb()<br><br><br>fun()<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C++】C++ PremierReadNote</title>
    <link href="/2021/02/03/%E3%80%90C++%E3%80%91C++%20PremierReadNote/"/>
    <url>/2021/02/03/%E3%80%90C++%E3%80%91C++%20PremierReadNote/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="C-Primer-阅读笔记"><a href="#C-Primer-阅读笔记" class="headerlink" title="C++ Primer 阅读笔记"></a>C++ Primer 阅读笔记</h1><hr><a id="more"></a><h1 id="一、开始"><a href="#一、开始" class="headerlink" title="一、开始"></a>一、开始</h1><hr><h2 id="1-输入输出流的数据传输过程"><a href="#1-输入输出流的数据传输过程" class="headerlink" title="1.输入输出流的数据传输过程"></a>1.输入输出流的数据传输过程</h2><p><strong>输入:</strong><br>[窗]-&gt;[输入流对象(cin)]</p><p><strong>输出:</strong><br>[输出流对象(cout，cerr，clog)-&gt;[窗口]</p><p>c++从窗口中读取输入时不是直接存储在变量中而是先存储在istream类型对象cin中，输出是也非直接从变量输出到窗口而是先写入ostream对象cout/cerr/clog中，在从对象传输到窗口。</p><h2 id="2-输出运算符“-lt-lt-”"><a href="#2-输出运算符“-lt-lt-”" class="headerlink" title="2.输出运算符“&lt;&lt;”"></a>2.输出运算符“&lt;&lt;”</h2><p>“&lt;&lt;”运算符输出的是一个ostream类型对象，“&lt;&lt;”接受两个运算对象，其中左侧的运算对象必须是一个ostream对象，右侧可以是需要输出的值，“&lt;&lt;”将需要输出的值写入到ostream对象中。<br>std::cout&lt;&lt;”num:”&lt;&lt;a&lt;&lt;std::endl；<br>“&lt;&lt;”连续表达式可以理解为:<br>((std::cout&lt;&lt;”num:”)&lt;&lt;a)&lt;&lt;std::endl；<br>每一个括号最终返回的都是一个ostream对象。其中endl是“操纵符”，运行效果是换行，并将与设备关联的缓冲区的内容刷新到设备中去，如果不写endl则在程序运行结束或缓冲区满后系统自动将缓冲区内容刷新到设备中去。<br>输入运算符“&gt;&gt;”和输出运算符运行逻辑一样。</p><h2 id="3-char与unsigned-char"><a href="#3-char与unsigned-char" class="headerlink" title="3.char与unsigned char"></a>3.char与unsigned char</h2><p>在计算机中char也是分无符号和有符号两类的，char与int等类型不同的是，int等类型不显示标注unsigned默认为有符号数，而char在不同硬件环境中表示的类型可能是不一样的，所以为保证移植性最好在使用时指定signed和unsigned，c++标准不建议使用char来存储数值，这种区别主要出现在char类型向值类型的转换的过程中。</p><h2 id="4-有符号数与无符号数的运算"><a href="#4-有符号数与无符号数的运算" class="headerlink" title="4.有符号数与无符号数的运算"></a>4.有符号数与无符号数的运算</h2><p>在c++运算优先级中，无符号数的优先级大于有符号数，所以当一个表达式中即存在有符号数又不存在无符号数时，运算将被转换为无符号数的运算，由于无符号数表示的最小值是0所以当表达式的运算结果为负数时就会出现运算错误。</p><h2 id="5-c-11的四种变量初始化方式"><a href="#5-c-11的四种变量初始化方式" class="headerlink" title="5.c++11的四种变量初始化方式"></a>5.c++11的四种变量初始化方式</h2><p>int a=0;<br>int a={0};<br>int a{0};</p><h2 id="int-a-0"><a href="#int-a-0" class="headerlink" title="int a(0);"></a>int a(0);</h2><h1 id="二、变量和基本类型"><a href="#二、变量和基本类型" class="headerlink" title="二、变量和基本类型"></a>二、变量和基本类型</h1><hr><p>1.const引用的隐式类型转换<br>举例使用const限定的int类型的引用来引用double类型的变量的过程：double b=3.14;const int a=b;<br>在将double类型变量赋值给const int类型的引用时系统先创建一个临时变量，并将double隐式成int类型的结果存放到临时变量中，然后再将临时变量赋给引用，此时引用本质上是int类型的临时变量的别名，之后如果更改了double类型变量的值，引用值随之改变。</p><h2 id="2-constexpr变量"><a href="#2-constexpr变量" class="headerlink" title="2.constexpr变量"></a>2.constexpr变量</h2><p>constexpr是一个常量表达式，与const不同的是，const限定的变量只能被常量、常量的引用、常量表达式和常量与常量引用的表达式赋值，而constexpr可以被常量、常量的引用、表达式、以及可以在编译阶段就确定返回值的函数赋值。const在程序运行时的本质是在程序用的const的地方直接替换成期对应<br>的常量，而constexpr则是替换其在编译器期计算出来的结果值。<br>constexpr的意义在于constexpr强制要求赋值给变量的表达式必须在编译阶段可计算出结果值，这对很多重复运算的简单表达式直接限定了在编译期只进行一次运算起到了优化效果。</p><h2 id="3-constexpr指针"><a href="#3-constexpr指针" class="headerlink" title="3.constexpr指针"></a>3.constexpr指针</h2><p>被constexpr限定的指针的初始值只能是nullptr或者0或者指向一个地址固定不变的对象，这里需要注意在函数里的任何对象都不是存储在固定地址中的，所以constexpr限定的指针不能指向函数中的对象，全局对象则是存在在固定地址中的所以constexpr限定的指针可以指向这样的对象。</p><h2 id="4-c-11的两种别名声明方法"><a href="#4-c-11的两种别名声明方法" class="headerlink" title="4.c++ 11的两种别名声明方法"></a>4.c++ 11的两种别名声明方法</h2><p>typedef bm int;<br>using bm=int;</p><h2 id="5-decltype类型指示符"><a href="#5-decltype类型指示符" class="headerlink" title="5.decltype类型指示符"></a>5.decltype类型指示符</h2><p>decltype的作用是通过表达式或函数的返回值动态的推断其指示变量的类型，如：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal">decltype(<span class="hljs-function"><span class="hljs-keyword">fun</span>()) <span class="hljs-title">sum</span></span> = x;<span class="hljs-regexp">//sum</span>的类型为<span class="hljs-function"><span class="hljs-keyword">fun</span>函数返回值的类型，<span class="hljs-title">sum</span></span>的值由x赋予<br></code></pre></td></tr></table></figure><h2 id="顶层Const与底层Const"><a href="#顶层Const与底层Const" class="headerlink" title="顶层Const与底层Const"></a>顶层Const与底层Const</h2><p>由于指针本身也是一个对象，所以在Const修饰指针时，就立存在修饰指针或修饰指针所指的对象。如果Const修饰指针则是底层Const，如果修饰指针所指的对象则是顶层Const。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span>* pa;//<span class="hljs-keyword">const</span>修饰指针，所以为底层<span class="hljs-keyword">const</span><br><span class="hljs-built_in">int</span>* <span class="hljs-keyword">const</span> pb;//<span class="hljs-keyword">const</span>修饰pb，所以为顶层<span class="hljs-keyword">const</span><br></code></pre></td></tr></table></figure><hr><h1 id="三、字符串、向量和数组"><a href="#三、字符串、向量和数组" class="headerlink" title="三、字符串、向量和数组"></a>三、字符串、向量和数组</h1><hr><h2 id="1-c-11的string对象的初始化方式"><a href="#1-c-11的string对象的初始化方式" class="headerlink" title="1.c++11的string对象的初始化方式"></a>1.c++11的string对象的初始化方式</h2><p>string s;<br>string str=s;<br>string str(s);<br>string str(“str”);<br>string str=”str”;<br>string str(2,’s’);//这种形式得到的是字符串”ss”,其中括号里只能使用字符。</p><h2 id="2-cin、getline-和cin-getline"><a href="#2-cin、getline-和cin-getline" class="headerlink" title="2.cin、getline()和cin.getline()"></a>2.cin、getline()和cin.getline()</h2><p>cin在对象在从缓存中读取数据时遇到空格符，制表符，换行符时或读至文件尾时会结束读取。<br>getline()可以读取空格符，遇到换行符时或读至文件尾时结束读取。<br>cin.getline()作用和getline一样，只是cin.getline和cin都是标准输出流iosteeam中的对象方法，而getline这是属于string.h中的方法。</p><h2 id="3-string-size-type类型"><a href="#3-string-size-type类型" class="headerlink" title="3.string::size_type类型"></a>3.string::size_type类型</h2><p><code>size_type</code>类型是c++定义的几种标准库类型的几种配套类型，其目的在于解决在不同机器中因为机器字长不同而导致string.size()的返回值无法存储的问题，比如在一个16位的机器中int整型存储的最大字符数为32767，但这对于储存一个文件大小的string来说这个大小是明显不够的，所以c++引入<code>size_type</code>，以解决不同机器上string.size()的返回值一定能被存储。<br><code>size_type</code>的本质是无符号类型所以在使用string.size()和有符号数做运算时要十分注意，因为这会导致计算结果出现异常。<br>需要注意的一点是<code>size_type</code>类型实际上不是一个确定的类型，在使用<code>size_type</code>时应注明<code>size_type</code>的类型，如:<code>string::size_type,vector&lt;int&gt;::size_type</code>。</p><h2 id="4-cctype头文件提供的一些字符判断函数"><a href="#4-cctype头文件提供的一些字符判断函数" class="headerlink" title="4.cctype头文件提供的一些字符判断函数"></a>4.cctype头文件提供的一些字符判断函数</h2><ul><li><p>isalnum(c) 当c是字母过数字时为真</p></li><li><p>isalpha(c) 当c是字母时为真</p></li><li><p>iscntrl(c) 当c是控制字符时为真</p></li><li><p>isdigit(c) 当c是数字时为真</p></li><li><p>isgraph(c) 当c不是空格但可以打印时为真</p></li><li><p>islower(c) 当c是小写字母时为真</p></li><li><p>isprint(c) 当c是可打印字符时为真(即c是空格或c具有可视化形式)</p></li><li><p>ispunct(c) 当c是标点符号时为真(即c不是控制字符、数字、字母、可打印空白中的一种)</p></li><li><p>isspace(c) 当c是空格时为真</p></li><li><p>isupper(c) 当c是大写字母时为真</p></li><li><p>isxdigit(c) 当c是16进制数字时为真</p></li><li><p>tolower(c) 如果c是大写字母则输出其小写</p></li><li><p>toupper(c) 如果c是小写字母则输出其大写</p></li></ul><h2 id="5-c-11的“foreach”"><a href="#5-c-11的“foreach”" class="headerlink" title="5.c++11的“foreach”"></a>5.c++11的“foreach”</h2><p>c++本没有foreach循环，但是c++11为for语句添加了新的语法:<br>for(param:array){}这个for语法每次循环从array中读取一个数据并存放在param中用于操作<br>需要注意的是param如果不使用引用的话，param实际是array中元素的拷贝，此时对param进行修改不会改变array的元素，如需要更改array中的元素的值时需要对param取引用。<br>还有一点十分重要的是不可以在范围for语句中更改array的容量大小，这是因为能被范围for遍历的序列都需要包含begin,end两个返回迭代器的成员，我们可以先看一下范围for的源码:<br>for(auto beg=v.begin(),end=v.end();beg!=end;++beg)<br>{<br>}<br>可以看到在范围for中实际上在循环前就已经存储了可遍历序列的begin,end迭代器，所以如果在循环中改变了序列的大小循环就会出错。</p><h2 id="6-vector容器的初始化方式"><a href="#6-vector容器的初始化方式" class="headerlink" title="6.vector容器的初始化方式"></a>6.vector容器的初始化方式</h2><ul><li>vector<T> v v是一个空的vector</T></li><li>vector<T> v2(v) v2是一个包含v所有副本的的vector</T></li><li>vector<T> v2=v 等价物v2(v)</T></li><li>vector<T> v(n,val) v是一个包含了n个重复元素，每个元素都是val的vector</T></li><li>vector<T> v(n) v是一个包含了n个重复执行了初始化的对象</T></li><li>vector<T> v{a,b,c……} v是一个包含了初始值个数元素的vector，每个元素被赋予对应的初始值</T></li><li>vector<T> v={a,b,c……} 等于v{a,b,c……}</T></li><li><font color="red"> 使用数组初始化vector容器，vector<T>(begin(array),end(array))，其中begin(array)是数组array的首地址，end(array)是数组array的尾地址 </T></font></li></ul><h2 id="7-vector对象能高效增长"><a href="#7-vector对象能高效增长" class="headerlink" title="7.vector对象能高效增长"></a>7.vector对象能高效增长</h2><p>c++标准要求vector容器在运行时能高效快速地添加元素，在c++11标准中vector的动态添加元素的性能要优于预先规定容器大小的性能，只有一种情况例外，就是vector中的元素全部都是相同的时候这种情况会反过来。</p><h2 id="8-迭代器的end"><a href="#8-迭代器的end" class="headerlink" title="8.迭代器的end"></a>8.迭代器的end</h2><p>迭代器的end()并不实际指向某个元素，所以不能对其进行递增或解引用操作。 </p><h2 id="9-iterator和const-iterator"><a href="#9-iterator和const-iterator" class="headerlink" title="9.iterator和const_iterator"></a>9.iterator和const_iterator</h2><p>iterator和<code>const_iterator</code>是标准库定义的迭代器的类型，一般迭代器没有固定的类型，一般使用<code>类型::iterator</code>或<code>const_iterator</code>来确定迭代器的类型，如：<code>vector&lt;int&gt;::iterator  it</code><br><code>iterator</code>为可读可写迭代器，<code>iterator</code>迭代器只能用于非常量容器；<br><code>const_iterator</code>为只读迭代器，<code>const_iterator</code>既可以用于非常量容器又可以用于常量容器，但是常量容器只能使用<code>const_iterator</code>迭代器。</p><h2 id="10-cbegin与cend"><a href="#10-cbegin与cend" class="headerlink" title="10.cbegin与cend"></a>10.cbegin与cend</h2><p>cbegin和cend与begin和end相对，cbegin和cend返回const_iterator迭代器。</p><h2 id="11-迭代器的-gt-运算符"><a href="#11-迭代器的-gt-运算符" class="headerlink" title="11.迭代器的-&gt;运算符"></a>11.迭代器的-&gt;运算符</h2><p>在使用迭代器的过程中经常需要通过解引用后再进行.运算，如：<code>(*it).empty()</code>，操作较为繁琐，c++11对这个操作进行了简化，即通过-&gt;运算来替换<code>(*it).</code>，前面的操作就可以替换为<code>it-&gt;empty()</code></p><h2 id="12-容器的删添操作会是迭代器、引用和指针失效"><a href="#12-容器的删添操作会是迭代器、引用和指针失效" class="headerlink" title="12.容器的删添操作会是迭代器、引用和指针失效"></a>12.容器的删添操作会是迭代器、引用和指针失效</h2><p><font color="red">这是因为容器的删添操作可能会出现存储空间的重新分配，用string作为例子是最贴切的，当我们想一个string字符串中添加一个字符时，如：</font></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sting v</span> = <span class="hljs-string">&quot;str&quot;</span>;<br><span class="hljs-attribute">v</span> = v + ‘s’;<br><br></code></pre></td></tr></table></figure><p><font color="red">程序的实际操作是先创建一个临时变量来存储添加之后的字符串strs，然后再将v指向新分配的存储空间，于是指向之前空间位置的迭代器、引用和指针自然就失效了。</font></p><h2 id="13-迭代器的运算"><a href="#13-迭代器的运算" class="headerlink" title="13.迭代器的运算"></a>13.迭代器的运算</h2><p><img src="https://i.loli.net/2020/08/27/EG2yOZL4H8YvhsT.jpg" alt="Alt"></p><p>迭代器之后同时也可以进行加减运算其结果为dfference_type的带符号整型数表示两个迭代器之间的距离。</p><h2 id="14-数组的特殊性"><a href="#14-数组的特殊性" class="headerlink" title="14.数组的特殊性"></a>14.数组的特殊性</h2><p><font color="red">不能使数组来初始化数组，也不能使用数组来赋值数组，有的编译器支持数组初始化和赋值这是编译器的自身扩展，但仍然不应该这样做，因为当换了编译环境后程序可能就会出错人。</font></p><h2 id="15-存放存放指针的数组和指向数组的指针"><a href="#15-存放存放指针的数组和指向数组的指针" class="headerlink" title="15.存放存放指针的数组和指向数组的指针"></a>15.存放存放指针的数组和指向数组的指针</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">int</span> *<span class="hljs-selector-tag">ptr</span><span class="hljs-selector-attr">[2]</span>;<span class="hljs-comment">//拥有两个指针成员的数组</span><br><span class="hljs-selector-tag">int</span> <span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-tag">ptr2</span><span class="hljs-selector-attr">[2]</span>;<span class="hljs-comment">//错误，不存在引用数组</span><br><span class="hljs-selector-tag">int</span> (*ptr3)<span class="hljs-selector-attr">[2]</span>;<span class="hljs-comment">//指向有两个长度的整型数组的指针</span><br><span class="hljs-selector-tag">int</span> (&amp;ptr4)<span class="hljs-selector-attr">[2]</span>;<span class="hljs-comment">//指向两个长度的整型数组的引用</span><br><br></code></pre></td></tr></table></figure><h2 id="16-数组和指针"><a href="#16-数组和指针" class="headerlink" title="16.数组和指针"></a>16.数组和指针</h2><p>数组的名字实际上就是指向数组收地址的指针，所以下面操作得到是指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> arr[<span class="hljs-number">2</span>] = &#123;&#125;;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ptr</span><span class="hljs-params">(arr)</span></span>;<span class="hljs-comment">//per是一个指向arr首地址的int*类型指针</span><br><br></code></pre></td></tr></table></figure><p><font color="red">使用decltype进行上面的操作不会得到指针，而是得到数组，如：</font></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">decltype</span>(arr) arr<span class="hljs-number">2</span> = &#123;<span class="hljs-number">1</span>&#125;;//arr<span class="hljs-number">2</span>是一个包含一个元素的int型数组<br></code></pre></td></tr></table></figure><p><font color="red">对数组执行下标运算实质上是对指向数组首地址的指针执行下标运算，如：</font></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> i = ia[<span class="hljs-number">2</span>]; <span class="hljs-comment">//实际得到是(ia+2)所指向的元素</span><br></code></pre></td></tr></table></figure><p><font color="red">数组的下标运算只要不超过数组长度就可以执行下标运算，如：含有10个元素数组下标从0-9，但是 下标运算可以取到10，即a[10]，a[10]是数组的尾元素的下一个位置，但是对a[10]只能进行去地址运算(&amp;a[10])，不能对a[10]解引用或读取。</font></p><h2 id="17-ptrdiff-t类型"><a href="#17-ptrdiff-t类型" class="headerlink" title="17.ptrdiff_t类型"></a>17.ptrdiff_t类型</h2><p>和<code>size_type</code>一样，<code>ptrdiff_t</code>是c++11专门定制给begin()与end()的运算结果的类型，用于适应不同机器的字长。<br><font color="red">需要注意的是，内置数组下标值不是<code>ptrdiff_t</code>类型，如：a[1]，1就不是<code>ptrdiff_t</code>类型。</font></p><h2 id="18-void-指针"><a href="#18-void-指针" class="headerlink" title="18.void *指针"></a>18.void *指针</h2><p>任何非常量值都可以存入<code>void *</code>指针中。</p><h1 id="四、表达式"><a href="#四、表达式" class="headerlink" title="四、表达式"></a>四、表达式</h1><hr><h2 id="1-为定义行为"><a href="#1-为定义行为" class="headerlink" title="1.为定义行为"></a>1.为定义行为</h2><p>c++中存在一些为定义行为，如&lt;&lt;运算符在c++中并没有定义其后表达式的运算顺序，此时运行下面代码就会出现为定义行为。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;++i&lt;&lt;<span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure><p>此时会出现0，1或1，1两种结果，这是因为&lt;&lt;没有明确指定何时及如何对运算对象求值，但是在实际使用过程中并没有出现上述情况，这可能是编译器为&lt;&lt;规定了运算顺序。</p><h2 id="2-溢出与其他算术异常"><a href="#2-溢出与其他算术异常" class="headerlink" title="2.溢出与其他算术异常"></a>2.溢出与其他算术异常</h2><p><img src="https://i.loli.net/2020/09/04/QRnNjiTqEeOGaLV.jpg" alt="6"></p><h2 id="3-运算符的优先级"><a href="#3-运算符的优先级" class="headerlink" title="3.运算符的优先级"></a>3.运算符的优先级</h2><p><img src="https://i.loli.net/2020/10/09/6aVu9jBoswIgUEY.jpg" alt="Alt"></p><h2 id="4-前置递增运算符与后置递增运算符的运行过程"><a href="#4-前置递增运算符与后置递增运算符的运行过程" class="headerlink" title="4.前置递增运算符与后置递增运算符的运行过程"></a>4.前置递增运算符与后置递增运算符的运行过程</h2><p>前置递增运算符先将对象递增之后再返回递增后的结果，而后置递增运算符则先创建一个临时变量先将旧的值存储起来，然后再将变量递增，再将旧的值返回。<br>相对于前置递增运算符，后置递增运算符需要创建一个临时变量，这就产生了一个消耗，在一些普通的后置递增运算中可能不大可看得出来，但在较为复杂的迭代器中这种额外的消耗就会产生巨大的性能浪费，所以平时使用时尽量使用前置递增运算符。</p><h2 id="5-表达式在运算过程中值发生变化"><a href="#5-表达式在运算过程中值发生变化" class="headerlink" title="5.表达式在运算过程中值发生变化"></a>5.表达式在运算过程中值发生变化</h2><p><font color="red">在一个运算表达式中，参与运算的值不应该在运算的过程中发生变化，否则极易造成未定义行为，如：</font><br><font color="red"><code>v[i++]&lt;v[i]</code>，在大于号运算的过程中v[i++]的值向后移动了一位，造成了值的变化，由于C++没有定义二元运算符两端未定义自增运算符的运算顺序，所级就造成了未定义行为。</font></p><h2 id="6-有符号数的位运算"><a href="#6-有符号数的位运算" class="headerlink" title="6.有符号数的位运算"></a>6.有符号数的位运算</h2><p>有符号数尽量不要做位运算，因为位运算容易改变有符号数的符号位导致未定义行为。</p><h2 id="7-位运算中的类型提升"><a href="#7-位运算中的类型提升" class="headerlink" title="7.位运算中的类型提升"></a>7.位运算中的类型提升</h2><p>在程序编写时需要注意，任何占字节小于int类型的类型变量进行位运算时都会产生类型提升而被转换成int类型，如下代码所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">char</span> s=<span class="hljs-string">&#x27;s&#x27;</span>;<br><span class="hljs-keyword">short</span> a=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">bool</span> b=<span class="hljs-literal">true</span>;<br><span class="hljs-keyword">long</span> c=<span class="hljs-number">2</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(s)&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(~s)&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(s&lt;&lt;<span class="hljs-number">1</span>)&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;----------&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(a)&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(~a)&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;----------&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(b)&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(~b)&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;----------&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(c)&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(~c)&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;----------&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;~s&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;~b&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：<br><img src="https://i.loli.net/2020/10/23/GUI54xhOrQs7oyK.jpg" alt="Alt"></p><h2 id="8-sizeof计算指针大小"><a href="#8-sizeof计算指针大小" class="headerlink" title="8.sizeof计算指针大小"></a>8.sizeof计算指针大小</h2><p>sizeof在计算指针时有个很有趣的现象，因为sizeof满足右结合律且优先级与<code>*</code>相同，所以在<code>sizeof *p</code>中，先对p解引用，然后在对解引用后的内容计算所占内存大小，由于sizeof并没有使用解引用的内容，所以<code>*p</code>是否为空是否有效对sizeof的计算没有影响。<br><code>sizeof *p</code> == <code>sizeof(*p)</code></p><h2 id="9-隐式转换的过程"><a href="#9-隐式转换的过程" class="headerlink" title="9.隐式转换的过程"></a>9.隐式转换的过程</h2><p>以<code>int a=3.14+3；</code>为例<br>在这个例子中3.14是山比double类型，3是int类型，运算时为了保证精度C++会将int类型转换成double类型，而不是因为结果是int类型而将double类型转换成int类型，所以在表达示右侧的运算过程得到的结果是一个double类型的值，当这个值被赋值给a的时候才进行double到int的类型转换。</p><hr><h1 id="五、语句"><a href="#五、语句" class="headerlink" title="五、语句"></a>五、语句</h1><hr><h2 id="1-switch语句跨case标签引用变量"><a href="#1-switch语句跨case标签引用变量" class="headerlink" title="1.switch语句跨case标签引用变量"></a>1.switch语句跨case标签引用变量</h2><p>若需要在一个 case 语句下定义变量同时在多个 case 语下使用这个变量，则定义变量时不能同时初始化变量，应另起等于初始变量，否则编译器会报跨标签访问错误，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">switch</span> (a)<br>&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">int</span> b;  <span class="hljs-comment">//如果直接int b=1;则会报跨标签访问错误</span><br>        b=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        ;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-C-无法捕获计算溢出异常和除0异常"><a href="#2-C-无法捕获计算溢出异常和除0异常" class="headerlink" title="2.C++无法捕获计算溢出异常和除0异常"></a>2.C++无法捕获计算溢出异常和除0异常</h2><p>C++认为计算溢出和除0异常属于底层事件，应被同样底层的事件去处理，所以C++没有提供计算溢出和除0异常，如果需要捕获这两类异常在Windows系统中应使用Windows提供的SEH模型<code>__try</code>、<code>__except</code>、<code>__finally</code>异常语句，使用方法和try-catch基本类似，与try-catch不同的是，SEH中使用的是<code>__try-__except</code>搭配和<code>__try-__finally</code>搭配。</p><hr><h1 id="六、函数"><a href="#六、函数" class="headerlink" title="六、函数"></a>六、函数</h1><hr><h2 id="1-静态局布变量"><a href="#1-静态局布变量" class="headerlink" title="1.静态局布变量"></a>1.静态局布变量</h2><p>在函数体内使用static关键字可以效静态局布量，静态局布变量的生命周期从变量定义到程序结束，但是静态局布变量只对函数可见，在函数外不可访问。</p><h2 id="2-C-程序的编译过程"><a href="#2-C-程序的编译过程" class="headerlink" title="2.C++程序的编译过程"></a>2.C++程序的编译过程</h2><p><img src="https://i.loli.net/2020/11/09/bJ5xRFg6TGHnLCO.jpg" alt="Alt"></p><h2 id="3-函数调用过程中的形参创建"><a href="#3-函数调用过程中的形参创建" class="headerlink" title="3.函数调用过程中的形参创建"></a>3.函数调用过程中的形参创建</h2><p>函数的每一次调用都会重新创建形参并传入实参对其进行初始化，形餐盘类型决定了形参与实参的交互类型，如果形参是引用类型，则形参与相对应的实参相绑定，作为实参的别名使用；如果形参是值类型，则实参的值拷贝给形参，形参与实参相互独立。</p><h2 id="4-函数的指针参数传递"><a href="#4-函数的指针参数传递" class="headerlink" title="4.函数的指针参数传递"></a>4.函数的指针参数传递</h2><p><font color="red">当指针作为实参传递给函数形参时，传递的是指针的值拷贝而不是指针所指的对象，且形参指针与实参指针是两个不同的指针，此时形参指针与实参指针指向同一对象，修改形参的指针指向不会影实参指针。</font></p><h2 id="5-引用形参的限制"><a href="#5-引用形参的限制" class="headerlink" title="5.引用形参的限制"></a>5.引用形参的限制</h2><ul><li><p>如果将函数的参数定义普通引用参数，那么这个形参就无法接受const对象、字面值和需要类型转换的对象作为实参。</p></li><li><p>如果将函数的参数定义为const引用参数，这个参数可以接受第一条中的参数，但是却无法修改参数的值。</p></li></ul><h2 id="6-数组的两个特殊性质"><a href="#6-数组的两个特殊性质" class="headerlink" title="6.数组的两个特殊性质"></a>6.数组的两个特殊性质</h2><ul><li>数组不可被拷贝</li><li>数组再使用时被转换为指针</li></ul><h2 id="7-数组引用形参"><a href="#7-数组引用形参" class="headerlink" title="7.数组引用形参"></a>7.数组引用形参</h2><p>当我们使用数组作普通形参时，</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">void <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(int* arr)</span></span>;<br>void <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(int arr[])</span></span>;<br>void <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(int arr[<span class="hljs-number">10</span>])</span></span>;<br></code></pre></td></tr></table></figure><p>表示的都是同一个函数，且形参可接受任意长度的实参数组，但是当将普通形参改为引用形参时，</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">void <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(int (&amp;arr)</span></span>[<span class="hljs-number">10</span>]);<br></code></pre></td></tr></table></figure><p><code>(&amp;arr)</code>中()不可缺少，否则形参变成引用的数组而非数组的引用，且形参只能接收长度为10的数组。</p><h2 id="8-main函数传参"><a href="#8-main函数传参" class="headerlink" title="8.main函数传参"></a>8.main函数传参</h2><p>有的时候我们会遇到这样的main函数：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>通常情况下，直接使用argv，argv中的内容是空的，那么main函数在什么情况下会接收参数呢？<br>事实上main函数本身就是当前程序的入口，在当前程序中没有其他程序为main函数传入参数了，当我们把写好的程序打包后在外部调用时就可以给main函数传入参数了，如在CMD中调程序</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">prog -o -d ofile data0<span class="hljs-regexp">//</span>prog为程序名<br></code></pre></td></tr></table></figure><p><font color="red">需要注意的是argv数组的0号索引存储程序的名字，参数从1号索引开始存储，且最后一个索引位置固定内容为0</font></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPlus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Dev】DevExpress应用</title>
    <link href="/2021/02/03/%E3%80%90Dev%E3%80%91DevExpress%E5%BA%94%E7%94%A8/"/>
    <url>/2021/02/03/%E3%80%90Dev%E3%80%91DevExpress%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="一、大纲"><a href="#一、大纲" class="headerlink" title="一、大纲"></a>一、大纲</h2><p>最近使用DevExpress做C/S开发碰到了一些问题，在解决问题的同时在这里做一下记录，下面列出涉及到技术点</p><ul><li><strong>Dev框架下GridControl与GridView</strong></li><li><strong>使用模板列动态替换GridView的指定列</strong></li><li><strong>GridView分组并去掉列名的前缀</strong></li><li><strong>FPT服务器文件预览与下载</strong></li><li><strong>单元格添加按钮并添加自定义点击事件</strong></li><li><strong>GridView数据导出到Excel</strong></li><li><strong>向Word模板中写数据</strong></li></ul><a id="more"></a><h2 id="二、Dev框架下的GridControl和GridView"><a href="#二、Dev框架下的GridControl和GridView" class="headerlink" title="二、Dev框架下的GridControl和GridView"></a>二、Dev框架下的GridControl和GridView</h2><h3 id="1-GridControl和GridView的关系"><a href="#1-GridControl和GridView的关系" class="headerlink" title="1.GridControl和GridView的关系"></a>1.GridControl和GridView的关系</h3><p>Dev框架下GridControl负责操作数据，GridView负责展示数据，GridControl是GridView的容器，一个GridControl可以容纳多个GridView，在GridView中的任何数据操作都不会影响到GridControl中的源数据，即当我们将GridControl中数据重新刷入GridView时，GridView中数据操作会被清除，所以如果我们有要在本地展示的数据则需要在GridControl刷数据进入GridView的时候重新再刷入一次本地数据。</p><h3 id="2-GridControl输入数据到GridView的原理"><a href="#2-GridControl输入数据到GridView的原理" class="headerlink" title="2.GridControl输入数据到GridView的原理"></a>2.GridControl输入数据到GridView的原理</h3><p>GridControl的数据刷入GridView的操作由Dev框架执行，我们需要做的只是把数据绑定到GridControl.DataSource中即可。</p><p>只有当GridView中存在与GridControl数据源对应列时，GridControl才能将对应列的数据刷入GridView的对应列中，这里的对应列指的是GridView中列的<code>FiledName</code>的值与GridControl数据源的列名相同，且大小写敏感。</p><p>在GridView的列属性中有三个极为重要的属性：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090745.png"></p><ul><li><p>Name：列在程序中操作的标识符，类似变量名，对列的操作都由它来引用，如：修改colfilename列的列宽</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">colfilename.Width = <span class="hljs-number">300</span>;<br></code></pre></td></tr></table></figure></li><li><p>ColumnEdit：用于挂载模板列的属性，可以将列动态的替换为其他类型的控件，例子中是将列挂载了一个多行编辑框，这样就可以在单元格中显示多行内容</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090756.png"></p></li><li><p>FieldName：FieldName属性是列与GridControl数据源对应的标志，如果想要将GridControl数据源中某一列的数据刷入当前列，那么当前列的FieldName的取值必须和数据源中对应列的列名一致，并且FielName也是用来获取表格数据的标识，如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">gridView_FileViewer.GetFocusedDataRow()[<span class="hljs-string">&quot;path&quot;</span>]<span class="hljs-comment">//取所选行的path列单元格的数据</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-向GridView存在而GridControl中不存在的列刷入数据"><a href="#3-向GridView存在而GridControl中不存在的列刷入数据" class="headerlink" title="3.向GridView存在而GridControl中不存在的列刷入数据"></a>3.向GridView存在而GridControl中不存在的列刷入数据</h3><p>有的时候为了展示需要，我们需要在GridView中增加新列刷入自己的数据，而新增列在GridControl的数据源中没有与之对应的列，即在数据源中没有对应的字段（这里的数据源通常情况下指的就是数据库中的表），此时我们就需要在GridControl.Datasource中动态地添加一列来与新增列对应。</p><p>为什么要要在GridControl.Datasource中动态地添加一列呢？</p><p>这可能是由GridControl和GridView的内部机制影响的，当一列在GridView中存在而GridControl中不存在时，我们是无法向此列写入数据的，即使数据是来自本地而不是数据库，并且编译器会报错：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090901.png"></p><p>如果我们要向GridView存在而GridControl中不存在的列刷入数据，那么我们必须在GridControl的DataSource中动态的加列，下面是示例代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LoadFileNameColumn</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs args</span>)</span><br><span class="hljs-function"></span>&#123;<br>GridColumn col = gridView_JobPlacement.Columns[<span class="hljs-string">&quot;xgwj&quot;</span>];<span class="hljs-comment">//取表格xgwj列的索引</span><br><br><span class="hljs-comment">/*代码块说明：</span><br><span class="hljs-comment">*   作用：向gridview的datasource动态添加filename列，使GridView中的filename列与DataSource中的filename字段对应</span><br><span class="hljs-comment">*   说明：因为在GridView中添加了filename列如果在GridView的DataSource中没有与之对应的字段，</span><br><span class="hljs-comment">*       则无法对filename列做任何操作</span><br><span class="hljs-comment">*/</span><br>DataTable gridViewTable = gridControl_JobPlacement.DataSource <span class="hljs-keyword">as</span> DataTable;<span class="hljs-comment">//取DataSource的引用并转换成DataTable</span><br><span class="hljs-keyword">if</span> (!gridViewTable.Columns.Contains(<span class="hljs-string">&quot;filename&quot;</span>))<span class="hljs-comment">//判断DataSource中是否已存在filename列</span><br>&#123;<br>DataColumn dsFileNameCol = <span class="hljs-keyword">new</span> DataColumn();<span class="hljs-comment">//创建新列</span><br>dsFileNameCol.ColumnName = <span class="hljs-string">&quot;filename&quot;</span>;<span class="hljs-comment">//将新列命名为filename</span><br>         gridViewTable.Columns.Add(dsFileNameCol);<span class="hljs-comment">//将新列添加到DataSource中</span><br>&#125;<span class="hljs-comment">//至此，DataSource中就存在与GridView中的filename列对应的filename列了</span><br><br><span class="hljs-comment">//遍历GridView所有行，对有文件组编码的行在filename列载入文件列表信息</span><br> <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> rowIndex = <span class="hljs-number">0</span>; rowIndex &lt; gridView_JobPlacement.RowCount; rowIndex++)<br>&#123;     <br> DataRow row = gridView_JobPlacement.GetDataRow(rowIndex);<span class="hljs-comment">//根据索引数据行</span><br><span class="hljs-keyword">if</span> (row[<span class="hljs-string">&quot;xgwj&quot;</span>].ToString() != <span class="hljs-string">&quot;&quot;</span>)<span class="hljs-comment">//如果数据行中的xgwj列单元格不为空，则向单元格刷入指定数据</span><br>&#123;<br><span class="hljs-built_in">string</span> fileGroupTmp = gridView_JobPlacement.GetRowCellDisplayText(rowIndex, col);<span class="hljs-comment">//取指定单元格显示的内容</span><br><span class="hljs-built_in">string</span> fileGroup = CodingTool.GetFileGroup(fileGroupTmp);<span class="hljs-comment">//将单元格存储的文件组编码转换成数据库可用的编码</span><br>DataTable table = bll.SelectFromFileTableByFileGroup(fileGroup);<span class="hljs-comment">//根据编码到数据库查询文件列表</span><br><span class="hljs-keyword">foreach</span>(DataRow tableRow <span class="hljs-keyword">in</span> table.Rows)<span class="hljs-comment">//遍历文件列表将文件名刷入新增列</span><br>&#123;<br>row[<span class="hljs-string">&quot;filename&quot;</span>] += tableRow[<span class="hljs-string">&quot;filename&quot;</span>]+<span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-comment">//将数据刷入filename列单元格</span><br>&#125;<br>         &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、使用模板列动态替换GridView中的指定列"><a href="#三、使用模板列动态替换GridView中的指定列" class="headerlink" title="三、使用模板列动态替换GridView中的指定列"></a>三、使用模板列动态替换GridView中的指定列</h2><p>有的时候为了保密需要，在数据库中部分字段会用编码标识，如：人名使用编码标识，张三对应编码001，但是在表格中展示的时候应该显示人名而不是编码，此时我们就需要用到模板列的动态替换。</p><p>直接上代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#">Security.BLL.userinfo ubll = <span class="hljs-keyword">new</span> Security.BLL.userinfo();<br><br>RepositoryItemGridLookUpEdit replaceRegistrant = <span class="hljs-keyword">new</span> RepositoryItemGridLookUpEdit();<br>replaceRegistrant.DataSource = ubll.GetAllList().Tables[<span class="hljs-number">0</span>];<span class="hljs-comment">//绑定数据源到RepositoryItemGridLookUpEdit</span><br>replaceRegistrant.DisplayMember = <span class="hljs-string">&quot;fullname&quot;</span>;  <span class="hljs-comment">//选择要替换显示的字段</span><br>replaceRegistrant.ValueMember = <span class="hljs-string">&quot;ID&quot;</span>;  <span class="hljs-comment">//</span><br>replaceRegistrant.NullText = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-comment">//字段为空时要显示的内容</span><br>gridView_JobPlacement.Columns[<span class="hljs-string">&quot;djr&quot;</span>].ColumnEdit = replaceRegistrant;<span class="hljs-comment">//将RepositoryItemGridLookUpEdit绑定到GridView的“djr”列</span><br><br>RepositoryItemGridLookUpEdit replacePricipal = <span class="hljs-keyword">new</span> RepositoryItemGridLookUpEdit();<br>replacePricipal.DataSource = ubll.GetAllList().Tables[<span class="hljs-number">0</span>];<span class="hljs-comment">//绑定数据源到RepositoryItemGridLookUpEdit</span><br>replacePricipal.DisplayMember = <span class="hljs-string">&quot;fullname&quot;</span>;  <span class="hljs-comment">//选择要替换显示的字段</span><br>replacePricipal.ValueMember = <span class="hljs-string">&quot;ID&quot;</span>;  <span class="hljs-comment">//</span><br>replacePricipal.NullText = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-comment">//字段为空时要显示的内容</span><br>gridView_JobPlacement.Columns[<span class="hljs-string">&quot;fzr&quot;</span>].ColumnEdit = replacePricipal;<span class="hljs-comment">//将RepositoryItemGridLookUpEdit绑定到GridView的“djr”列</span><br></code></pre></td></tr></table></figure><p>这是通过代码添加动态的添加模板列，同时我们也可以在列属性中的ColumnEdit属性中静态的添加模板列。</p><h2 id="四、GridView分组并去掉列名的前缀"><a href="#四、GridView分组并去掉列名的前缀" class="headerlink" title="四、GridView分组并去掉列名的前缀"></a>四、GridView分组并去掉列名的前缀</h2><h3 id="1-分组"><a href="#1-分组" class="headerlink" title="1.分组"></a>1.分组</h3><p>GridView分组只需要在需要分组的列的属性中将GroupIndex属性值由“-1”改为0即可，如果需要二级分组则在需要分组的列的属性中将GroupIndex属性值由“-1”改为1，以此类推需要三级分组则改为2。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090912.png"></p><h3 id="2-去掉列名前缀"><a href="#2-去掉列名前缀" class="headerlink" title="2.去掉列名前缀"></a>2.去掉列名前缀</h3><p>分完组后如果不做修改我们加载数据之后表格是这样的：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090919.png"></p><p>有时我们不需要显示列名前缀，这时我们需要修改GridView的GroupFormat属性修改为{1}，GroupFormat属性的默认值是<code>&#123;0&#125;: [#image]&#123;1&#125; &#123;2&#125;</code>，其中</p><ul><li>{0}显示列标题</li><li>[#image]显示图片</li><li>{1}显示列的内容值</li><li>{2}显示列的摘要</li></ul><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090923.png"></p><p>设置好之后，效果是这样的:</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090936.png"></p><h2 id="四、FTP文件预览与下载"><a href="#四、FTP文件预览与下载" class="headerlink" title="四、FTP文件预览与下载"></a>四、FTP文件预览与下载</h2><p>直接上代码，解释都放注释上了：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PreviewFile</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender,EventArgs e</span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (fileDic == <span class="hljs-literal">null</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//自定义函数，获取文件在服务器中的路径</span><br>    <span class="hljs-built_in">string</span> serverPath = ServerFTP.CreateFilePathInServerBySQLPath(gridView_FileViewer.GetFocusedDataRow()[<span class="hljs-string">&quot;path&quot;</span>].ToString());<br>    <span class="hljs-comment">//获取文件名</span><br>    <span class="hljs-built_in">string</span> fileName = gridView_FileViewer.GetFocusedDataRow()[<span class="hljs-string">&quot;file&quot;</span>].ToString();<br>    <span class="hljs-comment">//根据路径将文件下载到本地，并返回文件路径</span><br>    <span class="hljs-built_in">string</span> savePath = ServerFTP.currentMode.RequestFile(serverPath,fileName,GeneralLib.FTPDownloadStyle.CACHE);<br>    <span class="hljs-keyword">if</span> (savePath != <span class="hljs-string">&quot;&quot;</span>)<br>    &#123;<br>        <span class="hljs-comment">//调用系统软件打开文件</span><br>        FileIO.OpenFileInWindows(savePath);<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>这里挑几个比较重要的函数讲解</p><p><strong>RequestFile</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">RequestFile</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> serverPath,<span class="hljs-built_in">string</span> fileName, FTPDownloadStyle style</span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">string</span> savePath = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">switch</span> (style)<br>    &#123;<br>        <span class="hljs-comment">//下载文件到缓存临时文件夹，用于预览</span><br>        <span class="hljs-keyword">case</span> FTPDownloadStyle.CACHE:<br>            savePath = Path.Combine(ServerFTP.cachePath, fileName);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//下载文件到所选的文件夹，用于下载</span><br>        <span class="hljs-keyword">case</span> FTPDownloadStyle.CHOOSEDIC:<br>            savePath = FileIO.ChooseSaveFile(fileName, <span class="hljs-string">&quot;&quot;</span>, ServerFTP.chooseTempDic);       <br>            <span class="hljs-comment">//保存所选的文件夹，以便下次打开直接进入相应目录</span><br>            ServerFTP.chooseTempDic = Path.GetDirectoryName(savePath);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (savePath == <span class="hljs-literal">null</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//判断目录是否存在</span><br>    <span class="hljs-keyword">if</span> (!Directory.Exists(Path.GetDirectoryName(savePath)))<br>    &#123;<br>        <span class="hljs-comment">//如果不存在则创建目录</span><br>        Directory.CreateDirectory(Path.GetDirectoryName(savePath));<br>    &#125;<br><br><span class="hljs-comment">//根据文件路径创建FPT连接实例</span><br>    FtpWebRequest ftp = (FtpWebRequest)WebRequest.Create(serverPath);<br>    <span class="hljs-comment">//从配置文件中读取登录项</span><br>    ICredentials credentials = <span class="hljs-keyword">new</span> NetworkCredential(Config.Get[<span class="hljs-string">&quot;ftp_username&quot;</span>], Config.Get[<span class="hljs-string">&quot;ftp_password&quot;</span>]);<br>    <span class="hljs-comment">//配置FPT服务器登录项</span><br>    ftp.Credentials = credentials；<br>    <span class="hljs-comment">//配置FPT操作为下载文件</span><br>    ftp.Method = WebRequestMethods.Ftp.DownloadFile;<br><span class="hljs-comment">//向FPT服务器发出操作请求</span><br>    FtpWebResponse response = (FtpWebResponse)ftp.GetResponse();<br>    <span class="hljs-comment">//创建流缓冲区接收FPT服务器反馈的字节流</span><br>    Stream responseStream = response.GetResponseStream();<br>    <span class="hljs-comment">//根据存储路径在本地创建文件</span><br>    FileStream fs = File.Create(savePath);<br>    <span class="hljs-comment">//创建用于批量取缓冲区字节数据的数据</span><br>    <span class="hljs-built_in">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[ConstLib.BUFFER_SIZE];<br>    <span class="hljs-built_in">int</span> read = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">do</span><br>    &#123;<br>        <span class="hljs-comment">//将缓冲区的字节数据读入字节数组</span><br>        read = responseStream.Read(buffer, <span class="hljs-number">0</span>, buffer.Length);<br>        <span class="hljs-comment">//将字节数组的数据写入到文件中</span><br>        fs.Write(buffer, <span class="hljs-number">0</span>, read);<br>        <span class="hljs-comment">//清楚fs的流缓冲区，这里fs的流缓冲区与responseStream流缓冲区不是同一个缓冲区，需要注意</span><br>        fs.Flush();<br>    &#125;<br>    <span class="hljs-keyword">while</span> (read != <span class="hljs-number">0</span>)；<br>        <br>    fs.Flush();<br>    <span class="hljs-comment">//关闭文件</span><br>    fs.Close();<br>    <br>    <span class="hljs-keyword">return</span> savePath;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>OpenFileInWindows</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Process <span class="hljs-title">OpenFileInWindows</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> filePath</span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//创建一个新的进程</span><br>    ProcessStartInfo info = <span class="hljs-keyword">new</span> ProcessStartInfo();<br>    <span class="hljs-comment">//设置进程要打开的文档，Windows会根据文件类型的默认开打应用来启动对应应用程序来打开文件</span><br>    info.FileName = Path.GetFileName(filePath);<br>    <span class="hljs-comment">//设置启动进程的初始目录</span><br>    info.WorkingDirectory = Path.GetDirectoryName(filePath);<br>    <span class="hljs-comment">//设置进程启动后，窗口的状态，可以设置为最大化，最小化和正常</span><br>    info.WindowStyle = ProcessWindowStyle.Normal;<br>    <span class="hljs-comment">//启动进程</span><br>    Process proc = Process.Start(info);<br><br>    <span class="hljs-keyword">return</span> proc;<br>&#125;<br></code></pre></td></tr></table></figure><p>当关闭文件时清楚临时文件夹的内容</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CleanCacheDirectory</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//判断临时文件夹是否存在</span><br>    <span class="hljs-keyword">if</span> (!Directory.Exists(ServerFTP.cachePath))<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        <span class="hljs-comment">//等待系统将占用文件的进程杀死再清空临时文件夹</span><br>        System.Threading.Thread.Sleep(<span class="hljs-number">500</span>);<br>        <span class="hljs-comment">//获取临时文件夹目录信息</span><br>        DirectoryInfo dicInfo = <span class="hljs-keyword">new</span> DirectoryInfo(ServerFTP.cachePath);<br>        <span class="hljs-comment">//直接删除临时文件夹</span><br>        dicInfo.Delete(<span class="hljs-literal">true</span>);<br>    &#125;<br>    catch<br>    &#123;<br>        <span class="hljs-comment">//如果目录被其他进程占用，则暂时不清空临时文件夹</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我使用的是最简单的直接删除临时文件夹的暴力删除法，这样做会有一个问题就是，在程序删除文件夹的时候，可能预览文件的进程还没有被系统杀死或有其他的进程占用了目录中文件，这都会导致目录删除失败而抛出异常，我的解决方案是在删除目录之前等待500ms，等待系统将预览文件的进程杀死后在删除文件夹，但是如果是其他的进程占用了目录，则需要手动结束进程才能继续删除临时文件夹，我的解决方案是，如果有其他进程占用了目录，则本次本次临时缓冲区先不删除，等下次有机会再删除。所以这里的try-catch不是用来抛出异常的，而是用来推出函数的。</p><p>当然比较理想的删除方法是遍历整个目录中文件和子文件夹，依次删除目录下文件和子文件夹，有被其他进程占用的文件暂时不删除。这样就可以只留下被占用的文件，而不是整个目录。</p><h2 id="五、单元格添加按钮并添加自定义点击事件"><a href="#五、单元格添加按钮并添加自定义点击事件" class="headerlink" title="五、单元格添加按钮并添加自定义点击事件"></a>五、单元格添加按钮并添加自定义点击事件</h2><p>有时我们需要向某一列的单元格添加点击事件，甚至向某一个单元格添加点击事件，这时我们就需要向单元格添加按钮了。</p><h3 id="1-向单元格添加简单的点击事件"><a href="#1-向单元格添加简单的点击事件" class="headerlink" title="1.向单元格添加简单的点击事件"></a>1.向单元格添加简单的点击事件</h3><p>如果我们只想在某一单元格添加简单的点击事件</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">gridView_JobPlacement_RowCellClick</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, RowCellClickEventArgs e</span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (e.RowHandle == <span class="hljs-number">1</span> &amp;&amp; e.Column.FieldName == <span class="hljs-string">&quot;filename&quot;</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (e.Button == MouseButtons.Left)<br>        &#123;<br>            <span class="hljs-comment">//todo</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (e.Button == MouseButtons.Right)<br>        &#123;<br><span class="hljs-comment">//todo</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(e.Button == MouseButtons.Moddle)<br>        &#123;<br>            <span class="hljs-comment">//todo</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这时我们需要用到RowCellClick事件，RowCellClick事件在鼠标点击单元格时触发，然后我们只需要判定鼠标点击是哪一行哪一列，就可以实现某一个单元格的点击事件了。当然我们也可以通过添加按钮来实现。</p><h3 id="2-向单元格添加复杂点击事件"><a href="#2-向单元格添加复杂点击事件" class="headerlink" title="2.向单元格添加复杂点击事件"></a>2.向单元格添加复杂点击事件</h3><p>如果我们想向单元格添加一系列复杂的点击事件，如在某一单元格内做文件的上传，预览，下载，删除等操作，这时我们就需要借助模板列了，使用模板列是无法只向某一个单元添加点击事件的，因为模板列挂载的是一整列。</p><p>我需要用到模板列<code>RepositoryItemButtonEdit</code>，我可以在列属性里静态挂载，也可以在代码中动态挂载，重要的是我们需要用到<code>RepositoryItemButtonEdit</code>属性里的<code>Buttons</code>属性，向Buttons属性里添加元素。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090945.png"></p><p>光是添加按钮单元中还是看不到按钮的，我们还需要将每个按钮的Kind属性设置为Glyph，这样我们才能在单元格中看到按钮</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090950.png"></p><p>添加完按钮就可以向对应按钮添加点击事件了，我们可以发现在列属性里找不到事件，所以我们需要在代码中为按钮添加点击事件，这时我们需要用到<code>repositoryItemButtonEdit.Buttons[0].Click</code>，其中repositoryItemButtonEdit是模板列的名字，Buttons[0]是第一个按钮的引用，我们只需要向Click事件添加我们想要执行的函数即可。</p><h2 id="六、GridView数据导出到Excel"><a href="#六、GridView数据导出到Excel" class="headerlink" title="六、GridView数据导出到Excel"></a>六、GridView数据导出到Excel</h2><p> GridView的数据要导出到Excel有很多种方法，可以最直接的就是遍历GridView，然后将数据写入Excel，这算是比较麻烦的做法了，事实上Dev已经提供了一些便捷的方法。</p><h3 id="1-GetAllFilteredAndSortedRows-方法"><a href="#1-GetAllFilteredAndSortedRows-方法" class="headerlink" title="1.GetAllFilteredAndSortedRows()方法"></a>1.GetAllFilteredAndSortedRows()方法</h3><p>Dev提供了一个<code>GridView.DataController.GetAllFilteredAndSortedRows()</code>方法，可以用于提取GridView当前数据，在筛选排序等操作之后更改了的数据也可以提取。</p><p><font color="red"> 但是，GridView类中的DataController对象在VS中被隐藏了，即通过提示器是找不到GDataController对象的的，只能通过手写调用。</font></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326090957.png"></p><p>GetAllFilteredAndSortedRows()方法返回的是一个IList泛型列表，数据写入Excel一就要自己手动写入，写入方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//需要包含的引用</span><br><span class="hljs-keyword">using</span> DevExpress.XtraSpreadsheet;<br><span class="hljs-keyword">using</span> DevExpress.Spreadsheet;<br><br>SpreadsheetControl ss = <span class="hljs-keyword">new</span> SpreadsheetControl();<br><span class="hljs-keyword">var</span> book = ss.Document;<br>Worksheet sheet = book.Worksheets[<span class="hljs-number">0</span>];<br>sheet.Import(table, <span class="hljs-literal">true</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-comment">//table是DataTable类型，也是要导出到Excel的数据</span><br></code></pre></td></tr></table></figure><p><font color="red"> 其中有一点需要格外注意，在使用Import函数时需要引用<code>DevExpress.Docs</code>程序集，因为Import函数在这个程序集里，Dev在DevExpress.Docs程序集里给Worksheet的父类ExternalWorksheet写了扩展，也就是扩展了Import函数等，其中DevExpress.Docs程序集和DevExpress.Spreadsheet程序集的命名空间是一样的，如果没有搞清楚这一点很容易产生玄学问题🥴</font></p><h3 id="2-GridView-Export-方法"><a href="#2-GridView-Export-方法" class="headerlink" title="2.GridView.Export()方法"></a>2.GridView.Export()方法</h3><p>最简单的方法就是使用Dev官方提供的导出方法GridView.Export().</p><p>Dev已经在GridView中添加了官方的Export方法，支持多种导出格式：</p><ul><li>Xls</li><li>Xlsx</li><li>Html</li><li>Mht</li><li>Pdf</li><li>Text</li><li>Rtf</li><li>Csv</li><li>Image</li><li>Docx</li></ul><p>同时提供三种重载：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326091003.png"></p><p>使用方法也很简单：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 将GridView中的数据导出到Excel</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;fileName&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;view&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ExportExcel</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> fileName, GridView view</span>)</span><br><span class="hljs-function"></span>&#123;<br>    SaveFileDialog sfd = <span class="hljs-keyword">new</span> SaveFileDialog();<br>    sfd.Title = <span class="hljs-string">&quot;另存为&quot;</span>;<br>    sfd.InitialDirectory = <span class="hljs-string">&quot;C:\\&quot;</span>;<br>    sfd.Filter = <span class="hljs-string">&quot;Excel文件(*.xlsx) | *.xlsx&quot;</span>;<br>    sfd.FileName = fileName;<span class="hljs-comment">//fileName文件名不需要包含后缀</span><br>    <span class="hljs-keyword">if</span> (sfd.ShowDialog() == DialogResult.OK)<br>    &#123;<br>        view.Export(DevExpress.XtraPrinting.ExportTarget.Xlsx, sfd.FileName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>view.Export是dev自带的导出方法，在导出文件后dev会自动调用系统对此文件的默认打开应用来打开文件，当然dev也提供内置的预览方法，这在下一节导出word模板中使用。</li></ul><h2 id="七、向Word模板中写入数据"><a href="#七、向Word模板中写入数据" class="headerlink" title="七、向Word模板中写入数据"></a>七、向Word模板中写入数据</h2><h3 id="1-载入word模板文件"><a href="#1-载入word模板文件" class="headerlink" title="1.载入word模板文件"></a>1.载入word模板文件</h3><p>向word模板中写入数据我这里主要使用的是<font color="red">RichEditControl</font>类，RichEditControl类提供海量的富文本API接口，这里主要讲解使用到的API。</p><p>首先打开word文档，RichEditControl类提供RichEditControl.LoadDocument(string path)方法加载文档，RichEditControl类也提供多个LoadDocument函数的重载给予各种文件的加载形式，我这里使用的是直接通过文件路径加载文档。LoadDocument函数支持DOC、DOCX、RTP、HTM、HTML、MHT、XML和EPUB类型的文档，可以自动检测文档类型。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">RichEditControl.LoadDocument(<span class="hljs-built_in">string</span> path)<br></code></pre></td></tr></table></figure><p>将文档载入内存之后就可以通过<font color="red">RichEditControl.Document.Text</font>属性查看文档内容了，也可以通过RichEditControl.Document.Text属性判断文档是否加载成功。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">if</span>(richEditControl.Document.Text == <span class="hljs-literal">null</span>)<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-向word模板的指定位置写入数据"><a href="#2-向word模板的指定位置写入数据" class="headerlink" title="2.向word模板的指定位置写入数据"></a>2.向word模板的指定位置写入数据</h3><p>向word模板的指定位置写入数据主要使用Word的书签和域，我这里使用的是书签，在word中想要插入数据的地方添加一个书签即可，如：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210326091009.png"></p><p>我想要在生产号、型号和图号后面的单元格写入数据，那么我只需要在这些单元中添加书签即可，添加书签的步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph LR;<br>将光标定位到要添加的书签的位置--&gt;插入--&gt;书签--&gt;添加一个书签名--&gt;添加<br></code></pre></td></tr></table></figure><p>添加完书签时候在word上是看不到的，但是把光标定位到书签所在的位置处，插入书签时会自定定位到所插入的书签名。</p><p>然后即可通过<font color="red"> Document.Replace(DocumentRange range,string text)</font>函数来向书签所在位置插入数据了，其中DocumentRange类型的参数需要通过<font color="red">Document.Bookmarks[string bookmarks].Range</font>来将字符串类型的书签标志转换为DocumentRange类型的可用书签标志。</p><p>如：我要在生产号、型号和图号后面的单元格写入数据，那么我需要分别在这些单元格中插入书签<code>sch</code>、<code>xh</code>、<code>th</code>，然后通过下面代码即可向word模板中写入数据</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#">RichEditControl richEdit = <span class="hljs-keyword">new</span> RichEditControl();<br>richEdit.LoadDocument(<span class="hljs-string">&quot;C:/a.doc&quot;</span>);<br>Document doc = rich.Document;<br>doc.Replace(doc.Bookmarks[<span class="hljs-string">&quot;sch&quot;</span>].Range,<span class="hljs-string">&quot;01&quot;</span>);<br>doc.Replace(doc.Bookmarks[<span class="hljs-string">&quot;xh&quot;</span>].Range,<span class="hljs-string">&quot;02&quot;</span>);<br>doc.Replace(doc.Bookmarks[<span class="hljs-string">&quot;th&quot;</span>].Range,<span class="hljs-string">&quot;03&quot;</span>);<br></code></pre></td></tr></table></figure><p>原理就是书签提供了一个占位符，而dev则通过搜索匹配的占位符，将指定数据替换掉占位符。</p><h3 id="3-向word模板中的表格插入新行并写入内容"><a href="#3-向word模板中的表格插入新行并写入内容" class="headerlink" title="3.向word模板中的表格插入新行并写入内容"></a>3.向word模板中的表格插入新行并写入内容</h3><p>向word模板中的表格插入新行则稍微复杂一些。主要步骤如下：</p><ul><li><p>首先word文档中要有一个模板表格</p></li><li><p>需要在要插入表的位置添加书签table</p></li><li><p>遍历word文档中所有的表再遍历每一个表中所有的单元格，查找到书签所在的单元格</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> TableCell <span class="hljs-title">GetTableCell</span>(<span class="hljs-params">Document document</span>) </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//遍历文档中所有的表</span><br>    <span class="hljs-keyword">foreach</span> (Table table <span class="hljs-keyword">in</span> document.Tables)<br>    &#123;<br>        <span class="hljs-built_in">int</span> row = <span class="hljs-number">0</span>, col = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">bool</span> ok = <span class="hljs-literal">false</span>;<br>        TableCell retCell = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">//遍历表格中所有的单元格</span><br>        table.ForEachCell((cell, rowIndex, columnIndex) =&gt;<br>                          &#123;<br>                              <span class="hljs-keyword">if</span> (cell.Range.Contains(document.Bookmarks[<span class="hljs-string">&quot;table&quot;</span>].Range.Start))<br>                              &#123;<br>                                  row = rowIndex;<br>                                  col = columnIndex;<br>                                  retCell = cell;<br>                                  ok = <span class="hljs-literal">true</span>;<br>                              &#125;<br>                          &#125;);<br>        <span class="hljs-keyword">if</span> (ok)<br>        &#123;<br>            <span class="hljs-keyword">return</span> retCell;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><font color="red">Table.ForEachCell(TableCellProcessorDelegate cellProcessor)</font>函数传入的是一个委托。这里使用的是匿名方法</p></li><li><p>在指定单元格后新增行</p><p>可以使用<font color="red">Document.Tables[int index].Rows.Append()</font>函数在表的最后追加行，或使用<font color="red"> Document.Tables[int index].Rows.InsertAfter(int rowIndex)</font>函数在指定行之后插入行。其中Document.Tables[int index].Rows.Append()中index（表的索引）可以通过<font color="red"> Document.Tables.IndexOf(Table table)</font>函数获取，而table又可以同通过上一步查找到的TableCell对象retCell.Table属性获取。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#">RichEditControl richEdit = <span class="hljs-keyword">new</span> RichEditControl();<br>richEdit.LoadDocument(<span class="hljs-string">&quot;C:/a.doc&quot;</span>);<br>Document doc = rich.Document;<br>TableCell cell = GetTableCell(doc);<br>doc.BeginUpdate();<br><span class="hljs-built_in">int</span> index = doc.Tables.IndexOf(cell.Table);<br>doc.Tables[index].Rows.Append();<span class="hljs-comment">//或者</span><br><span class="hljs-comment">//doc.Table[index].Rows.InsertAfter(cell.Row.Index - 1);</span><br><span class="hljs-comment">//获取指定单元格的占位符范围</span><br>DocumentRange range = doc.Tables[index].Rows[cell.Row.Index].Cells[cell.Index].ContentRange;<br>doc.Replace()<br>doc.EndUpdate();<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dev</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【日记】在衡变的日子</title>
    <link href="/2021/02/02/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E8%A1%A1%E5%8F%98%E7%9A%84%E6%97%A5%E5%AD%90/"/>
    <url>/2021/02/02/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E8%A1%A1%E5%8F%98%E7%9A%84%E6%97%A5%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3 id="encrypt-message">这里不可以看哦！</h3><link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"> <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css"> <script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <script src="//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js"></script> <div id="security"> <div> <div class="input-group"> <input type="text" class="form-control" aria-label="Enter the password." id="pass"/> <div class="input-group-btn"> <button type="button" class="btn btn-default" onclick="decryptAES()">Decrypt</button> </div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
    
    
    <categories>
      
      <category>日记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大事件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE4】UE4联级粒子系统</title>
    <link href="/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <url>/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="一、粒子系统的一些基本概念"><a href="#一、粒子系统的一些基本概念" class="headerlink" title="一、粒子系统的一些基本概念"></a>一、粒子系统的一些基本概念</h1><h2 id="1-Particle-System-粒子系统"><a href="#1-Particle-System-粒子系统" class="headerlink" title="1.Particle System(粒子系统)"></a>1.Particle System(粒子系统)</h2><p>粒子系统如同贴图、模型一样属于UE4的驻留资产，不能单独存在于场景中，必须使用载体依托才能在场景中渲染出来，粒子系统包含粒子特效的所有配置。粒子系统在UE4中表现为如下样子：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224655.png"></p><h3 id="创建粒子系统"><a href="#创建粒子系统" class="headerlink" title="创建粒子系统"></a>创建粒子系统</h3><p>在内容浏览器中右键选择Particle System可以直接创建粒子系统。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224659.png"></p><h2 id="2-Emitter-Actor-粒子发射器"><a href="#2-Emitter-Actor-粒子发射器" class="headerlink" title="2.Emitter Actor(粒子发射器)"></a>2.Emitter Actor(粒子发射器)</h2><p>粒子发射器就是粒子系统的载体，粒子发射器承载粒子系统确定粒子系统在场景中的位置坐标等信息。但是似乎UE4没办法直接创建空的粒子发射器，UE4的粒子发射器在将粒子系统拖入场景中时，UE4会自动为该粒子系统创建一个粒子发射器。</p><h2 id="3-Particle-System-Component-粒子系统组件"><a href="#3-Particle-System-Component-粒子系统组件" class="headerlink" title="3.Particle System Component(粒子系统组件)"></a>3.Particle System Component(粒子系统组件)</h2><p>粒子系统组件是一个包含了粒子系统的蓝图，粒子系统组件可以使用代码逻辑来控制粒子系统。</p><h1 id="二、Cascade-粒子编辑器"><a href="#二、Cascade-粒子编辑器" class="headerlink" title="二、Cascade(粒子编辑器)"></a>二、Cascade(粒子编辑器)</h1><p>粒子系统的核心就是粒子编辑器，在粒子编辑器里我们可以创造出琳琅满目的粒子特效。</p><p>粒子编辑器包含Toolbar、Emitters、Details、Viewport和Curve Editor等视图。</p><h2 id="1-ToolBar-工具栏"><a href="#1-ToolBar-工具栏" class="headerlink" title="1.ToolBar(工具栏)"></a>1.ToolBar(工具栏)</h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224706.png"></p><h2 id="2-Emitters"><a href="#2-Emitters" class="headerlink" title="2.Emitters"></a>2.Emitters</h2><p>Emitters是用于控制粒子属性的视图，Emitters的基本组成单元就是Emitter(发射器)，这里的Emitter和前面提到的Emitter Actor有一些差异，二者都是粒子发射器，但是Emitter是属于粒子系统内部的发射器，主要用于对粒子系统的某一部分的粒子发射，如爆炸的粒子特效中可以由烟、火光和火花等粒子部分组成，Emitter就是用于发射这些粒子部分的发射器，而Emitter Actor则是用于发射整个粒子系统的发射器。</p><h2 id="3-Emitter-发射器"><a href="#3-Emitter-发射器" class="headerlink" title="3.Emitter(发射器)"></a>3.Emitter(发射器)</h2><p>在Emitters视图中每一列就是一个Emitter，一个Emitter控制一个粒子部分。一个Emitter拥有Required和Spawn两个固有组成模块，即每个Emitter被创建出来就拥有Required和Spawn模块，且这两个模块不能删除。</p><p>Emitter的执行顺序是自左而右的。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224709.png"></p><h3 id="创建Emitter"><a href="#创建Emitter" class="headerlink" title="创建Emitter"></a>创建Emitter</h3><p>直接在Emitters视图的空白出右键选择New Particle Sprite Emitter即可。</p><h3 id="赋值Emitter"><a href="#赋值Emitter" class="headerlink" title="赋值Emitter"></a>赋值Emitter</h3><p>选中需要复制的Emitter右键/Emiter/Duplicate Emitter即可。</p><h3 id="删除Emitter"><a href="#删除Emitter" class="headerlink" title="删除Emitter"></a>删除Emitter</h3><p>选中需要删除的Emitter右键/Emitter/Delete Emitter，或直接按delete键。</p><h2 id="4-Emitter的分类"><a href="#4-Emitter的分类" class="headerlink" title="4.Emitter的分类"></a>4.Emitter的分类</h2><p>直接创建的Emitter默认为普通Emitter即没有任何特殊属性的Emitter，要创建具有特殊属性的特殊的Emitter需要修改Emitter的TypeData属性，右键/TypeData选择需要的类型即可修改Emitter的类型。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224713.png"></p><h3 id="AnimTrail-Data"><a href="#AnimTrail-Data" class="headerlink" title="AnimTrail Data"></a>AnimTrail Data</h3><p>骨骼动画发射器，AnimTrail可以使粒子跟随人物骨骼运动而运动，如下图的跟随人物手臂运动的彩虹带</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224716.png"></p><p>AnimTrail是配合UE4的动画系统一起使用的，使用AnimTrail我们需要选择一段动画片段如下图</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224721.png"></p><p>发射器会在选定的时间片段内发射粒子，在右侧的Trail栏中选定粒子需要跟随的骨骼和骨骼需要绑定的粒子系统，就可以使粒子跟随着骨骼运动了。</p><h3 id="Beam-Data"><a href="#Beam-Data" class="headerlink" title="Beam Data"></a>Beam Data</h3><p>光束发射器，Beam有一个源点和一个目标点，粒子由源点发射运动到目标点销毁，Beam在粒子由源点运动到目标点的过程中可以设置粒子抖动，使粒子的运动具有抖动效果，如下图的闪电。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224725.png"></p><p>Beam拥有一个专属Module–Beam，在这个模块里可以为Beam添加Source(源点)、Target(目标点)和Noise(噪声)，Noise就是控制粒子抖动的Module，要想粒子出现抖动有几点是必须要做的，即勾选Noise模块的Low Freq/Low Freq Enabled、设置Frequency(噪声点的频率，影响粒子抖动的平滑程度)；Source和Target模块的Suorce Tangent/Distribution/Constant和Target Tangent/Distribution/Constant(影响源点到目标点的粒子抖动的曲率)，要想这两个设置起作用还必须设置Source/Source Tangent Method为User Set，目标点也是一样的设置；还有一点就是要想粒子从源点向目标点运动还需要设置Beam Data模块的Beam/Beam Method为Target。</p><h3 id="GPU-Sprites"><a href="#GPU-Sprites" class="headerlink" title="GPU Sprites"></a>GPU Sprites</h3><p>GPU Sprites是普通粒子的加强版，可以使粒子具有更完美的物理效果，但当对于普通粒子发射器来说更消耗GPU性能。</p><p><strong>矢量场：</strong></p><p>矢量场是GPU粒子独有的属性，GPU粒子在矢量成的控制下可以作出任意轨迹运用，如：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224729.png"></p><p>矢量场有多个属性控制模块</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224733.png"></p><p>矢量场默认是看不见的，我们需要在Viewport里勾选View/Vector Fields，使矢量场可见。</p><h3 id="Mesh-Data"><a href="#Mesh-Data" class="headerlink" title="Mesh Data"></a>Mesh Data</h3><p>网格发射器，Mesh可以使粒子使用模型网格，这样发射出来的粒子就是一个个具体的模型，如下图所示。</p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224735.png" style="zoom:50%;"><h3 id="Ribbon-Data"><a href="#Ribbon-Data" class="headerlink" title="Ribbon Data"></a>Ribbon Data</h3><p>光带发射器，Ribbon可以记录粒子的运行轨迹，并可以对其属性进行编辑，如下图使用粒子运行轨迹制作的光带。</p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224739.png" style="zoom:50%;"><p>Ribbon的粒子生成模块不是使用Spawn，而是Spawn PerUnit，由于Spawn是Emitter的固有Module所以无法移除，我们要启用Spawn PerUnit则需要将Spawn Module的Spawn/Distribution/Constant设置为0，达到间接禁用Spawn的效果。这样彩带粒子就是用Spawn PerUnit生成粒子了，想要彩带粒子跟随其他粒子运动我们还需要一个Module–Trail/Source，将Source Module里的Source/Source Mothod设置为PET2SRCM Particle，并且Source Name设置为需要跟随粒子部分的Emitter的名字，这样就可以产生一个跟随其他粒子的彩带了，当然这个彩带粒子是需要设置贴图的，否则尽管生成了，但是却没有渲染。</p><h2 id="4-Module-模块"><a href="#4-Module-模块" class="headerlink" title="4.Module(模块)"></a>4.Module(模块)</h2><p>模块用于控制粒子某一方面的属性，在Emitter中每一行就是一个Module，Module的种类很多，这里只列举自己使用过的Module。</p><p>UE4Module的执行顺序是自上而下的所以当一个Emitter中有两个相同的Module时，下面的Module会覆盖上面的Module。</p><h3 id="添加Module"><a href="#添加Module" class="headerlink" title="添加Module"></a>添加Module</h3><p>选中需要添加Module的Emitter，右键选择需要的Module即可</p><h3 id="移除Module"><a href="#移除Module" class="headerlink" title="移除Module"></a>移除Module</h3><p>选中需要移除的Module右键/Delete Module，或直接按Delete键。</p><h3 id="拷贝Module"><a href="#拷贝Module" class="headerlink" title="拷贝Module"></a>拷贝Module</h3><p>Shift+拖动即可拷贝一个Module到另一个Emitter中。</p><h3 id="Required"><a href="#Required" class="headerlink" title="Required"></a>Required</h3><p>Required控制粒子的显示方面的属性，如粒子贴图，显示模式等。</p><ul><li>Sub UV栏控制贴图的逐帧融合。</li></ul><h3 id="Spawn"><a href="#Spawn" class="headerlink" title="Spawn"></a>Spawn</h3><p>Spawn控制粒子的发射方面的属性，如粒子发射量，发射模式等。</p><ul><li>Spawn栏控制粒子持续性的发射；</li><li>Burst栏控制粒子间歇性的爆炸发射。</li></ul><h3 id="LifeTime"><a href="#LifeTime" class="headerlink" title="LifeTime"></a>LifeTime</h3><p>LifeTime控制粒子的声明周期方面的属性。</p><h3 id="Initial-Size"><a href="#Initial-Size" class="headerlink" title="Initial Size"></a>Initial Size</h3><p>Initial Size控制粒子初始尺寸方面的属性。</p><h3 id="Initial-Velocity"><a href="#Initial-Velocity" class="headerlink" title="Initial Velocity"></a>Initial Velocity</h3><p>Initial Velocity控制粒子初始速度方面的属性。</p><h3 id="Color-Over-Life"><a href="#Color-Over-Life" class="headerlink" title="Color Over Life"></a>Color Over Life</h3><p>Color Over Life控制粒子生命周期内的颜色变化方面的属性。</p><p>生命周期的初始颜色是Color Over Life/Distribution/Constant Curve/Points/0/Out Val，</p><p>生命周期的结束颜色是Color Over Life/Distribution/Constant Curve/Points/1/Out Val。</p><h3 id="Initial-Location"><a href="#Initial-Location" class="headerlink" title="Initial Location"></a>Initial Location</h3><p>Initial Location控制粒子发射的初始位置方面的属性，通过Start Location/Distribution/Max和Min可以控制粒子发射时的位置分布，如Max，Min都为0时粒子只从一个点发射出来，当设置了值，粒子会在设置的范围内随机发射出来。</p><h3 id="Const-Acceleration"><a href="#Const-Acceleration" class="headerlink" title="Const Acceleration"></a>Const Acceleration</h3><p>Const Acceleration控制粒子的运动的加速度。</p><h3 id="Size-By-Speed"><a href="#Size-By-Speed" class="headerlink" title="Size By Speed"></a>Size By Speed</h3><p>Size By Speed控制粒子的尺寸随速度的变化，要想粒子的尺寸可以随速度变化需要将Required模块的Emitter/Screen Alignment设置为PSA Velocity。</p><h3 id="Light"><a href="#Light" class="headerlink" title="Light"></a>Light</h3><p>Light控制粒子发光，但是似乎只有发生碰撞之后才会发光。</p><h3 id="Actor-Collision"><a href="#Actor-Collision" class="headerlink" title="Actor Collision"></a>Actor Collision</h3><p>Actor Collision控制粒子的物理碰撞。</p><h3 id="Orbit"><a href="#Orbit" class="headerlink" title="Orbit"></a>Orbit</h3><p>Obirt控制粒子的随机运动。</p><h1 id="三、LOD-细节层次"><a href="#三、LOD-细节层次" class="headerlink" title="三、LOD(细节层次)"></a>三、LOD(细节层次)</h1><p>默认情况下任何创建出来的粒子系统默认为LOD0等级的细节层次，我们可以在Toolbar中的Add LOD添加细节层次，在LOD中切换细节层次。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224746.png"></p><p>Details/LOD栏可以设置LOD切换与距离的关系，可以在不同的细节层次下修改Emitter不会对其他的细节层次产生影响，这样就可以很精确的控制各个细节层次了。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE4】UE4组件</title>
    <link href="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/"/>
    <url>/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>不同的蓝图脚本拥有不同的组件集，蓝图脚本的组件集过于庞大，这里只对自己使用过的组件进行列举。</p><p><font color="red">说明：红色字体表示一级目录组件，绿色字体表示二级目录，黄色字体为三级目录(三级目录较为少见所以使用和二级目录相同的三级标题)，白色字体为具体组件说明</font>。</p><h1 id="一、材质蓝图组件"><a href="#一、材质蓝图组件" class="headerlink" title="一、材质蓝图组件"></a>一、材质蓝图组件</h1><h2 id="Constans-常量"><a href="#Constans-常量" class="headerlink" title="Constans(常量)"></a><font color="red">Constans(常量)</font></h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224830.png"></p><table><thead><tr><th>组件</th><th>作用</th></tr></thead><tbody><tr><td>Constans</td><td>一维量，可以表示任何一维数据，如：小数、整数等</td></tr><tr><td>Constans2Vector</td><td>二维量，可以表示任何二维数据，如：二维坐标</td></tr><tr><td>Constans3Vector</td><td>三维量，可以表示任何三维数据，如：三维坐标、RBG等</td></tr><tr><td>Constans4Vector</td><td>四维量，可以表示任何四维数据，如：四元数</td></tr></tbody></table><h2 id="Math-数学函数"><a href="#Math-数学函数" class="headerlink" title="Math(数学函数)"></a><font color="red">Math(数学函数)</font></h2><h4 id="Multiply-乘积"><a href="#Multiply-乘积" class="headerlink" title="Multiply(乘积)"></a><strong>Multiply(乘积)</strong></h4><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224834.png"></p><h3 id="Lerp-插值"><a href="#Lerp-插值" class="headerlink" title="Lerp(插值)"></a><font color="green">Lerp(插值)</font></h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224837.png"></p><p>Lerp组件在Math的多个二级目录中存在，有各种类型的插值变化。</p><p><strong>输入：</strong></p><ul><li>A：插值变化的起始值；</li><li>B：插值变化的目标值；</li><li>Alpha：插值的变化规则，连接Float的TimeLine插值将按照TimeLine的规则变化。</li></ul><p><strong>输出：</strong></p><ul><li>Return Value：返回变化后的插值，将Lerp放入帧函数中可以获得每帧变化的插值。</li></ul><h1 id="二、普通蓝图组件"><a href="#二、普通蓝图组件" class="headerlink" title="二、普通蓝图组件"></a>二、普通蓝图组件</h1><hr><h2 id="Add-TimeLine-添加时间线"><a href="#Add-TimeLine-添加时间线" class="headerlink" title="Add TimeLine(添加时间线)"></a><font color="red">Add TimeLine(添加时间线)</font></h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224840.png"></p><p><strong>输入：</strong></p><ul><li>Play：播放，播放完毕下一次触发时不会从头开始，而是会从上一次时间点继续开始；</li><li>Play from Start：从头开始播放，每次触发都从时间线起点开始执行；</li><li>Stop：暂停，触发后直接从当前时刻暂停；</li><li>Reverse：倒序播放，从当前时刻开始倒叙播放；</li><li>Reverse from End：从末尾开始倒序播放；</li><li>Set New Time：设置新的时间起点，即时间线从新设置的时间点开始执行；</li><li>New Time：新的时间起点由外部输入。</li></ul><p><strong>输出：</strong></p><ul><li>Update：在时间线内每帧执行；</li><li>Finished：时间线结束时触发；</li><li>Direction：返回时间线的执行方向，只有两个值“Forward”和“Backward”；</li><li>New Track 0：自己创建的时间线，创建了才会有，显示的名字也是自己命名的时间线的名字。</li></ul><h2 id="Add-Event-添加事件"><a href="#Add-Event-添加事件" class="headerlink" title="Add Event(添加事件)"></a><font color="red">Add Event(添加事件)</font></h2><h3 id="Collision-碰撞体组件"><a href="#Collision-碰撞体组件" class="headerlink" title="Collision(碰撞体组件)"></a><font color="green">Collision(碰撞体组件)</font></h3><h4 id="Event-ActorBeginOverlap-自动触发触发器"><a href="#Event-ActorBeginOverlap-自动触发触发器" class="headerlink" title="Event ActorBeginOverlap(自动触发触发器)"></a><strong>Event ActorBeginOverlap(自动触发触发器)</strong></h4><p>每当有物体进入触发器时自动触发</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224844.png"></p><ul><li>Other Actor：返回进入触发器的游戏物体的信息。</li></ul><h3 id="Game"><a href="#Game" class="headerlink" title="Game"></a><font color="green">Game</font></h3><h3 id="Damage"><a href="#Damage" class="headerlink" title="Damage"></a><font color="orange">Damage</font></h3><h4 id="Event-AnyDamage"><a href="#Event-AnyDamage" class="headerlink" title="Event AnyDamage"></a><strong>Event AnyDamage</strong></h4><p>Event AnyDamage事件是配合Apply Damage组件一起使用的，当Apply Damage组件执行时，会自动触发Event AnyDamage事件。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224847.png"></p><p><strong>输出：</strong></p><ul><li><p>Damage：从Apply Damage组件的Damage中传递过来的值；</p></li><li><p>Damage Type：从Apply Damage组件传递过来的Damage Type Class；</p></li><li><p>Instigated By：从Apply Damage组件传递过来的Event Instigateor；</p></li><li><p>Damage Causer：从Apply Damage组件传递过来的Damage Causer；</p></li></ul><h2 id="Camera-Fades-相机渐变"><a href="#Camera-Fades-相机渐变" class="headerlink" title="Camera Fades(相机渐变)"></a><font color="red">Camera Fades(相机渐变)</font></h2><p>Camera Fades组件是只有在Get Player Camera Menager组件的外拉中才能搜索到的专门服务于Get Player Camera Menager组件的相机组件集。</p><h4 id="Start-Camera-Fade-开始渐变"><a href="#Start-Camera-Fade-开始渐变" class="headerlink" title="Start Camera Fade(开始渐变)"></a><strong>Start Camera Fade(开始渐变)</strong></h4><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224850.png"></p><ul><li>Target：渐变目标相机，默认为当前相机；</li><li>From Alpha：渐变起始Alpha；</li><li>To Alpha：渐变目标Alpha；</li><li>Duration：渐变持续时间；</li><li>Color：渐变颜色；</li><li>Should Fade Audio：启用声音渐变；</li><li>Hold when Finished：渐变结束后保持当前Alpha值。</li></ul><h4 id="Stop-Camera-Fade-结束渐变"><a href="#Stop-Camera-Fade-结束渐变" class="headerlink" title="Stop Camera Fade(结束渐变)"></a><strong>Stop Camera Fade(结束渐变)</strong></h4><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224853.png"></p><p>触发时立刻停止当前渐变。</p><h2 id="Event-BeginPlay"><a href="#Event-BeginPlay" class="headerlink" title="Event BeginPlay"></a><font color="red">Event BeginPlay</font></h2><p>游戏开始时自动触发</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224857.png"></p><h2 id="Execute-Console-Command-执行控制台命令"><a href="#Execute-Console-Command-执行控制台命令" class="headerlink" title="Execute Console Command(执行控制台命令)"></a><font color="red">Execute Console Command(执行控制台命令)</font></h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224900.png"></p><ul><li>Command：控制台命令字符串</li><li>Specific Player：执行控制台命令的执行器，默认为当前GameMode指定的Player</li></ul><h3 id="常见控制台命令"><a href="#常见控制台命令" class="headerlink" title="常见控制台命令"></a><font color="green">常见控制台命令</font></h3><ul><li><p>start fps：显示帧率</p></li><li><p>start unit：显示性能调试信息</p></li><li><p>start rhi：显示GPU上的消耗细则</p><p><a href="https://docs.unrealengine.com/zh-CN/TestingAndOptimization/PerformanceAndProfiling/StatCommands/index.html">更多start命令</a></p></li><li><p>r.MobileContentScaleFactor 0：控制内容在移动设备中的缩放方式，0表示使用设备原始分辨率，如将DPI缩放曲线用于UI缩放，必须设为0</p></li><li><p>DisableAllScreenMessages：禁用所有在运行中的屏幕提示</p></li></ul><h2 id="Input-输入流"><a href="#Input-输入流" class="headerlink" title="Input(输入流)"></a><font color="red">Input(输入流)</font></h2><h3 id="Keyboard-Events-按键触发事件"><a href="#Keyboard-Events-按键触发事件" class="headerlink" title="Keyboard Events(按键触发事件)"></a><font color="green">Keyboard Events(按键触发事件)</font></h3><p>包含所有键盘按键出发事件</p><h2 id="Game-1"><a href="#Game-1" class="headerlink" title="Game"></a><font color="red">Game</font></h2><h4 id="Get-Player-Pawn-获取角色对象"><a href="#Get-Player-Pawn-获取角色对象" class="headerlink" title="Get Player Pawn(获取角色对象)"></a><strong>Get Player Pawn(获取角色对象)</strong></h4><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224905.png"></p><ul><li><p>Play Index：输入角色索引，可以直接设置也可以外部输入；</p></li><li><p>Return Value：返回获取的角色对象(Object)。</p></li></ul><h4 id="Get-Current-Level-Name-获取关卡名字"><a href="#Get-Current-Level-Name-获取关卡名字" class="headerlink" title="Get Current Level Name(获取关卡名字)"></a><strong>Get Current Level Name(获取关卡名字)</strong></h4><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224909.png"></p><ul><li>Remove Prefix String：移除前缀字符串；</li><li>Return Value：返回获取到的关卡名称(String)。</li></ul><h4 id="Get-Player-Camera-Manager-获取角色相机管理器"><a href="#Get-Player-Camera-Manager-获取角色相机管理器" class="headerlink" title="Get Player Camera Manager(获取角色相机管理器)"></a><strong>Get Player Camera Manager(获取角色相机管理器)</strong></h4><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224916.png"></p><ul><li>Player Index：输入角色索引；</li><li>Return Value：返回输入角色身上的相机对象。</li></ul><h3 id="Damage-1"><a href="#Damage-1" class="headerlink" title="Damage"></a><font color="green">Damage</font></h3><h4 id="Apply-Damage"><a href="#Apply-Damage" class="headerlink" title="Apply Damage"></a><strong>Apply Damage</strong></h4><p>Apply Damage组件一般和Event AnyDamage组件配合使用，当Apply Damage组件触发时，UE4会自动调用Event AnyDamage事件。需要注意的是，只有在Base Daamge不为0时才能触发Event Damage事件。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224919.png"></p><p><strong>输入：</strong></p><ul><li><p>Ddamaged Actor：受到伤害的对象；</p></li><li><p>Base Damage：输入的伤害值；</p></li><li><p>Event Instigator：引发伤害的对象，如：持枪的敌人；</p></li><li><p>Damage Causer：实际造成伤害的对象，如：子弹；</p></li><li><p>Damage Type Class：伤害的类型；</p></li></ul><p><strong>输出：</strong></p><p>Return Value：最终造成的实际伤害。</p><h3 id="Player-Controller-角色控制器组件"><a href="#Player-Controller-角色控制器组件" class="headerlink" title="Player Controller(角色控制器组件)"></a><font color="green">Player Controller(角色控制器组件)</font></h3><h3 id="Set-View-Target-With-Blend-相机线性移动"><a href="#Set-View-Target-With-Blend-相机线性移动" class="headerlink" title="Set View Target With Blend(相机线性移动)"></a>Set View Target With Blend(相机线性移动)</h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224923.png"></p><ul><li>Target：目标是PlayerController</li><li>New View Target：相机需要移动到的目的点</li><li>Blend Time：相机聚焦过程所需时间</li><li>Blend Func：聚焦方式</li><li>Blend Exp：控制曲线形状的指数，（实测中好像也没什么效果）</li><li>Lock Outgoing：为true时锁定视角移动，false则相机会转向</li></ul><h2 id="Rendering-渲染"><a href="#Rendering-渲染" class="headerlink" title="Rendering(渲染)"></a><font color="red">Rendering(渲染)</font></h2><h3 id="Components"><a href="#Components" class="headerlink" title="Components"></a><font color="green">Components</font></h3><h3 id="Light"><a href="#Light" class="headerlink" title=" Light"></a><font color="orange"> Light</font></h3><h4 id="Set-Intensity-设置光源强度"><a href="#Set-Intensity-设置光源强度" class="headerlink" title="Set Intensity(设置光源强度)"></a><strong>Set Intensity(设置光源强度)</strong></h4><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224927.png"></p><ul><li>Target：目标光源；</li><li>New Intensity：目标光源强度。</li></ul><h4 id="Get-Intensity-获取光源强度"><a href="#Get-Intensity-获取光源强度" class="headerlink" title="Get Intensity(获取光源强度)"></a><strong>Get Intensity(获取光源强度)</strong></h4><p>使用和Set Intensity一样。</p><h2 id="String-字符串组件"><a href="#String-字符串组件" class="headerlink" title="String(字符串组件)"></a><font color="red">String(字符串组件)</font></h2><h3 id="Append-字符串连接"><a href="#Append-字符串连接" class="headerlink" title="Append(字符串连接)"></a><font color="green">Append(字符串连接)</font></h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224931.png"></p><h3 id="Switch-On-String-字符串匹配"><a href="#Switch-On-String-字符串匹配" class="headerlink" title="Switch On String(字符串匹配)"></a><font color="green">Switch On String(字符串匹配)</font></h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224933.png"></p><ul><li>Selection：输入字符串</li><li>Default：默认输出端口</li><li>Add pin：添加匹配端口</li></ul><h2 id="Utilities-通用组件"><a href="#Utilities-通用组件" class="headerlink" title="Utilities(通用组件)"></a><font color="red">Utilities(通用组件)</font></h2><h3 id="Flow-Control"><a href="#Flow-Control" class="headerlink" title="Flow Control"></a><font color="green">Flow Control</font></h3><h4 id="Branch-if语句"><a href="#Branch-if语句" class="headerlink" title="Branch(if语句)"></a>Branch(if语句)</h4><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224936.png"></p><p>蓝图的if语句</p><ul><li>Condition：输入的判断条件，一般和各种判断组件的输出连接。</li></ul><h4 id="Delay-延迟函数"><a href="#Delay-延迟函数" class="headerlink" title="Delay(延迟函数)"></a>Delay(延迟函数)</h4><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224939.png"></p><ul><li>Duration：延迟时间。</li></ul><h3 id="Keyboard-Events-按键触发事件-1"><a href="#Keyboard-Events-按键触发事件-1" class="headerlink" title="Keyboard Events(按键触发事件)"></a><font color="green">Keyboard Events(按键触发事件)</font></h3><p>包含一些字符串操作函数。</p><h3 id="Text"><a href="#Text" class="headerlink" title="Text"></a><font color="green">Text</font></h3><h4 id="Equal"><a href="#Equal" class="headerlink" title="Equal"></a>Equal</h4><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224942.png"></p><p>输入两个比较对象，输出判断结果(Bool)。</p><p>各种其他的判断组件用法一致。</p><h3 id="Transformation"><a href="#Transformation" class="headerlink" title=" Transformation"></a><font color="green"> Transformation</font></h3><h4 id="Set-Actor-Scale-3D"><a href="#Set-Actor-Scale-3D" class="headerlink" title="Set Actor Scale 3D"></a>Set Actor Scale 3D</h4><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224945.png"></p><p>设置Actor的Scale值</p><ul><li>Target：要设置的目标Actor；</li><li>New Scale 3D：要设置的目标Scale值。</li></ul><h4 id="Get-Actor-Scale-3D"><a href="#Get-Actor-Scale-3D" class="headerlink" title="Get Actor Scale 3D"></a>Get Actor Scale 3D</h4><p>获取Actor的Scale值。</p><h4 id="Set-Timer-By-Function-Name"><a href="#Set-Timer-By-Function-Name" class="headerlink" title="Set Timer By Function Name"></a>Set Timer By Function Name</h4><p>节点：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224947.png"></p><p>描述：通过函数名定时调用函数</p><p>输入：</p><ul><li>Object：调用函数所在蓝图，默认为节点所在蓝图</li><li>Function Name：要调用的函数的名字</li><li>Time：定时调用时间间隔</li><li>Looping：是否循环调用</li></ul><p>输出：</p><ul><li>一个Timer Handle结构体，记录了一些函数调用的信息</li></ul><p><strong>关联节点：</strong></p><h4 id="Pause-Timer-By-Function-Name"><a href="#Pause-Timer-By-Function-Name" class="headerlink" title="Pause Timer By Function Name"></a>Pause Timer By Function Name</h4><p>节点：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224951.png"></p><p>描述：暂停有Set Timer By Function Name节点启用的函数定时调用过程</p><p>输入：与Set Timer By Function Name类似</p><h4 id="Unpause-Timer-By-Function-Name"><a href="#Unpause-Timer-By-Function-Name" class="headerlink" title="Unpause Timer By Function Name"></a>Unpause Timer By Function Name</h4><p>节点：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224954.png"></p><p>描述：取消Pause Timer By Function Name的效果，继续Set Timer By Function Name的函数定时调用</p><h4 id="Clear-Timer-By-Function-Name"><a href="#Clear-Timer-By-Function-Name" class="headerlink" title="Clear Timer By Function Name"></a>Clear Timer By Function Name</h4><p>节点：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224957.png"></p><p>描述：清除Set Timer By Function Name的定时调用设置</p><h4 id="Set-Timer-By-Event"><a href="#Set-Timer-By-Event" class="headerlink" title="Set Timer By Event"></a>Set Timer By Event</h4><p>节点：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811225001.png"></p><p>描述：设置定时调用事件，与Set Timer By Function Name不同Set Timer By Evnet没有对应的Pause和Unpause节点，且Set Timer By Event只能调用所在蓝图的事件</p><p>输入：</p><ul><li>Evnet：绑定需要调用的蓝图事件</li><li>Time：定时调用的时间间隔</li><li>Looping：是否循环调用</li></ul><h4 id="Puase-Timer-By-Handle"><a href="#Puase-Timer-By-Handle" class="headerlink" title="Puase Timer By Handle"></a>Puase Timer By Handle</h4><p>节点：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811225005.png"></p><p>描述：通过Set Timer By Function Name和Set Timer By Evnet的Timer Handle返回值来控制调用流程，暂停函数调用</p><p>输入：</p><ul><li>Handle：Timer Handle结构体，输入Set Timer By Function Name和Set Timer By Evnet的返回值</li></ul><h4 id="Upause-Timer-By-Handle"><a href="#Upause-Timer-By-Handle" class="headerlink" title="Upause Timer By Handle"></a>Upause Timer By Handle</h4><p>节点：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811225009.png"></p><p>描述：清除Pause Timer By Handle的暂定效果继续Set Timer By Function或Set Timer By Event的定时效果</p><h4 id="Clear-And-Invalidate-Timer-By-Handle"><a href="#Clear-And-Invalidate-Timer-By-Handle" class="headerlink" title="Clear And Invalidate Timer By Handle"></a>Clear And Invalidate Timer By Handle</h4><p>节点：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811225012.png"></p><p>描述：通过Timer Handle值清除Set Timer By Function Name和Set Timer By Event的定时调用设置</p><h1 id="三、物理组件"><a href="#三、物理组件" class="headerlink" title="三、物理组件"></a>三、物理组件</h1><p>UE4除了提供大量蓝图脚本函数组件来对蓝图类进行精细控制外还提供了一系列物理组件对蓝图类进行一些常规的复杂控制。</p><h2 id="Camera"><a href="#Camera" class="headerlink" title="Camera"></a><font color="red">Camera</font></h2><h4 id="Camera-1"><a href="#Camera-1" class="headerlink" title="Camera"></a><strong>Camera</strong></h4><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811225027.png"></p><p>相机，用于渲染视野，一般配合Spring Arm一起使用。</p><h4 id="Spring-Arm"><a href="#Spring-Arm" class="headerlink" title="Spring Arm"></a><strong>Spring Arm</strong></h4><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811225031.png"></p><p>弹簧悬臂，将相机附于其上可以实现相机跟随</p><h2 id="Movement"><a href="#Movement" class="headerlink" title="Movement"></a><font color="red">Movement</font></h2><h4 id="Rotating-Movement"><a href="#Rotating-Movement" class="headerlink" title="Rotating Movement"></a><strong>Rotating Movement</strong></h4><p>旋转控制，提供一系列参数对对蓝图类的旋转运动进行控制</p><h2 id="Rendering"><a href="#Rendering" class="headerlink" title="Rendering"></a><font color="red">Rendering</font></h2><h4 id="Static-Mesh"><a href="#Static-Mesh" class="headerlink" title="Static Mesh"></a><strong>Static Mesh</strong></h4><p>静态网格，网格控制蓝图的贴图材质、模型外观、阴影渲染等。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE4】UE4连接MySQL</title>
    <link href="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%BF%9E%E6%8E%A5MySQL/"/>
    <url>/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%BF%9E%E6%8E%A5MySQL/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="使用MySQLIntegration插件连接Mysql"><a href="#使用MySQLIntegration插件连接Mysql" class="headerlink" title="使用MySQLIntegration插件连接Mysql"></a>使用MySQLIntegration插件连接Mysql</h1><ul><li>Update Data from Query Async组件后面必须再跟一个其他的节点，节点才能正常执行</li><li>UE4 C++编程中不能出现私有私有变量？</li><li>UE4 C++静态变量？</li><li>MySQL Integration插件只支持sql语句，不支持存储过程</li><li>在蓝图中实现的C++函数在蓝图中没法使用？</li><li>暴露给蓝图的变量和函数必须是公有且非静态的</li><li>UE4 C++类创建对象，大象无形31页</li><li>UE4 C++编程中if else语句必须加{}</li></ul><h2 id="1-MySQL-Integration安装"><a href="#1-MySQL-Integration安装" class="headerlink" title="1.MySQL Integration安装"></a>1.MySQL Integration安装</h2><p>MySQL Integration插件可以直接在UE4商城中搜索到，直接下载安装即可，如何是从外部导入的离线包，直接将插件文件夹丢入UE4安装目录下的Engine\Plugins文件夹下即可。</p><h2 id="2-激活MySQL-Integration"><a href="#2-激活MySQL-Integration" class="headerlink" title="2.激活MySQL Integration"></a>2.激活MySQL Integration</h2><p>激活插件直接在UE4中的Edit/Plugins/Installed下找到MySQL Integration勾选Enabled即可，勾选插件之后UE4会提示需要重启UE4才可激活，重启软件就可以激活插件了。</p><h2 id="3-MySQL-Integration提供的蓝图组件"><a href="#3-MySQL-Integration提供的蓝图组件" class="headerlink" title="3.MySQL Integration提供的蓝图组件"></a>3.MySQL Integration提供的蓝图组件</h2><p>官方文档： <a href="https://sameek4.github.io/KodeSpire/Pages/MySQLIntegration.html">https://sameek4.github.io/KodeSpire/Pages/MySQLIntegration.html</a> </p><h3 id="Set-Connection-Properties-Mysql连接"><a href="#Set-Connection-Properties-Mysql连接" class="headerlink" title="Set Connection Properties(Mysql连接)"></a>Set Connection Properties(Mysql连接)</h3><p>Set Connection Properties组件提供UE4对Mysql的连接服务。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224542.png"></p><p><strong>输入：</strong></p><ul><li>server：数据库的连接ip；</li><li>DBName：数据库的名字；</li><li>User ID：登录数据库用户名；</li><li>Password：登录数据库的用户密码；</li><li>Extra Param：SetConnectionProperties提供的额外参数传入；</li><li>Is Trusted：启用windows用户名和密码登录数据库。</li></ul><h3 id="Check-Connection-State-Mysql连接状态检查"><a href="#Check-Connection-State-Mysql连接状态检查" class="headerlink" title="Check  Connection State(Mysql连接状态检查)"></a>Check  Connection State(Mysql连接状态检查)</h3><p>此组件提供对Mysql连接的状态的查询服务。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224546.png"></p><p><strong>输出：</strong></p><ul><li><p>Error Message：输出错误信息；</p></li><li><p>Return Value：输出连接状态；</p><p>包含如下状态值(类型为插件定义的EMysqlConnectionStateEnum枚举)：</p><ul><li>Broken：数据库损坏；</li><li>Closed：连接关闭；</li><li>connecting：正在连接；</li><li>Eecuting：正在发送命令；</li><li>Fetching：数据库正在检索数据；</li><li>Open：连接以正常打开，可以正常使用数据库。</li></ul></li></ul><h3 id="Update-Data-from-Query-Async-异步发送非查询sql命令"><a href="#Update-Data-from-Query-Async-异步发送非查询sql命令" class="headerlink" title="Update Data from Query Async(异步发送非查询sql命令)"></a>Update Data from Query Async(异步发送非查询sql命令)</h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224549.png"></p><p>此组件提供非查询的sql命令发送服务，即发送insert，delete，create等命令。</p><h3 id="Update-Data-from-Query-同步发送非查询sql命令"><a href="#Update-Data-from-Query-同步发送非查询sql命令" class="headerlink" title="Update Data from Query (同步发送非查询sql命令)"></a>Update Data from Query (同步发送非查询sql命令)</h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224602.png"></p><p><strong>输入：</strong></p><ul><li>Query：sql命令字符串；</li></ul><p><strong>输出：</strong></p><ul><li><p>Success Status：命令的执行状态</p><p>有三种执行状态值，类型为插件自定义的EMysqlSuccessStateEnum枚举，</p><ul><li>Executing：sql命令正在发送；</li><li>Success：sql命令执行成功；</li><li>Failed：sql命令执行失败。</li></ul></li><li><p>Error Message：输出错误信息。</p></li></ul><h3 id="Check-Query-EXecution-State-检查上一条命令的执行状态"><a href="#Check-Query-EXecution-State-检查上一条命令的执行状态" class="headerlink" title="Check Query EXecution State(检查上一条命令的执行状态)"></a>Check Query EXecution State(检查上一条命令的执行状态)</h3><p>此组件提任何sql命令的执行状态检查，<font color="red">但仅限检查Check Query EXecution State执行前的上一条sql语句的状态检查。</font></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224607.png"></p><p>输出内容和Update Data from Query一致。</p><h3 id="Select-Data-from-Query-Async-异步发送查询命令"><a href="#Select-Data-from-Query-Async-异步发送查询命令" class="headerlink" title="Select Data from Query Async(异步发送查询命令)"></a>Select Data from Query Async(异步发送查询命令)</h3><p>此组件仅限发送select语句，其他语句发送无效，<font color="red"> 查询到的数据会存储到插件自带的数据结构中，可以使用下面介绍的Get Selected Table组件进行数据访问。</font></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224613.png"></p><h2 id="Get-Selected-Table-读取数据表"><a href="#Get-Selected-Table-读取数据表" class="headerlink" title="Get Selected Table(读取数据表)"></a>Get Selected Table(读取数据表)</h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224619.png"></p><p><strong>输出:</strong></p><ul><li>Result by Column：以列的形式返回数据，<font color="red">返回一个MySQLDataTableStructures的结构体数据，每一个结构体就是一列，MySQLDataTableStructures结构体包含两个成员ColumnName(列名)和ColumnData(列数据)，其中ColumnData是一个FString类型的TArray数组，数组中每一个元数就是该列中某一行的数据。</font></li><li>Result by Row：以行的形式返回数据，返回一个<font color="red"> 返回一个MySQLDataRowStructures类型的结构体数组，每一个结构体就是一行，MySQLDataRowStructures结构体包含一个FString类型的TArray数组，数组中每一个元素就是该行中某一列的数据。</font></li></ul><h2 id="4-MySQL-Integration的注意事项"><a href="#4-MySQL-Integration的注意事项" class="headerlink" title="4.MySQL Integration的注意事项"></a>4.MySQL Integration的注意事项</h2><h3 id="MySQL-Integration不支持存储过程"><a href="#MySQL-Integration不支持存储过程" class="headerlink" title="MySQL Integration不支持存储过程"></a>MySQL Integration不支持存储过程</h3><p>MySQL Integration插件不支持数据库的存储过程的语法，在Query引脚输入“Call ProdureceName(ParameterList) ”是没有办法唤醒数据库中的存储过程的，所以很多的数据库中的查询和插入逻辑就需要在外部实现了。</p><h3 id="MySQL-Integration不提供C-函数"><a href="#MySQL-Integration不提供C-函数" class="headerlink" title="MySQL Integration不提供C++函数"></a>MySQL Integration不提供C++函数</h3><p>MySQL Integration插件只提供蓝图组件不提供C++函数，也就是说数据库的连接查询等只能使用蓝图来实现，但大多数情况我们又必须在C++中访问数据库，在这钟情况下我们该如何做呢？</p><p>目前，我只想到一种方法，就是在C++中创建访问数据库的类在类中声明数据库的访问函数，用这个类的蓝图子类来重写该数据库访问函数，以实现父类中该数据库访问函数，这是由C++继承中的重写的特性实现的。</p><p>具体做法如下：</p><p>首先在C++中创建一个专门负责连接数据库的类并在类中声明连接函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;MysqlJsonCpp.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;GameFramework/Actor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;MysqlConnector.generated.h&quot;</span></span><br><br>UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DATA_SYS_API</span> <span class="hljs-title">AMysqlConnector</span> :</span> <span class="hljs-keyword">public</span> AActor<br>&#123;<br>GENERATED_BODY()<br><span class="hljs-keyword">public</span>:<br><br>UPROPERTY(BlueprintReadWrite,Category = <span class="hljs-string">&quot;VariableRW&quot;</span>)<br>FString errorMessage;<br>UPROPERTY(BlueprintReadWrite, Category = <span class="hljs-string">&quot;VariableRW&quot;</span>)<br>FString stateMessage;<br><br><span class="hljs-keyword">protected</span>:<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-keyword">public</span>:<br><br>AMysqlConnector();<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Tick</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime)</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-comment">//从配置文件ConnectConfig.json中读取Mysql连接配置文件</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ConnectMysqlByConfig</span><span class="hljs-params">()</span></span>;<br>    <br><span class="hljs-comment">//使用MySQLIntegration插件连接Mysql</span><br>UFUNCTION(BlueprintImplementableEvent,Category = <span class="hljs-string">&quot;OverridFunction&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">(FName server, FName dbName, FName userId, FName passwd)</span></span>;<br>    <br><span class="hljs-comment">//使用MySQLIntegration插件检查连接状态</span><br>UFUNCTION(BlueprintImplementableEvent, Category = <span class="hljs-string">&quot;OverridFunction&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ConnectState</span><span class="hljs-params">(FString &amp;errorMessageParam,FString &amp;stateMessageParam)</span></span>;<br><span class="hljs-comment">//获取连接状态</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetConnectState</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面的void Connect(FName server, FName dbName, FName userId, FName passwd);函数就是需要用蓝图实现的数据库连接函数，<font color="red"> 这里要注意，这个函数只能在C++中声明，不可以实现，否则父类调用此函数时将无法关联到子类的重写，并且这个函数需要使用<code>BlueprintImplementableEvent</code>参数暴露给蓝图</font>。</p><p><font color="red"> 这里还需要注意，如果这个函数中使用了变量的引用，那么这个变量也需要使用<code>UPROPERTY(BlueprintReadWrite, Category = &quot;VariableRW&quot;)</code>暴漏给蓝图，如上面的<code>FString errorMessage;</code>一样。</font></p><p>这样我们就可以创建一个蓝图类来继承这个类，</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224624.png"></p><p>然后在该蓝图类的MyBlueprint/Functions/Override下看到我们在C++类中声明的函数，直接重写实现即可，如：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224631.png"></p><p>实现时候我们就可以在C++中调用这个函数了，这个函数就会通过重写关联到蓝图自类中的重写过程，如此数据库便连接上了。</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE4】UE4读写Json文件</title>
    <link href="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%AF%BB%E5%86%99Json%E6%96%87%E4%BB%B6/"/>
    <url>/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%AF%BB%E5%86%99Json%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h1><p>如果我们想要在UE4中读写Json文件，那么我们必须使UE4包含<font color="red">Json和JsonUtilities</font>这两个模块，那么UE4如何添加模块呢？</p><p>UE4添加预定义模块的方法很简单，我只需打开工程的.Biuld.cs文件，在其中的<code>PublicDependencyModuleNames.AddRange()</code>函数中追加两个模块即可，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> UnrealBuildTool;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DATA_sys</span> :</span> ModuleRules<br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DATA_sys</span><span class="hljs-params">(ReadOnlyTargetRules Target)</span> : <span class="hljs-title">base</span><span class="hljs-params">(Target)</span></span><br><span class="hljs-function"></span>&#123;<br>PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;<br><br>PublicDependencyModuleNames.AddRange(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123; <span class="hljs-string">&quot;Core&quot;</span>, <span class="hljs-string">&quot;CoreUObject&quot;</span>, <span class="hljs-string">&quot;Engine&quot;</span>, <span class="hljs-string">&quot;InputCore&quot;</span> ,<span class="hljs-string">&quot;Json&quot;</span>,<span class="hljs-string">&quot;JsonUtilities&quot;</span>&#125;);<br><br>PrivateDependencyModuleNames.AddRange(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123;  &#125;);<br><br><span class="hljs-comment">// Uncomment if you are using Slate UI</span><br><span class="hljs-comment">// PrivateDependencyModuleNames.AddRange(new string[] &#123; &quot;Slate&quot;, &quot;SlateCore&quot; &#125;);</span><br><br><span class="hljs-comment">// Uncomment if you are using online features</span><br><span class="hljs-comment">// PrivateDependencyModuleNames.Add(&quot;OnlineSubsystem&quot;);</span><br><br><span class="hljs-comment">// To include OnlineSubsystemSteam, add it to the plugins section in your uproject file with the Enabled attribute set to true</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们要添加自定义模块就有点麻烦了，当然这里就不赘述了。</p><p>包含这两个模块之后，我们还需要用到<font color="red"> Json.h、JsonObject.h、JsonSerializer.h</font>三个头文件，其中JsonSerializer.h是用于Json序列化与反序列化用的。</p><p>至此我们就可以使用UE4自带的工具进行Json文件的读写工作了。</p><h1 id="二、Json文件写"><a href="#二、Json文件写" class="headerlink" title="二、Json文件写"></a>二、Json文件写</h1><h2 id="1-非序列化写入"><a href="#1-非序列化写入" class="headerlink" title="1.非序列化写入"></a>1.非序列化写入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AMysqlJsonCpp::CreatJson</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>FString filePath = FPaths::GameContentDir() + TEXT(<span class="hljs-string">&quot;MysqlConfig/Connect.json&quot;</span>);<br>FString jsonStr;<br>TSharedRef&lt;TJsonWriter&lt;&gt;&gt; jsonWriter = TJsonWriterFactory&lt;&gt;::Create(&amp;jsonStr);<br>jsonWriter-&gt;WriteObjectStart();<br>jsonWriter-&gt;WriteValue(TEXT(<span class="hljs-string">&quot;server&quot;</span>), TEXT(<span class="hljs-string">&quot;127.0.0.1&quot;</span>));<br>jsonWriter-&gt;WriteObjectEnd();<br>jsonWriter-&gt;Close();<br>FFileHelper::SaveStringToFile(jsonStr, *filePath);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>FPaths::GameContentDir()</code>返回当前工程目录的Content文件夹的路径，FPaths为UE4的路径读写工具；</p></li><li><p><code>FString jsonStr</code>的作用是用于关联UE4的Json写工具TJsonWriter&lt;&gt;，作为输入流载体，且JsonStr必须是FString类型；</p></li><li><p><code>TShareRef&lt;T&gt;</code>是UE4自身的共享指针类型；</p></li><li><p><code>TJsonWriter&lt;&gt;</code>是UE4专门用于写Json的模板类，其中类型参数通常为TCHAR，其中有多个方法供开发者使用：</p><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>Close()</td><td>关闭写工具</td></tr><tr><td>WriterArrayStart()</td><td>开始一个Json数组</td></tr><tr><td>WriterArrayEnd()</td><td>结束一个Json数组</td></tr><tr><td>WriterNull(FString)</td><td>为一个键写一个空值</td></tr><tr><td>WriterObjectStart()</td><td>开始一个Json对象</td></tr><tr><td>WriterObjectEnd()</td><td>结束一个Json对象</td></tr><tr><td>WriterValue(FString,FString/int32/float/bool)</td><td>向Json文件写入键值对</td></tr></tbody></table></li></ul><ul><li><p><code>TJsonWriterFactory&lt;&gt;::Create(FString)</code>是UE4用来生成Json写工具TJsonWriter&lt;&gt;的类，TJsonFactory&lt;&gt;只有一个方法就是Create；</p></li><li><p><code>FFileHelper</code>UE4的文件读写工具，方法<code>SaveStringToFile(TJsonWriter*,FString*)</code>函数的作用就是将Json写工具中的Json数据写到FString字符串中的路径文件中。</p></li></ul><p>使用非序列化方式写入Json时，写入方式需要严格按照Json的语法格式来做，如最开始需要使用WriterObjectStart()创建一个根前括号，即Json语法中最外面一层的<code>&#123;</code>，所有写入结束后需要使用WriterObjectEnd()声明根对象结束，即Json语法中的最外面一层的<code>&#125;</code>，同理数组也需要按对象一样的方法进行处理。如此才能写入一个结构完整的Json文本。</p><h2 id="2-序列化写入"><a href="#2-序列化写入" class="headerlink" title="2.序列化写入"></a>2.序列化写入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AMyActor::Test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>TSharedPtr&lt;FJsonObject&gt; rootObj = MakeShareable(<span class="hljs-keyword">new</span> FJsonObject());<br>rootObj-&gt;SetStringField(<span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>);<br>TArray&lt;TSharedPtr&lt;FJsonValue&gt;&gt; arrValue;<br>TSharedPtr&lt;FJsonValueString&gt; tmp = MakeShareable(<span class="hljs-keyword">new</span> FJsonValueString(<span class="hljs-string">&quot;array&quot;</span>));<br>arrValue.Add(tmp);<br>rootObj-&gt;SetArrayField(<span class="hljs-string">&quot;array&quot;</span>, arrValue);<br>FString filePath = FPaths::GameContentDir() + TEXT(<span class="hljs-string">&quot;MysqlConfig/text.json&quot;</span>);<br>FString jsonStr;<br>TSharedRef&lt;TJsonWriter&lt;TCHAR&gt;&gt; jsonWriter = TJsonWriterFactory&lt;TCHAR&gt;::Create(&amp;jsonStr);<br>FJsonSerializer::Serialize(rootObj.ToSharedRef(), jsonWriter);<br>FFileHelper::SaveStringToFile(jsonStr, *filePath);<br>UE_LOG(LogTemp, Error, TEXT(<span class="hljs-string">&quot;%s&quot;</span>),*filePath);<br>&#125;<br></code></pre></td></tr></table></figure><p>序列化的写入方式则无需考虑按Json的语法结构进行写入，序列化的写入方式是通过一个FJsonObject对象进行Json文本的写入。</p><ul><li>首先使用MakeSahreable()函数创建一个FJsonObject对象并使用共享指针引用。</li><li>然后我们便可以使用FJsonObject对象中的<code>SetArrayField(FString,TArray&lt;FSharePtr&lt;FJsonValue&gt;&gt;)</code>、<code>SetBoolFiled(FString,bool)</code>、<code>SetNumberField(FString,Number)</code>、<code>SetStringField(FString,FString)</code>、<code>SetObjectField(FString,TSharePtr&lt;FJsonObject&gt;)</code>、<code>SetField(FString,TSharePtr&lt;FJsonValue&gt;)</code>等函数向FJsonObject对象中写分别入数组、bool值、数字、字符串、对象和Json键值对。其中数组的写入较为麻烦，我们需要先向创建Json键值对类型共享指针的TArray数组<code>TArray&lt;TSharePtr&lt;FJsonValue&gt;&gt;</code>。并向数组中添加指向FJsonValue对象的共享指针后然后才可以使用SetArrayField进行数组的Json文本写入。</li><li>我们序列化写好的FJsonObject对象需要转化为FString字符串才能向文本中写入数据，FJsonObject转化为FString输入流的方式就是<code>FJsonSerializer::Serialize(TSharePtr&lt;FJsonObject&gt;.ToShareRef(),TSharePtr&lt;FJsonWriter&gt;)</code>;其中<code>TSharePtr&lt;FJsonWriter&gt;</code>和非序列化写入一样需要绑定一个FString作为输入流载体。</li><li>最后就可以通过FFileHelper::SaveStringToFile(FString,*FString)，前一个FString是输入流载体，后一个*FString是Json文件的存储路径。</li></ul><h1 id="三、Json文件读"><a href="#三、Json文件读" class="headerlink" title="三、Json文件读"></a>三、Json文件读</h1><h2 id="1-反序列化读取"><a href="#1-反序列化读取" class="headerlink" title="1.反序列化读取"></a>1.反序列化读取</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">TArray&lt;FName&gt; <span class="hljs-title">AMysqlJsonCpp::ReadMysqlConnectConfig</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>FString filePath = FPaths::GameContentDir() + TEXT(<span class="hljs-string">&quot;MysqlConfig/Connect.json&quot;</span>);<br><span class="hljs-keyword">if</span> (FPaths::FileExists(filePath))<br>&#123;<br>FString server;<br>FString dbName;<br>FString userId;<br>FString passwd;<br>TArray&lt;FName&gt; connectConfig;<br>FString fileStr;<br>FFileHelper::LoadFileToString(fileStr, *filePath);<br>TSharedPtr&lt;FJsonObject&gt; rootObject = MakeShareable(<span class="hljs-keyword">new</span> FJsonObject());<br>TSharedRef&lt;TJsonReader&lt;&gt;&gt; jsonReader = TJsonReaderFactory&lt;&gt;::Create(fileStr);<br><span class="hljs-keyword">if</span> (FJsonSerializer::Deserialize(jsonReader, rootObject))<br>&#123;<br>server = rootObject-&gt;GetStringField(<span class="hljs-string">&quot;server&quot;</span>);<br>dbName = rootObject-&gt;GetStringField(<span class="hljs-string">&quot;dbName&quot;</span>);<br>userId = rootObject-&gt;GetStringField(<span class="hljs-string">&quot;userId&quot;</span>);<br>passwd = rootObject-&gt;GetStringField(<span class="hljs-string">&quot;passwd&quot;</span>);<br>&#125;<br>connectConfig.Add(FName(*server));<br>connectConfig.Add(FName(*dbName));<br>connectConfig.Add(FName(*userId));<br>connectConfig.Add(FName(*passwd));<br>&#125;<br><br><span class="hljs-keyword">return</span> TArray&lt;FName&gt;();<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>首先Json文本的读取需要将Json文本以字符串的形式读入到一个FString的输入流载体中；</li><li>然后我们需要将这个输入流载体绑定到TJsonReader&lt;&gt;读出工具上；</li><li>然后使用<code>FJsonSerializer::Deserialize(TSharePtr&lt;TJsonReader&lt;&gt;&gt;,TSahrePtr&lt;FJsonObject&gt;)</code>将输入流载体的Json数据反序列化到FJsonObject对象中；</li><li>最后我们就可以使用FJsonObject对象中的<code>GetArrayField(FString)</code>、<code>GetBoolFiled(FString)</code>、<code>GetNumberField(FString)</code>、<code>GetStringField(FString)</code>、<code>GetObjectField(FString)</code>、<code>GetField(FString)</code>等方法从Json对象中读取指定键的值了。</li></ul>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE4】UE4蓝图基础</title>
    <link href="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/"/>
    <url>/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="一、蓝图可视化脚本与蓝图系统"><a href="#一、蓝图可视化脚本与蓝图系统" class="headerlink" title="一、蓝图可视化脚本与蓝图系统"></a>一、蓝图可视化脚本与蓝图系统</h1><h2 id="1-蓝图脚本"><a href="#1-蓝图脚本" class="headerlink" title="1.蓝图脚本"></a>1.蓝图脚本</h2><p>蓝图可视化脚本简称“蓝图”或“蓝图脚本”，是一种需要编译的面向对象的可视化编程语言，蓝图完全集成在UE4中，蓝图通过节点与连线工作。</p><h3 id="蓝图脚本的节点"><a href="#蓝图脚本的节点" class="headerlink" title="蓝图脚本的节点"></a>蓝图脚本的节点</h3><ul><li>触发事件，在蓝图脚本中以红色的节点出现</li><li>函数，在看图脚本中以蓝色的节点出现</li><li>变量，在蓝图脚本中中以黄色节点出现</li></ul><h2 id="2-蓝图系统"><a href="#2-蓝图系统" class="headerlink" title="2.蓝图系统"></a>2.蓝图系统</h2><p>蓝图系统又称“蓝图”或“蓝图类”，蓝图类可以看成是一个包含游戏内容的容器，其中可以包含组件、脚本或可以仅仅包含数据。</p><p>蓝图类有点类似Unity3d中的预设(prefb)，蓝图类可以类似预设一般保存对象状态，可以随时拖入场景中使用，只是在其他功能上不如预设，如预设在U3D中的打包中可以发挥出优秀的效果，但是蓝图类只能作为容器使用。</p><p><font color="red"> 蓝图类包含蓝图脚本，每一个蓝图类都包含一个默认的蓝图脚本。</font></p><h3 id="蓝图类的分类"><a href="#蓝图类的分类" class="headerlink" title="蓝图类的分类"></a>蓝图类的分类</h3><ul><li><strong>关卡蓝图</strong>：关卡蓝图在每个Level中只能存在一个，负责整个关卡的运行逻辑，关卡的初始化，帧更新都在关卡蓝图里进行；</li><li><strong>普通蓝图</strong>：普通蓝图就是UE4的预设，在普通蓝图中我们可以对其中的对象进行一些的配置，如设置网格，贴图，粒子特效，添加相机，添加物理材质和挂载蓝图脚本等等；</li><li><strong>游戏模式蓝图</strong>：UE4中游戏模式也是以蓝图的形式存在的，游戏模式蓝图控制一系列游戏的规则；</li><li><strong>材质蓝图</strong>：在UE4中贴图材质也是蓝图的形式存在的，在材质蓝图中我们可以如同建模软件一般对材质进行一系列更高级的材质配置，如下图的一个简单示例：</li></ul><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224209.png"></p><h2 id="4-创建蓝图"><a href="#4-创建蓝图" class="headerlink" title="4.创建蓝图"></a>4.创建蓝图</h2><p>创建蓝图的方法很多，这里介绍比较常用的方法</p><ul><li>可以直接在Content Browser(内容浏览器)中右键创建一个空的蓝图类，空蓝图除了包含一个根组件外不再包含其他东西，当我们在空蓝图中创建了对象后可以通过拖拽的方式将对象拖动到根组件位置处，用游戏对象替换根组件作为根组件，这样创建空蓝图时的白色小球就会消失；</li><li>在World Outliner(世界大纲)中选中游戏对象，可以通过工具栏中的Blueprints工具中的下面两个选项创建一个包含所选内容的蓝图类；</li></ul><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224214.png"></p><ul><li>通过Blueprints工具的New Empty Blueprint Class也可以直接创建空蓝图类；</li><li>然而关卡蓝图似乎只能通过Blueprints工具的Open Blueprint Class打开。</li></ul><h1 id="二、变量与对象引用"><a href="#二、变量与对象引用" class="headerlink" title="二、变量与对象引用"></a>二、变量与对象引用</h1><h2 id="1-在蓝图中创建变量"><a href="#1-在蓝图中创建变量" class="headerlink" title="1.在蓝图中创建变量"></a>1.在蓝图中创建变量</h2><p>在蓝图中创建变量的方式有两种，其一：直接点击My BluePrint/Variables/+Variable，默认创建bool行的变量，可以点击变量前的色块更换变量类型。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224219.png"></p><p>其二：在蓝图脚本区域右键-&gt;输入Get New Var，可以直接在蓝图脚本中以节点的形式创建变量，在右侧细节面板中设置变量的值。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224223.png"></p><p>所有创建好的变量都会在My Blueprint面板Variables栏中显示。</p><p><font color="red"> 在创建好的变量的Details/Variable/Variable Type选项中可以设置变量为普通变量、数组、Set容器和Map容器。</font></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224225.png"></p><h2 id="2-在蓝图中使用变量"><a href="#2-在蓝图中使用变量" class="headerlink" title="2.在蓝图中使用变量"></a>2.在蓝图中使用变量</h2><p>可以直接在蓝图脚本区域右键-&gt;输入Get/Set [变量名]即可获取变量的获取/设置组件，也可以直接从左侧的My Blueprint面板Variables栏中拖拽变量到蓝图脚本区域选择Get/Set。</p><h2 id="3-生成时公开与私有变量"><a href="#3-生成时公开与私有变量" class="headerlink" title="3.生成时公开与私有变量"></a>3.生成时公开与私有变量</h2><p>蓝图中的公有与私有与程序中的公有私有有一些不同，蓝图中只分为生成时公开和私有两种访问权限。</p><h3 id="生成时公开-Expose-on-Spawn"><a href="#生成时公开-Expose-on-Spawn" class="headerlink" title="生成时公开(Expose on Spawn)"></a>生成时公开(Expose on Spawn)</h3><p>勾选生成时公开后，在蓝图类使用Spawn Actor from Class组件生成蓝图类实例时，勾选生成时公开的变量将可以接受外部值输入。<br><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224229.png"></p><p>如上图可以看到勾选生成时公开的变量会以输入接口的形式出现在Spawn Actor from Class节点里。这里需要注意的是，勾选Expose on Spawn，还需要勾选Instance Editable，否则会报警告。</p><h3 id="私有变量-Private"><a href="#私有变量-Private" class="headerlink" title="私有变量(Private)"></a>私有变量(Private)</h3><p>设置成私有变量的变量只能在蓝图类里访问，蓝图类的外部实例也无法访问这个变量，如上图，变量L没有设置成私有，所以可以通过Spawn Actor from Class组件生成的实例访问这个变量，而设置成私有的K变量搜索不到Set K节点。</p><h2 id="3-在蓝图中使用组件引用"><a href="#3-在蓝图中使用组件引用" class="headerlink" title="3.在蓝图中使用组件引用"></a>3.在蓝图中使用组件引用</h2><p>很多时候我们需要调节自身Actor上的组件的某些参数，那么我们就需要获得这个组件的引用以便获取组件上的参数进行调节，那么我们如何获得组件的引用呢？</p><p>其实方法也很简单，在My Blueprint/Variabales下有一个子栏“Components”其中存放着当前Actor上的所有的组件的引用，使用方法就是直接将需要的组件引用拖拽到蓝图脚本区域即可。获得了组件引用我们就可以通过引用使用不同的方法获取组件上的不同的参数了。</p><h2 id="4-动态获取世界大纲中的Actor"><a href="#4-动态获取世界大纲中的Actor" class="headerlink" title="4.动态获取世界大纲中的Actor"></a>4.动态获取世界大纲中的Actor</h2><p>在蓝图脚本中有四个方法获取外部Actor：</p><ul><li>Get All Actor of Class：通过类型来获取外部Actor</li></ul><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224234.png"></p><ul><li>Get All Actor with Tag：通过标签来获取外部Actor</li></ul><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224237.png"></p><ul><li>Get All Actor with Interface：通过外部接口在获取外部Actor</li></ul><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224240.png"></p><ul><li>Get Actors：通过层来获取Actor</li></ul><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224243.png"></p><h1 id="三、蓝图的数据类型"><a href="#三、蓝图的数据类型" class="headerlink" title="三、蓝图的数据类型"></a>三、蓝图的数据类型</h1><h2 id="1-5个基本数据类型"><a href="#1-5个基本数据类型" class="headerlink" title="1.5个基本数据类型"></a>1.5个基本数据类型</h2><p>UE4蓝图中基本数据类型只有5个，需要注意的是蓝图中没有char、double、short、long等数据类型，在C++与蓝图的配合使用时需要注意这些类型的变量。</p><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><h3 id="Byte"><a href="#Byte" class="headerlink" title="Byte"></a>Byte</h3><p>8位，一字节，0-255。</p><h3 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h3><p>32位整型，四字节。</p><h3 id="Integer64"><a href="#Integer64" class="headerlink" title="Integer64"></a>Integer64</h3><p>64位整型，八字节，能存储更大的数。</p><h3 id="Float"><a href="#Float" class="headerlink" title="Float"></a>Float</h3><p>32位单精度浮点型，其中1符号位、8指数位、23数值位，UE4中默认保留小数点后6位。UE4中只有Float类型没有Double类型。</p><h2 id="2-3种字符串"><a href="#2-3种字符串" class="headerlink" title="2.3种字符串"></a>2.3种字符串</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>蓝图中String类型就是蓝图C++中的FString类型，普通字符串，可以对其中的字符进行增删查改。</p><h3 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h3><p>Name是一种固定字符串类型，变量初始化以后不能在对其中的内容进行修改，且Name类型的字符串不区分大小写，多用于作为全局变量来唯一标识对象。Name类型的字符串在运行过程中存储于内存的字符串表中，使用效率高。</p><h3 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h3><p>Text是String的长度加强版，通常用于存储一段文字并可以进行国际化处理。</p><h2 id="3-Vector-维度向量"><a href="#3-Vector-维度向量" class="headerlink" title="3.Vector(维度向量)"></a>3.Vector(维度向量)</h2><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>默认创建的Vector是Vector 3D，即三维量，包含x、y、z三个值，可以表示任何任何三维量，如：三维坐标和RGB等。</p><h3 id="Vector-2D-和Vector-4"><a href="#Vector-2D-和Vector-4" class="headerlink" title="Vector 2D 和Vector 4"></a>Vector 2D 和Vector 4</h3><p>Vector 2D就是二维量，Vector 4就是四维量，常用于表示四元素。</p><h3 id="Two-Vectors"><a href="#Two-Vectors" class="headerlink" title="Two Vectors"></a>Two Vectors</h3><p>Two Vectors就是一个关于Vector的pair(对组)，pair在C++的STL种较为常用，是一个只包含两个元素的容器。</p><h2 id="4-Rotator-三维旋转量"><a href="#4-Rotator-三维旋转量" class="headerlink" title="4.Rotator(三维旋转量)"></a>4.Rotator(三维旋转量)</h2><p>包含：</p><p>x：roll，翻滚角，以x为轴，进行yz平面的旋转；</p><p>y：pitch，俯仰角，以y为轴，进行xz平面的旋转；</p><p>z：yaw，航向角，以z为轴，进行xy平面的旋转。</p><h2 id="5-Transform"><a href="#5-Transform" class="headerlink" title="5.Transform"></a>5.Transform</h2><p>Transfrom类型是一个3*3的矩阵，包含Location、Rotation和Scale三个三维向量。</p><h1 id="四、条件语句"><a href="#四、条件语句" class="headerlink" title="四、条件语句"></a>四、条件语句</h1><h2 id="1-Branch-if条件判断"><a href="#1-Branch-if条件判断" class="headerlink" title="1.Branch(if条件判断)"></a>1.Branch(if条件判断)</h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224256.png"></p><p>传入一个bool值，进行分流，通常和比较组件配合使用，如：“==”、“&gt;”等。</p><h2 id="2-Switch"><a href="#2-Switch" class="headerlink" title="2.Switch"></a>2.Switch</h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224300.png"></p><ul><li>Selection：case判断的变量；</li><li>Default：默认执行分支；</li><li>Add pin：添加执行分支。</li></ul><h1 id="五、循环语句"><a href="#五、循环语句" class="headerlink" title="五、循环语句"></a>五、循环语句</h1><h2 id="1-For-Loop-for循环"><a href="#1-For-Loop-for循环" class="headerlink" title="1.For Loop(for循环)"></a>1.For Loop(for循环)</h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224303.png"></p><ul><li>First Index/Last Index：提供循环的次数；</li><li>Loop Body：循环体执行分支；</li><li>Index：返回当前循环索引；</li><li>Conpleted：循环完毕后执行分支。</li></ul><h2 id="2-For-Loop-whit-Break-可跳出的for循环"><a href="#2-For-Loop-whit-Break-可跳出的for循环" class="headerlink" title="2.For Loop whit Break(可跳出的for循环)"></a>2.For Loop whit Break(可跳出的for循环)</h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224306.png"></p><p>使用方法和For Loop类似。</p><h2 id="3-For-Each-Loop-数组遍历"><a href="#3-For-Each-Loop-数组遍历" class="headerlink" title="3.For Each Loop(数组遍历)"></a>3.For Each Loop(数组遍历)</h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224309.png"></p><p>专门有用遍历数组的循环。</p><ul><li>Array：需要遍历的数组；</li><li>Loop Body：循环体分支；</li><li>Array Element：遍历的数组元素；</li><li>Array Index：当前索引；</li><li>Completed：遍历结束执行分支。</li></ul><h2 id="4-For-Each-Loop-with-Break-可跳出的数组遍历"><a href="#4-For-Each-Loop-with-Break-可跳出的数组遍历" class="headerlink" title="4.For Each Loop with Break(可跳出的数组遍历)"></a>4.For Each Loop with Break(可跳出的数组遍历)</h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224313.png"></p><p>用法和Foreach Loop一样，只是多了一个跳出执行分支。</p><h2 id="5-Reverse-for-Each-Loop-反向数组遍历"><a href="#5-Reverse-for-Each-Loop-反向数组遍历" class="headerlink" title="5.Reverse for Each Loop(反向数组遍历)"></a>5.Reverse for Each Loop(反向数组遍历)</h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224316.png"></p><h2 id="6-While-Loop-while循环"><a href="#6-While-Loop-while循环" class="headerlink" title="6.While Loop(while循环)"></a>6.While Loop(while循环)</h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224320.png"></p><h1 id="六、数组"><a href="#六、数组" class="headerlink" title="六、数组"></a>六、数组</h1><h2 id="1-创建数组"><a href="#1-创建数组" class="headerlink" title="1.创建数组"></a>1.创建数组</h2><p>创建数组要比创建变量多一个步骤，首先我们需要创建一个变量，然后再将这个变量的Details/Varialble Type选项的右侧色块选择九宫格，即可将对应变量转换成对应类型的数组。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224322.png"></p><h2 id="2-为数组赋值"><a href="#2-为数组赋值" class="headerlink" title="2.为数组赋值"></a>2.为数组赋值</h2><h3 id="Add-Array"><a href="#Add-Array" class="headerlink" title="Add(Array)"></a>Add(Array)</h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224326.png"></p><p>传入一个数组和一个元素即可通过Add(Array)组件为组数赋值</p><p>如：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224329.png"></p><p>循环完毕后数组Array内便存储有0-10的是个int型元素。</p><h2 id="3-获取元素"><a href="#3-获取元素" class="headerlink" title="3.获取元素"></a>3.获取元素</h2><h3 id="Get-a-copy"><a href="#Get-a-copy" class="headerlink" title="Get(a copy)"></a>Get(a copy)</h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224333.png"></p><p>获取指定索引的元素的拷贝。</p><h3 id="Get-a-ref"><a href="#Get-a-ref" class="headerlink" title="Get(a ref)"></a>Get(a ref)</h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224336.png"></p><p>获取指定索引的元素的引用。</p><h2 id="4-插入元素"><a href="#4-插入元素" class="headerlink" title="4.插入元素"></a>4.插入元素</h2><h3 id="Add-Aray"><a href="#Add-Aray" class="headerlink" title="Add(Aray)"></a>Add(Aray)</h3><p>直接在数组的末尾插入元素的方法也是使用Add(Array)组件，Add(Array)组件的的插入过程就是直接在数组的末尾插入元素。</p><h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224339.png"></p><p>指定位置插入使用Insert组件，输入参数从上至下依次为目标数组、要插入的元素、目标插入的索引位置。</p><p>当要使用Insert组件在数组末尾插入，而又不知道数组大小时，可以使用Last Index组件直接获取输入数组的尾索引，当然直接使用只会在最后一个索引位置插入，而使最后一位元素向后移动一位，而达不到在数组尾部插入的效果，所以需要加一食用。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224342.png"></p><h3 id="Set-Array-Elem"><a href="#Set-Array-Elem" class="headerlink" title="Set Array Elem"></a>Set Array Elem</h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224345.png"></p><p>设置输入数组指定索引的元素的值，Size to Fit选项可以设置如果指定索引不存在时数组自动扩充size大小。</p><h2 id="5-查找元素"><a href="#5-查找元素" class="headerlink" title="5.查找元素"></a>5.查找元素</h2><h3 id="Contains-Item"><a href="#Contains-Item" class="headerlink" title="Contains Item"></a>Contains Item</h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224349.png"></p><p>Contains Item组件可以查找指定数组中是否包含某一元素，但是Contains Item只返回bool的判断结果，不会返回目标的索引值。</p><h3 id="Find-Item"><a href="#Find-Item" class="headerlink" title="Find Item"></a>Find Item</h3><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Git/Temp/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-59-54.png"></p><p>Find Item则是从输入数组中查找指定元素并返回第一次查找到该元素的索引值。</p><h2 id="6-删除元素"><a href="#6-删除元素" class="headerlink" title="6.删除元素"></a>6.删除元素</h2><h3 id="Remove-Index"><a href="#Remove-Index" class="headerlink" title="Remove Index"></a>Remove Index</h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224353.png"></p><p>通过索引删除元素</p><h3 id="Remove-Item"><a href="#Remove-Item" class="headerlink" title="Remove Item"></a>Remove Item</h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224357.png"></p><p>从输入数组中移除指定元素，Remove Item会删除数组中所有指定的元素，如果删除成功则返回true，失败则返回false。</p><h2 id="7-筛选元素"><a href="#7-筛选元素" class="headerlink" title="7.筛选元素"></a>7.筛选元素</h2><h3 id="Filter-Array"><a href="#Filter-Array" class="headerlink" title="Filter Array"></a>Filter Array</h3><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224400.png"></p><p>过滤数组可以按类型来筛选数组元素，用于父类型数组存储子类型元素时进行类型筛选，如：Actor数组筛选MyClass类型元素，Filter Array返回一个筛选后的新数组。</p><h2 id="8-清空数组"><a href="#8-清空数组" class="headerlink" title="8.清空数组"></a>8.清空数组</h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224406.png"></p><p>使用Clear组件可以将数组内的元素全部清空。</p><h2 id="9-获取数组长度"><a href="#9-获取数组长度" class="headerlink" title="9.获取数组长度"></a>9.获取数组长度</h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224409.png"></p><h2 id="10-设置数组长度"><a href="#10-设置数组长度" class="headerlink" title="10.设置数组长度"></a>10.设置数组长度</h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224412.png"></p><h1 id="七、结构体"><a href="#七、结构体" class="headerlink" title="七、结构体"></a>七、结构体</h1><h2 id="1-结构体创建"><a href="#1-结构体创建" class="headerlink" title="1.结构体创建"></a>1.结构体创建</h2><p>蓝图中结构体的创建是没办法在蓝图脚本视图中创建的，UE4蓝图中结构体是与蓝图脚本同级的蓝图类，创建蓝图结构体的方法：在Content Browser中右键-&gt;Create Advanced Assect/Blueprint栏-&gt;Structure，即可创建一个结构体，创建出来的结构体默认拥有一个bool值得成员变量。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224416.png"></p><h2 id="2-定义成员变量"><a href="#2-定义成员变量" class="headerlink" title="2.定义成员变量"></a>2.定义成员变量</h2><p>蓝图中得结构体只能创建成员变量，不能创建成员函数，成员变量可以直接设置默认值。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224420.png"></p><h2 id="3-结构的使用"><a href="#3-结构的使用" class="headerlink" title="3.结构的使用"></a>3.结构的使用</h2><p>将结构体创建好以后便可以直接在蓝图脚本中搜索到并使用了。</p><h1 id="八、枚举"><a href="#八、枚举" class="headerlink" title="八、枚举"></a>八、枚举</h1><h2 id="1-枚举的创建"><a href="#1-枚举的创建" class="headerlink" title="1.枚举的创建"></a>1.枚举的创建</h2><p>枚举的创建和使用和结构体区别不大，创建方式一如结构体一般,Content Browser中右键-&gt;Create Advanced Assect/Blueprint栏-&gt;Enumeration，创建好后UE4也会在一个新的视图中对枚举进行编辑，枚举的编辑操作也相当简单，只有向枚举中添加与删除元素的操作，这些元素都可以添加注解提示，枚举也可以添加整个枚举的注解提示。</p><h2 id="2-枚举的使用"><a href="#2-枚举的使用" class="headerlink" title="2.枚举的使用"></a>2.枚举的使用</h2><p>枚举的使用就如同变量的使用一般，没有什么可说的。</p><h1 id="九、接口"><a href="#九、接口" class="headerlink" title="九、接口"></a>九、接口</h1><h2 id="1-接口的定义"><a href="#1-接口的定义" class="headerlink" title="1.接口的定义"></a>1.接口的定义</h2><p>接口的定义和和蓝图函数库，蓝图宏库一样，但是接口的不像函数库和宏库一般可以再一个蓝图类中定义多个函数和宏，接口就是一个蓝图类，并且接口的编辑界面及其简约，可编辑视图只有一个My Blueprint和一个Detials,在My Blueprint/Functions栏可以新建接口函数，在对应的接口函数的Details/Graph可以设置一些接口函数的描述和Const属性，在Details/Inputs和Outputs栏可以设置接口函数的输入与输出参数。</p><h2 id="2-接口的继承"><a href="#2-接口的继承" class="headerlink" title="2.接口的继承"></a>2.接口的继承</h2><p>接口是一个抽象蓝图，接口的实现必须通过继承接口的蓝图来实现，在蓝图中接口继承通过Toolbar/Class Settings/Interfaces栏即可添加接口到当前蓝图类是指继承此接口。</p><h2 id="3-接口的实现"><a href="#3-接口的实现" class="headerlink" title="3.接口的实现"></a>3.接口的实现</h2><h3 id="无返回值的接口实现"><a href="#无返回值的接口实现" class="headerlink" title="无返回值的接口实现"></a>无返回值的接口实现</h3><p>在一个蓝图继承了一个无返回值得接口后，这个接口将以事件的形式出现在这个蓝图类的All Actions for this Blueprint里</p><p>如：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224426.png"></p><p>蓝图以这个事件作为接口函数的入口，以此节点开始便可以开始实现各个蓝图类各自继承的接口函数的逻辑了。</p><h3 id="有返回值得接口实现"><a href="#有返回值得接口实现" class="headerlink" title="有返回值得接口实现"></a>有返回值得接口实现</h3><p>有返回值的接口不会以事件的形式出现在Add Event里，而是会直接出现在My Blueprint/Interface栏里，我们双击即可打开接口函数的编辑视图，在视图中实现接口即可。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224430.png"></p><h2 id="4-接口函数的调用"><a href="#4-接口函数的调用" class="headerlink" title="4.接口函数的调用"></a>4.接口函数的调用</h2><p>蓝图通过<code>[接口名](Mesasge)</code>组件来调用接口中的函数，如下图中的Interface1(Message)和Interface2(Message)。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224433.png"></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224436.png"></p><p>接口的使用需要指定使用的接口是哪个蓝图类中实现的接口和接口需要传入的参数。在蓝图类的My Blueprint/Variables栏是可以搜索到我们自己创建的蓝图类的，通过过去蓝图类的引用便可以指定接口函数的实现者了。当然我们也可以使用Get All Actors with Interface组件来获取实现了指定接口的所有蓝图类，然后再对这些蓝图类中实现的函数进行调用。</p><h1 id="十、蓝图函数库"><a href="#十、蓝图函数库" class="headerlink" title="十、蓝图函数库"></a>十、蓝图函数库</h1><p><font color="red"> 蓝图函数库是一个可以被所有蓝图类调用的函数集合，蓝图函数库里的方法全部都被定义为静态方法</font>，用于定义一些不与特定游戏对象绑定的功能性函数的实现。</p><h2 id="1-创建蓝图函数库"><a href="#1-创建蓝图函数库" class="headerlink" title="1.创建蓝图函数库"></a>1.创建蓝图函数库</h2><p>创建蓝图函数库的方式和创建结构体类似，在Content Browser中右键-&gt;Create Advanced Assect/Blueprint栏-&gt;Bluprint Function LiberLibrary。</p><h2 id="2-实现蓝图函数库里的函数"><a href="#2-实现蓝图函数库里的函数" class="headerlink" title="2.实现蓝图函数库里的函数"></a>2.实现蓝图函数库里的函数</h2><p>和结构体一样，创建好的蓝图函数库UE4会创建一个新的界面用于编辑库里函数；</p><ul><li>在My Blueprint/Functions栏可以申明函数</li><li>在My Blueprint/Local Variables栏可以生命局部变量，在其Details中可以设置局部变量默认值；</li><li>在对应函数的Details/Input和Output栏可以分别设置函数的输入输出参数</li><li>在脚本编辑区可以实现函数逻辑。</li></ul><h2 id="3-使用蓝图函数库里的函数"><a href="#3-使用蓝图函数库里的函数" class="headerlink" title="3.使用蓝图函数库里的函数"></a>3.使用蓝图函数库里的函数</h2><p>要使用蓝图函数库里的函数，可直接在脚本编辑区右键输入函数名即可在Class栏中看到蓝图函数库里的函数了。</p><h1 id="十一、蓝图宏库"><a href="#十一、蓝图宏库" class="headerlink" title="十一、蓝图宏库"></a>十一、蓝图宏库</h1><p>宏在UE4中几乎无处不在，蓝图宏库是开发者使用蓝图自定义的一系列的宏的容器，蓝图宏库和蓝图函数库一样可以定义多个宏；</p><ul><li>蓝图宏库与蓝图函数库不同的是，蓝图宏库中的宏是在预编译过程中完成处理的，即蓝图宏库不需要编译；</li><li>自定义的宏，可以有任意数量的输入输出引脚，即一个宏可以没有输出引脚，这样的宏可以只进行数据处理，一个宏也可以有多个输入输出引脚，这样的宏可以根据不同的逻辑选择不同的执行流，而蓝图函数库中的函数必须有且只有一个输入和一个输出引脚；</li><li>与函数不同，宏中不可以再定义成员变量，即宏只负责处理逻辑，不提供暂存能力。</li></ul><h2 id="1-创建蓝图宏库"><a href="#1-创建蓝图宏库" class="headerlink" title="1.创建蓝图宏库"></a>1.创建蓝图宏库</h2><p>宏库的创建与函数库的创建是一样的，在Content Browser中右键-&gt;Create Advanced Assect/Blueprint栏-&gt;Bluprint Macro LiberLibrary。</p><h2 id="2-蓝图宏声明"><a href="#2-蓝图宏声明" class="headerlink" title="2.蓝图宏声明"></a>2.蓝图宏声明</h2><ul><li>在My Blueprint/Macro中可以声明一个宏；</li><li>在指定宏的Details/Inputs和Outputs中可以定义输入与输出引脚和参数。</li></ul><h2 id="3-蓝图宏的使用"><a href="#3-蓝图宏的使用" class="headerlink" title="3.蓝图宏的使用"></a>3.蓝图宏的使用</h2><p>和蓝图函数的使用方法一致。</p><h2 id="4-自定义流程控制"><a href="#4-自定义流程控制" class="headerlink" title="4.自定义流程控制"></a>4.自定义流程控制</h2><p>除了蓝图提供给我们的条件语句和循环语句等流程控制语句外，我还可以使用宏编写自己的流程控制，因为宏可以有多个输入和输出引脚，使用方法就是使用宏的形式定义自己的流程控制逻辑，通过不同的输入给予不同输出，即可达到自定义流程控制的目的。</p><h1 id="十二、事件"><a href="#十二、事件" class="headerlink" title="十二、事件"></a>十二、事件</h1><p>除了UE4蓝图中给我们提供大量的预定义事件，我也可以自定义事件。</p><h2 id="1-事件的定义"><a href="#1-事件的定义" class="headerlink" title="1.事件的定义"></a>1.事件的定义</h2><p>事件的定义也很简单，在All Actions for this Buleprint中选择Add Custom Event，便可以创建一个自定义事件的入口，之后通过这个入口实现事件的内部逻辑，一个事件便定义完成。</p><h2 id="2-事件的调用"><a href="#2-事件的调用" class="headerlink" title="2.事件的调用"></a>2.事件的调用</h2><p>事件调用必须通过实现这个事件的蓝图类才可以对其中的事件进行调用。如：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224450.png"></p><p>Event Blueprint为实现自定义事件的蓝图类；</p><p>Print Str为自定义事件。</p><h2 id="3-事件调度器"><a href="#3-事件调度器" class="headerlink" title="3.事件调度器"></a>3.事件调度器</h2><p>事件调度器的创建与使用请阅读目录：十七、蓝图类的通信/3.使用事件调度器进行通信</p><h1 id="十三、蓝图模块"><a href="#十三、蓝图模块" class="headerlink" title="十三、蓝图模块"></a>十三、蓝图模块</h1><p>蓝图中可以将一个复杂了逻辑处理合并成一个节点模块，从而简化整体的执行流复杂度，使蓝图的执行流变得简单明了。我们可以将需要合并的执行流多选选中然后右键，即可在Organization栏中通过Collapse Nodes选项来合并执行流。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224454.png"></p><p>除了将执行流合并成节点外，蓝图还提供将多个执行流合并成一个函数或一个宏的功能。合并好的模块也可以在Organizition/Expand Node进行模块分离。</p><h1 id="十四、角色控制"><a href="#十四、角色控制" class="headerlink" title="十四、角色控制"></a>十四、角色控制</h1><h2 id="1-为角色添加跟随相机"><a href="#1-为角色添加跟随相机" class="headerlink" title="1.为角色添加跟随相机"></a>1.为角色添加跟随相机</h2><p>相对U3D来说，UE4的相机跟随要简单得多，UE4中直接将相机设置成了蓝图类的组件，当蓝图类时Player时，即可实现相机对Player的跟随了。</p><p>相机跟随需要通过一个物理组件<code>Spring Arm</code>来链接相机和Player，将相机附着在Spring Arm下，即可在Spring Arm的作用下实现相机跟随。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224458.png"></p><h2 id="2-为角色添加控制器"><a href="#2-为角色添加控制器" class="headerlink" title="2.为角色添加控制器"></a>2.为角色添加控制器</h2><p>在UE4的游戏制作过程中，我们不难发现当我们运行游戏时，在世界大纲中多出了很多东西，如下图：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224502.png"></p><p>其实，UE4为我们提供很多已经预制好的必须品，如上图的PlayerController(角色控制器)、PlayerCameraMenager(角色相机管理器)等。也就是说不可以直接使用UE4预制给我们的角色控制器来控制我们的Player，而不需要自己再去为Player蓝图配置角色控制器了，我们只需将Player的细节面板上的Auto Possess Player设置成Player0即可，Player0即表示本地角色。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224505.png"></p><p>需要注意的是，对于角色控制更优的方式是使用<code>Player Start</code>组件去持有Player蓝图类，再通过Player Controller来控制Player Start达到控制角色的目的。</p><h2 id="3-自定义游戏模式"><a href="#3-自定义游戏模式" class="headerlink" title="3.自定义游戏模式"></a>3.自定义游戏模式</h2><p>在我们创建一个UE4工程后，UE4会启用UE4默认的游戏模式<code>GameModeBase</code>，GameModeBase就控制着Player Controller、PlayerCameraMenager、PlayerState等运行时UE4动态生成的一些游戏物体，我们可以通过启用我们自定义的游戏模式来设置这些游戏物体按自己的定义的规则来生成运行。</p><p>游戏模式也是一个蓝图类，创建游戏模式就是创建蓝图类，只是这个蓝图类需要继承自GameModeBase类，继承自GameModeBase类的蓝图就是一个游戏模式蓝图。不过在我们第一此=次打开游戏模式蓝图时，UE4会将游戏模式蓝图识别成一个普通蓝图，而进入普通蓝图的编辑模式，可能是bug吧，此时我们只需将蓝图关闭，再打开一次，UE4便可以识别出游戏模式蓝图了。</p><p>游戏模式蓝图中可以定义自己的游戏模式规则，比如我们可以通过修改Spectator Class选项为自定义的游戏物体，这样在游戏运行时，UE4将不再生成DefaulPawn，而是会生成我们指定的游戏物体。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224510.png"></p><p>配置好游戏模式后我们还需要让当前项目使用我们自定义的游戏模式，通过Seettings -&gt;Project Settings-&gt;Project/Maps&amp;Modes-&gt;Dfault GameModes，选择我们自己的配置的游戏模式即可让当前项目启用我们自己定义的游戏模式了</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224513.png"></p><h2 id="4-操控角色控制器"><a href="#4-操控角色控制器" class="headerlink" title="4.操控角色控制器"></a>4.操控角色控制器</h2><p>我们要操控角色控制器就需要配置键盘按键映射，配置好的键盘映射会以函数的形式加入蓝图脚本组件集中。</p><p>我们在Seettings -&gt;Project Settings-&gt;Engine/Input-&gt;Bindings/Axis Mappings设置键盘映射并可以配置映射的值，</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224518.png"></p><p>配置好键盘映射以后便可以在蓝图脚本中使用这些函数主键来控制我们Player了，控制角色运动的方法很多，我这里以旋转力矩的方式来控制小球运动，具体的控制方法如下：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224521.png"></p><p>加入两个键盘映射函数组件(InputAxis MoveF/B,InputAxis MoveL/R)、两个添加角度力矩的组件(Add Torque in Radians,Add Torque in Radians)，但是添加角度力矩组件是需要一个控制目标的，我们需要从左侧的My Blueprint面板的Components中将需要控制的物体Player拖入脚本蓝图中，分别连接到添加角度力矩组件的Target上。</p><p>这里还需要注意的一点是，在我们为Player添加相机时，相机使用的是相对于Player的局部坐标，使用局部坐标的相机会跟随Player旋转，而使用世界坐标的相机将会固定某一个角度跟随Player移动。切换方法为：下拉Spring Arm的细节面板/Transform/Rotation的三角箭头选择切换。</p><p>并且相机默认情况下是启用了物理碰撞的，但大多数情况下我们是不需要让相机出现物理碰撞的，所以我们也应当取消相机的物理碰撞。操作方法为：取消Spring Arm的细节面板/Camera Collision/Do Collision Test选项。</p><p>当然要想比较真实的模拟出物理效果，光这样是不行的，因为默认情况下Player是没有启动物理模拟的，我们需要启用Player的细节面板/Physics/Simulate Physics选项，并且将调节Player的细节面板/Linear Damping(线性摩檫)和Player的细节面板/Angular Damping(旋转摩檫)到适当的值，应为UE4默认是没有旋转摩檫的并且，默认线性摩檫为0.01。</p><h2 id="小知识"><a href="#小知识" class="headerlink" title=" 小知识"></a><font color="Green"> 小知识</font></h2><ul><li><font color="green"> 大多数时候我们都需要勾选作用力函数组件的Acel Change选项，如：上面的Add Torque in Radians，勾选了Acel Change选项作用力组件会在作用目标物体时忽略物体的质量因素，因为存在质量影响的话，我们可能需要给一个极大的力才能推动目标物体；</font></li><li><font color="green"> 有时可能默认大小的作用力对目标物体的移动作用达不到我们理想的效果，此时可以先将作用力加倍后在传递给作用力组件，蓝图脚本组件集中提供多种多样的乘积组件，我们上面使用的是float*float组件</font>；</li></ul><h1 id="十五、触发器"><a href="#十五、触发器" class="headerlink" title="十五、触发器"></a>十五、触发器</h1><p>在游戏设计中触发器的使用是非常平凡的，而在蓝图中触发器的实现也并不复杂，我们来看一下具体操作：</p><h2 id="1-创建触发器"><a href="#1-创建触发器" class="headerlink" title="1.创建触发器"></a>1.创建触发器</h2><ul><li>蓝图模式中游戏的一切都是蓝图，触发器也不例外，所以要做一个触发器，首先我们的创建一个蓝图的壳子，并继承自Actor类</li><li>触发器还需要一个极为重要的东西就是碰撞体，当然这里的碰撞体不是具有物理碰撞的网格碰撞体，而是蓝图的物理组件集中的Box Collison，一个没有物理碰撞效果专门用于触发器的盒碰撞体，我们给蓝图类添加这个组件，一个触发器便完成了</li></ul><h2 id="2-使用触发器"><a href="#2-使用触发器" class="headerlink" title="2.使用触发器"></a>2.使用触发器</h2><p>当触发器放置于场景中，有物体进入触发器碰撞盒时，触发器便会出自动发触发Event ActorBeginOverlap时间组件，之后我们便可以进行一系列逻辑操作了。</p><h1 id="十六、蓝图类的通信"><a href="#十六、蓝图类的通信" class="headerlink" title="十六、蓝图类的通信"></a>十六、蓝图类的通信</h1><h2 id="1-使用引用进行通信"><a href="#1-使用引用进行通信" class="headerlink" title="1.使用引用进行通信"></a>1.使用引用进行通信</h2><p>两个蓝图类要想通过引用进行通信，那么其中一个蓝图类就必须拥有另一个蓝图类的引用，如何获取一个蓝图类的引用呢？</p><p>在My Blueprint/Variables栏中添加一个所需要引用的蓝图类类型的变量，勾选它的Details/Variable/Instance Editable选项，就可以在这个蓝图类的实例的Details/Default栏中看到引用变量(如果不勾选是没有default栏的)，如此便可以方便的获取另一个蓝图类的实例的引用了。</p><p>通过引用两个蓝图类之间便可以进行单向的信息传递了。即拥有引用的蓝图类可以获取所引用蓝图的传递过来的信息，反向则不行。</p><h2 id="2-使用接口进行通信"><a href="#2-使用接口进行通信" class="headerlink" title="2.使用接口进行通信"></a>2.使用接口进行通信</h2><p>使用接口进行通信的好处是可以很便利的通过同一事件让各种不同的蓝图做出不同的反应，如：当受到子弹攻击时，墙会反弹子弹，人会受伤，通过接口通信来实现这个效果就是，创建一个受到子弹攻击的接口OnTakeAttack，然后分别让墙和人都继承这个接口并实现不同的效果，如此当受到子弹攻击时，我们便可以通过Get All Actor with Interface来调用实现这些接口的Actor来做出各自的反应。</p><p>接口的实现与使用请阅读目录：九、接口。</p><h2 id="3-使用事件调度器通信"><a href="#3-使用事件调度器通信" class="headerlink" title="3.使用事件调度器通信"></a>3.使用事件调度器通信</h2><p>事件调度器的通信过程是一个调度者与一个或多个被调度者之间的通信过程，类似观察者模式的通信过程。</p><h3 id="创建事件调度器"><a href="#创建事件调度器" class="headerlink" title="创建事件调度器"></a>创建事件调度器</h3><p>使用事件调度器来进行蓝图通信，首先我们需要拥有一个事件调度器；</p><p>事件调度器只能被拥有者调用，所以我们需要在调度者蓝图上创建事件调度器，在My Blueprint/Event Dispatchers栏可以新建一个蓝图调度器，此时这个蓝图便拥有了一个事件调度器，我们可以通过拖拽事件调度器到脚本编辑视图或直接在All Actions for this Blueprint中搜索，可以对事件调度器进行事件绑定(Bind)、事件解绑(Unbind)、解绑全部事件(Unbind all)，直接为事件调度器绑定新事件(Assign)和调用事件调度器(Call)。当一个事件调度器被调用后，与这个事件调度器绑定的事件都会被调用，一次来达到信息传递的目的。</p><h3 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h3><p>调度者要事件调度器调用被调度者的事件，那么被调度者就需要向调度者的事件调度器上绑定事件，通过Bind Event to [事件调度器名]组件来绑定事件到事件调度器上。</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811224533.png"></p><p>Target：输入事件调度器的拥有者对象</p><p>Event：需要绑定的事件</p><p>如此一个基于事件调度器的通信机制便完成了。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【MyQSL】MyQSL存储过程</title>
    <link href="/2019/10/21/%E3%80%90MyQSL%E3%80%91MyQSL%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    <url>/2019/10/21/%E3%80%90MyQSL%E3%80%91MyQSL%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="1-什么是存储过程"><a href="#1-什么是存储过程" class="headerlink" title="1.什么是存储过程"></a>1.什么是存储过程</h1><p>数据库中的存储过程有点类似编程中的函数，可以供外部环境在需要时调用，并且存储过程只需要编译一次，之后再用则无需进行在此编译。</p><h1 id="2-存储过程的创建"><a href="#2-存储过程的创建" class="headerlink" title="2.存储过程的创建"></a>2.存储过程的创建</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">delimiter &#x2F;&#x2F;<br>create procedure Test(in parameter01 int,out parameter02 varchar(45));<br>begin<br>-- 存储逻辑<br>end<br>&#x2F;&#x2F;<br>delimiter ;<br></code></pre></td></tr></table></figure><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li><strong>delimiter //</strong>:更改MySQL中语句分隔符<code>;</code>，目的就是为了将存储过程作为一个整体，使MySQL中的存储逻辑中的<code>;</code>在代码编辑阶段不被编译器识别，<code>//</code>标识在两个<code>//</code>中间的逻辑为存储逻辑，告知MySQL其中的<code>;</code>不需要解释；<font color="red"> 但是要记住，在用完<code>//</code>这个之后要记得将分隔符转回<code>;</code>,否则之后的语句也会使用<code>//</code>作为分隔符</font>。其中<code>//</code>可以是任意字符或字符串。</li><li><strong>create procedure Test(in parameter01 int , out parameter02 vachar(45))</strong>:创建一个存储过程Test，存储过程包含输入参数parameter01和输出参数parameter02，其中<code>in</code>标识输入参数，<code>out</code>标识输出参数，如果括号中不写标识in/out则默认为输入参数，其中输入参数只能用于从外界传入参数，输出参数只能用于返回结果，类似编程中的返回值。MySQL中也提供<code>inout</code>类型的参数，既可以作为输入参数使用也可以作为输出参数使用，但是不建议这么用，比较好的用法还是输入输出分开。</li><li><strong>begin end</strong>:<code>begin end</code>用来标识一个语句块，必须承兑出现，可以用在任何地方，在存储过程中逻辑写在<code>begin end</code>块内。</li></ul><h1 id="3-存储过程的使用"><a href="#3-存储过程的使用" class="headerlink" title="3.存储过程的使用"></a>3.存储过程的使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">call Test(1,@out_parameter);<br></code></pre></td></tr></table></figure><p>存储过程的使用就如同函数调用一般，传入输入参数，并使用使用变量来接收输出参数。<code>@out_parameter</code>就是用来接收输出参数的变量。</p><h1 id="4-存储逻辑"><a href="#4-存储逻辑" class="headerlink" title="4.存储逻辑"></a>4.存储逻辑</h1><p>在编写存储过程时逻辑判断语句是一定会用到的，下面列举一些常用的逻辑判断语句及其用法。</p><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>MySQL中单独的if语句和程序编程中有所不同，单独的if语句一般嵌入其他语句中一起用，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select if(exc,&#39;A&#39;,&#39;B&#39;);<br></code></pre></td></tr></table></figure><p>当exc的值为true时，输出A，否则输出B，exc可以是一个变量也可以是是一个语句，同理A，B也可以是一个变量或是一个语句。</p><h2 id="if-esle语句"><a href="#if-esle语句" class="headerlink" title="if esle语句"></a>if esle语句</h2><p>if esle语句与esle则有极大的不同，if else语句更接近编程中if esle</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">if exc1 then<br> -- 执行逻辑1;<br>elseif exc2 then<br>-- 执行逻辑2;<br>else<br>-- 执行逻辑3;<br>end if;<br></code></pre></td></tr></table></figure><p>每一个if/elseif之后都需要跟一个then才能写执行逻辑，需要注意的是，then和执行逻辑之间没有<code>;</code>分隔。if语句结束时需要使用 end if;来告知MySQLif判断语句结束。同单独的if语句一样，if else中的exc也可以是变量和语句。</p><h2 id="循环体"><a href="#循环体" class="headerlink" title="循环体"></a>循环体</h2><p>MySQL的循环体使用游标来实现，具体的我们先看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs mysql">delimiter &#x2F;&#x2F;<br>-- 使用断面名删除断面的时间戳数据，此存储过程不允许删除断面<br>create procedure DeleteSurfaceDataByName(<br>in in_surface_name varchar(32),<br>in in_time_point_start varchar(32),<br>in in_time_point_end varchar(32),<br>out run_state bool<br>)<br>begin<br>-- 判断断面是否合法<br>    if exists (select surface_no from surface_number where surface_name &#x3D; in_surface_name) then<br>    begin<br>declare num varchar(32) default null;<br>-- 游标的结束标志<br>declare done bool default false;<br>        -- 为主键id创建游标<br>declare cur cursor for select id from surface_data where surface_name &#x3D; in_surface_name;<br>        -- 将结束标志关联到游标<br>        declare continue handler for not found set done &#x3D; true;<br>        -- 打开游标<br>        open cur;<br>        -- 创建循环过程<br>        delete_loop:loop<br>        -- 从游标结果集中取值到num<br>        fetch next from cur into num;<br>-- 游标后移<br>        if done then<br>leave delete_loop;<br>end if;<br>        -- 循环语句<br>        begin<br>-- 场景1-删除当前段面中某一时段的水文数据<br>if in_time_point_start is not null and in_time_point_end is not null then<br>delete from surface_data where id &#x3D; num and ascii(time_point) &gt;&#x3D; ascii(in_time_point_start) <br>and ascii(time_point) &lt;&#x3D; ascii(in_time_point_end);<br>-- 场景2-删除当前断面中某一时刻的水文数据<br>elseif in_time_point_start is not null and in_time_point_end is null then<br>delete from surface_data where id &#x3D; num and time_point &#x3D; in_time_point_start;<br>end if;<br>end;<br>        -- 结束循环<br>        end loop;<br>        set run_state &#x3D; true;<br>end;<br>else<br>set run_state &#x3D; false;<br>end if;<br>end<br>&#x2F;&#x2F;<br>delimiter ;<br></code></pre></td></tr></table></figure><ul><li><strong>exists()</strong>:和select搭配可以判断满足where条件的selete字段在from的表中是否存在</li><li><strong>declare cur cursor for</strong>:和select语句搭配可以为select出来的结果集创建一个游标cur，而这个游标便是循环体的关键，游标就有点类似SLT中迭代器，可以逐一读取结果集中的数据。</li><li><strong>declare continue handler for not found set done = true</strong>：光有游标还是无法实现循环体的，循环体还有一个很重要的标志–结束标志，这条语句便是为游标设置循环结束标志，这条语句和前面的<code>declare done bool default false;</code>搭配使用，done便是循环结束的标志，通过这条语句将游标和循环结束标志绑定起来。</li><li><strong>open cur</strong>：上面仅仅是做好了使用循环体的前提，要想使用循环体还需要将游标打开，以便游标可以使用，open cur便是打开游标cur。</li><li><strong>delete_loop:loop</strong>:这是真正的循环体的开始，开始一个循环题delete_loop,同时需要使用<code>end loop;</code>来标识循环题结束。</li><li><strong>fetch next from cur into num</strong>:向游标cur指向的结果几种逐一读取数据到num变量中，这里要值意num变量和结果集中的数据类型要一至。</li><li>**if done then leave delete_loop end if;**：判断结束标志done，如果done等于true就继续执行循环体。</li><li>在if done then leave delete_loop end if;和end loop之间的就是每次循环执行的语句了。</li></ul><p>至此整个循环语句结束。</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【日记】在武汉跑秋招的日子</title>
    <link href="/2019/10/12/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E6%AD%A6%E6%B1%89%E8%B7%91%E7%A7%8B%E6%8B%9B%E7%9A%84%E6%97%A5%E5%AD%90/"/>
    <url>/2019/10/12/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E6%AD%A6%E6%B1%89%E8%B7%91%E7%A7%8B%E6%8B%9B%E7%9A%84%E6%97%A5%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3 id="encrypt-message">绕路吧！</h3><link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"> <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css"> <script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <script src="//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js"></script> <div id="security"> <div> <div class="input-group"> <input type="text" class="form-control" aria-label="Enter the password." id="pass"/> <div class="input-group-btn"> <button type="button" class="btn btn-default" onclick="decryptAES()">Decrypt</button> </div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
    
    
    <categories>
      
      <category>日记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大事件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【待解决】一些待解决的难题</title>
    <link href="/2019/10/10/%E3%80%90%E5%BE%85%E8%A7%A3%E5%86%B3%E3%80%91%E4%B8%80%E4%BA%9B%E5%BE%85%E8%A7%A3%E5%86%B3%E7%9A%84%E9%9A%BE%E9%A2%98/"/>
    <url>/2019/10/10/%E3%80%90%E5%BE%85%E8%A7%A3%E5%86%B3%E3%80%91%E4%B8%80%E4%BA%9B%E5%BE%85%E8%A7%A3%E5%86%B3%E7%9A%84%E9%9A%BE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>这里记录一些待解决的程序难题</p><h1 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h1><p>1.这两种内存分配的方式，有什么不一样，<br>2.初始化的s最后结果有什么不一样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">a</span> &#123;</span><br><span class="hljs-keyword">int</span> id;<br><span class="hljs-built_in">string</span> s;<br>&#125;;<br>a *ptr1 = <span class="hljs-keyword">new</span> a();<br>ptr1-&gt;s = <span class="hljs-string">&quot;hello&quot;</span>;<br>a *ptr2 = (a*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(a));<br>ptr2-&gt;s = <span class="hljs-string">&quot;hello&quot;</span>;<span class="hljs-comment">//这一句却会报异常，为什么？</span><br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h1><p>List容器中empty()判空和size()==0判空有什么不同</p><h1 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h1><p>为什么函数外的指针的值没有变化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getmemory</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *p)</span></span><br><span class="hljs-function"></span>&#123;<br>p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">100</span>];<br>strcpy_s(p,<span class="hljs-number">12</span>, <span class="hljs-string">&quot;hello world&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, p);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">char</span> *p = <span class="hljs-literal">NULL</span>;<br>getmemory(p);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, p);<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>而下面代码却可以改变</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getmemory</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **p)</span></span><br><span class="hljs-function"></span>&#123;<br>*p = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>);<br>strcpy_s(*p, <span class="hljs-number">12</span>,<span class="hljs-string">&quot;hello world&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, *p);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">char</span> *p = <span class="hljs-literal">NULL</span>;<br>getmemory(&amp;p);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, p);<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h1><p>UE4热加载</p><h1 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h1><p>UE4 delegate，UScriptStruct，UProperty</p><h1 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h1><p>寻路算法</p>]]></content>
    
    
    <categories>
      
      <category>待解决</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程序问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C++】C++中的四种个智能指针.md</title>
    <link href="/2019/10/08/%E3%80%90C++%E3%80%91C++%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E4%B8%AA%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/2019/10/08/%E3%80%90C++%E3%80%91C++%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E4%B8%AA%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>智能指针的出现的目的就是为了解决c++中出现异常安全资源管理问题，智能指针的实现原理是依据RAII机制(Resource Acquisition Is Initialization)，这是的智能指针本质上是一个对象，行为表现上是一个指针。</p><p>智能指针都是类模板使用时是必须指定类型参数的，如：<code>auto_ptr&lt;int&gt; ptr</code></p><h1 id="1-auto-ptr"><a href="#1-auto-ptr" class="headerlink" title="1.auto_ptr"></a>1.auto_ptr</h1><ul><li>auto_ptr采用所有权的模式，指针内不做引用计数，因此一个对象只能由一个auto_ptr指针所拥有，在给其他auto_ptr指针赋值时，所有权会转移</li><li>auto_ptr中使用delete来释放资源，所以auto_ptr不能指向数组，因为数组的释放使用的是delete[]</li><li>auto_ptr指针的判空使用auto_ptr.get()==NULL来判断</li></ul><p>auto_ptr是C++98中的标准，在C++11中已经被弃用。</p><p>auto_ptr由于是所有权模式，所在在auto_ptr做参数时，会转移所有权，即将函数外的auto_ptr的所有权转义给函数内的auto_ptr的所有权，如果函数内不做所有权转移的话，函数外的auto_ptr将变为空指针，而导致引用出错。如：</p><p><strong>不转移所有权</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test</span><span class="hljs-params">(<span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; apt)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; *apt &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> apt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function"><span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">1</span>))</span></span>;<br>Test(ptr);<br><span class="hljs-keyword">if</span> (ptr.get() == <span class="hljs-literal">NULL</span>)<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;NULL&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;NO NULL&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">1</span><br><span class="hljs-literal">NULL</span><br></code></pre></td></tr></table></figure><p><strong>转移所有权</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">Test</span><span class="hljs-params">(<span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; apt)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; *apt &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> apt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function"><span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">1</span>))</span></span>;<br>ptr = Test(ptr);<br><span class="hljs-keyword">if</span> (ptr.get() == <span class="hljs-literal">NULL</span>)<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;NULL&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;NO NULL&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">1</span><br><span class="hljs-literal">NO</span> <span class="hljs-literal">NULL</span><br></code></pre></td></tr></table></figure><h1 id="2-unique-ptr"><a href="#2-unique-ptr" class="headerlink" title="2.unique_ptr"></a>2.unique_ptr</h1><ul><li><p>unique_ptr是C++11中对C++98中的auto_ptr的替换与强化</p></li><li><p>unique_ptr也是使用独占所有权模式，即一个unique_ptr指针指向一个对象后，不可以在把这个对象赋予给另一个unique_ptr指针，后来出于一些考虑C++又提供了srd::move()函数来做所有权的移交，被移交所有权的unique_ptr指针会指向空，这时再使用这个指针就会报错</p></li><li><p>unique_ptr指针支持直接使用==判空，如：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; ptr;<br><span class="hljs-keyword">if</span>(ptr == <span class="hljs-literal">NULL</span>)<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;NULL&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure><p>当然unique_ptr依旧支持unique_ptr.get()==NULL来判空。</p><ul><li>当unique_ptr作为实参进行传递时，必须使用std::move()来移交所有权，这是unique_ptr的独占所有权性质决定的。如：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test</span><span class="hljs-params">(<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; apt)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; *apt &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function"><span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">1</span>))</span></span>;<br><span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; pt = move(ptr);<br>Test(<span class="hljs-built_in">std</span>::move(ptr));<br><span class="hljs-keyword">if</span> (ptr == <span class="hljs-literal">NULL</span>)<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;NULL&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;NO NULL&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-shared-ptr"><a href="#3-shared-ptr" class="headerlink" title="3.shared_ptr"></a>3.shared_ptr</h1><ul><li><p>shared_ptr指针支持一个对象被多个指针指向</p></li><li><p>shared_ptr使用计数机制来记录对象被多少个shared_ptr指针所指向，可以使用share_ptr.reset()函数来释放当前指针，对象的引用计数减一，当引用计数减为0时，释放对象资源</p></li><li><p>可以使用shared_ptr.use_count()来获取当前对象的引用计数</p></li></ul><p>我们来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test</span><span class="hljs-params">(<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; ptr)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;count_1:&quot;</span>&lt;&lt; ptr.use_count() &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">1</span>))</span></span>;<br><span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; pt = ptr;<br>Test(ptr);<br>pt.reset();<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;count_2:&quot;</span>&lt;&lt; ptr.use_count() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">if</span> (ptr == <span class="hljs-literal">NULL</span>)<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;NULL&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;NO NULL&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">count_1:3</span><br><span class="hljs-string">count_2:1</span><br><span class="hljs-literal">NO</span> <span class="hljs-literal">NULL</span><br></code></pre></td></tr></table></figure><p>咦！为什么引用计数count_1是3呢？这是因为在函数内形参<code>shared_ptr&lt;int&gt; ptr</code>也指向了同一个对象。而当函数Test结束形参指针释放，同时又使用reset()函数释放pt指针，所以count_2:1</p><h1 id="4-weak-ptr"><a href="#4-weak-ptr" class="headerlink" title="4.weak_ptr"></a>4.weak_ptr</h1><p>虽然shared_ptr使用起来更接近C的原生指针，但是当shared_ptr指针作为类成员时，可能会出现互相引用的而形成死锁，导致引用计数永远无法将为0的现象，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">shared_ptr</span>&lt;B&gt; pa;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">shared_ptr</span>&lt;A&gt; pb;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;A&gt; <span class="hljs-title">pa</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br><span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;B&gt; <span class="hljs-title">pb</span><span class="hljs-params">(<span class="hljs-keyword">new</span> B())</span></span>;<br>pa-&gt;pa = pb;<br>pb-&gt;pb = pa;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种情况是，pa是指向A类型的shared_ptr指针指向A类型对象，而pa指向的内存里面又有一个shared_ptr指针指向B类型对象，同理pb也是如此，这样就导致，当A要被释放时，要先释放B，而B要释放时又要先释放A，如此便形成了一个互相等待的死循环。weak_ptr的存在就是为了解决这种问题。</p><p>weak_ptr指针是一种弱引用，它指向对象和释放时不会引起引用计数的变化，这样便可以打破shared_ptr的这种死循环了，我们将上面的代码改成如下，就可以解死循环了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>weak_ptr&lt;B&gt; pa;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">shared_ptr</span>&lt;A&gt; pb;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;A&gt; <span class="hljs-title">pa</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br><span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;B&gt; <span class="hljs-title">pb</span><span class="hljs-params">(<span class="hljs-keyword">new</span> B())</span></span>;<br>pa-&gt;pa = pb;<br>pb-&gt;pb = pa;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPlus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法】一些牛逼轰轰的算法记录</title>
    <link href="/2019/10/08/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%B8%80%E4%BA%9B%E7%89%9B%E9%80%BC%E8%BD%B0%E8%BD%B0%E7%9A%84%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/"/>
    <url>/2019/10/08/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%B8%80%E4%BA%9B%E7%89%9B%E9%80%BC%E8%BD%B0%E8%BD%B0%E7%9A%84%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="1-判断点是否在三角形内"><a href="#1-判断点是否在三角形内" class="headerlink" title="1.判断点是否在三角形内"></a>1.判断点是否在三角形内</h1><h2 id="衍生：快速计算三角形面积"><a href="#衍生：快速计算三角形面积" class="headerlink" title="衍生：快速计算三角形面积"></a>衍生：快速计算三角形面积</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> S_FLOAT 0.00000001</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-comment">//点类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">float</span> x;<br><span class="hljs-keyword">float</span> y;<br>Point() &#123;&#125;<br>Point(<span class="hljs-keyword">float</span> x,<span class="hljs-keyword">float</span> y)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;x = x;<br><span class="hljs-keyword">this</span>-&gt;y = y;<br>&#125;<br>&#125;;<br><span class="hljs-comment">//计算三角形面积</span><br><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetTriangleSquar</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Point a, <span class="hljs-keyword">const</span> Point b, <span class="hljs-keyword">const</span> Point c)</span></span><br><span class="hljs-function"></span>&#123;<br>Point AB, BC;<br>AB.x = b.x - a.x;<br>AB.y = b.y - a.y;<br>BC.x = c.x - b.x;<br>BC.y = c.y - b.y;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">fabs</span>(AB.x*BC.y - AB.y*BC.x) / <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">//判断点是否在三角形内</span><br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">IsInTriang</span><span class="hljs-params">(Point a, Point b, Point c, Point d)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">float</span> Sabc, Sabd, Sacd, Sbcd;<br>Sabc = GetTriangleSquar(a, b, c);<br>Sabd = GetTriangleSquar(a, b, d);<br>Sacd = GetTriangleSquar(a, c, d);<br>Sbcd = GetTriangleSquar(b, c, d);<br><span class="hljs-keyword">float</span> Sums = Sabd + Sacd + Sbcd;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Sabd:&quot;</span> &lt;&lt; Sabd &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; <span class="hljs-string">&quot;Sacd:&quot;</span> &lt;&lt; Sacd &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; <span class="hljs-string">&quot;Sbcd:&quot;</span> &lt;&lt; Sbcd &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt; <span class="hljs-string">&quot;Sabc:&quot;</span>&lt;&lt;Sabc&lt;&lt;<span class="hljs-built_in">endl</span>&lt;&lt;<span class="hljs-string">&quot;Sums:&quot;</span>&lt;&lt;Sums &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">if</span> ((-S_FLOAT &lt; (Sabc - Sums) &amp;&amp; (Sabc - Sums) &lt; S_FLOAT))<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Yes&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;No&quot;</span>;<br>&#125;<br><span class="hljs-comment">//测试函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Point a(2, 2), b(0, 0), c(4, 0), d(2, 1);<br><span class="hljs-built_in">cout</span> &lt;&lt; IsInTriang(a, b, c, d) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Test();<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-PNPoly算法-判断点是否在多边形内"><a href="#2-PNPoly算法-判断点是否在多边形内" class="headerlink" title="2.PNPoly算法-判断点是否在多边形内"></a>2.PNPoly算法-判断点是否在多边形内</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">PointInPolygon</span><span class="hljs-params">(Point point, Polygon polygon)</span> </span>&#123;<br>  <span class="hljs-built_in">vector</span>&lt;Point&gt; points = polygon.getPoints();<br>  <span class="hljs-keyword">int</span> i, j, nvert = points.size();<br>  <span class="hljs-keyword">bool</span> c = <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>, j = nvert - <span class="hljs-number">1</span>; i &lt; nvert; j = i++) &#123;<br>    <span class="hljs-keyword">if</span>( ( (points[i].y &gt;= point.y ) != (points[j].y &gt;= point.y) ) &amp;&amp;<br>        (point.x &lt;= (points[j].x - points[i].x) * (point.y - points[i].y) / (points[j].y - points[i].y) + points[i].x)<br>      )<br>      c = !c;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C++】C++STL标准模板库</title>
    <link href="/2019/10/06/%E3%80%90C++%E3%80%91C++STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/"/>
    <url>/2019/10/06/%E3%80%90C++%E3%80%91C++STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="一、STL的基本概念"><a href="#一、STL的基本概念" class="headerlink" title="一、STL的基本概念"></a>一、STL的基本概念</h1><h2 id="1-什么是STL"><a href="#1-什么是STL" class="headerlink" title="1.什么是STL"></a>1.什么是STL</h2><p> STL (Standard Template Librany）标准准模板庠是惠普实验室开发的一系列软件的统称。现在主要出现在C++中，但在被引入C++之前该技木就已存在了很长一段吋间了。</p><p>STL的从广义上讲分为三类: algorithm (算法)、container (容器)和iterator (迭代器)，容器和算法通过迭代器可以进行无缝链接。几乎所有的代码都釆用了模板类和模板函数的方式,这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。在C++标准中，STL 被组织为下面的13个尖文件:<code>&lt;algorithm&gt;</code>、<code>&lt;deque&gt;</code>、<code>&lt;functional&gt;</code>、<code>&lt;iterator&gt;</code>、<code>&lt;vector&gt;</code>、<code>&lt;list&gt;</code>、 <code>&lt;map&gt;</code>、<code>&lt;memory&gt;</code>、<code>&lt;numerio&gt;</code>、<code>&lt;queue&gt;</code>、<code>&lt;set&gt;</code>、    <code>&lt;stack&gt;</code> 和<code>&lt;utility&gt;</code>。</p><p><img src="/2019/10/06/%E3%80%90C++%E3%80%91C++STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/Snipaste_2019-10-06_10-41-56.png"></p><p>我们详细的说六大组件：</p><ul><li>容器(Container)</li><li>算法(Algorithm)</li><li>迭代器(Iterator)</li><li>仿函数(Function object)</li><li>适配器(Adaptor)</li><li>空间配置器(allocator)</li></ul><h2 id="2-STL的好处"><a href="#2-STL的好处" class="headerlink" title="2.STL的好处"></a>2.STL的好处</h2><ul><li><p>STL是C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。</p></li><li><p>STL的一个重要特点是数据结构和算法的分离。尽管这是个简单的概念，但是这种分离确实使得STL变得非常通用。<br>例如，在STL 的vector容器中，可以放入元素、 基础数据类型变量、元素的地址;<br>STL的sort()函数可以用来操作vector,list等容器。</p></li><li><p>程序员可以不用思考STL具体的实现过程，只要能够熟综使用STL就OK了。这样他们就可以把精力放在程序开发的别的方面。</p></li><li><p>STL 具有高可重用性，高性能，高移植性，跨平台的优点。</p><p>  高可重用性: STL 中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。关于模板的知识，已经给大家介绍了。</p><p>高性能:如map可以高效地从十万条记录里面查找出指定的记录，因为map是采用红黑树的变体实现的。</p><p>高移植性:如在项目A上用STL编写的模块，可以直接移植到项目B上。</p><p>跨平台:如用windows的Visual Studio编写的代码可以在Mac OS的XCode上直接运行。</p></li><li><p>了解到STL的这些好处，我们知道STL无疑是最值得C++程序员骄傲的一部分。每一个C++程序员都应该好好学习STL.只有能够熟练使用STL的程序员，才是好的C++程序员。</p></li></ul><h1 id="二、容器"><a href="#二、容器" class="headerlink" title="二、容器"></a>二、容器</h1><h2 id="1-容器"><a href="#1-容器" class="headerlink" title="1.容器"></a>1.容器</h2><p>  在实际的开发过程中，数据结构本身的重要性不会逊于操作于数据结构的算法的重要性，当程序中存在着对时间要求很高的部分时，数据结构的选择就显得更加重要。</p><p>  经典的数据结构数量有限，但是我们常常重复着一些为了实现向量、链表等结构而编写的代码，这些代码都十分相似，只是为了适应不同数据的变化而在细节上有所出入。STL容器就为我们提供了这样的方便，它允许我们重复利用己有的实现构造自己的特定类型下的数据结构，通过设置-些模板，STL 容器对最常用的数据结构提供了支持，这些模板的参数允许我们指定容器中元素的数据类型，可以将我们许多重复而乏味的工作简化。</p><p>​    容器部分主要由头文件<code>&lt;vector&gt;</code>, <code>&lt;list&gt;</code>, <code>&lt;deque&gt;</code>, <code>&lt;set&gt;</code>, <code>&lt;map&gt;</code>, <code>&lt;stack&gt;</code>和<code>&lt;queue&gt;</code>组成。对于常用的一些容器和容器适配器(可以看作由其它容器实现的容器)，可以通过下表总结一:下它们和相应头文件的对应关系。</p><p><img src="/2019/10/06/%E3%80%90C++%E3%80%91C++STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/Snipaste_2019-10-06_10-41-56.png"></p><h2 id="2-容器的分类"><a href="#2-容器的分类" class="headerlink" title="2.容器的分类"></a>2.容器的分类</h2><h3 id="序列式容器-Sequence-containers"><a href="#序列式容器-Sequence-containers" class="headerlink" title="序列式容器(Sequence containers)"></a>序列式容器(Sequence containers)</h3><p>每个元素都有固定位置–取决于插入时机和地点，和元素值无关。如：vector、deque、 Iist。</p><h3 id="关联式容器-Associated-containers"><a href="#关联式容器-Associated-containers" class="headerlink" title="关联式容器(Associated containers)"></a>关联式容器(Associated containers)</h3><p>元素位置取决于特定的排序准则，和插入顺序无关。如：sset、multiset、 map、multimapu。</p><p><img src="/2019/10/06/%E3%80%90C++%E3%80%91C++STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/Snipaste_2019-10-06_14-36-13.png"></p><h2 id="3-string类"><a href="#3-string类" class="headerlink" title="3.string类"></a>3.string类</h2><h3 id="string类的本质"><a href="#string类的本质" class="headerlink" title="string类的本质"></a>string类的本质</h3><p><code>string</code>类本质上其实就是<code>char*</code>的容器，是<code>cahr*</code>的封装。</p><h3 id="string类的遍历"><a href="#string类的遍历" class="headerlink" title="string类的遍历"></a>string类的遍历</h3><p><strong>使用[]遍历：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;string_str&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length(); i++)<br><span class="hljs-built_in">cout</span> &lt;&lt; str[i];<br></code></pre></td></tr></table></figure><p><strong>使用迭代器遍历：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;string_str&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">string</span>::iteratori=str.begin();i&lt;str.end();i++)<br><span class="hljs-built_in">cout</span> &lt;&lt;*i;<br></code></pre></td></tr></table></figure><p><font color="red"> 注意这里的<code>i</code>是一个指向string::iterator类型的指针。</font></p><p><strong>使用at()遍历：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;string_str&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length(); i++)<br><span class="hljs-built_in">cout</span> &lt;&lt; str.at(i);<br></code></pre></td></tr></table></figure><p><code>at()</code>与<code>[]</code>不同的是，当访问发生越界等错误时，<code>at()</code>会自动抛出异常，而<code>[]</code>不会抛出异常而中断程序。</p><h3 id="string解封成char"><a href="#string解封成char" class="headerlink" title="string解封成char*"></a>string解封成char*</h3><p>C++为string类提供了一个专门的函数<font color="red"> <strong>str.c_str()</strong></font>，str是string类型的对象，但是需要注意的是<code>str.c_str()</code>返回的是一个<font color="red"> const char*</font>，不能再被赋值给其他非常量指针，但是我们可以直接将<code>str.c_str()</code>当作<code>char*</code>来使用，如：<code>str.c_str()[1]</code>，即通过<code>char*</code>指针访问str中的第二个元素。</p><h3 id="string类中一些常用函数"><a href="#string类中一些常用函数" class="headerlink" title="string类中一些常用函数"></a>string类中一些常用函数</h3><table><thead><tr><th></th><th>函数名</th><th>作用</th></tr></thead><tbody><tr><td>复制</td><td>str.copy(char *buf,int cout)</td><td>从字符串str中拷贝cout个字符到char数组buf中</td></tr><tr><td>连接</td><td>str.append(string strs)</td><td>将字符串strs连接到str之后，支持string和char*</td></tr><tr><td>查找</td><td>int str.find(char *strs,int index)</td><td>从字符串str中的第index索引开始查找strs子串或字符，返回查找到的第一个匹配值的索引，返回的索引也可以使用迭代器来接收</td></tr><tr><td>替换</td><td>str.replace(int index,int length,char *strs)</td><td>在字符串str中，从index索引开始用strs字符串替换length个长度的子串</td></tr><tr><td>删除</td><td>str.erase(int index,int length)</td><td>删除字符出str从index位置开始的length长度的字符</td></tr><tr><td>插入</td><td>str.insert(int index,char *strs)</td><td>从str字符串的index位置开始插入字串strs</td></tr></tbody></table><h3 id="string类中常用算法函数"><a href="#string类中常用算法函数" class="headerlink" title="string类中常用算法函数"></a>string类中常用算法函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;string_str_io_stdsfx.h_iostream&quot;</span>;<br>transform(str.begin(), str.end(), str.begin(), <span class="hljs-built_in">toupper</span>);<br><span class="hljs-built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure><p>transform算法包含在<code>#include &lt;algorithm&gt;</code>头文件中</p><p><strong>transform算法的使用：</strong></p><p><strong>原型：</strong>transform(first,last,result,op);</p><p>first是容器的首迭代器，last为容器的末迭代器，result为存放结果的容器，op为要进行操作的一元函数对象或sturct、class。</p><p><strong>代码解释：</strong>str.begin()返回一个指向str首部位置的迭代器，str.end()返回一个指向str尾部位置的迭代器，因为我们把输出结果继续存放在str中，且迭代器始于容器相联系的，所以存放结果的容器也是str.begin()，而我们对str做的操作是将小写字母装换为大写，C++提供了标准的转换函数,所以操作函数为toupper。</p><p><strong>transform算法的另一个重载形式：</strong></p><p><strong>原型：</strong>transform(first1,last1,first2,result,binary_op);</p><p>first1是第一个容器的首迭代 器，last1为第一个容器的末迭代器，first2为第二个容器的首迭代器，result为存放结果的容器，binary_op为要进行操作的二元函数 对象或sturct、class。</p><p>需要注意的是，两个容器first1和first2中的元素数量必须相等，否则会抛异常。</p><h2 id="4-vector容器"><a href="#4-vector容器" class="headerlink" title="4.vector容器"></a>4.vector容器</h2><ul><li>vector是将元素置于一个<font color="red"> <strong>动态数组</strong></font>中加以管理的容器</li><li>vector支持随机存取元素，支持索引存取（[],at()）和迭代器存取</li><li>vector在尾部添加和移除元素速度快，在中部和头部速度慢</li><li>使用vector容易需要包含<code>#include&lt;vector&gt;</code>头文件</li></ul><h3 id="vector常用方法"><a href="#vector常用方法" class="headerlink" title="vector常用方法"></a>vector常用方法</h3><table>  <tr>    <th> </th>    <th>函数</th>    <th>作用</th>  </tr>  <tr>    <td rowspan="4">读取与赋值</td>    <td>front(void)</td>    <td>获取容器首元素，既可以作左值也可以作右值</td>  </tr>  <tr>    <td>back(void)</td>    <td>获取容器尾元素，既可以作左值也可以作右值</td>  </tr>  <tr>    <td>push_back(T t)</td>    <td>在容器的尾部添加元素</td>  </tr>  <tr>    <td>pop_back(T t)</td>    <td>删除容器最后一个元素</td>   </tr>  <tr>    <td rowspan="4">只读</td>    <td>begin(void)</td>    <td>获取容器首部迭代器</td>   </tr>  <tr>    <td>end(void)</td>    <td>获取容器尾部迭代器</td>   </tr>  <tr>    <td>rbegin(void)</td>    <td>获取逆序首部迭代器，实际指向容器的尾部，只能使用vector&#60int&#62::reverse_iterator逆序迭代器接收</td>   </tr>  <tr>    <td>rend(void)</td>    <td>获取逆序尾部部迭代器，实际指向容器的首部，只能使用vector&#60int&#62::reverse_iterator逆序迭代器接收</td>   </tr>  <tr>    <td rowspan="2">删除</td>    <td>erase(iterator pos)</td>    <td>删除迭代器pos指向位置的元素</td>   </tr>  <tr>    <td>erase(iterator begin,iterator end)</td>    <td>从迭代器begin指向位置开始到end指向位置结束，区间删除元素</td>   </tr>  <tr>    <td>插入</td>    <td>insert(iterator pos,T t)</td>    <td>在pos迭代器指向的位置插入元素t，insert中的迭代器pos只能是begin()或end()否则会报错，似乎不止其他的迭代器</td>   </tr>    <td>判空</td>    <td>empty(void)</td>    <td>容器判空</td>   </table>### Vector浅析<p>vector的最重要的实现组成其实只有三个指针，上源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// CLASS TEMPLATE vector</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> _<span class="hljs-title">Ty</span>,<span class="hljs-keyword">class</span> _<span class="hljs-title">Alloc</span> =</span> allocator&lt;_Ty&gt;&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">vector</span> :</span> <span class="hljs-keyword">public</span> _Vector_alloc&lt;_Vec_base_types&lt;_Ty, _Alloc&gt;&gt;<br>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>类体这里就省略了，如果仔细看源码就会发现vector的类体里主要实现的大多只是一些供外部调用的函数而已，而vector的最底层的一些实现其实在它的基类中就已经完成了，如<code>_Vector_alloc</code>类，而<code>_Vector_alloc</code>中也没有包含最重要的三个指针，我们在vector.cpp中搜索<code>_Myfirst</code>可以发现，<code>_Myfirst</code>,<code>_Mylast</code>,<code>_Myend</code>三个指针在<code>_Vector_val</code>这个类中，而<code>_Vector_alloc</code>中包含了对<code>_Vector_val</code>的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// CLASS TEMPLATE _Vector_val</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> _<span class="hljs-title">Val_types</span>&gt;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> _<span class="hljs-title">Vector_val</span> :</span> <span class="hljs-keyword">public</span> _Container_base<br>&#123;<span class="hljs-comment">// base class for vector to hold data</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">using</span> value_type = <span class="hljs-keyword">typename</span> _Val_types::value_type;<br><span class="hljs-keyword">using</span> size_type = <span class="hljs-keyword">typename</span> _Val_types::size_type;<br><span class="hljs-keyword">using</span> difference_type = <span class="hljs-keyword">typename</span> _Val_types::difference_type;<br><span class="hljs-keyword">using</span> pointer = <span class="hljs-keyword">typename</span> _Val_types::pointer;<br><span class="hljs-keyword">using</span> const_pointer = <span class="hljs-keyword">typename</span> _Val_types::const_pointer;<br><span class="hljs-keyword">using</span> reference = value_type&amp;;<br><span class="hljs-keyword">using</span> const_reference = <span class="hljs-keyword">const</span> value_type&amp;;<br><br>_Vector_val()<br>: _Myfirst(),<br>_Mylast(),<br>_Myend()<br>&#123;<span class="hljs-comment">// initialize values</span><br>&#125;<br><br>pointer _Myfirst;<span class="hljs-comment">// pointer to beginning of array</span><br>pointer _Mylast;<span class="hljs-comment">// pointer to current end of sequence</span><br>pointer _Myend;<span class="hljs-comment">// pointer to end of array</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在vector中有两个关键的数字，<font color="red">size与capacity</font>，其中<code>size=_Mylast-_Myfirst</code>，<code>capacity=_Myend-Myfirst</code>，三个指针指向的内存位置如下：</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210330094505.png"></p><p>size的计算源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">_NODISCARD size_type <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// return length of sequence</span><br><span class="hljs-keyword">return</span> (<span class="hljs-keyword">static_cast</span>&lt;size_type&gt;(<span class="hljs-keyword">this</span>-&gt;_Mylast() - <span class="hljs-keyword">this</span>-&gt;_Myfirst()));<br>&#125;<br></code></pre></td></tr></table></figure><p>capacity的计算源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">_NODISCARD size_type <span class="hljs-title">capacity</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// return current length of allocated storage</span><br><span class="hljs-keyword">return</span> (<span class="hljs-keyword">static_cast</span>&lt;size_type&gt;(<span class="hljs-keyword">this</span>-&gt;_Myend() - <span class="hljs-keyword">this</span>-&gt;_Myfirst()));<br>&#125;<br></code></pre></td></tr></table></figure><p>我们都知道vector的性能优越，而支撑着vector的优越性能的就是这两数据，size和capacity，size是vector中实际元素的个数，即vector总容量中的已用容量(used部分)，而capacity则是vector初始化时设置的总容量(等于used部分加unsed部分)，C++分配给vector的实际内存总是比定义时的要大一点，这是因为vector占用的内存是一整块连续的内存，预分配多一些内存可以降低vector之后的二次分配时的时间成本。所以capacity&gt;=size，档capacity=size时表示容易已满，若需要继续添加元素则需要整体移动vector，此时花费的成本会较高，所以种情况应尽量避免。</p><h2 id="5-deque容器"><a href="#5-deque容器" class="headerlink" title="5.deque容器"></a>5.deque容器</h2><ul><li>deque容器是一个双端数组，在双端数组的两端均可以插入和删除元素</li><li>使用deque容器需要包头文件<code>#include&lt;deque&gt;</code></li></ul><p>deque容器可以说是vector容器的升级版，deque的用法基本和vector一致，但是deque不仅提供push_back()，pop_back()还提供<font color="red"> <strong>push_front()</strong></font> 和<font color="red"> <strong>pop_front()</strong></font>。</p><h2 id="6-stack容器"><a href="#6-stack容器" class="headerlink" title="6.stack容器"></a>6.stack容器</h2><ul><li>stack容器是一个栈模型</li><li>使用stack容器需要包含头文件<code>#include&lt;stack&gt;</code></li></ul><h3 id="stack常用方法"><a href="#stack常用方法" class="headerlink" title="stack常用方法"></a>stack常用方法</h3><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>push(T t)</td><td>元素入栈顶</td></tr><tr><td>pop()</td><td>栈顶元素出栈</td></tr><tr><td>top()</td><td>获取栈顶元素</td></tr></tbody></table><h2 id="7-queue容器"><a href="#7-queue容器" class="headerlink" title="7.queue容器"></a>7.queue容器</h2><ul><li>queue容器是一个队列模型</li><li>使用queue容器需要包含头文件<code>#include&lt;queue&gt;</code></li></ul><h3 id="queue常用方法"><a href="#queue常用方法" class="headerlink" title="queue常用方法"></a>queue常用方法</h3><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>push(T t)</td><td>元素入队尾</td></tr><tr><td>pop()</td><td>队首元素出队</td></tr><tr><td>front()</td><td>获取队首元素，既可以作左值也可以作右值</td></tr><tr><td>back()</td><td>获取队尾元素，既可以作左值也可以作右值</td></tr></tbody></table><h2 id="8-list容器"><a href="#8-list容器" class="headerlink" title="8.list容器"></a>8.list容器</h2><ul><li>list容器是一个双向链表模型，可以高效的进行元素的插入和删除操作</li><li>list容器不支持随机访问，即不支持[],at()和iterator + n(如：begin()+1)等形式的访问</li><li>使用list容器需要包含头文件<code>#include&lt;list&gt;</code></li></ul><p>list容器除了不支持随机访问外，用法和deque容器的用法基本一致，除此之外list容器还提供一个<font color="red"> <strong>remove(T t)</strong></font>函数来根据元素内容删除元素</p><p>使用list容器时有一点需要注意<font color="red"> <strong>list容器在使用erase删除元素时，遵循左闭右开的原则</strong></font>，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; li;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>li.push_back(i);<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it = li.begin(); it != li.end(); it++)<br><span class="hljs-built_in">cout</span> &lt;&lt; *it;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it1 = li.begin();<span class="hljs-comment">//it1指向元素0</span><br><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it2 = li.begin();<br>it2++; it2++; it2++;<span class="hljs-comment">//此时it2指向元素3</span><br>li.erase(it1, it2);<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it = li.begin(); it != li.end(); it++)<br><span class="hljs-built_in">cout</span> &lt;&lt; *it;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">01234<br>34<br></code></pre></td></tr></table></figure><p>可以看到erase在删除0-3的元素时删除了0，1，2而没有删除3，即左闭右开。</p><h3 id="list浅析"><a href="#list浅析" class="headerlink" title="list浅析"></a>list浅析</h3><p>list在实现结构上和vector很类似，只是list比vector多了一个<code>_List_buy</code>中间层，list的实现的核心组成有两个，<code>_List_val</code>和<code>_List_node</code>前者主要与数据结构规模和头节点相关，后者主要与数据存储、prev和next相关。上<code>_List_val</code>的源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> _<span class="hljs-title">Val_types</span>&gt;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> _<span class="hljs-title">List_val</span> :</span> <span class="hljs-keyword">public</span> _Container_base<br>&#123;<span class="hljs-comment">// base class for list to hold data</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">using</span> _Nodeptr = <span class="hljs-keyword">typename</span> _Val_types::_Nodeptr;<br><br><span class="hljs-keyword">using</span> value_type = <span class="hljs-keyword">typename</span> _Val_types::value_type;<br><span class="hljs-keyword">using</span> size_type = <span class="hljs-keyword">typename</span> _Val_types::size_type;<br><span class="hljs-keyword">using</span> difference_type = <span class="hljs-keyword">typename</span> _Val_types::difference_type;<br><span class="hljs-keyword">using</span> pointer = <span class="hljs-keyword">typename</span> _Val_types::pointer;<br><span class="hljs-keyword">using</span> const_pointer = <span class="hljs-keyword">typename</span> _Val_types::const_pointer;<br><span class="hljs-keyword">using</span> reference = value_type&amp;;<br><span class="hljs-keyword">using</span> const_reference = <span class="hljs-keyword">const</span> value_type&amp;;<br><br>_List_val()<br>: _Myhead(),<br>_Mysize(<span class="hljs-number">0</span>)<br>&#123;<span class="hljs-comment">// initialize data</span><br>&#125;<br><br>_Nodeptr _Myhead;<span class="hljs-comment">// pointer to head node</span><br>size_type _Mysize;<span class="hljs-comment">// number of elements</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到list中包含了一个指向头节点的指针<code>_Myhead</code>，也就是说即使我们创建的一个空list也至少包含一个空的头节点，list使用头节点的目的就是更方便的构建容器，<code>_Mysize</code>记录的就是list的当前元素个数。</p><p>list节点_List_node`的底层数据结构是一个结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> _<span class="hljs-title">Value_type</span>,<span class="hljs-keyword">class</span> _<span class="hljs-title">Voidptr</span>&gt;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">List_node</span></span><br><span class="hljs-class">&#123;</span><span class="hljs-comment">// list node</span><br><span class="hljs-keyword">using</span> _Nodeptr = _Rebind_pointer_t&lt;_Voidptr, _List_node&gt;;<br>_Nodeptr _Next;<span class="hljs-comment">// successor node, or first element if head</span><br>_Nodeptr _Prev;<span class="hljs-comment">// predecessor node, or last element if head</span><br>_Value_type _Myval;<span class="hljs-comment">// the stored value, unused if head</span><br><br>_List_node&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> _List_node&amp;) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> _<span class="hljs-title">Alloc</span>&gt;</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> _Freenode0(_Alloc&amp; _Al, _Nodeptr _Ptr) <span class="hljs-keyword">noexcept</span><br>&#123;<br><span class="hljs-keyword">using</span> _Alnode = _Rebind_alloc_t&lt;_Alloc, _List_node&gt;;<br><span class="hljs-keyword">using</span> _Alnode_traits = allocator_traits&lt;_Alnode&gt;;<br>_Alnode _Node_alloc(_Al);<br>_Alnode_traits::destroy(_Node_alloc, _STD addressof(_Ptr-&gt;_Next));<br>_Alnode_traits::destroy(_Node_alloc, _STD addressof(_Ptr-&gt;_Prev));<br>_Alnode_traits::deallocate(_Node_alloc, _Ptr, <span class="hljs-number">1</span>);<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>_List_node</code>的核心组成就是<code>_Next</code>，<code>_Prev</code>，<code>_Myval</code>，<code>_Next</code>是下一个节点的指针，<code>_Prev</code>是指向上一个节点的指针，<code>_Myval</code>是存储数据的容器。</p><h2 id="9-priority-queue容器"><a href="#9-priority-queue容器" class="headerlink" title="9.priority_queue容器"></a>9.priority_queue容器</h2><ul><li><p><code>priority_queue</code>容器是一个具有优先级的队列，又叫优先级队列适配器，分为最大优先级队列和最小优先级队列两种</p></li><li><p>priority_queue容器是一种特殊的queue容器，所以也需要包含头文件<code>#include&lt;queue&gt;</code></p></li></ul><p>默认的定义<code>priority_queue&lt;T&gt; pr</code>的优先级队列是最大优先级队列，显示定义最小优先级队列：<code>priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt; pr</code>，<code>less</code>是一个谓词后面再学习，显示定义最大优先级队列：<code>priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; pr</code>，其中使用<code>greater</code>需要包含头文件<code>#include&lt;functional&gt;</code>。</p><p><code>priority_queue</code>容器的用法基本和<code>queue</code>一致，除此之外，<code>priority_queue</code>容器提供一个<code>top()</code>函数来获取队首元素，而<code>queue</code>容器没有这个方法。</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;,greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; pr;<br>pr.push(<span class="hljs-number">12</span>);<br>pr.push(<span class="hljs-number">4</span>);<br>pr.push(<span class="hljs-number">10</span>);<br>pr.push(<span class="hljs-number">20</span>);<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;最小元素：&quot;</span> &lt;&lt;pr.top() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">while</span> (pr.size() &gt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; pr.top() &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>;<br>pr.pop();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">最小元素：<span class="hljs-number">4</span><br><span class="hljs-number">4,10,12,20</span>,<br></code></pre></td></tr></table></figure><h2 id="10-set容器"><a href="#10-set容器" class="headerlink" title="10.set容器"></a>10.set容器</h2><ul><li><code>set</code>是一个<font color="red"><strong>集合</strong></font>容器，其中所包含的元素是<font color="red"><strong>唯一</strong></font>的，<font color="red"><strong>集合中的元素按一定的顺序排序</strong></font>，元素的插入过程是按排序规则插入，所以不能指定位置插入</li><li><code>set</code>采用红黑树变体的数据结构实现，红黑树属于平衡二叉树，在插入和删除操作上比<code>vector</code>容器速度更快</li><li><code>set</code>容器不支持[]和at()来存取元素</li><li><font color="red"><strong>set不支持直接修改容器中的元素</strong></font>，因为元素是自动排序的，如果希望修改一个元素值，就必须删除这个元素再插入新元素</li><li>要使用<code>set</code>容器需要包含头文件<code>#include&lt;set&gt;</code></li></ul><h3 id="set容器的基本特性"><a href="#set容器的基本特性" class="headerlink" title="set容器的基本特性"></a>set容器的基本特性</h3><p>默认情况下，直接定义的set容器采用最小优先排序，和priority_queue容器恰好相反，<code>set&lt;T&gt; se</code>就是隐式的<code>set&lt;T,less&lt;T&gt;&gt; se</code>，定义最大优先排序的set容器需要显示定义：<code>set&lt;T,greater&lt;T&gt;&gt; se</code>。</p><p>我们来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">string</span>,greater&lt;<span class="hljs-built_in">string</span>&gt;&gt; se;<span class="hljs-comment">//采用最大优先排序</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<span class="hljs-comment">//生成随机字符串元素</span><br>&#123;<br><span class="hljs-keyword">int</span> tmp = rand();<br><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">while</span> (str.length()&lt;=<span class="hljs-number">3</span>)<br>&#123;<br><span class="hljs-keyword">if</span>(tmp &gt;= <span class="hljs-number">97</span> &amp;&amp; tmp &lt;= <span class="hljs-number">122</span>)<br>str += tmp;<br>tmp = rand();<br>&#125;<br>se.insert(str);<br>&#125;<br>se.insert(<span class="hljs-string">&quot;strs&quot;</span>);<span class="hljs-comment">//插入相同的字符串元素</span><br>se.insert(<span class="hljs-string">&quot;strs&quot;</span>);<br>se.insert(<span class="hljs-string">&quot;strs&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">string</span>, greater&lt;<span class="hljs-built_in">string</span>&gt;&gt;::iterator it = se.begin(); it != se.end(); it++)<br><span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">wqye</span><br><span class="hljs-symbol">vfep</span><br><span class="hljs-symbol">strs</span><br><span class="hljs-symbol">omsk</span><br><span class="hljs-symbol">kfnm</span><br><span class="hljs-symbol">cdsb</span><br></code></pre></td></tr></table></figure><p>可以看到，容器里的字符串确实按照字符串的比较规则按从大到小的顺序排列着，并且无论我们插入多少个相同的元素，在容器内只会存储一个相同的元素值。</p><p>值得注意的是：</p><p><code>set</code>容器只提供了<code>insert(T t)</code>函数来插入元素。</p><h3 id="自定义元素的排序"><a href="#自定义元素的排序" class="headerlink" title="自定义元素的排序"></a>自定义元素的排序</h3><p>自定义类作元素可能会出现类中有多个字段，而我们需要其中的某一个字段来作为关键字在<code>set</code>容器中排序，要实现这样的行为，我们就需要用到<font color="red"><strong>仿函数</strong></font>了。</p><h4 id="什么是仿函数？"><a href="#什么是仿函数？" class="headerlink" title="什么是仿函数？"></a>什么是仿函数？</h4><p>仿函数实质上就是一个做了<code>()</code>重载的结构体，因为重载了<code>()</code>使用起来类似函数，所以称之为仿函数。</p><p>我们来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">string</span> name;<br><span class="hljs-keyword">int</span> age;<br><span class="hljs-keyword">bool</span> isStudent;<br>Student(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> name, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> age, <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> isStudent)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;age = age;<br><span class="hljs-keyword">this</span>-&gt;name = name;<br><span class="hljs-keyword">this</span>-&gt;isStudent = isStudent;<br>&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AgeSort</span>//仿函数</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Student &amp;lift, <span class="hljs-keyword">const</span> Student &amp;right)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> (lift.age &lt; right.age);<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">set</span>&lt;Student, AgeSort&gt; se;<br><span class="hljs-function">Student <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;Alian&quot;</span>, <span class="hljs-number">23</span>, <span class="hljs-literal">true</span>)</span></span>;<br><span class="hljs-function">Student <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-string">&quot;Blank&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-literal">true</span>)</span></span>;<br><span class="hljs-function">Student <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-string">&quot;Cary&quot;</span>, <span class="hljs-number">43</span>, <span class="hljs-literal">false</span>)</span></span>;<br><span class="hljs-function">Student <span class="hljs-title">s4</span><span class="hljs-params">(<span class="hljs-string">&quot;Davel&quot;</span>, <span class="hljs-number">23</span>, <span class="hljs-literal">true</span>)</span></span>;<br>se.insert(s1); se.insert(s2);<br>se.insert(s3); se.insert(s4);<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">set</span>&lt;Student, AgeSort&gt;::iterator it = se.begin(); it != se.end(); it++)<br><span class="hljs-built_in">cout</span> &lt;&lt; it-&gt;name &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; it-&gt;age &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; it-&gt;isStudent &lt;&lt; <span class="hljs-built_in">endl</span>;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Blank</span>   <span class="hljs-number">20</span>      <span class="hljs-number">1</span><br><span class="hljs-attribute">Alian</span>   <span class="hljs-number">23</span>      <span class="hljs-number">1</span><br><span class="hljs-attribute">Cary</span>    <span class="hljs-number">43</span>      <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>其中<code>AgeSort</code>就是仿函数，它的比较关键字是<code>Student.age</code>，所以<code>set</code>容器对象se会以age作为排序关键字，其实我们之前使用的<code>less&lt;&gt;</code>和<code>greater&lt;&gt;</code>也是反函数，只不过是C++预定义好的仿函数。</p><p>细心的朋友可能会发现，我们插入的s4对象居然不再容器里！！！这是因为set容器中的元素具有唯一性，而set容器是通过关键字来识别元素的，所当碰到关键字相同的元素时，set只会存储一个元素。</p><p>那么这种情况该怎么解决呢？答案是set容器没有办法解决这种情况，如果有出现这种情况，就不能使用set容器而改用multiset容器。</p><p>在后面的算法模块我们详细介绍仿函数。</p><h3 id="set常用函数"><a href="#set常用函数" class="headerlink" title="set常用函数"></a>set常用函数</h3><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>find(T t)</td><td>查找元素t，返回指向t元素的迭代器，查找失败返回指向set.end()的迭代器</td></tr><tr><td>count(T t)</td><td>返回容器中元素t的个数，值要么是0，要么是1</td></tr><tr><td>lower_bound(T t)</td><td>返回一个指向&gt;=t元素的迭代器，如果t存在则指向t，如果t不存在则指向t后面的一个元素</td></tr><tr><td>upper_bound(T t)</td><td>返回一个指向&gt;t元素的迭代器，即t元素后面的一个元素</td></tr><tr><td>equal_range(T t)</td><td>返回一个包含两个set类型的迭代器的对组pair&lt;set<T>::iterator,set<T>::iterator&gt;第一个迭代器指向t元素，第二个迭代器指向t后面的一个元素，如果t不存在，则两个迭代器都指向t后面的一个元素</T></T></td></tr></tbody></table><h3 id="小知识"><a href="#小知识" class="headerlink" title=" 小知识"></a><font color="blue"> 小知识</font></h3><p><font color="blue"> 事实上容器中的<code>insert</code>函数是有返回值的，<code>insert</code>的返回值是一个对组(pair)类型的泛型<code>pair&lt;set&lt;T&gt;::iterator, bool&gt;</code>的对象，<code>pair</code>是一个只有两个字段的模板，我们可以直接定义<code>pair&lt;set&lt;T&gt;::iterator, bool&gt;</code>类型对象来接收<code>insert</code>函数的返回值，如：</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">pair</span>&lt;<span class="hljs-built_in">set</span>&lt;Student,AgeSort&gt;::iterator, <span class="hljs-keyword">bool</span>&gt; pait=se.insert(s1);<br></code></pre></td></tr></table></figure><p><font color="blue"> 我们可以通过<code>pair.first</code>和<code>pair.second</code>来访问对组中的两个元素，通过<code>pair.first</code>来访问对组中的第一个元素<code>set&lt;Student,AgeSort&gt;::iterator</code>类型的迭代器，通过<code>pair.first-&gt;first</code>，和<code>pair.first-&gt;second</code>可以访问迭代器所指向的容器元素，我们通过<code>pair.second</code>来访问对组中的第二个元素，bool型的元素记录的是insert函数插入是否成功，如果插入成功则记录true，否则记录false。</font></p><h2 id="11-multiset容器"><a href="#11-multiset容器" class="headerlink" title="11.multiset容器"></a>11.multiset容器</h2><ul><li><code>multiset</code>容器可以说是set容器的升级版，multiset容器支持多个相同键值的元素的存储，所以要使用<code>multiset</code>需要包含头文件<code>#include&lt;set&gt;</code></li></ul><p>multiset的用法和set一致。</p><h2 id="12-map容器"><a href="#12-map容器" class="headerlink" title="12.map容器"></a>12.map容器</h2><ul><li><code>map</code>是标准的关联式容器，一个<code>map</code>元素是一个键值对(key,value),<code>map</code>提供基于键值的快速检索能力</li><li><code>map</code>中<font color="red"><code> key</code>值是唯一的</font></li><li><code>map</code>容器中的元素也是按一定顺序排列的，元素插入过程是按排序规则插入的，所以不能指定位置插入</li><li><code>map</code>容器的具体实现也是采用红黑二叉树变体的平衡二叉树的数据结构，在插入和删除的操作上比<code>vector</code>更快</li><li>与<code>set</code>不同的是<code>map</code>支持直接存取<code>key</code>值对应的<code>value</code>，也支持[]操作符</li><li>要使用<code>map</code>容器就需要包含头文件<code>#include&lt;map&gt;</code></li></ul><h3 id="map的元素插入"><a href="#map的元素插入" class="headerlink" title="map的元素插入"></a>map的元素插入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>&gt; ma;<br><span class="hljs-comment">//方法一</span><br>ma.insert(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;pair&quot;</span>));<br>ma.insert(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;pair_02&quot;</span>));<br><span class="hljs-comment">//方法二</span><br>ma.insert(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;make_pair&quot;</span>));<br>ma.insert(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;make_pair_02&quot;</span>));<br><span class="hljs-comment">//方法三</span><br>ma.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>&gt;::value_type(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;value_type&quot;</span>));<br>ma.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>&gt;::value_type(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;value_type_02&quot;</span>));<br><span class="hljs-comment">//方法四</span><br>ma[<span class="hljs-number">4</span>] = <span class="hljs-string">&quot;map&quot;</span>;<br>ma[<span class="hljs-number">4</span>] = <span class="hljs-string">&quot;map_02&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>&gt;::iterator it = ma.begin(); it != ma.end(); it++)<br><span class="hljs-built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="hljs-built_in">endl</span>;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>      pair<br><span class="hljs-symbol">2 </span>      make_pair<br><span class="hljs-symbol">3 </span>      value_type<br><span class="hljs-symbol">4 </span>      map_02<br></code></pre></td></tr></table></figure><p>上面四种方法都可以向map容器里添加元素，但是四者中也有一些微小的区别，前面三种方法在插入相同键值时，只会保存第一存储的结果，之后插入相同键值的元素时都会插入失败，而第四种方法则是后面赋值的元素覆盖前面赋值的元素。</p><p>map似乎没办法来指定是从大到小排序或是从小到大排序</p><p>map除了元素的形式不同，在其他方面map的用法基本和set一致</p><h2 id="13-multimap容器"><a href="#13-multimap容器" class="headerlink" title="13.multimap容器"></a>13.multimap容器</h2><p><code>multimap</code>容器和<code>multiset</code>容器一样，是<code>map</code>容器的升级版，支持一个键对应多个值，所以<code>multimap</code>的一个重要应用场景就是数据分组。</p><h2 id="14-容器在使用过程必须要注意的地方"><a href="#14-容器在使用过程必须要注意的地方" class="headerlink" title="14.容器在使用过程必须要注意的地方"></a>14.容器在使用过程必须要注意的地方</h2><p><font color="red"> 因为在将元素添加到容器里时，C++执行的是容器的默认的拷贝构造函数，将元素拷贝到容器里，这个过程是一个浅拷贝，既然是浅拷贝就会面临浅拷贝的两次内存释放的问题，尤其是类元素，所以在添加一些具有指针字段的元素到容器里时，一定在类里定义一个深拷贝的拷贝构造函数和=的重载函数。</font></p><h2 id="15-各个容器的比较"><a href="#15-各个容器的比较" class="headerlink" title="15.各个容器的比较"></a>15.各个容器的比较</h2><table><thead><tr><th></th><th>vector</th><th>deque</th><th>list</th><th>set</th><th>multiset</th><th>map</th><th>multimap</th></tr></thead><tbody><tr><td>内存结构</td><td>单端数组</td><td>双端数组</td><td>双向链表</td><td>二叉树</td><td>二叉树</td><td>二叉树</td><td>二叉树</td></tr><tr><td>随机存取</td><td>是</td><td>是</td><td>否</td><td>否</td><td>否</td><td>对key而言是</td><td>否</td></tr><tr><td>元素检索</td><td>慢</td><td>慢</td><td>非常慢</td><td>快</td><td>快</td><td>对key而言快</td><td>对key而言快</td></tr><tr><td>快速安插移除</td><td>尾端</td><td>头尾两端</td><td>任何位置</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><h1 id="三、算法"><a href="#三、算法" class="headerlink" title="三、算法"></a>三、算法</h1><h2 id="1-算法"><a href="#1-算法" class="headerlink" title="1.算法"></a>1.算法</h2><p>​    函数库对数据类型的选择对其可重用性起着至关重要的作用。举例来说，一个求方根的函数，在使用浮点数作为其参数类型的情况下的可重用性肯定比使用整型作为它的参数类性要高。而C++通过模板的机制允许推迟对某些类型的选择，直到真正想使用模板或者说对模板进行特化的时候，STL就利用了这一点提供了相当多的有用算法。它是在一个有效的框架中完成这些算法的–可以将所有的类型划分为少数的几类，然后就可以在模版的参数中使用一种类型替换掉同一种类中的其他类型。</p><p>  STL提供了大约100个实现算法的模版函数，比如算法for_ each 将为指定序列中的每一个元素调用指定的函数，stable_ _sort 以你所指定的规则对序列进行稳定性排序等等，这样一-来,只要熟悉了STL之后，许多代码可以被大大的化简，只需要通过调用一-两个算法模板，就可以完成所需要的功能并大大地提升效率。</p><p>  算法部分主要由头文件<code>&lt;algorithm&gt;</code>, <code>&lt;numeric&gt;</code>和<code>&lt;functional&gt;</code>组成。<code>&lt;algorithm&gt;</code>是所 有STL头文件中最大的一个(尽管它很好理解)，它是由一大堆模版函数组成的，可以认为每个函数在很大程度上都是独立的，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等等。<code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。<code>&lt;functional&gt;</code>中则定义了一些模板类，用以声明函数对象。</p><h2 id="2-算法的分类"><a href="#2-算法的分类" class="headerlink" title="2.算法的分类"></a>2.算法的分类</h2><h3 id="非可变序列算法"><a href="#非可变序列算法" class="headerlink" title="非可变序列算法"></a>非可变序列算法</h3><p>计数算法：count,count_if等 </p><p>搜索算法：search,find,find_if,find_list_of等</p><p>比较算法：equal,mismatch,lexicographical_compare等</p><h3 id="可变排序算法"><a href="#可变排序算法" class="headerlink" title="可变排序算法"></a>可变排序算法</h3><p>删除算法：remove,remove_if,remove_copy等</p><p>修改算法：for_each,transform等</p><p>排序算法：sort,stable_sort,partial_sort等</p><h2 id="3-仿函数"><a href="#3-仿函数" class="headerlink" title="3.仿函数"></a>3.仿函数</h2><h2 id="4-一些常用的算法模板"><a href="#4-一些常用的算法模板" class="headerlink" title="4.一些常用的算法模板"></a>4.一些常用的算法模板</h2><h3 id="find算法"><a href="#find算法" class="headerlink" title="find算法"></a>find算法</h3><p><strong>原型:</strong><code>iterator find(iterator begin,iterator end,T t)</code></p><p>在容器的begin迭代器所指向的位置开始到end所指向的位置结束，查找元素t，如果找到了，则返回指向t的迭代器。</p><h1 id="四、迭代器"><a href="#四、迭代器" class="headerlink" title="四、迭代器"></a>四、迭代器</h1><h2 id="1-迭代器"><a href="#1-迭代器" class="headerlink" title="1.迭代器"></a>1.迭代器</h2><p>​    迭代器从作用上来说是最基本的部分，可是理解起来比前两者都要费力一些。软件设计有一个基本原则，所有的问题都可以通过引进一个间接层来简化，这种简化在 STL中就是用迭代器来完成的。概括来说，迭代器在STL中用来将算法和容器联系起来，起着一种黏和剂的作用。几乎STL提供的所有算法都是通过送代器存取元素序列进行工作的，每一个容器都定义了其本身所专有的选代器，用以存取容器中的元素。</p><p>​    迭代器部分主要由头文件<code>&lt;utility&gt;</code>,<code>&lt;iterator&gt;</code>和<code>&lt;memory&gt;</code>组成。<code>&lt;utility&gt;</code>是-一个很小的头文件，它包括了贯穿使用在STL中的几个模板的声明，<code>&lt;iterator&gt;</code>中提供 了迭代器使用的许多方法，而对于<code>&lt;memory&gt;</code>的描述则十分的困难，它以不同寻常的方式为容器中的元素分配存储空间，同时也为某些算法执行期间产生的临时对象提供机制,<code>&lt;memory&gt;</code>中的主要部分是模板类<code>alocator</code>,它负责产生所有容器中的默认分配器。</p><h2 id="2-迭代器的基本原理"><a href="#2-迭代器的基本原理" class="headerlink" title="2.迭代器的基本原理"></a>2.迭代器的基本原理</h2><ul><li><p>迭代器是一个“可遍历STL容器内全部或部分元素”的对象</p></li><li><p>迭代器指出容器中的一个特定位置</p></li><li><p>迭代器就如同一个指针</p></li><li><p>迭代器提供对一个容器中的对象的访问方法，并且可以定义了容器中对象的范围</p></li></ul><h2 id="3-迭代器的分类"><a href="#3-迭代器的分类" class="headerlink" title="3.迭代器的分类"></a>3.迭代器的分类</h2><p><strong>输入迭代器</strong>:也有叫法称之为“只读迭代器”，它从容器中读取元素，只能一次读入一个元素向前移动，只支持一遍算法，同一个输入迭代器不能两遍遍历一个序列。</p><p><strong>输出迭代器</strong>:也有叫法称之为“只写迭代器”，它往容器中写入元素，只能一次写入一个元素向前移动，只支持一遍算法，同一个输出迭代器不能两遍遍历一个序列。</p><p><strong>正向迭代器</strong>:组合输入送代器和输出迭代器的功能,还可以多次解析一个迭代器指定的位置，可以对一个值进行多次读/写。</p><p><strong>双向达代器</strong>:组合正向迭代器的功能，还可以通过-操作符向后移动位置。</p><p><strong>随机访问送代器</strong>:组合双向送代器的功能，还可以向前向后跳过任意个位置，可以直接访问容器中任何位置的元素。</p><h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPlus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C++】C++函数模板的实现机制剖析</title>
    <link href="/2019/10/03/%E3%80%90C++%E3%80%91C++%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%89%96%E6%9E%90/"/>
    <url>/2019/10/03/%E3%80%90C++%E3%80%91C++%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="函数模板的实现机制剖析"><a href="#函数模板的实现机制剖析" class="headerlink" title="函数模板的实现机制剖析"></a>函数模板的实现机制剖析</h1><p>要剖析函数模板的实现机制，我们要先了解程序的编译过程，这里以gcc为例</p><p><img src="/2019/10/03/%E3%80%90C++%E3%80%91C++%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%89%96%E6%9E%90/Snipaste_2019-10-03_16-51-51.png"></p><p>这里对下面代码进行剖析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;stdafx.h&quot;</span><span class="hljs-comment">//这是VS的固有头文件</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">(T a,T b)</span></span><br><span class="hljs-function"></span>&#123;<br>a = a + b;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;我是函数模板&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Fun(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>Fun(<span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>);<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>打开控制台，使用命令生成汇编文件(当然环境变量里需要有g++编译器的路径才能这样使用，具体操作放在文末)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">g++ -S 1.cpp -o 1.s<br></code></pre></td></tr></table></figure><p>我们来查看汇编文件</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><code class="hljs pascal">.file&quot;C++.cpp&quot;<br>.lcomm __ZStL8__ioinit,<span class="hljs-number">1</span>,<span class="hljs-number">1</span><br>.def___main;.scl<span class="hljs-number">2</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>.section .rdata,&quot;dr&quot;<br>LC2:<br>.ascii &quot;pause\0&quot;<br>.text<br>.globl_main<br>.def_main;.scl<span class="hljs-number">2</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>_main:<br>LFB1062:<br>.cfi_startproc<br>pushl%ebp<br>.cfi_def_cfa_offset <span class="hljs-number">8</span><br>.cfi_offset <span class="hljs-number">5</span>, -<span class="hljs-number">8</span><br>movl%esp, %ebp<br>.cfi_def_cfa_register <span class="hljs-number">5</span><br>andl$-<span class="hljs-number">16</span>, %esp<br>subl<span class="hljs-number">$16</span>, %esp<br>call___main<span class="hljs-comment">//--------------进入main函数</span><br>movl<span class="hljs-number">$2</span>, <span class="hljs-number">4</span>(%esp)<br>movl<span class="hljs-number">$1</span>, (%esp)<br>call__Z3FunIiEvT_S0_<span class="hljs-comment">//-----第一次调用函数模板</span><br>fldlLC0<br>fstpl<span class="hljs-number">8</span>(%esp)<br>fldlLC1<br>fstpl(%esp)<br>call__Z3FunIdEvT_S0_<span class="hljs-comment">//-----第二次调用函数模板</span><br>movl$LC2, (%esp)<br>call_system<br>movl<span class="hljs-number">$0</span>, %eax<br>leave<br>.cfi_restore <span class="hljs-number">5</span><br>.cfi_def_cfa <span class="hljs-number">4</span>, <span class="hljs-number">4</span><br>ret<br>.cfi_endproc<br>LFE1062:<br>.section .rdata,&quot;dr&quot;<br>LC4:<br>.ascii &quot;\316\322\312\307\272\257\312\375\304\243\260\345\0&quot;<br>.section.text$_Z3FunIiEvT_S0_,&quot;x&quot;<br>.linkonce discard<br>.globl__Z3FunIiEvT_S0_<br>.def__Z3FunIiEvT_S0_;.scl<span class="hljs-number">2</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>__Z3FunIiEvT_S0_:<span class="hljs-comment">//------------第一次调用时函数模板的具体实现</span><br>LFB1063:<br>.cfi_startproc<br>pushl%ebp<br>.cfi_def_cfa_offset <span class="hljs-number">8</span><br>.cfi_offset <span class="hljs-number">5</span>, -<span class="hljs-number">8</span><br>movl%esp, %ebp<br>.cfi_def_cfa_register <span class="hljs-number">5</span><br>subl<span class="hljs-number">$24</span>, %esp<br>movl<span class="hljs-number">12</span>(%ebp), %eax<br>addl%eax, <span class="hljs-number">8</span>(%ebp)<br>movl$LC4, 4(%esp)<br>movl$__ZSt4cout, (%esp)<br>call__ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc<br>movl$__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_, (%esp)<br>movl%eax, %ecx<br>call__ZNSolsEPFRSoS_E<br>subl<span class="hljs-number">$4</span>, %esp<br>nop<br>leave<br>.cfi_restore <span class="hljs-number">5</span><br>.cfi_def_cfa <span class="hljs-number">4</span>, <span class="hljs-number">4</span><br>ret<br>.cfi_endproc<br>LFE1063:<br>.section.text$_Z3FunIdEvT_S0_,&quot;x&quot;<br>.linkonce discard<br>.globl__Z3FunIdEvT_S0_<span class="hljs-comment">//-第二次调用时函数模板的具体实现</span><br>.def__Z3FunIdEvT_S0_;.scl<span class="hljs-number">2</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>__Z3FunIdEvT_S0_:<br>LFB1064:<br>.cfi_startproc<br>pushl%ebp<br>.cfi_def_cfa_offset <span class="hljs-number">8</span><br>.cfi_offset <span class="hljs-number">5</span>, -<span class="hljs-number">8</span><br>movl%esp, %ebp<br>.cfi_def_cfa_register <span class="hljs-number">5</span><br>subl<span class="hljs-number">$40</span>, %esp<br>movl<span class="hljs-number">8</span>(%ebp), %eax<br>movl%eax, -<span class="hljs-number">16</span>(%ebp)<br>movl<span class="hljs-number">12</span>(%ebp), %eax<br>movl%eax, -<span class="hljs-number">12</span>(%ebp)<br>movl<span class="hljs-number">16</span>(%ebp), %eax<br>movl%eax, -<span class="hljs-number">24</span>(%ebp)<br>movl<span class="hljs-number">20</span>(%ebp), %eax<br>movl%eax, -<span class="hljs-number">20</span>(%ebp)<br>fldl-<span class="hljs-number">16</span>(%ebp)<br>faddl-<span class="hljs-number">24</span>(%ebp)<br>fstpl-<span class="hljs-number">16</span>(%ebp)<br>movl$LC4, 4(%esp)<br>movl$__ZSt4cout, (%esp)<br>call__ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc<br>movl$__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_, (%esp)<br>movl%eax, %ecx<br>call__ZNSolsEPFRSoS_E<br>subl<span class="hljs-number">$4</span>, %esp<br>nop<br>leave<br>.cfi_restore <span class="hljs-number">5</span><br>.cfi_def_cfa <span class="hljs-number">4</span>, <span class="hljs-number">4</span><br>ret<br>.cfi_endproc<br>LFE1064:<br>.text<br>.def___tcf_0;.scl<span class="hljs-number">3</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>___tcf_0:<br>LFB1074:<br>.cfi_startproc<br>pushl%ebp<br>.cfi_def_cfa_offset <span class="hljs-number">8</span><br>.cfi_offset <span class="hljs-number">5</span>, -<span class="hljs-number">8</span><br>movl%esp, %ebp<br>.cfi_def_cfa_register <span class="hljs-number">5</span><br>subl<span class="hljs-number">$8</span>, %esp<br>movl$__ZStL8__ioinit, %ecx<br>call__ZNSt8ios_base4InitD1Ev<br>leave<br>.cfi_restore <span class="hljs-number">5</span><br>.cfi_def_cfa <span class="hljs-number">4</span>, <span class="hljs-number">4</span><br>ret<br>.cfi_endproc<br>LFE1074:<br>.def__Z41__static_initialization_and_destruction_0ii;.scl<span class="hljs-number">3</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>__Z41__static_initialization_and_destruction_0ii:<br>LFB1073:<br>.cfi_startproc<br>pushl%ebp<br>.cfi_def_cfa_offset <span class="hljs-number">8</span><br>.cfi_offset <span class="hljs-number">5</span>, -<span class="hljs-number">8</span><br>movl%esp, %ebp<br>.cfi_def_cfa_register <span class="hljs-number">5</span><br>subl<span class="hljs-number">$24</span>, %esp<br>cmpl<span class="hljs-number">$1</span>, <span class="hljs-number">8</span>(%ebp)<br>jneL8<br>cmpl<span class="hljs-number">$65535</span>, <span class="hljs-number">12</span>(%ebp)<br>jneL8<br>movl$__ZStL8__ioinit, %ecx<br>call__ZNSt8ios_base4InitC1Ev<br>movl$___tcf_0, (%esp)<br>call_atexit<br>L8:<br>nop<br>leave<br>.cfi_restore <span class="hljs-number">5</span><br>.cfi_def_cfa <span class="hljs-number">4</span>, <span class="hljs-number">4</span><br>ret<br>.cfi_endproc<br>LFE1073:<br>.def__GLOBAL__sub_I_main;.scl<span class="hljs-number">3</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>__GLOBAL__sub_I_main:<br>LFB1075:<br>.cfi_startproc<br>pushl%ebp<br>.cfi_def_cfa_offset <span class="hljs-number">8</span><br>.cfi_offset <span class="hljs-number">5</span>, -<span class="hljs-number">8</span><br>movl%esp, %ebp<br>.cfi_def_cfa_register <span class="hljs-number">5</span><br>subl<span class="hljs-number">$24</span>, %esp<br>movl<span class="hljs-number">$65535</span>, <span class="hljs-number">4</span>(%esp)<br>movl<span class="hljs-number">$1</span>, (%esp)<br>call__Z41__static_initialization_and_destruction_0ii<br>leave<br>.cfi_restore <span class="hljs-number">5</span><br>.cfi_def_cfa <span class="hljs-number">4</span>, <span class="hljs-number">4</span><br>ret<br>.cfi_endproc<br>LFE1075:<br>.section.ctors,&quot;w&quot;<br>.align <span class="hljs-number">4</span><br>.long__GLOBAL__sub_I_main<br>.section .rdata,&quot;dr&quot;<br>.align <span class="hljs-number">8</span><br>LC0:<br>.long-<span class="hljs-number">1717986918</span><br>.long<span class="hljs-number">1070176665</span><br>.align <span class="hljs-number">8</span><br>LC1:<br>.long-<span class="hljs-number">1717986918</span><br>.long<span class="hljs-number">1069128089</span><br>.ident&quot;GCC: (i686-posix-dwarf-rev0, Built by MinGW-W64 project) 5.3.0&quot;<br>.def_system;.scl<span class="hljs-number">2</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>.def__ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc;.scl<span class="hljs-number">2</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>.def__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_;.scl<span class="hljs-number">2</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>.def__ZNSolsEPFRSoS_E;.scl<span class="hljs-number">2</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>.def__ZNSt8ios_base4InitD1Ev;.scl<span class="hljs-number">2</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>.def__ZNSt8ios_base4InitC1Ev;.scl<span class="hljs-number">2</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>.def_atexit;.scl<span class="hljs-number">2</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br></code></pre></td></tr></table></figure><p>可以看到，在汇编码中编译器将模板<code>void Fun(T a,T b)</code>分别针对类型<code>int</code>和类型<code>float</code>进行了两次具体实现，这不是和没有使用模板，直接写两个函数一样么？没错就是一样的，只是C++将这个工作交从程序员手里移交给了编译器来做。</p><p>事实上C++对函数模板进行了<font color="red">两次编译</font>，第一次编译仅仅生成一个函数头，第二次编译则是在函数调用时根据模板的类型参数列表具体的实现这个模板对应的类型的函数实例，注意这里是根据类型参数列表来实现，而不是根据调用次数，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">Fun(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>Fun(<span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>);<br></code></pre></td></tr></table></figure><p>编译器实现两个模板实例<code>int</code>和<code>float</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">Fun(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>Fun(<span class="hljs-number">3</span> ,<span class="hljs-number">4</span>);<br>Fun(<span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>);<br></code></pre></td></tr></table></figure><p>编译器还是实现两个模板实例<code>int</code>和<code>float</code></p><p>由此可以看出</p><p><font color="red"> 编译器并不是把函数模板处理成能够处理任意类的函数</font></p><p><font color="red">编译器将函数模板根据具体类型产生不同的函数</font></p><p><font color="red">编译器会对函数模板进行两次编译，在申明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。</font></p><p>g++命令的使用</p><p>首先电脑里要有g++这个软件，我这里使用的是Qt里集成的g++软件</p><p><img src="/2019/10/03/%E3%80%90C++%E3%80%91C++%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%89%96%E6%9E%90/Snipaste_2019-10-03_19-57-21.png"></p><p>然后右键我的电脑–&gt;属性–&gt;高级环境设置–&gt;环境变量–&gt;系统变量/Path–&gt;编辑</p><p><img src="/2019/10/03/%E3%80%90C++%E3%80%91C++%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%89%96%E6%9E%90/Snipaste_2019-10-03_20-07-41.png"></p><p>再然后新建–&gt;将g++.exe所在的路径拷贝到新建的环境变量中</p><p><img src="/2019/10/03/%E3%80%90C++%E3%80%91C++%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%89%96%E6%9E%90/Snipaste_2019-10-03_20-08-21.png"></p><p>测试一下，win+r–&gt;cmd–&gt;任意目录键入g++</p><p><img src="/2019/10/03/%E3%80%90C++%E3%80%91C++%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%89%96%E6%9E%90/Snipaste_2019-10-03_20-12-24.png"></p><p>可以看到系统没有提示无此命令，说明配置成功</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPlus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C】C的typedef的妙用</title>
    <link href="/2019/10/03/%E3%80%90C%E3%80%91C%E7%9A%84typedef%E7%9A%84%E5%A6%99%E7%94%A8/"/>
    <url>/2019/10/03/%E3%80%90C%E3%80%91C%E7%9A%84typedef%E7%9A%84%E5%A6%99%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="1-自定义数组类型"><a href="#1-自定义数组类型" class="headerlink" title="1.自定义数组类型"></a>1.自定义数组类型</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">typedef int (Array)[5];<br></code></pre></td></tr></table></figure><p><code>Array</code>是一个类型为<code>int</code>长度为5的数组类型，即定义一个<code>Array a;</code>那么a就是一个类型为int长度为5的数组，所以a的使用方法和数组一致。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">typedef int(Array)[5];<br>Array a;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>,j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>a[i] = i;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,&quot;</span>, a[j]);<br></code></pre></td></tr></table></figure><h1 id="2-自定义指向数组的指针类型"><a href="#2-自定义指向数组的指针类型" class="headerlink" title="2.自定义指向数组的指针类型"></a>2.自定义指向数组的指针类型</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">typedef char(*Arrayptr)[8];<br></code></pre></td></tr></table></figure><p><code>Arrayptr</code>是一个指向<code>char</code>类型的长度为8的数组的指针类型，此类型的指针只能指向<code>char</code>类型的长度为8的数组。且每一次指针移步，移动的距离是1*8=8字节。</p><p>需要注意的是<code>()</code>不能省略，否则定义就会变义。</p><p>除了自定义指针类型来指向一个固定的数组外，C还可以直接定义一个指向固定数组的指针变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> (*p)[<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><p><code>p</code>就是一个指向类型为整型且长度为5的数组的指针变量。</p><h1 id="3-自定义函数类型"><a href="#3-自定义函数类型" class="headerlink" title="3.自定义函数类型"></a>3.自定义函数类型</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(Funptr)</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;<span class="hljs-comment">//函数类型</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Fun1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fun2</span><span class="hljs-params">(Funptr *p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, p(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Funptr *p = &amp;Fun1;<br>Fun2(p);<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Funptr</code>是一个指向返回值为<code>int</code>参数列表为<code>int,int</code>的函数的类型，通过<code>Funptr</code>函数类型的指针可以将返回值为<code>int</code>参数列表为<code>int,int</code>的函数当作参数来使用，使函数的调用更为灵活。</p><p>除了定义函数类型可以达到这种效果，我们还可以直接定义指向函数的指针类型来实现函数参数化，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*Funptr)</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Fun1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fun2</span><span class="hljs-params">(Funptr p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, p(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Funptr p = &amp;Fun1;<br>Fun2(p);<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的效果和定义函数类型是一样的。</p><p>当然我们还可以直接定义一个指向函数的指针变量，来实现同样的效果，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Fun1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fun2</span><span class="hljs-params">(Funptr p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, p(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span>(*p)(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) = &amp;Fun1;<br>Fun2(p);<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们还可以这么做，一样能达到相同的效果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Fun1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fun2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*ptr)(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b))</span><span class="hljs-comment">//直接定义函数指针的形参</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ptr(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Fun2(&amp;Fun1);<span class="hljs-comment">//直接传递函数地址</span><br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>搞了那么多似乎函数指针只是把函数的调用弄得更复杂了而已，除了把函数当作参数来使用似乎没有什么作用了，真的是如此吗？</p><p><font color="red"> 如果我们仔细观察，会发现函数指针将函数的调用和函数的实现分隔开来了，即函数指针提前规定好了函数的实现标准，这样只要后来者按照这个标准来实现函数，可以不用修改前人的代码，就能实现函数的完美的调用，这一作用在具体的项目迭代中是及其出众的。</font></p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C++】C++面向对象模型初探</title>
    <link href="/2019/10/01/%E3%80%90C++%E3%80%91C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%88%9D%E6%8E%A2/"/>
    <url>/2019/10/01/%E3%80%90C++%E3%80%91C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%88%9D%E6%8E%A2/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="1-成员的分开存储"><a href="#1-成员的分开存储" class="headerlink" title="1.成员的分开存储"></a>1.成员的分开存储</h1><p>C++通过将类的成员分开存储的方式来实现面向对象</p><table><thead><tr><th>成员</th><th>存储位置</th></tr></thead><tbody><tr><td>普通成员变量</td><td>栈区，与struct变量有相同的内存布局和字节对齐方式</td></tr><tr><td>静态成员变量</td><td>全局数据区，如此便可以使用类名和类所有的对象都可以访问</td></tr><tr><td>成员函数</td><td>代码段，包括静态成员函数和非静态成员函数</td></tr><tr><td>虚函数</td><td>虚函数表指针(vfptr)存放在栈区，其指向的虚函数表有自身的内存存储空间</td></tr></tbody></table><h1 id="2-C-类的内存分布"><a href="#2-C-类的内存分布" class="headerlink" title="2.C++类的内存分布"></a>2.C++类的内存分布</h1><p>要想更好的了解这些，我们还需了解C++类的内存分布</p><p><img src="/2019/10/01/%E3%80%90C++%E3%80%91C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%88%9D%E6%8E%A2/Snipaste_2019-10-02_09-07-09.png"></p><h2 id="Stack："><a href="#Stack：" class="headerlink" title="Stack："></a><strong>Stack：</strong></h2><p>栈，存放Automatic Variables，按内存地址由高到低方向生长，其最大大小由编译时确定，速度快，但自由性差，最大空间不大。保存程序中的局部变量。</p><h2 id="Heap："><a href="#Heap：" class="headerlink" title="Heap："></a><strong>Heap：</strong></h2><p>堆，自由申请的空间，按内存地址由低到高方向生长，其大小由系统内存/虚拟内存上限决定，速度较慢，但自由性大，可用空间大。 动态分配的内存在调用malloc（）或者相关函数产生，在调用free()时释放，由程序员决定而不是一系列规则规定内存持续时间，因此内存块可在一个函数中创建，在另一个函数中释放。由于这点，动态内存分配容易导致堆区内存碎片化。</p><h2 id="Data："><a href="#Data：" class="headerlink" title=".Data："></a><strong>.Data：</strong></h2><p> 存放程序中<font color="red"> 已经初始化的非零全局变量。静态分配。</font></p><p>data又可分为读写（RW）区域和只读（RO）区域。 </p><ul><li>RO段保存常量所以也被称为<code>.constdata</code> eg const数据</li><li>RW段则是普通非常全局变量，静态变量就在其中</li></ul><h2 id="Bss："><a href="#Bss：" class="headerlink" title=".Bss："></a><strong>.Bss：</strong></h2><p>存放程序中<strong>未初始化</strong>的和零值全局变量。静态分配，在程序开始时通常会被清零。</p><h2 id="Text："><a href="#Text：" class="headerlink" title=".Text："></a><strong>.Text：</strong></h2><p>也称为代码段(Code)，用来存放程序执行代码，同时也可能会包含一些常量(如一些字符串常量等）。该段内存为静态分配，只读(某些架构可能允许修改)。<br>这块内存是共享的,当有多个相同进程(Process)存在时，共用同一个text段。</p><hr><p>普通成员变量存储在栈区，使得每一个类的对象都拥有各自独立的普通成员变量。</p><p>静态成员变量存储在全局数据区，是的每一个类的对象都共享一份静态</p><p>成员变量。</p><h1 id="3-this指针"><a href="#3-this指针" class="headerlink" title="3.this指针"></a>3.this指针</h1><p>那么，存放在代码段的成员函数是怎么区分调用对象的呢？</p><p>事实上，<font color="red"> C++为每一个函数都隐式定义了一个函数所属类类型的指针形参–this，而this指针永远指向调用函数的对象</font>，如此函数便可以识别调用自身的是类的哪个对象了。</p><p>这里有一点要注意，<font color="red"> C++并没有为静态成员函数定义this指针，如此，静态成员函数被所有的对象共享</font>。</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h1><p>通过成员的分开存储和普通成员函数的<code>this指针</code>C++便可以识别各个不同的对象，如此便实现了面向对象。</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPlus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【shell】shell基础</title>
    <link href="/2019/09/30/%E3%80%90shell%E3%80%91shell%E5%9F%BA%E7%A1%80/"/>
    <url>/2019/09/30/%E3%80%90shell%E3%80%91shell%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>由于本文内有大量的markdwon转义未处理，导致远程同步不通过，所以本文引入外部ULR预览</p><p><a href="https://blog.csdn.net/qq_39108291/article/details/101797244">https://blog.csdn.net/qq_39108291/article/details/101797244</a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C++】C++高级</title>
    <link href="/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/"/>
    <url>/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="一、类"><a href="#一、类" class="headerlink" title="一、类"></a>一、类</h1><h2 id="1-浅拷贝与深拷贝"><a href="#1-浅拷贝与深拷贝" class="headerlink" title="1.浅拷贝与深拷贝"></a>1.浅拷贝与深拷贝</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p><font color="red"> C++在进行浅拷贝时，只拷贝栈区的内存空间，不拷贝堆区的内存空间，即浅拷贝只拷贝非指针的成员变量和指针本身，而不拷贝指针所指向的堆区的内容。</font></p><p>我们代码1.1为例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//代码1.1</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Obj</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>Obj(<span class="hljs-keyword">char</span> *tp)<br>&#123;<br>len = <span class="hljs-built_in">strlen</span>(tp);<br>p = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(len + <span class="hljs-number">1</span>);<br>strcpy_s(p, len+<span class="hljs-number">1</span>, tp);<br>&#125;<br>~Obj()<br>&#123;<br><span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">free</span>(p);<br>p = <span class="hljs-literal">NULL</span>;<br>len = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; *p &lt;&lt; *(p + <span class="hljs-number">1</span>) &lt;&lt; *(p + <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">char</span> *p;<br><span class="hljs-keyword">int</span> len;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">text</span><span class="hljs-params">(Obj &amp;obj)</span></span><br><span class="hljs-function"></span>&#123;<br>Obj obj2 = obj;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Obj <span class="hljs-title">obj1</span><span class="hljs-params">(<span class="hljs-string">&quot;asd&quot;</span>)</span></span>;<br>text(obj1);<br>obj1.Show();<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们作一个图示：</p><p><img src="/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/Git\Blog\source_posts\【C++】C++高级\Snipaste_2019-10-01_16-21-15.png"></p><p>​    我们没有自定义Obj类的拷贝构造函数，所以当代码执行到<code>Obj obj2 = obj1;</code>时，编译器将调用默认的拷贝构造函数，然而，<font color="red"> 编译器默认的拷贝构造函数是一个浅拷贝</font>，所以新创建的对象obj2没有自己的堆区空间，obj2.p指向的是obj1.p所指向的内存地址。</p><p>​    上面的代码编译是通不过的，<font color="red"> 原因在于，对象析构时，同一个内存地址<code>0x0001</code>被对象obj1和obj2一起析构了两次</font>。当代码执行完<code>test(obj1)</code>时，对象obj2被析构，指针obj2.p所指向的内存地址<code>0x0001</code>被释放，所以当代码执行到<code>obj1.Show()</code>时，使用了已经被释放掉的内存<code>0x0001</code>地址，从而导致运行错误。</p><p>​    <font color="green"> <strong>这里我有一个疑问，既然浅拷贝在拷贝有指针的对象时，会出现两次析构而出错，所以浅拷贝只能拷贝没有指针成员的对象，那么浅拷贝和深拷贝似乎没有什么区别了，那么浅拷贝存在的意义是什么呢？</strong></font></p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>C++没有提供给开发者预定义的深拷贝方法，所以要想使用深拷贝，我们需要字写一个拷贝构造函数。</p><p>深拷贝可以解决上面遇到的浅拷贝的问题，因为，<font color="red"> 深拷贝会申请一新的内存空间用于存放拷贝过来的内容，即深拷贝拷贝对象的所有成员，包括指针所指向的内存空间也会一起被拷贝，被拷贝过来的指针会指向一个新的内存地址</font>。</p><p><img src="/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/Snipaste_2019-10-01_16-52-53.png"></p><h3 id="定义深拷贝构造函数"><a href="#定义深拷贝构造函数" class="headerlink" title="定义深拷贝构造函数"></a>定义深拷贝构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//代码1.2</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Obj</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>Obj(<span class="hljs-keyword">char</span> *tp)<br>&#123;<br>len = <span class="hljs-built_in">strlen</span>(tp);<br>p = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(len + <span class="hljs-number">1</span>);<br>strcpy_s(p, len+<span class="hljs-number">1</span>, tp);<br>&#125;<br>    <span class="hljs-comment">//------------------------------</span><br>    <span class="hljs-comment">//拷贝构造函数--深拷贝</span><br>Obj(<span class="hljs-keyword">const</span> Obj &amp;obj)<br>&#123;<br>len = obj.len;<br>p = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(len + <span class="hljs-number">1</span>);<br>strcpy_s(p, len + <span class="hljs-number">1</span>, obj.p);<br>&#125;<br>    <span class="hljs-comment">//------------------------------</span><br>~Obj()<br>&#123;<br><span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">free</span>(p);<br>p = <span class="hljs-literal">NULL</span>;<br>len = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; *p &lt;&lt; *(p + <span class="hljs-number">1</span>) &lt;&lt; *(p + <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">char</span> *p;<br><span class="hljs-keyword">int</span> len;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当一个类中定义了拷贝构造函数，则在对象拷贝时，编译器就不会在调用默认的拷贝构造函数转而调用自定义的拷贝构造函数，当我们把代码1.1中类的定义改为代码1.2中类的定义后，程序就可以正常执行了。</p><p><font color="red">使用深拷贝时，我们还需要注意下面的情况：</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Obj <span class="hljs-title">obj1</span><span class="hljs-params">(<span class="hljs-string">&quot;asd&quot;</span>)</span></span>;<br><span class="hljs-function">Obj <span class="hljs-title">obj3</span><span class="hljs-params">(<span class="hljs-string">&quot;fgh&quot;</span>)</span></span>;<br>obj3 = obj1;<br></code></pre></td></tr></table></figure><p>此时，在<code>obj3=obj1;</code>处依旧调用默认的拷贝构造函数，这里我们要弄清楚<code>obj3=obj1</code>和<code>Obj obj3 = obj1</code>之间的区别，<code>obj3=obj1</code>是将<font color="red">obj1赋值给obj3</font>，<code>=</code>赋值与拷贝构造函数没有什么关联，<code>=</code>在赋值时是C++编译器自己调用默认的拷贝构造函数—浅拷贝，和类中有无定义深拷贝无关；而<code>Obj obj3=obj1</code>则是<font color="red">使用obj1来构造obj3</font>，此时如果类中定义了深拷贝构造函数，就会使用深拷贝。要解决这个问题，就需要显示重载<code>=</code>运算符了。</p><h3 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a><font color="blue"><strong>小知识</strong></font></h3><ul><li><font color="blue">在定义拷贝构造函数时，必须使用引用传递，否则会出现无限拷贝的情况，因为，如果我们使用传值传递的话，在传递对象到拷贝构造函数时，又会调用拷贝构造函数将实参拷贝给形参，而这个过程又会将对象传递给拷贝构造函数，从而在此调用拷贝构造函数将实参拷贝给形参，如此无限循环</font></li><li><font color="blue">拷贝构造函数只能有一个参数，且必须是自身类的引用，否则编译器将识别被普通构造函数</font></li></ul><h2 id="2-初始化参数列表"><a href="#2-初始化参数列表" class="headerlink" title="2.初始化参数列表"></a>2.初始化参数列表</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>我们以下面的代码1.3来说明初始化参数列表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>A(<span class="hljs-keyword">int</span> a)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">int</span> a;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span> :<br>B(<span class="hljs-keyword">int</span> i)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;i = i;<br>&#125;<br><span class="hljs-keyword">int</span> i;<br>A a;<br><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">B <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">错误C2512“<span class="hljs-keyword">A</span>”: 没有合适的默认构造函数可用<br></code></pre></td></tr></table></figure><p>​    这个问题就在于，在类B中组合了一个A类的成员，编译器在构造B类对象时，同时会构造一个A类对象作为B类的成员，然而，因为A类自定义了一个有参的构造函数，所以在构造A类时，编译器不会使用默认构造函数，而是使用自定义的有参构造函数，问题就出在这里，编译器在构造A类时，没有参数传递到A类的有参构造函数中。初始化参数列表就是用于解决这种问题的。</p><p>​    需要说明的是，如果A类中没有自定义有参的构造函数，则在B类构造对象时编译器自动调用A类的默认构造函数构造A类对象成员，就不会报错。</p><p>​    初始化参数列表可以让我们在构造B类对象时，根据参数列表来构造不同的A类成员。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>初始化参数列表的使用如下面的<code>B(int i):a1(1),a2(2,&quot;asd&quot;)</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>A(<span class="hljs-keyword">int</span> a)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;构造小A&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>A(<span class="hljs-keyword">int</span> a, <span class="hljs-built_in">string</span> str)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br><span class="hljs-keyword">this</span>-&gt;str = str;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;构造大A&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>~A()<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;析构A&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">int</span> a;<br><span class="hljs-built_in">string</span> str;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span> :<br>B(<span class="hljs-keyword">int</span> i):a1(<span class="hljs-number">1</span>),a2(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;asd&quot;</span>)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;i = i;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;构造B&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>~B()<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;析构B&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-keyword">int</span> i;<br>A a1;<br>A a2;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">B <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; b.a1.str &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; b.a2.str &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>test();<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dns">构造小<span class="hljs-keyword">A</span><br>构造大<span class="hljs-keyword">A</span><br>构造B<br><br>asd<br>析构B<br>析构<span class="hljs-keyword">A</span><br>析构<span class="hljs-keyword">A</span><br></code></pre></td></tr></table></figure><p>​    值得注意的是<font color="red"> A类对象的构造顺序不是由初始化参数列表的顺序决定的，而是由对象的申明的前后顺序决定的</font>，如：<code>B(int i):a1(1),a2(2,&quot;asd&quot;)</code>和<code>B(int i):a2(2,&quot;asd&quot;),a1(1)</code>的构造顺序是一样的，但是当我们将类B中组合的A类对象的申明顺序改为如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span> :<br>B(<span class="hljs-keyword">int</span> i):a1(<span class="hljs-number">1</span>),a2(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;asd&quot;</span>)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;i = i;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;构造B&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>~B()<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;析构B&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-keyword">int</span> i;<br>A a2;<br>A a1;<br>&#125;;<br></code></pre></td></tr></table></figure><p>则构造顺序就变为“先构造a2再构造a1”了。</p><p><font color="red"> 析构的顺序和构造的顺序相反。</font></p><h3 id="小知识-1"><a href="#小知识-1" class="headerlink" title=" 小知识"></a><font color="blue"> 小知识</font></h3><ul><li><font color="blue"> 当一个类中组合了其他的类对象作为成员时，拷贝构造函数也必须使用初始化参数列表，来构造对象成员然后拷贝</font></li></ul><h2 id="3-匿名对象的生命周期"><a href="#3-匿名对象的生命周期" class="headerlink" title="3.匿名对象的生命周期"></a>3.匿名对象的生命周期</h2><h3 id="什么是匿名对象"><a href="#什么是匿名对象" class="headerlink" title="什么是匿名对象"></a>什么是匿名对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++">calss A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> a;<br>A(<span class="hljs-keyword">int</span> a)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的语句<code>A(1)</code>创建的就是一个匿名临时的对象，<font color="red"> 需要注意，如果一个类只有无参的构造函数，那么这个类将无法构建匿名对象</font>，匿名对象的生命周期就只在创建匿名对象的这条语句内，如果我们不使用一个对象来接收这个匿名对象，那么匿名对象会在语句结束时被销毁，当我们使用<code>A a = A(1);</code>不会出现匿名对象拷贝到类B对象b的情况，这种语句已经被C++优化成了类B的构造语句。说这么多其实匿名对象没什么卵用。</p><h2 id="4-new和delete"><a href="#4-new和delete" class="headerlink" title="4.new和delete"></a>4.new和delete</h2><p>1.new和delete的用法</p><p><code>new</code>可以为<strong>基础类型</strong>、<strong>数组</strong>、<strong>类</strong>分配内存空间，<code>new</code>分配的内存空间都分配在<strong>堆</strong>上。随意<code>new</code>出来的内存空间必须使用一个指针来指向，不能使用同类型的变量来接收，也禁止不接受。</p><p><strong>new 基础类型</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;<br><span class="hljs-keyword">delete</span> p;<br></code></pre></td></tr></table></figure><p><strong>new 数组</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">delete</span>[] p;<br></code></pre></td></tr></table></figure><p><strong>new 类</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//C++</span><br>A *p = <span class="hljs-keyword">new</span> A();<br><span class="hljs-keyword">delete</span> p;<br><span class="hljs-comment">//C</span><br>A *pc = (A*)<span class="hljs-built_in">malloc</span>(A);<br><span class="hljs-built_in">free</span>(pc);<br></code></pre></td></tr></table></figure><h3 id="new-delete和malloc-free的区别"><a href="#new-delete和malloc-free的区别" class="headerlink" title="new delete和malloc free的区别"></a><code>new delete</code>和<code>malloc free</code>的区别</h3><ul><li><p>在基础类型和基础类型数组方面<code>new delete</code>和<code>malloc free</code>几乎没有什么区别</p></li><li><p><code>new</code>不仅会分配内存还会调用构造函数，而<code>malloc</code>只会分配内存</p></li><li><p><code>delete</code>会调用析构函数来销毁对象，而<code>free</code>只是单纯的释放内存</p></li></ul><h3 id="小知识-2"><a href="#小知识-2" class="headerlink" title=" 小知识"></a><font color="blue"> <strong>小知识</strong></font></h3><p><font color="blue"> <code>new delete</code>和<code>malloc free</code>是可以穿插使用的，即<code>new</code>可以和<code>free</code>搭配使用，<code>malloc</code>可以和<code>delete</code>搭配使用。</font></p><h1 id="二、继承"><a href="#二、继承" class="headerlink" title="二、继承"></a>二、继承</h1><p>继承这边主要分析一下<code>虚继承</code></p><h2 id="1-虚继承"><a href="#1-虚继承" class="headerlink" title="1.虚继承"></a>1.虚继承</h2><p>虚继承的出现主要是为解决如下的继承关系中的二义性问题</p><p><img src="/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/Snipaste_2019-10-02_15-50-39.png" alt="图1"></p><p>当我们的类的继承过程中出现这种继承关系时，我们需要使类B和类C分别虚继承类A来解决二义性，具体操作如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>   <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> a;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> :</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> b;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> :</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> c;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> :</span> <span class="hljs-keyword">public</span> B,C<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> d;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    D d;<br>    d.a = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有一点要注意，虚继承的应用场景有限，虚继承只能解决这种情况：</p><p><img src="/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/Snipaste_2019-10-02_15-50-39.png"></p><p>而不能解决这种情况：</p><p><img src="/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/Snipaste_2019-10-02_16-10-55.png"></p><h2 id="2-继承中的static关键字"><a href="#2-继承中的static关键字" class="headerlink" title="2.继承中的static关键字"></a>2.继承中的static关键字</h2><p><font color="red"> 类中的静态成员变量被类的所有对象共享，同时也被类的派生类的所有对象共享。</font></p><h1 id="三、多态"><a href="#三、多态" class="headerlink" title="三、多态"></a>三、多态</h1><p>​    在C++的几个特性中，封装、继承和抽象都相对好理解，而多态则不太好理解，这里就说说C++的多态。</p><h2 id="1-多态分两种："><a href="#1-多态分两种：" class="headerlink" title="1.多态分两种："></a>1.多态分两种：</h2><p>​    静态多态：静态多态指的就是函数重载和运算符重载。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;动物&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;在叫&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> :</span> <span class="hljs-keyword">public</span> Animal<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;狗&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;在叫&quot;</span> &lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-built_in">string</span> <span class="hljs-keyword">operator</span>+(Animal animal,Dog dog)<br>&#123;<br><span class="hljs-keyword">return</span> animal.name + <span class="hljs-string">&quot;是&quot;</span> + dog.name + <span class="hljs-string">&quot;的父类&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Run</span><span class="hljs-params">(Animal animal)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; animal.name &lt;&lt;<span class="hljs-string">&quot;在跑&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Run</span><span class="hljs-params">(Dog dog)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; dog.name &lt;&lt; <span class="hljs-string">&quot;在跑&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Animal animal;<br>Dog dog;<br>Run(animal);<br>Run(dog);<br><span class="hljs-built_in">cout</span>&lt;&lt;animal+dog&lt;&lt;<span class="hljs-built_in">endl</span>;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    动态多态：动态多态则是通过继承和虚函数实现标签相同的函数因为传入不同的对象来实现不同的功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;动物&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;在叫&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> :</span> <span class="hljs-keyword">public</span> Animal<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;狗&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;在叫&quot;</span> &lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span><span class="hljs-params">(Animal *animal)</span></span><br><span class="hljs-function"></span>&#123;<br>animal-&gt;speak();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Animal animal;<br>Dog dog;<br>Speak(&amp;animal);<br>Speak(&amp;dog);<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    动态多态中只能用父类对象的指针或引用来指向子类或自身对象。</p><h2 id="2-多态的实现原理"><a href="#2-多态的实现原理" class="headerlink" title="2.多态的实现原理"></a>2.多态的实现原理</h2><p>​    C++多态的实现依赖于类的虚函数表，当一个类中定义了虚函数，那么这个类就拥有的了一个记录这个虚函数入口地址的虚函数表，子类继承父类时也会继承父类的虚函数表，当子类重写父类的虚函数时，则子类的虚函数入口地址将覆盖父类的地址，如此当子类对象调用此函数时则从子类的虚函数表中寻找入口地址，当父类的对象调用此函数时则从父类的虚函数表中寻找入口地址。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">当类创建虚函数时，编译器会在类中生成一个虚函数表<br>虚函数表是一个存储类成员函数指针的数据结构<br>虚函数表有编译器自动生成和维护<br>虚成员函数会被编译器放入虚函数表中<br>存在虚函数时，每一个对象中都会拥有一个指向虚函数表的虚函数表指针<span class="hljs-comment">(vptr)</span><br></code></pre></td></tr></table></figure><p>简单来说，多态实现的条件有三：</p><ul><li><p>要有继承</p></li><li><p>要有虚函数重写</p></li><li><p>要有父类指针(或引用)指向子类对象</p></li></ul><h2 id="3-纯虚函数和抽象类"><a href="#3-纯虚函数和抽象类" class="headerlink" title="3.纯虚函数和抽象类"></a>3.纯虚函数和抽象类</h2><p>​    纯虚函数的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>​    定义了纯虚函数的类就被成为抽象类，C++引入纯虚函数和抽象类的概念就是为了更好的使用多态，抽象类不能实例化对象，这个特性就规范了继承这个抽象类的子类必须重写父类的虚函数，因为如果继承了抽象类的子类不重写父类的虚函数，那么子类也是一个抽象类，子类便也不能实例化对象，如此便规范了多态实现，防止当子类很多时，出现某个子类在编写时忘记重写父类的虚函数，而导致这个子类没有实现多态。</p><h2 id="4-虚析构函数和纯虚析构函数"><a href="#4-虚析构函数和纯虚析构函数" class="headerlink" title="4.虚析构函数和纯虚析构函数"></a>4.虚析构函数和纯虚析构函数</h2><ul><li>虚析构函数的定义：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">virtual</span> ~Animal();<br></code></pre></td></tr></table></figure><ul><li>纯虚析构函数的定义：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">virtual</span> ~Animal() = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//纯虚析构函数必须要有申明也要有实现</span><br>Animal：：~Animal()<br>&#123;<br>    <span class="hljs-comment">//代码实现</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果子类在堆区中定义了数据，那么我们使用父类指针或引用来使用多态时，父类指针或引用是无法寻找到子类在堆区中的数据并释放的。C++引入虚析构函数和纯虚析构函数就是为了解决此类问题。</p><p>​    我们来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>Animal()<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;这是Animal的构造函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>~Animal()<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;这是Animal的析构函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> :</span> <span class="hljs-keyword">public</span> Animal<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> *p;<br>Dog()<br>&#123;<br>p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;这是Dog的构造函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>~Dog()<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;这是Dog的析构函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;释放堆区的p&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">delete</span> p;<br>p = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Animal *animal = <span class="hljs-keyword">new</span> Dog();<br><span class="hljs-keyword">delete</span> animal;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">这是<span class="hljs-keyword">Animal</span>的构造函数<br>这是Dog的构造函数<br>这是<span class="hljs-keyword">Animal</span>的析构函数<br></code></pre></td></tr></table></figure><p>可以看到，delete animal后并没有调用Dog的析构函数，释放子类Dog在堆区申请的空间。这样便出现了内存泄漏。</p><p>此时虚析构函数和纯虚析构函数便可以起作用了，我们再看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>Animal()<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;这是Animal的构造函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">virtual</span> ~Animal()<span class="hljs-comment">//把父类的析构函数改为虚析构函数</span><br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;这是Animal的析构函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> :</span> <span class="hljs-keyword">public</span> Animal<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> *p;<br>Dog()<br>&#123;<br>p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;这是Dog的构造函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>~Dog()<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;这是Dog的析构函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;释放堆区的p&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">delete</span> p;<br>p = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Animal *animal = <span class="hljs-keyword">new</span> Dog();<br><span class="hljs-keyword">delete</span> animal;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​    输出结果：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">这是<span class="hljs-keyword">Animal</span>的构造函数<br>这是Dog的构造函数<br>这是Dog的析构函数<br>释放堆区的p<br>这是<span class="hljs-keyword">Animal</span>的析构函数<br></code></pre></td></tr></table></figure><p>​    如此便可以释放子类Dog在堆区申请的空间了，纯虚析构函数和虚析构函数的作用是一样，只是纯虚析构函数有一个和纯虚函数一样的特性，即定义了纯虚析构函数的类也属于抽象类，纯虚析构函数必须实现，如果不实现所有继承了拥有纯虚析构函数的抽象类的派生类都属于抽象类。需要注意的是，因为纯虚析构函数的特性，纯虚析构函数的实现就必须在类外实现了。</p><h2 id="5-重载、重写、重定义"><a href="#5-重载、重写、重定义" class="headerlink" title="5.重载、重写、重定义"></a>5.重载、重写、重定义</h2><p><strong>重载</strong></p><p>重载发生在一个类的内部，拥有相同函数名，相同返回值而参数列表不同的函数之间互为重载关系。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><font color="red"> 只有相同函数名而参数列表不同的函数才是重载，函数名相同参数列表也相同而返回值不同的函数在C++中是不允许的。</font></p><p><strong>重写</strong></p><p>重写发生在基类和派生类之间，基类中定义虚函数(纯虚函数)，派生类中定义和虚函数拥有<strong>相同函数名，相同参数列表和相同返回值</strong>的函数，这种情况下发生函数重写。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> :</span> <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-comment">//重写A类的fun函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;&#125;<span class="hljs-comment">//重定义一个新函数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//这种情况C++不允许</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>重定义</strong></p><p>重定义也是发生在基类和派生类之间，派生类拥有与基类函数名相同，返回值相同，而参数列表不同的函数，此时发生重定义。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> :</span> <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;&#125;<span class="hljs-comment">//发生重定义</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><font color="red"> 派生类中可以重定义基类的任何函数，包括虚函数和纯虚函数。</font></p><h2 id="6-父类指针和子类指针步长不一致问题"><a href="#6-父类指针和子类指针步长不一致问题" class="headerlink" title="6.父类指针和子类指针步长不一致问题"></a>6.父类指针和子类指针步长不一致问题</h2><p>问题出现的场景是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> a;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> :</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> b;<br>B(<span class="hljs-keyword">int</span> b)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;b = b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A *a = <span class="hljs-literal">NULL</span>;<br>B *b = <span class="hljs-literal">NULL</span>;<br>B <span class="hljs-built_in">array</span>[<span class="hljs-number">2</span>]&#123; B(<span class="hljs-number">1</span>),B(<span class="hljs-number">2</span>) &#125;;<br>a = <span class="hljs-built_in">array</span>;<br>b = <span class="hljs-built_in">array</span>;<br>a-&gt;print();<br>b-&gt;print();<br>a++; b++;<br>a-&gt;print();<span class="hljs-comment">//这一步会出现异常</span><br>b-&gt;print();<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>即父类指针a和子类指针b都指向一个子类对象数组，于是我们可以通过指针++的自增运算来逐步访问数组元素，问题就出在这，使用<code>sizeof()</code>计算两个类的大小分别得出，sizeof(A)=8;sizeof(B)=20;这就导致A类指针a每一次移步时只移动了8个字节，这个距离还远远没有达到下一个元素的首地址，所以访问会出错，这是因为指针每次移步移动的距离是指针类型的空间大小，如：A类大小为8，所以A类指针每移步一次走8个字节。</p><p>可能会有疑问，为什么类B的大小是20？</p><p>我们可以算一算，类B继承至类A所以类A中拥有的成员变量，类B也拥有，占8字节，这8字节分别是int变量4字节和虚函数表指针4字节；类B自身定义了一个int变量占4字节，由于类B重写了类A的虚函数，所以类B也拥有一个自己的虚函数表指针，占4字节；类B虚继承了类A，在这个过程中，C++编译器会给类B增加一个属性，占4字节，于是，<strong>8+4+4+4+4=20</strong>。</p><hr><h1 id="四、泛型编程"><a href="#四、泛型编程" class="headerlink" title="四、泛型编程"></a>四、泛型编程</h1><h2 id="1-函数模板"><a href="#1-函数模板" class="headerlink" title="1.函数模板"></a>1.函数模板</h2><h3 id="函数模板的基本语法"><a href="#函数模板的基本语法" class="headerlink" title="函数模板的基本语法"></a>函数模板的基本语法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//---------------函数模板</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-comment">//告诉编译器我要开始泛型编程了，遇到T不要报错</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">(T &amp;a,T &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>T t = a;<br>a = b;<br>b = t;<br>&#125;<br><span class="hljs-comment">//----------------</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">char</span> a = <span class="hljs-number">97</span>,b = <span class="hljs-number">102</span>;<br>Fun(a, b);<span class="hljs-comment">//自动推导类型调用</span><br><span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">string</span> x = <span class="hljs-string">&quot;xxx&quot;</span>, y = <span class="hljs-string">&quot;yyy&quot;</span>;<br>Fun&lt;<span class="hljs-built_in">string</span>&gt;(x, y);<span class="hljs-comment">//显示类型调用</span><br><span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-built_in">endl</span>;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="当函数模板遇到函数重载"><a href="#当函数模板遇到函数重载" class="headerlink" title="当函数模板遇到函数重载"></a>当函数模板遇到函数重载</h3><p>当函数模板遇到函数重载准许下面4条原则</p><ul><li>函数模板可以像普通函数一样被重载</li><li>C++编译器优先考虑普通函数</li><li>如果函数模板可以产生一个更好的匹配，那么选择函数模板</li><li>可以通过模板的空实参列表的语法限定编译器只通过函数模板匹配</li></ul><p>我们来看一个例子，逐一分析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">(T a,T b)</span></span><br><span class="hljs-function"></span>&#123;<br>a = a + b;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;我是函数模板&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1,<span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">(T1 a,T2 b)</span></span><br><span class="hljs-function"></span>&#123;<br>T1 x = a;<br>T2 y = b;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;我是函数模板重载&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;我是普通函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fun2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Fun(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>Fun(<span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>);<br>Fun(<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">1</span>);<br>Fun&lt;&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>Fun2(<span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>);<br>Fun2(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">3</span>);<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">我是普通函数<br>我是函数模板<br>我是函数模板重载<br>我是函数模板<br>0,0<br>97,3<br></code></pre></td></tr></table></figure><p><strong>分析：</strong></p><ul><li><code>Fun(1,2)</code>:有完全匹配的普通函数，所以调用<code>void Fun(int a, int b)</code></li><li><code>Fun(0.1,0.2)</code>:虽然普通函数<code>void Fun(int a, int b)</code>可以像<code>void Fun2(int a, int b)</code>一样进行隐式类型转换调用，倒是<code>Fun()</code>函数有更好的重载函数<code>void Fun(T1 a,T2 b)</code>模板匹配所以编译器优先调用<code>void Fun(T1 a,T2 b)</code></li><li><code>Fun(&#39;c&#39;,1)</code>:编译器能找到匹配的函数模板重载<code>void Fun(T1 a,T2 b)</code>所以优先调用函数模板</li><li><code>Fun&lt;&gt;(1,2)</code>:使用了空参数列表，告诉编译器只匹配函数模板，即使代码段中有能完美匹配的普通函数，也只调用函数模板</li></ul><h2 id="2-类模板"><a href="#2-类模板" class="headerlink" title="2.类模板"></a>2.类模板</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-comment">//定义</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TemplateA</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>TemplateA(T a)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintA</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>T a;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test</span><span class="hljs-params">(TemplateA&lt;<span class="hljs-keyword">int</span>&gt; &amp;a)</span><span class="hljs-comment">//类模板作形参</span></span><br><span class="hljs-function"></span>&#123;<br>a.PrintA();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">TemplateA&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">//使用</span><br><span class="hljs-function">TemplateA&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-string">&quot;str&quot;</span>)</span></span>;<br><span class="hljs-function">TemplateA&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-literal">true</span>)</span></span>;<br>Test(a);<br>b.PrintA();<br>c.PrintA();<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">a:</span><span class="hljs-number">1</span><br><span class="hljs-symbol">a:</span>str<br><span class="hljs-symbol">a:</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>类模板的定义和函数模板的定义类似</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>类模板的使用必须显示的确定模板的类型参数，如：<code>TemplateA&lt;string&gt; b(&quot;str&quot;)</code></p><h3 id="类模板作参数"><a href="#类模板作参数" class="headerlink" title="类模板作参数"></a>类模板作参数</h3><p>类模板作参数也必须显示的确定模板那的类型参数，如：</p><p><code>void Test(TemplateA&lt;int&gt; &amp;a)</code>以便编译器为形参确定内存空间。</p><h3 id="类模板派生普通类"><a href="#类模板派生普通类" class="headerlink" title="类模板派生普通类"></a>类模板派生普通类</h3><p>类模板也可以被继承，但是在继承时需要显示确定模板的类型参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TemplateA</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>TemplateA(T a)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintA</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>T a;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> :</span> <span class="hljs-keyword">public</span> TemplateA&lt;<span class="hljs-keyword">int</span>&gt;<span class="hljs-comment">//类模板派生普通类</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>B(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) :TemplateA(a)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;b = b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintB</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;b:&quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">int</span> b;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">B <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>b.PrintA();<br>b.PrintB();<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="模板类派生模板类"><a href="#模板类派生模板类" class="headerlink" title="模板类派生模板类"></a>模板类派生模板类</h3><p>模板类不仅可以派生普通类，还可以派生模板类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TemplateA</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>TemplateA(T a)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintA</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>T a;<br>&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1,<span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TemplateB</span> :</span> <span class="hljs-keyword">public</span> TemplateA&lt;T2&gt;<span class="hljs-comment">//类模板派生类模板</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>TemplateB(T2 a, T1 b) :TemplateA(a)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;b = b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintB</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;b:&quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>T1 b;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>TemplateB&lt;string,char&gt; b(&#x27;A&#x27;, &quot;TemplateB&quot;);<br>b.PrintA();<br>b.PrintB();<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">a:</span>A<br><span class="hljs-symbol">b:</span>TemplateB<br></code></pre></td></tr></table></figure><h3 id="类模板的主要作用"><a href="#类模板的主要作用" class="headerlink" title="类模板的主要作用"></a>类模板的主要作用</h3><p>类模板的主要作用就是将数据结构的表示和算法不受包含的元素类型的影响，即类模板将元素类型和数据结构算法分离开来了，使数据结构和算法成为真正意义上的数据结构和算法，如：链表不再因为<code>int</code>类型而定义一个<code>int</code>类型的链表，因<code>string</code>类型而定义一个<code>string</code>类型的链表，而是定义一个链表可以通用于所有类型。</p><h1 id="五、异常处理"><a href="#五、异常处理" class="headerlink" title="五、异常处理"></a>五、异常处理</h1><h2 id="1-异常的基本语法"><a href="#1-异常的基本语法" class="headerlink" title="1.异常的基本语法"></a>1.异常的基本语法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Try</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;除数不能等于0，抛出异常&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">throw</span> y;<span class="hljs-comment">//这里必须指明抛出异常的数据类型，否则程序无法处理异常，只能使用这个类型的变量，x和y的效果是一样的，不能直接抛出int，即这样是不行的throw int</span><br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;x/y=&quot;</span> &lt;&lt; x / y &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Try(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>Try(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">try</span><br>&#123;<br>Test1();<br>&#125;<br><span class="hljs-keyword">catch</span> (<span class="hljs-keyword">char</span> e)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;处理char异常&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">catch</span>(...)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;无法处理的异常继续往上抛&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">throw</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">try</span><br>&#123;<br>Test2();<br>&#125;<br><span class="hljs-keyword">catch</span>(<span class="hljs-keyword">int</span> e)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;处理int异常&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">catch</span> (...)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;处理其他异常&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-symbol">x</span>/<span class="hljs-symbol">y</span>=<span class="hljs-number">0</span><br>除数不能等于<span class="hljs-number">0</span>，抛出异常<br>无法处理的异常继续往上抛<br>处理int异常<br></code></pre></td></tr></table></figure><ul><li>异常的抛出是可以跨函数的，如上面的代码，在<code>Try</code>函数里抛出的异常可以在<code>mian</code>函数中处理，中间跨过了<code>Test1</code>，<code>Test2</code>两个函数</li><li>如果在一个函数内捕捉到异常但是却无法处理可以通过<code>throw</code>继续向上抛，直至main函数，如上面代码，<code>Test2</code>捕捉到异常但是没有处理继续向上抛给了main函数，如果main函数还是没有处理，则会直接中断程序</li><li>C++使用<code>cacth(...)</code>来捕捉其他没有捕捉到的异常，如上面代码，main函数中只捕捉了int类型的异常，如果出现其他类型的异常则有<code>cacth(...)</code>来捕捉</li><li>异常处理是按照类型匹配来处理的，即<code>throw</code>的int类型的异常只有<code>cacth(int e)</code>能够接收得到，否则就只能使用<code>cacth(...)</code>来接收未知异常</li></ul><h2 id="2-C-异常处理的特性"><a href="#2-C-异常处理的特性" class="headerlink" title="2.C++异常处理的特性"></a>2.C++异常处理的特性</h2><p>​    C++的异常处理具有跨函数性，这使得<font color="red"> 异常引发</font>和<font color="red"> 异常处理</font>分离开来，这样下层函数可以不用过多的在一异常处理，而把重点放在问题的逻辑处理上，异常处理可以由上层调用者专门来处理。</p><h2 id="3-异常接口申明"><a href="#3-异常接口申明" class="headerlink" title="3.异常接口申明"></a>3.异常接口申明</h2><p><strong>不抛出任何异常：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Try</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span><span class="hljs-comment">//异常接口申明</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;除数不能等于0，抛出异常&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">throw</span> x;<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;x/y=&quot;</span> &lt;&lt; x / y &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>只能抛出列表中类型的异常：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Try</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> <span class="hljs-title">throw</span><span class="hljs-params">(<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>*)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;除数不能等于0，抛出异常&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">throw</span> x;<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;x/y=&quot;</span> &lt;&lt; x / y &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>可以抛出任何异常：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Try</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;除数不能等于0，抛出异常&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">throw</span> x;<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;x/y=&quot;</span> &lt;&lt; x / y &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过经过测试，三份代码无论是否写throw都是可以抛出并处理异常的，似乎这个语法没什么卵用，可能C++11摒弃了这种用法，但是考虑到兼容保留这个语法。</p><h2 id="4-异常接收的3种方式"><a href="#4-异常接收的3种方式" class="headerlink" title="4.异常接收的3种方式"></a>4.异常接收的3种方式</h2><h3 id="普通形参"><a href="#普通形参" class="headerlink" title="普通形参"></a>普通形参</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>A() &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;构造A&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<br>A(<span class="hljs-keyword">const</span> A &amp;a) &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;拷贝A&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<br>~A() &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;析构A&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Try</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A a;<br><span class="hljs-keyword">throw</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">try</span><br>&#123;<br>Try();<br>&#125;<br><span class="hljs-keyword">catch</span>(A e)<span class="hljs-comment">//使用普通形参</span><br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;处理int异常&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns">构造<span class="hljs-keyword">A</span><br>拷贝<span class="hljs-keyword">A</span><br>拷贝<span class="hljs-keyword">A</span><br>析构<span class="hljs-keyword">A</span><br>处理int异常<br>析构<span class="hljs-keyword">A</span><br>析构<span class="hljs-keyword">A</span><br></code></pre></td></tr></table></figure><p>可以看到a被拷贝两次，第一次从<code>A a</code>拷贝到<code>throw a</code>，第二次从<code>throw a</code>拷贝到<code>catch(A e)</code>，可以看出如果使用普通形参来接收异常，异常变量会由异常抛出处拷贝到异常接收处。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>将上面代码的<code>catch(A e)</code>改为<code>catch(A &amp;e)</code></p><p><strong>输出结果：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">构造<span class="hljs-keyword">A</span><br>拷贝<span class="hljs-keyword">A</span><br>析构<span class="hljs-keyword">A</span><br>处理int异常<br>析构<span class="hljs-keyword">A</span><br></code></pre></td></tr></table></figure><p>可以看到只拷贝了一次，即从<code>A a</code>拷贝到<code>throw a</code>。</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>上面代码应该修改为如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>A() &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;构造A&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<br>A(<span class="hljs-keyword">const</span> A &amp;a) &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;拷贝A&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<br>~A() &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;析构A&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Try</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A *a = <span class="hljs-keyword">new</span> A();<span class="hljs-comment">//对象必须创建在堆区，函数结束对象就会被销毁，而无法通过指针传递到catch中</span><br><span class="hljs-keyword">throw</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">try</span><br>&#123;<br>Try();<br>&#125;<br><span class="hljs-keyword">catch</span>(A *e)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;处理int异常&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">delete</span> e;<span class="hljs-comment">//需要手动释放堆区的内存</span><br>&#125;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">构造<span class="hljs-keyword">A</span><br>处理int异常<br>析构<span class="hljs-keyword">A</span><br></code></pre></td></tr></table></figure><p>可以看到使用指针完全不需要拷贝，但是却需要消耗堆区的内存且容易造成内存泄露。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的来说，最优的方式还是使用引用。</p><h2 id="5-继承在异常处理中的应用"><a href="#5-继承在异常处理中的应用" class="headerlink" title="5.继承在异常处理中的应用"></a>5.继承在异常处理中的应用</h2><p>在实际的项目中我们处理的异常并不是一些基础的数据类型，大多都是开发者的自定义类，这种情况在捕捉异常的时候就相当麻烦，尽管有些异常处理起来程序基本一致，但是却要将每一种异常一一捕捉并一一处理，下面的代码我们来模拟一下这种情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>//<span class="hljs-title">A</span>类实现输入一个范围在0-10的奇数</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>A(<span class="hljs-keyword">int</span> a) <br>&#123;<br><span class="hljs-keyword">if</span> (a % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span>)<span class="hljs-keyword">throw</span> LtZero();<br><span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">10</span>)<span class="hljs-keyword">throw</span> GtTen();<br><span class="hljs-keyword">else</span> num = a;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> Even();<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">int</span> num;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LtZero</span>//专门处理异常的异常类</span><br><span class="hljs-class">&#123;</span>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GtTen</span></span><br><span class="hljs-class">&#123;</span>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Even</span></span><br><span class="hljs-class">&#123;</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">try</span> &#123; <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>; &#125;<br><span class="hljs-keyword">catch</span> (LtZero &amp;lz) &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;输入的数小于0&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<br><span class="hljs-keyword">catch</span> (GtTen &amp;gt) &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;输入的数大于10&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<br><span class="hljs-keyword">catch</span> (Even &amp;ev) &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;输入的数是偶数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<br><span class="hljs-keyword">catch</span> (...) &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;其他异常&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到我们的异常处理模块相当繁杂，在实际开发项目中异常的数量远远不止上面模拟的三种，可能多达上百种或则更多，这是异常的处理将变得十分繁杂，那么如何处理呢？</p><p>可能心细的读者会发现，我们在处理异常时使用了专门的异常处理类，而类是可以继承的，于是乎，继承在异常处理中的作用就体现出来了。</p><p>我们再来看一份优化后的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>//<span class="hljs-title">A</span>类实现输入一个范围在0-10的奇数</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>A(<span class="hljs-keyword">int</span> a) <br>&#123;<br><span class="hljs-keyword">if</span> (a % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span>)<span class="hljs-keyword">throw</span> LtZero();<br><span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">10</span>)<span class="hljs-keyword">throw</span> GtTen();<br><span class="hljs-keyword">else</span> num = a;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> Even();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Even</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintErro</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span>&lt;&lt; <span class="hljs-string">&quot;输入的数是偶数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LtZero</span>:</span><span class="hljs-keyword">public</span> Even<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintErro</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;输入的数小于0&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GtTen</span>:</span><span class="hljs-keyword">public</span> Even<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintErro</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;输入的数大于10&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">int</span> num;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">try</span> &#123; <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>; &#125;<br><span class="hljs-keyword">catch</span> (A::Even e) &#123; e.PrintErro(); &#125;<br><span class="hljs-keyword">catch</span> (...) &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;其他异常&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到我们的异常处理模块使用多态，繁杂程度被大幅缩水了，而我们的异常处理被集中在了异常处理类中，有时，如果我们的异常处理只对某一个类有效也是可以直接将异常处理类定义在抛出类里面的。</p><h2 id="6-标准异常库"><a href="#6-标准异常库" class="headerlink" title="6.标准异常库"></a>6.标准异常库</h2><p>C++提供一些标准的异常库，头文件为：#include<stdexcep></stdexcep></p><h1 id="六、标准IO流"><a href="#六、标准IO流" class="headerlink" title="六、标准IO流"></a>六、标准IO流</h1><h2 id="1-标准IO流流程"><a href="#1-标准IO流流程" class="headerlink" title="1.标准IO流流程"></a>1.标准IO流流程</h2><p><img src="/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/Snipaste_2019-10-06_10-03-47.png"></p><h2 id="2-标准输入流"><a href="#2-标准输入流" class="headerlink" title="2.标准输入流"></a>2.标准输入流</h2><table><thead><tr><th>标准函数</th><th>作用</th></tr></thead><tbody><tr><td>cin</td><td>cin&gt;&gt;操作支持任何基本类型的输入，但是遇到空格则结束读取</td></tr><tr><td>cin.get(char chr)</td><td>从缓冲区中读取一个字符到chr中，因为C++定义的cin.get(char)中会返回一个函数自身的引用，所以此函数支持链式编程，即cin.get(a).get(b).get(c);b表示依次从缓冲区中读取三个字符到a，b，c中</td></tr><tr><td>cin.get(char* buf,int cout)</td><td>从缓冲区中读取cout个字符到buf数组中，因为函数似乎会在数组末尾添加点什么，所以实际读取的字符数量是cout-1个，此函数也支持链式编程</td></tr><tr><td>cin.get(char* buf,int cout,char chr)</td><td>从缓冲区中读取cout个字符到buf数组中，如果碰到字符chr则结束读取</td></tr><tr><td>cin.getline(char buf,int cout)</td><td>从缓冲区中读取cout个字符到buf数组中</td></tr><tr><td>cin.ignore(int num)</td><td>忽略缓冲区当前读取指针开始的num个字符再读取</td></tr><tr><td>cin.peek()</td><td>判断缓冲区中是否有数据，如果有则返回第一个字符，如果没有则阻塞程序</td></tr><tr><td>cin.putback(char chr)</td><td>将读取出来的字符再返存回缓冲区，只能读取一个字符</td></tr></tbody></table><h2 id="3-标准输出流"><a href="#3-标准输出流" class="headerlink" title="3.标准输出流"></a>3.标准输出流</h2><table><thead><tr><th>标准函数</th><th>作用</th></tr></thead><tbody><tr><td>cout</td><td>输出缓冲区内容，支持任何基本类型数据的输出</td></tr><tr><td>cout.flush(void)</td><td>刷新缓冲区，无视系统繁忙，强制输出缓冲区的字符，语法和cout一样“cout.flush()&lt;&lt;buf&lt;&lt;endl;”</td></tr><tr><td>cout.put(char chr)</td><td>在标准输出设备输出指针的当前位置插入字符chr，语法和cout一致</td></tr><tr><td>cout.write(char *chr,int cout)</td><td>输出*chr所指向空间中cout个数量的字符，即使越界也会继续输出，语法和cout一致</td></tr><tr><td>cout.width(int num)</td><td>输出num个字节宽度的字符，一般配合cout.fill(char chr)和其他cout函数一起使用</td></tr><tr><td>cout.fill(char chr)</td><td>配合cout.width(int num)和其他cout一起使用，在输出的num宽度的字符中将cout函数没有填充完的字符用chr填充</td></tr><tr><td>cout.setf(标记)</td><td>格式化cout输出，标记种类很多，具体的可以查阅资料，配合cout函数一起使用</td></tr></tbody></table><h2 id="4-文件IO流"><a href="#4-文件IO流" class="headerlink" title="4.文件IO流"></a>4.文件IO流</h2><p>​    文件操作相对来说比较简单，总的来说就是5个步骤，即</p><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><ul><li><p>​    包含头文件<font color="red">#include<ftream></ftream></font></p></li><li><p>​    创建流对象</p></li><li><p>​    打开文件</p></li><li><p>​    读写文件</p><p>​    <font color="red">需要注意的是C++中文件写的方式是使用符号“&lt;&lt;”，如：fout &lt;&lt; “文件内容”&lt;&lt;endl;</font></p><p>​    <font color="red">同理文件读也可以使用“&gt;&gt;”来读。</font></p></li><li><p>​    关闭文件</p><p><strong>文件写</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ofstream fout;<br>fout.open(<span class="hljs-string">&quot;文件测试.txt&quot;</span>, ios::out);<br>fout &lt;&lt; <span class="hljs-string">&quot;姓名：张三&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>fout &lt;&lt; <span class="hljs-string">&quot;性别：男&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>fout.close();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>test();<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    <strong>输出结果：</strong>    </p><p><img src="/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/Snipaste_2019-09-14_16-29-43.png"></p><h3 id="4种文件读的方式"><a href="#4种文件读的方式" class="headerlink" title="4种文件读的方式"></a>4种文件读的方式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ifstream fin;<br>fin.open(<span class="hljs-string">&quot;文件测试.txt&quot;</span>, ios::in);<br><span class="hljs-keyword">if</span> (!fin.is_open())<span class="hljs-comment">//文件读需要多添加一步判断文件是否打开成功的步骤</span><br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;文件打开失败&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">char</span> str[<span class="hljs-number">1024</span>];<br><span class="hljs-built_in">string</span> strs;<br><span class="hljs-keyword">char</span> chr;<br><span class="hljs-comment">//第一中方式</span><br><span class="hljs-comment">//while (fin &gt;&gt; str)//操作符&quot;&gt;&gt;&quot;每次只能读取一行数据，读到文件尾“EOF”时结束</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment">//第二种方式</span><br><span class="hljs-comment">//while (fin.getline(str, 50))//ifstream::getline(char *str,int num);这个函数只支持字符数组，参数num指的是需要读取的字节数</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment">//第三种方式</span><br><span class="hljs-comment">//while (getline(fin, strs))//与第二种方式不同的是，这个getline函数是全局的，且只支持输出到string类型的对象中</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//cout &lt;&lt; strs &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment">//第四中方式</span><br><span class="hljs-keyword">while</span> ((chr = fin.get()) != EOF)<span class="hljs-comment">//get()函数每次只能读取一个字符</span><br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; chr ;<br>&#125;<br>fin.close();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>test();<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="文件的打开模式"><a href="#文件的打开模式" class="headerlink" title="文件的打开模式"></a>文件的打开模式</h3><p>​    C++提供6中文件的打开方式</p><table><thead><tr><th>打开方式</th><th>解释</th></tr></thead><tbody><tr><td>ios::in</td><td>以读的形式打开</td></tr><tr><td>ios::out</td><td>以写的形式打开，会覆盖源文件</td></tr><tr><td>ios::ate</td><td>以写的形式打开并初始文件位置：文件尾，会覆盖源文件</td></tr><tr><td>ios::app</td><td>以追加的方式打开文件</td></tr><tr><td>ios::trunc</td><td>如果文件存在先删除再创建</td></tr><tr><td>ios::binary</td><td>以二进制的形式打开</td></tr></tbody></table><h3 id="读写二进制文件"><a href="#读写二进制文件" class="headerlink" title="读写二进制文件"></a>读写二进制文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;张三&quot;</span>;<br><span class="hljs-built_in">string</span> sex = <span class="hljs-string">&quot;男&quot;</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ofstream fout;<br>fout.open(<span class="hljs-string">&quot;二进制文件测试.txt&quot;</span>, ios::out | ios::binary);<br>Person p;<br>fout.write((<span class="hljs-keyword">char</span> *)&amp;p, <span class="hljs-keyword">sizeof</span>(Person));<span class="hljs-comment">//注意这里使用ofstream::write()来写</span><br>fout.close;<br><br>ifstream fin;<br>fin.open(<span class="hljs-string">&quot;二进制文件测试.txt&quot;</span>, ios::in | ios::binary);<br><span class="hljs-keyword">if</span> (!fin.is_open())<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;文件打开错误&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>Person pin;<br>fin.read((<span class="hljs-keyword">char</span> *)&amp;pin, <span class="hljs-keyword">sizeof</span>(Person));<span class="hljs-comment">//注意这里使用ofstream::read()来读</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;姓名：&quot;</span> &lt;&lt; pin.name &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;性别：&quot;</span> &lt;&lt; pin.sex &lt;&lt; <span class="hljs-built_in">endl</span>;<br>fin.close();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>test();<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPlus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C++】C++中的四种类型转换</title>
    <link href="/2019/09/12/%E3%80%90C++%E3%80%91C++%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/"/>
    <url>/2019/09/12/%E3%80%90C++%E3%80%91C++%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>C++提供四种类型转换：const_cast、static_cast、dynamic_cast、reinterpret_cast</p><h1 id="1-const-cast"><a href="#1-const-cast" class="headerlink" title="1.const_cast"></a>1.const_cast</h1><p>​    const_cast的存在主要就是针对const字段，C++提供const_cast的目的就是为了消除const字段的const属性，让const字段也可以修改。</p><p>​    const_cast的用法：</p><p>​        const_cast只能将常指针转换为非常指针，不能直接将常字段转换为非常字段，只能通过指针类间接的修改常字段所在的内存的内容。</p><p>​        例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>* n = &amp;a;<br><span class="hljs-keyword">int</span>* m = <span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">int</span>*&gt;(n) ;<br>*m = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>​    最终的输出结果：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-attr">a</span> = <span class="hljs-number">1</span>,*<span class="hljs-attr">n</span> = <span class="hljs-number">2</span>,*<span class="hljs-attr">m</span> = <span class="hljs-number">2</span><br>&amp;<span class="hljs-attr">a=n=m</span><br></code></pre></td></tr></table></figure><p>​        奇怪，指针n，m的确指向了地址&amp;a，之中的内容的确也修改成了2，可为什么字段a的值依旧是1？</p><p>​        经过多方查阅资料和自己的试验，原来对于常字段在预编译的过程中编译器就会给常字段预定义为初始化的值，类似宏定义一般，尽管内存的内容被改变了，但是常字段的值依旧被预定义为初始化的值。</p><p>​        但是，我就疑问了，既然const_cast就是用来修改const字段的，可是只是改变了其内存的值，字段的值依旧没变，那么程序里使用该字段的地方的值依旧没有改变，如此const_cast似乎没有达到想要的结果。</p><p>​        $\color{red}{不过const_cast似乎可以修改const标识的结构体对象中没有再用const标识的字段，也可以修改用const标识的类对象中没有用const标识的公有字段，但是在结构体或类中用const标识的字段就不能再修改了。}$</p><p><img src="/2019/09/12/%E3%80%90C++%E3%80%91C++%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/Snipaste_2019-09-12_10-44-16.png"></p><h1 id="2-static-cast"><a href="#2-static-cast" class="headerlink" title="2.static_cast"></a>2.static_cast</h1><p>​    static_cast类型转换的用法几乎和C中的基本类型转换的用法一致，而C++的static_cast类型转换增加了类型检查，在安全性上较C要强。</p><p>​    static_cast支持所有类型之间的转换包括类，对于类在继承过程中的类型转换有两点是需要注意的，</p><p>一、static_cast类型转换在上行转换是安全的，在下行转换是不安全，（上行转换：从子类转换到父类，下行转换：从父类转换到子类），</p><p>二、static_cast类型转换在类的转换中因该使用指针转换，即通过指针间接的实现转换，直接对类的对象进行转换类型会被裁剪，并且在下行转换中不使用指针会报错。</p><p><img src="/2019/09/12/%E3%80%90C++%E3%80%91C++%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/Snipaste_2019-09-12_11-51-30.png"></p><h1 id="3-dynamic-cast"><a href="#3-dynamic-cast" class="headerlink" title="3.dynamic_cast"></a>3.dynamic_cast</h1><p>​    dynamic_cast类型转换用于类之间的上下行转换，与static_cast不同的是，dynamic_cast类型转换无论上下行都具有类型检查，都可以进行安全的类型转换。上行转换dynamic_cast与static_cast完全一致，下行转换dynamic_cast比static_cast更安全。</p><p>​    dynamic_cast的具体使用场景就是将父类指针转换成子类指针，但是使用条件就是只能用于含有虚函数的类，因为dynamic_cast的内部机制就是利用虚函数表里的类型信息来判断一个父类指针是否指向一个子类对象，转换失败会抛出bad_cast异常，并返回null。</p><h1 id="4-reinterpret-cast"><a href="#4-reinterpret-cast" class="headerlink" title="4.reinterpret_cast"></a>4.reinterpret_cast</h1><p>​    reinterpret_cast类型转换只能对指针进行操作，reinterpret_cast类型转换提供的是一种更底层的转换模式–比特位上的重新解释，即对某一类型的内存地址的比特位以另一种类型来解释，这可能不好理解，在这放一张图来辅助理解。</p><p><img src="/2019/09/12/%E3%80%90C++%E3%80%91C++%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/Snipaste_2019-09-12_16-32-44.png"></p><p>​    p是指向字符串的char类型指针，i是指向整型的指针，i = reinterpret_cast&lt;int*&gt;(p)则将p所指向的内存里的比特位以int类型来重新解释并复制到i所指向的内存地址上，于是在输出 *i 时，输出的是一个整型的数值。</p><p>reinterret_cast可以说是一个安全的强制类型转换了。 </p><p>​    至于为什么cout&lt;&lt;p时不是输出的p所指向的地址而是地址里的内容，我始终没有弄明白，不过不影响对reinterpret_cast类型转换的理解。</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPlus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C++】普通全局变量、静态全局变量、普通局部变量与静态局部变量</title>
    <link href="/2019/09/11/%E3%80%90C++%E3%80%91%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E9%9D%99%E6%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/"/>
    <url>/2019/09/11/%E3%80%90C++%E3%80%91%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E9%9D%99%E6%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="1-普通全局变量"><a href="#1-普通全局变量" class="headerlink" title="1.普通全局变量"></a>1.普通全局变量</h1><p>​    普通全局变量是定义在函数和类外的或由extern标识或直接定义没有static标识的变量。</p><p>​    各个类型的变量之间最主要的区别就是作用域的不同了，普通全局变量的作用域在整个源程序中，全局变量对整个源程序中都是可见的，无论源程序是由单个文件还是多个文件组成，普通全局变量具有external链接属性，所以普通全局变量在整个源程序的各个文件中都可以被引用。</p><h1 id="2-静态全局变量"><a href="#2-静态全局变量" class="headerlink" title="2.静态全局变量"></a>2.静态全局变量</h1><p>​    静态全局变量是定义在函数和类外的由static标识的变量。</p><p>​    静态全局变量具有文件作用域，具有internal链接属性，只能在定义的文件中使用，在其他文件中可以定义同名的变量，而全局变量则不行，这里要注意静态全局变量与类静态全局变量是不同的，类静态全局变量受到类权限限制，不同的访问权限就之间决定了类静态全局变量的作用域，类全局变量的使用与类一致，能使用类的地方就能使用类全局变量。</p><p>​    关于普通全局变量和静态全局变量的区别，我一直没有弄得很清楚，我有在网上查阅很多bolg，大家的说法都出奇的一致，我上面写的也是在查阅很多blog后总结的，但是我实际测试时，普通全局变量和静态全局变量似乎都可以被其他文件使用，并且 在其他文件中定义静态全局变量似乎也没有报错，没有弄明白这个其他文件指的是什么文件。</p><p><img src="/2019/09/11/%E3%80%90C++%E3%80%91%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E9%9D%99%E6%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/Snipaste_2019-09-11_21-36-28.png"></p><p><img src="/2019/09/11/%E3%80%90C++%E3%80%91%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E9%9D%99%E6%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/Snipaste_2019-09-11_21-36-38.png"></p><h1 id="3-普通局部变量"><a href="#3-普通局部变量" class="headerlink" title="3.普通局部变量"></a>3.普通局部变量</h1><p>​    普通局部变量是定义在函数内的没有static标识的变量。</p><p>​    普通局部变量具有块作用域，生命周期从定义开始到跳出函数结束，普通局部变量每次使用都会初始化一次。</p><h1 id="4-静态局部变量"><a href="#4-静态局部变量" class="headerlink" title="4.静态局部变量"></a>4.静态局部变量</h1><p>​    静态局部变量的作用于和普通局部变量一致，但是静态局部变量的内存地址在函数结束后不会被销毁，且会保存赋值结果，静态局部变量和静态全局变量一样会一直驻留在静态区，静态局部变量只会初始化一次，在下一次函数被调用时不会再初始化而是直接调用。</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPlus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C#】C#两种二维数组的区别</title>
    <link href="/2019/09/11/%E3%80%90C#%E3%80%91C#%E4%B8%A4%E7%A7%8D%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2019/09/11/%E3%80%90C#%E3%80%91C#%E4%B8%A4%E7%A7%8D%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>C#支持两种二维数组的定义方式（以int数组为例）：</p><h1 id="1-普通数组"><a href="#1-普通数组" class="headerlink" title="1.普通数组"></a>1.普通数组</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span>[,] array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><p>这种方式形式上较为简便，要注意的是new之后的[]里面是一定要注明数组大小的，不注明会报错，也就是说这种方式定义的数组是确定大小的。</p><p>数组的赋值：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span>[,] array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-多播数组"><a href="#2-多播数组" class="headerlink" title="2.多播数组"></a>2.多播数组</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span>[][] array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">2</span>][];<br></code></pre></td></tr></table></figure><p>这种方式需要注明行数，列数不能注明，注明会报错，这种方式定义的是一个函数确定而列数不确定的不确定大小的数组。</p><p>数组的赋值：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span>[][] array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">2</span>][]&#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;&#125;<br></code></pre></td></tr></table></figure><p>两种二维数组是不能兼容的，即使用方式1定义的二维数组不能使用方式2来使用，反之亦然。</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Lua】Lua基础</title>
    <link href="/2019/09/09/%E3%80%90Lua%E3%80%91Lua%E5%9F%BA%E7%A1%80/"/>
    <url>/2019/09/09/%E3%80%90Lua%E3%80%91Lua%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://img-blog.csdnimg.cn/2019090916141255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190909161442706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>参考博文：<a href="https://www.cnblogs.com/cjswwdz/p/5634442.html">https://www.cnblogs.com/cjswwdz/p/5634442.html</a></p><p>XMind源文件：<a href="https://github.com/Goulandis/XMinds-2019.8.27/tree/master/Lua">https://github.com/Goulandis/XMinds-2019.8.27/tree/master/Lua</a></p><p>学习地址：<a href="https://www.bilibili.com/video/av50685253?from=search&amp;seid=12754355294240767428">https://www.bilibili.com/video/av50685253?from=search&amp;seid=12754355294240767428</a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lua</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Unity3d】Space</title>
    <link href="/2019/08/25/%E3%80%90Unity3d%E3%80%91Space/"/>
    <url>/2019/08/25/%E3%80%90Unity3d%E3%80%91Space/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="/2019/08/25/%E3%80%90Unity3d%E3%80%91Space/Unity3d_Space.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity3d</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Unity3d】Lightmap</title>
    <link href="/2019/08/25/%E3%80%90Unity3d%E3%80%91Lightmap/"/>
    <url>/2019/08/25/%E3%80%90Unity3d%E3%80%91Lightmap/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="/2019/08/25/%E3%80%90Unity3d%E3%80%91Lightmap/Unity_Lightmap.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity3d</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【计算机网络】网络游戏基础</title>
    <link href="/2019/08/25/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%9F%BA%E7%A1%80/"/>
    <url>/2019/08/25/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="/2019/08/25/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%9F%BA%E7%A1%80.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序编程高级</title>
    <link href="/2019/08/25/%E3%80%90%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E3%80%91%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7/"/>
    <url>/2019/08/25/%E3%80%90%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E3%80%91%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="/2019/08/25/%E3%80%90%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E3%80%91%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程序编程原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【计算机网络】物联网通信基础</title>
    <link href="/2019/08/25/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E7%89%A9%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/"/>
    <url>/2019/08/25/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E7%89%A9%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="/2019/08/25/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E7%89%A9%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/%E7%89%A9%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux基础</title>
    <link href="/2019/08/25/%E3%80%90Linux%E3%80%91Linux%E5%9F%BA%E7%A1%80/"/>
    <url>/2019/08/25/%E3%80%90Linux%E3%80%91Linux%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><center>Linux学习笔记</center><h1 id="l-pwd：查看当前所在路"><a href="#l-pwd：查看当前所在路" class="headerlink" title="l  pwd：查看当前所在路"></a>l  <strong>pwd</strong>：查看当前所在路</h1><p>命令格式：命令 -选项 -参数（目录）</p><p>命令：</p><p>ls：查看当前路径下的文件</p><p>选项：</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td><strong>-d</strong></td><td>只查看当前目录的信息</td></tr><tr><td><strong>-l</strong></td><td>查看详细信息</td></tr><tr><td><strong>-a</strong></td><td>显示所有文件（包含隐藏文件）</td></tr><tr><td><strong>-h</strong></td><td>显示文件大小</td></tr></tbody></table><p>例：ls -l     命令 -选项</p><p>选项可以组合：ls -a -l/ls -al：查看所有文件的详细信息</p><p>ls -al /etc/   命令 -选项 -参数 ：查看etc目录下的所有文件的详细信息</p><h1 id="l-cd-：-路径切换"><a href="#l-cd-：-路径切换" class="headerlink" title="l  cd ： 路径切换"></a>l  <strong>cd</strong> <strong>：</strong> <strong>路径切换</strong></h1><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>“**-**”</td><td>返回到之前目录</td></tr><tr><td>“**..**”</td><td>返回上一级目录（“.”当前目录，“..”上一级目录）</td></tr><tr><td>“**~**”</td><td>到用户所在的家目录（家目录：用户所在目录，如windowsC盘的用户目录）</td></tr></tbody></table><p>touch ：cd到临时目录tmp下可创建新文件    touch 文件名</p><h1 id="l-Linux目录结构"><a href="#l-Linux目录结构" class="headerlink" title="l  Linux目录结构"></a>l  <strong>Linux目录结构</strong></h1><table><thead><tr><th>文件名</th><th>作用</th></tr></thead><tbody><tr><td>/boot</td><td>linux启动时，需要的文件</td></tr><tr><td>/dve</td><td>设备文件</td></tr><tr><td>/etc</td><td>配置文件</td></tr><tr><td>/home</td><td>用户家目录</td></tr><tr><td>/media</td><td>媒体文件</td></tr><tr><td>/mnt</td><td>挂载文件</td></tr><tr><td>/opt</td><td>第三方软件</td></tr><tr><td>/proc</td><td>虚拟化文件</td></tr><tr><td>/root</td><td>管理员的家目录</td></tr><tr><td>/run</td><td>远程文件</td></tr><tr><td>/srv</td><td>压缩过的文件</td></tr><tr><td>/sys</td><td>系统文件</td></tr><tr><td>/usr</td><td>安装的软件，</td></tr><tr><td>/var</td><td>可变数据、日志</td></tr><tr><td>/tmp</td><td>临时文件</td></tr><tr><td>/usr/bin</td><td>普通用户可以使用的命令</td></tr><tr><td>/usr/sbin</td><td>超级用户可以使用的命令</td></tr><tr><td>/usr/lib</td><td>32位库文件</td></tr><tr><td>/usr/lib64</td><td>64位库文件</td></tr></tbody></table><h1 id="l-Linux文件处理"><a href="#l-Linux文件处理" class="headerlink" title="l  Linux文件处理"></a>l  <strong>Linux文件处理</strong></h1><h2 id="文件类型判断："><a href="#文件类型判断：" class="headerlink" title="文件类型判断："></a><strong>文件类型判断：</strong></h2><p>-ls -l</p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811223714.png" alt="img"></p><table><thead><tr><th>文件以“_”开头</th><th>文件类型</th></tr></thead><tbody><tr><td>“d”</td><td>目录</td></tr><tr><td>“-”</td><td>文件</td></tr><tr><td>“l”</td><td>链接文件（类似win中快捷方式）</td></tr><tr><td>“b”</td><td>设备文件，提供存储接口的设备</td></tr><tr><td>“c”</td><td>设备文件，提供串行结合口的设备—键盘</td></tr></tbody></table><h2 id="文件处理："><a href="#文件处理：" class="headerlink" title="文件处理："></a><strong>文件处理：</strong></h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811223801.png" alt="img"></p><p>cp            cp abc a：复制abc并命名为a/多文件复制：cp a abc goulandis/：复制a、abc到goulandis下</p><p>mv            mv 文件1 文件2：将文件1更名为文件2/mv 文件1（文件2 ….） 目录：将文件移动到目录下                 </p><p>rm             rm -f 文件1 （文件2…）：强制删除</p><p>mkdir       mkdir -p （要创建的）目录1/（要创建的）目录2：创建目录1并在目录1下创建目录2</p><h2 id="查看文件："><a href="#查看文件：" class="headerlink" title="查看文件："></a><strong>查看文件：</strong></h2><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><strong>cat/**</strong>路径**</td><td>查看文件</td></tr><tr><td>nl</td><td>显示的时候，顺便出现行号</td></tr><tr><td>tac</td><td>从最后一行开始显示</td></tr><tr><td>head</td><td>显示文件前10行 -n：设置行数</td></tr><tr><td>tail</td><td>显示文件尾10行 -n：设置行数</td></tr><tr><td>wc</td><td>显示文件行数，数字，字节</td></tr><tr><td>more</td><td>一页一页翻动</td></tr><tr><td><strong>less</strong></td><td>一页一页翻动</td></tr></tbody></table><table><thead><tr><th><strong>cat**</strong>和tac**<strong>选项</strong></th><th>作用</th></tr></thead><tbody><tr><td>-A</td><td>整合命令-vET（整合-v、-E、-T）</td></tr><tr><td>-b</td><td>列出行号，但是空白行不标志行号</td></tr><tr><td>-E</td><td>将结尾的断行字符（$）显示出来</td></tr><tr><td>-n</td><td>列出行号，空白行也会标志出来</td></tr><tr><td>-T</td><td>将tab键以^I显示</td></tr><tr><td>-v</td><td>列出一些看不出来的字符</td></tr><tr><td>&lt;区分大小写&gt;</td><td></td></tr></tbody></table><table><thead><tr><th><strong>nl**</strong>的选项**</th><th></th><th></th></tr></thead><tbody><tr><td>总选项</td><td>分选项</td><td>作用</td></tr><tr><td>b</td><td>ba</td><td>无论是否有空，都列出行号</td></tr><tr><td>bt</td><td>如果有空行，则不列出行号（默认）</td><td></td></tr><tr><td>n</td><td>nln</td><td>行号在屏幕最左方</td></tr><tr><td>nrn</td><td>行号在屏幕最右方，前面不加0</td><td></td></tr><tr><td>nrz</td><td>行号在屏幕最右方，前面加0</td><td></td></tr><tr><td>w</td><td></td><td>缩进多少位</td></tr></tbody></table><table><thead><tr><th><strong>more**</strong>的选项**</th><th>作用</th></tr></thead><tbody><tr><td>空格</td><td>向下翻一页</td></tr><tr><td>回车</td><td>向下翻一行</td></tr><tr><td>/字符串</td><td>搜索</td></tr><tr><td>:f</td><td>立刻显示文件名和行数</td></tr><tr><td>b</td><td>翻到第一页</td></tr><tr><td>q</td><td>离开</td></tr></tbody></table><table><thead><tr><th><strong>less**</strong>的选项**</th><th>作用</th></tr></thead><tbody><tr><td><strong>空格</strong></td><td>向下翻动一行</td></tr><tr><td><strong>回车</strong></td><td>向下翻动一页</td></tr><tr><td><strong>pagedown</strong></td><td>向下翻动一页</td></tr><tr><td><strong>pageup</strong></td><td>向上翻动一页</td></tr><tr><td><strong>n</strong></td><td>重复前一个搜索（操作：n）</td></tr><tr><td><strong>N</strong></td><td>反向重复前一个搜索（操作：shift+n）</td></tr><tr><td><strong>q</strong></td><td>退出</td></tr></tbody></table><table><thead><tr><th>head和tail的选项</th><th>作用</th></tr></thead><tbody><tr><td>-n</td><td>指定显示几行，默认10行</td></tr><tr><td>日志文件路径（/var/log/messages）</td><td>查看日志</td></tr></tbody></table><table><thead><tr><th>wc的选项</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>只显示字节</td></tr><tr><td>-w</td><td>只显示字数，一个字被定义为空白、跳格、换行字符、分隔字符串</td></tr><tr><td>-l</td><td>只显示行</td></tr></tbody></table><table><thead><tr><th><strong>Vim编辑器操作命令</strong></th><th>作用</th></tr></thead><tbody><tr><td><strong>i</strong></td><td>插入</td></tr><tr><td><strong>esc</strong></td><td>退出</td></tr><tr><td><strong>u</strong></td><td>撤销</td></tr><tr><td><strong>x</strong></td><td>删除</td></tr><tr><td><strong>v</strong></td><td>选择文本</td></tr><tr><td><strong>y</strong></td><td>复制</td></tr><tr><td><strong>yy</strong></td><td>复制当前行</td></tr><tr><td><strong>dd</strong></td><td>删除光标所在行</td></tr><tr><td><strong>p</strong></td><td>粘贴</td></tr><tr><td><strong>:w</strong></td><td>保存</td></tr><tr><td><strong>:wq</strong></td><td>保存并退出</td></tr><tr><td><strong>:q**</strong>！**</td><td>强制退出</td></tr></tbody></table><h2 id="软链接："><a href="#软链接：" class="headerlink" title="软链接："></a><strong>软链接：</strong></h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811223809.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811223812.png" alt="img"></p><h2 id="硬链接："><a href="#硬链接：" class="headerlink" title="硬链接："></a><strong>硬链接：</strong></h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811223815.png"></p><p>ls -I ：查看Inode编号</p><h1 id="l-关机操作"><a href="#l-关机操作" class="headerlink" title="l  关机操作"></a>l  <strong>关机操作</strong></h1><table><thead><tr><th>sync</th><th>数据同步写入磁盘</th></tr></thead><tbody><tr><td><strong>shutdown</strong></td><td>常用关机指令</td></tr><tr><td>reboot、halt、poweroff</td><td>重启，关机</td></tr></tbody></table><table><thead><tr><th>shutdown的指令</th><th>作用</th></tr></thead><tbody><tr><td>-t</td><td>添加秒数。几秒后关机</td></tr><tr><td>-k</td><td>不是真关机，二十发出警告信息</td></tr><tr><td><strong>-r</strong></td><td>在系统服务都停止后，重启</td></tr><tr><td><strong>-h</strong></td><td>在系统服务都停止后，关机</td></tr><tr><td>-f</td><td>关闭，并且开机一个后强行略过磁盘检查</td></tr><tr><td>-F</td><td>重启后强制进行磁盘检查</td></tr><tr><td>-c</td><td>取消已经在进行的shutdown指令内容</td></tr><tr><td></td><td>shutdown -h now    现在马上停止服务并关机   shutdown -h 12：00       在12：00时刻停止服务并关机   shutdown -h +10     十分钟以后停止服务并关机   shutdown -r now     现在马上停止服务并重启   shutdown -r +30 ‘the system will reboot’       先发一个警告信息“the system will reboot”，系统将要在30分钟后重启   shutdown -k now ‘the system will reboot’     现在马上发出一个警告信息“the system will reboot”</td></tr></tbody></table><h1 id="l-Linux文件权限"><a href="#l-Linux文件权限" class="headerlink" title="l  Linux文件权限"></a>l  <strong>Linux文件权限</strong></h1><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811223822.png" alt="img"></p><table><thead><tr><th>权限</th><th>连接</th><th>所有者</th><th>所属组</th><th>容量（默认单位B）</th><th>修改日期</th><th>文件名</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th><strong>文件的权限</strong></th><th></th></tr></thead><tbody><tr><td>r、w、x ： 读、写、执行，没有权限就是-</td><td></td></tr><tr><td>第一组rwx</td><td>文件所有者的权限</td></tr><tr><td>第二组rwx</td><td>文件所属组的权限</td></tr><tr><td>第三组rwx</td><td>文件其他人的权限</td></tr></tbody></table><table><thead><tr><th><strong>目录的权限</strong></th><th></th></tr></thead><tbody><tr><td>r</td><td>具有读取目录的结构列表的权限，可以查看目录下有哪些文件</td></tr><tr><td>w</td><td>该权限对于目录来说是很大的</td></tr><tr><td>1</td><td>可以在该目录下新建新的文件和目录</td></tr><tr><td>2</td><td>可以删除已存在的文件和目录</td></tr><tr><td>3</td><td>将已存在的文件和目录重命名</td></tr><tr><td>4</td><td>移动该目录内的文件和目录的位置</td></tr><tr><td>X</td><td>是否可以进入该目录</td></tr></tbody></table><table><thead><tr><th><strong>文件权限的修改</strong></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>命令</td><td>命令作用</td><td>格式</td><td>选项</td><td>选项作用</td><td></td></tr><tr><td>chown</td><td>修改文件的拥有者，前提是要有该拥有者</td><td>chown 拥有者   文件/目录</td><td>-R</td><td>递归修改</td><td></td></tr><tr><td>chgrp</td><td>修改文件所属组，前提是要有该组</td><td></td><td>-R</td><td>递归修改</td><td></td></tr><tr><td>chmod</td><td>修改拥有者和所属组的权限</td><td></td><td></td><td></td><td></td></tr><tr><td>加减法</td><td>chmod    u/g/o+/-/=r/w/x 123：   将文件1213给用户/组/其他人加/减/赋予一个读/写/执行权限</td><td></td><td></td><td></td><td></td></tr><tr><td>数字法</td><td>r=4    w=2  x=1 ： chmod  632 123 ：   将文件123给用户赋予r和w权限，给组赋予wx权限，给其他人赋予w权限</td><td></td><td></td><td></td><td></td></tr><tr><td>chown -R goulandis 123 ： 将123目录下的所有文件包括目录本身的拥有者修改为goulandis</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p><strong>默认权限：</strong></p><p>umask      查看当前用户的umask权限       </p><p>umask –(选项) ：临时修改默认权限</p><p>/etc/bashrc ： 永久修改默认权限（通过修改脚本文件实现）</p><p>umask的选项说明</p><p>0022         拿走的权限</p><p>​         第一个数字表示特殊权限</p><p>​         022=rwxr-xr-x ：不拿走用户的权限、拿走用户组的w权限、拿走其他用户的w权限</p><p>目录无法拿走x权限</p><p>普通用户umask值 0002</p><p>root用户umask值 0022</p><h2 id="文件的特殊权限"><a href="#文件的特殊权限" class="headerlink" title="文件的特殊权限:"></a><strong>文件的特殊权限:</strong></h2><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811223827.png" alt="img"></p><p>当s出现在拥有者的x权限的位置时，表示拥有者有SUID的权限（Set UID）</p><p>当s出现在用户组的x权限的位置时，表示用户组有SGID的权限（Set GID）</p><p>当s出现在其他人的x权限的位置时，表示其他人有SBIT的权限（Sticky Bit）</p><table><thead><tr><th>SUID</th><th>临时获取文件拥有者的权限—–只能针对文件</th></tr></thead><tbody><tr><td>SGID</td><td>可以作用于目录，也可以作用于文件</td></tr><tr><td>作用于文件 ： 和SUID作用一样</td><td></td></tr><tr><td>作用与目录 ： 继承父级目—–目录会不停的继承，下级目录会一直继承父级目录的权限值</td><td></td></tr><tr><td>SBIT</td><td>只有文件的拥有者才能删除修改该目录下的文件—–只能针对目录</td></tr><tr><td>S和T有大小写之分   大写 ： 没有x权限   小写 ： 有x权限</td><td></td></tr><tr><td>数字法 ：SUID=4、SGID=2、SBIT=1</td><td></td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811223832.png" alt="img"></p><h1 id="l-Linux进程"><a href="#l-Linux进程" class="headerlink" title="l  Linux进程"></a>l  <strong>Linux进程</strong></h1><p>进程 ：已经启动的可执行程序的运行实例</p><p>PID : 进程的ID（每一个进程都有唯一的PID）</p><p>PPID ： 父进程的ID</p><p>任何一个进程都可以创建紫进程</p><table><thead><tr><th>ｐｓ　：　查看当前的进程情况</th><th></th></tr></thead><tbody><tr><td>选项</td><td>作用</td></tr><tr><td>－ａｕｘ／ａｕｘ</td><td>列出所有进程</td></tr><tr><td>－ｅｆ</td><td>列出所有进程</td></tr><tr><td>－ｌ</td><td>列出和当前用户有关的进程</td></tr><tr><td>－ｕ</td><td>查看某一用户的进程</td></tr><tr><td>－ｔｏｐ</td><td>实时查看进程状况</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20210811223836.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#高级</title>
    <link href="/2019/08/25/%E3%80%90C#%E3%80%91C#%E9%AB%98%E7%BA%A7/"/>
    <url>/2019/08/25/%E3%80%90C#%E3%80%91C#%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20190825170050917.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190825170113521.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20190825170131207.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#中级</title>
    <link href="/2019/08/25/%E3%80%90C#%E3%80%91C#%E4%B8%AD%E7%BA%A7/"/>
    <url>/2019/08/25/%E3%80%90C#%E3%80%91C#%E4%B8%AD%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<p>﻿<img src="https://img-blog.csdnimg.cn/20190825154217891.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C++】C++进阶</title>
    <link href="/2019/08/23/%E3%80%90C++%E3%80%91C++%E8%BF%9B%E9%98%B6/"/>
    <url>/2019/08/23/%E3%80%90C++%E3%80%91C++%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="1-C-介绍"><a href="#1-C-介绍" class="headerlink" title="1.C++介绍"></a>1.C++介绍</h1><p>​    C语言作为结构化和模块化语言适合规模较小的程序，对于大规模的复杂程序，能够高度抽象和建模的C++则更加适合，C++是C语言的加强版，以C语言为基础，并且完全兼容C语言的特性。<br><img src="https://img-blog.csdnimg.cn/20190623193001260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="2-C-对C语言的增强语法"><a href="#2-C-对C语言的增强语法" class="headerlink" title="2.C++对C语言的增强语法"></a>2.C++对C语言的增强语法</h1><p>​    2.1.命名空间<br>​    2.2.引用<br>​    2.3.函数与运算符的重载<br>​    2.4.面向对象的特性<br>​    2.5.泛型编程<br>​    2.6.异常处理<br>​    2.7.标准模板库<br>下面笔者就者7个特性进行详细说明：</p><h1 id="3-命名空间"><a href="#3-命名空间" class="headerlink" title="3.命名空间"></a>3.命名空间</h1><p>​    命名空间是C++提供的一种解决不同文件互相调用时符号名字冲突的方法，一个命名空间就是一个作用域，在不同的命名空间下允许相同的名字符号代表不同的实体。</p><h2 id="3-1命名空间的定义"><a href="#3-1命名空间的定义" class="headerlink" title="3.1命名空间的定义"></a>3.1命名空间的定义</h2><p><img src="https://img-blog.csdnimg.cn/20190623200228628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>        注意：命名空间的声明要在类和函数的外面定义，并且没有分号结束。</p><h2 id="3-2-命名空间成员的引用"><a href="#3-2-命名空间成员的引用" class="headerlink" title="3.2.命名空间成员的引用"></a>3.2.命名空间成员的引用</h2><p>命名空间名::成员名<br>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//1.cpp</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> namesapce <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">namespace</span> A &#123;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mian</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>,b = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; add(a,b)&lt;&lt;<span class="hljs-string">&quot;  &quot;</span>&lt;&lt;A::add(a,b)&lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br><span class="hljs-keyword">return</span>(a + b);<br>&#125;<br><br><span class="hljs-comment">//2.cpp</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">namespace</span> A &#123;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br><span class="hljs-keyword">return</span>(a + b)；<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>命名空间的声明方式，我们需要用到命名空间中的什么方法就在{}内加入什么方法的声明，当然直接使用“using namespace A”来声明A命名空间也是可以的，但是这种命名方法会将A命名空间下的所有方法都作声明，包括我们可能没有使用的方法，当工程很大时，这种做法会导致代码臃肿。</p><p>在很多人编程的时候，如果各程序员之间不一直进行密切的交流，极容易出现变量名或方法名类名等相同的情况，这样    在多文档联合编译时，编译器会无法区分同名符号而报错，而命名空间就很好的解决了这种问题，我们为各个文档都定义一个唯一的命名空间，这样即使是相同符号也可以通过命名空间唯一标识了，命名空间的出现极大的改善了多人编程的困处。</p><h2 id="3-3-命名空间的别名"><a href="#3-3-命名空间的别名" class="headerlink" title="3.3.命名空间的别名"></a>3.3.命名空间的别名</h2><p>命名空间是可以另起别命的，别命是已定义的命名空间的可代替的名字，一个命名空间可以有很多个别名，所有的别命和命名空间原名可以互换使用<br>别命的定义：namespace 别命 = 命名空间原名;<br>    <img src="https://img-blog.csdnimg.cn/2019062320111766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="3-4-命名空间的成员类型"><a href="#3-4-命名空间的成员类型" class="headerlink" title="3.4.命名空间的成员类型"></a>3.4.命名空间的成员类型</h2><p>命名空间的成员类型可以是变量、常量、函数、结构体、联合体、枚举、类、嵌套的命名空间</p><h2 id="3-5-全局命名空间"><a href="#3-5-全局命名空间" class="headerlink" title="3.5.全局命名空间"></a>3.5.全局命名空间</h2><p>在全局作用域中定义的命名空间，大多数命名空间都属于全局命名空间。即自定义的命名空间是全局命名空间的扩张和细分。全局命名空间是隐式声明的，它存在于每一个程序中。<br>由于全局命名空间是隐含的，它没有名字，所以使用“::成员名字”引用全局命名空间。</p><h2 id="3-6-匿名命名空间"><a href="#3-6-匿名命名空间" class="headerlink" title="3.6.匿名命名空间"></a>3.6.匿名命名空间</h2><p>匿名命名空间与全局命名空间类似，也没有名字，但是匿名命名空间定义在局部作用域，不能用于多文件编译。<br>匿名命名空间可以直接使用变量名引用成员。</p><h1 id="4-引用"><a href="#4-引用" class="headerlink" title="4.引用"></a>4.引用</h1><h2 id="4-1-什么是引用？"><a href="#4-1-什么是引用？" class="headerlink" title="4.1.什么是引用？"></a>4.1.什么是引用？</h2><p>引用即别命，是某一个变量或对象的别命，绑定一个引用到一个变量或对象，即引用初始化，之后对引用的操作完全等价于对与其绑定的变量或对象的操作。</p><h2 id="4-2-引用的定义"><a href="#4-2-引用的定义" class="headerlink" title="4.2.引用的定义"></a>4.2.引用的定义</h2><p>类型 &amp;引用名 = 目标变量名;<br>需要注意的是：</p><ul><li>&amp;不是求地址运算符，而是起标志作用</li><li>引用的类型必须和其所绑定的变量类型相同</li><li>声明应用的同时必须对其初始化，否则系统会报错</li><li>引用相当于变量或对象的别命，因此不可将已绑定的引用再绑定其他变量或对象，也不可将一个引用绑定另一个引用。</li></ul><h2 id="4-3-引用与指针的区别"><a href="#4-3-引用与指针的区别" class="headerlink" title="4.3.引用与指针的区别"></a>4.3.引用与指针的区别</h2><ul><li><p>占用存储空间上：<br>引用占用一个地址空间，本地计算机的一个地址空间是多少位，引用就占多少位的地址空间。<br>而指针除了占用一个地址空间外，还占用一个数据空间用于存储其指向的变量或对象的地址。</p></li><li><p>在操作上：<br>引用声明的同时必须对其初始化，且初始化后引用不可更改，引用不能为空。如：int &amp;a ;是错误的用法，正确的用法应该是：int &amp;a = b;<br>指针的声明可以在任何时候初始化，且指针在后续操作中可以变更其指向的变量或对象，指针可以为空。</p></li><li><p>存储内容上<br>“sizeof引用”得到的是引用所指向的变量或对象的大小<br>“sizeof指针”得到的是指针本身的大小</p></li><li><p>层级上<br>引用只能有一级，引用不可以再指向引用<br>指针理论上对级数没有限制</p></li><li><p>可以将引用理解为不可更改的指针，即：类型* const 指针变量</p></li></ul><h2 id="4-4-对数组的引用"><a href="#4-4-对数组的引用" class="headerlink" title="4.4.对数组的引用"></a>4.4.对数组的引用</h2><p>类型 （&amp;引用名）[数组下标] = 数组名;<br>如：对int a[3]数组的引用为int (&amp;quote)[3] = a;即将引用名替换成数组名。<br>这里要注意，“()”是不能省略的，因为如果省略()，则会改变优先级，变成int &amp;(quote[3]) = a;而出现语法错误。</p><h2 id="4-5-对指针的引用"><a href="#4-5-对指针的引用" class="headerlink" title="4.5.对指针的引用"></a>4.5.对指针的引用</h2><p>类型* &amp;引用名 = 指针名;<br>如：int* &amp;quote = p;</p><h2 id="4-6-引用的作用"><a href="#4-6-引用的作用" class="headerlink" title="4.6.引用的作用"></a>4.6.引用的作用</h2><p>引用既可以作为别命使用，还可以作为函数的参数、函数的返回值使用。<br>需要注意的是，引用作为函数的返回值时不能返回局部变量的引用。<br>至此，我可能提出这样的疑问：引用能做的事指针也能做，引用不能做的事指针还能做，那么C++么什么要引入“引用”这个概念呢？<br>这是因为，指针的操作太过于强大，正因如此对指针的使用存在一定的风险，所谓“收益与风险并存”，在很多高版本的编译器中已经不能再操作指针了，如VS2015，而C++之所以还保留着指针，是因为指针的魅力无比诱人，尽管有风险却不愿意就此抛弃。<br>引用的另一个用处我们举一个例子来说明<br>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add_1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> b)</span></span>&#123;<br>b++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add_2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;c)</span></span>&#123;<br>c++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mian</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> &amp;a = a;<br><span class="hljs-built_in">cout</span>&lt;&lt;add_1(a)&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;add_2(&amp;a)&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们的输出结果是：1 2，为什么呢?因为普通的参数传递，传递的是参数的拷贝，如add_1我们对b++，实际进行运算的是形参b，而实参a却没有发生运算，所以cout&lt;&lt;add_1(a)输出1，而如果传递引用的话，我们在函数add_2中对引用的操作实质上就是对a进行运算，因为&amp;a就是a。</p><h2 id="4-7-常引用"><a href="#4-7-常引用" class="headerlink" title="4.7.常引用"></a>4.7.常引用</h2><p>const 类型 &amp;引用名 = 目标变量名<br>常引用可以引用常量也可以引用变量，常引用不允许通过引用对其绑定的变量或对象进行修改。</p><h2 id><a href="#" class="headerlink" title></a><img src="https://img-blog.csdnimg.cn/2019062512243728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></h2><h1 id="5-函数重载"><a href="#5-函数重载" class="headerlink" title="5.函数重载"></a>5.函数重载</h1><h2 id="5-1-C-重载的实现"><a href="#5-1-C-重载的实现" class="headerlink" title="5.1.C++重载的实现"></a>5.1.C++重载的实现</h2><p>从本质上来说，C++之所以能实现函数的重载是因为C++编译器对函数名的处理方法进行了优化，我们来对比一下C语言编译器和C++编译器对函数名的编译</p><ul><li><p>C语言编译器<br>对函数 int add(int a);编译后的名字为：add</p></li><li><p>C++编译器<br>对函数int add(int a);编译后的名字为：addi，对int add(int a,float b);编译后的名字为：addij，C++编译器使用函数名和参数类型的共同组合成编译后函数的唯一标识，即可实现函数的重载。</p></li></ul><h2 id="5-2-重载的定义"><a href="#5-2-重载的定义" class="headerlink" title="5.2.重载的定义"></a>5.2.重载的定义</h2><p>重载就是在相同的声明域中函数名相同而参数列表不同，通过函数的参数表唯一标识的函数。</p><h2 id="5-3-函数的默认参数"><a href="#5-3-函数的默认参数" class="headerlink" title="5.3.函数的默认参数"></a>5.3.函数的默认参数</h2><p>C++可以使用默认参数，即在函数声明时为参数提供一个默认值，当函数调用时没有指定这个参数的值时，编译器会自动使用默认值替换。<br><img src="https://img-blog.csdnimg.cn/20190625221621705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>需要注意的是，默认参数只能放在声明或定义处，能放在声明处就放在声明处。如果某个参数是默认参数，那么其后的参数也必须都是默认参数，如：<code>int add(int a = 1,int b,int c);</code>编译器将报错，而<code>int add(int a,int b = 1,int c = 2);</code>则不会报错，因为参数在传递的时候是从左到右的，首先使用无默认参数的参数列表，当遇到没有传入实参的形参时开始使用默认参数的参数列表。使用默认参数的情况仅限于用在没有没有重载冲突的函数上，如：重载add函数，<code>int add()&#123;...&#125; int add(int a = 1,int b = 2)&#123;...&#125;</code>,此时调用add();将调用不带参数的add()函数。<br><img src="https://img-blog.csdnimg.cn/20190625222013457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="5-4-内联函数"><a href="#5-4-内联函数" class="headerlink" title="5.4.内联函数"></a>5.4.内联函数</h2><h3 id="5-4-1-为什么需要内联函数？"><a href="#5-4-1-为什么需要内联函数？" class="headerlink" title="5.4.1.为什么需要内联函数？"></a>5.4.1.为什么需要内联函数？</h3><p>在程序执行的过程中，当碰到函数调用时，系统要将程序当前状态保存到栈中，同时跳转到函数代码处执行函数体，此过程需要占用时间和空间，是的程序执行效率低下。当然我们声明一个内联函数只是建议编译器将此函数作为内联函数，但是编译器有自己的判断算法，在编译时编译器会自行判断我们声明的内联函数是否值得变为内联函数，以保证主程序体不会过于臃肿，所以我们声明的内联函数不一定会成为内联函数。</p><h3 id="5-4-2-内联函数的定义"><a href="#5-4-2-内联函数的定义" class="headerlink" title="5.4.2.内联函数的定义"></a>5.4.2.内联函数的定义</h3><p>inline 返回值类型 函数名(参数列表){函数体;} </p><h3 id="5-4-3-内联函数是一种用空间换时间的措施，通常只有较短的函数才定义为内联函数。"><a href="#5-4-3-内联函数是一种用空间换时间的措施，通常只有较短的函数才定义为内联函数。" class="headerlink" title="5.4.3.内联函数是一种用空间换时间的措施，通常只有较短的函数才定义为内联函数。"></a>5.4.3.内联函数是一种用空间换时间的措施，通常只有较短的函数才定义为内联函数。</h3><h1 id="6-new和delete运算符"><a href="#6-new和delete运算符" class="headerlink" title="6.new和delete运算符"></a>6.new和delete运算符</h1><h2 id="6-1-new运算符"><a href="#6-1-new运算符" class="headerlink" title="6.1.new运算符"></a>6.1.new运算符</h2><p>new运算符的功能是在堆区分配内存，通过new运算符获得的内存空间都处于堆上。delete运算符的功能正好与new相反，delete运算符的功能是释放new运算符的在堆区创建的内存，new运算符与delete运算符最好是配套出现，即使用new运算符创建了内存就一定要用delete运算符在不需要的时候此内存的时候将其释放，为什么呢？因为堆区的内存是不会随着程序结束而释放的，堆区的内存只要在操作系统关闭时才会释放，所以如果不手动释放new运算符在堆区创建的内存，则会造成大量无用数据占据着堆区内存，当堆区内存被占满时这会出现系统无堆区内存可用而出现系统死机。</p><h2 id="6-2-new-delete运算符的使用"><a href="#6-2-new-delete运算符的使用" class="headerlink" title="6.2.new/delete运算符的使用"></a>6.2.new/delete运算符的使用</h2><p>new &lt;数据类型&gt; (参数)<br>delete &lt;对象指针&gt;/delete &lt;对象数组指针&gt;<br><img src="https://img-blog.csdnimg.cn/201907121654256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="6-3-那么C-的new-delete与C语言的malloc-free有什么区别呢？"><a href="#6-3-那么C-的new-delete与C语言的malloc-free有什么区别呢？" class="headerlink" title="6.3.那么C++的new/delete与C语言的malloc/free有什么区别呢？"></a>6.3.那么C++的new/delete与C语言的malloc/free有什么区别呢？</h2><ul><li>它们都是动态管理内存的入口</li><li>malloc/free是C/C++标准库函数，而new/delete是C++操作符</li><li>malloc/free只是动态分分配/释放内存空间，而new/delete除了分配内存空间还会调用构造/析构函数进行初始化/清理（清理成员）</li><li>malloc/free需要手动计算类型大小且返回值为void，而new/delete可以自行计算类型大小返回对应类型的指针</li><li>new/delete在底层是调用了malloc/free的。可以认为是C++对malloc/free的封装</li><li>malloc/free申请空间后需要判空，new/delete则不需要</li><li>new直接跟类型，malloc跟字节数。<br>new/delete和malloc/free的区别是C++企业招聘时特别喜欢考的一项</li></ul><h1 id="7-程序的内存空间"><a href="#7-程序的内存空间" class="headerlink" title="7.程序的内存空间"></a>7.程序的内存空间</h1><h2 id="7-1-指针的内存操作"><a href="#7-1-指针的内存操作" class="headerlink" title="7.1.指针的内存操作"></a>7.1.指针的内存操作</h2><ul><li>指针不仅可以可以指向变量还可以指向函数</li><li>有new运算符在堆区创建的内存空间由位于栈区的指针确定入口</li></ul><p><img src="https://img-blog.csdnimg.cn/20190712165857369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>说到这，我们有必要了解一下计算机程序的内存结构，供程序运行的内存空间分为：堆区、栈区、.data段、.bss段、.ro段、.txt段，我使用一张图来说明<br><img src="https://img-blog.csdnimg.cn/20190712170749180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="8-面向对象编程的特点"><a href="#8-面向对象编程的特点" class="headerlink" title="8.面向对象编程的特点"></a>8.面向对象编程的特点</h1><p><img src="https://img-blog.csdnimg.cn/2019071310135053.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="9-C-中的类"><a href="#9-C-中的类" class="headerlink" title="9.C++中的类"></a>9.C++中的类</h1><h2 id="9-1-类的定义"><a href="#9-1-类的定义" class="headerlink" title="9.1.类的定义"></a>9.1.类的定义</h2><p><img src="https://img-blog.csdnimg.cn/2019071310150942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="9-2-访问权限"><a href="#9-2-访问权限" class="headerlink" title="9.2.访问权限"></a>9.2.访问权限</h2><ul><li>C++为类的成员添加了三种访问权限<br>public–公有成员：权限最高，在public修饰下的成员是类的外部接口，可以被类的成员函数和对象直接访问</li><li>protected–保护成员：权限居中，可以被类的成员函数和其派生类的成员函数直接访问，但不能被类的对象和派生类的对象直接访问。</li><li>private–私有成员：权限最低，只能通过类的成员函数访问。</li></ul><h2 id="9-3-类的成员"><a href="#9-3-类的成员" class="headerlink" title="9.3.类的成员"></a>9.3.类的成员</h2><ul><li>成员变量：类的成员变量用以描述一个对象的属性信息，与一般的变量声明相同，但类的成员变量只能在类的声明体中定义，类的成员变量一般在类的构造函数中初始化，但这不是必须的。</li><li>成员函数：用来描述一个对象的行为动作，与一般的函数声明相同，但只能放在类的声明体中声明，成员函数可以在类内实现也可以在类外实现，但在类内实现则形成内联的成员函数，会使类变得冗杂，所以成员函数的实现最好在类外实现，类成员函数可以重载和带默认参数。</li></ul><h2 id="9-4-类的成员函数与成员变量的声明与实现"><a href="#9-4-类的成员函数与成员变量的声明与实现" class="headerlink" title="9.4.类的成员函数与成员变量的声明与实现"></a>9.4.类的成员函数与成员变量的声明与实现</h2><p><img src="https://img-blog.csdnimg.cn/20190713104139644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="9-5-struct和class的区别"><a href="#9-5-struct和class的区别" class="headerlink" title="9.5.struct和class的区别"></a>9.5.struct和class的区别</h2><ul><li>C++对struct关键字扩展了其功能，和class的功能几乎等价</li><li>struct的成员默认访问权限是public，而class是private</li></ul><h2 id="9-6-this指针"><a href="#9-6-this指针" class="headerlink" title="9.6.this指针"></a>9.6.this指针</h2><ul><li>this指针是一个特殊的指针，指向对象的自身的首地址</li><li>每一个对象的成员函数都有一个this指针，指向调用的对象，如果要引用整个对象则通过*this引用</li><li>this指针仅能在类的内部使用，即只能在类的声明体或成员函数中使用</li></ul><h2 id="9-7-static关键字"><a href="#9-7-static关键字" class="headerlink" title="9.7.static关键字"></a>9.7.static关键字</h2><h3 id="9-7-1-static修饰的成员变量–静态成员变量"><a href="#9-7-1-static修饰的成员变量–静态成员变量" class="headerlink" title="9.7.1.static修饰的成员变量–静态成员变量"></a>9.7.1.static修饰的成员变量–静态成员变量</h3><ul><li>static修饰的变量存储在静态变量区</li><li>在类中static关键字修饰的变量被此类的所有对象共享，即所有对象共享这一个变量</li><li>static修饰的变量必须在类外初始化，不可以在定义的时候直接初始化</li><li>static修饰的公有成员变量可以直接通过类名来访问，没有staic修饰的成员变量只能通过对象才能访问<br><img src="https://img-blog.csdnimg.cn/20190713105202141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h3 id="9-7-2-static修饰的成员函数–静态成员函数"><a href="#9-7-2-static修饰的成员函数–静态成员函数" class="headerlink" title="9.7.2.static修饰的成员函数–静态成员函数"></a>9.7.2.static修饰的成员函数–静态成员函数</h3><ul><li>static修饰的成员函数也可以直接通过类名访问</li><li>静态成员函数只能访问静态成员变量</li></ul><h3 id="9-7-3-类的静态与非静态部分"><a href="#9-7-3-类的静态与非静态部分" class="headerlink" title="9.7.3.类的静态与非静态部分"></a>9.7.3.类的静态与非静态部分</h3><ul><li>静态部分只属于类，与类一起存放在内存的静态区，被所有对象共享</li><li>非静态部分属于对象，每个对象都有自己的非静态部分，互不影响</li><li>静态部分只能直接访问静态部分，非静态部分可以访问所有部分</li><li>那么为什么静态部分只能直接访问静态部分，而非静态部分却可以访问所有部分呢？<br>那是因为，非静态成员变量/函数是属于对象的，只能通过对象来访问，而静态部分是属于类的，使用静态部分时</li></ul><p>没有确定对象的存在，所以不能确定静态部分应该访问哪个对象的非静态部分，而静态部分是属于类的，所有对象共享，所以通过对象使用非静态部分时，可以访问静态部分。<br>思导图：<br><img src="https://img-blog.csdnimg.cn/20190623192350471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190712170853343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPlus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Unity3d】游戏截屏</title>
    <link href="/2019/08/23/%E3%80%90Unity3d%E3%80%91%E6%B8%B8%E6%88%8F%E6%88%AA%E5%B1%8F/"/>
    <url>/2019/08/23/%E3%80%90Unity3d%E3%80%91%E6%B8%B8%E6%88%8F%E6%88%AA%E5%B1%8F/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer">﻿<p>在Unity3d中游戏截屏操作比较简单，主要使用通过Application类下的CaptureScreenhot方法实现：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (Input.<span class="hljs-constructor">GetKeyDown(KeyCode.P)</span>) &#123;<br>            Application.<span class="hljs-constructor">CaptureScreenshot(<span class="hljs-string">&quot;截图&quot;</span> +<span class="hljs-params">screenhotNom</span>+<span class="hljs-string">&quot;.jpg&quot;</span>)</span>;<br>            screenhotNom++;<span class="hljs-comment">//截图序号</span><br>        &#125;<br></code></pre></td></tr></table></figure><p>截取的图片以设计者规定名字存储在与exe文件一起生成的的Data文件下，没有导出的项目直接存储到工程文件夹下<br><img src="https://img-blog.csdnimg.cn/20190622155156312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity3d</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Unity3d】简单的存档与读档</title>
    <link href="/2019/08/23/%E3%80%90Unity3d%E3%80%91%E5%AD%98%E6%A1%A3%E4%B8%8E%E8%AF%BB%E6%A1%A3/"/>
    <url>/2019/08/23/%E3%80%90Unity3d%E3%80%91%E5%AD%98%E6%A1%A3%E4%B8%8E%E8%AF%BB%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer">﻿<p>在Unity3d中，游戏的存档与读档主要由PlayerPrefs类来完成，在Windows下PlayerPrefs存档主要存储在注册表中，路径为HKCU\Software[company name][product name] ，这里的company name和product name由作者自己确定，在Edit-&gt;Project Settings-&gt;Player中可以设置<br><img src="https://img-blog.csdnimg.cn/20190622143530421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>PlayerSettings视图<br><img src="https://img-blog.csdnimg.cn/20190622143747327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>那么如何设计游戏存档呢？<br>以笔者个人的经验而言，在游戏设计之初，我们就应该想好需要存档的数据，为需要保存的数据或状态设计可供读取的状态标志，以便以后在设计存档时，提供给PlayerPrefs类的方法使用。<br>PlayerPrefs类提供如下方法供设计者使用<br><img src="https://img-blog.csdnimg.cn/20190622144312778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到，PlayerPrefs类中没有提供对bool型数据的存储方法，由此可以看出为需要保存的数据或状态设计可供读取的状态标志的重要性，否则那些由bool型数据确定的状态将无法被存档。<br><img src="https://img-blog.csdnimg.cn/20190622151126795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下面给一段示例代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    * inventory.charge--int--能量电池数量</span><br><span class="hljs-comment">    * inventory.playerTransform--float--玩家位置</span><br><span class="hljs-comment">    * talk.yeshu--int--man的任务进度</span><br><span class="hljs-comment">    * talk.wyeshu--int--women的任务进度</span><br><span class="hljs-comment">     */</span><br>   void game<span class="hljs-constructor">Save()</span> &#123;<br>       PlayerPrefs.<span class="hljs-constructor">SetInt(<span class="hljs-string">&quot;charge&quot;</span>, <span class="hljs-params">inventory</span>.<span class="hljs-params">charge</span>)</span>;<br>       PlayerPrefs.<span class="hljs-constructor">SetInt(<span class="hljs-string">&quot;yeshu&quot;</span>, <span class="hljs-params">talk</span>.<span class="hljs-params">yeshu</span>)</span>;<br>       PlayerPrefs.<span class="hljs-constructor">SetInt(<span class="hljs-string">&quot;wyeshu&quot;</span>, <span class="hljs-params">talk</span>.<span class="hljs-params">wyeshu</span>)</span>;<br>       PlayerPrefs.<span class="hljs-constructor">SetFloat(<span class="hljs-string">&quot;playerPosition.x&quot;</span>, <span class="hljs-params">inventory</span>.<span class="hljs-params">playerTransform</span>.<span class="hljs-params">position</span>.<span class="hljs-params">x</span>)</span>;<br>       PlayerPrefs.<span class="hljs-constructor">SetFloat(<span class="hljs-string">&quot;playerPosition.y&quot;</span>, <span class="hljs-params">inventory</span>.<span class="hljs-params">playerTransform</span>.<span class="hljs-params">position</span>.<span class="hljs-params">y</span>)</span>;<br>       PlayerPrefs.<span class="hljs-constructor">SetFloat(<span class="hljs-string">&quot;playerPosition.z&quot;</span>, <span class="hljs-params">inventory</span>.<span class="hljs-params">playerTransform</span>.<span class="hljs-params">position</span>.<span class="hljs-params">z</span>)</span>;<br>       PlayerPrefs.<span class="hljs-constructor">Save()</span>;<br>   &#125;<br>   void game<span class="hljs-constructor">Read()</span> &#123;<br>       <span class="hljs-keyword">if</span> (PlayerPrefs.<span class="hljs-constructor">HasKey(<span class="hljs-string">&quot;charge&quot;</span>)</span>)<span class="hljs-comment">//存档读取的一般方式</span><br>           inventory.charge = PlayerPrefs.<span class="hljs-constructor">GetInt(<span class="hljs-string">&quot;charge&quot;</span>)</span>;<br>       <span class="hljs-keyword">if</span> (PlayerPrefs.<span class="hljs-constructor">HasKey(<span class="hljs-string">&quot;yeshu&quot;</span>)</span>)<br>           talk.yeshu = PlayerPrefs.<span class="hljs-constructor">GetInt(<span class="hljs-string">&quot;yehsu&quot;</span>)</span>;<br>       <span class="hljs-keyword">if</span> (PlayerPrefs.<span class="hljs-constructor">HasKey(<span class="hljs-string">&quot;wyeshu&quot;</span>)</span>)<br>           talk.wyeshu = PlayerPrefs.<span class="hljs-constructor">GetInt(<span class="hljs-string">&quot;wyeshu&quot;</span>)</span>;<br>       <span class="hljs-keyword">if</span> (PlayerPrefs.<span class="hljs-constructor">HasKey(<span class="hljs-string">&quot;playerPosition.x&quot;</span>)</span>)<br>           x = PlayerPrefs.<span class="hljs-constructor">GetFloat(<span class="hljs-string">&quot;playerPosition.x&quot;</span>)</span>;<br>       <span class="hljs-keyword">if</span> (PlayerPrefs.<span class="hljs-constructor">HasKey(<span class="hljs-string">&quot;playerPosition.y&quot;</span>)</span>)<br>           y = PlayerPrefs.<span class="hljs-constructor">GetFloat(<span class="hljs-string">&quot;playerPosition.y&quot;</span>)</span>;<br>       <span class="hljs-keyword">if</span> (PlayerPrefs.<span class="hljs-constructor">HasKey(<span class="hljs-string">&quot;playerPosition.z&quot;</span>)</span>)<br>           z = PlayerPrefs.<span class="hljs-constructor">GetFloat(<span class="hljs-string">&quot;playerPosition.z&quot;</span>)</span>;<br>       inventory.playerTransform.position = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Vector3(<span class="hljs-params">x</span>, <span class="hljs-params">y</span>, <span class="hljs-params">z</span>)</span>;<br><br>   &#125;<br></code></pre></td></tr></table></figure><p>那么对于已经产生的注册表我们如何查看呢？<br>在Windows下通过注册表编辑器查看注册表，通过Win+R将呼出“运行”，输入“regedit”即可打开注册表编辑器在HKCU\Software[company name][product name] 路径下即可找到我们已经生成的注册表<br><img src="https://img-blog.csdnimg.cn/20190622151747405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity3d</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Unity3d】Animation</title>
    <link href="/2019/08/23/%E3%80%90Unity3d%E3%80%91Animation/"/>
    <url>/2019/08/23/%E3%80%90Unity3d%E3%80%91Animation/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>﻿1.总索引<br><img src="https://img-blog.csdnimg.cn/2019061314131628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>1.1.视图简介<br><img src="https://img-blog.csdnimg.cn/20190520144632375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190520143240580.png" alt="在这里插入图片描述"><br>2.动画分类<br><img src="https://img-blog.csdnimg.cn/20190613141413854.png" alt="在这里插入图片描述"></p><p>2.1.普通动画<br><img src="https://img-blog.csdnimg.cn/20190613141551260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    2.2.人物角色动画<br>    <img src="https://img-blog.csdnimg.cn/20190613141959166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    2.2.1.人物角色动画的导入<br>    <img src="https://img-blog.csdnimg.cn/20190613142213379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>+大图导向<br>    -骨骼映射视图的打开 <img src="https://img-blog.csdnimg.cn/20190531125401236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    -骨骼映射视图和骨骼映射表的修改<img src="https://img-blog.csdnimg.cn/20190531125301603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>-三种动画的导入方式<br><img src="https://img-blog.csdnimg.cn/20190613142757765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">-模型导入注意事项<br><img src="https://img-blog.csdnimg.cn/20190613142937598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190531130631610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    <img src="https://img-blog.csdnimg.cn/20190531130654193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2.3.IK动画<br><img src="https://img-blog.csdnimg.cn/20190613143849254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2.4.TimeLine<br><img src="https://img-blog.csdnimg.cn/20190613143939800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>+大图导向<br>    -存储<br>    <img src="https://img-blog.csdnimg.cn/20190613144055967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    -Playable Track<br>    <img src="https://img-blog.csdnimg.cn/20190613144133197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.AnimatorController(状态机)<br><img src="https://img-blog.csdnimg.cn/20190613144259619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.1.状态机的打开方式<br><img src="https://img-blog.csdnimg.cn/20190613144350891.png" alt="在这里插入图片描述"><br>3.2.Animator视图简介<br><img src="https://img-blog.csdnimg.cn/20190613144502456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.3.作用<br><img src="https://img-blog.csdnimg.cn/20190613144550261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.4.精细控制<br><img src="https://img-blog.csdnimg.cn/20190613144641944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>+大图导向<br><img src="https://img-blog.csdnimg.cn/20190613144744729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.5.混合树<br><img src="https://img-blog.csdnimg.cn/201906131452528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.5.1.四种2D混合树<br><img src="https://img-blog.csdnimg.cn/20190613145340965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.5.2.大图导向<br> -混合树的创建<br> <img src="https://img-blog.csdnimg.cn/20190613145440631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> -1D混合树Inspector<br> <img src="https://img-blog.csdnimg.cn/20190613144953557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> -2D混合树Inspector<br> <img src="https://img-blog.csdnimg.cn/20190613145057715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.6.Avatar Mask骨骼遮罩<br><img src="https://img-blog.csdnimg.cn/20190613145729200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4.MacthTarget场景动画匹配技术<br><img src="https://img-blog.csdnimg.cn/20190613145909634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4.1.核心方法<br><img src="https://img-blog.csdnimg.cn/20190613150056658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4.2.MacthTarget函数细述<br><img src="https://img-blog.csdnimg.cn/20190613150207340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4.3.难点<br><img src="https://img-blog.csdnimg.cn/20190613150430468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>+大图导向<br><img src="https://img-blog.csdnimg.cn/2019061315050794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>5.相机运动<br><img src="https://img-blog.csdnimg.cn/20190613150709467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>+大图导向<br><img src="https://img-blog.csdnimg.cn/20190613150735692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>6.学习过程中遇到的问题<br><img src="https://img-blog.csdnimg.cn/20190613150827535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>7.函数方法<br><img src="https://img-blog.csdnimg.cn/20190613150913675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>8.动画的Inspector<br><img src="https://img-blog.csdnimg.cn/20190613151018312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity3d</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【计算机图形学】多边形填充算法</title>
    <link href="/2019/08/23/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E3%80%91%E5%A4%9A%E5%8F%98%E5%BD%A2%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/"/>
    <url>/2019/08/23/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E3%80%91%E5%A4%9A%E5%8F%98%E5%BD%A2%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>首先对于如下的多边形：</p><p><img src="https://img-blog.csdnimg.cn/20190618080545123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="1-有效边表填充算法"><a href="#1-有效边表填充算法" class="headerlink" title="1.有效边表填充算法"></a>1.有效边表填充算法</h1><h2 id="1-1-有效边表填充算法分为如下几个步骤："><a href="#1-1-有效边表填充算法分为如下几个步骤：" class="headerlink" title="1.1.有效边表填充算法分为如下几个步骤："></a><strong>1.1.有效边表填充算法分为如下几个步骤</strong>：</h2><p>​    1.1.1.将多边形所有的边分别与扫描线1计算交点，得到交点集，与扫描线计算的边没有顺序要求。<br>​    1.1.2.将点集按标x的大小递增排序，得到有序点集。<br>​    1.1.3.将有序点集两两配对，得到对应的像素区间。<br>​    1.1.4.将像素区间内的像素填充颜色，至此第一条扫描线上处于多边形内的的像素填充完毕。<br>​    1.1.5.扫描线标号加1，重复以上步骤，直至到最后一条扫描线。<br>​    如：对于扫描线3（y=3）与多边形所有的边计算交点，得到与P3P4交于点（4.5，3），与P3P2交于点（2.4，3），与P5P6交于点（8.8，3），与P5P4交于点（7，3）。<br>​    圆整处理得到点集（5，3）、（2，3）、（9，3）、（7，3）。<br>​    递增排序得到有序点集（2，3）、（5，3）、（7，3）、（9，3）。<br>​    两两配对得到扫描线3上的填充像素区间[2，5]、[7，9]。<br>​    填充区间内的所有像素。<br>​    得到如图所示的填充效果：<br><img src="https://img-blog.csdnimg.cn/20190617115850448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>全部填充得到如下效果：<br><img src="https://img-blog.csdnimg.cn/20190617115915999.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-2-至此我们发现如下疑问："><a href="#1-2-至此我们发现如下疑问：" class="headerlink" title="1.2.至此我们发现如下疑问："></a><strong>1.2.至此我们发现如下疑问：</strong></h2><p>​    1.2.1.像素填充的多边形面积大于多边形实际面积。<br>​    可能上图不太明显，我们举一个明显一点的例子，如下正方形：<br><img src="https://img-blog.csdnimg.cn/20190617115935411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们填充后的效果为：<br><img src="https://img-blog.csdnimg.cn/20190617115949648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>​    而正方形的实际面积是4，在显示器上一个像素为一面积，正方形应该占4个像素点，而实际却占了9个像素点，对于这种问题，有效边表填充算法采用“左闭右开”，“下闭上开”的原则进行像素点的填充，按照此原则，正方形的填充效果如下：<br><img src="https://img-blog.csdnimg.cn/20190617120002618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>1.2.1.对于点集（1，3）、（1，8）它们分别为扫描线1与P3P2、P3P4、P5P4、P5P6的交点，而在实际计算中它们仍只是两个点，如果处理不当，计算机可能会两两配对得到区间（3，8）而填充到错误的像素区间。<br>对于此问题，有效边表填充算法采用分类连接点进行处理。<br>有效边表填充算法将多边形的各个连接点分为三类连接点：</p><h3 id="普通连接点："><a href="#普通连接点：" class="headerlink" title="+普通连接点："></a><strong>+普通连接点：</strong></h3><p>​    连接点所在的两条边分别处于其所在的扫描线的上方和下方，如P2点。</p><h3 id="局部最低点："><a href="#局部最低点：" class="headerlink" title="+局部最低点："></a><strong>+局部最低点：</strong></h3><p>​    连接点所在的两条边都处于其所在的扫描线的上方，如P3、P5点。</p><h3 id="局部最高点："><a href="#局部最高点：" class="headerlink" title="+局部最高点："></a><strong>+局部最高点：</strong></h3><p>​    连接点所在的两条边都处于其所在的扫描线的下方，如：P4、P1、P6点。<br>​    在填充开始前，有效边填充算法先对多边形所有的连接点进行分类，判断其在点集中的数量。<br>有效边填充算法采用如下原则对多边形的连接点进行处理：</p><h3 id="1-2-2-普通连接点的处理原则"><a href="#1-2-2-普通连接点的处理原则" class="headerlink" title="1.2.2.普通连接点的处理原则"></a><strong>1.2.2.普通连接点的处理原则</strong></h3><p>​    以P2为例，根据“下闭上开”原则，对于P3P2上的点P2不予填充，P2P1上的点P2需要填充，P2点只填充1次，顾在扫描线7的填充像素点集中P2点的个数记为1，即可以不处理。</p><h3 id="1-2-3-局部最低点的处理原则"><a href="#1-2-3-局部最低点的处理原则" class="headerlink" title="1.2.3.局部最低点的处理原则"></a><strong>1.2.3.局部最低点的处理原则</strong></h3><p>​    以P3为例，根据“下闭上开”原则，对于P3P2上的点P3需要填充，P3P4上的点P3也需要填充，P3填充2次，扫描线1的填充像素点集中，再添加一个P3点，使其中有两个P3点，在像素点集中将P3点的个数记为2，P5点进行同样的处理，这样当算法进行两两配对时，得到的像素区间为[3，3]、[5，5]，如此即可避免出现[3，8]的点集区间，解决此类情况的填充错误。</p><h2 id="1-2-4-局部最高点的处理原则"><a href="#1-2-4-局部最高点的处理原则" class="headerlink" title="1.2.4.局部最高点的处理原则"></a><strong>1.2.4.局部最高点的处理原则</strong></h2><p>​    以P1点为例，根据“下闭上开”原则，对于P2P1上的P1点不予填充，P0P1上的P1点也不予填充，P1填充0次，扫描线12的像素填充点集中P1点的个数记为0，即从点集中删除P1点，这样的处理符合多边形整体的“下闭上开”原则。<br>至此，多边形的有效边表填充算法的填充原理已经完成。<br>但是，我们在填充多边形之前还需要进行一项很重要的工作——根据多边形计算其有效边表，首先我们要了解什么是有效边。<br><strong>有效边</strong>：多边形与当前扫描线相交的边称为有效边，有效边的引入可以有效的避免扫描边与多边形的所有的边进行交点计算，提高算法的效率。<br><strong>有效边表</strong>：有效边按与扫描线交点x坐标递增顺序存放的链表。<br><strong>有效边表节点结构</strong>：<br><img src="https://img-blog.csdnimg.cn/20190618080124847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>示例：扫描线1的有效边表如下：<br><img src="https://img-blog.csdnimg.cn/20190618081306344.png" alt="在这里插入图片描述"><br><strong>桶表</strong>：有效边表按扫描线自增顺序存放的表，可以是链表，也可以是顺序表。<br><strong>桶表的结构</strong>：<br>​    如：多边形P0-P6的桶表为：<br><img src="https://img-blog.csdnimg.cn/20190618082918644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>​    有效边表可以有效的减少计算量，提升多边形的填充效率，如所有的扫描线中，计算机只需要计算扫描线1、扫描线7和扫描线8，且扫描线1只需和边P2P3、P3P4、P4P5、P5P6计算交点，而无需与所有边计算交点，有效边填充算法是目前最有效的多边形填充算法之一。<br>至此，多边形的有效边填充算法全部完成。</p><h1 id="2-边缘填充算法"><a href="#2-边缘填充算法" class="headerlink" title="2.边缘填充算法"></a>2.边缘填充算法</h1><h2 id="2-1-算法原理："><a href="#2-1-算法原理：" class="headerlink" title="2.1.算法原理："></a><strong>2.1.算法原理：</strong></h2><p>​    先计算多边形每条边与扫描线的交点，然后将交点右侧的所有像素颜色全部取补色。</p><h2 id="2-2-补色的定义："><a href="#2-2-补色的定义：" class="headerlink" title="2.2.补色的定义："></a><strong>2.2.补色的定义：</strong></h2><p>​    对于黑白图像，白色的补色为黑色，黑色补色为白色，对于彩色图像，前景色取补就是将前景色置为背景色，背景色取补就是将背景声置为前景色。<br>示例：<br><img src="https://img-blog.csdnimg.cn/20190618092226427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>​    边缘填充算法的填充效率受到右侧填充像素的数量影响，当多边形靠近屏幕左侧时，计算机将填充大量无用像素，大大降低的算法的性能，浪费了系统资源。<br>于是有人提出这样的改进：首先在进行多边形填充之前，先扫描一遍多边形，得出多边形的包围盒，并在适当的位置加入一条栅栏。<br>包围盒：包围多边形的最小矩形。</p><h2 id="2-3-加入包围盒和栅栏的边缘填充算法原理："><a href="#2-3-加入包围盒和栅栏的边缘填充算法原理：" class="headerlink" title="2.3.加入包围盒和栅栏的边缘填充算法原理："></a><strong>2.3.加入包围盒和栅栏的边缘填充算法原理：</strong></h2><p>​    每次填充前先判断当前边在栅栏的左侧还是右侧，若在左侧，则取补边以右，栅栏以左的像素；若在右侧，则取补边以右，栅栏以左的像素。<br>示例：<br><img src="https://img-blog.csdnimg.cn/20190621084324207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>​    可以看出，加入包围盒和栅栏的边缘填充算法极大的减少了需要填充像素的数量，对填充效率的提升是显著的。<br>​    观察边缘填充算法的两幅图，我们是可以察觉到的，边缘填充算法，对多边形的顶点与边的填充不甚理想，边缘填充算法没有给定具体填充时，直线上的点是否包含在填充范围内，笔者试过两种情况的对比——填充时包含直线上的点和填充时不包含直线上的点，得出的结果，多边形的顶点与边的填充都不理想，但是，填充时包含直线上的点的填充方法的最总结果，使多边形在整体上满足“左闭右开”，“下闭上开”原则，顾才用此方法作图。然而，边缘填充算法的填充原理是没有考虑边界的，即多边形的所有像素都填充为一个颜色，无论多边形内部还是多边形的边和顶点，在实际填充效果中，多边形所有像素都填充为一个颜色的填充方式，顶点和边对整体的效果不大，即可以忽略，所以边缘填充算法依旧是效率极高的填充算法之一。</p><h1 id="3-种子填充算法"><a href="#3-种子填充算法" class="headerlink" title="3.种子填充算法"></a>3.种子填充算法</h1><p>3.1.种子填充算法是区域填充算法中的一种，种子填充算法分为：四邻接点种子填充算法和八邻接点种子填充算法。<br>在此之前，我们需要了解一些概念：</p><h3 id="3-1-1-四邻接点："><a href="#3-1-1-四邻接点：" class="headerlink" title="3.1.1.四邻接点："></a><strong>3.1.1.四邻接点：</strong></h3><p>​    任易一个种子像素，其左右上下这四个像素成为这个种子像素的四邻接点。<br><img src="https://img-blog.csdnimg.cn/20190621092132813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-1-2-八邻接点："><a href="#3-1-2-八邻接点：" class="headerlink" title="3.1.2.八邻接点："></a><strong>3.1.2.八邻接点：</strong></h3><p>​    任易一个种子像素，其左右上下及左上、右下、右上、左上这八个像素成为这个种子像素的八邻接点。<br><img src="https://img-blog.csdnimg.cn/20190621092334685.png" alt="在这里插入图片描述"></p><h3 id="3-1-3-四连通域："><a href="#3-1-3-四连通域：" class="headerlink" title="3.1.3.四连通域："></a><strong>3.1.3.四连通域：</strong></h3><p>​    多边形中能被四邻接点遍历填充的区域。</p><h3 id="3-1-4-八连通域："><a href="#3-1-4-八连通域：" class="headerlink" title="3.1.4.八连通域："></a><strong>3.1.4.八连通域：</strong></h3><p>​    多边形中能被八邻接点遍历填充的区域。<br><img src="https://img-blog.csdnimg.cn/20190621094757411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-1-5-四连通边界："><a href="#3-1-5-四连通边界：" class="headerlink" title="3.1.5.四连通边界："></a><strong>3.1.5.四连通边界：</strong></h3><p><img src="https://img-blog.csdnimg.cn/20190621094925910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-1-6-八连通边界："><a href="#3-1-6-八连通边界：" class="headerlink" title="3.1.6.八连通边界："></a><strong>3.1.6.八连通边界：</strong></h3><p><img src="https://img-blog.csdnimg.cn/20190621095031628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="3-2-适用场景："><a href="#3-2-适用场景：" class="headerlink" title="3.2.适用场景："></a><strong>3.2.适用场景：</strong></h2><p>​    区域填充算法适用于多边形的边界与内部使用不同的填充色的场景。</p><h2 id="3-3-多边形边界的颜色："><a href="#3-3-多边形边界的颜色：" class="headerlink" title="3.3.多边形边界的颜色："></a><strong>3.3.多边形边界的颜色：</strong></h2><p>​    边界的颜色由绘制多边形时的画笔确定。</p><h2 id="3-4-多边形内部的颜色填充步骤"><a href="#3-4-多边形内部的颜色填充步骤" class="headerlink" title="3.4.多边形内部的颜色填充步骤"></a><strong>3.4.多边形内部的颜色填充步骤</strong></h2><p>​    3.4.1.在多边形内部任易选择一个像素作为种子像素。<br>​    3.4.2.将种子像素入栈。<br>​    3.4.3.如果栈不为空，则将栈顶元素出栈。<br>​    3.4.4.按填充色绘制出栈像素。<br>​    3.4.5.按四邻接点（左、上、右、下）（或八邻接点（左、左上、上、右上、右、右下、下、左下））顺序搜索与出栈像素相邻的4（或8）个像素，若该像素的颜色不是填充色并且也不是边界色，则把该像素入栈，否则丢弃该像素。<br>​    不难想象，当多边形的面积极大时，入栈的像素像素将是巨量，有的像素可能即是一个像素的邻接点又是另一个像素的邻接点，以致部分像素入栈多次，此情况下填充过程将大量占用栈存储空间，甚至过量占用空间，致使栈空间不足，导致其他程序无空间可用，如此既不能完成填充，又会造成空间溢出，甚至系统崩溃，所以种子填充算法的缺点极为严重。</p><h2 id="3-5-改进——扫描种子填充算法"><a href="#3-5-改进——扫描种子填充算法" class="headerlink" title="3.5.改进——扫描种子填充算法"></a><strong>3.5.改进——扫描种子填充算法</strong></h2><p>​    3.5.1.在多边形内部选择一个像素作为种子像素。<br>​    3.5.2.将种子像素入栈。<br>​    3.5.3.若栈不为空，则将栈顶元素出栈<br>​    3.5.4.沿出栈像素所在扫描线，对出栈像素左右像素依次填充，直至遇到边界像素为止。<br>​    3.5.5.记录该区间的范围，将最左端的像素记为Xl，将最右端的像素记为Xr。<br>​    3.5.6.检查与当前扫描线相邻的上下两条扫描线中在区间[Xl，Xr]里的有关像素是否全为边界像素或以填充像素，若存在非边界且未填充的像素，则把区间最右端像素取作种子像素入栈。<br>​    扫描种子填充像素每次只将区间最右端的像素入栈，极大的减少了入栈像素，不仅减少了栈空间的占用，还有效的提高了填充效率和填充速度。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
