<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【UE4】UE4联级粒子系统</title>
    <link href="/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <url>/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="一、粒子系统的一些基本概念"><a href="#一、粒子系统的一些基本概念" class="headerlink" title="一、粒子系统的一些基本概念"></a>一、粒子系统的一些基本概念</h1><h2 id="1-Particle-System-粒子系统"><a href="#1-Particle-System-粒子系统" class="headerlink" title="1.Particle System(粒子系统)"></a>1.Particle System(粒子系统)</h2><p>粒子系统如同贴图、模型一样属于UE4的驻留资产，不能单独存在于场景中，必须使用载体依托才能在场景中渲染出来，粒子系统包含粒子特效的所有配置。粒子系统在UE4中表现为如下样子：</p><p><img src="/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-14_09-41-14.png"></p><h3 id="创建粒子系统"><a href="#创建粒子系统" class="headerlink" title="创建粒子系统"></a>创建粒子系统</h3><p>在内容浏览器中右键选择Particle System可以直接创建粒子系统。</p><p><img src="/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-14_10-14-27.png"></p><h2 id="2-Emitter-Actor-粒子发射器"><a href="#2-Emitter-Actor-粒子发射器" class="headerlink" title="2.Emitter Actor(粒子发射器)"></a>2.Emitter Actor(粒子发射器)</h2><p>粒子发射器就是粒子系统的载体，粒子发射器承载粒子系统确定粒子系统在场景中的位置坐标等信息。但是似乎UE4没办法直接创建空的粒子发射器，UE4的粒子发射器在将粒子系统拖入场景中时，UE4会自动为该粒子系统创建一个粒子发射器。</p><h2 id="3-Particle-System-Component-粒子系统组件"><a href="#3-Particle-System-Component-粒子系统组件" class="headerlink" title="3.Particle System Component(粒子系统组件)"></a>3.Particle System Component(粒子系统组件)</h2><p>粒子系统组件是一个包含了粒子系统的蓝图，粒子系统组件可以使用代码逻辑来控制粒子系统。</p><h1 id="二、Cascade-粒子编辑器"><a href="#二、Cascade-粒子编辑器" class="headerlink" title="二、Cascade(粒子编辑器)"></a>二、Cascade(粒子编辑器)</h1><p>粒子系统的核心就是粒子编辑器，在粒子编辑器里我们可以创造出琳琅满目的粒子特效。</p><p>粒子编辑器包含Toolbar、Emitters、Details、Viewport和Curve Editor等视图。</p><h2 id="1-ToolBar-工具栏"><a href="#1-ToolBar-工具栏" class="headerlink" title="1.ToolBar(工具栏)"></a>1.ToolBar(工具栏)</h2><p><img src="/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-14_11-50-46.png"></p><h2 id="2-Emitters"><a href="#2-Emitters" class="headerlink" title="2.Emitters"></a>2.Emitters</h2><p>Emitters是用于控制粒子属性的视图，Emitters的基本组成单元就是Emitter(发射器)，这里的Emitter和前面提到的Emitter Actor有一些差异，二者都是粒子发射器，但是Emitter是属于粒子系统内部的发射器，主要用于对粒子系统的某一部分的粒子发射，如爆炸的粒子特效中可以由烟、火光和火花等粒子部分组成，Emitter就是用于发射这些粒子部分的发射器，而Emitter Actor则是用于发射整个粒子系统的发射器。</p><h2 id="3-Emitter-发射器"><a href="#3-Emitter-发射器" class="headerlink" title="3.Emitter(发射器)"></a>3.Emitter(发射器)</h2><p>在Emitters视图中每一列就是一个Emitter，一个Emitter控制一个粒子部分。一个Emitter拥有Required和Spawn两个固有组成模块，即每个Emitter被创建出来就拥有Required和Spawn模块，且这两个模块不能删除。</p><p>Emitter的执行顺序是自左而右的。</p><p><img src="/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-14_10-25-52.png"></p><h3 id="创建Emitter"><a href="#创建Emitter" class="headerlink" title="创建Emitter"></a>创建Emitter</h3><p>直接在Emitters视图的空白出右键选择New Particle Sprite Emitter即可。</p><h3 id="赋值Emitter"><a href="#赋值Emitter" class="headerlink" title="赋值Emitter"></a>赋值Emitter</h3><p>选中需要复制的Emitter右键/Emiter/Duplicate Emitter即可。</p><h3 id="删除Emitter"><a href="#删除Emitter" class="headerlink" title="删除Emitter"></a>删除Emitter</h3><p>选中需要删除的Emitter右键/Emitter/Delete Emitter，或直接按delete键。</p><h2 id="4-Emitter的分类"><a href="#4-Emitter的分类" class="headerlink" title="4.Emitter的分类"></a>4.Emitter的分类</h2><p>直接创建的Emitter默认为普通Emitter即没有任何特殊属性的Emitter，要创建具有特殊属性的特殊的Emitter需要修改Emitter的TypeData属性，右键/TypeData选择需要的类型即可修改Emitter的类型。</p><p><img src="/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-14_10-51-44.png"></p><h3 id="AnimTrail-Data"><a href="#AnimTrail-Data" class="headerlink" title="AnimTrail Data"></a>AnimTrail Data</h3><p>骨骼动画发射器，AnimTrail可以使粒子跟随人物骨骼运动而运动，如下图的跟随人物手臂运动的彩虹带</p><p><img src="/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-14_10-58-31.png"></p><p>AnimTrail是配合UE4的动画系统一起使用的，使用AnimTrail我们需要选择一段动画片段如下图</p><p><img src="/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-15_15-05-48.png"></p><p>发射器会在选定的时间片段内发射粒子，在右侧的Trail栏中选定粒子需要跟随的骨骼和骨骼需要绑定的粒子系统，就可以使粒子跟随着骨骼运动了。</p><h3 id="Beam-Data"><a href="#Beam-Data" class="headerlink" title="Beam Data"></a>Beam Data</h3><p>光束发射器，Beam有一个源点和一个目标点，粒子由源点发射运动到目标点销毁，Beam在粒子由源点运动到目标点的过程中可以设置粒子抖动，使粒子的运动具有抖动效果，如下图的闪电。</p><p><img src="/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-14_11-14-32.png"></p><p>Beam拥有一个专属Module–Beam，在这个模块里可以为Beam添加Source(源点)、Target(目标点)和Noise(噪声)，Noise就是控制粒子抖动的Module，要想粒子出现抖动有几点是必须要做的，即勾选Noise模块的Low Freq/Low Freq Enabled、设置Frequency(噪声点的频率，影响粒子抖动的平滑程度)；Source和Target模块的Suorce Tangent/Distribution/Constant和Target Tangent/Distribution/Constant(影响源点到目标点的粒子抖动的曲率)，要想这两个设置起作用还必须设置Source/Source Tangent Method为User Set，目标点也是一样的设置；还有一点就是要想粒子从源点向目标点运动还需要设置Beam Data模块的Beam/Beam Method为Target。</p><h3 id="GPU-Sprites"><a href="#GPU-Sprites" class="headerlink" title="GPU Sprites"></a>GPU Sprites</h3><p>GPU Sprites是普通粒子的加强版，可以使粒子具有更完美的物理效果，但当对于普通粒子发射器来说更消耗GPU性能。</p><p><strong>矢量场：</strong></p><p>矢量场是GPU粒子独有的属性，GPU粒子在矢量成的控制下可以作出任意轨迹运用，如：</p><p><img src="/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-14_19-48-16.png"></p><p>矢量场有多个属性控制模块</p><p><img src="/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-14_19-47-55.png"></p><p>矢量场默认是看不见的，我们需要在Viewport里勾选View/Vector Fields，使矢量场可见。</p><h3 id="Mesh-Data"><a href="#Mesh-Data" class="headerlink" title="Mesh Data"></a>Mesh Data</h3><p>网格发射器，Mesh可以使粒子使用模型网格，这样发射出来的粒子就是一个个具体的模型，如下图所示。</p><img src="/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-14_11-10-41.png" style="zoom:50%;"><h3 id="Ribbon-Data"><a href="#Ribbon-Data" class="headerlink" title="Ribbon Data"></a>Ribbon Data</h3><p>光带发射器，Ribbon可以记录粒子的运行轨迹，并可以对其属性进行编辑，如下图使用粒子运行轨迹制作的光带。</p><img src="/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-14_11-03-35.png" style="zoom:50%;"><p>Ribbon的粒子生成模块不是使用Spawn，而是Spawn PerUnit，由于Spawn是Emitter的固有Module所以无法移除，我们要启用Spawn PerUnit则需要将Spawn Module的Spawn/Distribution/Constant设置为0，达到间接禁用Spawn的效果。这样彩带粒子就是用Spawn PerUnit生成粒子了，想要彩带粒子跟随其他粒子运动我们还需要一个Module–Trail/Source，将Source Module里的Source/Source Mothod设置为PET2SRCM Particle，并且Source Name设置为需要跟随粒子部分的Emitter的名字，这样就可以产生一个跟随其他粒子的彩带了，当然这个彩带粒子是需要设置贴图的，否则尽管生成了，但是却没有渲染。</p><h2 id="4-Module-模块"><a href="#4-Module-模块" class="headerlink" title="4.Module(模块)"></a>4.Module(模块)</h2><p>模块用于控制粒子某一方面的属性，在Emitter中每一行就是一个Module，Module的种类很多，这里只列举自己使用过的Module。</p><p>UE4Module的执行顺序是自上而下的所以当一个Emitter中有两个相同的Module时，下面的Module会覆盖上面的Module。</p><h3 id="添加Module"><a href="#添加Module" class="headerlink" title="添加Module"></a>添加Module</h3><p>选中需要添加Module的Emitter，右键选择需要的Module即可</p><h3 id="移除Module"><a href="#移除Module" class="headerlink" title="移除Module"></a>移除Module</h3><p>选中需要移除的Module右键/Delete Module，或直接按Delete键。</p><h3 id="拷贝Module"><a href="#拷贝Module" class="headerlink" title="拷贝Module"></a>拷贝Module</h3><p>Shift+拖动即可拷贝一个Module到另一个Emitter中。</p><h3 id="Required"><a href="#Required" class="headerlink" title="Required"></a>Required</h3><p>Required控制粒子的显示方面的属性，如粒子贴图，显示模式等。</p><ul><li>Sub UV栏控制贴图的逐帧融合。</li></ul><h3 id="Spawn"><a href="#Spawn" class="headerlink" title="Spawn"></a>Spawn</h3><p>Spawn控制粒子的发射方面的属性，如粒子发射量，发射模式等。</p><ul><li>Spawn栏控制粒子持续性的发射；</li><li>Burst栏控制粒子间歇性的爆炸发射。</li></ul><h3 id="LifeTime"><a href="#LifeTime" class="headerlink" title="LifeTime"></a>LifeTime</h3><p>LifeTime控制粒子的声明周期方面的属性。</p><h3 id="Initial-Size"><a href="#Initial-Size" class="headerlink" title="Initial Size"></a>Initial Size</h3><p>Initial Size控制粒子初始尺寸方面的属性。</p><h3 id="Initial-Velocity"><a href="#Initial-Velocity" class="headerlink" title="Initial Velocity"></a>Initial Velocity</h3><p>Initial Velocity控制粒子初始速度方面的属性。</p><h3 id="Color-Over-Life"><a href="#Color-Over-Life" class="headerlink" title="Color Over Life"></a>Color Over Life</h3><p>Color Over Life控制粒子生命周期内的颜色变化方面的属性。</p><p>生命周期的初始颜色是Color Over Life/Distribution/Constant Curve/Points/0/Out Val，</p><p>生命周期的结束颜色是Color Over Life/Distribution/Constant Curve/Points/1/Out Val。</p><h3 id="Initial-Location"><a href="#Initial-Location" class="headerlink" title="Initial Location"></a>Initial Location</h3><p>Initial Location控制粒子发射的初始位置方面的属性，通过Start Location/Distribution/Max和Min可以控制粒子发射时的位置分布，如Max，Min都为0时粒子只从一个点发射出来，当设置了值，粒子会在设置的范围内随机发射出来。</p><h3 id="Const-Acceleration"><a href="#Const-Acceleration" class="headerlink" title="Const Acceleration"></a>Const Acceleration</h3><p>Const Acceleration控制粒子的运动的加速度。</p><h3 id="Size-By-Speed"><a href="#Size-By-Speed" class="headerlink" title="Size By Speed"></a>Size By Speed</h3><p>Size By Speed控制粒子的尺寸随速度的变化，要想粒子的尺寸可以随速度变化需要将Required模块的Emitter/Screen Alignment设置为PSA Velocity。</p><h3 id="Light"><a href="#Light" class="headerlink" title="Light"></a>Light</h3><p>Light控制粒子发光，但是似乎只有发生碰撞之后才会发光。</p><h3 id="Actor-Collision"><a href="#Actor-Collision" class="headerlink" title="Actor Collision"></a>Actor Collision</h3><p>Actor Collision控制粒子的物理碰撞。</p><h3 id="Orbit"><a href="#Orbit" class="headerlink" title="Orbit"></a>Orbit</h3><p>Obirt控制粒子的随机运动。</p><h1 id="三、LOD-细节层次"><a href="#三、LOD-细节层次" class="headerlink" title="三、LOD(细节层次)"></a>三、LOD(细节层次)</h1><p>默认情况下任何创建出来的粒子系统默认为LOD0等级的细节层次，我们可以在Toolbar中的Add LOD添加细节层次，在LOD中切换细节层次。</p><p><img src="/2019/11/17/%E3%80%90UE4%E3%80%91UE4%E8%81%94%E7%BA%A7%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2019-11-15_15-41-29.png"></p><p>Details/LOD栏可以设置LOD切换与距离的关系，可以在不同的细节层次下修改Emitter不会对其他的细节层次产生影响，这样就可以很精确的控制各个细节层次了。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE4】UE4组件</title>
    <link href="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/"/>
    <url>/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>不同的蓝图脚本拥有不同的组件集，蓝图脚本的组件集过于庞大，这里只对自己使用过的组件进行列举。</p><p><font color="red">说明：红色字体表示一级目录组件，绿色字体表示二级目录，黄色字体为三级目录(三级目录较为少见所以使用和二级目录相同的三级标题)，白色字体为具体组件说明</font>。</p><h1 id="一、材质蓝图组件"><a href="#一、材质蓝图组件" class="headerlink" title="一、材质蓝图组件"></a>一、材质蓝图组件</h1><h2 id="Constans-常量"><a href="#Constans-常量" class="headerlink" title="Constans(常量)"></a><font color="red">Constans(常量)</font></h2><p><img src="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_11-46-47.png"></p><table><thead><tr><th>组件</th><th>作用</th></tr></thead><tbody><tr><td>Constans</td><td>一维量，可以表示任何一维数据，如：小数、整数等</td></tr><tr><td>Constans2Vector</td><td>二维量，可以表示任何二维数据，如：二维坐标</td></tr><tr><td>Constans3Vector</td><td>三维量，可以表示任何三维数据，如：三维坐标、RBG等</td></tr><tr><td>Constans4Vector</td><td>四维量，可以表示任何四维数据，如：四元数</td></tr></tbody></table><h2 id="Math-数学函数"><a href="#Math-数学函数" class="headerlink" title="Math(数学函数)"></a><font color="red">Math(数学函数)</font></h2><h4 id="Multiply-乘积"><a href="#Multiply-乘积" class="headerlink" title="Multiply(乘积)"></a><strong>Multiply(乘积)</strong></h4><p><img src="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_11-50-37.png"></p><h3 id="Lerp-插值"><a href="#Lerp-插值" class="headerlink" title="Lerp(插值)"></a><font color="green">Lerp(插值)</font></h3><p><img src="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_13-12-40.png"></p><p>Lerp组件在Math的多个二级目录中存在，有各种类型的插值变化。</p><p><strong>输入：</strong></p><ul><li>A：插值变化的起始值；</li><li>B：插值变化的目标值；</li><li>Alpha：插值的变化规则，连接Float的TimeLine插值将按照TimeLine的规则变化。</li></ul><p><strong>输出：</strong></p><ul><li>Return Value：返回变化后的插值，将Lerp放入帧函数中可以获得每帧变化的插值。</li></ul><h1 id="二、普通蓝图组件"><a href="#二、普通蓝图组件" class="headerlink" title="二、普通蓝图组件"></a>二、普通蓝图组件</h1><hr><h2 id="Add-Event-添加事件"><a href="#Add-Event-添加事件" class="headerlink" title="Add Event(添加事件)"></a><font color="red">Add Event(添加事件)</font></h2><h3 id="Collision-碰撞体组件"><a href="#Collision-碰撞体组件" class="headerlink" title="Collision(碰撞体组件)"></a><font color="green">Collision(碰撞体组件)</font></h3><h4 id="Event-ActorBeginOverlap-自动触发触发器"><a href="#Event-ActorBeginOverlap-自动触发触发器" class="headerlink" title="Event ActorBeginOverlap(自动触发触发器)"></a><strong>Event ActorBeginOverlap(自动触发触发器)</strong></h4><p>每当有物体进入触发器时自动触发</p><p><img src="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_10-53-07.png"></p><ul><li>Other Actor：返回进入触发器的游戏物体的信息。</li></ul><h3 id="Game"><a href="#Game" class="headerlink" title="Game"></a><font color="green">Game</font></h3><h3 id="Damage"><a href="#Damage" class="headerlink" title="Damage"></a><font color="orange">Damage</font></h3><h4 id="Event-AnyDamage"><a href="#Event-AnyDamage" class="headerlink" title="Event AnyDamage"></a><strong>Event AnyDamage</strong></h4><p>Event AnyDamage事件是配合Apply Damage组件一起使用的，当Apply Damage组件执行时，会自动触发Event AnyDamage事件。</p><p><img src="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-28_17-28-37.png"></p><p><strong>输出：</strong></p><p>Damage：从Apply Damage组件的Damage中传递过来的值；</p><p>Damage Type：从Apply Damage组件传递过来的Damage Type Class；</p><p>Instigated By：从Apply Damage组件传递过来的Event Instigateor；</p><p>Damage Causer：从Apply Damage组件传递过来的Damage Causer；</p><h2 id="Event-BeginPlay"><a href="#Event-BeginPlay" class="headerlink" title="Event BeginPlay"></a><font color="red">Event BeginPlay</font></h2><p>游戏开始时自动触发</p><p><img src="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_10-57-11.png"></p><h2 id="Add-TimeLine-添加时间线"><a href="#Add-TimeLine-添加时间线" class="headerlink" title="Add TimeLine(添加时间线)"></a><font color="red">Add TimeLine(添加时间线)</font></h2><p><img src="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_10-33-38.png"></p><p><strong>输入：</strong></p><ul><li>Play：播放，播放完毕下一次触发时不会从头开始，而是会从上一次时间点继续开始；</li><li>Play from Start：从头开始播放，每次触发都从时间线起点开始执行；</li><li>Stop：暂停，触发后直接从当前时刻暂停；</li><li>Reverse：倒序播放，从当前时刻开始倒叙播放；</li><li>Reverse from End：从末尾开始倒序播放；</li><li>Set New Time：设置新的时间起点，即时间线从新设置的时间点开始执行；</li><li>New Time：新的时间起点由外部输入。</li></ul><p><strong>输出：</strong></p><ul><li>Update：在时间线内每帧执行；</li><li>Finished：时间线结束时触发；</li><li>Direction：返回时间线的执行方向，只有两个值“Forward”和“Backward”；</li><li>New Track 0：自己创建的时间线，创建了才会有，显示的名字也是自己命名的时间线的名字。</li></ul><h2 id="Camera-Fades-相机渐变"><a href="#Camera-Fades-相机渐变" class="headerlink" title="Camera Fades(相机渐变)"></a><font color="red">Camera Fades(相机渐变)</font></h2><p>Camera Fades组件是只有在Get Player Camera Menager组件的外拉中才能搜索到的专门服务于Get Player Camera Menager组件的相机组件集。</p><h4 id="Start-Camera-Fade-开始渐变"><a href="#Start-Camera-Fade-开始渐变" class="headerlink" title="Start Camera Fade(开始渐变)"></a><strong>Start Camera Fade(开始渐变)</strong></h4><p><img src="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_11-02-10.png"></p><ul><li>Target：渐变目标相机，默认为当前相机；</li><li>From Alpha：渐变起始Alpha；</li><li>To Alpha：渐变目标Alpha；</li><li>Duration：渐变持续时间；</li><li>Color：渐变颜色；</li><li>Should Fade Audio：启用声音渐变；</li><li>Hold when Finished：渐变结束后保持当前Alpha值。</li></ul><h4 id="Stop-Camera-Fade-结束渐变"><a href="#Stop-Camera-Fade-结束渐变" class="headerlink" title="Stop Camera Fade(结束渐变)"></a><strong>Stop Camera Fade(结束渐变)</strong></h4><p><img src="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_11-10-28.png"></p><p>触发时立刻停止当前渐变。</p><h2 id="Input-输入流"><a href="#Input-输入流" class="headerlink" title="Input(输入流)"></a><font color="red">Input(输入流)</font></h2><h3 id="Keyboard-Events-按键触发事件"><a href="#Keyboard-Events-按键触发事件" class="headerlink" title="Keyboard Events(按键触发事件)"></a><font color="green">Keyboard Events(按键触发事件)</font></h3><p>包含所有键盘按键出发事件</p><h2 id="Game-1"><a href="#Game-1" class="headerlink" title="Game"></a><font color="red">Game</font></h2><h4 id="Get-Player-Pawn-获取角色对象"><a href="#Get-Player-Pawn-获取角色对象" class="headerlink" title="Get Player Pawn(获取角色对象)"></a><strong>Get Player Pawn(获取角色对象)</strong></h4><p><img src="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_11-17-59.png"></p><ul><li><p>Play Index：输入角色索引，可以直接设置也可以外部输入；</p></li><li><p>Return Value：返回获取的角色对象(Object)。</p></li></ul><h4 id="Get-Current-Level-Name-获取关卡名字"><a href="#Get-Current-Level-Name-获取关卡名字" class="headerlink" title="Get Current Level Name(获取关卡名字)"></a><strong>Get Current Level Name(获取关卡名字)</strong></h4><p><img src="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_11-21-18.png"></p><ul><li>Remove Prefix String：移除前缀字符串；</li><li>Return Value：返回获取到的关卡名称(String)。</li></ul><h4 id="Get-Player-Camera-Manager-获取角色相机管理器"><a href="#Get-Player-Camera-Manager-获取角色相机管理器" class="headerlink" title="Get Player Camera Manager(获取角色相机管理器)"></a><strong>Get Player Camera Manager(获取角色相机管理器)</strong></h4><p><img src="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_11-26-07.png"></p><ul><li>Player Index：输入角色索引；</li><li>Return Value：返回输入角色身上的相机对象。</li></ul><h3 id="Damage-1"><a href="#Damage-1" class="headerlink" title="Damage"></a><font color="green">Damage</font></h3><h4 id="Apply-Damage"><a href="#Apply-Damage" class="headerlink" title="Apply Damage"></a><strong>Apply Damage</strong></h4><p>Apply Damage组件一般和Event AnyDamage组件配合使用，当Apply Damage组件触发时，UE4会自动调用Event AnyDamage事件。需要注意的是，只有在Base Daamge不为0时才能触发Event Damage事件。</p><p><img src="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-28_17-26-35.png"></p><p><strong>输入：</strong></p><p>Ddamaged Actor：受到伤害的对象；</p><p>Base Damage：输入的伤害值；</p><p>Event Instigator：引发伤害的对象，如：持枪的敌人；</p><p>Damage Causer：实际造成伤害的对象，如：子弹；</p><p>Damage Type Class：伤害的类型；</p><p><strong>输出：</strong></p><p>Return Value：最终造成的实际伤害。</p><h2 id="Rendering-渲染"><a href="#Rendering-渲染" class="headerlink" title="Rendering(渲染)"></a><font color="red">Rendering(渲染)</font></h2><h3 id="Components"><a href="#Components" class="headerlink" title="Components"></a><font color="green">Components</font></h3><h3 id="Light"><a href="#Light" class="headerlink" title=" Light"></a><font color="orange"> Light</font></h3><h4 id="Set-Intensity-设置光源强度"><a href="#Set-Intensity-设置光源强度" class="headerlink" title="Set Intensity(设置光源强度)"></a><strong>Set Intensity(设置光源强度)</strong></h4><p><img src="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_13-32-38.png"></p><ul><li>Target：目标光源；</li><li>New Intensity：目标光源强度。</li></ul><h4 id="Get-Intensity-获取光源强度"><a href="#Get-Intensity-获取光源强度" class="headerlink" title="Get Intensity(获取光源强度)"></a><strong>Get Intensity(获取光源强度)</strong></h4><p>使用和Set Intensity一样。</p><h2 id="String-字符串组件"><a href="#String-字符串组件" class="headerlink" title="String(字符串组件)"></a><font color="red">String(字符串组件)</font></h2><h3 id="Append-字符串连接"><a href="#Append-字符串连接" class="headerlink" title="Append(字符串连接)"></a><font color="green">Append(字符串连接)</font></h3><p><img src="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-28_17-04-19.png"></p><h2 id="Utilities-通用组件"><a href="#Utilities-通用组件" class="headerlink" title="Utilities(通用组件)"></a><font color="red">Utilities(通用组件)</font></h2><h3 id="Flow-Control"><a href="#Flow-Control" class="headerlink" title="Flow Control"></a><font color="green">Flow Control</font></h3><h4 id="Branch-if语句"><a href="#Branch-if语句" class="headerlink" title="Branch(if语句)"></a><strong>Branch</strong>(if语句)</h4><p><img src="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_11-30-52.png"></p><p>蓝图的if语句</p><ul><li>Condition：输入的判断条件，一般和各种判断组件的输出连接。</li></ul><h4 id="Delay-延迟函数"><a href="#Delay-延迟函数" class="headerlink" title="Delay(延迟函数)"></a><strong>Delay(延迟函数)</strong></h4><p><img src="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_11-39-53.png"></p><ul><li>Duration：延迟时间。</li></ul><h3 id="Keyboard-Events-按键触发事件-1"><a href="#Keyboard-Events-按键触发事件-1" class="headerlink" title="Keyboard Events(按键触发事件)"></a><font color="green">Keyboard Events(按键触发事件)</font></h3><p>包含一些字符串操作函数。</p><h3 id="Text"><a href="#Text" class="headerlink" title="Text"></a><font color="green">Text</font></h3><h4 id="Equal"><a href="#Equal" class="headerlink" title="Equal"></a><strong>Equal</strong></h4><p><img src="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_11-42-14.png"></p><p>输入两个比较对象，输出判断结果(Bool)。</p><p>各种其他的判断组件用法一致。</p><h3 id="Transformation"><a href="#Transformation" class="headerlink" title=" Transformation"></a><font color="green"> Transformation</font></h3><h4 id="Set-Actor-Scale-3D"><a href="#Set-Actor-Scale-3D" class="headerlink" title="Set Actor Scale 3D"></a><strong>Set Actor Scale 3D</strong></h4><p><img src="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_13-19-47.png"></p><p>设置Actor的Scale值</p><ul><li>Target：要设置的目标Actor；</li><li>New Scale 3D：要设置的目标Scale值。</li></ul><h4 id="Get-Actor-Scale-3D"><a href="#Get-Actor-Scale-3D" class="headerlink" title="Get Actor Scale 3D"></a><strong>Get Actor Scale 3D</strong></h4><p>获取Actor的Scale值。</p><h1 id="二、物理组件"><a href="#二、物理组件" class="headerlink" title="二、物理组件"></a>二、物理组件</h1><p>UE4除了提供大量蓝图脚本函数组件来对蓝图类进行精细控制外还提供了一系列物理组件对蓝图类进行一些常规的复杂控制。</p><h2 id="Camera"><a href="#Camera" class="headerlink" title="Camera"></a><font color="red">Camera</font></h2><h4 id="Camera-1"><a href="#Camera-1" class="headerlink" title="Camera"></a><strong>Camera</strong></h4><p><img src="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_11-53-42.png"></p><p>相机，用于渲染视野，一般配合Spring Arm一起使用。</p><h4 id="Spring-Arm"><a href="#Spring-Arm" class="headerlink" title="Spring Arm"></a><strong>Spring Arm</strong></h4><p><img src="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E7%BB%84%E4%BB%B6/Snipaste_2019-10-25_11-56-15.png"></p><p>弹簧悬臂，将相机附于其上可以实现相机跟随</p><h2 id="Movement"><a href="#Movement" class="headerlink" title="Movement"></a><font color="red">Movement</font></h2><h4 id="Rotating-Movement"><a href="#Rotating-Movement" class="headerlink" title="Rotating Movement"></a><strong>Rotating Movement</strong></h4><p>旋转控制，提供一系列参数对对蓝图类的旋转运动进行控制</p><h2 id="Rendering"><a href="#Rendering" class="headerlink" title="Rendering"></a><font color="red">Rendering</font></h2><h4 id="Static-Mesh"><a href="#Static-Mesh" class="headerlink" title="Static Mesh"></a><strong>Static Mesh</strong></h4><p>静态网格，网格控制蓝图的贴图材质、模型外观、阴影渲染等。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE4】UE4连接MySQL</title>
    <link href="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%BF%9E%E6%8E%A5MySQL/"/>
    <url>/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%BF%9E%E6%8E%A5MySQL/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="一、使用MySQLIntegration插件连接Mysql"><a href="#一、使用MySQLIntegration插件连接Mysql" class="headerlink" title="一、使用MySQLIntegration插件连接Mysql"></a>一、使用MySQLIntegration插件连接Mysql</h1><ul><li>Update Data from Query Async组件后面必须再跟一个其他的节点，节点才能正常执行</li><li>UE4 C++编程中不能出现私有私有变量？</li><li>UE4 C++静态变量？</li><li>MySQL Integration插件只支持sql语句，不支持存储过程</li><li>在蓝图中实现的C++函数在蓝图中没法使用？</li><li>暴露给蓝图的变量和函数必须是公有且非静态的</li><li>UE4 C++类创建对象，大象无形31页</li><li>UE4 C++编程中if else语句必须加{}</li></ul><h2 id="1-MySQL-Integration安装"><a href="#1-MySQL-Integration安装" class="headerlink" title="1.MySQL Integration安装"></a>1.MySQL Integration安装</h2><p>MySQL Integration插件可以直接在UE4商城中搜索到，直接下载安装即可，如何是从外部导入的离线包，直接将插件文件夹丢入UE4安装目录下的Engine\Plugins文件夹下即可。</p><h2 id="2-激活MySQL-Integration"><a href="#2-激活MySQL-Integration" class="headerlink" title="2.激活MySQL Integration"></a>2.激活MySQL Integration</h2><p>激活插件直接在UE4中的Edit/Plugins/Installed下找到MySQL Integration勾选Enabled即可，勾选插件之后UE4会提示需要重启UE4才可激活，重启软件就可以激活插件了。</p><h2 id="3-MySQL-Integration提供的蓝图组件"><a href="#3-MySQL-Integration提供的蓝图组件" class="headerlink" title="3.MySQL Integration提供的蓝图组件"></a>3.MySQL Integration提供的蓝图组件</h2><p>官方文档： <a href="https://sameek4.github.io/KodeSpire/Pages/MySQLIntegration.html">https://sameek4.github.io/KodeSpire/Pages/MySQLIntegration.html</a> </p><h3 id="Set-Connection-Properties-Mysql连接"><a href="#Set-Connection-Properties-Mysql连接" class="headerlink" title="Set Connection Properties(Mysql连接)"></a>Set Connection Properties(Mysql连接)</h3><p>Set Connection Properties组件提供UE4对Mysql的连接服务。</p><p><img src="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%BF%9E%E6%8E%A5MySQL/Snipaste_2019-11-05_17-54-58.png"></p><p><strong>输入：</strong></p><ul><li>server：数据库的连接ip；</li><li>DBName：数据库的名字；</li><li>User ID：登录数据库用户名；</li><li>Password：登录数据库的用户密码；</li><li>Extra Param：SetConnectionProperties提供的额外参数传入；</li><li>Is Trusted：启用windows用户名和密码登录数据库。</li></ul><h3 id="Check-Connection-State-Mysql连接状态检查"><a href="#Check-Connection-State-Mysql连接状态检查" class="headerlink" title="Check  Connection State(Mysql连接状态检查)"></a>Check  Connection State(Mysql连接状态检查)</h3><p>此组件提供对Mysql连接的状态的查询服务。</p><p><img src="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%BF%9E%E6%8E%A5MySQL/Snipaste_2019-11-05_18-02-53.png"></p><p><strong>输出：</strong></p><ul><li><p>Error Message：输出错误信息；</p></li><li><p>Return Value：输出连接状态；</p><p>包含如下状态值(类型为插件定义的EMysqlConnectionStateEnum枚举)：</p><ul><li>Broken：数据库损坏；</li><li>Closed：连接关闭；</li><li>connecting：正在连接；</li><li>Eecuting：正在发送命令；</li><li>Fetching：数据库正在检索数据；</li><li>Open：连接以正常打开，可以正常使用数据库。</li></ul></li></ul><h3 id="Update-Data-from-Query-Async-异步发送非查询sql命令"><a href="#Update-Data-from-Query-Async-异步发送非查询sql命令" class="headerlink" title="Update Data from Query Async(异步发送非查询sql命令)"></a>Update Data from Query Async(异步发送非查询sql命令)</h3><p><img src="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%BF%9E%E6%8E%A5MySQL/Snipaste_2019-11-05_18-14-47.png"></p><p>此组件提供非查询的sql命令发送服务，即发送insert，delete，create等命令。</p><h3 id="Update-Data-from-Query-同步发送非查询sql命令"><a href="#Update-Data-from-Query-同步发送非查询sql命令" class="headerlink" title="Update Data from Query (同步发送非查询sql命令)"></a>Update Data from Query (同步发送非查询sql命令)</h3><p><img src="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%BF%9E%E6%8E%A5MySQL/Snipaste_2019-11-05_18-17-44.png"></p><p><strong>输入：</strong></p><ul><li>Query：sql命令字符串；</li></ul><p><strong>输出：</strong></p><ul><li><p>Success Status：命令的执行状态</p><p>有三种执行状态值，类型为插件自定义的EMysqlSuccessStateEnum枚举，</p><ul><li>Executing：sql命令正在发送；</li><li>Success：sql命令执行成功；</li><li>Failed：sql命令执行失败。</li></ul></li><li><p>Error Message：输出错误信息。</p></li></ul><h3 id="Check-Query-EXecution-State-检查上一条命令的执行状态"><a href="#Check-Query-EXecution-State-检查上一条命令的执行状态" class="headerlink" title="Check Query EXecution State(检查上一条命令的执行状态)"></a>Check Query EXecution State(检查上一条命令的执行状态)</h3><p>此组件提任何sql命令的执行状态检查，<font color="red">但仅限检查Check Query EXecution State执行前的上一条sql语句的状态检查。</font></p><p><img src="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%BF%9E%E6%8E%A5MySQL/Snipaste_2019-11-05_18-26-48.png"></p><p>输出内容和Update Data from Query一致。</p><h3 id="Select-Data-from-Query-Async-异步发送查询命令"><a href="#Select-Data-from-Query-Async-异步发送查询命令" class="headerlink" title="Select Data from Query Async(异步发送查询命令)"></a>Select Data from Query Async(异步发送查询命令)</h3><p>此组件仅限发送select语句，其他语句发送无效，<font color="red"> 查询到的数据会存储到插件自带的数据结构中，可以使用下面介绍的Get Selected Table组件进行数据访问。</font></p><p><img src="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%BF%9E%E6%8E%A5MySQL/Snipaste_2019-11-05_18-27-48.png"></p><h2 id="Get-Selected-Table-读取数据表"><a href="#Get-Selected-Table-读取数据表" class="headerlink" title="Get Selected Table(读取数据表)"></a>Get Selected Table(读取数据表)</h2><p><img src="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%BF%9E%E6%8E%A5MySQL/Snipaste_2019-11-05_18-34-52.png"></p><p><strong>输出:</strong></p><ul><li>Result by Column：以列的形式返回数据，<font color="red">返回一个MySQLDataTableStructures的结构体数据，每一个结构体就是一列，MySQLDataTableStructures结构体包含两个成员ColumnName(列名)和ColumnData(列数据)，其中ColumnData是一个FString类型的TArray数组，数组中每一个元数就是该列中某一行的数据。</font></li><li>Result by Row：以行的形式返回数据，返回一个<font color="red"> 返回一个MySQLDataRowStructures类型的结构体数组，每一个结构体就是一行，MySQLDataRowStructures结构体包含一个FString类型的TArray数组，数组中每一个元素就是该行中某一列的数据。</font></li></ul><h2 id="4-MySQL-Integration的注意事项"><a href="#4-MySQL-Integration的注意事项" class="headerlink" title="4.MySQL Integration的注意事项"></a>4.MySQL Integration的注意事项</h2><h3 id="MySQL-Integration不支持存储过程"><a href="#MySQL-Integration不支持存储过程" class="headerlink" title="MySQL Integration不支持存储过程"></a>MySQL Integration不支持存储过程</h3><p>MySQL Integration插件不支持数据库的存储过程的语法，在Query引脚输入“Call ProdureceName(ParameterList) ”是没有办法唤醒数据库中的存储过程的，所以很多的数据库中的查询和插入逻辑就需要在外部实现了。</p><h3 id="MySQL-Integration不提供C-函数"><a href="#MySQL-Integration不提供C-函数" class="headerlink" title="MySQL Integration不提供C++函数"></a>MySQL Integration不提供C++函数</h3><p>MySQL Integration插件只提供蓝图组件不提供C++函数，也就是说数据库的连接查询等只能使用蓝图来实现，但大多数情况我们又必须在C++中访问数据库，在这钟情况下我们该如何做呢？</p><p>目前，我只想到一种方法，就是在C++中创建访问数据库的类在类中声明数据库的访问函数，用这个类的蓝图子类来重写该数据库访问函数，以实现父类中该数据库访问函数，这是由C++继承中的重写的特性实现的。</p><p>具体做法如下：</p><p>首先在C++中创建一个专门负责连接数据库的类并在类中声明连接函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;MysqlJsonCpp.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;GameFramework/Actor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;MysqlConnector.generated.h&quot;</span></span><br><br>UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DATA_SYS_API</span> <span class="hljs-title">AMysqlConnector</span> :</span> <span class="hljs-keyword">public</span> AActor<br>&#123;<br>GENERATED_BODY()<br><span class="hljs-keyword">public</span>:<br><br>UPROPERTY(BlueprintReadWrite,Category = <span class="hljs-string">&quot;VariableRW&quot;</span>)<br>FString errorMessage;<br>UPROPERTY(BlueprintReadWrite, Category = <span class="hljs-string">&quot;VariableRW&quot;</span>)<br>FString stateMessage;<br><br><span class="hljs-keyword">protected</span>:<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-keyword">public</span>:<br><br>AMysqlConnector();<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Tick</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime)</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-comment">//从配置文件ConnectConfig.json中读取Mysql连接配置文件</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ConnectMysqlByConfig</span><span class="hljs-params">()</span></span>;<br>    <br><span class="hljs-comment">//使用MySQLIntegration插件连接Mysql</span><br>UFUNCTION(BlueprintImplementableEvent,Category = <span class="hljs-string">&quot;OverridFunction&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">(FName server, FName dbName, FName userId, FName passwd)</span></span>;<br>    <br><span class="hljs-comment">//使用MySQLIntegration插件检查连接状态</span><br>UFUNCTION(BlueprintImplementableEvent, Category = <span class="hljs-string">&quot;OverridFunction&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ConnectState</span><span class="hljs-params">(FString &amp;errorMessageParam,FString &amp;stateMessageParam)</span></span>;<br><span class="hljs-comment">//获取连接状态</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetConnectState</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面的void Connect(FName server, FName dbName, FName userId, FName passwd);函数就是需要用蓝图实现的数据库连接函数，<font color="red"> 这里要注意，这个函数只能在C++中声明，不可以实现，否则父类调用此函数时将无法关联到子类的重写，并且这个函数需要使用<code>BlueprintImplementableEvent</code>参数暴露给蓝图</font>。</p><p><font color="red"> 这里还需要注意，如果这个函数中使用了变量的引用，那么这个变量也需要使用<code>UPROPERTY(BlueprintReadWrite, Category = &quot;VariableRW&quot;)</code>暴漏给蓝图，如上面的<code>FString errorMessage;</code>一样。</font></p><p>这样我们就可以创建一个蓝图类来继承这个类，</p><p><img src="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%BF%9E%E6%8E%A5MySQL/Snipaste_2019-11-05_19-12-00.png"></p><p>然后在该蓝图类的MyBlueprint/Functions/Override下看到我们在C++类中声明的函数，直接重写实现即可，如：</p><p><img src="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%BF%9E%E6%8E%A5MySQL/Snipaste_2019-11-05_19-14-07.png"></p><p>实现时候我们就可以在C++中调用这个函数了，这个函数就会通过重写关联到蓝图自类中的重写过程，如此数据库便连接上了。</p><h1 id="二、使用C-库连接Mysql"><a href="#二、使用C-库连接Mysql" class="headerlink" title="二、使用C++库连接Mysql"></a>二、使用C++库连接Mysql</h1><p>目前卡在#include&lt;mysql.h&gt;编译不通过。</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE4】UE4读写Json文件</title>
    <link href="/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%AF%BB%E5%86%99Json%E6%96%87%E4%BB%B6/"/>
    <url>/2019/11/06/%E3%80%90UE4%E3%80%91UE4%E8%AF%BB%E5%86%99Json%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h1><p>如果我们想要在UE4中读写Json文件，那么我们必须使UE4包含<font color="red">Json和JsonUtilities</font>这两个模块，那么UE4如何添加模块呢？</p><p>UE4添加预定义模块的方法很简单，我只需打开工程的.Biuld.cs文件，在其中的<code>PublicDependencyModuleNames.AddRange()</code>函数中追加两个模块即可，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> UnrealBuildTool;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DATA_sys</span> :</span> ModuleRules<br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DATA_sys</span><span class="hljs-params">(ReadOnlyTargetRules Target)</span> : <span class="hljs-title">base</span><span class="hljs-params">(Target)</span></span><br><span class="hljs-function"></span>&#123;<br>PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;<br><br>PublicDependencyModuleNames.AddRange(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123; <span class="hljs-string">&quot;Core&quot;</span>, <span class="hljs-string">&quot;CoreUObject&quot;</span>, <span class="hljs-string">&quot;Engine&quot;</span>, <span class="hljs-string">&quot;InputCore&quot;</span> ,<span class="hljs-string">&quot;Json&quot;</span>,<span class="hljs-string">&quot;JsonUtilities&quot;</span>&#125;);<br><br>PrivateDependencyModuleNames.AddRange(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123;  &#125;);<br><br><span class="hljs-comment">// Uncomment if you are using Slate UI</span><br><span class="hljs-comment">// PrivateDependencyModuleNames.AddRange(new string[] &#123; &quot;Slate&quot;, &quot;SlateCore&quot; &#125;);</span><br><br><span class="hljs-comment">// Uncomment if you are using online features</span><br><span class="hljs-comment">// PrivateDependencyModuleNames.Add(&quot;OnlineSubsystem&quot;);</span><br><br><span class="hljs-comment">// To include OnlineSubsystemSteam, add it to the plugins section in your uproject file with the Enabled attribute set to true</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们要添加自定义模块就有点麻烦了，当然这里就不赘述了。</p><p>包含这两个模块之后，我们还需要用到<font color="red"> Json.h、JsonObject.h、JsonSerializer.h</font>三个头文件，其中JsonSerializer.h是用于Json序列化与反序列化用的。</p><p>至此我们就可以使用UE4自带的工具进行Json文件的读写工作了。</p><h1 id="二、Json文件写"><a href="#二、Json文件写" class="headerlink" title="二、Json文件写"></a>二、Json文件写</h1><h2 id="1-非序列化写入"><a href="#1-非序列化写入" class="headerlink" title="1.非序列化写入"></a>1.非序列化写入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AMysqlJsonCpp::CreatJson</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>FString filePath = FPaths::GameContentDir() + TEXT(<span class="hljs-string">&quot;MysqlConfig/Connect.json&quot;</span>);<br>FString jsonStr;<br>TSharedRef&lt;TJsonWriter&lt;&gt;&gt; jsonWriter = TJsonWriterFactory&lt;&gt;::Create(&amp;jsonStr);<br>jsonWriter-&gt;WriteObjectStart();<br>jsonWriter-&gt;WriteValue(TEXT(<span class="hljs-string">&quot;server&quot;</span>), TEXT(<span class="hljs-string">&quot;127.0.0.1&quot;</span>));<br>jsonWriter-&gt;WriteObjectEnd();<br>jsonWriter-&gt;Close();<br>FFileHelper::SaveStringToFile(jsonStr, *filePath);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>FPaths::GameContentDir()</code>返回当前工程目录的Content文件夹的路径，FPaths为UE4的路径读写工具；</p></li><li><p><code>FString jsonStr</code>的作用是用于关联UE4的Json写工具TJsonWriter&lt;&gt;，作为输入流载体，且JsonStr必须是FString类型；</p></li><li><p><code>TShareRef&lt;T&gt;</code>是UE4自身的共享指针类型；</p></li><li><p><code>TJsonWriter&lt;&gt;</code>是UE4专门用于写Json的模板类，其中类型参数通常为TCHAR，其中有多个方法供开发者使用：</p><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>Close()</td><td>关闭写工具</td></tr><tr><td>WriterArrayStart()</td><td>开始一个Json数组</td></tr><tr><td>WriterArrayEnd()</td><td>结束一个Json数组</td></tr><tr><td>WriterNull(FString)</td><td>为一个键写一个空值</td></tr><tr><td>WriterObjectStart()</td><td>开始一个Json对象</td></tr><tr><td>WriterObjectEnd()</td><td>结束一个Json对象</td></tr><tr><td>WriterValue(FString,FString/int32/float/bool)</td><td>向Json文件写入键值对</td></tr></tbody></table></li></ul><ul><li><p><code>TJsonWriterFactory&lt;&gt;::Create(FString)</code>是UE4用来生成Json写工具TJsonWriter&lt;&gt;的类，TJsonFactory&lt;&gt;只有一个方法就是Create；</p></li><li><p><code>FFileHelper</code>UE4的文件读写工具，方法<code>SaveStringToFile(TJsonWriter*,FString*)</code>函数的作用就是将Json写工具中的Json数据写到FString字符串中的路径文件中。</p></li></ul><p>使用非序列化方式写入Json时，写入方式需要严格按照Json的语法格式来做，如最开始需要使用WriterObjectStart()创建一个根前括号，即Json语法中最外面一层的<code>&#123;</code>，所有写入结束后需要使用WriterObjectEnd()声明根对象结束，即Json语法中的最外面一层的<code>&#125;</code>，同理数组也需要按对象一样的方法进行处理。如此才能写入一个结构完整的Json文本。</p><h2 id="2-序列化写入"><a href="#2-序列化写入" class="headerlink" title="2.序列化写入"></a>2.序列化写入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AMyActor::Test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>TSharedPtr&lt;FJsonObject&gt; rootObj = MakeShareable(<span class="hljs-keyword">new</span> FJsonObject());<br>rootObj-&gt;SetStringField(<span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>);<br>TArray&lt;TSharedPtr&lt;FJsonValue&gt;&gt; arrValue;<br>TSharedPtr&lt;FJsonValueString&gt; tmp = MakeShareable(<span class="hljs-keyword">new</span> FJsonValueString(<span class="hljs-string">&quot;array&quot;</span>));<br>arrValue.Add(tmp);<br>rootObj-&gt;SetArrayField(<span class="hljs-string">&quot;array&quot;</span>, arrValue);<br>FString filePath = FPaths::GameContentDir() + TEXT(<span class="hljs-string">&quot;MysqlConfig/text.json&quot;</span>);<br>FString jsonStr;<br>TSharedRef&lt;TJsonWriter&lt;TCHAR&gt;&gt; jsonWriter = TJsonWriterFactory&lt;TCHAR&gt;::Create(&amp;jsonStr);<br>FJsonSerializer::Serialize(rootObj.ToSharedRef(), jsonWriter);<br>FFileHelper::SaveStringToFile(jsonStr, *filePath);<br>UE_LOG(LogTemp, Error, TEXT(<span class="hljs-string">&quot;%s&quot;</span>),*filePath);<br>&#125;<br></code></pre></td></tr></table></figure><p>序列化的写入方式则无需考虑按Json的语法结构进行写入，序列化的写入方式是通过一个FJsonObject对象进行Json文本的写入。</p><ul><li>首先使用MakeSahreable()函数创建一个FJsonObject对象并使用共享指针引用。</li><li>然后我们便可以使用FJsonObject对象中的<code>SetArrayField(FString,TArray&lt;FSharePtr&lt;FJsonValue&gt;&gt;)</code>、<code>SetBoolFiled(FString,bool)</code>、<code>SetNumberField(FString,Number)</code>、<code>SetStringField(FString,FString)</code>、<code>SetObjectField(FString,TSharePtr&lt;FJsonObject&gt;)</code>、<code>SetField(FString,TSharePtr&lt;FJsonValue&gt;)</code>等函数向FJsonObject对象中写分别入数组、bool值、数字、字符串、对象和Json键值对。其中数组的写入较为麻烦，我们需要先向创建Json键值对类型共享指针的TArray数组<code>TArray&lt;TSharePtr&lt;FJsonValue&gt;&gt;</code>。并向数组中添加指向FJsonValue对象的共享指针后然后才可以使用SetArrayField进行数组的Json文本写入。</li><li>我们序列化写好的FJsonObject对象需要转化为FString字符串才能向文本中写入数据，FJsonObject转化为FString输入流的方式就是<code>FJsonSerializer::Serialize(TSharePtr&lt;FJsonObject&gt;.ToShareRef(),TSharePtr&lt;FJsonWriter&gt;)</code>;其中<code>TSharePtr&lt;FJsonWriter&gt;</code>和非序列化写入一样需要绑定一个FString作为输入流载体。</li><li>最后就可以通过FFileHelper::SaveStringToFile(FString,*FString)，前一个FString是输入流载体，后一个*FString是Json文件的存储路径。</li></ul><h1 id="三、Json文件读"><a href="#三、Json文件读" class="headerlink" title="三、Json文件读"></a>三、Json文件读</h1><h2 id="1-反序列化读取"><a href="#1-反序列化读取" class="headerlink" title="1.反序列化读取"></a>1.反序列化读取</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">TArray&lt;FName&gt; <span class="hljs-title">AMysqlJsonCpp::ReadMysqlConnectConfig</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>FString filePath = FPaths::GameContentDir() + TEXT(<span class="hljs-string">&quot;MysqlConfig/Connect.json&quot;</span>);<br><span class="hljs-keyword">if</span> (FPaths::FileExists(filePath))<br>&#123;<br>FString server;<br>FString dbName;<br>FString userId;<br>FString passwd;<br>TArray&lt;FName&gt; connectConfig;<br>FString fileStr;<br>FFileHelper::LoadFileToString(fileStr, *filePath);<br>TSharedPtr&lt;FJsonObject&gt; rootObject = MakeShareable(<span class="hljs-keyword">new</span> FJsonObject());<br>TSharedRef&lt;TJsonReader&lt;&gt;&gt; jsonReader = TJsonReaderFactory&lt;&gt;::Create(fileStr);<br><span class="hljs-keyword">if</span> (FJsonSerializer::Deserialize(jsonReader, rootObject))<br>&#123;<br>server = rootObject-&gt;GetStringField(<span class="hljs-string">&quot;server&quot;</span>);<br>dbName = rootObject-&gt;GetStringField(<span class="hljs-string">&quot;dbName&quot;</span>);<br>userId = rootObject-&gt;GetStringField(<span class="hljs-string">&quot;userId&quot;</span>);<br>passwd = rootObject-&gt;GetStringField(<span class="hljs-string">&quot;passwd&quot;</span>);<br>&#125;<br>connectConfig.Add(FName(*server));<br>connectConfig.Add(FName(*dbName));<br>connectConfig.Add(FName(*userId));<br>connectConfig.Add(FName(*passwd));<br>&#125;<br><br><span class="hljs-keyword">return</span> TArray&lt;FName&gt;();<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>首先Json文本的读取需要将Json文本以字符串的形式读入到一个FString的输入流载体中；</li><li>然后我们需要将这个输入流载体绑定到TJsonReader&lt;&gt;读出工具上；</li><li>然后使用<code>FJsonSerializer::Deserialize(TSharePtr&lt;TJsonReader&lt;&gt;&gt;,TSahrePtr&lt;FJsonObject&gt;)</code>将输入流载体的Json数据反序列化到FJsonObject对象中；</li><li>最后我们就可以使用FJsonObject对象中的<code>GetArrayField(FString)</code>、<code>GetBoolFiled(FString)</code>、<code>GetNumberField(FString)</code>、<code>GetStringField(FString)</code>、<code>GetObjectField(FString)</code>、<code>GetField(FString)</code>等方法从Json对象中读取指定键的值了。</li></ul>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE4】UE4蓝图基础</title>
    <link href="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/"/>
    <url>/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="一、蓝图可视化脚本与蓝图系统"><a href="#一、蓝图可视化脚本与蓝图系统" class="headerlink" title="一、蓝图可视化脚本与蓝图系统"></a>一、蓝图可视化脚本与蓝图系统</h1><h2 id="1-蓝图脚本"><a href="#1-蓝图脚本" class="headerlink" title="1.蓝图脚本"></a>1.蓝图脚本</h2><p>蓝图可视化脚本简称“蓝图”或“蓝图脚本”，是一种需要编译的面向对象的可视化编程语言，蓝图完全集成在UE4中，蓝图通过节点与连线工作。</p><h3 id="蓝图脚本的节点"><a href="#蓝图脚本的节点" class="headerlink" title="蓝图脚本的节点"></a>蓝图脚本的节点</h3><ul><li>触发事件，在蓝图脚本中以红色的节点出现</li><li>函数，在看图脚本中以蓝色的节点出现</li><li>变量，在蓝图脚本中中以黄色节点出现</li></ul><h2 id="2-蓝图系统"><a href="#2-蓝图系统" class="headerlink" title="2.蓝图系统"></a>2.蓝图系统</h2><p>蓝图系统又称“蓝图”或“蓝图类”，蓝图类可以看成是一个包含游戏内容的容器，其中可以包含组件、脚本或可以仅仅包含数据。</p><p>蓝图类有点类似Unity3d中的预设(prefb)，蓝图类可以类似预设一般保存对象状态，可以随时拖入场景中使用，只是在其他功能上不如预设，如预设在U3D中的打包中可以发挥出优秀的效果，但是蓝图类只能作为容器使用。</p><p><font color="red"> 蓝图类包含蓝图脚本，每一个蓝图类都包含一个默认的蓝图脚本。</font></p><h3 id="蓝图类的分类"><a href="#蓝图类的分类" class="headerlink" title="蓝图类的分类"></a>蓝图类的分类</h3><ul><li><strong>关卡蓝图</strong>：关卡蓝图在每个Level中只能存在一个，负责整个关卡的运行逻辑，关卡的初始化，帧更新都在关卡蓝图里进行；</li><li><strong>普通蓝图</strong>：普通蓝图就是UE4的预设，在普通蓝图中我们可以对其中的对象进行一些的配置，如设置网格，贴图，粒子特效，添加相机，添加物理材质和挂载蓝图脚本等等；</li><li><strong>游戏模式蓝图</strong>：UE4中游戏模式也是以蓝图的形式存在的，游戏模式蓝图控制一系列游戏的规则；</li><li><strong>材质蓝图</strong>：在UE4中贴图材质也是蓝图的形式存在的，在材质蓝图中我们可以如同建模软件一般对材质进行一系列更高级的材质配置，如下图的一个简单示例：</li></ul><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-24_09-41-27.png"></p><h2 id="4-创建蓝图"><a href="#4-创建蓝图" class="headerlink" title="4.创建蓝图"></a>4.创建蓝图</h2><p>创建蓝图的方法很多，这里介绍比较常用的方法</p><ul><li>可以直接在Content Browser(内容浏览器)中右键创建一个空的蓝图类，空蓝图除了包含一个根组件外不再包含其他东西，当我们在空蓝图中创建了对象后可以通过拖拽的方式将对象拖动到根组件位置处，用游戏对象替换根组件作为根组件，这样创建空蓝图时的白色小球就会消失；</li><li>在World Outliner(世界大纲)中选中游戏对象，可以通过工具栏中的Blueprints工具中的下面两个选项创建一个包含所选内容的蓝图类；</li></ul><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-24_09-51-55.png"></p><ul><li>通过Blueprints工具的New Empty Blueprint Class也可以直接创建空蓝图类；</li><li>然而关卡蓝图似乎只能通过Blueprints工具的Open Blueprint Class打开。</li></ul><h1 id="二、变量与对象引用"><a href="#二、变量与对象引用" class="headerlink" title="二、变量与对象引用"></a>二、变量与对象引用</h1><h2 id="1-在蓝图中创建变量"><a href="#1-在蓝图中创建变量" class="headerlink" title="1.在蓝图中创建变量"></a>1.在蓝图中创建变量</h2><p>在蓝图中创建变量的方式有两种，其一：直接点击My BluePrint/Variables/+Variable，默认创建bool行的变量，可以点击变量前的色块更换变量类型。</p><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_17-18-23.png"></p><p>其二：在蓝图脚本区域右键-&gt;输入Get New Var，可以直接在蓝图脚本中以节点的形式创建变量，在右侧细节面板中设置变量的值。</p><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_17-23-27.png"></p><p>所有创建好的变量都会在My Blueprint面板Variables栏中显示。</p><p><font color="red"> 在创建好的变量的Details/Variable/Variable Type选项中可以设置变量为普通变量、数组、Set容器和Map容器。</font></p><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-27_11-01-39.png"></p><h2 id="2-在蓝图中使用变量"><a href="#2-在蓝图中使用变量" class="headerlink" title="2.在蓝图中使用变量"></a>2.在蓝图中使用变量</h2><p>可以直接在蓝图脚本区域右键-&gt;输入Get/Set [变量名]即可获取变量的获取/设置组件，也可以直接从左侧的My Blueprint面板Variables栏中拖拽变量到蓝图脚本区域选择Get/Set。</p><h2 id="3-生成时公开与私有变量"><a href="#3-生成时公开与私有变量" class="headerlink" title="3.生成时公开与私有变量"></a>3.生成时公开与私有变量</h2><p>蓝图中的公有与私有与程序中的公有私有有一些不同，蓝图中只分为生成时公开和私有两种访问权限。</p><h3 id="生成时公开-Expose-on-Spawn"><a href="#生成时公开-Expose-on-Spawn" class="headerlink" title="生成时公开(Expose on Spawn)"></a>生成时公开(Expose on Spawn)</h3><p>勾选生成时公开后，在蓝图类使用Spawn Actor from Class组件生成蓝图类实例时，勾选生成时公开的变量将可以接受外部值输入。<br><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-28_16-45-41.png"></p><p>如上图可以看到勾选生成时公开的变量会以输入接口的形式出现在Spawn Actor from Class节点里。这里需要注意的是，勾选Expose on Spawn，还需要勾选Instance Editable，否则会报警告。</p><h3 id="私有变量-Private"><a href="#私有变量-Private" class="headerlink" title="私有变量(Private)"></a>私有变量(Private)</h3><p>设置成私有变量的变量只能在蓝图类里访问，蓝图类的外部实例也无法访问这个变量，如上图，变量L没有设置成私有，所以可以通过Spawn Actor from Class组件生成的实例访问这个变量，而设置成私有的K变量搜索不到Set K节点。</p><h2 id="3-在蓝图中使用组件引用"><a href="#3-在蓝图中使用组件引用" class="headerlink" title="3.在蓝图中使用组件引用"></a>3.在蓝图中使用组件引用</h2><p>很多时候我们需要调节自身Actor上的组件的某些参数，那么我们就需要获得这个组件的引用以便获取组件上的参数进行调节，那么我们如何获得组件的引用呢？</p><p>其实方法也很简单，在My Blueprint/Variabales下有一个子栏“Components”其中存放着当前Actor上的所有的组件的引用，使用方法就是直接将需要的组件引用拖拽到蓝图脚本区域即可。获得了组件引用我们就可以通过引用使用不同的方法获取组件上的不同的参数了。</p><h2 id="4-动态获取世界大纲中的Actor"><a href="#4-动态获取世界大纲中的Actor" class="headerlink" title="4.动态获取世界大纲中的Actor"></a>4.动态获取世界大纲中的Actor</h2><p>在蓝图脚本中有四个方法获取外部Actor：</p><ul><li>Get All Actor of Class：通过类型来获取外部Actor</li></ul><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_18-31-16.png"></p><ul><li>Get All Actor with Tag：通过标签来获取外部Actor</li></ul><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_18-31-23.png"></p><ul><li>Get All Actor with Interface：通过外部接口在获取外部Actor</li></ul><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_18-31-36.png"></p><ul><li>Get Actors：通过层来获取Actor</li></ul><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_18-31-47.png"></p><h1 id="三、蓝图的数据类型"><a href="#三、蓝图的数据类型" class="headerlink" title="三、蓝图的数据类型"></a>三、蓝图的数据类型</h1><h2 id="1-5个基本数据类型"><a href="#1-5个基本数据类型" class="headerlink" title="1.5个基本数据类型"></a>1.5个基本数据类型</h2><p>UE4蓝图中基本数据类型只有5个，需要注意的是蓝图中没有char、double、short、long等数据类型，在C++与蓝图的配合使用时需要注意这些类型的变量。</p><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><h3 id="Byte"><a href="#Byte" class="headerlink" title="Byte"></a>Byte</h3><p>8位，一字节，0-255。</p><h3 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h3><p>32位整型，四字节。</p><h3 id="Integer64"><a href="#Integer64" class="headerlink" title="Integer64"></a>Integer64</h3><p>64位整型，八字节，能存储更大的数。</p><h3 id="Float"><a href="#Float" class="headerlink" title="Float"></a>Float</h3><p>32位单精度浮点型，其中1符号位、8指数位、23数值位，UE4中默认保留小数点后6位。UE4中只有Float类型没有Double类型。</p><h2 id="2-3种字符串"><a href="#2-3种字符串" class="headerlink" title="2.3种字符串"></a>2.3种字符串</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>蓝图中String类型就是蓝图C++中的FString类型，普通字符串，可以对其中的字符进行增删查改。</p><h3 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h3><p>Name是一种固定字符串类型，变量初始化以后不能在对其中的内容进行修改，且Name类型的字符串不区分大小写，多用于作为全局变量来唯一标识对象。Name类型的字符串在运行过程中存储于内存的字符串表中，使用效率高。</p><h3 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h3><p>Text是String的长度加强版，通常用于存储一段文字并可以进行国际化处理。</p><h2 id="3-Vector-维度向量"><a href="#3-Vector-维度向量" class="headerlink" title="3.Vector(维度向量)"></a>3.Vector(维度向量)</h2><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>默认创建的Vector是Vector 3D，即三维量，包含x、y、z三个值，可以表示任何任何三维量，如：三维坐标和RGB等。</p><h3 id="Vector-2D-和Vector-4"><a href="#Vector-2D-和Vector-4" class="headerlink" title="Vector 2D 和Vector 4"></a>Vector 2D 和Vector 4</h3><p>Vector 2D就是二维量，Vector 4就是四维量，常用于表示四元素。</p><h3 id="Two-Vectors"><a href="#Two-Vectors" class="headerlink" title="Two Vectors"></a>Two Vectors</h3><p>Two Vectors就是一个关于Vector的pair(对组)，pair在C++的STL种较为常用，是一个只包含两个元素的容器。</p><h2 id="4-Rotator-三维旋转量"><a href="#4-Rotator-三维旋转量" class="headerlink" title="4.Rotator(三维旋转量)"></a>4.Rotator(三维旋转量)</h2><p>包含：</p><p>x：roll，翻滚角，以x为轴，进行yz平面的旋转；</p><p>y：pitch，俯仰角，以y为轴，进行xz平面的旋转；</p><p>z：yaw，航向角，以z为轴，进行xy平面的旋转。</p><h2 id="5-Transform"><a href="#5-Transform" class="headerlink" title="5.Transform"></a>5.Transform</h2><p>Transfrom类型是一个3*3的矩阵，包含Location、Rotation和Scale三个三维向量。</p><h1 id="四、条件语句"><a href="#四、条件语句" class="headerlink" title="四、条件语句"></a>四、条件语句</h1><h2 id="1-Branch-if条件判断"><a href="#1-Branch-if条件判断" class="headerlink" title="1.Branch(if条件判断)"></a>1.Branch(if条件判断)</h2><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_18-39-15.png"></p><p>传入一个bool值，进行分流，通常和比较组件配合使用，如：“==”、“&gt;”等。</p><h2 id="2-Switch"><a href="#2-Switch" class="headerlink" title="2.Switch"></a>2.Switch</h2><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_19-14-34.png"></p><ul><li>Selection：case判断的变量；</li><li>Default：默认执行分支；</li><li>Add pin：添加执行分支。</li></ul><h1 id="五、循环语句"><a href="#五、循环语句" class="headerlink" title="五、循环语句"></a>五、循环语句</h1><h2 id="1-For-Loop-for循环"><a href="#1-For-Loop-for循环" class="headerlink" title="1.For Loop(for循环)"></a>1.For Loop(for循环)</h2><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_18-39-35.png"></p><ul><li>First Index/Last Index：提供循环的次数；</li><li>Loop Body：循环体执行分支；</li><li>Index：返回当前循环索引；</li><li>Conpleted：循环完毕后执行分支。</li></ul><h2 id="2-For-Loop-whit-Break-可跳出的for循环"><a href="#2-For-Loop-whit-Break-可跳出的for循环" class="headerlink" title="2.For Loop whit Break(可跳出的for循环)"></a>2.For Loop whit Break(可跳出的for循环)</h2><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_18-39-52.png"></p><p>使用方法和For Loop类似。</p><h2 id="3-For-Each-Loop-数组遍历"><a href="#3-For-Each-Loop-数组遍历" class="headerlink" title="3.For Each Loop(数组遍历)"></a>3.For Each Loop(数组遍历)</h2><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_18-40-45.png"></p><p>专门有用遍历数组的循环。</p><ul><li>Array：需要遍历的数组；</li><li>Loop Body：循环体分支；</li><li>Array Element：遍历的数组元素；</li><li>Array Index：当前索引；</li><li>Completed：遍历结束执行分支。</li></ul><h2 id="4-For-Each-Loop-with-Break-可跳出的数组遍历"><a href="#4-For-Each-Loop-with-Break-可跳出的数组遍历" class="headerlink" title="4.For Each Loop with Break(可跳出的数组遍历)"></a>4.For Each Loop with Break(可跳出的数组遍历)</h2><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_18-40-54.png"></p><p>用法和Foreach Loop一样，只是多了一个跳出执行分支。</p><h2 id="5-Reverse-for-Each-Loop-反向数组遍历"><a href="#5-Reverse-for-Each-Loop-反向数组遍历" class="headerlink" title="5.Reverse for Each Loop(反向数组遍历)"></a>5.Reverse for Each Loop(反向数组遍历)</h2><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-25_18-40-59.png"></p><h2 id="6-While-Loop-while循环"><a href="#6-While-Loop-while循环" class="headerlink" title="6.While Loop(while循环)"></a>6.While Loop(while循环)</h2><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-27_11-04-21.png"></p><h1 id="六、数组"><a href="#六、数组" class="headerlink" title="六、数组"></a>六、数组</h1><h2 id="1-创建数组"><a href="#1-创建数组" class="headerlink" title="1.创建数组"></a>1.创建数组</h2><p>创建数组要比创建变量多一个步骤，首先我们需要创建一个变量，然后再将这个变量的Details/Varialble Type选项的右侧色块选择九宫格，即可将对应变量转换成对应类型的数组。</p><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_11-02-54.png"></p><h2 id="2-为数组赋值"><a href="#2-为数组赋值" class="headerlink" title="2.为数组赋值"></a>2.为数组赋值</h2><h3 id="Add-Array"><a href="#Add-Array" class="headerlink" title="Add(Array)"></a>Add(Array)</h3><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_11-21-48.png"></p><p>传入一个数组和一个元素即可通过Add(Array)组件为组数赋值</p><p>如：</p><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_11-24-33.png"></p><p>循环完毕后数组Array内便存储有0-10的是个int型元素。</p><h2 id="3-获取元素"><a href="#3-获取元素" class="headerlink" title="3.获取元素"></a>3.获取元素</h2><h3 id="Get-a-copy"><a href="#Get-a-copy" class="headerlink" title="Get(a copy)"></a>Get(a copy)</h3><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_12-07-50.png"></p><p>获取指定索引的元素的拷贝。</p><h3 id="Get-a-ref"><a href="#Get-a-ref" class="headerlink" title="Get(a ref)"></a>Get(a ref)</h3><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_12-07-44.png"></p><p>获取指定索引的元素的引用。</p><h2 id="4-插入元素"><a href="#4-插入元素" class="headerlink" title="4.插入元素"></a>4.插入元素</h2><h3 id="Add-Aray"><a href="#Add-Aray" class="headerlink" title="Add(Aray)"></a>Add(Aray)</h3><p>直接在数组的末尾插入元素的方法也是使用Add(Array)组件，Add(Array)组件的的插入过程就是直接在数组的末尾插入元素。</p><h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_11-37-55.png"></p><p>指定位置插入使用Insert组件，输入参数从上至下依次为目标数组、要插入的元素、目标插入的索引位置。</p><p>当要使用Insert组件在数组末尾插入，而又不知道数组大小时，可以使用Last Index组件直接获取输入数组的尾索引，当然直接使用只会在最后一个索引位置插入，而使最后一位元素向后移动一位，而达不到在数组尾部插入的效果，所以需要加一食用。</p><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_11-46-46.png"></p><h3 id="Set-Array-Elem"><a href="#Set-Array-Elem" class="headerlink" title="Set Array Elem"></a>Set Array Elem</h3><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_12-25-34.png"></p><p>设置输入数组指定索引的元素的值，Size to Fit选项可以设置如果指定索引不存在时数组自动扩充size大小。</p><h2 id="5-查找元素"><a href="#5-查找元素" class="headerlink" title="5.查找元素"></a>5.查找元素</h2><h3 id="Contains-Item"><a href="#Contains-Item" class="headerlink" title="Contains Item"></a>Contains Item</h3><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_11-50-31.png"></p><p>Contains Item组件可以查找指定数组中是否包含某一元素，但是Contains Item只返回bool的判断结果，不会返回目标的索引值。</p><h3 id="Find-Item"><a href="#Find-Item" class="headerlink" title="Find Item"></a>Find Item</h3><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Git/Temp/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-59-54.png"></p><p>Find Item则是从输入数组中查找指定元素并返回第一次查找到该元素的索引值。</p><h2 id="6-删除元素"><a href="#6-删除元素" class="headerlink" title="6.删除元素"></a>6.删除元素</h2><h3 id="Remove-Index"><a href="#Remove-Index" class="headerlink" title="Remove Index"></a>Remove Index</h3><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_12-12-59.png"></p><p>通过索引删除元素</p><h3 id="Remove-Item"><a href="#Remove-Item" class="headerlink" title="Remove Item"></a>Remove Item</h3><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_12-21-30.png"></p><p>从输入数组中移除指定元素，Remove Item会删除数组中所有指定的元素，如果删除成功则返回true，失败则返回false。</p><h2 id="7-筛选元素"><a href="#7-筛选元素" class="headerlink" title="7.筛选元素"></a>7.筛选元素</h2><h3 id="Filter-Array"><a href="#Filter-Array" class="headerlink" title="Filter Array"></a>Filter Array</h3><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_11-53-49.png"></p><p>过滤数组可以按类型来筛选数组元素，用于父类型数组存储子类型元素时进行类型筛选，如：Actor数组筛选MyClass类型元素，Filter Array返回一个筛选后的新数组。</p><h2 id="8-清空数组"><a href="#8-清空数组" class="headerlink" title="8.清空数组"></a>8.清空数组</h2><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_11-42-24.png"></p><p>使用Clear组件可以将数组内的元素全部清空。</p><h2 id="9-获取数组长度"><a href="#9-获取数组长度" class="headerlink" title="9.获取数组长度"></a>9.获取数组长度</h2><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_12-29-34.png"></p><h2 id="10-设置数组长度"><a href="#10-设置数组长度" class="headerlink" title="10.设置数组长度"></a>10.设置数组长度</h2><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_12-30-00.png"></p><h1 id="七、结构体"><a href="#七、结构体" class="headerlink" title="七、结构体"></a>七、结构体</h1><h2 id="1-结构体创建"><a href="#1-结构体创建" class="headerlink" title="1.结构体创建"></a>1.结构体创建</h2><p>蓝图中结构体的创建是没办法在蓝图脚本视图中创建的，UE4蓝图中结构体是与蓝图脚本同级的蓝图类，创建蓝图结构体的方法：在Content Browser中右键-&gt;Create Advanced Assect/Blueprint栏-&gt;Structure，即可创建一个结构体，创建出来的结构体默认拥有一个bool值得成员变量。</p><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_17-38-54.png"></p><h2 id="2-定义成员变量"><a href="#2-定义成员变量" class="headerlink" title="2.定义成员变量"></a>2.定义成员变量</h2><p>蓝图中得结构体只能创建成员变量，不能创建成员函数，成员变量可以直接设置默认值。</p><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_19-59-29.png"></p><h2 id="3-结构的使用"><a href="#3-结构的使用" class="headerlink" title="3.结构的使用"></a>3.结构的使用</h2><p>将结构体创建好以后便可以直接在蓝图脚本中搜索到并使用了。</p><h1 id="八、枚举"><a href="#八、枚举" class="headerlink" title="八、枚举"></a>八、枚举</h1><h2 id="1-枚举的创建"><a href="#1-枚举的创建" class="headerlink" title="1.枚举的创建"></a>1.枚举的创建</h2><p>枚举的创建和使用和结构体区别不大，创建方式一如结构体一般,Content Browser中右键-&gt;Create Advanced Assect/Blueprint栏-&gt;Enumeration，创建好后UE4也会在一个新的视图中对枚举进行编辑，枚举的编辑操作也相当简单，只有向枚举中添加与删除元素的操作，这些元素都可以添加注解提示，枚举也可以添加整个枚举的注解提示。</p><h2 id="2-枚举的使用"><a href="#2-枚举的使用" class="headerlink" title="2.枚举的使用"></a>2.枚举的使用</h2><p>枚举的使用就如同变量的使用一般，没有什么可说的。</p><h1 id="九、接口"><a href="#九、接口" class="headerlink" title="九、接口"></a>九、接口</h1><h2 id="1-接口的定义"><a href="#1-接口的定义" class="headerlink" title="1.接口的定义"></a>1.接口的定义</h2><p>接口的定义和和蓝图函数库，蓝图宏库一样，但是接口的不像函数库和宏库一般可以再一个蓝图类中定义多个函数和宏，接口就是一个蓝图类，并且接口的编辑界面及其简约，可编辑视图只有一个My Blueprint和一个Detials,在My Blueprint/Functions栏可以新建接口函数，在对应的接口函数的Details/Graph可以设置一些接口函数的描述和Const属性，在Details/Inputs和Outputs栏可以设置接口函数的输入与输出参数。</p><h2 id="2-接口的继承"><a href="#2-接口的继承" class="headerlink" title="2.接口的继承"></a>2.接口的继承</h2><p>接口是一个抽象蓝图，接口的实现必须通过继承接口的蓝图来实现，在蓝图中接口继承通过Toolbar/Class Settings/Interfaces栏即可添加接口到当前蓝图类是指继承此接口。</p><h2 id="3-接口的实现"><a href="#3-接口的实现" class="headerlink" title="3.接口的实现"></a>3.接口的实现</h2><h3 id="无返回值的接口实现"><a href="#无返回值的接口实现" class="headerlink" title="无返回值的接口实现"></a>无返回值的接口实现</h3><p>在一个蓝图继承了一个无返回值得接口后，这个接口将以事件的形式出现在这个蓝图类的All Actions for this Blueprint里</p><p>如：</p><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-27_10-32-38.png"></p><p>蓝图以这个事件作为接口函数的入口，以此节点开始便可以开始实现各个蓝图类各自继承的接口函数的逻辑了。</p><h3 id="有返回值得接口实现"><a href="#有返回值得接口实现" class="headerlink" title="有返回值得接口实现"></a>有返回值得接口实现</h3><p>有返回值的接口不会以事件的形式出现在Add Event里，而是会直接出现在My Blueprint/Interface栏里，我们双击即可打开接口函数的编辑视图，在视图中实现接口即可。</p><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-28_17-00-10.png"></p><h2 id="4-接口函数的调用"><a href="#4-接口函数的调用" class="headerlink" title="4.接口函数的调用"></a>4.接口函数的调用</h2><p>蓝图通过<code>[接口名](Mesasge)</code>组件来调用接口中的函数，如下图中的Interface1(Message)和Interface2(Message)。</p><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-27_10-35-51.png"></p><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-27_10-38-13.png"></p><p>接口的使用需要指定使用的接口是哪个蓝图类中实现的接口和接口需要传入的参数。在蓝图类的My Blueprint/Variables栏是可以搜索到我们自己创建的蓝图类的，通过过去蓝图类的引用便可以指定接口函数的实现者了。当然我们也可以使用Get All Actors with Interface组件来获取实现了指定接口的所有蓝图类，然后再对这些蓝图类中实现的函数进行调用。</p><h1 id="十、蓝图函数库"><a href="#十、蓝图函数库" class="headerlink" title="十、蓝图函数库"></a>十、蓝图函数库</h1><p><font color="red"> 蓝图函数库是一个可以被所有蓝图类调用的函数集合，蓝图函数库里的方法全部都被定义为静态方法</font>，用于定义一些不与特定游戏对象绑定的功能性函数的实现。</p><h2 id="1-创建蓝图函数库"><a href="#1-创建蓝图函数库" class="headerlink" title="1.创建蓝图函数库"></a>1.创建蓝图函数库</h2><p>创建蓝图函数库的方式和创建结构体类似，在Content Browser中右键-&gt;Create Advanced Assect/Blueprint栏-&gt;Bluprint Function LiberLibrary。</p><h2 id="2-实现蓝图函数库里的函数"><a href="#2-实现蓝图函数库里的函数" class="headerlink" title="2.实现蓝图函数库里的函数"></a>2.实现蓝图函数库里的函数</h2><p>和结构体一样，创建好的蓝图函数库UE4会创建一个新的界面用于编辑库里函数；</p><ul><li>在My Blueprint/Functions栏可以申明函数</li><li>在My Blueprint/Local Variables栏可以生命局部变量，在其Details中可以设置局部变量默认值；</li><li>在对应函数的Details/Input和Output栏可以分别设置函数的输入输出参数</li><li>在脚本编辑区可以实现函数逻辑。</li></ul><h2 id="3-使用蓝图函数库里的函数"><a href="#3-使用蓝图函数库里的函数" class="headerlink" title="3.使用蓝图函数库里的函数"></a>3.使用蓝图函数库里的函数</h2><p>要使用蓝图函数库里的函数，可直接在脚本编辑区右键输入函数名即可在Class栏中看到蓝图函数库里的函数了。</p><h1 id="十一、蓝图宏库"><a href="#十一、蓝图宏库" class="headerlink" title="十一、蓝图宏库"></a>十一、蓝图宏库</h1><p>宏在UE4中几乎无处不在，蓝图宏库是开发者使用蓝图自定义的一系列的宏的容器，蓝图宏库和蓝图函数库一样可以定义多个宏；</p><ul><li>蓝图宏库与蓝图函数库不同的是，蓝图宏库中的宏是在预编译过程中完成处理的，即蓝图宏库不需要编译；</li><li>自定义的宏，可以有任意数量的输入输出引脚，即一个宏可以没有输出引脚，这样的宏可以只进行数据处理，一个宏也可以有多个输入输出引脚，这样的宏可以根据不同的逻辑选择不同的执行流，而蓝图函数库中的函数必须有且只有一个输入和一个输出引脚；</li><li>与函数不同，宏中不可以再定义成员变量，即宏只负责处理逻辑，不提供暂存能力。</li></ul><h2 id="1-创建蓝图宏库"><a href="#1-创建蓝图宏库" class="headerlink" title="1.创建蓝图宏库"></a>1.创建蓝图宏库</h2><p>宏库的创建与函数库的创建是一样的，在Content Browser中右键-&gt;Create Advanced Assect/Blueprint栏-&gt;Bluprint Macro LiberLibrary。</p><h2 id="2-蓝图宏声明"><a href="#2-蓝图宏声明" class="headerlink" title="2.蓝图宏声明"></a>2.蓝图宏声明</h2><ul><li>在My Blueprint/Macro中可以声明一个宏；</li><li>在指定宏的Details/Inputs和Outputs中可以定义输入与输出引脚和参数。</li></ul><h2 id="3-蓝图宏的使用"><a href="#3-蓝图宏的使用" class="headerlink" title="3.蓝图宏的使用"></a>3.蓝图宏的使用</h2><p>和蓝图函数的使用方法一致。</p><h2 id="4-自定义流程控制"><a href="#4-自定义流程控制" class="headerlink" title="4.自定义流程控制"></a>4.自定义流程控制</h2><p>除了蓝图提供给我们的条件语句和循环语句等流程控制语句外，我还可以使用宏编写自己的流程控制，因为宏可以有多个输入和输出引脚，使用方法就是使用宏的形式定义自己的流程控制逻辑，通过不同的输入给予不同输出，即可达到自定义流程控制的目的。</p><h1 id="十二、事件"><a href="#十二、事件" class="headerlink" title="十二、事件"></a>十二、事件</h1><p>除了UE4蓝图中给我们提供大量的预定义事件，我也可以自定义事件。</p><h2 id="1-事件的定义"><a href="#1-事件的定义" class="headerlink" title="1.事件的定义"></a>1.事件的定义</h2><p>事件的定义也很简单，在All Actions for this Buleprint中选择Add Custom Event，便可以创建一个自定义事件的入口，之后通过这个入口实现事件的内部逻辑，一个事件便定义完成。</p><h2 id="2-事件的调用"><a href="#2-事件的调用" class="headerlink" title="2.事件的调用"></a>2.事件的调用</h2><p>事件调用必须通过实现这个事件的蓝图类才可以对其中的事件进行调用。如：</p><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-27_11-28-43.png"></p><p>Event Blueprint为实现自定义事件的蓝图类；</p><p>Print Str为自定义事件。</p><h2 id="3-事件调度器"><a href="#3-事件调度器" class="headerlink" title="3.事件调度器"></a>3.事件调度器</h2><p>事件调度器的创建与使用请阅读目录：十七、蓝图类的通信/3.使用事件调度器进行通信</p><h1 id="十三、蓝图模块"><a href="#十三、蓝图模块" class="headerlink" title="十三、蓝图模块"></a>十三、蓝图模块</h1><p>蓝图中可以将一个复杂了逻辑处理合并成一个节点模块，从而简化整体的执行流复杂度，使蓝图的执行流变得简单明了。我们可以将需要合并的执行流多选选中然后右键，即可在Organization栏中通过Collapse Nodes选项来合并执行流。</p><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-27_11-31-04.png"></p><p>除了将执行流合并成节点外，蓝图还提供将多个执行流合并成一个函数或一个宏的功能。合并好的模块也可以在Organizition/Expand Node进行模块分离。</p><h1 id="十四、角色控制"><a href="#十四、角色控制" class="headerlink" title="十四、角色控制"></a>十四、角色控制</h1><h2 id="1-为角色添加跟随相机"><a href="#1-为角色添加跟随相机" class="headerlink" title="1.为角色添加跟随相机"></a>1.为角色添加跟随相机</h2><p>相对U3D来说，UE4的相机跟随要简单得多，UE4中直接将相机设置成了蓝图类的组件，当蓝图类时Player时，即可实现相机对Player的跟随了。</p><p>相机跟随需要通过一个物理组件<code>Spring Arm</code>来链接相机和Player，将相机附着在Spring Arm下，即可在Spring Arm的作用下实现相机跟随。</p><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-24_10-45-29.png"></p><h2 id="2-为角色添加控制器"><a href="#2-为角色添加控制器" class="headerlink" title="2.为角色添加控制器"></a>2.为角色添加控制器</h2><p>在UE4的游戏制作过程中，我们不难发现当我们运行游戏时，在世界大纲中多出了很多东西，如下图：</p><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-24_10-53-34.png"></p><p>其实，UE4为我们提供很多已经预制好的必须品，如上图的PlayerController(角色控制器)、PlayerCameraMenager(角色相机管理器)等。也就是说不可以直接使用UE4预制给我们的角色控制器来控制我们的Player，而不需要自己再去为Player蓝图配置角色控制器了，我们只需将Player的细节面板上的Auto Possess Player设置成Player0即可，Player0即表示本地角色。</p><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-24_10-53-06.png"></p><p>需要注意的是，对于角色控制更优的方式是使用<code>Player Start</code>组件去持有Player蓝图类，再通过Player Controller来控制Player Start达到控制角色的目的。</p><h2 id="3-自定义游戏模式"><a href="#3-自定义游戏模式" class="headerlink" title="3.自定义游戏模式"></a>3.自定义游戏模式</h2><p>在我们创建一个UE4工程后，UE4会启用UE4默认的游戏模式<code>GameModeBase</code>，GameModeBase就控制着Player Controller、PlayerCameraMenager、PlayerState等运行时UE4动态生成的一些游戏物体，我们可以通过启用我们自定义的游戏模式来设置这些游戏物体按自己的定义的规则来生成运行。</p><p>游戏模式也是一个蓝图类，创建游戏模式就是创建蓝图类，只是这个蓝图类需要继承自GameModeBase类，继承自GameModeBase类的蓝图就是一个游戏模式蓝图。不过在我们第一此=次打开游戏模式蓝图时，UE4会将游戏模式蓝图识别成一个普通蓝图，而进入普通蓝图的编辑模式，可能是bug吧，此时我们只需将蓝图关闭，再打开一次，UE4便可以识别出游戏模式蓝图了。</p><p>游戏模式蓝图中可以定义自己的游戏模式规则，比如我们可以通过修改Spectator Class选项为自定义的游戏物体，这样在游戏运行时，UE4将不再生成DefaulPawn，而是会生成我们指定的游戏物体。</p><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80%5CSnipaste_2019-10-24_11-09-34.png"></p><p>配置好游戏模式后我们还需要让当前项目使用我们自定义的游戏模式，通过Seettings -&gt;Project Settings-&gt;Project/Maps&amp;Modes-&gt;Dfault GameModes，选择我们自己的配置的游戏模式即可让当前项目启用我们自己定义的游戏模式了</p><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-24_11-12-38.png"></p><h2 id="4-操控角色控制器"><a href="#4-操控角色控制器" class="headerlink" title="4.操控角色控制器"></a>4.操控角色控制器</h2><p>我们要操控角色控制器就需要配置键盘按键映射，配置好的键盘映射会以函数的形式加入蓝图脚本组件集中。</p><p>我们在Seettings -&gt;Project Settings-&gt;Engine/Input-&gt;Bindings/Axis Mappings设置键盘映射并可以配置映射的值，</p><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-24_14-55-47.png"></p><p>配置好键盘映射以后便可以在蓝图脚本中使用这些函数主键来控制我们Player了，控制角色运动的方法很多，我这里以旋转力矩的方式来控制小球运动，具体的控制方法如下：</p><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-24_15-11-12.png"></p><p>加入两个键盘映射函数组件(InputAxis MoveF/B,InputAxis MoveL/R)、两个添加角度力矩的组件(Add Torque in Radians,Add Torque in Radians)，但是添加角度力矩组件是需要一个控制目标的，我们需要从左侧的My Blueprint面板的Components中将需要控制的物体Player拖入脚本蓝图中，分别连接到添加角度力矩组件的Target上。</p><p>这里还需要注意的一点是，在我们为Player添加相机时，相机使用的是相对于Player的局部坐标，使用局部坐标的相机会跟随Player旋转，而使用世界坐标的相机将会固定某一个角度跟随Player移动。切换方法为：下拉Spring Arm的细节面板/Transform/Rotation的三角箭头选择切换。</p><p>并且相机默认情况下是启用了物理碰撞的，但大多数情况下我们是不需要让相机出现物理碰撞的，所以我们也应当取消相机的物理碰撞。操作方法为：取消Spring Arm的细节面板/Camera Collision/Do Collision Test选项。</p><p>当然要想比较真实的模拟出物理效果，光这样是不行的，因为默认情况下Player是没有启动物理模拟的，我们需要启用Player的细节面板/Physics/Simulate Physics选项，并且将调节Player的细节面板/Linear Damping(线性摩檫)和Player的细节面板/Angular Damping(旋转摩檫)到适当的值，应为UE4默认是没有旋转摩檫的并且，默认线性摩檫为0.01。</p><h2 id="小知识"><a href="#小知识" class="headerlink" title=" 小知识"></a><font color="Green"> 小知识</font></h2><ul><li><font color="green"> 大多数时候我们都需要勾选作用力函数组件的Acel Change选项，如：上面的Add Torque in Radians，勾选了Acel Change选项作用力组件会在作用目标物体时忽略物体的质量因素，因为存在质量影响的话，我们可能需要给一个极大的力才能推动目标物体；</font></li><li><font color="green"> 有时可能默认大小的作用力对目标物体的移动作用达不到我们理想的效果，此时可以先将作用力加倍后在传递给作用力组件，蓝图脚本组件集中提供多种多样的乘积组件，我们上面使用的是float*float组件</font>；</li></ul><h1 id="十五、触发器"><a href="#十五、触发器" class="headerlink" title="十五、触发器"></a>十五、触发器</h1><p>在游戏设计中触发器的使用是非常平凡的，而在蓝图中触发器的实现也并不复杂，我们来看一下具体操作：</p><h2 id="1-创建触发器"><a href="#1-创建触发器" class="headerlink" title="1.创建触发器"></a>1.创建触发器</h2><ul><li>蓝图模式中游戏的一切都是蓝图，触发器也不例外，所以要做一个触发器，首先我们的创建一个蓝图的壳子，并继承自Actor类</li><li>触发器还需要一个极为重要的东西就是碰撞体，当然这里的碰撞体不是具有物理碰撞的网格碰撞体，而是蓝图的物理组件集中的Box Collison，一个没有物理碰撞效果专门用于触发器的盒碰撞体，我们给蓝图类添加这个组件，一个触发器便完成了</li></ul><h2 id="2-使用触发器"><a href="#2-使用触发器" class="headerlink" title="2.使用触发器"></a>2.使用触发器</h2><p>当触发器放置于场景中，有物体进入触发器碰撞盒时，触发器便会出自动发触发Event ActorBeginOverlap时间组件，之后我们便可以进行一系列逻辑操作了。</p><h1 id="十六、蓝图类的通信"><a href="#十六、蓝图类的通信" class="headerlink" title="十六、蓝图类的通信"></a>十六、蓝图类的通信</h1><h2 id="1-使用引用进行通信"><a href="#1-使用引用进行通信" class="headerlink" title="1.使用引用进行通信"></a>1.使用引用进行通信</h2><p>两个蓝图类要想通过引用进行通信，那么其中一个蓝图类就必须拥有另一个蓝图类的引用，如何获取一个蓝图类的引用呢？</p><p>在My Blueprint/Variables栏中添加一个所需要引用的蓝图类类型的变量，勾选它的Details/Variable/Instance Editable选项，就可以在这个蓝图类的实例的Details/Default栏中看到引用变量(如果不勾选是没有default栏的)，如此便可以方便的获取另一个蓝图类的实例的引用了。</p><p>通过引用两个蓝图类之间便可以进行单向的信息传递了。即拥有引用的蓝图类可以获取所引用蓝图的传递过来的信息，反向则不行。</p><h2 id="2-使用接口进行通信"><a href="#2-使用接口进行通信" class="headerlink" title="2.使用接口进行通信"></a>2.使用接口进行通信</h2><p>使用接口进行通信的好处是可以很便利的通过同一事件让各种不同的蓝图做出不同的反应，如：当受到子弹攻击时，墙会反弹子弹，人会受伤，通过接口通信来实现这个效果就是，创建一个受到子弹攻击的接口OnTakeAttack，然后分别让墙和人都继承这个接口并实现不同的效果，如此当受到子弹攻击时，我们便可以通过Get All Actor with Interface来调用实现这些接口的Actor来做出各自的反应。</p><p>接口的实现与使用请阅读目录：九、接口。</p><h2 id="3-使用事件调度器通信"><a href="#3-使用事件调度器通信" class="headerlink" title="3.使用事件调度器通信"></a>3.使用事件调度器通信</h2><p>事件调度器的通信过程是一个调度者与一个或多个被调度者之间的通信过程，类似观察者模式的通信过程。</p><h3 id="创建事件调度器"><a href="#创建事件调度器" class="headerlink" title="创建事件调度器"></a>创建事件调度器</h3><p>使用事件调度器来进行蓝图通信，首先我们需要拥有一个事件调度器；</p><p>事件调度器只能被拥有者调用，所以我们需要在调度者蓝图上创建事件调度器，在My Blueprint/Event Dispatchers栏可以新建一个蓝图调度器，此时这个蓝图便拥有了一个事件调度器，我们可以通过拖拽事件调度器到脚本编辑视图或直接在All Actions for this Blueprint中搜索，可以对事件调度器进行事件绑定(Bind)、事件解绑(Unbind)、解绑全部事件(Unbind all)，直接为事件调度器绑定新事件(Assign)和调用事件调度器(Call)。当一个事件调度器被调用后，与这个事件调度器绑定的事件都会被调用，一次来达到信息传递的目的。</p><h3 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h3><p>调度者要事件调度器调用被调度者的事件，那么被调度者就需要向调度者的事件调度器上绑定事件，通过Bind Event to [事件调度器名]组件来绑定事件到事件调度器上。</p><p><img src="/2019/10/28/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-28_15-51-30.png"></p><p>Target：输入事件调度器的拥有者对象</p><p>Event：需要绑定的事件</p><p>如此一个基于事件调度器的通信机制便完成了。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【MyQSL】MyQSL存储过程</title>
    <link href="/2019/10/21/%E3%80%90MyQSL%E3%80%91MyQSL%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    <url>/2019/10/21/%E3%80%90MyQSL%E3%80%91MyQSL%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="1-什么是存储过程"><a href="#1-什么是存储过程" class="headerlink" title="1.什么是存储过程"></a>1.什么是存储过程</h1><p>数据库中的存储过程有点类似编程中的函数，可以供外部环境在需要时调用，并且存储过程只需要编译一次，之后再用则无需进行在此编译。</p><h1 id="2-存储过程的创建"><a href="#2-存储过程的创建" class="headerlink" title="2.存储过程的创建"></a>2.存储过程的创建</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">delimiter &#x2F;&#x2F;<br>create procedure Test(in parameter01 int,out parameter02 varchar(45));<br>begin<br>-- 存储逻辑<br>end<br>&#x2F;&#x2F;<br>delimiter ;<br></code></pre></td></tr></table></figure><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li><strong>delimiter //</strong>:更改MySQL中语句分隔符<code>;</code>，目的就是为了将存储过程作为一个整体，使MySQL中的存储逻辑中的<code>;</code>在代码编辑阶段不被编译器识别，<code>//</code>标识在两个<code>//</code>中间的逻辑为存储逻辑，告知MySQL其中的<code>;</code>不需要解释；<font color="red"> 但是要记住，在用完<code>//</code>这个之后要记得将分隔符转回<code>;</code>,否则之后的语句也会使用<code>//</code>作为分隔符</font>。其中<code>//</code>可以是任意字符或字符串。</li><li><strong>create procedure Test(in parameter01 int , out parameter02 vachar(45))</strong>:创建一个存储过程Test，存储过程包含输入参数parameter01和输出参数parameter02，其中<code>in</code>标识输入参数，<code>out</code>标识输出参数，如果括号中不写标识in/out则默认为输入参数，其中输入参数只能用于从外界传入参数，输出参数只能用于返回结果，类似编程中的返回值。MySQL中也提供<code>inout</code>类型的参数，既可以作为输入参数使用也可以作为输出参数使用，但是不建议这么用，比较好的用法还是输入输出分开。</li><li><strong>begin end</strong>:<code>begin end</code>用来标识一个语句块，必须承兑出现，可以用在任何地方，在存储过程中逻辑写在<code>begin end</code>块内。</li></ul><h1 id="3-存储过程的使用"><a href="#3-存储过程的使用" class="headerlink" title="3.存储过程的使用"></a>3.存储过程的使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">call Test(1,@out_parameter);<br></code></pre></td></tr></table></figure><p>存储过程的使用就如同函数调用一般，传入输入参数，并使用使用变量来接收输出参数。<code>@out_parameter</code>就是用来接收输出参数的变量。</p><h1 id="4-存储逻辑"><a href="#4-存储逻辑" class="headerlink" title="4.存储逻辑"></a>4.存储逻辑</h1><p>在编写存储过程时逻辑判断语句是一定会用到的，下面列举一些常用的逻辑判断语句及其用法。</p><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>MySQL中单独的if语句和程序编程中有所不同，单独的if语句一般嵌入其他语句中一起用，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select if(exc,&#39;A&#39;,&#39;B&#39;);<br></code></pre></td></tr></table></figure><p>当exc的值为true时，输出A，否则输出B，exc可以是一个变量也可以是是一个语句，同理A，B也可以是一个变量或是一个语句。</p><h2 id="if-esle语句"><a href="#if-esle语句" class="headerlink" title="if esle语句"></a>if esle语句</h2><p>if esle语句与esle则有极大的不同，if else语句更接近编程中if esle</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">if exc1 then<br> -- 执行逻辑1;<br>elseif exc2 then<br>-- 执行逻辑2;<br>else<br>-- 执行逻辑3;<br>end if;<br></code></pre></td></tr></table></figure><p>每一个if/elseif之后都需要跟一个then才能写执行逻辑，需要注意的是，then和执行逻辑之间没有<code>;</code>分隔。if语句结束时需要使用 end if;来告知MySQLif判断语句结束。同单独的if语句一样，if else中的exc也可以是变量和语句。</p><h2 id="循环体"><a href="#循环体" class="headerlink" title="循环体"></a>循环体</h2><p>MySQL的循环体使用游标来实现，具体的我们先看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs mysql">delimiter &#x2F;&#x2F;<br>-- 使用断面名删除断面的时间戳数据，此存储过程不允许删除断面<br>create procedure DeleteSurfaceDataByName(<br>in in_surface_name varchar(32),<br>in in_time_point_start varchar(32),<br>in in_time_point_end varchar(32),<br>out run_state bool<br>)<br>begin<br>-- 判断断面是否合法<br>    if exists (select surface_no from surface_number where surface_name &#x3D; in_surface_name) then<br>    begin<br>declare num varchar(32) default null;<br>-- 游标的结束标志<br>declare done bool default false;<br>        -- 为主键id创建游标<br>declare cur cursor for select id from surface_data where surface_name &#x3D; in_surface_name;<br>        -- 将结束标志关联到游标<br>        declare continue handler for not found set done &#x3D; true;<br>        -- 打开游标<br>        open cur;<br>        -- 创建循环过程<br>        delete_loop:loop<br>        -- 从游标结果集中取值到num<br>        fetch next from cur into num;<br>-- 游标后移<br>        if done then<br>leave delete_loop;<br>end if;<br>        -- 循环语句<br>        begin<br>-- 场景1-删除当前段面中某一时段的水文数据<br>if in_time_point_start is not null and in_time_point_end is not null then<br>delete from surface_data where id &#x3D; num and ascii(time_point) &gt;&#x3D; ascii(in_time_point_start) <br>and ascii(time_point) &lt;&#x3D; ascii(in_time_point_end);<br>-- 场景2-删除当前断面中某一时刻的水文数据<br>elseif in_time_point_start is not null and in_time_point_end is null then<br>delete from surface_data where id &#x3D; num and time_point &#x3D; in_time_point_start;<br>end if;<br>end;<br>        -- 结束循环<br>        end loop;<br>        set run_state &#x3D; true;<br>end;<br>else<br>set run_state &#x3D; false;<br>end if;<br>end<br>&#x2F;&#x2F;<br>delimiter ;<br></code></pre></td></tr></table></figure><ul><li><strong>exists()</strong>:和select搭配可以判断满足where条件的selete字段在from的表中是否存在</li><li><strong>declare cur cursor for</strong>:和select语句搭配可以为select出来的结果集创建一个游标cur，而这个游标便是循环体的关键，游标就有点类似SLT中迭代器，可以逐一读取结果集中的数据。</li><li><strong>declare continue handler for not found set done = true</strong>：光有游标还是无法实现循环体的，循环体还有一个很重要的标志–结束标志，这条语句便是为游标设置循环结束标志，这条语句和前面的<code>declare done bool default false;</code>搭配使用，done便是循环结束的标志，通过这条语句将游标和循环结束标志绑定起来。</li><li><strong>open cur</strong>：上面仅仅是做好了使用循环体的前提，要想使用循环体还需要将游标打开，以便游标可以使用，open cur便是打开游标cur。</li><li><strong>delete_loop:loop</strong>:这是真正的循环体的开始，开始一个循环题delete_loop,同时需要使用<code>end loop;</code>来标识循环题结束。</li><li><strong>fetch next from cur into num</strong>:向游标cur指向的结果几种逐一读取数据到num变量中，这里要值意num变量和结果集中的数据类型要一至。</li><li>**if done then leave delete_loop end if;**：判断结束标志done，如果done等于true就继续执行循环体。</li><li>在if done then leave delete_loop end if;和end loop之间的就是每次循环执行的语句了。</li></ul><p>至此整个循环语句结束。</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE4】基础</title>
    <link href="/2019/10/14/%E3%80%90UE4%E3%80%91UE4%E5%9F%BA%E7%A1%80/"/>
    <url>/2019/10/14/%E3%80%90UE4%E3%80%91UE4%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【日记】在武汉跑秋招的日子</title>
    <link href="/2019/10/12/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E6%AD%A6%E6%B1%89%E8%B7%91%E7%A7%8B%E6%8B%9B%E7%9A%84%E6%97%A5%E5%AD%90/"/>
    <url>/2019/10/12/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E6%AD%A6%E6%B1%89%E8%B7%91%E7%A7%8B%E6%8B%9B%E7%9A%84%E6%97%A5%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>​    今天是十月十二号，阴，天灰蒙蒙的，仿佛和我此时的心境一般，此时我心身具备，虽然在国庆结束的前一天我拿到了第一个offer，可能也是唯一的一个offer了，尽管这份工作是那么的不尽人意。</p><p><img src="/2019/10/12/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E6%AD%A6%E6%B1%89%E8%B7%91%E7%A7%8B%E6%8B%9B%E7%9A%84%E6%97%A5%E5%AD%90/QQ%E5%9B%BE%E7%89%8720191012190626.jpg"></p><p>​    我呢，现在是三峡大学计算机与信息学院在校2020应届生，为了秋招我从今年5月份开始准备，当时打算的就业方向是Unity3d客户端开发，哎！现在想想当时自己是不是太幼稚了，完全没有考虑过就业形势，而是全凭自己的兴趣一头扎入进去，就开始不闻窗外的苦学。结果真正到了秋招的时候，自己完全蒙了，去武汉大学和华中科技大学的校招的游戏公司一双手数足以，去三峡大学招聘的只需要三个手指😂。结果可想而知，九月份奋斗了一个月，也就吃了一个月的灰。</p><p><img src="/2019/10/12/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E6%AD%A6%E6%B1%89%E8%B7%91%E7%A7%8B%E6%8B%9B%E7%9A%84%E6%97%A5%E5%AD%90/QQ%E5%9B%BE%E7%89%8720191012190452.jpg"></p><p>​    我东谷伯伯说的好啊，穷人的孩子，不该有梦想，带着梦想的穷孩子只会过得很累。家里没有足够的经济支持你去追求这些梦想。穷人的孩子更多的应该是考虑现实，而不是追求兴趣，选专业就应该选好就业的，无论兴趣如何。因为生活在一个穷困的家庭，没有钱是万万不能的。你需要的是尽早的就业来当起这个家。可笑的是，我现在才明白，难道我选择专业的时候选择了兴趣，选择就业的时候选择兴趣，真的错了吗？</p><p>​    九月五号，我和儒哥踏上了前往武汉的动车，两个小时的动车路程加一个小时的地铁路程加十几分钟的滴滴路程，我们来的早已预约好的租房“武汉市洪山区竹苑小区四栋一单元302号房”，涉世不深的我第一次被社会割肉，房租交了1100软妹币，押金交了1300软妹币，大出血啊！从家里带的5000软妹币瞬间去掉一半，更可恶的是，第一个星期进去仅仅五天，水电费就花掉50，一个月下来水电费足足花了200。</p><p><img src="/2019/10/12/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E6%AD%A6%E6%B1%89%E8%B7%91%E7%A7%8B%E6%8B%9B%E7%9A%84%E6%97%A5%E5%AD%90/QQ%E5%9B%BE%E7%89%8720191012190616.jpg"></p><p>​    入住第二天，上午我们来到了武大，只能说名校果然是名校，那环境，那楼宇，那面积，那宿舍都不是普通本科能比的，这天正好碰到武大有一场音乐艺术展，于是就去，里面一排排的钢琴，尽管看不懂，但是依旧觉得牛逼。纵穿武大，便来到了东湖，不得不说武汉的风景确实没得说。下午我们来到了华科，华科也不是一般的大，而且规划工整，那路是横七竖八，笔直笔直的，那绿植覆盖面积，走在校园里几乎不用晒太阳。我们也是骑着一个哈罗单车足足逛了一下午。到了晚上便开始了我们来到武行的第一场宣讲会–oppo华科宣讲会。</p><p><img src="/2019/10/12/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E6%AD%A6%E6%B1%89%E8%B7%91%E7%A7%8B%E6%8B%9B%E7%9A%84%E6%97%A5%E5%AD%90/Snipaste_2019-09-08_09-15-55.png"></p><p><img src="/2019/10/12/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E6%AD%A6%E6%B1%89%E8%B7%91%E7%A7%8B%E6%8B%9B%E7%9A%84%E6%97%A5%E5%AD%90/Snipaste_2019-09-08_09-23-19.png"></p><p><img src="/2019/10/12/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E6%AD%A6%E6%B1%89%E8%B7%91%E7%A7%8B%E6%8B%9B%E7%9A%84%E6%97%A5%E5%AD%90/QQ%E5%9B%BE%E7%89%8720191012190552.jpg"></p><p><img src="/2019/10/12/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E6%AD%A6%E6%B1%89%E8%B7%91%E7%A7%8B%E6%8B%9B%E7%9A%84%E6%97%A5%E5%AD%90/QQ%E5%9B%BE%E7%89%8720191012190600.jpg"></p><p><img src="/2019/10/12/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E6%AD%A6%E6%B1%89%E8%B7%91%E7%A7%8B%E6%8B%9B%E7%9A%84%E6%97%A5%E5%AD%90/QQ%E5%9B%BE%E7%89%8720191012190518.jpg"></p><p><img src="/2019/10/12/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E6%AD%A6%E6%B1%89%E8%B7%91%E7%A7%8B%E6%8B%9B%E7%9A%84%E6%97%A5%E5%AD%90/Snipaste_2019-09-08_09-28-22.png"></p><p><img src="/2019/10/12/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E6%AD%A6%E6%B1%89%E8%B7%91%E7%A7%8B%E6%8B%9B%E7%9A%84%E6%97%A5%E5%AD%90/Snipaste_2019-09-08_09-34-22.png"></p><p>​    只有当自己切真切实的接触到了这些名校，切真切实的接触到了名校中的那些人，才会明白在大学四年里所说的那些名校差距原来如此之大。可能是高中三年太辛苦，亦或是预科一年太放纵，大学三年啊，我终究是没有学会多少东西。可这又怎能让我信服呢？我真的没有学到什么东西吗？大一，因为读了一年预科，我不再是出来扎到，于是乎我做了班级负责人，然后觉得太累，于是正式选举班委时选择了副班长，学生组织，我选择了院新媒体。一年来，我参加比赛，制作视频，最后也是拿了个校三等奖学金。大二，我成了新媒体摄像部的部长，我把精力都用来管理部门，教导干事，于是乎我们部门成了优秀部门。同年借着新媒体和宋哥，我们成立的木瓜传媒工作室，对外接单，曾三次远赴神农架，总盈利13000软妹币，同样也顺利拿下了那年的三等奖学金。大三,我和儒哥一起在必胜客兼职了半年，同时我做到了经济独立11一个月，差一个月的经济独立一年。同时在富云达学习了半年，也开始为找工作而忧心，大三呆在学校的时间确实少了很多，尽管没拿到奖学金，但是成绩确实是提升了很多。如此充实的大学生活，我真的什么也没学到吗？</p><p><img src="/2019/10/12/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E6%AD%A6%E6%B1%89%E8%B7%91%E7%A7%8B%E6%8B%9B%E7%9A%84%E6%97%A5%E5%AD%90/QQ%E5%9B%BE%E7%89%8720191012190504.jpg"></p><p>​    事实证明，我真的很差劲，九月份，我和儒哥都开始了自己的秋招之旅，一整个九月，我跑了好几家游戏公司，成都摩丰，长沙的沃尔信息，武汉的微派网络，众娱，广州的速游网络，北京的多乐游戏，结果是一家没进。反观儒哥，他搞Web，结果一面就进了快客云，实习工资3700。顿时我被打击到哭泣，对没错因为恰逢中秋，我哭了，在和妈打的电话中哭得很彻底。这一次我想家了，想家想到了骨子里，这还是自从我小学六年级第一次离开父母留校寄宿以来最想家的一次，即使当年预科父亲送我来到宜昌离开我回家那次都没有这一次那么想家。想家也许是每一个在外漂泊的游子必定要经历的吧。</p><p>​    第二天我买上了回家的车票，早上九点到晚上十一点，我到家了，我终于暂时卸下了三个多月来的忧心忡忡。母亲知道我要回来就上山区采了皇竹笋，做了一顿竹笋酿，那是我这么久以来吃的最无忧无虑的一顿，心里没有忧愁，嘴里尽是美味，对面坐者母亲，顶上是家，可能这才是我想要的生活吧。每天能有一些时间在家陪陪父母，也不失是一种幸福。父母操劳了半辈子，送我和弟弟读书，弟弟不争气跑去复读了，我作为长子找工作的事本不应该让父母操心，因为父母操心也不打劲，只能为我干着急。于是我开始反思，走游戏开发这条路我真的走对了吗？我是不是应该换条路走呢？比如C++。</p><p><img src="/2019/10/12/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E6%AD%A6%E6%B1%89%E8%B7%91%E7%A7%8B%E6%8B%9B%E7%9A%84%E6%97%A5%E5%AD%90/QQ%E5%9B%BE%E7%89%8720191012190448.jpg"></p><p><img src="/2019/10/12/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E6%AD%A6%E6%B1%89%E8%B7%91%E7%A7%8B%E6%8B%9B%E7%9A%84%E6%97%A5%E5%AD%90/QQ%E5%9B%BE%E7%89%8720191012190414.jpg"></p><p><img src="/2019/10/12/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E6%AD%A6%E6%B1%89%E8%B7%91%E7%A7%8B%E6%8B%9B%E7%9A%84%E6%97%A5%E5%AD%90/QQ%E5%9B%BE%E7%89%8720191012190444.jpg"></p><p>​    在家里的几天是我整个大三以来过的最舒心的几天，可是时间转瞬即逝，我又踏上了秋招之旅。九月25日，依旧没找到工作的我决定返校回去深造C++，然后国庆之后转行寻找C++的岗位。回到学校才发现学生时代的生活真的很美好，相比社会的残酷，校园原来真的是一个乐园，只是十几年的学生生活让我忽略了这一点。只剩最后一年的大学生活了，现在明白过来也为时不晚，且行还须且珍惜。</p><p>​    国庆过了，房租也到期了，我开始了寄居生活，儒哥找到了工作于是就在公司附近租了个房子，我便开始寄居在儒哥的房子里，十月七号，我拿到了第一个offer，蛛网传媒，这是一家半个游戏公司的公司，因为他们做游戏却不是做自己的游戏，并且他们不仅仅做游戏，还做其他的软件，类似一家外包公司。实习工资3000软妹币加餐补300。也许是我自己把待遇开低了，唉~也罢，谁让我九月份受够了打击呢？于此同时九月份投的很多家公司也都邮来了面试通知，我去了，却都凉凉了，在和我们班那些去华清远见培训的同学聊面试题的时候，我才知道自己的C++是有多菜，我真的没有什么可值得骄傲的，可笑的是，八月的时候我居然笑着说“找工作不难，难的是找一个好工作”，我啊，似乎是出来些什么问题了。</p><p><img src="/2019/10/12/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E6%AD%A6%E6%B1%89%E8%B7%91%E7%A7%8B%E6%8B%9B%E7%9A%84%E6%97%A5%E5%AD%90/QQ%E5%9B%BE%E7%89%8720191012190638.jpg"></p><p>​    今天是十月十二号，我已经和房东商量好了，明天搬过去，住在武汉市银河湾，离公司蛮近的。后天就要去上班了，我的进修之旅还远没结束。</p><p>​    经历了这么多，那些平时不爱学习，成绩不好的同学反而找到了一个不错的工作，我这个自以为比他们优秀的学生却秋招那么惨，最终去了一家连自己都不觉得有多好的小公司，尽管我已经很努力的准备了三个月，很努力的学了三个月，可最终的结果却是那么的不尽人意，我很失落，我有问题，我的身上肯定出了什么问题，以至于我得到了一个如此不满意的结果。</p><p><img src="/2019/10/12/%E3%80%90%E6%97%A5%E8%AE%B0%E3%80%91%E5%9C%A8%E6%AD%A6%E6%B1%89%E8%B7%91%E7%A7%8B%E6%8B%9B%E7%9A%84%E6%97%A5%E5%AD%90/QQ%E5%9B%BE%E7%89%8720191012190641.jpg"></p><p>​    也许生活就是这样雕琢一个孩子的吧，这次秋招我才意识到，自己眼中的优秀就是个屁，也许我该拾起初高中的那股劲了，大学的自己似乎过于放纵了，以至于成就了一个失败的自己。我的身上出问题了，我要找出来，我不比他们差，我不应该如此生活，我需要变强的，变得很强很强。现在得我真的没有资格说累，“累”，那是给别人说的。</p>]]></content>
    
    
    <categories>
      
      <category>日记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大事件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【待解决】一些待解决的难题</title>
    <link href="/2019/10/10/%E3%80%90%E5%BE%85%E8%A7%A3%E5%86%B3%E3%80%91%E4%B8%80%E4%BA%9B%E5%BE%85%E8%A7%A3%E5%86%B3%E7%9A%84%E9%9A%BE%E9%A2%98/"/>
    <url>/2019/10/10/%E3%80%90%E5%BE%85%E8%A7%A3%E5%86%B3%E3%80%91%E4%B8%80%E4%BA%9B%E5%BE%85%E8%A7%A3%E5%86%B3%E7%9A%84%E9%9A%BE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>这里记录一些待解决的程序难题</p><h1 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h1><p>1.这两种内存分配的方式，有什么不一样，<br>2.初始化的s最后结果有什么不一样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">a</span> &#123;</span><br><span class="hljs-keyword">int</span> id;<br><span class="hljs-built_in">string</span> s;<br>&#125;;<br>a *ptr1 = <span class="hljs-keyword">new</span> a();<br>ptr1-&gt;s = <span class="hljs-string">&quot;hello&quot;</span>;<br>a *ptr2 = (a*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(a));<br>ptr2-&gt;s = <span class="hljs-string">&quot;hello&quot;</span>;<span class="hljs-comment">//这一句却会报异常，为什么？</span><br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h1><p>List容器中empty()判空和size()==0判空有什么不同</p><h1 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h1><p>为什么函数外的指针的值没有变化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getmemory</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *p)</span></span><br><span class="hljs-function"></span>&#123;<br>p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">100</span>];<br>strcpy_s(p,<span class="hljs-number">12</span>, <span class="hljs-string">&quot;hello world&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, p);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">char</span> *p = <span class="hljs-literal">NULL</span>;<br>getmemory(p);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, p);<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>而下面代码却可以改变</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getmemory</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **p)</span></span><br><span class="hljs-function"></span>&#123;<br>*p = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>);<br>strcpy_s(*p, <span class="hljs-number">12</span>,<span class="hljs-string">&quot;hello world&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, *p);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">char</span> *p = <span class="hljs-literal">NULL</span>;<br>getmemory(&amp;p);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, p);<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>待解决</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程序问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C++】C++中的四种个智能指针.md</title>
    <link href="/2019/10/08/%E3%80%90C++%E3%80%91C++%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E4%B8%AA%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/2019/10/08/%E3%80%90C++%E3%80%91C++%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E4%B8%AA%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>智能指针的出现的目的就是为了解决c++中出现异常安全资源管理问题，智能指针的实现原理是依据RAII机制(Resource Acquisition Is Initialization)，这是的智能指针本质上是一个对象，行为表现上是一个指针。</p><p>智能指针都是类模板使用时是必须指定类型参数的，如：<code>auto_ptr&lt;int&gt; ptr</code></p><h1 id="1-auto-ptr"><a href="#1-auto-ptr" class="headerlink" title="1.auto_ptr"></a>1.auto_ptr</h1><ul><li>auto_ptr采用所有权的模式，指针内不做引用计数，因此一个对象只能由一个auto_ptr指针所拥有，在给其他auto_ptr指针赋值时，所有权会转移</li><li>auto_ptr中使用delete来释放资源，所以auto_ptr不能指向数组，因为数组的释放使用的是delete[]</li><li>auto_ptr指针的判空使用auto_ptr.get()==NULL来判断</li></ul><p>auto_ptr是C++98中的标准，在C++11中已经被弃用。</p><p>auto_ptr由于是所有权模式，所在在auto_ptr做参数时，会转移所有权，即将函数外的auto_ptr的所有权转义给函数内的auto_ptr的所有权，如果函数内不做所有权转移的话，函数外的auto_ptr将变为空指针，而导致引用出错。如：</p><p><strong>不转移所有权</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test</span><span class="hljs-params">(<span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; apt)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; *apt &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> apt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function"><span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">1</span>))</span></span>;<br>Test(ptr);<br><span class="hljs-keyword">if</span> (ptr.get() == <span class="hljs-literal">NULL</span>)<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;NULL&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;NO NULL&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">1</span><br><span class="hljs-literal">NULL</span><br></code></pre></td></tr></table></figure><p><strong>转移所有权</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">Test</span><span class="hljs-params">(<span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; apt)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; *apt &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> apt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function"><span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">1</span>))</span></span>;<br>ptr = Test(ptr);<br><span class="hljs-keyword">if</span> (ptr.get() == <span class="hljs-literal">NULL</span>)<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;NULL&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;NO NULL&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">1</span><br><span class="hljs-literal">NO</span> <span class="hljs-literal">NULL</span><br></code></pre></td></tr></table></figure><h1 id="2-unique-ptr"><a href="#2-unique-ptr" class="headerlink" title="2.unique_ptr"></a>2.unique_ptr</h1><ul><li><p>unique_ptr是C++11中对C++98中的auto_ptr的替换与强化</p></li><li><p>unique_ptr也是使用独占所有权模式，即一个unique_ptr指针指向一个对象后，不可以在把这个对象赋予给另一个unique_ptr指针，后来出于一些考虑C++又提供了srd::move()函数来做所有权的移交，被移交所有权的unique_ptr指针会指向空，这时再使用这个指针就会报错</p></li><li><p>unique_ptr指针支持直接使用对用判空，如：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; ptr;<br><span class="hljs-keyword">if</span>(ptr == <span class="hljs-literal">NULL</span>)<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;NULL&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure><p>当然unique_ptr依旧支持unique_ptr.get()==NULL来判空。</p><ul><li>当unique_ptr作为实参进行传递时，必须使用std::move()来移交所有权，这是unique_ptr的独占所有权性质决定的。如：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test</span><span class="hljs-params">(<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; apt)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; *apt &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function"><span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">1</span>))</span></span>;<br><span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; pt = move(ptr);<br>Test(<span class="hljs-built_in">std</span>::move(ptr));<br><span class="hljs-keyword">if</span> (ptr == <span class="hljs-literal">NULL</span>)<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;NULL&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;NO NULL&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-shared-ptr"><a href="#3-shared-ptr" class="headerlink" title="3.shared_ptr"></a>3.shared_ptr</h1><ul><li><p>shared_ptr指针支持一个对象被多个指针指向</p></li><li><p>shared_ptr使用计数机制来记录对象被多少个shared_ptr指针所指向，可以使用share_ptr.reset()函数来释放当前指针，对象的引用技术减一，当引用计数减为0时，释放对象资源</p></li><li><p>可以使用shared_ptr.use_count()来获取当前对象的引用计数</p></li></ul><p>我们来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test</span><span class="hljs-params">(<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; ptr)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;count_1:&quot;</span>&lt;&lt; ptr.use_count() &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">1</span>))</span></span>;<br><span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; pt = ptr;<br>Test(ptr);<br>pt.reset();<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;count_2:&quot;</span>&lt;&lt; ptr.use_count() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">if</span> (ptr == <span class="hljs-literal">NULL</span>)<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;NULL&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;NO NULL&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">count_1:3</span><br><span class="hljs-string">count_2:1</span><br><span class="hljs-literal">NO</span> <span class="hljs-literal">NULL</span><br></code></pre></td></tr></table></figure><p>咦！为什么引用计数count_1是3呢？这是因为在函数内形参<code>shared_ptr&lt;int&gt; ptr</code>也指向了同一个对象。而当函数Test结束形参指针释放，同时又使用reset()函数释放pt指针，所以count_2:1</p><h1 id="4-weak-ptr"><a href="#4-weak-ptr" class="headerlink" title="4.weak_ptr"></a>4.weak_ptr</h1><p>虽然shared_ptr使用起来更接近C的原生指针，但是当shared_ptr指针作为类成员时，可能会出现互相引用的而形成死锁，导致引用计数永远无法将为0的现象，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">shared_ptr</span>&lt;B&gt; pa;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">shared_ptr</span>&lt;A&gt; pb;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;A&gt; <span class="hljs-title">pa</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br><span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;B&gt; <span class="hljs-title">pb</span><span class="hljs-params">(<span class="hljs-keyword">new</span> B())</span></span>;<br>pa-&gt;pa = pb;<br>pb-&gt;pb = pa;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种情况是，pa是指向A类型的shared_ptr指针指向A类型对象，而pa指向的内存里面又有一个shared_ptr指针指向B类型对象，同理pb也是如此，这样就导致，当A要被释放时，要先释放B，而B要释放时又要先释放A，如此便形成了一个互相等待的死循环。weak_ptr的存在就是为了解决这种问题。</p><p>weak_ptr指针是一种若引用，它指向对象和释放时不会引起引用计数的变化，这样既可以打破shared_ptr的这种死循环了，我们将上面的代码改成如下，就可以解死循环了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>weak_ptr&lt;B&gt; pa;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">shared_ptr</span>&lt;A&gt; pb;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;A&gt; <span class="hljs-title">pa</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br><span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;B&gt; <span class="hljs-title">pb</span><span class="hljs-params">(<span class="hljs-keyword">new</span> B())</span></span>;<br>pa-&gt;pa = pb;<br>pb-&gt;pb = pa;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法】一些牛逼轰轰的算法记录</title>
    <link href="/2019/10/08/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%B8%80%E4%BA%9B%E7%89%9B%E9%80%BC%E8%BD%B0%E8%BD%B0%E7%9A%84%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/"/>
    <url>/2019/10/08/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%B8%80%E4%BA%9B%E7%89%9B%E9%80%BC%E8%BD%B0%E8%BD%B0%E7%9A%84%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="1-判断点是否在三角形内"><a href="#1-判断点是否在三角形内" class="headerlink" title="1.判断点是否在三角形内"></a>1.判断点是否在三角形内</h1><h2 id="衍生：快速计算三角形面积"><a href="#衍生：快速计算三角形面积" class="headerlink" title="衍生：快速计算三角形面积"></a>衍生：快速计算三角形面积</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> S_FLOAT 0.00000001</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-comment">//点类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">float</span> x;<br><span class="hljs-keyword">float</span> y;<br>Point() &#123;&#125;<br>Point(<span class="hljs-keyword">float</span> x,<span class="hljs-keyword">float</span> y)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;x = x;<br><span class="hljs-keyword">this</span>-&gt;y = y;<br>&#125;<br>&#125;;<br><span class="hljs-comment">//计算三角形面积</span><br><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetTriangleSquar</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Point a, <span class="hljs-keyword">const</span> Point b, <span class="hljs-keyword">const</span> Point c)</span></span><br><span class="hljs-function"></span>&#123;<br>Point AB, BC;<br>AB.x = b.x - a.x;<br>AB.y = b.y - a.y;<br>BC.x = c.x - b.x;<br>BC.y = c.y - b.y;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">fabs</span>(AB.x*BC.y - AB.y*BC.x) / <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">//判断点是否在三角形内</span><br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">IsInTriang</span><span class="hljs-params">(Point a, Point b, Point c, Point d)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">float</span> Sabc, Sabd, Sacd, Sbcd;<br>Sabc = GetTriangleSquar(a, b, c);<br>Sabd = GetTriangleSquar(a, b, d);<br>Sacd = GetTriangleSquar(a, c, d);<br>Sbcd = GetTriangleSquar(b, c, d);<br><span class="hljs-keyword">float</span> Sums = Sabd + Sacd + Sbcd;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Sabd:&quot;</span> &lt;&lt; Sabd &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; <span class="hljs-string">&quot;Sacd:&quot;</span> &lt;&lt; Sacd &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; <span class="hljs-string">&quot;Sbcd:&quot;</span> &lt;&lt; Sbcd &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt; <span class="hljs-string">&quot;Sabc:&quot;</span>&lt;&lt;Sabc&lt;&lt;<span class="hljs-built_in">endl</span>&lt;&lt;<span class="hljs-string">&quot;Sums:&quot;</span>&lt;&lt;Sums &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">if</span> ((-S_FLOAT &lt; (Sabc - Sums) &amp;&amp; (Sabc - Sums) &lt; S_FLOAT))<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Yes&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;No&quot;</span>;<br>&#125;<br><span class="hljs-comment">//测试函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Point a(2, 2), b(0, 0), c(4, 0), d(2, 1);<br><span class="hljs-built_in">cout</span> &lt;&lt; IsInTriang(a, b, c, d) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Test();<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C++】C++STL标准模板库</title>
    <link href="/2019/10/06/%E3%80%90C++%E3%80%91C++STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/"/>
    <url>/2019/10/06/%E3%80%90C++%E3%80%91C++STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="一、STL的基本概念"><a href="#一、STL的基本概念" class="headerlink" title="一、STL的基本概念"></a>一、STL的基本概念</h1><h2 id="1-什么是STL"><a href="#1-什么是STL" class="headerlink" title="1.什么是STL"></a>1.什么是STL</h2><p> STL (Standard Template Librany）标准准模板庠是惠普实验室开发的一系列软件的统称。现在主要出现在C++中，但在被引入C++之前该技木就已存在了很长一段吋间了。</p><p>STL的从广义上讲分为三类: algorithm (算法)、container (容器)和iterator (迭代器)，容器和算法通过迭代器可以进行无缝链接。几乎所有的代码都釆用了模板类和模板函数的方式,这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。在C++标准中，STL 被组织为下面的13个尖文件:<code>&lt;algorithm&gt;</code>、<code>&lt;deque&gt;</code>、<code>&lt;functional&gt;</code>、<code>&lt;iterator&gt;</code>、<code>&lt;vector&gt;</code>、<code>&lt;list&gt;</code>、 <code>&lt;map&gt;</code>、<code>&lt;memory&gt;</code>、<code>&lt;numerio&gt;</code>、<code>&lt;queue&gt;</code>、<code>&lt;set&gt;</code>、    <code>&lt;stack&gt;</code> 和<code>&lt;utility&gt;</code>。</p><p><img src="/2019/10/06/%E3%80%90C++%E3%80%91C++STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/Snipaste_2019-10-06_10-41-56.png"></p><p>我们详细的说六大组件：</p><ul><li>容器(Container)</li><li>算法(Algorithm)</li><li>迭代器(Iterator)</li><li>仿函数(Function object)</li><li>适配器(Adaptor)</li><li>空间配置器(allocator)</li></ul><h2 id="2-STL的好处"><a href="#2-STL的好处" class="headerlink" title="2.STL的好处"></a>2.STL的好处</h2><ul><li><p>STL是C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。</p></li><li><p>STL的一个重要特点是数据结构和算法的分离。尽管这是个简单的概念，但是这种分离确实使得STL变得非常通用。<br>例如，在STL 的vector容器中，可以放入元素、 基础数据类型变量、元素的地址;<br>STL的sort()函数可以用来操作vector,list等容器。</p></li><li><p>程序员可以不用思考STL具体的实现过程，只要能够熟综使用STL就OK了。这样他们就可以把精力放在程序开发的别的方面。</p></li><li><p>STL 具有高可重用性，高性能，高移植性，跨平台的优点。</p><p>  高可重用性: STL 中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。关于模板的知识，已经给大家介绍了。</p><p>高性能:如map可以高效地从十万条记录里面查找出指定的记录，因为map是采用红黑树的变体实现的。</p><p>高移植性:如在项目A上用STL编写的模块，可以直接移植到项目B上。</p><p>跨平台:如用windows的Visual Studio编写的代码可以在Mac OS的XCode上直接运行。</p></li><li><p>了解到STL的这些好处，我们知道STL无疑是最值得C++程序员骄傲的一部分。每一个C++程序员都应该好好学习STL.只有能够熟练使用STL的程序员，才是好的C++程序员。</p></li></ul><h1 id="二、容器"><a href="#二、容器" class="headerlink" title="二、容器"></a>二、容器</h1><h2 id="1-容器"><a href="#1-容器" class="headerlink" title="1.容器"></a>1.容器</h2><p>  在实际的开发过程中，数据结构本身的重要性不会逊于操作于数据结构的算法的重要性，当程序中存在着对时间要求很高的部分时，数据结构的选择就显得更加重要。</p><p>  经典的数据结构数量有限，但是我们常常重复着一些为了实现向量、链表等结构而编写的代码，这些代码都十分相似，只是为了适应不同数据的变化而在细节上有所出入。STL容器就为我们提供了这样的方便，它允许我们重复利用己有的实现构造自己的特定类型下的数据结构，通过设置-些模板，STL 容器对最常用的数据结构提供了支持，这些模板的参数允许我们指定容器中元素的数据类型，可以将我们许多重复而乏味的工作简化。</p><p>​    容器部分主要由头文件<code>&lt;vector&gt;</code>, <code>&lt;list&gt;</code>, <code>&lt;deque&gt;</code>, <code>&lt;set&gt;</code>, <code>&lt;map&gt;</code>, <code>&lt;stack&gt;</code>和<code>&lt;queue&gt;</code>组成。对于常用的一些容器和容器适配器(可以看作由其它容器实现的容器)，可以通过下表总结一:下它们和相应头文件的对应关系。</p><p><img src="/2019/10/06/%E3%80%90C++%E3%80%91C++STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/Snipaste_2019-10-06_10-41-56.png"></p><h2 id="2-容器的分类"><a href="#2-容器的分类" class="headerlink" title="2.容器的分类"></a>2.容器的分类</h2><h3 id="序列式容器-Sequence-containers"><a href="#序列式容器-Sequence-containers" class="headerlink" title="序列式容器(Sequence containers)"></a>序列式容器(Sequence containers)</h3><p>每个元素都有固定位置–取决于插入时机和地点，和元素值无关。如：vector、deque、 Iist。</p><h3 id="关联式容器-Associated-containers"><a href="#关联式容器-Associated-containers" class="headerlink" title="关联式容器(Associated containers)"></a>关联式容器(Associated containers)</h3><p>元素位置取决于特定的排序准则，和插入顺序无关。如：sset、multiset、 map、multimapu。</p><p><img src="/2019/10/06/%E3%80%90C++%E3%80%91C++STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/Snipaste_2019-10-06_14-36-13.png"></p><h2 id="3-string类"><a href="#3-string类" class="headerlink" title="3.string类"></a>3.string类</h2><h3 id="string类的本质"><a href="#string类的本质" class="headerlink" title="string类的本质"></a>string类的本质</h3><p><code>string</code>类本质上其实就是<code>char*</code>的容器，是<code>cahr*</code>的封装。</p><h3 id="string类的遍历"><a href="#string类的遍历" class="headerlink" title="string类的遍历"></a>string类的遍历</h3><p><strong>使用[]遍历：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;string_str&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length(); i++)<br><span class="hljs-built_in">cout</span> &lt;&lt; str[i];<br></code></pre></td></tr></table></figure><p><strong>使用迭代器遍历：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;string_str&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">string</span>::iteratori=str.begin();i&lt;str.end();i++)<br><span class="hljs-built_in">cout</span> &lt;&lt;*i;<br></code></pre></td></tr></table></figure><p><font color="red"> 注意这里的<code>i</code>是一个指向string::iterator类型的指针。</font></p><p><strong>使用at()遍历：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;string_str&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length(); i++)<br><span class="hljs-built_in">cout</span> &lt;&lt; str.at(i);<br></code></pre></td></tr></table></figure><p><code>at()</code>与<code>[]</code>不同的是，当访问发生越界等错误时，<code>at()</code>会自动抛出异常，而<code>[]</code>不会抛出异常而中断程序。</p><h3 id="string解封成char"><a href="#string解封成char" class="headerlink" title="string解封成char*"></a>string解封成char*</h3><p>C++为string类提供了一个专门的函数<font color="red"> <strong>str.c_str()</strong></font>，str是string类型的对象，但是需要注意的是<code>str.c_str()</code>返回的是一个<font color="red"> *<em>const char**</em></font>，不能再被赋值给其他的变量，但是我们可以直接将<code>str.c_str()</code>当作<code>char*</code>来使用，如：<code>str.c_str()[1]</code>，即通过<code>char*</code>指针访问str中的第二个元素。</p><h3 id="string类中一些常用函数"><a href="#string类中一些常用函数" class="headerlink" title="string类中一些常用函数"></a>string类中一些常用函数</h3><table><thead><tr><th></th><th>函数名</th><th>作用</th></tr></thead><tbody><tr><td>复制</td><td>str.copy(char *buf,int cout)</td><td>从字符串str中拷贝cout个字符到char数组buf中</td></tr><tr><td>连接</td><td>str.append(string strs)</td><td>将字符串strs连接到str之后，支持string和char*</td></tr><tr><td>查找</td><td>int str.find(char *strs,int index)</td><td>从字符串str中的第index索引开始查找strs子串或字符，返回查找到的第一个匹配值的索引，返回的索引也可以使用迭代器来接收</td></tr><tr><td>替换</td><td>str.replace(int index,int length,char *strs)</td><td>在字符串str中，从index索引开始用strs字符串替换length个长度的子串</td></tr><tr><td>删除</td><td>str.erase(int index,int length)</td><td>删除字符出str从index位置开始的length长度的字符</td></tr><tr><td>插入</td><td>str.insert(int index,char *strs)</td><td>从str字符串的index位置开始插入字串strs</td></tr></tbody></table><h3 id="string类中常用算法函数"><a href="#string类中常用算法函数" class="headerlink" title="string类中常用算法函数"></a>string类中常用算法函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;string_str_io_stdsfx.h_iostream&quot;</span>;<br>transform(str.begin(), str.end(), str.begin(), <span class="hljs-built_in">toupper</span>);<br><span class="hljs-built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure><p>transform算法包含在<code>#include &lt;algorithm&gt;</code>头文件中</p><p><strong>transform算法的使用：</strong></p><p><strong>原型：</strong>transform(first,last,result,op);</p><p>first是容器的首迭代器，last为容器的末迭代器，result为存放结果的容器，op为要进行操作的一元函数对象或sturct、class。</p><p><strong>代码解释：</strong>str.begin()返回一个指向str首部位置的迭代器，str.end()返回一个指向str尾部位置的迭代器，因为我们把输出结果继续存放在str中，且迭代器始于容器相联系的，所以存放结果的容器也是str.begin()，而我们对str做的操作是将小写字母装换为大写，C++提供了标准的转换函数,所以操作函数为toupper。</p><p><strong>transform算法的另一个重载形式：</strong></p><p><strong>原型：</strong>transform(first1,last1,first2,result,binary_op);</p><p>first1是第一个容器的首迭代 器，last1为第一个容器的末迭代器，first2为第二个容器的首迭代器，result为存放结果的容器，binary_op为要进行操作的二元函数 对象或sturct、class。</p><p>需要注意的是，两个容器first1和first2中的元素数量必须相等，否则会抛异常。</p><h2 id="4-vector容器"><a href="#4-vector容器" class="headerlink" title="4.vector容器"></a>4.vector容器</h2><ul><li>vector是将元素置于一个<font color="red"> <strong>动态数组</strong></font>中加以管理的容器</li><li>vector支持随机存取元素，支持索引存取（[],at()）和迭代器存取</li><li>vector在尾部添加和移除元素速度快，在中部和头部速度慢</li><li>使用vector容易需要包含<code>#include&lt;vector&gt;</code>头文件</li></ul><h3 id="vector常用方法"><a href="#vector常用方法" class="headerlink" title="vector常用方法"></a>vector常用方法</h3><table>  <tr>    <th> </th>    <th>函数</th>    <th>作用</th>  </tr>  <tr>    <td rowspan="4">读取与赋值</td>    <td>front(void)</td>    <td>获取容器首元素，既可以作左值也可以作右值</td>  </tr>  <tr>    <td>back(void)</td>    <td>获取容器尾元素，既可以作左值也可以作右值</td>  </tr>  <tr>    <td>push_back(T t)</td>    <td>在容器的尾部添加元素</td>  </tr>  <tr>    <td>pop_back(T t)</td>    <td>删除容器最后一个元素</td>   </tr>  <tr>    <td rowspan="4">只读</td>    <td>begin(void)</td>    <td>获取容器首部迭代器</td>   </tr>  <tr>    <td>end(void)</td>    <td>获取容器尾部迭代器</td>   </tr>  <tr>    <td>rbegin(void)</td>    <td>获取逆序首部迭代器，实际指向容器的尾部，只能使用vector&#60int&#62::reverse_iterator逆序迭代器接收</td>   </tr>  <tr>    <td>rend(void)</td>    <td>获取逆序尾部部迭代器，实际指向容器的首部，只能使用vector&#60int&#62::reverse_iterator逆序迭代器接收</td>   </tr>  <tr>    <td rowspan="2">删除</td>    <td>erase(iterator pos)</td>    <td>删除迭代器pos指向位置的元素</td>   </tr>  <tr>    <td>erase(iterator begin,iterator end)</td>    <td>从迭代器begin指向位置开始到end指向位置结束，区间删除元素</td>   </tr>  <tr>    <td>插入</td>    <td>insert(iterator pos,T t)</td>    <td>在pos迭代器指向的位置插入元素t，insert中的迭代器pos只能是begin()或end()否则会报错，似乎不止其他的迭代器</td>   </tr>    <td>判空</td>    <td>empty(void)</td>    <td>容器判空</td>   </table><h2 id="5-deque容器"><a href="#5-deque容器" class="headerlink" title="5.deque容器"></a>5.deque容器</h2><ul><li>deque容器是一个双端数组，在双端数组的两端均可以插入和删除元素</li><li>使用deque容器需要包头文件<code>#include&lt;deque&gt;</code></li></ul><p>deque容器可以说是vector容器的升级版，deque的用法基本和vector一致，但是deque不仅提供push_back()，pop_back()还提供<font color="red"> <strong>push_front()</strong></font> 和<font color="red"> <strong>pop_front()</strong></font>。</p><h2 id="6-stack容器"><a href="#6-stack容器" class="headerlink" title="6.stack容器"></a>6.stack容器</h2><ul><li>stack容器是一个栈模型</li><li>使用stack容器需要包含头文件<code>#include&lt;stack&gt;</code></li></ul><h3 id="stack常用方法"><a href="#stack常用方法" class="headerlink" title="stack常用方法"></a>stack常用方法</h3><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>push(T t)</td><td>元素入栈顶</td></tr><tr><td>pop()</td><td>栈顶元素出栈</td></tr><tr><td>top()</td><td>获取栈顶元素</td></tr></tbody></table><h2 id="7-queue容器"><a href="#7-queue容器" class="headerlink" title="7.queue容器"></a>7.queue容器</h2><ul><li>queue容器是一个队列模型</li><li>使用queue容器需要包含头文件<code>#include&lt;queue&gt;</code></li></ul><h3 id="queue常用方法"><a href="#queue常用方法" class="headerlink" title="queue常用方法"></a>queue常用方法</h3><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>push(T t)</td><td>元素入队尾</td></tr><tr><td>pop()</td><td>队首元素出队</td></tr><tr><td>front()</td><td>获取队首元素，既可以作左值也可以作右值</td></tr><tr><td>back()</td><td>获取队尾元素，既可以作左值也可以作右值</td></tr></tbody></table><h2 id="8-list容器"><a href="#8-list容器" class="headerlink" title="8.list容器"></a>8.list容器</h2><ul><li>list容器是一个双向链表模型，可以高效的进行元素的插入和删除操作</li><li>list容器不支持随机访问，即不支持[],at()和iterator + n(如：begin()+1)等形式的访问</li><li>使用list容器需要包含头文件<code>#include&lt;list&gt;</code></li></ul><p>list容器除了不支持随机访问外，用法和deque容器的用法基本一致，除此之外list容器还提供一个<font color="red"> <strong>remove(T t)</strong></font>函数来根据元素内容删除元素</p><p>使用list容器时有一点需要注意<font color="red"> <strong>list容器在使用erase删除元素时，遵循左闭右开的原则</strong></font>，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; li;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>li.push_back(i);<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it = li.begin(); it != li.end(); it++)<br><span class="hljs-built_in">cout</span> &lt;&lt; *it;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it1 = li.begin();<span class="hljs-comment">//it1指向元素0</span><br><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it2 = li.begin();<br>it2++; it2++; it2++;<span class="hljs-comment">//此时it2指向元素3</span><br>li.erase(it1, it2);<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it = li.begin(); it != li.end(); it++)<br><span class="hljs-built_in">cout</span> &lt;&lt; *it;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">01234<br>34<br></code></pre></td></tr></table></figure><p>可以看到erase在删除0-3的元素时删除了0，1，2而没有删除3，即左闭右开。</p><h2 id="9-priority-queue容器"><a href="#9-priority-queue容器" class="headerlink" title="9.priority_queue容器"></a>9.priority_queue容器</h2><ul><li><p><code>priority_queue</code>容器是一个具有优先级的队列，又叫优先级队列适配器，分为最大优先级队列和最小优先级队列两种</p></li><li><p>priority_queue容器是一种特殊的queue容器，所以也需要包含头文件<code>#include&lt;queue&gt;</code></p></li></ul><p>默认的定义<code>priority_queue&lt;T&gt; pr</code>的优先级队列是最大优先级队列，显示定义最大优先级队列：<code>priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt; pr</code>，<code>less</code>是一个谓词后面再学习，显示定义最小优先级队列：<code>priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; pr</code>，其中使用<code>greater</code>需要包含头文件<code>#include&lt;functional&gt;</code>。</p><p><code>priority_queue</code>容器的用法基本和<code>queue</code>一致，除此之外，<code>priority_queue</code>容器提供一个<code>top()</code>函数来获取队首元素，而<code>queue</code>容器没有这个方法。</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;,greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; pr;<br>pr.push(<span class="hljs-number">12</span>);<br>pr.push(<span class="hljs-number">4</span>);<br>pr.push(<span class="hljs-number">10</span>);<br>pr.push(<span class="hljs-number">20</span>);<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;最小元素：&quot;</span> &lt;&lt;pr.top() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">while</span> (pr.size() &gt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; pr.top() &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>;<br>pr.pop();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">最小元素：<span class="hljs-number">4</span><br><span class="hljs-number">4,10,12,20</span>,<br></code></pre></td></tr></table></figure><h2 id="10-set容器"><a href="#10-set容器" class="headerlink" title="10.set容器"></a>10.set容器</h2><ul><li><code>set</code>是一个<font color="red"><strong>集合</strong></font>容器，其中所包含的元素是<font color="red"><strong>唯一</strong></font>的，<font color="red"><strong>集合中的元素按一定的顺序排序</strong></font>，元素的插入过程是按排序规则插入，所以不能指定位置插入</li><li><code>set</code>采用红黑树变体的数据结构实现，红黑树属于平衡二叉树，在插入和删除操作上比<code>vector</code>容器速度更快</li><li><code>set</code>容器不支持[]和at()来存取元素</li><li><font color="red"><strong>set不支持直接修改容器中的元素</strong></font>，因为元素是自动排序的，如果希望修改一个元素值，就必须删除这个元素再插入新元素</li><li>要使用<code>set</code>容器需要包含头文件<code>#include&lt;set&gt;</code></li></ul><h3 id="set容器的基本特性"><a href="#set容器的基本特性" class="headerlink" title="set容器的基本特性"></a>set容器的基本特性</h3><p>默认情况下，直接定义的set容器采用最小优先排序，和priority_queue容器恰好相反，<code>set&lt;T&gt; se</code>就是隐式的<code>set&lt;T,less&lt;T&gt;&gt; se</code>，定义最大优先排序的set容器需要显示定义：<code>set&lt;T,greater&lt;T&gt;&gt; se</code>。</p><p>我们来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">string</span>,greater&lt;<span class="hljs-built_in">string</span>&gt;&gt; se;<span class="hljs-comment">//采用最大优先排序</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<span class="hljs-comment">//生成随机字符串元素</span><br>&#123;<br><span class="hljs-keyword">int</span> tmp = rand();<br><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">while</span> (str.length()&lt;=<span class="hljs-number">3</span>)<br>&#123;<br><span class="hljs-keyword">if</span>(tmp &gt;= <span class="hljs-number">97</span> &amp;&amp; tmp &lt;= <span class="hljs-number">122</span>)<br>str += tmp;<br>tmp = rand();<br>&#125;<br>se.insert(str);<br>&#125;<br>se.insert(<span class="hljs-string">&quot;strs&quot;</span>);<span class="hljs-comment">//插入相同的字符串元素</span><br>se.insert(<span class="hljs-string">&quot;strs&quot;</span>);<br>se.insert(<span class="hljs-string">&quot;strs&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">string</span>, greater&lt;<span class="hljs-built_in">string</span>&gt;&gt;::iterator it = se.begin(); it != se.end(); it++)<br><span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">wqye</span><br><span class="hljs-symbol">vfep</span><br><span class="hljs-symbol">strs</span><br><span class="hljs-symbol">omsk</span><br><span class="hljs-symbol">kfnm</span><br><span class="hljs-symbol">cdsb</span><br></code></pre></td></tr></table></figure><p>可以看到，容器里的字符串确实按照字符串的比较规则按从大到小的顺序排列着，并且无论我们插入多少个相同的元素，在容器内只会存储一个相同的元素值。</p><p>值得注意的是：</p><p><code>set</code>容器只提供了<code>insert(T t)</code>函数来插入元素。</p><h3 id="自定义元素的排序"><a href="#自定义元素的排序" class="headerlink" title="自定义元素的排序"></a>自定义元素的排序</h3><p>自定义类作元素可能会出现类中有多个字段，而我们需要其中的某一个字段来作为关键字在<code>set</code>容器中排序，要实现这样的行为，我们就需要用到<font color="red"><strong>仿函数</strong></font>了。</p><h4 id="什么是仿函数？"><a href="#什么是仿函数？" class="headerlink" title="什么是仿函数？"></a>什么是仿函数？</h4><p>仿函数实质上就是一个做了<code>()</code>重载的结构体，因为重载了<code>()</code>使用起来类似函数，所以称之为仿函数。</p><p>我们来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">string</span> name;<br><span class="hljs-keyword">int</span> age;<br><span class="hljs-keyword">bool</span> isStudent;<br>Student(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> name, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> age, <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> isStudent)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;age = age;<br><span class="hljs-keyword">this</span>-&gt;name = name;<br><span class="hljs-keyword">this</span>-&gt;isStudent = isStudent;<br>&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AgeSort</span>//仿函数</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Student &amp;lift, <span class="hljs-keyword">const</span> Student &amp;right)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> (lift.age &lt; right.age);<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">set</span>&lt;Student, AgeSort&gt; se;<br><span class="hljs-function">Student <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;Alian&quot;</span>, <span class="hljs-number">23</span>, <span class="hljs-literal">true</span>)</span></span>;<br><span class="hljs-function">Student <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-string">&quot;Blank&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-literal">true</span>)</span></span>;<br><span class="hljs-function">Student <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-string">&quot;Cary&quot;</span>, <span class="hljs-number">43</span>, <span class="hljs-literal">false</span>)</span></span>;<br><span class="hljs-function">Student <span class="hljs-title">s4</span><span class="hljs-params">(<span class="hljs-string">&quot;Davel&quot;</span>, <span class="hljs-number">23</span>, <span class="hljs-literal">true</span>)</span></span>;<br>se.insert(s1); se.insert(s2);<br>se.insert(s3); se.insert(s4);<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">set</span>&lt;Student, AgeSort&gt;::iterator it = se.begin(); it != se.end(); it++)<br><span class="hljs-built_in">cout</span> &lt;&lt; it-&gt;name &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; it-&gt;age &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; it-&gt;isStudent &lt;&lt; <span class="hljs-built_in">endl</span>;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Blank</span>   <span class="hljs-number">20</span>      <span class="hljs-number">1</span><br><span class="hljs-attribute">Alian</span>   <span class="hljs-number">23</span>      <span class="hljs-number">1</span><br><span class="hljs-attribute">Cary</span>    <span class="hljs-number">43</span>      <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>其中<code>AgeSort</code>就是仿函数，它的比较关键字是<code>Student.age</code>，所以<code>set</code>容器对象se会以age作为排序关键字，其实我们之前使用的<code>less&lt;&gt;</code>和<code>greater&lt;&gt;</code>也是反函数，只不过是C++预定义好的仿函数。</p><p>细心的朋友可能会发现，我们插入的s4对象居然不再容器里！！！这是因为set容器中的元素具有唯一性，而set容器是通过关键字来识别元素的，所当碰到关键字相同的元素时，set只会存储一个元素。</p><p>那么这种情况该怎么解决呢？答案是set容器没有办法解决这种情况，如果有出现这种情况，就不能使用set容器而改用multiset容器。</p><p>在后面的算法模块我们详细介绍仿函数。</p><h3 id="set常用函数"><a href="#set常用函数" class="headerlink" title="set常用函数"></a>set常用函数</h3><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>find(T t)</td><td>查找元素t，返回指向t元素的迭代器，查找失败返回指向set.end()的迭代器</td></tr><tr><td>count(T t)</td><td>返回容器中元素t的个数，值要么是0，要么是1</td></tr><tr><td>lower_bound(T t)</td><td>返回一个指向&gt;=t元素的迭代器，如果t存在则指向t，如果t不存在则指向t后面的一个元素</td></tr><tr><td>upper_bound(T t)</td><td>返回一个指向&gt;t元素的迭代器，即t元素后面的一个元素</td></tr><tr><td>equal_range(T t)</td><td>返回一个包含两个set类型的迭代器的对组pair&lt;set<T>::iterator,set<T>::iterator&gt;第一个迭代器指向t元素，第二个迭代器指向t后面的一个元素，如果t不存在，则两个迭代器都指向t后面的一个元素</T></T></td></tr></tbody></table><h3 id="小知识"><a href="#小知识" class="headerlink" title=" 小知识"></a><font color="blue"> 小知识</font></h3><p><font color="blue"> 事实上容器中的<code>insert</code>函数是有返回值的，<code>insert</code>的返回值是一个对组(pair)类型的泛型<code>pair&lt;set&lt;T&gt;::iterator, bool&gt;</code>的对象，<code>pair</code>是一个只有两个字段的模板，我们可以直接定义<code>pair&lt;set&lt;T&gt;::iterator, bool&gt;</code>类型对象来接收<code>insert</code>函数的返回值，如：</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">pair</span>&lt;<span class="hljs-built_in">set</span>&lt;Student,AgeSort&gt;::iterator, <span class="hljs-keyword">bool</span>&gt; pait=se.insert(s1);<br></code></pre></td></tr></table></figure><p><font color="blue"> 我们可以通过<code>pair.first</code>和<code>pair.second</code>来访问对组中的两个元素，通过<code>pair.first</code>来访问对组中的第一个元素<code>set&lt;Student,AgeSort&gt;::iterator</code>类型的迭代器，通过<code>pair.first-&gt;first</code>，和<code>pair.first-&gt;second</code>可以访问迭代器所指向的容器元素，我们通过<code>pair.second</code>来访问对组中的第二个元素，bool型的元素记录的是insert函数插入是否成功，如果插入成功则记录true，否则记录false。</font></p><h2 id="11-multiset容器"><a href="#11-multiset容器" class="headerlink" title="11.multiset容器"></a>11.multiset容器</h2><ul><li><code>multiset</code>容器可以说是set容器的升级版，multiset容器支持多个相同键值的元素的存储，所以要使用<code>multiset</code>需要包含头文件<code>#include&lt;set&gt;</code></li></ul><p>multiset的用法和set一致。</p><h2 id="12-map容器"><a href="#12-map容器" class="headerlink" title="12.map容器"></a>12.map容器</h2><ul><li><code>map</code>是标准的关联式容器，一个<code>map</code>元素是一个键值对(key,value),<code>map</code>提供基于键值的快速检索能力</li><li><code>map</code>中<font color="red"><code> key</code>值是唯一的</font></li><li><code>map</code>容器中的元素也是按一定顺序排列的，元素插入过程是按排序规则插入的，所以不能指定位置插入</li><li><code>map</code>容器的具体实现也是采用红黑二叉树变体的平衡二叉树的数据结构，在插入和删除的操作上比<code>vector</code>更快</li><li>与<code>set</code>不同的是<code>map</code>支持直接存取<code>key</code>值对应的<code>value</code>，也支持[]操作符</li><li>要使用<code>map</code>容器就需要包含头文件<code>#include&lt;map&gt;</code></li></ul><h3 id="map的元素插入"><a href="#map的元素插入" class="headerlink" title="map的元素插入"></a>map的元素插入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>&gt; ma;<br><span class="hljs-comment">//方法一</span><br>ma.insert(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;pair&quot;</span>));<br>ma.insert(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;pair_02&quot;</span>));<br><span class="hljs-comment">//方法二</span><br>ma.insert(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;make_pair&quot;</span>));<br>ma.insert(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;make_pair_02&quot;</span>));<br><span class="hljs-comment">//方法三</span><br>ma.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>&gt;::value_type(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;value_type&quot;</span>));<br>ma.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>&gt;::value_type(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;value_type_02&quot;</span>));<br><span class="hljs-comment">//方法四</span><br>ma[<span class="hljs-number">4</span>] = <span class="hljs-string">&quot;map&quot;</span>;<br>ma[<span class="hljs-number">4</span>] = <span class="hljs-string">&quot;map_02&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>&gt;::iterator it = ma.begin(); it != ma.end(); it++)<br><span class="hljs-built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="hljs-built_in">endl</span>;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>      pair<br><span class="hljs-symbol">2 </span>      make_pair<br><span class="hljs-symbol">3 </span>      value_type<br><span class="hljs-symbol">4 </span>      map_02<br></code></pre></td></tr></table></figure><p>上面四种方法都可以向map容器里添加元素，但是四者中也有一些微小的区别，前面三种方法在插入相同键值时，只会保存第一存储的结果，之后插入相同键值的元素时都会插入失败，而第四种方法则是后面赋值的元素覆盖前面赋值的元素。</p><p>map似乎没办法来指定是从大到小排序或是从小到大排序</p><p>map除了元素的形式不同，在其他方面map的用法基本和set一致</p><h2 id="13-multimap容器"><a href="#13-multimap容器" class="headerlink" title="13.multimap容器"></a>13.multimap容器</h2><p><code>multimap</code>容器和<code>multiset</code>容器一样，是<code>map</code>容器的升级版，支持一个键对应多个值，所以<code>multimap</code>的一个重要应用场景就是数据分组。</p><h2 id="14-容器在使用过程必须要注意的地方"><a href="#14-容器在使用过程必须要注意的地方" class="headerlink" title="14.容器在使用过程必须要注意的地方"></a>14.容器在使用过程必须要注意的地方</h2><p><font color="red"> 因为在将元素添加到容器里时，C++执行的是容器的默认的拷贝构造函数，将元素拷贝到容器里，这个过程是一个浅拷贝，既然是浅拷贝就会面临浅拷贝的两次内存释放的问题，尤其是类元素，所以在添加一些具有指针字段的元素到容器里时，一定在类里定义一个深拷贝的拷贝构造函数和=的重载函数。</font></p><h2 id="15-各个容器的比较"><a href="#15-各个容器的比较" class="headerlink" title="15.各个容器的比较"></a>15.各个容器的比较</h2><table><thead><tr><th></th><th>vector</th><th>deque</th><th>list</th><th>set</th><th>multiset</th><th>map</th><th>multimap</th></tr></thead><tbody><tr><td>内存结构</td><td>单端数组</td><td>双端数组</td><td>双向链表</td><td>二叉树</td><td>二叉树</td><td>二叉树</td><td>二叉树</td></tr><tr><td>随机存取</td><td>是</td><td>是</td><td>否</td><td>否</td><td>否</td><td>对key而言是</td><td>否</td></tr><tr><td>元素检索</td><td>慢</td><td>慢</td><td>非常慢</td><td>快</td><td>快</td><td>对key而言快</td><td>对key而言快</td></tr><tr><td>快速安插移除</td><td>尾端</td><td>头尾两端</td><td>任何位置</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><h1 id="三、算法"><a href="#三、算法" class="headerlink" title="三、算法"></a>三、算法</h1><h2 id="1-算法"><a href="#1-算法" class="headerlink" title="1.算法"></a>1.算法</h2><p>​    函数库对数据类型的选择对其可重用性起着至关重要的作用。举例来说，一个求方根的函数，在使用浮点数作为其参数类型的情况下的可重用性肯定比使用整型作为它的参数类性要高。而C++通过模板的机制允许推迟对某些类型的选择，直到真正想使用模板或者说对模板进行特化的时候，STL就利用了这一点提供了相当多的有用算法。它是在一个有效的框架中完成这些算法的–可以将所有的类型划分为少数的几类，然后就可以在模版的参数中使用一种类型替换掉同一种类中的其他类型。</p><p>  STL提供了大约100个实现算法的模版函数，比如算法for_ each 将为指定序列中的每一个元素调用指定的函数，stable_ _sort 以你所指定的规则对序列进行稳定性排序等等，这样一-来,只要熟悉了STL之后，许多代码可以被大大的化简，只需要通过调用一-两个算法模板，就可以完成所需要的功能并大大地提升效率。</p><p>  算法部分主要由头文件<code>&lt;algorithm&gt;</code>, <code>&lt;numeric&gt;</code>和<code>&lt;functional&gt;</code>组成。<code>&lt;algorithm&gt;</code>是所 有STL头文件中最大的一个(尽管它很好理解)，它是由一大堆模版函数组成的，可以认为每个函数在很大程度上都是独立的，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等等。<code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。<code>&lt;functional&gt;</code>中则定义了一些模板类，用以声明函数对象。</p><h2 id="2-算法的分类"><a href="#2-算法的分类" class="headerlink" title="2.算法的分类"></a>2.算法的分类</h2><h3 id="非可变序列算法"><a href="#非可变序列算法" class="headerlink" title="非可变序列算法"></a>非可变序列算法</h3><p>计数算法：count,count_if等 </p><p>搜索算法：search,find,find_if,find_list_of等</p><p>比较算法：equal,mismatch,lexicographical_compare等</p><h3 id="可变排序算法"><a href="#可变排序算法" class="headerlink" title="可变排序算法"></a>可变排序算法</h3><p>删除算法：remove,remove_if,remove_copy等</p><p>修改算法：for_each,transform等</p><p>排序算法：sort,stable_sort,partial_sort等</p><h2 id="3-仿函数"><a href="#3-仿函数" class="headerlink" title="3.仿函数"></a>3.仿函数</h2><h2 id="4-一些常用的算法模板"><a href="#4-一些常用的算法模板" class="headerlink" title="4.一些常用的算法模板"></a>4.一些常用的算法模板</h2><h3 id="find算法"><a href="#find算法" class="headerlink" title="find算法"></a>find算法</h3><p><strong>原型:</strong><code>iterator find(iterator begin,iterator end,T t)</code></p><p>在容器的begin迭代器所指向的位置开始到end所指向的位置结束，查找元素t，如果找到了，则返回指向t的迭代器。</p><h1 id="四、迭代器"><a href="#四、迭代器" class="headerlink" title="四、迭代器"></a>四、迭代器</h1><h2 id="1-迭代器"><a href="#1-迭代器" class="headerlink" title="1.迭代器"></a>1.迭代器</h2><p>​    迭代器从作用上来说是最基本的部分，可是理解起来比前两者都要费力一些。软件设计有一个基本原则，所有的问题都可以通过引进一个间接层来简化，这种简化在 STL中就是用迭代器来完成的。概括来说，迭代器在STL中用来将算法和容器联系起来，起着一种黏和剂的作用。几乎STL提供的所有算法都是通过送代器存取元素序列进行工作的，每一个容器都定义了其本身所专有的选代器，用以存取容器中的元素。</p><p>​    迭代器部分主要由头文件<code>&lt;utility&gt;</code>,<code>&lt;iterator&gt;</code>和<code>&lt;memory&gt;</code>组成。<code>&lt;utility&gt;</code>是-一个很小的头文件，它包括了贯穿使用在STL中的几个模板的声明，<code>&lt;iterator&gt;</code>中提供 了迭代器使用的许多方法，而对于<code>&lt;memory&gt;</code>的描述则十分的困难，它以不同寻常的方式为容器中的元素分配存储空间，同时也为某些算法执行期间产生的临时对象提供机制,<code>&lt;memory&gt;</code>中的主要部分是模板类<code>alocator</code>,它负责产生所有容器中的默认分配器。</p><h2 id="2-迭代器的基本原理"><a href="#2-迭代器的基本原理" class="headerlink" title="2.迭代器的基本原理"></a>2.迭代器的基本原理</h2><ul><li><p>迭代器是一个“可遍历STL容器内全部或部分元素”的对象</p></li><li><p>迭代器指出容器中的一个特定位置</p></li><li><p>迭代器就如同一个指针</p></li><li><p>迭代器提供对一个容器中的对象的访问方法，并且可以定义了容器中对象的范围</p></li></ul><h2 id="3-迭代器的分类"><a href="#3-迭代器的分类" class="headerlink" title="3.迭代器的分类"></a>3.迭代器的分类</h2><p><strong>输入迭代器</strong>:也有叫法称之为“只读迭代器”，它从容器中读取元素，只能一次读入一个元素向前移动，只支持一遍算法，同一个输入迭代器不能两遍遍历一个序列。</p><p><strong>输出迭代器</strong>:也有叫法称之为“只写迭代器”，它往容器中写入元素，只能一次写入一个元素向前移动，只支持一遍算法，同一个输出迭代器不能两遍遍历一个序列。</p><p><strong>正向迭代器</strong>:组合输入送代器和输出迭代器的功能,还可以多次解析一个迭代器指定的位置，可以对一个值进行多次读/写。</p><p><strong>双向达代器</strong>:组合正向迭代器的功能，还可以通过-操作符向后移动位置。</p><p><strong>随机访问送代器</strong>:组合双向送代器的功能，还可以向前向后跳过任意个位置，可以直接访问容器中任何位置的元素。</p><h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C++】C++函数模板的实现机制剖析</title>
    <link href="/2019/10/03/%E3%80%90C++%E3%80%91C++%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%89%96%E6%9E%90/"/>
    <url>/2019/10/03/%E3%80%90C++%E3%80%91C++%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="函数模板的实现机制剖析"><a href="#函数模板的实现机制剖析" class="headerlink" title="函数模板的实现机制剖析"></a>函数模板的实现机制剖析</h1><p>要剖析函数模板的实现机制，我们要先了解程序的编译过程，这里以gcc为例</p><p><img src="/2019/10/03/%E3%80%90C++%E3%80%91C++%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%89%96%E6%9E%90/Snipaste_2019-10-03_16-51-51.png"></p><p>这里对下面代码进行剖析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;stdafx.h&quot;</span><span class="hljs-comment">//这是VS的固有头文件</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">(T a,T b)</span></span><br><span class="hljs-function"></span>&#123;<br>a = a + b;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;我是函数模板&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Fun(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>Fun(<span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>);<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>打开控制台，使用命令生成汇编文件(当然环境变量里需要有g++编译器的路径才能这样使用，具体操作放在文末)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">g++ -S 1.cpp -o 1.s<br></code></pre></td></tr></table></figure><p>我们来查看汇编文件</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><code class="hljs pascal">.file&quot;C++.cpp&quot;<br>.lcomm __ZStL8__ioinit,<span class="hljs-number">1</span>,<span class="hljs-number">1</span><br>.def___main;.scl<span class="hljs-number">2</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>.section .rdata,&quot;dr&quot;<br>LC2:<br>.ascii &quot;pause\0&quot;<br>.text<br>.globl_main<br>.def_main;.scl<span class="hljs-number">2</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>_main:<br>LFB1062:<br>.cfi_startproc<br>pushl%ebp<br>.cfi_def_cfa_offset <span class="hljs-number">8</span><br>.cfi_offset <span class="hljs-number">5</span>, -<span class="hljs-number">8</span><br>movl%esp, %ebp<br>.cfi_def_cfa_register <span class="hljs-number">5</span><br>andl$-<span class="hljs-number">16</span>, %esp<br>subl<span class="hljs-number">$16</span>, %esp<br>call___main<span class="hljs-comment">//--------------进入main函数</span><br>movl<span class="hljs-number">$2</span>, <span class="hljs-number">4</span>(%esp)<br>movl<span class="hljs-number">$1</span>, (%esp)<br>call__Z3FunIiEvT_S0_<span class="hljs-comment">//-----第一次调用函数模板</span><br>fldlLC0<br>fstpl<span class="hljs-number">8</span>(%esp)<br>fldlLC1<br>fstpl(%esp)<br>call__Z3FunIdEvT_S0_<span class="hljs-comment">//-----第二次调用函数模板</span><br>movl$LC2, (%esp)<br>call_system<br>movl<span class="hljs-number">$0</span>, %eax<br>leave<br>.cfi_restore <span class="hljs-number">5</span><br>.cfi_def_cfa <span class="hljs-number">4</span>, <span class="hljs-number">4</span><br>ret<br>.cfi_endproc<br>LFE1062:<br>.section .rdata,&quot;dr&quot;<br>LC4:<br>.ascii &quot;\316\322\312\307\272\257\312\375\304\243\260\345\0&quot;<br>.section.text$_Z3FunIiEvT_S0_,&quot;x&quot;<br>.linkonce discard<br>.globl__Z3FunIiEvT_S0_<br>.def__Z3FunIiEvT_S0_;.scl<span class="hljs-number">2</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>__Z3FunIiEvT_S0_:<span class="hljs-comment">//------------第一次调用时函数模板的具体实现</span><br>LFB1063:<br>.cfi_startproc<br>pushl%ebp<br>.cfi_def_cfa_offset <span class="hljs-number">8</span><br>.cfi_offset <span class="hljs-number">5</span>, -<span class="hljs-number">8</span><br>movl%esp, %ebp<br>.cfi_def_cfa_register <span class="hljs-number">5</span><br>subl<span class="hljs-number">$24</span>, %esp<br>movl<span class="hljs-number">12</span>(%ebp), %eax<br>addl%eax, <span class="hljs-number">8</span>(%ebp)<br>movl$LC4, 4(%esp)<br>movl$__ZSt4cout, (%esp)<br>call__ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc<br>movl$__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_, (%esp)<br>movl%eax, %ecx<br>call__ZNSolsEPFRSoS_E<br>subl<span class="hljs-number">$4</span>, %esp<br>nop<br>leave<br>.cfi_restore <span class="hljs-number">5</span><br>.cfi_def_cfa <span class="hljs-number">4</span>, <span class="hljs-number">4</span><br>ret<br>.cfi_endproc<br>LFE1063:<br>.section.text$_Z3FunIdEvT_S0_,&quot;x&quot;<br>.linkonce discard<br>.globl__Z3FunIdEvT_S0_<span class="hljs-comment">//-第二次调用时函数模板的具体实现</span><br>.def__Z3FunIdEvT_S0_;.scl<span class="hljs-number">2</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>__Z3FunIdEvT_S0_:<br>LFB1064:<br>.cfi_startproc<br>pushl%ebp<br>.cfi_def_cfa_offset <span class="hljs-number">8</span><br>.cfi_offset <span class="hljs-number">5</span>, -<span class="hljs-number">8</span><br>movl%esp, %ebp<br>.cfi_def_cfa_register <span class="hljs-number">5</span><br>subl<span class="hljs-number">$40</span>, %esp<br>movl<span class="hljs-number">8</span>(%ebp), %eax<br>movl%eax, -<span class="hljs-number">16</span>(%ebp)<br>movl<span class="hljs-number">12</span>(%ebp), %eax<br>movl%eax, -<span class="hljs-number">12</span>(%ebp)<br>movl<span class="hljs-number">16</span>(%ebp), %eax<br>movl%eax, -<span class="hljs-number">24</span>(%ebp)<br>movl<span class="hljs-number">20</span>(%ebp), %eax<br>movl%eax, -<span class="hljs-number">20</span>(%ebp)<br>fldl-<span class="hljs-number">16</span>(%ebp)<br>faddl-<span class="hljs-number">24</span>(%ebp)<br>fstpl-<span class="hljs-number">16</span>(%ebp)<br>movl$LC4, 4(%esp)<br>movl$__ZSt4cout, (%esp)<br>call__ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc<br>movl$__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_, (%esp)<br>movl%eax, %ecx<br>call__ZNSolsEPFRSoS_E<br>subl<span class="hljs-number">$4</span>, %esp<br>nop<br>leave<br>.cfi_restore <span class="hljs-number">5</span><br>.cfi_def_cfa <span class="hljs-number">4</span>, <span class="hljs-number">4</span><br>ret<br>.cfi_endproc<br>LFE1064:<br>.text<br>.def___tcf_0;.scl<span class="hljs-number">3</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>___tcf_0:<br>LFB1074:<br>.cfi_startproc<br>pushl%ebp<br>.cfi_def_cfa_offset <span class="hljs-number">8</span><br>.cfi_offset <span class="hljs-number">5</span>, -<span class="hljs-number">8</span><br>movl%esp, %ebp<br>.cfi_def_cfa_register <span class="hljs-number">5</span><br>subl<span class="hljs-number">$8</span>, %esp<br>movl$__ZStL8__ioinit, %ecx<br>call__ZNSt8ios_base4InitD1Ev<br>leave<br>.cfi_restore <span class="hljs-number">5</span><br>.cfi_def_cfa <span class="hljs-number">4</span>, <span class="hljs-number">4</span><br>ret<br>.cfi_endproc<br>LFE1074:<br>.def__Z41__static_initialization_and_destruction_0ii;.scl<span class="hljs-number">3</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>__Z41__static_initialization_and_destruction_0ii:<br>LFB1073:<br>.cfi_startproc<br>pushl%ebp<br>.cfi_def_cfa_offset <span class="hljs-number">8</span><br>.cfi_offset <span class="hljs-number">5</span>, -<span class="hljs-number">8</span><br>movl%esp, %ebp<br>.cfi_def_cfa_register <span class="hljs-number">5</span><br>subl<span class="hljs-number">$24</span>, %esp<br>cmpl<span class="hljs-number">$1</span>, <span class="hljs-number">8</span>(%ebp)<br>jneL8<br>cmpl<span class="hljs-number">$65535</span>, <span class="hljs-number">12</span>(%ebp)<br>jneL8<br>movl$__ZStL8__ioinit, %ecx<br>call__ZNSt8ios_base4InitC1Ev<br>movl$___tcf_0, (%esp)<br>call_atexit<br>L8:<br>nop<br>leave<br>.cfi_restore <span class="hljs-number">5</span><br>.cfi_def_cfa <span class="hljs-number">4</span>, <span class="hljs-number">4</span><br>ret<br>.cfi_endproc<br>LFE1073:<br>.def__GLOBAL__sub_I_main;.scl<span class="hljs-number">3</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>__GLOBAL__sub_I_main:<br>LFB1075:<br>.cfi_startproc<br>pushl%ebp<br>.cfi_def_cfa_offset <span class="hljs-number">8</span><br>.cfi_offset <span class="hljs-number">5</span>, -<span class="hljs-number">8</span><br>movl%esp, %ebp<br>.cfi_def_cfa_register <span class="hljs-number">5</span><br>subl<span class="hljs-number">$24</span>, %esp<br>movl<span class="hljs-number">$65535</span>, <span class="hljs-number">4</span>(%esp)<br>movl<span class="hljs-number">$1</span>, (%esp)<br>call__Z41__static_initialization_and_destruction_0ii<br>leave<br>.cfi_restore <span class="hljs-number">5</span><br>.cfi_def_cfa <span class="hljs-number">4</span>, <span class="hljs-number">4</span><br>ret<br>.cfi_endproc<br>LFE1075:<br>.section.ctors,&quot;w&quot;<br>.align <span class="hljs-number">4</span><br>.long__GLOBAL__sub_I_main<br>.section .rdata,&quot;dr&quot;<br>.align <span class="hljs-number">8</span><br>LC0:<br>.long-<span class="hljs-number">1717986918</span><br>.long<span class="hljs-number">1070176665</span><br>.align <span class="hljs-number">8</span><br>LC1:<br>.long-<span class="hljs-number">1717986918</span><br>.long<span class="hljs-number">1069128089</span><br>.ident&quot;GCC: (i686-posix-dwarf-rev0, Built by MinGW-W64 project) 5.3.0&quot;<br>.def_system;.scl<span class="hljs-number">2</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>.def__ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc;.scl<span class="hljs-number">2</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>.def__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_;.scl<span class="hljs-number">2</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>.def__ZNSolsEPFRSoS_E;.scl<span class="hljs-number">2</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>.def__ZNSt8ios_base4InitD1Ev;.scl<span class="hljs-number">2</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>.def__ZNSt8ios_base4InitC1Ev;.scl<span class="hljs-number">2</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br>.def_atexit;.scl<span class="hljs-number">2</span>;.<span class="hljs-keyword">type</span><span class="hljs-number">32</span>;.endef<br></code></pre></td></tr></table></figure><p>可以看到，在汇编码中编译器将模板<code>void Fun(T a,T b)</code>分别针对类型<code>int</code>和类型<code>float</code>进行了两次具体实现，这不是和没有使用模板，直接写两个函数一样么？没错就是一样的，只是C++将这个工作交从程序员手里移交给了编译器来做。</p><p>事实上C++对函数模板进行了<font color="red">两次编译</font>，第一次编译仅仅生成一个函数头，第二次编译则是在函数调用时根据模板的类型参数列表具体的实现这个模板对应的类型的函数实例，注意这里是根据类型参数列表来实现，而不是根据调用次数，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">Fun(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>Fun(<span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>);<br></code></pre></td></tr></table></figure><p>编译器实现两个模板实例<code>int</code>和<code>float</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">Fun(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>Fun(<span class="hljs-number">3</span> ,<span class="hljs-number">4</span>);<br>Fun(<span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>);<br></code></pre></td></tr></table></figure><p>编译器还是实现两个模板实例<code>int</code>和<code>float</code></p><p>由此可以看出</p><p><font color="red"> 编译器并不是把函数模板处理成能够处理任意类的函数</font></p><p><font color="red">编译器将函数模板根据具体类型产生不同的函数</font></p><p><font color="red">编译器会对函数模板进行两次编译，在申明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。</font></p><p>g++命令的使用</p><p>首先电脑里要有g++这个软件，我这里使用的是Qt里集成的g++软件</p><p><img src="/2019/10/03/%E3%80%90C++%E3%80%91C++%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%89%96%E6%9E%90/Snipaste_2019-10-03_19-57-21.png"></p><p>然后右键我的电脑–&gt;属性–&gt;高级环境设置–&gt;环境变量–&gt;系统变量/Path–&gt;编辑</p><p><img src="/2019/10/03/%E3%80%90C++%E3%80%91C++%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%89%96%E6%9E%90/Snipaste_2019-10-03_20-07-41.png"></p><p>再然后新建–&gt;将g++.exe所在的路径拷贝到新建的环境变量中</p><p><img src="/2019/10/03/%E3%80%90C++%E3%80%91C++%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%89%96%E6%9E%90/Snipaste_2019-10-03_20-08-21.png"></p><p>测试一下，win+r–&gt;cmd–&gt;任意目录键入g++</p><p><img src="/2019/10/03/%E3%80%90C++%E3%80%91C++%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%89%96%E6%9E%90/Snipaste_2019-10-03_20-12-24.png"></p><p>可以看到系统没有提示无此命令，说明配置成功</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C】C的typedef的妙用</title>
    <link href="/2019/10/03/%E3%80%90C%E3%80%91C%E7%9A%84typedef%E7%9A%84%E5%A6%99%E7%94%A8/"/>
    <url>/2019/10/03/%E3%80%90C%E3%80%91C%E7%9A%84typedef%E7%9A%84%E5%A6%99%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="1-自定义数组类型"><a href="#1-自定义数组类型" class="headerlink" title="1.自定义数组类型"></a>1.自定义数组类型</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">typedef int (Array)[5];<br></code></pre></td></tr></table></figure><p><code>Array</code>是一个类型为<code>int</code>长度为5的数组类型，即定义一个<code>Array a;</code>那么a就是一个类型为int长度为5的数组，所以a的使用方法和数组一致。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">typedef int(Array)[5];<br>Array a;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>,j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>a[i] = i;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,&quot;</span>, a[j]);<br></code></pre></td></tr></table></figure><h1 id="2-自定义指向数组的指针类型"><a href="#2-自定义指向数组的指针类型" class="headerlink" title="2.自定义指向数组的指针类型"></a>2.自定义指向数组的指针类型</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">typedef char(*Arrayptr)[8];<br></code></pre></td></tr></table></figure><p><code>Arrayptr</code>是一个指向<code>char</code>类型的长度为8的数组的指针类型，此类型的指针只能指向<code>char</code>类型的长度为8的数组。且每一次指针移步，移动的距离是1*8=8字节。</p><p>需要注意的是<code>()</code>不能省略，否则定义就会变义。</p><p>除了自定义指针类型来指向一个固定的数组外，C还可以直接定义一个指向固定数组的指针变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> (*p)[<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><p><code>p</code>就是一个指向类型为整型且长度为5的数组的指针变量。</p><h1 id="3-自定义函数类型"><a href="#3-自定义函数类型" class="headerlink" title="3.自定义函数类型"></a>3.自定义函数类型</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(Funptr)</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;<span class="hljs-comment">//函数类型</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Fun1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fun2</span><span class="hljs-params">(Funptr *p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, p(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Funptr *p = &amp;Fun1;<br>Fun2(p);<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Funptr</code>是一个指向返回值为<code>int</code>参数列表为<code>int,int</code>的函数的类型，通过<code>Funptr</code>函数类型的指针可以将返回值为<code>int</code>参数列表为<code>int,int</code>的函数当作参数来使用，使函数的调用更为灵活。</p><p>除了定义函数类型可以达到这种效果，我们还可以直接定义指向函数的指针类型来实现函数参数化，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*Funptr)</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Fun1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fun2</span><span class="hljs-params">(Funptr p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, p(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Funptr p = &amp;Fun1;<br>Fun2(p);<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的效果和定义函数类型是一样的。</p><p>当然我们还可以直接定义一个指向函数的指针变量，来实现同样的效果，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Fun1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fun2</span><span class="hljs-params">(Funptr p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, p(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span>(*p)(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) = &amp;Fun1;<br>Fun2(p);<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们还可以这么做，一样能达到相同的效果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Fun1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fun2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*ptr)(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b))</span><span class="hljs-comment">//直接定义函数指针的形参</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ptr(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Fun2(&amp;Fun1);<span class="hljs-comment">//直接传递函数地址</span><br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>搞了那么多似乎函数指针只是把函数的调用弄得更复杂了而已，除了把函数当作参数来使用似乎没有什么作用了，真的是如此吗？</p><p><font color="red"> 如果我们仔细观察，会发现函数指针将函数的调用和函数的实现分隔开来了，即函数指针提前规定好了函数的实现标准，这样只要后来者按照这个标准来实现函数，可以不用修改前人的代码，就能实现函数的完美的调用，这一作用在具体的项目迭代中是及其出众的。</font></p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C++】C++面向对象模型初探</title>
    <link href="/2019/10/01/%E3%80%90C++%E3%80%91C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%88%9D%E6%8E%A2/"/>
    <url>/2019/10/01/%E3%80%90C++%E3%80%91C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%88%9D%E6%8E%A2/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="1-成员的分开存储"><a href="#1-成员的分开存储" class="headerlink" title="1.成员的分开存储"></a>1.成员的分开存储</h1><p>C++通过将类的成员分开存储的方式来实现面向对象</p><table><thead><tr><th>成员</th><th>存储位置</th></tr></thead><tbody><tr><td>普通成员变量</td><td>栈区，与struct变量有相同的内存布局和字节对齐方式</td></tr><tr><td>静态成员变量</td><td>全局数据区，如此便可以使用类名和类所有的对象都可以访问</td></tr><tr><td>成员函数</td><td>代码段，包括静态成员函数和非静态成员函数</td></tr><tr><td>虚函数</td><td>虚函数表指针(vfptr)存放在栈区，其指向的虚函数表有自身的内存存储空间</td></tr></tbody></table><h1 id="2-C-类的内存分布"><a href="#2-C-类的内存分布" class="headerlink" title="2.C++类的内存分布"></a>2.C++类的内存分布</h1><p>要想更好的了解这些，我们还需了解C++类的内存分布</p><p><img src="/2019/10/01/%E3%80%90C++%E3%80%91C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%88%9D%E6%8E%A2/Snipaste_2019-10-02_09-07-09.png"></p><h2 id="Stack："><a href="#Stack：" class="headerlink" title="Stack："></a><strong>Stack：</strong></h2><p>栈，存放Automatic Variables，按内存地址由高到低方向生长，其最大大小由编译时确定，速度快，但自由性差，最大空间不大。保存程序中的局部变量。</p><h2 id="Heap："><a href="#Heap：" class="headerlink" title="Heap："></a><strong>Heap：</strong></h2><p>堆，自由申请的空间，按内存地址由低到高方向生长，其大小由系统内存/虚拟内存上限决定，速度较慢，但自由性大，可用空间大。 动态分配的内存在调用malloc（）或者相关函数产生，在调用free()时释放，由程序员决定而不是一系列规则规定内存持续时间，因此内存块可在一个函数中创建，在另一个函数中释放。由于这点，动态内存分配容易导致堆区内存碎片化。</p><h2 id="Data："><a href="#Data：" class="headerlink" title=".Data："></a><strong>.Data：</strong></h2><p> 存放程序中<font color="red"> 已经初始化的非零全局变量。静态分配。</font></p><p>data又可分为读写（RW）区域和只读（RO）区域。 </p><ul><li>RO段保存常量所以也被称为<code>.constdata</code> eg const数据</li><li>RW段则是普通非常全局变量，静态变量就在其中</li></ul><h2 id="Bss："><a href="#Bss：" class="headerlink" title=".Bss："></a><strong>.Bss：</strong></h2><p>存放程序中<strong>未初始化</strong>的和零值全局变量。静态分配，在程序开始时通常会被清零。</p><h2 id="Text："><a href="#Text：" class="headerlink" title=".Text："></a><strong>.Text：</strong></h2><p>也称为代码段(Code)，用来存放程序执行代码，同时也可能会包含一些常量(如一些字符串常量等）。该段内存为静态分配，只读(某些架构可能允许修改)。<br>这块内存是共享的,当有多个相同进程(Process)存在时，共用同一个text段。</p><hr><p>普通成员变量存储在栈区，使得每一个类的对象都拥有各自独立的普通成员变量。</p><p>静态成员变量存储在全局数据区，是的每一个类的对象都共享一份静态</p><p>成员变量。</p><h1 id="3-this指针"><a href="#3-this指针" class="headerlink" title="3.this指针"></a>3.this指针</h1><p>那么，存放在代码段的成员函数是怎么区分调用对象的呢？</p><p>事实上，<font color="red"> C++为每一个函数都隐式定义了一个函数所属类类型的指针形参–this，而this指针永远指向调用函数的对象</font>，如此函数便可以识别调用自身的是类的哪个对象了。</p><p>这里有一点要注意，<font color="red"> C++并没有为静态成员函数定义this指针，如此，静态成员函数被所有的对象共享</font>。</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h1><p>通过成员的分开存储和普通成员函数的<code>this指针</code>C++便可以识别各个不同的对象，如此便实现了面向对象。</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【shell】shell基础</title>
    <link href="/2019/09/30/%E3%80%90shell%E3%80%91shell%E5%9F%BA%E7%A1%80/"/>
    <url>/2019/09/30/%E3%80%90shell%E3%80%91shell%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>由于本文内有大量的markdwon转义未处理，导致远程同步不通过，所以本文引入外部ULR预览</p><p><a href="https://blog.csdn.net/qq_39108291/article/details/101797244">https://blog.csdn.net/qq_39108291/article/details/101797244</a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C++】高级</title>
    <link href="/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/"/>
    <url>/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="一、类"><a href="#一、类" class="headerlink" title="一、类"></a>一、类</h1><h2 id="1-浅拷贝与深拷贝"><a href="#1-浅拷贝与深拷贝" class="headerlink" title="1.浅拷贝与深拷贝"></a>1.浅拷贝与深拷贝</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p><font color="red"> C++在进行浅拷贝时，只拷贝栈区的内存空间，不拷贝堆区的内存空间，即浅拷贝只拷贝非指针的成员变量和指针本身，而不拷贝指针所指向的堆区的内容。</font></p><p>我们代码1.1为例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//代码1.1</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Obj</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>Obj(<span class="hljs-keyword">char</span> *tp)<br>&#123;<br>len = <span class="hljs-built_in">strlen</span>(tp);<br>p = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(len + <span class="hljs-number">1</span>);<br>strcpy_s(p, len+<span class="hljs-number">1</span>, tp);<br>&#125;<br>~Obj()<br>&#123;<br><span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">free</span>(p);<br>p = <span class="hljs-literal">NULL</span>;<br>len = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; *p &lt;&lt; *(p + <span class="hljs-number">1</span>) &lt;&lt; *(p + <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">char</span> *p;<br><span class="hljs-keyword">int</span> len;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">text</span><span class="hljs-params">(Obj &amp;obj)</span></span><br><span class="hljs-function"></span>&#123;<br>Obj obj2 = obj;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Obj <span class="hljs-title">obj1</span><span class="hljs-params">(<span class="hljs-string">&quot;asd&quot;</span>)</span></span>;<br>text(obj1);<br>obj1.Show();<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们作一个图示：</p><p><img src="/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/Git\Blog\source_posts\【C++】C++高级\Snipaste_2019-10-01_16-21-15.png"></p><p>​    我们没有自定义Obj类的拷贝构造函数，所以当代码执行到<code>Obj obj2 = obj1;</code>时，编译器将调用默认的拷贝构造函数，然而，<font color="red"> 编译器默认的拷贝构造函数是一个浅拷贝</font>，所以新创建的对象obj2没有自己的堆区空间，obj2.p指向的是obj1.p所指向的内存地址。</p><p>​    上面的代码编译是通不过的，<font color="red"> 原因在于，对象析构时，同一个内存地址<code>0x0001</code>被对象obj1和obj2一起析构了两次</font>。当代码执行完<code>test(obj1)</code>时，对象obj2被析构，指针obj2.p所指向的内存地址<code>0x0001</code>被释放，所以当代码执行到<code>obj1.Show()</code>时，使用了已经被释放掉的内存<code>0x0001</code>地址，从而导致运行错误。</p><p>​    <font color="green"> <strong>这里我有一个疑问，既然浅拷贝在拷贝有指针的对象时，会出现两次析构而出错，所以浅拷贝只能拷贝没有指针成员的对象，那么浅拷贝和深拷贝似乎没有什么区别了，那么浅拷贝存在的意义是什么呢？</strong></font></p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>C++没有提供给开发者预定义的深拷贝方法，所以要想使用深拷贝，我们需要字写一个拷贝构造函数。</p><p>深拷贝可以解决上面遇到的浅拷贝的问题，因为，<font color="red"> 深拷贝会申请一新的内存空间用于存放拷贝过来的内容，即深拷贝拷贝对象的所有成员，包括指针所指向的内存空间也会一起被拷贝，被拷贝过来的指针会指向一个新的内存地址</font>。</p><p><img src="/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/Snipaste_2019-10-01_16-52-53.png"></p><h3 id="定义深拷贝构造函数"><a href="#定义深拷贝构造函数" class="headerlink" title="定义深拷贝构造函数"></a>定义深拷贝构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//代码1.2</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Obj</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>Obj(<span class="hljs-keyword">char</span> *tp)<br>&#123;<br>len = <span class="hljs-built_in">strlen</span>(tp);<br>p = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(len + <span class="hljs-number">1</span>);<br>strcpy_s(p, len+<span class="hljs-number">1</span>, tp);<br>&#125;<br>    <span class="hljs-comment">//------------------------------</span><br>    <span class="hljs-comment">//拷贝构造函数--深拷贝</span><br>Obj(<span class="hljs-keyword">const</span> Obj &amp;obj)<br>&#123;<br>len = obj.len;<br>p = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(len + <span class="hljs-number">1</span>);<br>strcpy_s(p, len + <span class="hljs-number">1</span>, obj.p);<br>&#125;<br>    <span class="hljs-comment">//------------------------------</span><br>~Obj()<br>&#123;<br><span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">free</span>(p);<br>p = <span class="hljs-literal">NULL</span>;<br>len = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; *p &lt;&lt; *(p + <span class="hljs-number">1</span>) &lt;&lt; *(p + <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">char</span> *p;<br><span class="hljs-keyword">int</span> len;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当一个类中定义了拷贝构造函数，则在对象拷贝时，编译器就不会在调用默认的拷贝构造函数转而调用自定义的拷贝构造函数，当我们把代码1.1中类的定义改为代码1.2中类的定义后，程序就可以正常执行了。</p><p><font color="red">使用深拷贝时，我们还需要注意下面的情况：</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Obj <span class="hljs-title">obj1</span><span class="hljs-params">(<span class="hljs-string">&quot;asd&quot;</span>)</span></span>;<br><span class="hljs-function">Obj <span class="hljs-title">obj3</span><span class="hljs-params">(<span class="hljs-string">&quot;fgh&quot;</span>)</span></span>;<br>obj3 = obj1;<br></code></pre></td></tr></table></figure><p>此时，在<code>obj3=obj1;</code>处依旧调用默认的拷贝构造函数，这里我们要弄清楚<code>obj3=obj1</code>和<code>Obj obj3 = obj1</code>之间的区别，<code>obj3=obj1</code>是将<font color="red">obj1赋值给obj3</font>，<code>=</code>赋值与拷贝构造函数没有什么关联，<code>=</code>在赋值时是C++编译器自己调用默认的拷贝构造函数—浅拷贝，和类中有无定义深拷贝无关；而<code>Obj obj3=obj1</code>则是<font color="red">使用obj1来构造obj3</font>，此时如果类中定义了深拷贝构造函数，就会使用深拷贝。要解决这个问题，就需要显示重载<code>=</code>运算符了。</p><h3 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a><font color="blue"><strong>小知识</strong></font></h3><ul><li><font color="blue">在定义拷贝构造函数时，必须使用引用传递，否则会出现无限拷贝的情况，因为，如果我们使用传值传递的话，在传递对象到拷贝构造函数时，又会调用拷贝构造函数将实参拷贝给形参，而这个过程又会将对象传递给拷贝构造函数，从而在此调用拷贝构造函数将实参拷贝给形参，如此无限循环</font></li><li><font color="blue">拷贝构造函数只能有一个参数，且必须是自身类的引用，否则编译器将识别被普通构造函数</font></li></ul><h2 id="2-初始化参数列表"><a href="#2-初始化参数列表" class="headerlink" title="2.初始化参数列表"></a>2.初始化参数列表</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>我们以下面的代码1.3来说明初始化参数列表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>A(<span class="hljs-keyword">int</span> a)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">int</span> a;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span> :<br>B(<span class="hljs-keyword">int</span> i)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;i = i;<br>&#125;<br><span class="hljs-keyword">int</span> i;<br>A a;<br><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">B <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">错误C2512“<span class="hljs-keyword">A</span>”: 没有合适的默认构造函数可用<br></code></pre></td></tr></table></figure><p>​    这个问题就在于，在类B中组合了一个A类的成员，编译器在构造B类对象时，同时会构造一个A类对象作为B类的成员，然而，因为A类自定义了一个有参的构造函数，所以在构造A类时，编译器不会使用默认构造函数，而是使用自定义的有参构造函数，问题就出在这里，编译器在构造A类时，没有参数传递到A类的有参构造函数中。初始化参数列表就是用于解决这种问题的。</p><p>​    需要说明的是，如果A类中没有自定义有参的构造函数，则在B类构造对象时编译器自动调用A类的默认构造函数构造A类对象成员，就不会报错。</p><p>​    初始化参数列表可以让我们在构造B类对象时，根据参数列表来构造不同的A类成员。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>初始化参数列表的使用如下面的<code>B(int i):a1(1),a2(2,&quot;asd&quot;)</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>A(<span class="hljs-keyword">int</span> a)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;构造小A&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>A(<span class="hljs-keyword">int</span> a, <span class="hljs-built_in">string</span> str)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br><span class="hljs-keyword">this</span>-&gt;str = str;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;构造大A&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>~A()<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;析构A&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">int</span> a;<br><span class="hljs-built_in">string</span> str;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span> :<br>B(<span class="hljs-keyword">int</span> i):a1(<span class="hljs-number">1</span>),a2(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;asd&quot;</span>)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;i = i;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;构造B&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>~B()<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;析构B&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-keyword">int</span> i;<br>A a1;<br>A a2;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">B <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; b.a1.str &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; b.a2.str &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>test();<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dns">构造小<span class="hljs-keyword">A</span><br>构造大<span class="hljs-keyword">A</span><br>构造B<br><br>asd<br>析构B<br>析构<span class="hljs-keyword">A</span><br>析构<span class="hljs-keyword">A</span><br></code></pre></td></tr></table></figure><p>​    值得注意的是<font color="red"> A类对象的构造顺序不是由初始化参数列表的顺序决定的，而是由对象的申明的前后顺序决定的</font>，如：<code>B(int i):a1(1),a2(2,&quot;asd&quot;)</code>和<code>B(int i):a2(2,&quot;asd&quot;),a1(1)</code>的构造顺序是一样的，但是当我们将类B中组合的A类对象的申明顺序改为如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span> :<br>B(<span class="hljs-keyword">int</span> i):a1(<span class="hljs-number">1</span>),a2(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;asd&quot;</span>)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;i = i;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;构造B&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>~B()<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;析构B&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-keyword">int</span> i;<br>A a2;<br>A a1;<br>&#125;;<br></code></pre></td></tr></table></figure><p>则构造顺序就变为“先构造a2再构造a1”了。</p><p><font color="red"> 析构的顺序和构造的顺序相反。</font></p><h3 id="小知识-1"><a href="#小知识-1" class="headerlink" title=" 小知识"></a><font color="blue"> 小知识</font></h3><ul><li><font color="blue"> 当一个类中组合了其他的类对象作为成员时，拷贝构造函数也必须使用初始化参数列表，来构造对象成员然后拷贝</font></li></ul><h2 id="3-匿名对象的生命周期"><a href="#3-匿名对象的生命周期" class="headerlink" title="3.匿名对象的生命周期"></a>3.匿名对象的生命周期</h2><h3 id="什么是匿名对象"><a href="#什么是匿名对象" class="headerlink" title="什么是匿名对象"></a>什么是匿名对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++">calss A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> a;<br>A(<span class="hljs-keyword">int</span> a)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的语句<code>A(1)</code>创建的就是一个匿名临时的对象，<font color="red"> 需要注意，如果一个类只有无参的构造函数，那么这个类将无法构建匿名对象</font>，匿名对象的生命周期就只在创建匿名对象的这条语句内，如果我们不使用一个对象来接收这个匿名对象，那么匿名对象会在语句结束时被销毁，当我们使用<code>A a = A(1);</code>不会出现匿名对象拷贝到类B对象b的情况，这种语句已经被C++优化成了类B的构造语句。说这么多其实匿名对象没什么卵用。</p><h2 id="4-new和delete"><a href="#4-new和delete" class="headerlink" title="4.new和delete"></a>4.new和delete</h2><p>1.new和delete的用法</p><p><code>new</code>可以为<strong>基础类型</strong>、<strong>数组</strong>、<strong>类</strong>分配内存空间，<code>new</code>分配的内存空间都分配在<strong>堆</strong>上。随意<code>new</code>出来的内存空间必须使用一个指针来指向，不能使用同类型的变量来接收，也禁止不接受。</p><p><strong>new 基础类型</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;<br><span class="hljs-keyword">delete</span> p;<br></code></pre></td></tr></table></figure><p><strong>new 数组</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">delete</span>[] p;<br></code></pre></td></tr></table></figure><p><strong>new 类</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//C++</span><br>A *p = <span class="hljs-keyword">new</span> A();<br><span class="hljs-keyword">delete</span> p;<br><span class="hljs-comment">//C</span><br>A *pc = (A*)<span class="hljs-built_in">malloc</span>(A);<br><span class="hljs-built_in">free</span>(pc);<br></code></pre></td></tr></table></figure><h3 id="new-delete和malloc-free的区别"><a href="#new-delete和malloc-free的区别" class="headerlink" title="new delete和malloc free的区别"></a><code>new delete</code>和<code>malloc free</code>的区别</h3><ul><li><p>在基础类型和基础类型数组方面<code>new delete</code>和<code>malloc free</code>几乎没有什么区别</p></li><li><p><code>new</code>不仅会分配内存还会调用构造函数，而<code>malloc</code>只会分配内存</p></li><li><p><code>delete</code>会调用析构函数来销毁对象，而<code>free</code>只是单纯的释放内存</p></li></ul><h3 id="小知识-2"><a href="#小知识-2" class="headerlink" title=" 小知识"></a><font color="blue"> <strong>小知识</strong></font></h3><p><font color="blue"> <code>new delete</code>和<code>malloc free</code>是可以穿插使用的，即<code>new</code>可以和<code>free</code>搭配使用，<code>malloc</code>可以和<code>delete</code>搭配使用。</font></p><h1 id="二、继承"><a href="#二、继承" class="headerlink" title="二、继承"></a>二、继承</h1><p>继承这边主要分析一下<code>虚继承</code></p><h2 id="1-虚继承"><a href="#1-虚继承" class="headerlink" title="1.虚继承"></a>1.虚继承</h2><p>虚继承的出现主要是为解决如下的继承关系中的二义性问题</p><p><img src="/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/Snipaste_2019-10-02_15-50-39.png" alt="图1"></p><p>当我们的类的继承过程中出现这种继承关系时，我们需要使类B和类C分别虚继承类A来解决二义性，具体操作如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>   <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> a;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> :</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> b;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> :</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> c;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> :</span> <span class="hljs-keyword">public</span> B,C<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> d;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    D d;<br>    d.a = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有一点要注意，虚继承的应用场景有限，虚继承只能解决这种情况：</p><p><img src="/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/Snipaste_2019-10-02_15-50-39.png"></p><p>而不能解决这种情况：</p><p><img src="/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/Snipaste_2019-10-02_16-10-55.png"></p><h2 id="2-继承中的static关键字"><a href="#2-继承中的static关键字" class="headerlink" title="2.继承中的static关键字"></a>2.继承中的static关键字</h2><p><font color="red"> 类中的静态成员变量被类的所有对象共享，同时也被类的派生类的所有对象共享。</font></p><h1 id="三、多态"><a href="#三、多态" class="headerlink" title="三、多态"></a>三、多态</h1><p>​    在C++的几个特性中，封装、继承和抽象都相对好理解，而多态则不太好理解，这里就说说C++的多态。</p><h2 id="1-多态分两种："><a href="#1-多态分两种：" class="headerlink" title="1.多态分两种："></a>1.多态分两种：</h2><p>​    静态多态：静态多态指的就是函数重载和运算符重载。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;动物&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;在叫&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> :</span> <span class="hljs-keyword">public</span> Animal<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;狗&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;在叫&quot;</span> &lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-built_in">string</span> <span class="hljs-keyword">operator</span>+(Animal animal,Dog dog)<br>&#123;<br><span class="hljs-keyword">return</span> animal.name + <span class="hljs-string">&quot;是&quot;</span> + dog.name + <span class="hljs-string">&quot;的父类&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Run</span><span class="hljs-params">(Animal animal)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; animal.name &lt;&lt;<span class="hljs-string">&quot;在跑&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Run</span><span class="hljs-params">(Dog dog)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; dog.name &lt;&lt; <span class="hljs-string">&quot;在跑&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Animal animal;<br>Dog dog;<br>Run(animal);<br>Run(dog);<br><span class="hljs-built_in">cout</span>&lt;&lt;animal+dog&lt;&lt;<span class="hljs-built_in">endl</span>;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    动态多态：动态多态则是通过继承和虚函数实现标签相同的函数因为传入不同的对象来实现不同的功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;动物&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;在叫&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> :</span> <span class="hljs-keyword">public</span> Animal<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;狗&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;在叫&quot;</span> &lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span><span class="hljs-params">(Animal *animal)</span></span><br><span class="hljs-function"></span>&#123;<br>animal-&gt;speak();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Animal animal;<br>Dog dog;<br>Speak(&amp;animal);<br>Speak(&amp;dog);<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    动态多态中只能用父类对象的指针或引用来指向子类或自身对象。</p><h2 id="2-多态的实现原理"><a href="#2-多态的实现原理" class="headerlink" title="2.多态的实现原理"></a>2.多态的实现原理</h2><p>​    C++多态的实现依赖于类的虚函数表，当一个类中定义了虚函数，那么这个类就拥有的了一个记录这个虚函数入口地址的虚函数表，子类继承父类时也会继承父类的虚函数表，当子类重写父类的虚函数时，则子类的虚函数入口地址将覆盖父类的地址，如此当子类对象调用此函数时则从子类的虚函数表中寻找入口地址，当父类的对象调用此函数时则从父类的虚函数表中寻找入口地址。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">当类生命虚函数时，编译器会在类中生成一个虚函数表<br>虚函数表是一个存储类成员函数指针的数据结构<br>虚函数表有编译器自动生成和维护<br>虚成员函数会被编译器放入虚函数表中<br>存在虚函数时，每一个对象中都会拥有一个指向虚函数表的虚函数表指针<span class="hljs-comment">(vptr)</span><br></code></pre></td></tr></table></figure><p>简单来说，多态实现的条件有三：</p><ul><li><p>要有继承</p></li><li><p>要有虚函数重写</p></li><li><p>要有父类指针(或引用)指向子类对象</p></li></ul><h2 id="3-纯虚函数和抽象类"><a href="#3-纯虚函数和抽象类" class="headerlink" title="3.纯虚函数和抽象类"></a>3.纯虚函数和抽象类</h2><p>​    纯虚函数的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>​    定义了纯虚函数的类就被成为抽象类，C++引入纯虚函数和抽象类的概念就是为了更好的使用多态，抽象类不能实例化对象，这个特性就规范了继承这个抽象类的子类必须重写父类的虚函数，因为如果继承了抽象类的子类不重写父类的虚函数，那么子类也是一个抽象类，子类便也不能实例化对象，如此便规范了多态实现，防止当子类很多时，出现某个子类在编写时忘记重写父类的虚函数，而导致这个子类没有实现多态。</p><h2 id="4-虚析构函数和纯虚析构函数"><a href="#4-虚析构函数和纯虚析构函数" class="headerlink" title="4.虚析构函数和纯虚析构函数"></a>4.虚析构函数和纯虚析构函数</h2><ul><li>虚析构函数的定义：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">virtual</span> ~Animal();<br></code></pre></td></tr></table></figure><ul><li>纯虚析构函数的定义：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">virtual</span> ~Animal() = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//纯虚析构函数必须要有申明也要有实现</span><br>Animal：：~Animal()<br>&#123;<br>    <span class="hljs-comment">//代码实现</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​    如果子类在堆区中定义了数据，那么我们使用父类指针或引用来使用多态时，父类指针或引用是无法寻找到子在堆区中的数据并释放的。C++引入虚析构函数和纯虚析构函数就是为了解决此类问题。</p><p>​    我们来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>Animal()<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;这是Animal的构造函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>~Animal()<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;这是Animal的析构函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> :</span> <span class="hljs-keyword">public</span> Animal<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> *p;<br>Dog()<br>&#123;<br>p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;这是Dog的构造函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>~Dog()<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;这是Dog的析构函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;释放堆区的p&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">delete</span> p;<br>p = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Animal *animal = <span class="hljs-keyword">new</span> Dog();<br><span class="hljs-keyword">delete</span> animal;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">这是<span class="hljs-keyword">Animal</span>的构造函数<br>这是Dog的构造函数<br>这是<span class="hljs-keyword">Animal</span>的析构函数<br></code></pre></td></tr></table></figure><p>可以看到，delete animal后并没有调用Dog的析构函数，释放子类Dog在堆区申请的空间。这样便出现了内存泄漏。</p><p>此时虚析构函数和纯虚析构函数便可以起作用了，我们再看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>Animal()<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;这是Animal的构造函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">virtual</span> ~Animal()<span class="hljs-comment">//把父类的析构函数改为虚析构函数</span><br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;这是Animal的析构函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> :</span> <span class="hljs-keyword">public</span> Animal<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> *p;<br>Dog()<br>&#123;<br>p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;这是Dog的构造函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>~Dog()<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;这是Dog的析构函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;释放堆区的p&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">delete</span> p;<br>p = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Animal *animal = <span class="hljs-keyword">new</span> Dog();<br><span class="hljs-keyword">delete</span> animal;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​    输出结果：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">这是<span class="hljs-keyword">Animal</span>的构造函数<br>这是Dog的构造函数<br>这是Dog的析构函数<br>释放堆区的p<br>这是<span class="hljs-keyword">Animal</span>的析构函数<br></code></pre></td></tr></table></figure><p>​    如此便可以释放子类Dog在堆区申请的空间了，纯虚析构函数和虚析构函数的作用是一样，只是纯虚析构函数有一个和纯虚函数一样的特性，即定义看纯虚析构函数的类也属于抽象类，纯虚析构函数必须实现，如果不实现所有继承了拥有纯虚析构函数的抽象类的派生类都属于抽象类。需要注意的是，因为纯虚析构函数的特性，纯虚析构函数的实现就必须在类外实现了。</p><h2 id="5-重载、重写、重定义"><a href="#5-重载、重写、重定义" class="headerlink" title="5.重载、重写、重定义"></a>5.重载、重写、重定义</h2><p><strong>重载</strong></p><p>重载发生在一个类的内部，拥有相同函数名，相同返回值而参数列表不同的函数之间互为重载关系。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><font color="red"> 只有相同函数名而参数列表的函数才是重载，函数名相同参数列表也相同而返回值不同的函数在C++中是不允许的。</font></p><p><strong>重写</strong></p><p>重写发生在基类和派生类之间，基类中定义虚函数(纯虚函数)，派生类中定义和虚函数拥有<strong>相同函数名，相同参数列表和相同返回值</strong>的函数，这种情况下发生函数重写。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> :</span> <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-comment">//重写A类的fun函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;&#125;<span class="hljs-comment">//重定义一个新函数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//这种情况C++不允许</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>重定义</strong></p><p>重定义也是发生在基类和派生类之间，派生类拥有与基类函数名相同，返回值相同，而参数列表不同的函数，此时发生重定义。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> :</span> <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;&#125;<span class="hljs-comment">//发生重定义</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><font color="red"> 派生类中可以重定义基类的任何函数，包括虚函数和纯虚函数。</font></p><h2 id="6-父类指针和子类指针步长不一致问题"><a href="#6-父类指针和子类指针步长不一致问题" class="headerlink" title="6.父类指针和子类指针步长不一致问题"></a>6.父类指针和子类指针步长不一致问题</h2><p>问题出现的场景是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> a;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> :</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> b;<br>B(<span class="hljs-keyword">int</span> b)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;b = b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A *a = <span class="hljs-literal">NULL</span>;<br>B *b = <span class="hljs-literal">NULL</span>;<br>B <span class="hljs-built_in">array</span>[<span class="hljs-number">2</span>]&#123; B(<span class="hljs-number">1</span>),B(<span class="hljs-number">2</span>) &#125;;<br>a = <span class="hljs-built_in">array</span>;<br>b = <span class="hljs-built_in">array</span>;<br>a-&gt;print();<br>b-&gt;print();<br>a++; b++;<br>a-&gt;print();<span class="hljs-comment">//这一步会出现异常</span><br>b-&gt;print();<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>即父类指针a和子类指针b都指向一个子类对象数组，于是我们可以通过指针++的自增运算来逐步访问数组元素，问题就出在这，使用<code>sizeof()</code>计算两个类的大小分别得出，sizeof(A)=8;sizeof(B)=20;这就导致A类指针a每一次移步时只移动了8个字节，这个距离还远远没有达到下一个元素的首地址，所以访问会出错，这是因为指针每次移步移动的距离是指针类型的空间大小，如：A类大小为8，所以A类指针每移步一次走8个字节。</p><p>可能会有疑问，为什么类B的大小是20？</p><p>我们可以算一算，类B继承至类A所以类A中拥有的成员变量，类B也拥有，占8字节，这8字节分别是int变量4字节和虚函数表指针4字节；类B自身定义了一个int变量占4字节，由于类B重写了类A的虚函数，所以类B也拥有一个自己的虚函数表指针，占4字节；类B虚继承了类A，在这个过程中，C++编译器会给类B增加一个属性，占4字节，于是，<strong>8+4+4+4+4=20</strong>。</p><hr><h1 id="四、泛型编程"><a href="#四、泛型编程" class="headerlink" title="四、泛型编程"></a>四、泛型编程</h1><h2 id="1-函数模板"><a href="#1-函数模板" class="headerlink" title="1.函数模板"></a>1.函数模板</h2><h3 id="函数模板的基本语法"><a href="#函数模板的基本语法" class="headerlink" title="函数模板的基本语法"></a>函数模板的基本语法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//---------------函数模板</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-comment">//告诉编译器我要开始泛型编程了，遇到T不要报错</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">(T &amp;a,T &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>T t = a;<br>a = b;<br>b = t;<br>&#125;<br><span class="hljs-comment">//----------------</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">char</span> a = <span class="hljs-number">97</span>,b = <span class="hljs-number">102</span>;<br>Fun(a, b);<span class="hljs-comment">//自动推导类型调用</span><br><span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">string</span> x = <span class="hljs-string">&quot;xxx&quot;</span>, y = <span class="hljs-string">&quot;yyy&quot;</span>;<br>Fun&lt;<span class="hljs-built_in">string</span>&gt;(x, y);<span class="hljs-comment">//显示类型调用</span><br><span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-built_in">endl</span>;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="当函数模板遇到函数重载"><a href="#当函数模板遇到函数重载" class="headerlink" title="当函数模板遇到函数重载"></a>当函数模板遇到函数重载</h3><p>当函数模板遇到函数重载准许下面4条原则</p><ul><li>函数模板可以像普通函数一样被重载</li><li>C++编译器优先考虑普通函数</li><li>如果函数模板可以产生一个更好的匹配，那么选择函数模板</li><li>可以通过模板的空实参列表的语法限定编译器只通过函数模板匹配</li></ul><p>我们来看一个例子，逐一分析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">(T a,T b)</span></span><br><span class="hljs-function"></span>&#123;<br>a = a + b;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;我是函数模板&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1,<span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">(T1 a,T2 b)</span></span><br><span class="hljs-function"></span>&#123;<br>T1 x = a;<br>T2 y = b;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;我是函数模板重载&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;我是普通函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fun2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Fun(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>Fun(<span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>);<br>Fun(<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">1</span>);<br>Fun&lt;&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>Fun2(<span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>);<br>Fun2(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">3</span>);<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">我是普通函数<br>我是函数模板<br>我是函数模板重载<br>我是函数模板<br>0,0<br>97,3<br></code></pre></td></tr></table></figure><p><strong>分析：</strong></p><ul><li><code>Fun(1,2)</code>:有完全匹配的普通函数，所以调用<code>void Fun(int a, int b)</code></li><li><code>Fun(0.1,0.2)</code>:虽然普通函数<code>void Fun(int a, int b)</code>可以像<code>void Fun2(int a, int b)</code>一样进行隐式类型转换调用，倒是<code>Fun()</code>函数有更好的重载函数<code>void Fun(T1 a,T2 b)</code>模板匹配所以编译器优先调用<code>void Fun(T1 a,T2 b)</code></li><li><code>Fun(&#39;c&#39;,1)</code>:编译器能找到匹配的函数模板重载<code>void Fun(T1 a,T2 b)</code>所以优先调用函数模板</li><li><code>Fun&lt;&gt;(1,2)</code>:使用了空参数列表，告诉编译器只匹配函数模板，即使代码段中有能完美匹配的普通函数，也只调用函数模板</li></ul><h2 id="2-类模板"><a href="#2-类模板" class="headerlink" title="2.类模板"></a>2.类模板</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-comment">//定义</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TemplateA</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>TemplateA(T a)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintA</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>T a;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test</span><span class="hljs-params">(TemplateA&lt;<span class="hljs-keyword">int</span>&gt; &amp;a)</span><span class="hljs-comment">//类模板作形参</span></span><br><span class="hljs-function"></span>&#123;<br>a.PrintA();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">TemplateA&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">//使用</span><br><span class="hljs-function">TemplateA&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-string">&quot;str&quot;</span>)</span></span>;<br><span class="hljs-function">TemplateA&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-literal">true</span>)</span></span>;<br>Test(a);<br>b.PrintA();<br>c.PrintA();<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">a:</span><span class="hljs-number">1</span><br><span class="hljs-symbol">a:</span>str<br><span class="hljs-symbol">a:</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>类模板的定义和函数模板的定义类似</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>类模板的使用必须显示的确定模板的类型参数，如：<code>TemplateA&lt;string&gt; b(&quot;str&quot;)</code></p><h3 id="类模板作参数"><a href="#类模板作参数" class="headerlink" title="类模板作参数"></a>类模板作参数</h3><p>类模板作参数也必须显示的确定模板那的类型参数，如：</p><p><code>void Test(TemplateA&lt;int&gt; &amp;a)</code>以便编译器为形参确定内存空间。</p><h3 id="类模板派生普通类"><a href="#类模板派生普通类" class="headerlink" title="类模板派生普通类"></a>类模板派生普通类</h3><p>类模板也可以被继承，但是在继承时需要显示确定模板的类型参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TemplateA</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>TemplateA(T a)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintA</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>T a;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> :</span> <span class="hljs-keyword">public</span> TemplateA&lt;<span class="hljs-keyword">int</span>&gt;<span class="hljs-comment">//类模板派生普通类</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>B(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) :TemplateA(a)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;b = b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintB</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;b:&quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">int</span> b;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">B <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>b.PrintA();<br>b.PrintB();<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="模板类派生模板类"><a href="#模板类派生模板类" class="headerlink" title="模板类派生模板类"></a>模板类派生模板类</h3><p>模板类不仅可以派生普通类，还可以派生模板类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TemplateA</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>TemplateA(T a)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintA</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>T a;<br>&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1,<span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TemplateB</span> :</span> <span class="hljs-keyword">public</span> TemplateA&lt;T2&gt;<span class="hljs-comment">//类模板派生类模板</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>TemplateB(T2 a, T1 b) :TemplateA(a)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;b = b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintB</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;b:&quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>T1 b;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>TemplateB&lt;string,char&gt; b(&#x27;A&#x27;, &quot;TemplateB&quot;);<br>b.PrintA();<br>b.PrintB();<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">a:</span>A<br><span class="hljs-symbol">b:</span>TemplateB<br></code></pre></td></tr></table></figure><h3 id="类模板的主要作用"><a href="#类模板的主要作用" class="headerlink" title="类模板的主要作用"></a>类模板的主要作用</h3><p>类模板的主要作用就是将数据结构的表示和算法不受包含的元素类型的影响，即类模板将元素类型和数据结构算法分离开来了，使数据结构和算法成为真正意义上的数据结构和算法，如：链表不再因为<code>int</code>类型而定义一个<code>int</code>类型的链表，因<code>string</code>类型而定义一个<code>string</code>类型的链表，而是定义一个链表可以通用于所有类型。</p><h1 id="五、异常处理"><a href="#五、异常处理" class="headerlink" title="五、异常处理"></a>五、异常处理</h1><h2 id="1-异常的基本语法"><a href="#1-异常的基本语法" class="headerlink" title="1.异常的基本语法"></a>1.异常的基本语法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Try</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;除数不能等于0，抛出异常&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">throw</span> y;<span class="hljs-comment">//这里必须指明抛出异常的数据类型，否则程序无法处理异常，只能使用这个类型的变量，x和y的效果是一样的，不能直接抛出int，即这样是不行的throw int</span><br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;x/y=&quot;</span> &lt;&lt; x / y &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Try(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>Try(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">try</span><br>&#123;<br>Test1();<br>&#125;<br><span class="hljs-keyword">catch</span> (<span class="hljs-keyword">char</span> e)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;处理char异常&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">catch</span>(...)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;无法处理的异常继续往上抛&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">throw</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">try</span><br>&#123;<br>Test2();<br>&#125;<br><span class="hljs-keyword">catch</span>(<span class="hljs-keyword">int</span> e)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;处理int异常&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">catch</span> (...)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;处理其他异常&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-symbol">x</span>/<span class="hljs-symbol">y</span>=<span class="hljs-number">0</span><br>除数不能等于<span class="hljs-number">0</span>，抛出异常<br>无法处理的异常继续往上抛<br>处理int异常<br></code></pre></td></tr></table></figure><ul><li>异常的抛出是可以跨函数的，如上面的代码，在<code>Try</code>函数里抛出的异常可以在<code>mian</code>函数中处理，中间跨过了<code>Test1</code>，<code>Test2</code>两个函数</li><li>如果在一个函数内捕捉到异常但是却无法处理可以通过<code>throw</code>继续向上抛，直至main函数，如上面代码，<code>Test2</code>捕捉到异常但是没有处理继续向上抛给了main函数，如果main函数还是没有处理，则会直接中断程序</li><li>C++使用<code>cacth(...)</code>来捕捉其他没有捕捉到的异常，如上面代码，main函数中只捕捉了int类型的异常，如果出现其他类型的异常则有<code>cacth(...)</code>来捕捉</li><li>异常处理是按照类型匹配来处理的，即<code>throw</code>的int类型的异常只有<code>cacth(int e)</code>能够接收得到，否则就只能使用<code>cacth(...)</code>来接收未知异常</li></ul><h2 id="2-C-异常处理的特性"><a href="#2-C-异常处理的特性" class="headerlink" title="2.C++异常处理的特性"></a>2.C++异常处理的特性</h2><p>​    C++的异常处理具有跨函数性，这使得<font color="red"> 异常引发</font>和<font color="red"> 异常处理</font>分离开来，这样下层函数可以不用过多的在一异常处理，而把重点放在问题的逻辑处理上，异常处理可以由上层调用者专门来处理。</p><h2 id="3-异常接口申明"><a href="#3-异常接口申明" class="headerlink" title="3.异常接口申明"></a>3.异常接口申明</h2><p><strong>不抛出任何异常：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Try</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span><span class="hljs-comment">//异常接口申明</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;除数不能等于0，抛出异常&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">throw</span> x;<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;x/y=&quot;</span> &lt;&lt; x / y &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>只能抛出列表中类型的异常：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Try</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> <span class="hljs-title">throw</span><span class="hljs-params">(<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>*)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;除数不能等于0，抛出异常&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">throw</span> x;<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;x/y=&quot;</span> &lt;&lt; x / y &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>可以抛出任何异常：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Try</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;除数不能等于0，抛出异常&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">throw</span> x;<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;x/y=&quot;</span> &lt;&lt; x / y &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过经过测试，三份代码无论是否写throw都是可以抛出并处理异常的，似乎这个语法没什么卵用，可能C++11摒弃了这种用法，但是考虑到兼容保留这个语法。</p><h2 id="4-异常接收的3种方式"><a href="#4-异常接收的3种方式" class="headerlink" title="4.异常接收的3种方式"></a>4.异常接收的3种方式</h2><h3 id="普通形参"><a href="#普通形参" class="headerlink" title="普通形参"></a>普通形参</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>A() &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;构造A&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<br>A(<span class="hljs-keyword">const</span> A &amp;a) &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;拷贝A&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<br>~A() &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;析构A&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Try</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A a;<br><span class="hljs-keyword">throw</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">try</span><br>&#123;<br>Try();<br>&#125;<br><span class="hljs-keyword">catch</span>(A e)<span class="hljs-comment">//使用普通形参</span><br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;处理int异常&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns">构造<span class="hljs-keyword">A</span><br>拷贝<span class="hljs-keyword">A</span><br>拷贝<span class="hljs-keyword">A</span><br>析构<span class="hljs-keyword">A</span><br>处理int异常<br>析构<span class="hljs-keyword">A</span><br>析构<span class="hljs-keyword">A</span><br></code></pre></td></tr></table></figure><p>可以看到a被拷贝两次，第一次从<code>A a</code>拷贝到<code>throw a</code>，第二次从<code>throw a</code>拷贝到<code>catch(A e)</code>，可以看出如果使用普通形参来接收异常，异常变量会由异常抛出处拷贝到异常接收处。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>将上面代码的<code>catch(A e)</code>改为<code>catch(A &amp;e)</code></p><p><strong>输出结果：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">构造<span class="hljs-keyword">A</span><br>拷贝<span class="hljs-keyword">A</span><br>析构<span class="hljs-keyword">A</span><br>处理int异常<br>析构<span class="hljs-keyword">A</span><br></code></pre></td></tr></table></figure><p>可以看到只拷贝了一次，即从<code>A a</code>拷贝到<code>throw a</code>。</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>上面代码应该修改为如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>A() &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;构造A&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<br>A(<span class="hljs-keyword">const</span> A &amp;a) &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;拷贝A&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<br>~A() &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;析构A&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Try</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A *a = <span class="hljs-keyword">new</span> A();<span class="hljs-comment">//对象必须创建在堆区，函数结束对象就会被销毁，而无法通过指针传递到catch中</span><br><span class="hljs-keyword">throw</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">try</span><br>&#123;<br>Try();<br>&#125;<br><span class="hljs-keyword">catch</span>(A *e)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;处理int异常&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">delete</span> e;<span class="hljs-comment">//需要手动释放堆区的内存</span><br>&#125;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">构造<span class="hljs-keyword">A</span><br>处理int异常<br>析构<span class="hljs-keyword">A</span><br></code></pre></td></tr></table></figure><p>可以看到使用指针完全不需要拷贝，但是却需要消耗堆区的内存且容易造成内存泄露。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的来说，最优的方式还是使用引用。</p><h2 id="5-继承在异常处理中的应用"><a href="#5-继承在异常处理中的应用" class="headerlink" title="5.继承在异常处理中的应用"></a>5.继承在异常处理中的应用</h2><p>在实际的项目中我们处理的异常并不是一些基础的数据类型，大多都是开发者的自定义类，这种情况在捕捉异常的时候就相当麻烦，尽管有些异常处理起来程序基本一致，但是却要将每一种异常一一捕捉并一一处理，下面的代码我们来模拟一下这种情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>//<span class="hljs-title">A</span>类实现输入一个范围在0-10的奇数</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>A(<span class="hljs-keyword">int</span> a) <br>&#123;<br><span class="hljs-keyword">if</span> (a % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span>)<span class="hljs-keyword">throw</span> LtZero();<br><span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">10</span>)<span class="hljs-keyword">throw</span> GtTen();<br><span class="hljs-keyword">else</span> num = a;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> Even();<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">int</span> num;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LtZero</span>//专门处理异常的异常类</span><br><span class="hljs-class">&#123;</span>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GtTen</span></span><br><span class="hljs-class">&#123;</span>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Even</span></span><br><span class="hljs-class">&#123;</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">try</span> &#123; <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>; &#125;<br><span class="hljs-keyword">catch</span> (LtZero &amp;lz) &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;输入的数小于0&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<br><span class="hljs-keyword">catch</span> (GtTen &amp;gt) &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;输入的数大于10&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<br><span class="hljs-keyword">catch</span> (Even &amp;ev) &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;输入的数是偶数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<br><span class="hljs-keyword">catch</span> (...) &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;其他异常&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到我们的异常处理模块相当繁杂，在实际开发项目中异常的数量远远不止上面模拟的三种，可能多达上百种或则更多，这是异常的处理将变得十分繁杂，那么如何处理呢？</p><p>可能心细的读者会发现，我们在处理异常时使用了专门的异常处理类，而类是可以继承的，于是乎，继承在异常处理中的作用就体现出来了。</p><p>我们再来看一份优化后的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>//<span class="hljs-title">A</span>类实现输入一个范围在0-10的奇数</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>A(<span class="hljs-keyword">int</span> a) <br>&#123;<br><span class="hljs-keyword">if</span> (a % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span>)<span class="hljs-keyword">throw</span> LtZero();<br><span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">10</span>)<span class="hljs-keyword">throw</span> GtTen();<br><span class="hljs-keyword">else</span> num = a;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> Even();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Even</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintErro</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span>&lt;&lt; <span class="hljs-string">&quot;输入的数是偶数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LtZero</span>:</span><span class="hljs-keyword">public</span> Even<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintErro</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;输入的数小于0&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GtTen</span>:</span><span class="hljs-keyword">public</span> Even<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintErro</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;输入的数大于10&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">int</span> num;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">try</span> &#123; <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>; &#125;<br><span class="hljs-keyword">catch</span> (A::Even e) &#123; e.PrintErro(); &#125;<br><span class="hljs-keyword">catch</span> (...) &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;其他异常&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到我们的异常处理模块使用多态，繁杂程度被大幅缩水了，而我们的异常处理被集中在了异常处理类中，有时，如果我们的异常处理只对某一个类有效也是可以直接将异常处理类定义在抛出类里面的。</p><h2 id="6-标准异常库"><a href="#6-标准异常库" class="headerlink" title="6.标准异常库"></a>6.标准异常库</h2><p>C++提供一些标准的异常库，头文件为：#include<stdexcep></stdexcep></p><h1 id="六、标准IO流"><a href="#六、标准IO流" class="headerlink" title="六、标准IO流"></a>六、标准IO流</h1><h2 id="1-标准IO流流程"><a href="#1-标准IO流流程" class="headerlink" title="1.标准IO流流程"></a>1.标准IO流流程</h2><p><img src="/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/Snipaste_2019-10-06_10-03-47.png"></p><h2 id="2-标准输入流"><a href="#2-标准输入流" class="headerlink" title="2.标准输入流"></a>2.标准输入流</h2><table><thead><tr><th>标准函数</th><th>作用</th></tr></thead><tbody><tr><td>cin</td><td>cin&gt;&gt;操作支持任何基本类型的输入，但是遇到空格则结束读取</td></tr><tr><td>cin.get(char chr)</td><td>从缓冲区中读取一个字符到chr中，因为C++定义的cin.get(char)中会返回一个函数自身的引用，所以此函数支持链式编程，即cin.get(a).get(b).get(c);b表示依次从缓冲区中读取三个字符到a，b，c中</td></tr><tr><td>cin.get(char* buf,int cout)</td><td>从缓冲区中读取cout个字符到buf数组中，因为函数似乎会在数组末尾添加点什么，所以实际读取的字符数量是cout-1个，此函数也支持链式编程</td></tr><tr><td>cin.get(char* buf,int cout,char chr)</td><td>从缓冲区中读取cout个字符到buf数组中，如果碰到字符chr则结束读取</td></tr><tr><td>cin.getline(char buf,int cout)</td><td>从缓冲区中读取cout个字符到buf数组中</td></tr><tr><td>cin.ignore(int num)</td><td>忽略缓冲区当前读取指针开始的num个字符再读取</td></tr><tr><td>cin.peek()</td><td>判断缓冲区中是否有数据，如果有则返回第一个字符，如果没有则阻塞程序</td></tr><tr><td>cin.putback(char chr)</td><td>将读取出来的字符再返存回缓冲区，只能读取一个字符</td></tr></tbody></table><h2 id="3-标准输出流"><a href="#3-标准输出流" class="headerlink" title="3.标准输出流"></a>3.标准输出流</h2><table><thead><tr><th>标准函数</th><th>作用</th></tr></thead><tbody><tr><td>cout</td><td>输出缓冲区内容，支持任何基本类型数据的输出</td></tr><tr><td>cout.flush(void)</td><td>刷新缓冲区，无视系统繁忙，强制输出缓冲区的字符，语法和cout一样“cout.flush()&lt;&lt;buf&lt;&lt;endl;”</td></tr><tr><td>cout.put(char chr)</td><td>在标准输出设备输出指针的当前位置插入字符chr，语法和cout一致</td></tr><tr><td>cout.write(char *chr,int cout)</td><td>输出*chr所指向空间中cout个数量的字符，即使越界也会继续输出，语法和cout一致</td></tr><tr><td>cout.width(int num)</td><td>输出num个字节宽度的字符，一般配合cout.fill(char chr)和其他cout函数一起使用</td></tr><tr><td>cout.fill(char chr)</td><td>配合cout.width(int num)和其他cout一起使用，在输出的num宽度的字符中将cout函数没有填充完的字符用chr填充</td></tr><tr><td>cout.setf(标记)</td><td>格式化cout输出，标记种类很多，具体的可以查阅资料，配合cout函数一起使用</td></tr></tbody></table><h2 id="4-文件IO流"><a href="#4-文件IO流" class="headerlink" title="4.文件IO流"></a>4.文件IO流</h2><p>​    文件操作相对来说比较简单，总的来说就是5个步骤，即</p><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><ul><li><p>​    包含头文件<font color="red">#include<ftream></ftream></font></p></li><li><p>​    创建流对象</p></li><li><p>​    打开文件</p></li><li><p>​    读写文件</p><p>​    <font color="red">需要注意的是C++中文件写的方式是使用符号“&lt;&lt;”，如：fout &lt;&lt; “文件内容”&lt;&lt;endl;</font></p><p>​    <font color="red">同理文件读也可以使用“&gt;&gt;”来读。</font></p></li><li><p>​    关闭文件</p><p><strong>文件写</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ofstream fout;<br>fout.open(<span class="hljs-string">&quot;文件测试.txt&quot;</span>, ios::out);<br>fout &lt;&lt; <span class="hljs-string">&quot;姓名：张三&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>fout &lt;&lt; <span class="hljs-string">&quot;性别：男&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>fout.close();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>test();<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    <strong>输出结果：</strong>    </p><p><img src="/2019/09/14/%E3%80%90C++%E3%80%91C++%E9%AB%98%E7%BA%A7/Snipaste_2019-09-14_16-29-43.png"></p><h3 id="4种文件读的方式"><a href="#4种文件读的方式" class="headerlink" title="4种文件读的方式"></a>4种文件读的方式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ifstream fin;<br>fin.open(<span class="hljs-string">&quot;文件测试.txt&quot;</span>, ios::in);<br><span class="hljs-keyword">if</span> (!fin.is_open())<span class="hljs-comment">//文件读需要多添加一步判断文件是否打开成功的步骤</span><br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;文件打开失败&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">char</span> str[<span class="hljs-number">1024</span>];<br><span class="hljs-built_in">string</span> strs;<br><span class="hljs-keyword">char</span> chr;<br><span class="hljs-comment">//第一中方式</span><br><span class="hljs-comment">//while (fin &gt;&gt; str)//操作符&quot;&gt;&gt;&quot;每次只能读取一行数据，读到文件尾“EOF”时结束</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment">//第二种方式</span><br><span class="hljs-comment">//while (fin.getline(str, 50))//ifstream::getline(char *str,int num);这个函数只支持字符数组，参数num指的是需要读取的字节数</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment">//第三种方式</span><br><span class="hljs-comment">//while (getline(fin, strs))//与第二种方式不同的是，这个getline函数是全局的，且只支持输出到string类型的对象中</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//cout &lt;&lt; strs &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment">//第四中方式</span><br><span class="hljs-keyword">while</span> ((chr = fin.get()) != EOF)<span class="hljs-comment">//get()函数每次只能读取一个字符</span><br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; chr ;<br>&#125;<br>fin.close();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>test();<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="文件的打开模式"><a href="#文件的打开模式" class="headerlink" title="文件的打开模式"></a>文件的打开模式</h3><p>​    C++提供6中文件的打开方式</p><table><thead><tr><th>打开方式</th><th>解释</th></tr></thead><tbody><tr><td>ios::in</td><td>以读的形式打开</td></tr><tr><td>ios::out</td><td>以写的形式打开，会覆盖源文件</td></tr><tr><td>ios::ate</td><td>以写的形式打开并初始文件位置：文件尾，会覆盖源文件</td></tr><tr><td>ios::app</td><td>以追加的方式打开文件</td></tr><tr><td>ios::trunc</td><td>如果文件存在先删除再创建</td></tr><tr><td>ios::binary</td><td>以二进制的形式打开</td></tr></tbody></table><h3 id="读写二进制文件"><a href="#读写二进制文件" class="headerlink" title="读写二进制文件"></a>读写二进制文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;张三&quot;</span>;<br><span class="hljs-built_in">string</span> sex = <span class="hljs-string">&quot;男&quot;</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ofstream fout;<br>fout.open(<span class="hljs-string">&quot;二进制文件测试.txt&quot;</span>, ios::out | ios::binary);<br>Person p;<br>fout.write((<span class="hljs-keyword">char</span> *)&amp;p, <span class="hljs-keyword">sizeof</span>(Person));<span class="hljs-comment">//注意这里使用ofstream::write()来写</span><br>fout.close;<br><br>ifstream fin;<br>fin.open(<span class="hljs-string">&quot;二进制文件测试.txt&quot;</span>, ios::in | ios::binary);<br><span class="hljs-keyword">if</span> (!fin.is_open())<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;文件打开错误&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>Person pin;<br>fin.read((<span class="hljs-keyword">char</span> *)&amp;pin, <span class="hljs-keyword">sizeof</span>(Person));<span class="hljs-comment">//注意这里使用ofstream::read()来读</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;姓名：&quot;</span> &lt;&lt; pin.name &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;性别：&quot;</span> &lt;&lt; pin.sex &lt;&lt; <span class="hljs-built_in">endl</span>;<br>fin.close();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>test();<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C++】C++中的四种类型转换</title>
    <link href="/2019/09/12/%E3%80%90C++%E3%80%91C++%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/"/>
    <url>/2019/09/12/%E3%80%90C++%E3%80%91C++%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>C++提供四种类型转换：const_cast、static_cast、dynamic_cast、reinterpret_cast</p><h1 id="1-const-cast"><a href="#1-const-cast" class="headerlink" title="1.const_cast"></a>1.const_cast</h1><p>​    const_cast的存在主要就是针对const字段，C++提供const_cast的目的就是为了消除const字段的const属性，让const字段也可以修改。</p><p>​    const_cast的用法：</p><p>​        const_cast只能将常指针转换为非常指针，不能直接将常字段转换为非常字段，只能通过指针类间接的修改常字段所在的内存的内容。</p><p>​        例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>* n = &amp;a;<br><span class="hljs-keyword">int</span>* m = <span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">int</span>*&gt;(n) ;<br>*m = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>​    最终的输出结果：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-attr">a</span> = <span class="hljs-number">1</span>,*<span class="hljs-attr">n</span> = <span class="hljs-number">2</span>,*<span class="hljs-attr">m</span> = <span class="hljs-number">2</span><br>&amp;<span class="hljs-attr">a=n=m</span><br></code></pre></td></tr></table></figure><p>​        奇怪，指针n，m的确指向了地址&amp;a，之中的内容的确也修改成了2，可为什么字段a的值依旧是1？</p><p>​        经过多方查阅资料和自己的试验，原来对于常字段在预编译的过程中编译器就会给常字段预定义为初始化的值，类似宏定义一般，尽管内存的内容被改变了，但是常字段的值依旧被预定义为初始化的值。</p><p>​        但是，我就疑问了，既然const_cast就是用来修改const字段的，可是只是改变了其内存的值，字段的值依旧没变，那么程序里使用该字段的地方的值依旧没有改变，如此const_cast似乎没有达到想要的结果。</p><p>​        $\color{red}{不过const_cast似乎可以修改const标识的结构体对象中没有再用const标识的字段，也可以修改用const标识的类对象中没有用const标识的公有字段，但是在结构体或类中用const标识的字段就不能再修改了。}$</p><p><img src="/2019/09/12/%E3%80%90C++%E3%80%91C++%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/Snipaste_2019-09-12_10-44-16.png"></p><h1 id="2-static-cast"><a href="#2-static-cast" class="headerlink" title="2.static_cast"></a>2.static_cast</h1><p>​    static_cast类型转换的用法几乎和C中的基本类型转换的用法一致，而C++的static_cast类型转换增加l类型检查，在安全性上较C要强。</p><p>​    static_cast支持所有类型之间的转换包括类，对于类在继承过程中的类型转换有两点是需要注意的，一、static_cast类型转换在上行转换是安全的，在下行转换是不安全，（上行转换：从子类转换到父类，下行转换：从父类转换到子类），二、static_cast类型转换在类的转换中因该使用指针转换，即通过指针间接的实现转换，直接对类的对象进行转换类型会被裁剪，并且在下行转换中不使用指针会报错。</p><p><img src="/2019/09/12/%E3%80%90C++%E3%80%91C++%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/Snipaste_2019-09-12_11-51-30.png"></p><h1 id="3-dynamic-cast"><a href="#3-dynamic-cast" class="headerlink" title="3.dynamic_cast"></a>3.dynamic_cast</h1><p>​    dynamic_cast类型转换用于类之间的上下行转换，与static_cast不同的是，dynamic_cast类型转换无论上下行都具有类型检查，都可以进行安全的类型转换。上行转换dynamic_cast与static_cast完全一致，下行转换dynamic_cast比static_cast更安全</p><h1 id="4-reinterpret-cast"><a href="#4-reinterpret-cast" class="headerlink" title="4.reinterpret_cast"></a>4.reinterpret_cast</h1><p>​    reinterpret_cast类型转换只能对指针进行操作，reinterpret_cast类型转换提供的是一种更底层的转换模式–比特位上的重新解释，即对某一类型的内存地址的比特位以另一种类型来解释，这可能不好理解，在这放一张图来辅助理解。</p><p><img src="/2019/09/12/%E3%80%90C++%E3%80%91C++%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/Snipaste_2019-09-12_16-32-44.png"></p><p>​    p是指向字符串的char类型指针，i是指向整型的指针，i = reinterpret_cast&lt;int*&gt;(p)则将p所指向的内存里的比特位以int类型来重新解释并复制到i所指向的内存地址上，于是在输出 *i 时，输出的是一个整型的数值。</p><p>reinterret_cast可以说是一个安全的强制类型转换了。 </p><p>​    至于为什么cout&lt;&lt;p时不是输出的p所指向的地址而是地址里的内容，我始终没有弄明白，不过不影响对reinterpret_cast类型转换的理解。</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C++】普通全局变量、静态全局变量、普通局部变量与静态局部变量</title>
    <link href="/2019/09/11/%E3%80%90C++%E3%80%91%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E9%9D%99%E6%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/"/>
    <url>/2019/09/11/%E3%80%90C++%E3%80%91%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E9%9D%99%E6%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="1-普通全局变量"><a href="#1-普通全局变量" class="headerlink" title="1.普通全局变量"></a>1.普通全局变量</h1><p>​    普通全局变量是定义在函数和类外的或由extern标识或直接定义没有static标识的变量。</p><p>​    各个类型的变量之间最主要的区别就是作用域的不同了，普通全局变量的作用域在整个源程序中，全局变量对整个源程序中都是可见的，无论源程序是由单个文件还是多个文件组成，普通全局变量具有external链接属性，所以普通全局变量在整个源程序的各个文件中都可以被引用。</p><h1 id="2-静态全局变量"><a href="#2-静态全局变量" class="headerlink" title="2.静态全局变量"></a>2.静态全局变量</h1><p>​    静态全局变量是定义在函数和类外的由static标识的变量。</p><p>​    静态全局变量具有文件作用域，具有internal链接属性，只能在定义的文件中使用，在其他文件中可以定义同名的变量，而全局变量则不行，这里要注意静态全局变量与类静态全局变量是不同的，类静态全局变量受到类权限限制，不同的访问权限就之间决定了类静态全局变量的作用域，类全局变量的使用与类一致，能使用类的地方就能使用类全局变量。</p><p>​    关于普通全局变量和静态全局变量的区别，我一直没有弄得很清楚，我有在网上查阅很多bolg，大家的说法都出奇的一致，我上面写的也是在查阅很多blog后总结的，但是我实际测试时，普通全局变量和静态全局变量似乎都可以被其他文件使用，并且 在其他文件中定义静态全局变量似乎也没有报错，没有弄明白这个其他文件指的是什么文件。</p><p><img src="/2019/09/11/%E3%80%90C++%E3%80%91%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E9%9D%99%E6%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/Snipaste_2019-09-11_21-36-28.png"></p><p><img src="/2019/09/11/%E3%80%90C++%E3%80%91%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E9%9D%99%E6%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/Snipaste_2019-09-11_21-36-38.png"></p><h1 id="3-普通局部变量"><a href="#3-普通局部变量" class="headerlink" title="3.普通局部变量"></a>3.普通局部变量</h1><p>​    普通局部变量是定义在函数内的没有static标识的变量。</p><p>​    普通局部变量具有块作用域，生命周期从定义开始到跳出函数结束，普通局部变量每次使用都会初始化一次。</p><h1 id="4-静态局部变量"><a href="#4-静态局部变量" class="headerlink" title="4.静态局部变量"></a>4.静态局部变量</h1><p>​    静态局部变量的作用于和普通局部变量一致，但是静态局部变量的内存地址在函数结束后不会被销毁，且会保存赋值结果，静态局部变量和静态全局变量一样会一直驻留在静态区，静态局部变量只会初始化一次，在下一次函数被调用时不会再初始化而是直接调用。</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C#】C#两种二维数组的区别</title>
    <link href="/2019/09/11/%E3%80%90C#%E3%80%91C#%E4%B8%A4%E7%A7%8D%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2019/09/11/%E3%80%90C#%E3%80%91C#%E4%B8%A4%E7%A7%8D%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>C#支持两种二维数组的定义方式（以int数组为例）：</p><h1 id="1-普通数组"><a href="#1-普通数组" class="headerlink" title="1.普通数组"></a>1.普通数组</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span>[,] array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><p>这种方式形式上较为简便，要注意的是new之后的[]里面是一定要注明数组大小的，不注明会报错，也就是说这种方式定义的数组是确定大小的。</p><p>数组的赋值：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span>[,] array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-多播数组"><a href="#2-多播数组" class="headerlink" title="2.多播数组"></a>2.多播数组</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span>[][] array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">2</span>][];<br></code></pre></td></tr></table></figure><p>这种方式需要注明行数，列数不能注明，注明会报错，这种方式定义的是一个函数确定而列数不确定的不确定大小的数组。</p><p>数组的赋值：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span>[][] array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">2</span>][]&#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;&#125;<br></code></pre></td></tr></table></figure><p>两种二维数组是不能兼容的，即使用方式1定义的二维数组不能使用方式2来使用，反之亦然。</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Lua】Lua基础</title>
    <link href="/2019/09/09/%E3%80%90Lua%E3%80%91Lua%E5%9F%BA%E7%A1%80/"/>
    <url>/2019/09/09/%E3%80%90Lua%E3%80%91Lua%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://img-blog.csdnimg.cn/2019090916141255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190909161442706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>参考博文：<a href="https://www.cnblogs.com/cjswwdz/p/5634442.html">https://www.cnblogs.com/cjswwdz/p/5634442.html</a></p><p>XMind源文件：<a href="https://github.com/Goulandis/XMinds-2019.8.27/tree/master/Lua">https://github.com/Goulandis/XMinds-2019.8.27/tree/master/Lua</a></p><p>学习地址：<a href="https://www.bilibili.com/video/av50685253?from=search&amp;seid=12754355294240767428">https://www.bilibili.com/video/av50685253?from=search&amp;seid=12754355294240767428</a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lua</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Unity3d】Unity常用技巧笔记</title>
    <link href="/2019/08/27/%E3%80%90Unity3d%E3%80%91Unity%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%E7%AC%94%E8%AE%B0/"/>
    <url>/2019/08/27/%E3%80%90Unity3d%E3%80%91Unity%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="为Image组件添加sprite"><a href="#为Image组件添加sprite" class="headerlink" title="为Image组件添加sprite"></a>为Image组件添加sprite</h1><p><img src="/2019/08/27/%E3%80%90Unity3d%E3%80%91Unity%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%E7%AC%94%E8%AE%B0/Snipaste_2019-08-27_11-35-00.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity3d</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Unity3d】Space</title>
    <link href="/2019/08/25/%E3%80%90Unity3d%E3%80%91Space/"/>
    <url>/2019/08/25/%E3%80%90Unity3d%E3%80%91Space/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="/2019/08/25/%E3%80%90Unity3d%E3%80%91Space/Unity3d_Space.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity3d</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Unity3d】Lightmap</title>
    <link href="/2019/08/25/%E3%80%90Unity3d%E3%80%91Lightmap/"/>
    <url>/2019/08/25/%E3%80%90Unity3d%E3%80%91Lightmap/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="/2019/08/25/%E3%80%90Unity3d%E3%80%91Lightmap/Unity_Lightmap.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity3d</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络游戏基础</title>
    <link href="/2019/08/25/%E3%80%90%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E3%80%91%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%9F%BA%E7%A1%80/"/>
    <url>/2019/08/25/%E3%80%90%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E3%80%91%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="/2019/08/25/%E3%80%90%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E3%80%91%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%9F%BA%E7%A1%80.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序编程高级</title>
    <link href="/2019/08/25/%E3%80%90%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E3%80%91%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7/"/>
    <url>/2019/08/25/%E3%80%90%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E3%80%91%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="/2019/08/25/%E3%80%90%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E3%80%91%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程序编程原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>物联网通信基础</title>
    <link href="/2019/08/25/%E3%80%90%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E3%80%91%E7%89%A9%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/"/>
    <url>/2019/08/25/%E3%80%90%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E3%80%91%E7%89%A9%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="/2019/08/25/%E3%80%90%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E3%80%91%E7%89%A9%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/%E7%89%A9%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络通信</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt基础</title>
    <link href="/2019/08/25/%E3%80%90Qt%E3%80%91Qt%E5%9F%BA%E7%A1%80/"/>
    <url>/2019/08/25/%E3%80%90Qt%E3%80%91Qt%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>﻿<img src="https://img-blog.csdnimg.cn/20190825185005696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux基础</title>
    <link href="/2019/08/25/%E3%80%90Linux%E3%80%91Linux%E5%9F%BA%E7%A1%80/"/>
    <url>/2019/08/25/%E3%80%90Linux%E3%80%91Linux%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><center>Linux学习笔记</center><h1 id="l-pwd：查看当前所在路"><a href="#l-pwd：查看当前所在路" class="headerlink" title="l  pwd：查看当前所在路"></a>l  <strong>pwd</strong>：查看当前所在路</h1><p>命令格式：命令 -选项 -参数（目录）</p><p>命令：</p><p>ls：查看当前路径下的文件</p><p>选项：</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td><strong>-d</strong></td><td>只查看当前目录的信息</td></tr><tr><td><strong>-l</strong></td><td>查看详细信息</td></tr><tr><td><strong>-a</strong></td><td>显示所有文件（包含隐藏文件）</td></tr><tr><td><strong>-h</strong></td><td>显示文件大小</td></tr></tbody></table><p>例：ls -l     命令 -选项</p><p>选项可以组合：ls -a -l/ls -al：查看所有文件的详细信息</p><p>ls -al /etc/   命令 -选项 -参数 ：查看etc目录下的所有文件的详细信息</p><h1 id="l-cd-：-路径切换"><a href="#l-cd-：-路径切换" class="headerlink" title="l  cd ： 路径切换"></a>l  <strong>cd</strong> <strong>：</strong> <strong>路径切换</strong></h1><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>“**-**”</td><td>返回到之前目录</td></tr><tr><td>“**..**”</td><td>返回上一级目录（“.”当前目录，“..”上一级目录）</td></tr><tr><td>“**~**”</td><td>到用户所在的家目录（家目录：用户所在目录，如windowsC盘的用户目录）</td></tr></tbody></table><p>touch ：cd到临时目录tmp下可创建新文件    touch 文件名</p><h1 id="l-Linux目录结构"><a href="#l-Linux目录结构" class="headerlink" title="l  Linux目录结构"></a>l  <strong>Linux目录结构</strong></h1><table><thead><tr><th>文件名</th><th>作用</th></tr></thead><tbody><tr><td>/boot</td><td>linux启动时，需要的文件</td></tr><tr><td>/dve</td><td>设备文件</td></tr><tr><td>/etc</td><td>配置文件</td></tr><tr><td>/home</td><td>用户家目录</td></tr><tr><td>/media</td><td>媒体文件</td></tr><tr><td>/mnt</td><td>挂载文件</td></tr><tr><td>/opt</td><td>第三方软件</td></tr><tr><td>/proc</td><td>虚拟化文件</td></tr><tr><td>/root</td><td>管理员的家目录</td></tr><tr><td>/run</td><td>远程文件</td></tr><tr><td>/srv</td><td>压缩过的文件</td></tr><tr><td>/sys</td><td>系统文件</td></tr><tr><td>/usr</td><td>安装的软件，</td></tr><tr><td>/var</td><td>可变数据、日志</td></tr><tr><td>/tmp</td><td>临时文件</td></tr><tr><td>/usr/bin</td><td>普通用户可以使用的命令</td></tr><tr><td>/usr/sbin</td><td>超级用户可以使用的命令</td></tr><tr><td>/usr/lib</td><td>32位库文件</td></tr><tr><td>/usr/lib64</td><td>64位库文件</td></tr></tbody></table><h1 id="l-Linux文件处理"><a href="#l-Linux文件处理" class="headerlink" title="l  Linux文件处理"></a>l  <strong>Linux文件处理</strong></h1><h2 id="文件类型判断："><a href="#文件类型判断：" class="headerlink" title="文件类型判断："></a><strong>文件类型判断：</strong></h2><p>-ls -l</p><p><img src="/2019/08/25/%E3%80%90Linux%E3%80%91Linux%E5%9F%BA%E7%A1%80/1.png" alt="img"></p><table><thead><tr><th>文件以“_”开头</th><th>文件类型</th></tr></thead><tbody><tr><td>“d”</td><td>目录</td></tr><tr><td>“-”</td><td>文件</td></tr><tr><td>“l”</td><td>链接文件（类似win中快捷方式）</td></tr><tr><td>“b”</td><td>设备文件，提供存储接口的设备</td></tr><tr><td>“c”</td><td>设备文件，提供串行结合口的设备—键盘</td></tr></tbody></table><h2 id="文件处理："><a href="#文件处理：" class="headerlink" title="文件处理："></a><strong>文件处理：</strong></h2><p><img src="/2019/08/25/%E3%80%90Linux%E3%80%91Linux%E5%9F%BA%E7%A1%80/2.png" alt="img"></p><p>cp            cp abc a：复制abc并命名为a/多文件复制：cp a abc goulandis/：复制a、abc到goulandis下</p><p>mv            mv 文件1 文件2：将文件1更名为文件2/mv 文件1（文件2 ….） 目录：将文件移动到目录下                 </p><p>rm             rm -f 文件1 （文件2…）：强制删除</p><p>mkdir       mkdir -p （要创建的）目录1/（要创建的）目录2：创建目录1并在目录1下创建目录2</p><h2 id="查看文件："><a href="#查看文件：" class="headerlink" title="查看文件："></a><strong>查看文件：</strong></h2><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><strong>cat/**</strong>路径**</td><td>查看文件</td></tr><tr><td>nl</td><td>显示的时候，顺便出现行号</td></tr><tr><td>tac</td><td>从最后一行开始显示</td></tr><tr><td>head</td><td>显示文件前10行 -n：设置行数</td></tr><tr><td>tail</td><td>显示文件尾10行 -n：设置行数</td></tr><tr><td>wc</td><td>显示文件行数，数字，字节</td></tr><tr><td>more</td><td>一页一页翻动</td></tr><tr><td><strong>less</strong></td><td>一页一页翻动</td></tr></tbody></table><table><thead><tr><th><strong>cat**</strong>和tac**<strong>选项</strong></th><th>作用</th></tr></thead><tbody><tr><td>-A</td><td>整合命令-vET（整合-v、-E、-T）</td></tr><tr><td>-b</td><td>列出行号，但是空白行不标志行号</td></tr><tr><td>-E</td><td>将结尾的断行字符（$）显示出来</td></tr><tr><td>-n</td><td>列出行号，空白行也会标志出来</td></tr><tr><td>-T</td><td>将tab键以^I显示</td></tr><tr><td>-v</td><td>列出一些看不出来的字符</td></tr><tr><td>&lt;区分大小写&gt;</td><td></td></tr></tbody></table><table><thead><tr><th><strong>nl**</strong>的选项**</th><th></th><th></th></tr></thead><tbody><tr><td>总选项</td><td>分选项</td><td>作用</td></tr><tr><td>b</td><td>ba</td><td>无论是否有空，都列出行号</td></tr><tr><td>bt</td><td>如果有空行，则不列出行号（默认）</td><td></td></tr><tr><td>n</td><td>nln</td><td>行号在屏幕最左方</td></tr><tr><td>nrn</td><td>行号在屏幕最右方，前面不加0</td><td></td></tr><tr><td>nrz</td><td>行号在屏幕最右方，前面加0</td><td></td></tr><tr><td>w</td><td></td><td>缩进多少位</td></tr></tbody></table><table><thead><tr><th><strong>more**</strong>的选项**</th><th>作用</th></tr></thead><tbody><tr><td>空格</td><td>向下翻一页</td></tr><tr><td>回车</td><td>向下翻一行</td></tr><tr><td>/字符串</td><td>搜索</td></tr><tr><td>:f</td><td>立刻显示文件名和行数</td></tr><tr><td>b</td><td>翻到第一页</td></tr><tr><td>q</td><td>离开</td></tr></tbody></table><table><thead><tr><th><strong>less**</strong>的选项**</th><th>作用</th></tr></thead><tbody><tr><td><strong>空格</strong></td><td>向下翻动一行</td></tr><tr><td><strong>回车</strong></td><td>向下翻动一页</td></tr><tr><td><strong>pagedown</strong></td><td>向下翻动一页</td></tr><tr><td><strong>pageup</strong></td><td>向上翻动一页</td></tr><tr><td><strong>n</strong></td><td>重复前一个搜索（操作：n）</td></tr><tr><td><strong>N</strong></td><td>反向重复前一个搜索（操作：shift+n）</td></tr><tr><td><strong>q</strong></td><td>退出</td></tr></tbody></table><table><thead><tr><th>head和tail的选项</th><th>作用</th></tr></thead><tbody><tr><td>-n</td><td>指定显示几行，默认10行</td></tr><tr><td>日志文件路径（/var/log/messages）</td><td>查看日志</td></tr></tbody></table><table><thead><tr><th>wc的选项</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>只显示字节</td></tr><tr><td>-w</td><td>只显示字数，一个字被定义为空白、跳格、换行字符、分隔字符串</td></tr><tr><td>-l</td><td>只显示行</td></tr></tbody></table><table><thead><tr><th><strong>Vim编辑器操作命令</strong></th><th>作用</th></tr></thead><tbody><tr><td><strong>i</strong></td><td>插入</td></tr><tr><td><strong>esc</strong></td><td>退出</td></tr><tr><td><strong>u</strong></td><td>撤销</td></tr><tr><td><strong>x</strong></td><td>删除</td></tr><tr><td><strong>v</strong></td><td>选择文本</td></tr><tr><td><strong>y</strong></td><td>复制</td></tr><tr><td><strong>yy</strong></td><td>复制当前行</td></tr><tr><td><strong>dd</strong></td><td>删除光标所在行</td></tr><tr><td><strong>p</strong></td><td>粘贴</td></tr><tr><td><strong>:w</strong></td><td>保存</td></tr><tr><td><strong>:wq</strong></td><td>保存并退出</td></tr><tr><td><strong>:q**</strong>！**</td><td>强制退出</td></tr></tbody></table><h2 id="软链接："><a href="#软链接：" class="headerlink" title="软链接："></a><strong>软链接：</strong></h2><p><img src="/2019/08/25/%E3%80%90Linux%E3%80%91Linux%E5%9F%BA%E7%A1%80/3.png" alt="img"></p><p><img src="/2019/08/25/%E3%80%90Linux%E3%80%91Linux%E5%9F%BA%E7%A1%80/4.png" alt="img"></p><h2 id="硬链接："><a href="#硬链接：" class="headerlink" title="硬链接："></a><strong>硬链接：</strong></h2><p><img src="/2019/08/25/%E3%80%90Linux%E3%80%91Linux%E5%9F%BA%E7%A1%80/5.png"></p><p>ls -I ：查看Inode编号</p><h1 id="l-关机操作"><a href="#l-关机操作" class="headerlink" title="l  关机操作"></a>l  <strong>关机操作</strong></h1><table><thead><tr><th>sync</th><th>数据同步写入磁盘</th></tr></thead><tbody><tr><td><strong>shutdown</strong></td><td>常用关机指令</td></tr><tr><td>reboot、halt、poweroff</td><td>重启，关机</td></tr></tbody></table><table><thead><tr><th>shutdown的指令</th><th>作用</th></tr></thead><tbody><tr><td>-t</td><td>添加秒数。几秒后关机</td></tr><tr><td>-k</td><td>不是真关机，二十发出警告信息</td></tr><tr><td><strong>-r</strong></td><td>在系统服务都停止后，重启</td></tr><tr><td><strong>-h</strong></td><td>在系统服务都停止后，关机</td></tr><tr><td>-f</td><td>关闭，并且开机一个后强行略过磁盘检查</td></tr><tr><td>-F</td><td>重启后强制进行磁盘检查</td></tr><tr><td>-c</td><td>取消已经在进行的shutdown指令内容</td></tr><tr><td></td><td>shutdown -h now    现在马上停止服务并关机   shutdown -h 12：00       在12：00时刻停止服务并关机   shutdown -h +10     十分钟以后停止服务并关机   shutdown -r now     现在马上停止服务并重启   shutdown -r +30 ‘the system will reboot’       先发一个警告信息“the system will reboot”，系统将要在30分钟后重启   shutdown -k now ‘the system will reboot’     现在马上发出一个警告信息“the system will reboot”</td></tr></tbody></table><h1 id="l-Linux文件权限"><a href="#l-Linux文件权限" class="headerlink" title="l  Linux文件权限"></a>l  <strong>Linux文件权限</strong></h1><p><img src="/2019/08/25/%E3%80%90Linux%E3%80%91Linux%E5%9F%BA%E7%A1%80/6.png" alt="img"></p><table><thead><tr><th>权限</th><th>连接</th><th>所有者</th><th>所属组</th><th>容量（默认单位B）</th><th>修改日期</th><th>文件名</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th><strong>文件的权限</strong></th><th></th></tr></thead><tbody><tr><td>r、w、x ： 读、写、执行，没有权限就是-</td><td></td></tr><tr><td>第一组rwx</td><td>文件所有者的权限</td></tr><tr><td>第二组rwx</td><td>文件所属组的权限</td></tr><tr><td>第三组rwx</td><td>文件其他人的权限</td></tr></tbody></table><table><thead><tr><th><strong>目录的权限</strong></th><th></th></tr></thead><tbody><tr><td>r</td><td>具有读取目录的结构列表的权限，可以查看目录下有哪些文件</td></tr><tr><td>w</td><td>该权限对于目录来说是很大的</td></tr><tr><td>1</td><td>可以在该目录下新建新的文件和目录</td></tr><tr><td>2</td><td>可以删除已存在的文件和目录</td></tr><tr><td>3</td><td>将已存在的文件和目录重命名</td></tr><tr><td>4</td><td>移动该目录内的文件和目录的位置</td></tr><tr><td>X</td><td>是否可以进入该目录</td></tr></tbody></table><table><thead><tr><th><strong>文件权限的修改</strong></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>命令</td><td>命令作用</td><td>格式</td><td>选项</td><td>选项作用</td><td></td></tr><tr><td>chown</td><td>修改文件的拥有者，前提是要有该拥有者</td><td>chown 拥有者   文件/目录</td><td>-R</td><td>递归修改</td><td></td></tr><tr><td>chgrp</td><td>修改文件所属组，前提是要有该组</td><td></td><td>-R</td><td>递归修改</td><td></td></tr><tr><td>chmod</td><td>修改拥有者和所属组的权限</td><td></td><td></td><td></td><td></td></tr><tr><td>加减法</td><td>chmod    u/g/o+/-/=r/w/x 123：   将文件1213给用户/组/其他人加/减/赋予一个读/写/执行权限</td><td></td><td></td><td></td><td></td></tr><tr><td>数字法</td><td>r=4    w=2  x=1 ： chmod  632 123 ：   将文件123给用户赋予r和w权限，给组赋予wx权限，给其他人赋予w权限</td><td></td><td></td><td></td><td></td></tr><tr><td>chown -R goulandis 123 ： 将123目录下的所有文件包括目录本身的拥有者修改为goulandis</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p><strong>默认权限：</strong></p><p>umask      查看当前用户的umask权限       </p><p>umask –(选项) ：临时修改默认权限</p><p>/etc/bashrc ： 永久修改默认权限（通过修改脚本文件实现）</p><p>umask的选项说明</p><p>0022         拿走的权限</p><p>​         第一个数字表示特殊权限</p><p>​         022=rwxr-xr-x ：不拿走用户的权限、拿走用户组的w权限、拿走其他用户的w权限</p><p>目录无法拿走x权限</p><p>普通用户umask值 0002</p><p>root用户umask值 0022</p><h2 id="文件的特殊权限"><a href="#文件的特殊权限" class="headerlink" title="文件的特殊权限:"></a><strong>文件的特殊权限:</strong></h2><p><img src="/2019/08/25/%E3%80%90Linux%E3%80%91Linux%E5%9F%BA%E7%A1%80/7.png" alt="img"></p><p>当s出现在拥有者的x权限的位置时，表示拥有者有SUID的权限（Set UID）</p><p>当s出现在用户组的x权限的位置时，表示用户组有SGID的权限（Set GID）</p><p>当s出现在其他人的x权限的位置时，表示其他人有SBIT的权限（Sticky Bit）</p><table><thead><tr><th>SUID</th><th>临时获取文件拥有者的权限—–只能针对文件</th></tr></thead><tbody><tr><td>SGID</td><td>可以作用于目录，也可以作用于文件</td></tr><tr><td>作用于文件 ： 和SUID作用一样</td><td></td></tr><tr><td>作用与目录 ： 继承父级目—–目录会不停的继承，下级目录会一直继承父级目录的权限值</td><td></td></tr><tr><td>SBIT</td><td>只有文件的拥有者才能删除修改该目录下的文件—–只能针对目录</td></tr><tr><td>S和T有大小写之分   大写 ： 没有x权限   小写 ： 有x权限</td><td></td></tr><tr><td>数字法 ：SUID=4、SGID=2、SBIT=1</td><td></td></tr></tbody></table><p><img src="/2019/08/25/%E3%80%90Linux%E3%80%91Linux%E5%9F%BA%E7%A1%80/8.png" alt="img"></p><h1 id="l-Linux进程"><a href="#l-Linux进程" class="headerlink" title="l  Linux进程"></a>l  <strong>Linux进程</strong></h1><p>进程 ：已经启动的可执行程序的运行实例</p><p>PID : 进程的ID（每一个进程都有唯一的PID）</p><p>PPID ： 父进程的ID</p><p>任何一个进程都可以创建紫进程</p><table><thead><tr><th>ｐｓ　：　查看当前的进程情况</th><th></th></tr></thead><tbody><tr><td>选项</td><td>作用</td></tr><tr><td>－ａｕｘ／ａｕｘ</td><td>列出所有进程</td></tr><tr><td>－ｅｆ</td><td>列出所有进程</td></tr><tr><td>－ｌ</td><td>列出和当前用户有关的进程</td></tr><tr><td>－ｕ</td><td>查看某一用户的进程</td></tr><tr><td>－ｔｏｐ</td><td>实时查看进程状况</td></tr></tbody></table><p><img src="/2019/08/25/%E3%80%90Linux%E3%80%91Linux%E5%9F%BA%E7%A1%80/9.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#高级</title>
    <link href="/2019/08/25/%E3%80%90C#%E3%80%91C#%E9%AB%98%E7%BA%A7/"/>
    <url>/2019/08/25/%E3%80%90C#%E3%80%91C#%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20190825170050917.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190825170113521.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20190825170131207.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#中级</title>
    <link href="/2019/08/25/%E3%80%90C#%E3%80%91C#%E4%B8%AD%E7%BA%A7/"/>
    <url>/2019/08/25/%E3%80%90C#%E3%80%91C#%E4%B8%AD%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<p>﻿<img src="https://img-blog.csdnimg.cn/20190825154217891.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C++】C++进阶</title>
    <link href="/2019/08/23/%E3%80%90C++%E3%80%91C++%E8%BF%9B%E9%98%B6/"/>
    <url>/2019/08/23/%E3%80%90C++%E3%80%91C++%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>﻿1.C++介绍：<br>    C语言作为结构化和模块化语言适合规模较小的程序，对于大规模的复杂程序，能够高度抽象和建模的C++则更加适合，C++是C语言的加强版，以C语言为基础，并且完全兼容C语言的特性。<br><img src="https://img-blog.csdnimg.cn/20190623193001260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2.C++对C语言的增强语法<br>    2.1.命名空间<br>    2.2.引用<br>    2.3.函数与运算符的重载<br>    2.4.面向对象的特性<br>    2.5.泛型编程<br>    2.6.异常处理<br>    2.7.标准模板库<br>下面笔者就者7个特性进行详细说明：<br>3.命名空间<br>    命名空间是C++提供的一种解决不同文件互相调用时符号名字冲突的方法，一个命名空间就是一个作用域，在不同的命名空间下允许相同的名字符号代表不同的实体。<br>    3.1命名空间的定义<br><img src="https://img-blog.csdnimg.cn/20190623200228628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>        注意：命名空间的声明要在类和函数的外面定义，并且没有分号结束。<br>        3.2.命名空间成员的引用<br>            命名空间名::成员名<br>    如：<br>    1.cpp<br>#include<iostream><br>using namesapce std;<br>/*<br>命名空间的声明方式，我们需要用到命名空间中的什么方法就在{}内加入什么方法的声明，当然直接使用“using namespace A”来声明A命名空间也是可以的，但是这种命名方法会将A命名空间下的所有方法都作声明，包括我们可能没有使用的方法，当工程很大时，这种做法会导致代码臃肿。<br><em>/<br>namespace A {<br>    int add(int a,int b);<br>}<br>int add(int a,int b);<br>int mian(){<br>    int a = 1,b = 1;<br>/</em><br>在很多多人编程的时候，如果各程序员之间不一直进行密切的交流，极容易出现变量名或方法名类名等相同的情况，这样    在；多文档联合编译时，编译器会无法区分同名符号而报错，而命名空间就很好的解决了这种问题，我们为各个文档都定义一个唯一的命名空间，这样即使是相同符号也可以通过命名空间唯一标识了，命名空间的出现极大的改善了多人编程的困处<br><em>/<br>    cout &lt;&lt; add(a,b)&lt;&lt;”  “&lt;&lt;A::add(a,b)&lt;&lt; endl;<br>    return 0;<br>    }<br>int add(int a,int b){<br>    return(a + b);<br>}<br>    2.cpp<br>#include<iostream><br>namespace A {<br>    int add(int a,int b){<br>        return(a + b)；<br>    }<br>}<br>3.3.命名空间的别名<br>    命名空间是可以另起别命的，别命是已定义的命名空间的可代替的名字，一个命名空间可以有很多个别名，所有的别命和命名空间原名可以互换使用<br>    别命的定义：namespace 别命 = 命名空间原名;<br>    <img src="https://img-blog.csdnimg.cn/2019062320111766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    3.4.命名空间的成员类型<br>        命名空间的成员类型可以是变量、常量、函数、结构体、联合体、枚举、类、嵌套的命名空间<br>    3.5.全局命名空间<br>        在全局作用域中定义的命名空间，大多数命名空间都属于全局命名空间。即自定义的命名空间是全局命名空间的扩张和细分。全局命名空间是隐式声明的，它存在于每一个程序中。<br>        由于全局命名空间是隐含的，它没有名字，所以使用“::成员名字”引用全局命名空间。<br>    3.6.匿名命名空间<br>        匿名命名空间与全局命名空间类似，也没有名字，但是匿名命名空间定义在局部作用域，不能用于多文件编译。<br>        匿名命名空间可以直接使用变量名引用成员。<br>    4.引用<br>        4.1.什么是引用？<br>            引用即别命，是某一个变量或对象的别命，绑定一个引用到一个变量或对象，即引用初始化，之后对引用的操作完全等价于对与其绑定的变量或对象的操作。<br>    4.2.引用的定义<br>        类型 &amp;引用名 = 目标变量名;<br>        需要注意的是：<br>            - &amp;不是求地址运算符，而是起标志作用<br>            - 引用的类型必须和其所绑定的变量类型相同<br>            - 声明应用的同时必须对其初始化，否则系统会报错<br>            - 引用相当于变量或对象的别命，因此不可将已绑定的引用再绑定其他变量或对象，也不可将一个引用绑定另一个引用。<br>    4.3.引用与指针的区别<br>        +占用存储空间上：<br>                    -引用占用一个地址空间，本地计算机的一个地址空间是多少位，引用就占多少位的地址空间。<br>                    -而指针除了占用一个地址空间外，还占用一个数据空间用于存储其指向的变量或对象的地址。<br>        +在操作上：<br>                    -引用声明的同时必须对其初始化，且初始化后引用不可更改，引用不能为空。如：int &amp;a ;是错误的用法，正确的用法应该是：int &amp;a = b;<br>                    -指针的声明可以在任何时候初始化，且指针在后续操作中可以变更其指向的变量或对象，指针可以为空。<br>        +存储内容上<br>                    -“sizeof引用”得到的是引用所指向的变量或对象的大小<br>                    -“sizeof指针”得到的是指针本身的大小<br>        +层级上<br>                    -引用只能有一级，引用不可以再指向引用<br>                    -指针理论上对级数没有限制<br>        +可以将引用理解为不可更改的指针，即：类型</iostream></em> const 指针变量<br>    4.4.对数组的引用<br>        类型 （&amp;引用名）[数组下标] = 数组名;<br>        如：对int a[3]数组的引用为int (&amp;quote)[3] = a;即将引用名替换成数组名。<br>        这里要注意，“()”是不能省略的，因为如果省略()，则会改变优先级，变成int &amp;(quote[3]) = a;而出现语法错误。<br>    4.5.对指针的引用<br>        类型* &amp;引用名 = 指针名;<br>        如：int* &amp;quote = p;<br>    4.6.引用的作用<br>        引用既可以作为别命使用，还可以作为函数的参数、函数的返回值使用。<br>        需要注意的是，引用作为函数的返回值时不能返回局部变量的引用。<br>    至此，我可能提出这样的疑问：引用能做的事指针也能做，引用不能做的事指针还能做，那么C++么什么要引入“引用”这个概念呢？<br>    这是因为，指针的操作太过于强大，正因如此对指针的使用存在一定的风险，所谓“收益与风险并存”，在很多高版本的编译器中已经不能再操作指针了，如VS2015，而C++之所以还保留着指针，是因为指针的魅力无比诱人，尽管有风险却不愿意就此抛弃。<br>    引用的另一个用处我们举一个例子来说明<br>    如：<br>    int add_1(int b){<br>        b++;<br>    }<br>    int add_2(int &amp;c){<br>        c++;<br>    }<br>    void mian(){<br>        int a = 1;<br>        int &amp;a = a;<br>        cout&lt;&lt;add_1(a)&lt;&lt;endl;<br>        cout&lt;&lt;add_2(&amp;a)&lt;&lt;endl;<br>    }<br>    我们的输出结果是：1 2，为什么呢?因为普通的参数传递，传递的是参数的拷贝，如add_1我们对b++，实际进行运算的是形参b，而实参a却没有发生运算，所以cout&lt;&lt;add_1(a)输出1，而如果传递引用的话，我们在函数add_2中对引用的操作实质上就是对a进行运算，因为&amp;a就是a。<br>    4.7.常引用<br>        const 类型 &amp;引用名 = 目标变量名<br>        常引用可以引用常量也可以引用变量，常引用不允许通过引用对其绑定的变量或对象进行修改。<br>        <img src="https://img-blog.csdnimg.cn/2019062512243728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">5.函数重载<br>    5.1.C++重载的实现<br>    从本质上来说，C++之所以能实现函数的重载是因为C++编译器对函数名的处理方法进行了优化，我们来对比一下C语言编译器和C++编译器对函数名的编译<br>    +C语言编译器<br>        对函数 int add(int a);编译后的名字为：add<br>    +C++编译器<br>        对函数int add(int a);编译后的名字为：addi，对int add(int a,float b);编译后的名字为：addij，C++编译器使用函数名和参数类型的共同组合成编译后函数的唯一标识，即可实现函数的重载。<br>    5.2.重载的定义<br>        重载就是在相同的声明域中函数名相同而参数列表不同，通过函数的参数表唯一标识的函数。<br>    5.3.函数的默认参数<br>        C++可以使用默认参数，即在函数声明时为参数提供一个默认值，当函数调用时没有指定这个参数的值时，编译器会自动使用默认值替换。<br>        <img src="https://img-blog.csdnimg.cn/20190625221621705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>        需要注意的是，默认参数只能放在声明或定义处，能放在声明处就放在声明处。如果某个参数是默认参数，那么其后的参数也必须都是默认参数，如：int add(int a = 1,int b,int c);编译器将报错，而int add(int a,int b = 1,int c = 2);则不会报错，因为参数在传递的时候是从左到右的，首先使用无默认参数的参数列表，当遇到没有传入实参的形参时开始使用默认参数的参数列表。使用默认参数的情况仅限于用在没有没有重载冲突的函数上，如：重载add函数，int add(){…} int add(int a = 1,int b = 2){…},此时调用add();将调用不带参数的add()函数。<br>        <img src="https://img-blog.csdnimg.cn/20190625222013457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">5.4.内联函数<br>    5.4.1.为什么需要内联函数？<br>        在程序执行的过程中，当碰到函数调用时，系统要将程序当前状态保存到栈中，同时跳转到函数代码处执行函数体，此过程需要占用时间和空间，是的程序执行效率低下。当然我们声明一个内联函数只是建议编译器将此函数作为内联函数，但是编译器有自己的判断算法，在编译时编译器会自行判断我们声明的内联函数是否值得变为内联函数，以保证主程序体不会过于臃肿，所以我们声明的内联函数不一定会成为内联函数。<br>    5.4.2.内联函数的定义<br>        inline 返回值类型 函数名(参数列表){函数体;}<br>    5.4.3.内联函数是一种用空间换时间的措施，通常只有较短的函数才定义为内联函数。<br>6.new和delete运算符<br>    6.1.new运算符的功能是在堆区分配内存，通过new运算符获得的内存空间都处于堆上。delete运算符的功能正好与new相反，delete运算符的功能是释放new运算符的在堆区创建的内存，new运算符与delete运算符最好是配套出现，即使用new运算符创建了内存就一定要用delete运算符在不需要的时候此内存的时候将其释放，为什么呢？因为堆区的内存是不会随着程序结束而释放的，堆区的内存只要在操作系统关闭时才会释放，所以如果不手动释放new运算符在堆区创建的内存，则会造成大量无用数据占据着堆区内存，当堆区内存被占满时这会出现系统无堆区内存可用而出现系统死机。<br>    6.2.new/delete运算符的使用<br>        new &lt;数据类型&gt; (参数)<br>        delete &lt;对象指针&gt;/delete &lt;对象数组指针&gt;<br>        <img src="https://img-blog.csdnimg.cn/201907121654256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    6.3.那么C++的new/delete与C语言的malloc/free有什么区别呢？<br>        -它们都是动态管理内存的入口<br>        -malloc/free是C/C++标准库函数，而new/delete是C++操作符<br>        -malloc/free只是动态分分配/释放内存空间，而new/delete除了分配内存空间还会调用构造/析构函数进行初始化/清理（清理成员）<br>        -malloc/free需要手动计算类型大小且返回值为void，而new/delete可以自行计算类型大小返回对应类型的指针<br>        -new/delete在底层是调用了malloc/free的。可以认为是C++对malloc/free的封装<br>        -malloc/free申请空间后需要判空，new/delete则不需要<br>        -new直接跟类型，malloc跟字节数。<br>        new/delete和malloc/free的区别是C++企业招聘时特别喜欢考的一项<br>7.程序的内存空间<br>    7.1.指针的内存操作<br>        -指针不仅可以可以指向变量还可以指向函数<br>        -有new运算符在堆区创建的内存空间由位于栈区的指针确定入口<br>    <img src="https://img-blog.csdnimg.cn/20190712165857369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>说到这，我们有必要了解一下计算机程序的内存结构，供程序运行的内存空间分为：堆区、栈区、.data段、.bss段、.ro段、.txt段，我使用一张图来说明<br><img src="https://img-blog.csdnimg.cn/20190712170749180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>8.面向对象编程的特点<br><img src="https://img-blog.csdnimg.cn/2019071310135053.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>9.C++中的类<br>    9.1.类的定义<br><img src="https://img-blog.csdnimg.cn/2019071310150942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    9.2.访问权限<br>        C++为类的成员添加了三种访问权限<br>        -public–公有成员：权限最高，在public修饰下的成员是类的外部接口，可以被类的成员函数和对象直接访问。<br>        -protected–保护成员：权限居中，可以被类的成员函数和其派生类的成员函数直接访问，但不能被类的对象和派生类的对象直接访问。<br>        -private–私有成员：权限最低，只能通过类的成员函数访问。<br>    9.3.类的成员<br>        -成员变量：类的成员变量用以描述一个对象的属性信息，与一般的变量声明相同，但类的成员变量只能在类的声明体中定义，类的成员变量一般在类的构造函数中初始化，但这不是必须的。<br>        -成员函数：用来描述一个对象的行为动作，与一般的函数声明相同，但只能放在类的声明体中声明，成员函数可以在类内实现也可以在类外实现，但在类内实现则形成内联的成员函数，会使类变得冗杂，所以成员函数的实现最好在类外实现，类成员函数可以重载和带默认参数。<br>    9.5.类的成员函数与成员变量的声明与实现<br>    <img src="https://img-blog.csdnimg.cn/20190713104139644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    9.6.struct和class的区别<br>        -C++对struct关键字扩展了其功能，和class的功能几乎等价<br>        -struct的成员默认访问权限是public，而class是private<br>    9.7.this指针<br>        -this指针是一个特殊的指针，指向对象的自身的首地址<br>        -每一个对象的成员函数都有一个this指针，指向调用的对象，如果要引用整个对象则通过*this引用<br>        -this指针仅能在类的内部使用，即只能在类的声明体或成员函数中使用<br>    9.8.static关键字<br>        9.8.1.static修饰的成员变量–静态成员变量<br>                    -static修饰的变量存储在静态变量区<br>                    -在类中static关键字修饰的变量被此类的所有对象共享，即所有对象共享这一个变量<br>                    -static修饰的变量必须在类外初始化，不可以在定义的时候直接初始化<br>                    -static修饰的公有成员变量可以直接通过类名来访问，没有staic修饰的成员变量只能通过对象才能访问<br>        <img src="https://img-blog.csdnimg.cn/20190713105202141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>        9.8.2.static修饰的成员函数–静态成员函数<br>                    -static修饰的成员函数也可以直接通过类名访问<br>                    -静态成员函数只能访问静态成员变量<br>        9.8.3.类的静态与非静态部分<br>                    -静态部分只属于类，与类一起存放在内存的静态区，被所有对象共享<br>                    -非静态部分属于对象，每个对象都有自己的非静态部分，互不影响<br>                    -静态部分只能直接访问静态部分，非静态部分可以访问所有部分<br>                    那么为什么静态部分只能直接访问静态部分，而非静态部分却可以访问所有部分呢？<br>                    那是因为，非静态成员变量/函数是属于对象的，只能通过对象来访问，而静态部分是属于类的，使用静态部分时没有确定对象的存在，所以不能确定静态部分应该访问哪个对象的非静态部分，而静态部分是属于类的，所有对象共享，所以通过对象使用非静态部分时，可以访问静态部分。<br>    思导图：<br><img src="https://img-blog.csdnimg.cn/20190623192350471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190712170853343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></iostream></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Unity3d】游戏截屏</title>
    <link href="/2019/08/23/%E3%80%90Unity3d%E3%80%91%E6%B8%B8%E6%88%8F%E6%88%AA%E5%B1%8F/"/>
    <url>/2019/08/23/%E3%80%90Unity3d%E3%80%91%E6%B8%B8%E6%88%8F%E6%88%AA%E5%B1%8F/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer">﻿<p>在Unity3d中游戏截屏操作比较简单，主要使用通过Application类下的CaptureScreenhot方法实现：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (Input.<span class="hljs-constructor">GetKeyDown(KeyCode.P)</span>) &#123;<br>            Application.<span class="hljs-constructor">CaptureScreenshot(<span class="hljs-string">&quot;截图&quot;</span> +<span class="hljs-params">screenhotNom</span>+<span class="hljs-string">&quot;.jpg&quot;</span>)</span>;<br>            screenhotNom++;<span class="hljs-comment">//截图序号</span><br>        &#125;<br></code></pre></td></tr></table></figure><p>截取的图片以设计者规定名字存储在与exe文件一起生成的的Data文件下，没有导出的项目直接存储到工程文件夹下<br><img src="https://img-blog.csdnimg.cn/20190622155156312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity3d</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Unity3d】简单的存档与读档</title>
    <link href="/2019/08/23/%E3%80%90Unity3d%E3%80%91%E5%AD%98%E6%A1%A3%E4%B8%8E%E8%AF%BB%E6%A1%A3/"/>
    <url>/2019/08/23/%E3%80%90Unity3d%E3%80%91%E5%AD%98%E6%A1%A3%E4%B8%8E%E8%AF%BB%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer">﻿<p>在Unity3d中，游戏的存档与读档主要由PlayerPrefs类来完成，在Windows下PlayerPrefs存档主要存储在注册表中，路径为HKCU\Software[company name][product name] ，这里的company name和product name由作者自己确定，在Edit-&gt;Project Settings-&gt;Player中可以设置<br><img src="https://img-blog.csdnimg.cn/20190622143530421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>PlayerSettings视图<br><img src="https://img-blog.csdnimg.cn/20190622143747327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>那么如何设计游戏存档呢？<br>以笔者个人的经验而言，在游戏设计之初，我们就应该想好需要存档的数据，为需要保存的数据或状态设计可供读取的状态标志，以便以后在设计存档时，提供给PlayerPrefs类的方法使用。<br>PlayerPrefs类提供如下方法供设计者使用<br><img src="https://img-blog.csdnimg.cn/20190622144312778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到，PlayerPrefs类中没有提供对bool型数据的存储方法，由此可以看出为需要保存的数据或状态设计可供读取的状态标志的重要性，否则那些由bool型数据确定的状态将无法被存档。<br><img src="https://img-blog.csdnimg.cn/20190622151126795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下面给一段示例代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    * inventory.charge--int--能量电池数量</span><br><span class="hljs-comment">    * inventory.playerTransform--float--玩家位置</span><br><span class="hljs-comment">    * talk.yeshu--int--man的任务进度</span><br><span class="hljs-comment">    * talk.wyeshu--int--women的任务进度</span><br><span class="hljs-comment">     */</span><br>   void game<span class="hljs-constructor">Save()</span> &#123;<br>       PlayerPrefs.<span class="hljs-constructor">SetInt(<span class="hljs-string">&quot;charge&quot;</span>, <span class="hljs-params">inventory</span>.<span class="hljs-params">charge</span>)</span>;<br>       PlayerPrefs.<span class="hljs-constructor">SetInt(<span class="hljs-string">&quot;yeshu&quot;</span>, <span class="hljs-params">talk</span>.<span class="hljs-params">yeshu</span>)</span>;<br>       PlayerPrefs.<span class="hljs-constructor">SetInt(<span class="hljs-string">&quot;wyeshu&quot;</span>, <span class="hljs-params">talk</span>.<span class="hljs-params">wyeshu</span>)</span>;<br>       PlayerPrefs.<span class="hljs-constructor">SetFloat(<span class="hljs-string">&quot;playerPosition.x&quot;</span>, <span class="hljs-params">inventory</span>.<span class="hljs-params">playerTransform</span>.<span class="hljs-params">position</span>.<span class="hljs-params">x</span>)</span>;<br>       PlayerPrefs.<span class="hljs-constructor">SetFloat(<span class="hljs-string">&quot;playerPosition.y&quot;</span>, <span class="hljs-params">inventory</span>.<span class="hljs-params">playerTransform</span>.<span class="hljs-params">position</span>.<span class="hljs-params">y</span>)</span>;<br>       PlayerPrefs.<span class="hljs-constructor">SetFloat(<span class="hljs-string">&quot;playerPosition.z&quot;</span>, <span class="hljs-params">inventory</span>.<span class="hljs-params">playerTransform</span>.<span class="hljs-params">position</span>.<span class="hljs-params">z</span>)</span>;<br>       PlayerPrefs.<span class="hljs-constructor">Save()</span>;<br>   &#125;<br>   void game<span class="hljs-constructor">Read()</span> &#123;<br>       <span class="hljs-keyword">if</span> (PlayerPrefs.<span class="hljs-constructor">HasKey(<span class="hljs-string">&quot;charge&quot;</span>)</span>)<span class="hljs-comment">//存档读取的一般方式</span><br>           inventory.charge = PlayerPrefs.<span class="hljs-constructor">GetInt(<span class="hljs-string">&quot;charge&quot;</span>)</span>;<br>       <span class="hljs-keyword">if</span> (PlayerPrefs.<span class="hljs-constructor">HasKey(<span class="hljs-string">&quot;yeshu&quot;</span>)</span>)<br>           talk.yeshu = PlayerPrefs.<span class="hljs-constructor">GetInt(<span class="hljs-string">&quot;yehsu&quot;</span>)</span>;<br>       <span class="hljs-keyword">if</span> (PlayerPrefs.<span class="hljs-constructor">HasKey(<span class="hljs-string">&quot;wyeshu&quot;</span>)</span>)<br>           talk.wyeshu = PlayerPrefs.<span class="hljs-constructor">GetInt(<span class="hljs-string">&quot;wyeshu&quot;</span>)</span>;<br>       <span class="hljs-keyword">if</span> (PlayerPrefs.<span class="hljs-constructor">HasKey(<span class="hljs-string">&quot;playerPosition.x&quot;</span>)</span>)<br>           x = PlayerPrefs.<span class="hljs-constructor">GetFloat(<span class="hljs-string">&quot;playerPosition.x&quot;</span>)</span>;<br>       <span class="hljs-keyword">if</span> (PlayerPrefs.<span class="hljs-constructor">HasKey(<span class="hljs-string">&quot;playerPosition.y&quot;</span>)</span>)<br>           y = PlayerPrefs.<span class="hljs-constructor">GetFloat(<span class="hljs-string">&quot;playerPosition.y&quot;</span>)</span>;<br>       <span class="hljs-keyword">if</span> (PlayerPrefs.<span class="hljs-constructor">HasKey(<span class="hljs-string">&quot;playerPosition.z&quot;</span>)</span>)<br>           z = PlayerPrefs.<span class="hljs-constructor">GetFloat(<span class="hljs-string">&quot;playerPosition.z&quot;</span>)</span>;<br>       inventory.playerTransform.position = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Vector3(<span class="hljs-params">x</span>, <span class="hljs-params">y</span>, <span class="hljs-params">z</span>)</span>;<br><br>   &#125;<br></code></pre></td></tr></table></figure><p>那么对于已经产生的注册表我们如何查看呢？<br>在Windows下通过注册表编辑器查看注册表，通过Win+R将呼出“运行”，输入“regedit”即可打开注册表编辑器在HKCU\Software[company name][product name] 路径下即可找到我们已经生成的注册表<br><img src="https://img-blog.csdnimg.cn/20190622151747405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity3d</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Unity3d】Animation</title>
    <link href="/2019/08/23/%E3%80%90Unity3d%E3%80%91Animation/"/>
    <url>/2019/08/23/%E3%80%90Unity3d%E3%80%91Animation/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>﻿1.总索引<br><img src="https://img-blog.csdnimg.cn/2019061314131628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>1.1.视图简介<br><img src="https://img-blog.csdnimg.cn/20190520144632375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190520143240580.png" alt="在这里插入图片描述"><br>2.动画分类<br><img src="https://img-blog.csdnimg.cn/20190613141413854.png" alt="在这里插入图片描述"></p><p>2.1.普通动画<br><img src="https://img-blog.csdnimg.cn/20190613141551260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    2.2.人物角色动画<br>    <img src="https://img-blog.csdnimg.cn/20190613141959166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    2.2.1.人物角色动画的导入<br>    <img src="https://img-blog.csdnimg.cn/20190613142213379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>+大图导向<br>    -骨骼映射视图的打开 <img src="https://img-blog.csdnimg.cn/20190531125401236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    -骨骼映射视图和骨骼映射表的修改<img src="https://img-blog.csdnimg.cn/20190531125301603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>-三种动画的导入方式<br><img src="https://img-blog.csdnimg.cn/20190613142757765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">-模型导入注意事项<br><img src="https://img-blog.csdnimg.cn/20190613142937598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190531130631610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    <img src="https://img-blog.csdnimg.cn/20190531130654193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2.3.IK动画<br><img src="https://img-blog.csdnimg.cn/20190613143849254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2.4.TimeLine<br><img src="https://img-blog.csdnimg.cn/20190613143939800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>+大图导向<br>    -存储<br>    <img src="https://img-blog.csdnimg.cn/20190613144055967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    -Playable Track<br>    <img src="https://img-blog.csdnimg.cn/20190613144133197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.AnimatorController(状态机)<br><img src="https://img-blog.csdnimg.cn/20190613144259619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.1.状态机的打开方式<br><img src="https://img-blog.csdnimg.cn/20190613144350891.png" alt="在这里插入图片描述"><br>3.2.Animator视图简介<br><img src="https://img-blog.csdnimg.cn/20190613144502456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.3.作用<br><img src="https://img-blog.csdnimg.cn/20190613144550261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.4.精细控制<br><img src="https://img-blog.csdnimg.cn/20190613144641944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>+大图导向<br><img src="https://img-blog.csdnimg.cn/20190613144744729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.5.混合树<br><img src="https://img-blog.csdnimg.cn/201906131452528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.5.1.四种2D混合树<br><img src="https://img-blog.csdnimg.cn/20190613145340965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.5.2.大图导向<br> -混合树的创建<br> <img src="https://img-blog.csdnimg.cn/20190613145440631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> -1D混合树Inspector<br> <img src="https://img-blog.csdnimg.cn/20190613144953557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> -2D混合树Inspector<br> <img src="https://img-blog.csdnimg.cn/20190613145057715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.6.Avatar Mask骨骼遮罩<br><img src="https://img-blog.csdnimg.cn/20190613145729200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4.MacthTarget场景动画匹配技术<br><img src="https://img-blog.csdnimg.cn/20190613145909634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4.1.核心方法<br><img src="https://img-blog.csdnimg.cn/20190613150056658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4.2.MacthTarget函数细述<br><img src="https://img-blog.csdnimg.cn/20190613150207340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4.3.难点<br><img src="https://img-blog.csdnimg.cn/20190613150430468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>+大图导向<br><img src="https://img-blog.csdnimg.cn/2019061315050794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>5.相机运动<br><img src="https://img-blog.csdnimg.cn/20190613150709467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>+大图导向<br><img src="https://img-blog.csdnimg.cn/20190613150735692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>6.学习过程中遇到的问题<br><img src="https://img-blog.csdnimg.cn/20190613150827535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>7.函数方法<br><img src="https://img-blog.csdnimg.cn/20190613150913675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>8.动画的Inspector<br><img src="https://img-blog.csdnimg.cn/20190613151018312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity3d</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【计算机图形学】多边形填充算法</title>
    <link href="/2019/08/23/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E3%80%91%E5%A4%9A%E5%8F%98%E5%BD%A2%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/"/>
    <url>/2019/08/23/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E3%80%91%E5%A4%9A%E5%8F%98%E5%BD%A2%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>首先对于如下的多边形：</p><p><img src="https://img-blog.csdnimg.cn/20190618080545123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="1-有效边表填充算法"><a href="#1-有效边表填充算法" class="headerlink" title="1.有效边表填充算法"></a>1.有效边表填充算法</h1><h2 id="1-1-有效边表填充算法分为如下几个步骤："><a href="#1-1-有效边表填充算法分为如下几个步骤：" class="headerlink" title="1.1.有效边表填充算法分为如下几个步骤："></a><strong>1.1.有效边表填充算法分为如下几个步骤</strong>：</h2><p>​    1.1.1.将多边形所有的边分别与扫描线1计算交点，得到交点集，与扫描线计算的边没有顺序要求。<br>​    1.1.2.将点集按标x的大小递增排序，得到有序点集。<br>​    1.1.3.将有序点集两两配对，得到对应的像素区间。<br>​    1.1.4.将像素区间内的像素填充颜色，至此第一条扫描线上处于多边形内的的像素填充完毕。<br>​    1.1.5.扫描线标号加1，重复以上步骤，直至到最后一条扫描线。<br>​    如：对于扫描线3（y=3）与多边形所有的边计算交点，得到与P3P4交于点（4.5，3），与P3P2交于点（2.4，3），与P5P6交于点（8.8，3），与P5P4交于点（7，3）。<br>​    圆整处理得到点集（5，3）、（2，3）、（9，3）、（7，3）。<br>​    递增排序得到有序点集（2，3）、（5，3）、（7，3）、（9，3）。<br>​    两两配对得到扫描线3上的填充像素区间[2，5]、[7，9]。<br>​    填充区间内的所有像素。<br>​    得到如图所示的填充效果：<br><img src="https://img-blog.csdnimg.cn/20190617115850448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>全部填充得到如下效果：<br><img src="https://img-blog.csdnimg.cn/20190617115915999.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-2-至此我们发现如下疑问："><a href="#1-2-至此我们发现如下疑问：" class="headerlink" title="1.2.至此我们发现如下疑问："></a><strong>1.2.至此我们发现如下疑问：</strong></h2><p>​    1.2.1.像素填充的多边形面积大于多边形实际面积。<br>​    可能上图不太明显，我们举一个明显一点的例子，如下正方形：<br><img src="https://img-blog.csdnimg.cn/20190617115935411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们填充后的效果为：<br><img src="https://img-blog.csdnimg.cn/20190617115949648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>​    而正方形的实际面积是4，在显示器上一个像素为一面积，正方形应该占4个像素点，而实际却占了9个像素点，对于这种问题，有效边表填充算法采用“左闭右开”，“下闭上开”的原则进行像素点的填充，按照此原则，正方形的填充效果如下：<br><img src="https://img-blog.csdnimg.cn/20190617120002618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>1.2.1.对于点集（1，3）、（1，8）它们分别为扫描线1与P3P2、P3P4、P5P4、P5P6的交点，而在实际计算中它们仍只是两个点，如果处理不当，计算机可能会两两配对得到区间（3，8）而填充到错误的像素区间。<br>对于此问题，有效边表填充算法采用分类连接点进行处理。<br>有效边表填充算法将多边形的各个连接点分为三类连接点：</p><h3 id="普通连接点："><a href="#普通连接点：" class="headerlink" title="+普通连接点："></a><strong>+普通连接点：</strong></h3><p>​    连接点所在的两条边分别处于其所在的扫描线的上方和下方，如P2点。</p><h3 id="局部最低点："><a href="#局部最低点：" class="headerlink" title="+局部最低点："></a><strong>+局部最低点：</strong></h3><p>​    连接点所在的两条边都处于其所在的扫描线的上方，如P3、P5点。</p><h3 id="局部最高点："><a href="#局部最高点：" class="headerlink" title="+局部最高点："></a><strong>+局部最高点：</strong></h3><p>​    连接点所在的两条边都处于其所在的扫描线的下方，如：P4、P1、P6点。<br>​    在填充开始前，有效边填充算法先对多边形所有的连接点进行分类，判断其在点集中的数量。<br>有效边填充算法采用如下原则对多边形的连接点进行处理：</p><h3 id="1-2-2-普通连接点的处理原则"><a href="#1-2-2-普通连接点的处理原则" class="headerlink" title="1.2.2.普通连接点的处理原则"></a><strong>1.2.2.普通连接点的处理原则</strong></h3><p>​    以P2为例，根据“下闭上开”原则，对于P3P2上的点P2不予填充，P2P1上的点P2需要填充，P2点只填充1次，顾在扫描线7的填充像素点集中P2点的个数记为1，即可以不处理。</p><h3 id="1-2-3-局部最低点的处理原则"><a href="#1-2-3-局部最低点的处理原则" class="headerlink" title="1.2.3.局部最低点的处理原则"></a><strong>1.2.3.局部最低点的处理原则</strong></h3><p>​    以P3为例，根据“下闭上开”原则，对于P3P2上的点P3需要填充，P3P4上的点P3也需要填充，P3填充2次，扫描线1的填充像素点集中，再添加一个P3点，使其中有两个P3点，在像素点集中将P3点的个数记为2，P5点进行同样的处理，这样当算法进行两两配对时，得到的像素区间为[3，3]、[5，5]，如此即可避免出现[3，8]的点集区间，解决此类情况的填充错误。</p><h2 id="1-2-4-局部最高点的处理原则"><a href="#1-2-4-局部最高点的处理原则" class="headerlink" title="1.2.4.局部最高点的处理原则"></a><strong>1.2.4.局部最高点的处理原则</strong></h2><p>​    以P1点为例，根据“下闭上开”原则，对于P2P1上的P1点不予填充，P0P1上的P1点也不予填充，P1填充0次，扫描线12的像素填充点集中P1点的个数记为0，即从点集中删除P1点，这样的处理符合多边形整体的“下闭上开”原则。<br>至此，多边形的有效边表填充算法的填充原理已经完成。<br>但是，我们在填充多边形之前还需要进行一项很重要的工作——根据多边形计算其有效边表，首先我们要了解什么是有效边。<br><strong>有效边</strong>：多边形与当前扫描线相交的边称为有效边，有效边的引入可以有效的避免扫描边与多边形的所有的边进行交点计算，提高算法的效率。<br><strong>有效边表</strong>：有效边按与扫描线交点x坐标递增顺序存放的链表。<br><strong>有效边表节点结构</strong>：<br><img src="https://img-blog.csdnimg.cn/20190618080124847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>示例：扫描线1的有效边表如下：<br><img src="https://img-blog.csdnimg.cn/20190618081306344.png" alt="在这里插入图片描述"><br><strong>桶表</strong>：有效边表按扫描线自增顺序存放的表，可以是链表，也可以是顺序表。<br><strong>桶表的结构</strong>：<br>​    如：多边形P0-P6的桶表为：<br><img src="https://img-blog.csdnimg.cn/20190618082918644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>​    有效边表可以有效的减少计算量，提升多边形的填充效率，如所有的扫描线中，计算机只需要计算扫描线1、扫描线7和扫描线8，且扫描线1只需和边P2P3、P3P4、P4P5、P5P6计算交点，而无需与所有边计算交点，有效边填充算法是目前最有效的多边形填充算法之一。<br>至此，多边形的有效边填充算法全部完成。</p><h1 id="2-边缘填充算法"><a href="#2-边缘填充算法" class="headerlink" title="2.边缘填充算法"></a>2.边缘填充算法</h1><h2 id="2-1-算法原理："><a href="#2-1-算法原理：" class="headerlink" title="2.1.算法原理："></a><strong>2.1.算法原理：</strong></h2><p>​    先计算多边形每条边与扫描线的交点，然后将交点右侧的所有像素颜色全部取补色。</p><h2 id="2-2-补色的定义："><a href="#2-2-补色的定义：" class="headerlink" title="2.2.补色的定义："></a><strong>2.2.补色的定义：</strong></h2><p>​    对于黑白图像，白色的补色为黑色，黑色补色为白色，对于彩色图像，前景色取补就是将前景色置为背景色，背景色取补就是将背景声置为前景色。<br>示例：<br><img src="https://img-blog.csdnimg.cn/20190618092226427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>​    边缘填充算法的填充效率受到右侧填充像素的数量影响，当多边形靠近屏幕左侧时，计算机将填充大量无用像素，大大降低的算法的性能，浪费了系统资源。<br>于是有人提出这样的改进：首先在进行多边形填充之前，先扫描一遍多边形，得出多边形的包围盒，并在适当的位置加入一条栅栏。<br>包围盒：包围多边形的最小矩形。</p><h2 id="2-3-加入包围盒和栅栏的边缘填充算法原理："><a href="#2-3-加入包围盒和栅栏的边缘填充算法原理：" class="headerlink" title="2.3.加入包围盒和栅栏的边缘填充算法原理："></a><strong>2.3.加入包围盒和栅栏的边缘填充算法原理：</strong></h2><p>​    每次填充前先判断当前边在栅栏的左侧还是右侧，若在左侧，则取补边以右，栅栏以左的像素；若在右侧，则取补边以右，栅栏以左的像素。<br>示例：<br><img src="https://img-blog.csdnimg.cn/20190621084324207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>​    可以看出，加入包围盒和栅栏的边缘填充算法极大的减少了需要填充像素的数量，对填充效率的提升是显著的。<br>​    观察边缘填充算法的两幅图，我们是可以察觉到的，边缘填充算法，对多边形的顶点与边的填充不甚理想，边缘填充算法没有给定具体填充时，直线上的点是否包含在填充范围内，笔者试过两种情况的对比——填充时包含直线上的点和填充时不包含直线上的点，得出的结果，多边形的顶点与边的填充都不理想，但是，填充时包含直线上的点的填充方法的最总结果，使多边形在整体上满足“左闭右开”，“下闭上开”原则，顾才用此方法作图。然而，边缘填充算法的填充原理是没有考虑边界的，即多边形的所有像素都填充为一个颜色，无论多边形内部还是多边形的边和顶点，在实际填充效果中，多边形所有像素都填充为一个颜色的填充方式，顶点和边对整体的效果不大，即可以忽略，所以边缘填充算法依旧是效率极高的填充算法之一。</p><h1 id="3-种子填充算法"><a href="#3-种子填充算法" class="headerlink" title="3.种子填充算法"></a>3.种子填充算法</h1><p>3.1.种子填充算法是区域填充算法中的一种，种子填充算法分为：四邻接点种子填充算法和八邻接点种子填充算法。<br>在此之前，我们需要了解一些概念：</p><h3 id="3-1-1-四邻接点："><a href="#3-1-1-四邻接点：" class="headerlink" title="3.1.1.四邻接点："></a><strong>3.1.1.四邻接点：</strong></h3><p>​    任易一个种子像素，其左右上下这四个像素成为这个种子像素的四邻接点。<br><img src="https://img-blog.csdnimg.cn/20190621092132813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-1-2-八邻接点："><a href="#3-1-2-八邻接点：" class="headerlink" title="3.1.2.八邻接点："></a><strong>3.1.2.八邻接点：</strong></h3><p>​    任易一个种子像素，其左右上下及左上、右下、右上、左上这八个像素成为这个种子像素的八邻接点。<br><img src="https://img-blog.csdnimg.cn/20190621092334685.png" alt="在这里插入图片描述"></p><h3 id="3-1-3-四连通域："><a href="#3-1-3-四连通域：" class="headerlink" title="3.1.3.四连通域："></a><strong>3.1.3.四连通域：</strong></h3><p>​    多边形中能被四邻接点遍历填充的区域。</p><h3 id="3-1-4-八连通域："><a href="#3-1-4-八连通域：" class="headerlink" title="3.1.4.八连通域："></a><strong>3.1.4.八连通域：</strong></h3><p>​    多边形中能被八邻接点遍历填充的区域。<br><img src="https://img-blog.csdnimg.cn/20190621094757411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-1-5-四连通边界："><a href="#3-1-5-四连通边界：" class="headerlink" title="3.1.5.四连通边界："></a><strong>3.1.5.四连通边界：</strong></h3><p><img src="https://img-blog.csdnimg.cn/20190621094925910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-1-6-八连通边界："><a href="#3-1-6-八连通边界：" class="headerlink" title="3.1.6.八连通边界："></a><strong>3.1.6.八连通边界：</strong></h3><p><img src="https://img-blog.csdnimg.cn/20190621095031628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTA4Mjkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="3-2-适用场景："><a href="#3-2-适用场景：" class="headerlink" title="3.2.适用场景："></a><strong>3.2.适用场景：</strong></h2><p>​    区域填充算法适用于多边形的边界与内部使用不同的填充色的场景。</p><h2 id="3-3-多边形边界的颜色："><a href="#3-3-多边形边界的颜色：" class="headerlink" title="3.3.多边形边界的颜色："></a><strong>3.3.多边形边界的颜色：</strong></h2><p>​    边界的颜色由绘制多边形时的画笔确定。</p><h2 id="3-4-多边形内部的颜色填充步骤"><a href="#3-4-多边形内部的颜色填充步骤" class="headerlink" title="3.4.多边形内部的颜色填充步骤"></a><strong>3.4.多边形内部的颜色填充步骤</strong></h2><p>​    3.4.1.在多边形内部任易选择一个像素作为种子像素。<br>​    3.4.2.将种子像素入栈。<br>​    3.4.3.如果栈不为空，则将栈顶元素出栈。<br>​    3.4.4.按填充色绘制出栈像素。<br>​    3.4.5.按四邻接点（左、上、右、下）（或八邻接点（左、左上、上、右上、右、右下、下、左下））顺序搜索与出栈像素相邻的4（或8）个像素，若该像素的颜色不是填充色并且也不是边界色，则把该像素入栈，否则丢弃该像素。<br>​    不难想象，当多边形的面积极大时，入栈的像素像素将是巨量，有的像素可能即是一个像素的邻接点又是另一个像素的邻接点，以致部分像素入栈多次，此情况下填充过程将大量占用栈存储空间，甚至过量占用空间，致使栈空间不足，导致其他程序无空间可用，如此既不能完成填充，又会造成空间溢出，甚至系统崩溃，所以种子填充算法的缺点极为严重。</p><h2 id="3-5-改进——扫描种子填充算法"><a href="#3-5-改进——扫描种子填充算法" class="headerlink" title="3.5.改进——扫描种子填充算法"></a><strong>3.5.改进——扫描种子填充算法</strong></h2><p>​    3.5.1.在多边形内部选择一个像素作为种子像素。<br>​    3.5.2.将种子像素入栈。<br>​    3.5.3.若栈不为空，则将栈顶元素出栈<br>​    3.5.4.沿出栈像素所在扫描线，对出栈像素左右像素依次填充，直至遇到边界像素为止。<br>​    3.5.5.记录该区间的范围，将最左端的像素记为Xl，将最右端的像素记为Xr。<br>​    3.5.6.检查与当前扫描线相邻的上下两条扫描线中在区间[Xl，Xr]里的有关像素是否全为边界像素或以填充像素，若存在非边界且未填充的像素，则把区间最右端像素取作种子像素入栈。<br>​    扫描种子填充像素每次只将区间最右端的像素入栈，极大的减少了入栈像素，不仅减少了栈空间的占用，还有效的提高了填充效率和填充速度。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
