

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/G.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Goulandis">
  <meta name="keywords" content="技术博客，Hexo，UE5，编程">
  
    <meta property="og:type" content="article">
<meta property="og:title" content="【UE4】C++编程">
<meta property="og:url" content="http://example.com/2022/10/16/%E3%80%90UE4%E3%80%91C++%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Goulandis">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002336.jpg">
<meta property="article:published_time" content="2022-10-15T16:00:00.000Z">
<meta property="article:modified_time" content="2025-12-23T14:21:02.819Z">
<meta property="article:author" content="Goulandis">
<meta property="article:tag" content="UE4">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002336.jpg">
  
  
  
  <title>【UE4】C++编程 - Goulandis</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Goulandis</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/Page.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="【UE4】C++编程"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-10-16 00:00" pubdate>
          2022年10月16日
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          37k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          312 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">【UE4】C++编程</h1>
            
            
              <div class="markdown-body">
                
                <meta name="referrer" content="no-referrer" />

<span id="more"></span>

<h1 id="一、工程目录"><a href="#一、工程目录" class="headerlink" title="一、工程目录"></a>一、工程目录</h1><p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016001916.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016001916.png" alt="img"></a></p>
<ul>
<li>.vs：VS的缓存文件夹；</li>
<li>Binaries：存放UE的工程的可执行文件，以及编译的中间文件；</li>
<li>Biuld：存放一些编辑器相关的日志；</li>
<li>Config：存放游戏的默认配置文件；</li>
<li>Content：存放项目资产；</li>
<li>DerivedDataCache：主要存放DivX Descriptor File文件，应该是UE为制作影视视频准备的；</li>
<li>Plugins：存放项目中使用的插件；</li>
<li>Intermediate：存放UBT生成的文件，如：.generated.h文件；</li>
<li>Saved：缓存一些临时配置文件，在PIE模式下运行项目产生的日志以及Cook产生的数据文件；</li>
<li>Script：用来存放脚本语言，如python脚本等；</li>
<li>Source：存放项目的C++文件。</li>
</ul>
<h2 id="uproject"><a href="#uproject" class="headerlink" title=".uproject"></a>.uproject</h2><p>右键.uproject会出现几个选项：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016001947.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016001947.png" alt="img"></a></p>
<ul>
<li>Open：使用默认的UE编辑器打开.uproject文件；</li>
<li>Launch game：以打包后的exe的形式直接运行项目；</li>
<li>Generate Visual Studio project files：生成VS相关文件；</li>
<li>Switch Unreal Engine version：选择默认的UE版本用以打开.uproject文件。</li>
</ul>
<p>.uproject是UE的项目描述文件，采用json的格式来描述一个项目的版本信息、模块信息、插件信息等。</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<br>	<span class="hljs-string">&quot;FileVersion&quot;</span>: <span class="hljs-number">3</span>,<br>	<span class="hljs-string">&quot;EngineAssociation&quot;</span>: <span class="hljs-string">&quot;4.26&quot;</span>,<br>	<span class="hljs-string">&quot;Category&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>	<span class="hljs-string">&quot;Description&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>	<span class="hljs-string">&quot;Modules&quot;</span>: [<br>		&#123;<br>			<span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;MyProject&quot;</span>,<br>			<span class="hljs-string">&quot;Type&quot;</span>: <span class="hljs-string">&quot;Runtime&quot;</span>,<br>			<span class="hljs-string">&quot;LoadingPhase&quot;</span>: <span class="hljs-string">&quot;Default&quot;</span>,<br>			<span class="hljs-string">&quot;AdditionalDependencies&quot;</span>: [<br>				<span class="hljs-string">&quot;Engine&quot;</span><br>			]<br>		&#125;<br>	],<br>	<span class="hljs-string">&quot;Plugins&quot;</span>: [<br>		&#123;<br>			<span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;WebBrowserWidget&quot;</span>,<br>			<span class="hljs-string">&quot;Enabled&quot;</span>: true<br>		&#125;<br>	]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>.uproject参数描述文件—<code>ProjectDescriptor.h</code></p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">struct</span> <span class="hljs-type">PROJECTS_API</span> FProjectDescriptor<br>&#123;<br>	<span class="hljs-comment">/** Descriptor version number. */</span><br>	EProjectDescriptorVersion::<span class="hljs-built_in">Type</span> FileVersion;<br>	<span class="hljs-comment">/** </span><br><span class="hljs-comment">	 * The engine to open this project with. Set this value using IDesktopPlatform::SetEngineIdentifierForProject to ensure that</span><br><span class="hljs-comment">	 * the most portable value for this field is used.</span><br><span class="hljs-comment">	 * This field allows us to open the right version of the engine when you double-click on a .uproject file, and to detect when you </span><br><span class="hljs-comment">	 * open a project with a different version of the editor and need the upgrade/downgrade UI flow. The normal engine </span><br><span class="hljs-comment">	 * version doesn&#x27;t work for those purposes, because you can have multiple 4.x branches in various states on one machine.</span><br><span class="hljs-comment">	 * For Launcher users, this field gets set to something stable like &quot;4.7&quot; or &quot;4.8&quot;, so you can swap projects and game binaries </span><br><span class="hljs-comment">	 * between users, and it&#x27;ll automatically work on any platform or machine regardless of where the engine is installed. You </span><br><span class="hljs-comment">	 * can only have one binary release of each major engine version installed at once.</span><br><span class="hljs-comment">	 * For Perforce or Git users that branch the engine along with their games, this field is left blank. You can sync the repository </span><br><span class="hljs-comment">	 * down on any platform and machine, and it can figure out which engine a project should use by looking up the directory </span><br><span class="hljs-comment">	 * hierarchy until it finds one.</span><br><span class="hljs-comment">	 * For other cases, where you have a source build of the engine but are working with a foreign project, we use a random identifier </span><br><span class="hljs-comment">	 * for each local engine installation and use the registry to map it back to the engine directory. All bets are off as to which</span><br><span class="hljs-comment">	 * engine you should use to open it on a different machine, and using a random GUID ensures that every new machine triggers the</span><br><span class="hljs-comment">	 * engine selection UI when you open or attempt to generate project files for it. </span><br><span class="hljs-comment">	 * For users which mount the engine through a Git submodule (where the engine is in a subdirectory of the project), this field </span><br><span class="hljs-comment">	 * can be manually edited to be a relative path.</span><br><span class="hljs-comment">	 * @see IDesktopPlatform::GetEngineIdentifierForProject</span><br><span class="hljs-comment">	 * @see IDesktopPlatform::SetEngineIdentifierForProject</span><br><span class="hljs-comment">	 * @see IDesktopPlatform::GetEngineRootDirFromIdentifier</span><br><span class="hljs-comment">	 * @see IDesktopPlatform::GetEngineIdentifierFromRootDir</span><br><span class="hljs-comment">	 */</span><br>	FString EngineAssociation;<br>	<span class="hljs-comment">/** Category to show under the project browser */</span><br>	FString Category;<br>	<span class="hljs-comment">/** Description to show in the project browser */</span><br>	FString Description;<br>	<span class="hljs-comment">/** List of all modules associated with this project */</span><br>	TArray&lt;FModuleDescriptor&gt; Modules;<br>	<span class="hljs-comment">/** List of plugins for this project (may be enabled/disabled) */</span><br>	TArray&lt;FPluginReferenceDescriptor&gt; Plugins;<br>	<span class="hljs-comment">/** Array of platforms that this project is targeting */</span><br>	TArray&lt;FName&gt; TargetPlatforms;<br>	<span class="hljs-comment">/** A hash that is used to determine if the project was forked from a sample */</span><br>	uint32 EpicSampleNameHash;<br>	<span class="hljs-comment">/** Custom steps to execute before building targets in this project */</span><br>	FCustomBuildSteps PreBuildSteps;<br>	<span class="hljs-comment">/** Custom steps to execute after building targets in this project */</span><br>	FCustomBuildSteps PostBuildSteps;<br>	<span class="hljs-comment">/** Indicates if this project is an Enterprise project */</span><br>	<span class="hljs-keyword">bool</span> bIsEnterpriseProject;<br>	<span class="hljs-comment">/** Indicates that enabled by default engine plugins should not be enabled unless explicitly enabled by the project or target files. */</span><br>	<span class="hljs-keyword">bool</span> bDisableEnginePluginsByDefault;  <br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>FileVersion：描述项目版本；</p>
</li>
<li><p>EngineAssociation：引擎版本；</p>
</li>
<li><p>Category：这个分类着实是不知道有什么卵用；</p>
</li>
<li><p>Description：项目描述；</p>
</li>
<li><p>Modules：模块信息，是一个<code>FModuleDescriptor</code>类型的数组，数组中一个元素代表一个模块，<code>FModuleDescriptor</code>的具体描述在ModuleDescriptor.h</p>
<p>里面涉及很多模块的描述，最常使用的基本只有三个：</p>
<p>Name：模块名称；</p>
<p>Type：模块的使用类型，描述模块在什么时候能够使用；</p>
<p>Type是一个EHostType::Type类型，描述文件也在ModuleDescriptor.h中</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">namespace</span> <span class="hljs-symbol">EHostType</span><br>&#123;<br>	<span class="hljs-keyword">enum</span> Type<br>	&#123;<br>		<span class="hljs-comment">// Loads on all targets, except programs.</span><br>		Runtime,	<br>		<span class="hljs-comment">// Loads on all targets, except programs and the editor running commandlets.</span><br>		RuntimeNoCommandlet,<br>		<span class="hljs-comment">// Loads on all targets, including supported programs.</span><br>		RuntimeAndProgram,<br>		<span class="hljs-comment">// Loads only in cooked games.</span><br>		CookedOnly,<br>		<span class="hljs-comment">// Only loads in uncooked games.</span><br>		UncookedOnly,<br>		<span class="hljs-comment">// Deprecated due to ambiguities. Only loads in editor and program targets, but loads in any editor mode (eg. -game, -server).</span><br>		<span class="hljs-comment">// Use UncookedOnly for the same behavior (eg. for editor blueprint nodes needed in uncooked games), or DeveloperTool for modules</span><br>		<span class="hljs-comment">// that can also be loaded in cooked games but should not be shipped (eg. debugging utilities).</span><br>		Developer,<br>		<span class="hljs-comment">// Loads on any targets where bBuildDeveloperTools is enabled.</span><br>		DeveloperTool,<br>		<span class="hljs-comment">// Loads only when the editor is starting up.</span><br>		Editor,		<br>		<span class="hljs-comment">// Loads only when the editor is starting up, but not in commandlet mode.</span><br>		EditorNoCommandlet,<br>		<span class="hljs-comment">// Loads only on editor and program targets</span><br>		EditorAndProgram,<br>		<span class="hljs-comment">// Only loads on program targets.</span><br>		Program,	<br>		<span class="hljs-comment">// Loads on all targets except dedicated clients.</span><br>		ServerOnly,		<br>		<span class="hljs-comment">// Loads on all targets except dedicated servers.</span><br>		ClientOnly,<br>		<span class="hljs-comment">// Loads in editor and client but not in commandlets.</span><br>		ClientOnlyNoCommandlet,		<br>		<span class="hljs-comment">//~ <span class="hljs-doctag">NOTE:</span> If you add a new value, make sure to update the ToString() method below!</span><br>		Max<br>	&#125;;<br></code></pre></td></tr></table></figure>

<p>LoadingPhase：模块的加载策略，控制模块的加载时机；</p>
<p>LoadingPhase是一个ELoadingPhase::Type类型，描述文件也在ModuleDescriptor.h</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">namespace ELoadingPhase<br>&#123;<br>	enum Type<br>	&#123;<br>		<span class="hljs-comment">/** As soon as possible - in other words, uplugin files are loadable from a pak file (as well as right after PlatformFile is set up in case pak files aren&#x27;t used) Used for plugins needed to read files (compression formats, etc) */</span><br><span class="hljs-built_in">		EarliestPossible,</span><br>		<span class="hljs-comment">/** Loaded before the engine is fully initialized, immediately after the config system has been initialized.  Necessary only for very low-level hooks */</span><br><span class="hljs-built_in">		PostConfigInit,</span><br>		<span class="hljs-comment">/** The first screen to be rendered after system splash screen */</span><br><span class="hljs-built_in">		PostSplashScreen,</span><br>		<span class="hljs-comment">/** Loaded before coreUObject for setting up manual loading screens, used for our chunk patching system */</span><br><span class="hljs-built_in">		PreEarlyLoadingScreen,</span><br>		<span class="hljs-comment">/** Loaded before the engine is fully initialized for modules that need to hook into the loading screen before it triggers */</span><br><span class="hljs-built_in">		PreLoadingScreen,</span><br>		<span class="hljs-comment">/** Right before the default phase */</span><br><span class="hljs-built_in">		PreDefault,</span><br>		<span class="hljs-comment">/** Loaded at the default loading point during startup (during engine init, after game modules are loaded.) */</span><br><span class="hljs-built_in">		Default,</span><br>		<span class="hljs-comment">/** Right after the default phase */</span><br><span class="hljs-built_in">		PostDefault,</span><br>		<span class="hljs-comment">/** After the engine has been initialized */</span><br><span class="hljs-built_in">		PostEngineInit,</span><br>		<span class="hljs-comment">/** Do not automatically load this module */</span><br><span class="hljs-built_in">		None,</span><br><span class="hljs-title">		// NOTE:</span> If you add a <span class="hljs-keyword">new</span> value, make sure to update the ToString() method below!<br>		Max<br>	&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>Plugins：插件信息，是一个FPluginReferenceDescriptor数组，数组中一个元素代表一个插件，描述文件在PluginDescriptor.h和PluginReferenceDescriptor.h文件中</p>
<p>其中也包含大量的描述参数，最常用的基本也只有Name：插件名称，Enabled：是否启用插件。</p>
</li>
<li><p>TargetPlatforms：描述项目的目标平台；</p>
</li>
<li><p>EpicSampleNameHash：也没有研究出是干什么用的；</p>
</li>
<li><p>PreBuildSteps和PostBuildSteps：根据源码描述是用来在当前项目构建的前后执行一些自定义操作用的，具体怎么使用着实是找不到案例，查看了FCustomBuildSteps是一个很简单的结构体，里面只有一个叫HostPlatformToCommands的与命令行相关的TMap，和几个简单函数。</p>
</li>
<li><p>bIsEnterpriseProject：描述当前项目是否为企业项目；</p>
</li>
<li><p>bDisableEnginePluginsByDefault：是否启用引擎默认启用的插件，这是在FProjectDescriptor结构体中的变量，所以默认值为0。</p>
</li>
</ul>
<h1 id="二、类"><a href="#二、类" class="headerlink" title="二、类"></a>二、类</h1><h2 id="1-UE4中的预定义类"><a href="#1-UE4中的预定义类" class="headerlink" title="1.UE4中的预定义类"></a>1.UE4中的预定义类</h2><p>UE的预定义类，祥见<a target="_blank" rel="noopener" href="https://goulandis.github.io/2022/01/27/%E3%80%90UE4%E3%80%91UE4%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">GamePlay架构</a>。</p>
<h2 id="2-C-类的创建"><a href="#2-C-类的创建" class="headerlink" title="2.C++类的创建"></a>2.C++类的创建</h2><h3 id="使用Unreal-Editor创建C-类"><a href="#使用Unreal-Editor创建C-类" class="headerlink" title="使用Unreal Editor创建C++类"></a>使用Unreal Editor创建C++类</h3><p>当我们创建一个C++编程模板时，在内容浏览器中会生成一个C++类文件夹，同时目录下还会生成一个项目名称文件夹，我们可以在对应的文件夹下右键创建一个C++类，选择新类需要继承的父类和存储位置后确定，UE4会自动打开VS，并生成一个<code>.cpp</code>文件和一个<code>.h文件</code>。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016001959.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016001959.png" alt="img"></a></p>
<p>勾选Show All Classes可以看到引擎支持的所有可继承的类。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002005.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002005.png" alt="img"></a></p>
<p>在Path处可以直接添加新的文件夹名称，UE会自动创建新的文件夹来存放新建的类。</p>
<p>我们在创建类时可以选择后面的公有与私有，或者都不选</p>
<ul>
<li>选择公有，UE4会在C++Class&#x2F;ProjectName文件夹下创建一个Public文件夹存放我们创建的类，而在VS中则会创建一个public文件夹存放.h文件，创建一个private文件夹存放.cpp文件；</li>
<li>选择私有，UE4会在C++Class&#x2F;ProjectName文件夹下创建一个Public文件夹存放我们创建的类，而在VS中则将.h和.cpp都存放在private文件下；</li>
<li>如果都不选，则我们创建的类直接存放在C++Class&#x2F;ProjectName文件夹下，而VS中.cpp和.h文件都存放在Source文件夹下。</li>
<li>如下图Unkown处是一个用于选择模块的下拉列表，可以选择当前创建的类应该放在哪个模块下，这个一般涉及到多模块时才使用，一般情况下都是直接选择当前项目，在UE的视角当前项目也是一个模块。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002010.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002010.png" alt="img"></a></p>
<p>创建的C++类的<code>.h</code>文件的结构，以一个UObject为例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Fill out your copyright notice in the Description page of Project Settings.</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UObject/NoExportTypes.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;PakExpand.generated.h&quot;</span></span><br><br><span class="hljs-built_in">UCLASS</span>()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UNKOWN_API</span> UPakExpand : <span class="hljs-keyword">public</span> UObject<br>&#123;<br>	<span class="hljs-built_in">GENERATED_BODY</span>()<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>CoreMinimal.h头文件中包含了一些UE预定义需要包含的头文件；</p>
</li>
<li><p>NoExportTypes.h头文件中包含了大量的引擎需要的状态量；</p>
</li>
<li><p>.generated.h文件则是由UBT生成的用于反射的代码；</p>
</li>
<li><p>UCLASS()表示这个类加入UE4的反射系统，使用UCLASS()就必须包含.generated.h头文件；</p>
</li>
<li><p>XXX_API这个宏由UBT生成，XXX会被模块名代替，如我当前的项目名为Unkown，则生成UNKOWN_API，对于引擎来说，整个项目就是一个模块，UNKOWN_API标识这个类属于UNKOWN模块。、；</p>
</li>
<li><p>GENERATED_BODY()：</p>
<p>这里GENERATED_BODY()宏处有两种情况，我们可以使用GENERATED_UCLASS_BODY()宏和GENERATED_BODY()宏，二者的区别是:</p>
<p>使用了GENERATED_BODY()宏，我们的类中就不能直接使用父类中的声明，如果我们要去实现，我就必须在本类中声明。使用GENERATED_BODY()宏，我们必须手动实现一个无参构造函数。</p>
<p>使用GENERATED_UCLASS_BODY()宏，我们就可以使用父类声明的构造函数，在本类中不需要再声明，而可以直接实现即可，且实现的构造函数必须带const FObjectInitializer&amp;参数。</p>
</li>
</ul>
<h3 id="在VS中手动创建类"><a href="#在VS中手动创建类" class="headerlink" title="在VS中手动创建类"></a>在VS中手动创建类</h3><p>VS中的工程目录的Source目录下的目录结构有两种：</p>
<ul>
<li>一堆的.cpp、.h和.build.cs文件。</li>
<li>.h文件在public目录下，.cpp文件在private目录下，.biuld.cs文件在Source目录下.。</li>
</ul>
<p>对于第一种目录结构，直接在Source文件夹下使用VS添加.cpp和.h文件即可。</p>
<p>对于第二种目录结构，我们需要在public下添加.h文件，在private下添加.cpp文件。</p>
<p>在VS中手动创建的类如果继承UObject，我们需要手动添加UCLASS()宏和GENERATED_BODY()或GENERATED_UCLASS_BODY()宏。</p>
<p> 但是要注意的是手动创建的类系统不会自动为类名加前缀，所以手动创建的类定义类名时应该合乎UE4C++类的命名规范。</p>
<h2 id="2-C-类的删除"><a href="#2-C-类的删除" class="headerlink" title="2.C++类的删除"></a>2.C++类的删除</h2><p>UE4引擎自身不提供C++的删除功能，但是有时候我们需要删除一些类的时候怎么办呢？</p>
<p>唯一的办法就是建立在文件操作上了，步骤如下：</p>
<ul>
<li>删除项目目录下Source文件夹下需要删除类的<code>.cpp</code>和<code>.h</code>文件；</li>
<li>重新Generate Visual Studio project files，生成sln文件；</li>
<li>双击.uproject文件，启动项目让引擎重新加载配置。</li>
</ul>
<h2 id="3-UE4类的命名规则"><a href="#3-UE4类的命名规则" class="headerlink" title="3.UE4类的命名规则"></a>3.UE4类的命名规则</h2><p>UE4为一些常用类的命名添加了一些命名前缀， 如果我们不写这些前缀，UE4会编译错误。</p>
<table>
<thead>
<tr>
<th>前缀</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>F</td>
<td>纯c++类</td>
</tr>
<tr>
<td>U</td>
<td>继承自UObject，但不继承自Actor的类</td>
</tr>
<tr>
<td>A</td>
<td>继承自Actor的类</td>
</tr>
<tr>
<td>S</td>
<td>Slate控件相关类</td>
</tr>
<tr>
<td>H</td>
<td>HitResult相关类</td>
</tr>
</tbody></table>
<h2 id="4-C-类的实例化"><a href="#4-C-类的实例化" class="headerlink" title="4.C++类的实例化"></a>4.C++类的实例化</h2><p>在UE4中实例化C++类稍显复杂，分为如下几种情况：</p>
<ul>
<li>如果是一个纯C++类型的类，即按UE4的命名规则F开头的类，符合C++的实例化条件，可以直接使用new运算符来实例化，或者直接使用构造函数在栈区中实例化；</li>
<li>如果是一个继承自UObject的类，那么我们需要使用<code>NewObject&lt;T&gt;()</code>函数来实例化类对象；</li>
<li>如果是一个继承自Actor的类，那么我们需要使用UWorld对象中的SpawnActor函数来实例化，调用方式为： <code>GetWorld()-&gt;SpawnActor&lt;T&gt;()</code>， <code>GetWorld()-&gt;SpawnActor&lt;T&gt;()</code>不可以在构造函数中使用，如果直接在构造函数中使用UE4在编译时会直接崩溃。；</li>
<li>如果我们需要产出一个Slate类，那么我们需要使用 SNew()函数来实例化。</li>
</ul>
<h2 id="5-类的使用"><a href="#5-类的使用" class="headerlink" title="5.类的使用"></a>5.类的使用</h2><h3 id="继承自UObject类的C-类"><a href="#继承自UObject类的C-类" class="headerlink" title="继承自UObject类的C++类"></a>继承自UObject类的C++类</h3><p>UE中UObject类可以直接在C++中使用但是不能直接在蓝图中使用，如果想要在蓝图中使用一个继承自UObject的类，那么我们就可以使用UCLASS(Blueprintable)在类前说明，编译后就可以直接在蓝图中使用这个C++类，同时可以创建继承这个类的蓝图类，也可以在对应的类对象上右键创建蓝图类，否则创建蓝图类的按钮是非激活状态。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002017.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002017.png" alt="img"></a></p>
<p>当然如果我们只需要在蓝图中使用，而不需要创建对应的蓝图类，我们可以使用UCLASS(BlueprintType)来描述。</p>
<p>如：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl">UCLASS(BlueprintType)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ARP_04_API</span> <span class="hljs-title">UTest</span><span class="hljs-attr"> : public</span> <span class="hljs-title">UObject</span></span><br><span class="hljs-class"></span>&#123;<br>	GENERATED_BODY()<br>	<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>除此之外，我们若想要让类里面的变量和函数也能被蓝图类使用，我同时还需要在变量前指定<code>UPROPERTY(BlueprintReadWrite)</code>，在函数前指定<code>UFUNCTION(BlueprintCallable)</code>，就如上面的实例代码一样。</p>
<p>UPROPERTY(BlueprintReadWrite)里的参数不是唯一的， BlueprintReadWrite表示成员变量在蓝图类里可读写，BlueprintReadOnly表示成员变量在蓝图类里只读，BlueprintWriteOnly表示成员变量在蓝图类里只写。</p>
<p>经过以上步骤我们的继承自UObject类的类便可以通过对应的蓝图类在关卡蓝图中使用了，使用BeginPlay节点开始程序，使用Construct节点来实例化我们的蓝图类，通过实例化出来的对象便可调用类中的资源了。</p>
<h3 id="继承自AActor类的C-类"><a href="#继承自AActor类的C-类" class="headerlink" title="继承自AActor类的C++类"></a>继承自AActor类的C++类</h3><p>由于AActor在UE中就是一个场景中的基本实体，所以继承自AActor类的C++类默认是可以直接被蓝图使用的。</p>
<h3 id="纯C-类"><a href="#纯C-类" class="headerlink" title="纯C++类"></a>纯C++类</h3><p>纯C++类完全脱离UE的反射系统，无法被UCLASS，UPROPERTY等宏修饰，所以无法被蓝图使用。由于纯C++类无法使用UE的反射系统，所以也就不支持UE的GC系统，所以UE提供了共享指针来管理纯C++类。</p>
<h2 id="6-抽象类"><a href="#6-抽象类" class="headerlink" title="6.抽象类"></a>6.抽象类</h2><p>UE对C++的抽象类也进行了魔改，UE使用UCLASS(abstract)宏来标识一个类是抽象类，对于UObject类和AActor类的抽象类在实例化上又有所区别。</p>
<h3 id="继承自UObject的抽象类"><a href="#继承自UObject的抽象类" class="headerlink" title="继承自UObject的抽象类"></a>继承自UObject的抽象类</h3><p>使用UCLASS(abstract)宏标识一个UObject类，那么这个UObject类就是一个于C++抽象类基本一致的抽象类了，由于在C++中抽象类是不可以实例化的，所以如果代码中去实例化了一个抽象类，编译阶段就会报错，但是由于编译器不完全支持UE魔改后的C++标准，所以即使我们在代码里去实例化了一个抽象类，编译也不会报错，只有在编辑器运行时，真正跑到这行代码时才会报错。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">UCLASS(<span class="hljs-keyword">abstract</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-symbol">MYPROJECT_API</span> <span class="hljs-symbol">UAbstractObject</span> : <span class="hljs-symbol">public</span> <span class="hljs-symbol">UObject</span><br>&#123;<br>	GENERATED_BODY()<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">void</span> Log();<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>之所以编译阶段不会报错是因为，UE是通过UCLASS(abstract)宏来标识抽象类的，所以即使一个类没有纯虚函数UE也可以识别它为抽象类，但这个类在C++层面其实不是抽象类，所以编译阶段不会出现错误，当然我们也可以给这个类创建一个纯虚函数，是这类成为一个真正意义上的抽象类。</p>
<h3 id="继承自AActor的抽象类"><a href="#继承自AActor的抽象类" class="headerlink" title="继承自AActor的抽象类"></a>继承自AActor的抽象类</h3><p>继承自AActor的抽象类在实例化上和UObject有一些区别，一个不包含纯虚函数的AActor抽象类在运行时是可以被实例化的，UE编辑器仅仅是报出一个警告，标识为抽象类的Actor不可以被放入场景中，但是却可以在C++中使用SapwnActor函数实例化，并且实例是有效的，只是Actor不会被spawn到场景中，只能像UObject一样驻留在内存中。如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp">UCLASS(<span class="hljs-keyword">abstract</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROJECT_API</span> <span class="hljs-title">AAbstractBase</span> : <span class="hljs-title">public</span> <span class="hljs-title">AActor</span><br>&#123;<br>	GENERATED_BODY()	<br><span class="hljs-keyword">public</span>:	<br>	AAbstractBase();<br><br><span class="hljs-keyword">protected</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BeginPlay</span>() <span class="hljs-keyword">override</span></span>;<br><span class="hljs-keyword">public</span>:	<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Tick</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> DeltaTime</span>) <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Log</span>()</span><br>    &#123;<br>    	UE_LOG(LogTemp, Error, TEXT(<span class="hljs-string">&quot;AAbstractBase::Log()&quot;</span>));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>然后在另一个Actor—AAbstractOpreater的BeginPlay中去实例化：</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">void</span> <span class="hljs-variable">AAbstractOpreater</span>::<span class="hljs-function"><span class="hljs-title">BeginPlay</span>()</span><br>&#123;<br>	<span class="hljs-variable">Super</span>::<span class="hljs-function"><span class="hljs-title">BeginPlay</span>();</span><br><span class="hljs-function">    <span class="hljs-variable">AAbstractBase</span>* <span class="hljs-variable">AbstractBase</span> = <span class="hljs-variable">GWorld</span>-&gt;<span class="hljs-variable">SpawnActor</span>&lt;<span class="hljs-variable">AAbstractBase</span>&gt;();    </span><br><span class="hljs-function">    <span class="hljs-variable">AbstractBase</span>-&gt;<span class="hljs-title">Log</span>();</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<p>然后将AAbstractOpreater丢进场景中运行，看看结果：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002024.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002024.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002026.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002026.png" alt="img"></a></p>
<p>可以看到AAbstractBase虽然被实例化了，并且Log函数也调用成功了，但是场景中并没有AAbstractBase这个Actor。</p>
<p>这估计是UE的bug吧，在使用时抽象类最好还是创建一个纯虚函数，以符合C++的标准。</p>
<h2 id="7-接口"><a href="#7-接口" class="headerlink" title="7.接口"></a>7.接口</h2><p>与C++的接口不同，UE对C++的接口进行了魔改，我们先创建一个UE接口来看一下，UE的接口长什么样。</p>
<p>我们要创建一个UE的接口，那么我们就需要使自己的接口继承自UInterface，在编辑器里则是选择：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002030.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002030.png" alt="img"></a></p>
<p>创建出来的接口：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#pragma once</span><br><br><span class="hljs-comment">#include &quot;CoreMinimal.h&quot;</span><br><span class="hljs-comment">#include &quot;UObject/Interface.h&quot;</span><br><span class="hljs-comment">#include &quot;UnkInterface.generated.h&quot;</span><br><br>// This <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">does</span> <span class="hljs-title">not</span> <span class="hljs-title">need</span> <span class="hljs-title">to</span> <span class="hljs-title">be</span> <span class="hljs-title">modified</span>.</span><br><span class="hljs-class"><span class="hljs-title">UINTERFACE</span>(<span class="hljs-title">MinimalAPI</span>)</span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">UUnkInterface</span><span class="hljs-attr"> : public</span> <span class="hljs-title">UInterface</span></span><br><span class="hljs-class"></span>&#123;<br>	GENERATED_BODY()<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROJECT_API</span> <span class="hljs-title">IUnkInterface</span></span><br><span class="hljs-class"></span>&#123;<br>	GENERATED_BODY()	<br>	// Add interface functions to this class. This is the <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">that</span> <span class="hljs-title">will</span> <span class="hljs-title">be</span> <span class="hljs-title">inherited</span> <span class="hljs-title">to</span> <span class="hljs-title">implement</span> <span class="hljs-title">this</span> <span class="hljs-title">interface</span>.</span><br><span class="hljs-class"><span class="hljs-title">public</span>:</span><br><span class="hljs-class"></span><br><span class="hljs-class">&#125;</span>;<br></code></pre></td></tr></table></figure>

<p>可以看到.h文件里面有两个类，一个是继承自UInterface，一个为纯C++类，UE这样做的目的就是为了使接口也接入UE的对象系统，因为UInterface的顶层基类也是UObject，但是这就出现了另一个问题，即继承自UObject的其他类如果想要使用UE接口，就会出现菱形继承，为了使开发者避免自己使用虚继承来避开菱形继承问题，UE就直接魔改了C++的接口。</p>
<p>其中两部分 UInterface负责对象系统，即接口也能使用UE的反射系统和GC系统，而纯C++类部分则负责具体的接口内容，使用方式完全和C++一样，同时由于接口接入UE的反射系统，所以接口行数可以使用UFUNCTION来暴漏给蓝图。</p>
<h3 id="C-使用接口"><a href="#C-使用接口" class="headerlink" title="C++使用接口"></a>C++使用接口</h3><p>C++使用接口，和普通C++一样，直接继承并实现所有接口的纯虚函数，然后使用即可。</p>
<h3 id="蓝图使用接口"><a href="#蓝图使用接口" class="headerlink" title="蓝图使用接口"></a>蓝图使用接口</h3><p>虽然UE提供了纯蓝图的接口，但是纯蓝图接口限制比较多，不能设置成员变量，也不能在接口中对函数进行实现，所以很多时候还是会需要用到C++接口，比如要写一些通用接口的时候，但是C++接口可以声明成员变量却不能暴漏给蓝图，估计是UE接口的特殊实现方式决定的。</p>
<p>C++接口默认暴漏给蓝图，所以不需要再使用UCLASS(BlueprintCallable)或UCLASS(BlueprintType)去暴漏，但是蓝图只能看到接口暴漏给蓝图的函数和变量，蓝图类继承一个包含纯虚函数的接口，可以不实现，因为在UE中纯虚函数是不能暴漏给蓝图的。</p>
<p>所以如果蓝图要继承一个C++接口，那么C++接口中的函数就需要暴漏给蓝图，函数需要使用UFUNCTION(BlueprintNativeEvent)和UFUNCTION(BlueprintNativeEvent)暴漏给蓝图。</p>
<ul>
<li><p>BlueprintNativeEvent：BlueprintNativeEvent可以使一个函数在C++中声明并在C++中实现，然后提供给蓝图可重写的能力，如果蓝图不重写，那么蓝图调用时就使用C++的实现，如果蓝图重写了，那么蓝图调用时就是用蓝图重写的实现。在UE C++接口中被BlueprintNativeEvent标识函数需要在C++中实现一个<code>[FunctionName]_Implementation</code>的函数体，并且必须要配合一个<code>virtual [FunctionName]_Implementation</code>函数声明，二者缺一都会导致程序编译不过，如：</p>
<p>.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UObject/Interface.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UnkInterface.generated.h&quot;</span></span><br><br><span class="hljs-built_in">UINTERFACE</span>(MinimalAPI)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UUnkInterface</span> : <span class="hljs-keyword">public</span> UInterface<br>&#123;<br>	<span class="hljs-built_in">GENERATED_BODY</span>()<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MYPROJECT_API</span> IUnkInterface<br>&#123;<br>	<span class="hljs-built_in">GENERATED_BODY</span>()	<br><span class="hljs-keyword">public</span>:	<br>    <span class="hljs-built_in">UFUNCTION</span>(BlueprintNativeEvent)<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Log</span><span class="hljs-params">(<span class="hljs-type">const</span> FString&amp; msg)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Log_Implementation</span><span class="hljs-params">(<span class="hljs-type">const</span> FString&amp; msg)</span></span>;<br>    <span class="hljs-built_in">UFUNCTION</span>(BlueprintImplementableEvent)<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Log2</span><span class="hljs-params">(<span class="hljs-type">const</span> FString&amp; msg)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UnkInterface.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">IUnkInterface::Log_Implementation</span><span class="hljs-params">(<span class="hljs-type">const</span> FString&amp; msg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">UE_LOG</span>(LogTemp, Error, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;IUnkInterface::Log_Implementation(%s)&quot;</span>), *msg);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当然如果BlueprintNativeEvent标识的函数去掉<code>virtual [FunctionName]_Implementation</code>函数体声明和<code>[FunctionName]_Implementation</code>函数体定义也是可以编译过的，只是这样就失去了BlueprintNativeEvent的意义。如：</p>
<p>.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UObject/Interface.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UnkInterface.generated.h&quot;</span></span><br><br><span class="hljs-built_in">UINTERFACE</span>(MinimalAPI)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UUnkInterface</span> : <span class="hljs-keyword">public</span> UInterface<br>&#123;<br>	<span class="hljs-built_in">GENERATED_BODY</span>()<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MYPROJECT_API</span> IUnkInterface<br>&#123;<br>	<span class="hljs-built_in">GENERATED_BODY</span>()	<br><span class="hljs-keyword">public</span>:	<br>    <span class="hljs-built_in">UFUNCTION</span>(BlueprintNativeEvent)<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Log</span><span class="hljs-params">(<span class="hljs-type">const</span> FString&amp; msg)</span></span>;<br>    <span class="hljs-built_in">UFUNCTION</span>(BlueprintImplementableEvent)<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Log2</span><span class="hljs-params">(<span class="hljs-type">const</span> FString&amp; msg)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>.cpp</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UnkInterface.h&quot;</span></span><br></code></pre></td></tr></table></figure>

<p>这里有一点是需要注意的，C++接口中使用BlueprintNativeEvent和在普通的类中使用BlueprintNativeEvent是有所不同的，如前面所说，接口中使用BlueprintNativeEvent必须配合一个<code>virtual [FunctionName]_Implementation</code>声明并且必须实现<code>[FunctionName]_Implementation</code>函数体，而在普通的UE类中使用BlueprintNativeEvent则不需要带<code>virtual [FunctionName]_Implementation</code>声明，只需要实现<code>[FunctionName]_Implementation</code>函数体即可。</p>
<p>这可能是因为C++接口既要考虑蓝图实现，又要考虑C++实现的原因，<code>virtual [FunctionName]_Implementation</code>声明就是为了给C++实现这个函数留接口。</p>
</li>
<li><p>BlueprintImplementableEvent：BlueprintImplementableEvent标识的函数不能有C++实现，必须由蓝图来重写，BlueprintImplementableEvent标识的函数可以看成是相对于蓝图的纯虚函数。如上面代码中Log2函数，C++中是没有函数体实现的。</p>
</li>
</ul>
<h3 id="BlueprintNativeEvent和BlueprintImplementableEvent函数的蓝图实现"><a href="#BlueprintNativeEvent和BlueprintImplementableEvent函数的蓝图实现" class="headerlink" title="BlueprintNativeEvent和BlueprintImplementableEvent函数的蓝图实现"></a>BlueprintNativeEvent和BlueprintImplementableEvent函数的蓝图实现</h3><ul>
<li><p>参数中使用了FString类的时候有一个坑，即所有的FString参数都必须使用引用—FString&amp;，否则编译时会报没有找到重载的成员函数，但是使用引用又会引出另一个问题，就是引用类型参数暴漏给蓝图是作为蓝图函数返回值来使用的，如果想要FString&amp;作为输入参数，那么就必须使用const FString&amp;。</p>
</li>
<li><p>BlueprintNativeEvent和BlueprintImplementableEvent标识的函数暴漏给蓝图，根据是否有返回值在蓝图中的表现是不一样的，不带返回值的函数在蓝图中以事件的形式存在，需要通过右键菜单调出重写，在接口栏表现为一个黄色的函数标识；带返回值的函数在蓝图中表现为普通的函数，可以直接双击接口栏的函数名重写，在接口栏表现为一个蓝色的函数标识。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002037.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002037.png" alt="img"></a></p>
</li>
</ul>
<h3 id="C-调用蓝图的接口实现"><a href="#C-调用蓝图的接口实现" class="headerlink" title="C++调用蓝图的接口实现"></a>C++调用蓝图的接口实现</h3><p>UE接口的实现原理使得同一个UE接口既可以被C++继承也可以被蓝图继承，于是就会涉及到C++来调用蓝图的接口实现的情况，事实上C++调用蓝图的接口实现依旧是通过蓝图子类重写父类函数的方式实现的，只是说通过接口的方式调用可以做到比重写子类的方式更加灵活的多态。</p>
<p>比如我们现在创建6个类，分别是动物：Animal，狗狗：Dog，飞禽：Bird，母鸡：Chicken，动物园：Zoo以及接口IMove</p>
<p>Animal.h</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">UCLASS()<br><span class="hljs-keyword">class</span> <span class="hljs-symbol">MYPROJECT_API</span> <span class="hljs-symbol">AAnimal</span> : <span class="hljs-symbol">public</span> <span class="hljs-symbol">AActor,<span class="hljs-symbol">public</span></span> <span class="hljs-symbol">IMove</span><br>&#123;<br>	GENERATED_BODY()<br><span class="hljs-keyword">public</span>:	<br>	AAnimal();<br><span class="hljs-keyword">protected</span>:<br>	virtual <span class="hljs-built_in">void</span> BeginPlay() <span class="hljs-keyword">override</span>;<br><span class="hljs-keyword">public</span>:	<br>	virtual <span class="hljs-built_in">void</span> Tick(<span class="hljs-built_in">float</span> DeltaTime) <span class="hljs-keyword">override</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>Dog.h</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs perl">UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROJECT_API</span> <span class="hljs-title">ADog</span><span class="hljs-attr"> : public</span> <span class="hljs-title">AAnimal</span></span><br><span class="hljs-class"></span>&#123;<br>	GENERATED_BODY()<br>public:<br>    void Move_Implementation();<br>    &#123;<br>        UE_LOG(LogTemp, Error, TEXT(<span class="hljs-string">&quot;Dog can creep&quot;</span>));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>Bird.h</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs perl">UCLASS()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROJECT_API</span> <span class="hljs-title">ABird</span><span class="hljs-attr"> : public</span> <span class="hljs-title">AAnimal</span></span><br><span class="hljs-class"></span>&#123;<br>	GENERATED_BODY()<br>public:<br>    void Move_Implementation()<br>    &#123;<br>    	UE_LOG(LogTemp, Error, TEXT(<span class="hljs-string">&quot;Bird can fly&quot;</span>));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>Move.h</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp">UINTERFACE(MinimalAPI)<br><span class="hljs-keyword">class</span> <span class="hljs-title">UMove</span> : <span class="hljs-title">public</span> <span class="hljs-title">UInterface</span><br>&#123;<br>	GENERATED_BODY()<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROJECT_API</span> <span class="hljs-title">IMove</span><br>&#123;<br>	GENERATED_BODY()<br><span class="hljs-keyword">public</span>:<br>    UFUNCTION(BlueprintNativeEvent,Category=<span class="hljs-string">&quot;IMove&quot;</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Move</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Move_Implementation</span>()</span>;<br>    UFUNCTION(BlueprintImplementableEvent, Category = <span class="hljs-string">&quot;IMove&quot;</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Shout</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> FString&amp; Cry</span>)</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>Move.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Interface/Move.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">IMove::Move_Implementation</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">UE_LOG</span>(LogTemp, Error, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Animal can move&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Zoo.h</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp">UCLASS()<br><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROJECT_API</span> <span class="hljs-title">AZoo</span> : <span class="hljs-title">public</span> <span class="hljs-title">AActor</span><br>&#123;<br>	GENERATED_BODY()	<br><span class="hljs-keyword">public</span>:	<br>	AZoo();<br><br><span class="hljs-keyword">protected</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BeginPlay</span>() <span class="hljs-keyword">override</span></span>;<br><span class="hljs-keyword">public</span>:	<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Tick</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> DeltaTime</span>) <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AnimalObservationDiary</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AnimalAction</span>(<span class="hljs-params">AAnimal* Animal</span>)</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>Zoo.cpp</p>
<figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs sas">#include <span class="hljs-string">&quot;Interface/Zoo.h&quot;</span><br>//...<br>void AZoo::AnimalObservationDiary()<br>&#123;<br>    AAnimal<span class="hljs-comment">* Animal;</span><br>    UE_<span class="hljs-meta">LOG</span>(LogTemp, <span class="hljs-keyword">Error</span>, TEXT(<span class="hljs-string">&quot;Animal Action:&quot;</span>));<br>    Animal = GWorld-&gt;SpawnActor&lt;AAnimal&gt;();<br>    AnimalActio<span class="hljs-meta">n</span>(Animal);<br>    UE_<span class="hljs-meta">LOG</span>(LogTemp, <span class="hljs-keyword">Error</span>, TEXT(<span class="hljs-string">&quot;Dog Action:&quot;</span>));<br>    Animal = GWorld-&gt;SpawnActor&lt;ADog&gt;();<br>    AnimalActio<span class="hljs-meta">n</span>(Animal);<br>    UE_<span class="hljs-meta">LOG</span>(LogTemp, <span class="hljs-keyword">Error</span>, TEXT(<span class="hljs-string">&quot;Bird Action:&quot;</span>));<br>    Animal = GWorld-&gt;SpawnActor&lt;ABird&gt;();<br>    AnimalActio<span class="hljs-meta">n</span>(Animal);<br>    UE_<span class="hljs-meta">LOG</span>(LogTemp, <span class="hljs-keyword">Error</span>, TEXT(<span class="hljs-string">&quot;Bird Action:&quot;</span>));<br>    UClass<span class="hljs-comment">* ChickenClass = StaticLoadClass(ABird::StaticClass(), nullptr, TEXT(&quot;Blueprint&#x27;/Game/CPlus/Chicken.Chicken_C&#x27;&quot;));</span><br>    <span class="hljs-keyword">if</span> (ChickenClass != nullptr)<br>    &#123;<br>        Animal = GWorld-&gt;SpawnActor &lt;ABird&gt;(ChickenClass);<br>        AnimalActio<span class="hljs-meta">n</span>(Animal);<br>    &#125;<br>&#125;<br>void AZoo::AnimalActio<span class="hljs-meta">n</span>(AAnimal<span class="hljs-comment">* Animal)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    UClass* AnimalClass = Animal-&gt;GetClass();</span><br>    <span class="hljs-keyword">if</span> (AnimalClass-&gt;ImplementsInterface(UMove::StaticClass()))<br>    &#123;<br>        IMove<span class="hljs-comment">* Move = CastChecked&lt;IMove&gt;(Animal);</span><br>        IMove::Execute_Move(Animal);<br>        IMove::Execute_Shout(Animal, <span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以及继承自Bird的蓝图类Chicken</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002043.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002043.png" alt="img"></a></p>
<ul>
<li>ImplementsInterface：检测一个类是否实现了接口；</li>
<li><code>IMove* Move = CastChecked&lt;IMove&gt;(Animal)</code>：通过接口指针指向子类，实现多态；</li>
<li>IMove::Execute_Shout(Animal, “ “)：UE4C++调用蓝图的接口实现，由于蓝图属于C++的上层，所以UE使用了Execute_XX的反射调用方式，第一个参数必须为要调用的对象，后面用空格隔开要传入的参数。</li>
</ul>
<p>全部实现之后我们把Zoo类丢进场景里，运行下看看：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002047.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002047.png" alt="img"></a></p>
<p>可以看到C++通过接口调用到了蓝图函数。</p>
<p>这里面有一个坑，就是如果蓝图类是一个纯蓝图类直接去继承IMove接口，而不是像上面一样通过一个Animal父类去继承IMove接口，那么Zoo::AnimalAction在调用蓝图的接口实现的时候将会产生断言。</p>
<h1 id="三、字符串"><a href="#三、字符串" class="headerlink" title="三、字符串"></a>三、字符串</h1><h2 id="1-FString"><a href="#1-FString" class="headerlink" title="1.FString"></a>1.FString</h2><p>FString是UE4C++编程中极其常用的一个UE4字符串封装类型，是UE4自带字符串类型中唯一可以进行各种字符串操作的字符串类型，同时FString的资源消耗也是最大的。FString的底层事实上是一个TCHAR的数组。</p>
<h3 id="FString初始化"><a href="#FString初始化" class="headerlink" title="FString初始化"></a>FString初始化</h3><ul>
<li>方法1：</li>
</ul>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">FString fStr <span class="hljs-operator">=</span> FString(TEXT(<span class="hljs-string">&quot;str&quot;</span>))<span class="hljs-comment">; </span><br></code></pre></td></tr></table></figure>

<ul>
<li>方法2：</li>
</ul>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">FString fStr <span class="hljs-operator">=</span> FString(<span class="hljs-string">&quot;str&quot;</span>)<span class="hljs-comment">; </span><br></code></pre></td></tr></table></figure>

<ul>
<li>方法3：</li>
</ul>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">FString fStr <span class="hljs-operator">=</span> <span class="hljs-string">&quot;str&quot;</span><span class="hljs-comment">; </span><br></code></pre></td></tr></table></figure>

<ul>
<li>方法4：</li>
</ul>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">FString fStr <span class="hljs-operator">=</span> TEXT(<span class="hljs-string">&quot;str&quot;</span>)<span class="hljs-comment">; </span><br></code></pre></td></tr></table></figure>

<h3 id="FString的中文乱码"><a href="#FString的中文乱码" class="headerlink" title="FString的中文乱码"></a>FString的中文乱码</h3><p>默认情况下我们用FString存储一个中文字符串，在UE里使用，如使用UE_LOG打印是会出现乱码的情况的，这是因为VS在国区默认使用的文件编码为GB2313和UE使用的UTF-8编码不一致导的，我们需要把cpp文件的编码格式换成UTF-8即可。</p>
<p>默认情况下VS把设置文件编码的入口隐藏了起来，所以要想设置文件编码我们还需要把设置入口给显示出来。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002100.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002100.png" alt="img"></a></p>
<p>然后高级保存选项就出来了，然后设置文件编码格式。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002104.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002104.png" alt="img"></a></p>
<p>然后我们来测试一下</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">void</span> AAbstractOpreater::FStringConvert()<br>&#123;<br>    FString fStr = <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;中文&quot;</span>);<br>    UE_LOG(LogTemp, Error, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;fStr:%s&quot;</span>),*fStr);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>结果：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002108.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002108.png" alt="img"></a></p>
<h2 id="2-FName"><a href="#2-FName" class="headerlink" title="2.FName"></a>2.FName</h2><p>FName也是UE4自带的字符串类型，FName是不区分大小写的，赋予FName的字符串会被存放到UE4的数据表中，多个FName赋予相同的字符串时都会指向同一个数据表地址。FName被赋值之后不可改变也不能被操作，FName的不可改变的性质和C++的string类很相似，std::string在修改时事实上是创建了一个新的字符串，而不是修改原字符串，因为FName的这些性质使得FName的查找和访问非常快。</p>
<ul>
<li>FName的初始化</li>
</ul>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">FName fn1 <span class="hljs-operator">=</span> FName(TEXT(<span class="hljs-string">&quot;str&quot;</span>))<span class="hljs-comment">;</span><br>FName fn2 <span class="hljs-operator">=</span> FName(<span class="hljs-string">&quot;str&quot;</span>)<span class="hljs-comment">;</span><br>FName fn3 <span class="hljs-operator">=</span> <span class="hljs-string">&quot;str&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<h2 id="3-FText"><a href="#3-FText" class="headerlink" title="3.FText"></a>3.FText</h2><p>FText是一个FString的升级版字符串，存储容量比FString要大很多，主要用于UE4的文本存储与处理。FText主要涉及UE的文本本地化处理。</p>
<p>FText不可以像FString和FName一样从构造函数通过TCHAR构建，FText从构造函数只能构建一个空FText，要想构建一个有内容的FText，则需要使用FText::FromString，FText::FromName，FText::AsCultureInvariant。</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">FString</span> <span class="hljs-variable">fStr</span> = <span class="hljs-function"><span class="hljs-title">TEXT</span>(<span class="hljs-string">&quot;fStr&quot;</span>);</span><br><span class="hljs-function"><span class="hljs-variable">FName</span> <span class="hljs-variable">fn</span> = <span class="hljs-title">FName</span>(<span class="hljs-title">TEXT</span>(<span class="hljs-string">&quot;fn&quot;</span>));</span><br><span class="hljs-function"><span class="hljs-variable">FText</span> <span class="hljs-variable">ft1</span> = <span class="hljs-title">FText</span>();</span><br><span class="hljs-function"><span class="hljs-variable">FText</span> <span class="hljs-variable">ft2</span> = <span class="hljs-variable">FText</span>::<span class="hljs-title">FromString</span>(<span class="hljs-variable">fStr</span>);</span><br><span class="hljs-function"><span class="hljs-variable">FText</span> <span class="hljs-variable">ft3</span> = <span class="hljs-variable">FText</span>::<span class="hljs-title">AsCultureInvariant</span>(<span class="hljs-variable">fStr</span>);</span><br></code></pre></td></tr></table></figure>

<h2 id="4-TCHAR"><a href="#4-TCHAR" class="headerlink" title="4.TCHAR"></a>4.TCHAR</h2><p>TCHAR就是UE层面的char类型了，TCHAR是UE对C++的char和wchar_t的封装，C++的char和wchar_t适用于不同的平台，而TCHAR则将二者的操作进行了统一，使得TCHAR具备可以移植性。</p>
<p>事实上TCHAR不是对char和wchar_t的直接封装，UE将char封装成了ANSICHAR，将wchar_t封装成了WIDECHAR，而TCHAR则是对ANSICHAR和WIDECHAR的再封装。</p>
<p>UE对C++类型的封装都在GenericPlatform.h文件里。</p>
<h2 id="7-TChar"><a href="#7-TChar" class="headerlink" title="7.TChar"></a>7.TChar</h2><p>TChar是一个针对ASCII编码的字符串操作的封装泛型结构体，提供一系列方法操作字符串。</p>
<p>其中UE还对专门将<code>TChar&lt;TCHAR&gt;</code>封装成了<code>FChar</code>，将<code>TChar&lt;WIDECHAR&gt;</code>封装成了<code>FCharWide</code>，将<code>TChar&lt;ANSICHAR&gt;</code>封装成了<code>FCharAnsi</code></p>
<h2 id="8-TCString"><a href="#8-TCString" class="headerlink" title="8.TCString"></a>8.TCString</h2><p>TCString和TChar类似，是UE专门封装的用于处理C字符串的泛型结构体，其中对ANSICHAR和WIDECHAR字符做了专门实现，提供一系列方法操作C字符串。</p>
<p>和TChar一样，TCString也对一些常用的类型做了封装，<code>TCString&lt;TCHAR&gt;</code>封装成<code>FCString</code>，<code>TCString&lt;ANSICHAR&gt;</code>封装成<code>FCStringAnsi</code>，<code>TCString&lt;WIDECHAR&gt;</code>封装成<code>FCStringWide</code>。</p>
<h2 id="9-TStringView"><a href="#9-TStringView" class="headerlink" title="9.TStringView"></a>9.TStringView</h2><p>TStringView和FString用法基本上是一样的，底层也是对TCHAR的封装，只是TStringView有着自己的特殊的使用场景，按照源码的说明就是：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * String View</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * A string view is implicitly constructible from const char* style strings and from compatible character ranges such as FString and TStringBuilderBase.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * A string view does not own any data nor does it attempt to control any lifetimes, it merely points at a subrange of characters in some other string. It&#x27;s up to the user to ensure the underlying string stays valid for the lifetime of the string view.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * A string view is cheap to copy and is intended to be passed by value.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * A string view does not represent a NUL terminated string and therefore you should never pass in the pointer returned by GetData() into a C-string API accepting only a pointer. You must either use a string builder to make a properly terminated string, or use an API that accepts a length argument in addition to the C-string.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * String views are a good fit for arguments to functions which don&#x27;t wish to care which style of string construction is used by the caller. If you accept strings via string views then the caller is free to use FString, FStringBuilder, raw C strings, or any other type which can be converted into a string view.</span><br><span class="hljs-comment"> **/</span><br></code></pre></td></tr></table></figure>

<p>谷歌翻译过来就是：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs markdown">/**<br><span class="hljs-bullet"> *</span> 字符串视图<br><span class="hljs-bullet"> *</span><br> * 字符串视图可以从 const char* 样式字符串和兼容的字符范围（例如 FString 和 TStringBuilderBase）隐式构造。<br><span class="hljs-bullet"> *</span><br> * 字符串视图不拥有任何数据，也不尝试控制任何生命周期，它仅指向其他字符串中的字符子范围。由用户确保底层字符串在字符串视图的生命周期内保持有效。<br><span class="hljs-bullet"> *</span><br> * 字符串视图复制起来很便宜，并且旨在按值传递。<br><span class="hljs-bullet"> *</span><br> * 字符串视图不代表 NUL 终止的字符串，因此您永远不应将 GetData() 返回的指针传递给仅接受指针的 C 字符串 API。您必须使用字符串生成器来生成正确终止的字符串，或者使用除了 C 字符串之外还接受长度参数的 API。<br><span class="hljs-bullet"> *</span><br> * 字符串视图非常适合不希望关心调用者使用哪种字符串构造方式的函数的参数。如果您通过字符串视图接受字符串，则调用者可以自由使用 FString、FStringBuilder、原始 C 字符串或任何其他可以转换为字符串视图的类型。<br> <span class="hljs-strong">**/</span><br></code></pre></td></tr></table></figure>

<p>和TChar，TCString一样，TStringView也将<code>TStringView&lt;TCHAR&gt;</code>封装成了<code>FStringView</code>，<code>TStringView&lt;ANSICHAR&gt;</code>封装成了<code>FAnsiStringView</code>，<code>TStringView&lt;WIDECHAR&gt;</code>封装成了<code>FWideStringView</code>。</p>
<p>不过TStringView实际使用过程中好像也没什么用😂。</p>
<h2 id="10-TEXT"><a href="#10-TEXT" class="headerlink" title="10.TEXT()"></a>10.TEXT()</h2><p>TEXT宏又是对TCHAR的一层封装，使得TCHAR更易于使用，TEXT宏可以使其包裹的字符串根据设备自行选择最适合的编码格式，所以在UE里使用字符串时最好使用TEXT宏包裹，使代码的兼容性更好。</p>
<p>需要注意的是TEXT()宏不支持中文，如果转码中文UE4在打印时会变成乱码。</p>
<h2 id="11-各字符串之间的转换"><a href="#11-各字符串之间的转换" class="headerlink" title="11.各字符串之间的转换"></a>11.各字符串之间的转换</h2><h3 id="FString-FName"><a href="#FString-FName" class="headerlink" title="FString-&gt;FName"></a>FString-&gt;FName</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">FString fStr <span class="hljs-operator">=</span> TEXT(<span class="hljs-string">&quot;fStr&quot;</span>)<span class="hljs-comment">;</span><br>FName fn <span class="hljs-operator">=</span> FName(*fStr)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<h3 id="FString-FText"><a href="#FString-FText" class="headerlink" title="FString-&gt;FText"></a>FString-&gt;FText</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">FString fStr</span> = TEXT(<span class="hljs-string">&quot;fStr&quot;</span>);<br><span class="hljs-attribute">FText ft</span> = FText::FromString(fStr)<br></code></pre></td></tr></table></figure>

<h3 id="FString-bool"><a href="#FString-bool" class="headerlink" title="FString-&gt;bool"></a>FString-&gt;bool</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">FString fStr <span class="hljs-operator">=</span> TEXT(<span class="hljs-string">&quot;fStr&quot;</span>)<span class="hljs-comment">;</span><br>bool b <span class="hljs-operator">=</span> fStr.ToBool()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<h3 id="FString-int"><a href="#FString-int" class="headerlink" title="FString-&gt;int"></a>FString-&gt;int</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">FString fStr</span> = TEXT(<span class="hljs-string">&quot;fStr&quot;</span>);<br><span class="hljs-attribute">int i</span> = FCString::Atoi<span class="hljs-comment">(*fStr);</span><br></code></pre></td></tr></table></figure>

<h3 id="FString-float"><a href="#FString-float" class="headerlink" title="FString-&gt;float"></a>FString-&gt;float</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">FString fStr</span> = TEXT(<span class="hljs-string">&quot;fStr&quot;</span>);<br><span class="hljs-attribute">float f</span> = FCString::Atof<span class="hljs-comment">(*fStr);</span><br></code></pre></td></tr></table></figure>

<h3 id="FString-char"><a href="#FString-char" class="headerlink" title="FString-&gt;char*"></a>FString-&gt;char*</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">FString fStr <span class="hljs-operator">=</span> TEXT(<span class="hljs-string">&quot;fStr&quot;</span>)<span class="hljs-comment">;</span><br>char* chr <span class="hljs-operator">=</span> TCHAR_TO_ANSI(*fStr)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<h3 id="FString-std-string"><a href="#FString-std-string" class="headerlink" title="FString-&gt;std::string"></a>FString-&gt;std::string</h3><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">FString fStr = <span class="hljs-keyword">TEXT</span>(<span class="hljs-string">&quot;fStr&quot;</span>);<br><span class="hljs-symbol">std:</span>:<span class="hljs-type">string</span> str = TCHAR_TO_UTF8(*fStr);<br></code></pre></td></tr></table></figure>

<h3 id="char-FString"><a href="#char-FString" class="headerlink" title="char* -&gt;FString"></a>char* -&gt;FString</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">char* chr <span class="hljs-operator">=</span> <span class="hljs-string">&quot;chr&quot;</span><span class="hljs-comment">;</span><br>FString fStr <span class="hljs-operator">=</span> ANSI_TO_TCHAR(chr)<br></code></pre></td></tr></table></figure>

<h3 id="std-string-FString"><a href="#std-string-FString" class="headerlink" title="std::string-&gt;FString"></a>std::string-&gt;FString</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">std::string str = <span class="hljs-string">&quot;str&quot;</span><br>FString fStr = <span class="hljs-built_in">FString</span>(str.<span class="hljs-built_in">c_str</span>());<br></code></pre></td></tr></table></figure>

<h3 id="FName-FStirng"><a href="#FName-FStirng" class="headerlink" title="FName-&gt;FStirng"></a>FName-&gt;FStirng</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">FName fn <span class="hljs-operator">=</span> FName(<span class="hljs-string">&quot;fn&quot;</span>)<span class="hljs-comment">;</span><br>FString fstr <span class="hljs-operator">=</span> fn.ToString()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<h3 id="FText-FString"><a href="#FText-FString" class="headerlink" title="FText-&gt;FString"></a>FText-&gt;FString</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">FText ft <span class="hljs-operator">=</span> FText(<span class="hljs-string">&quot;ft&quot;</span>)<span class="hljs-comment">;</span><br>FString fstr <span class="hljs-operator">=</span> ft.ToString()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<h3 id="float-FString"><a href="#float-FString" class="headerlink" title="float-&gt;FString"></a>float-&gt;FString</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">float</span> FloatValue = <span class="hljs-number">0</span>.<span class="hljs-number">1</span>f;<br><span class="hljs-attribute">FString</span> fstr = FString::SanitizeFloat(FloatValue);<br></code></pre></td></tr></table></figure>

<h3 id="int-FString"><a href="#int-FString" class="headerlink" title="int-&gt;FString"></a>int-&gt;FString</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">int IntValue</span> = 1;<br><span class="hljs-attribute">FString fstr</span> = FString::FromInt(IntValue);<br></code></pre></td></tr></table></figure>

<h3 id="bool-FString"><a href="#bool-FString" class="headerlink" title="bool-&gt;FString"></a>bool-&gt;FString</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">bool</span> InBool = <span class="hljs-keyword">true</span><br>FString fstr = InBool?TEXT(&quot;true&quot;):TEXT(&quot;false&quot;);<br></code></pre></td></tr></table></figure>

<h3 id="FVector-FString"><a href="#FVector-FString" class="headerlink" title="FVector-&gt;FString"></a>FVector-&gt;FString</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">FVector</span> Vec = FVector(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br><span class="hljs-attribute">FString</span> fstr = Vec.ToString();<br></code></pre></td></tr></table></figure>

<h3 id="FVector2D-FString"><a href="#FVector2D-FString" class="headerlink" title="FVector2D-&gt;FString"></a>FVector2D-&gt;FString</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">FVector2D</span> Vec2D = FVector2D(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br><span class="hljs-attribute">FString</span> fstr = Vec2D.ToString();<br></code></pre></td></tr></table></figure>

<h3 id="FRotator-FString"><a href="#FRotator-FString" class="headerlink" title="FRotator-&gt;FString"></a>FRotator-&gt;FString</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">FRotator</span> Rot = FRotator(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br><span class="hljs-attribute">FString</span> fstr = Rot.ToString();<br></code></pre></td></tr></table></figure>

<h3 id="UObject-FString"><a href="#UObject-FString" class="headerlink" title="UObject-&gt;FString"></a>UObject-&gt;FString</h3><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">UObject* InObj = NewObject&lt;UObject&gt;();<br>FString fstr = (InObj != NULL)?InObj-&gt;GetName():FString(TEXT(<span class="hljs-string">&quot;None&quot;</span>));<br></code></pre></td></tr></table></figure>

<h2 id="12-TCHAR与char，wchar-t的转换"><a href="#12-TCHAR与char，wchar-t的转换" class="headerlink" title="12.TCHAR与char，wchar_t的转换"></a>12.TCHAR与char，wchar_t的转换</h2><p>C++支持两种字符集：ANSI和Unicode，ANSI字符集对应char，Unicode字符集对应wchar_t，其中Unicode字符集又分为三种编码：UTF-8，UTF-16，UTF-32，不同的字符集适应不用的平台，而TCHAR是UE对C++的char和wchat_t的封装，统一了char和wchar_t的操作，是UE的字符具有可移植性。</p>
<ul>
<li><p>TCHAR_TO_ANSI：使用ANSI字符集将<code>TCHAR*</code>转换成<code>char*</code>；</p>
</li>
<li><p>ANSI_TO_TCAHR：将ANSI字符集的<code>char*</code>转换成<code>TCHAR*</code>；</p>
</li>
<li><p>TCHAR_TO_UTF8：使用Unicode字符集UTF-8编码将<code>TCHAR*</code>转换成<code>char*</code>；</p>
</li>
<li><p>UTF8_TO_TCAHR：将Unicode字符集UTF-8编码的<code>char*</code>转换成<code>TCHAR*</code>。</p>
<p>同理还有TCAHR_TO_UTF16，UFT16_TO_TCAHR，TCHAR_TO_UTF32，UTF32_TO_TCHAR。</p>
</li>
<li><p>TCHAR_TO_WCHAR：将<code>TCAHR*</code>转换成<code>wchar_t*</code>；</p>
</li>
<li><p>WCHAR_TO_TCAHR：将<code>wchat_t*</code>转换成<code>TCAHR*</code>，或者使用强转，如：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">wchar_t str <span class="hljs-operator">=</span> L<span class="hljs-string">&quot;str&quot;</span><span class="hljs-comment">;</span><br>TCAHR* tchr <span class="hljs-operator">=</span> (TCAHR*)str<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<h1 id="四、枚举与结构体"><a href="#四、枚举与结构体" class="headerlink" title="四、枚举与结构体"></a>四、枚举与结构体</h1></li>
</ul>
<h2 id="1-枚举"><a href="#1-枚举" class="headerlink" title="1.枚举"></a>1.枚举</h2><p>UE遵循C++11标准，所以枚举的构造有两种形式：</p>
<p>C++11以前的标准形式</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">UENUM()<br><span class="hljs-keyword">namespace</span> <span class="hljs-symbol">EnumSpace</span><br>&#123;<br>    <span class="hljs-keyword">enum</span> NEnum<br>    &#123;<br>        NE_A,<br>        NE_B<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这种形式的枚举不能通过<code>:</code>去指定枚举使用的索引类型，也不能使用UENUM(BlueprintType)宏暴露给蓝图，尽管加了这个宏编译不会报错，但是蓝图里面识别不到这个枚举，所以也没法使用UMETA()宏去设置枚举成员，同时也不支持反射。</p>
<p>C++11的标准形式</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl">UENUM(BlueprintType)<br>enum <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MEnum</span><span class="hljs-attr"> : uint8</span></span><br><span class="hljs-class"></span>&#123;<br>    ME_A     UMETA(DisplayName=<span class="hljs-string">&quot;MEnumA&quot;</span>),<br>    ME_B     UMETA(DisplayName=<span class="hljs-string">&quot;MEnumB&quot;</span>)<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这种形式可以暴露给蓝图，也可以使用<code>:</code>指定枚举的索引类型，还可以使用UMETA宏描述枚举成员，同时可以使用UE提供的枚举反射函数。如：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002120.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002120.png" alt="img"></a></p>
<h2 id="2-UMETA"><a href="#2-UMETA" class="headerlink" title="2.UMETA"></a>2.UMETA</h2><p>UMETA宏是枚举成员专用的元数据说明宏，和UFUNCTION，UCALSS，UPROPERTY以及UINTERFACE中使用的meta效果上是一样的，注意这里说的是枚举成员而不是枚举类型，枚举类型的元数据也使用meta。</p>
<p>UMETA可以使用的元数据说明符详情参见<a target="_blank" rel="noopener" href="https://goulandis.github.io/2022/10/16/%E3%80%90UE4%E3%80%91C++%E7%BC%96%E7%A8%8B/#meta">第八章宏第4节meta</a>。</p>
<h2 id="3-结构体"><a href="#3-结构体" class="headerlink" title="3.结构体"></a>3.结构体</h2><p>根据<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/GameplayArchitecture/Structs/">官方文档</a>的说法，UE结构体通过USTRUCT宏支持了UE的反射系统，支持UPROPERTY属性反射，但是由于结构体不继承自UObject所以不支持GC，也不支持UFUNCTION，所以结构体中的函数无法暴露给蓝图。</p>
<p>通过UPROPERTY(BlueprintReadWrite)可以将结构体的属性暴露给蓝图，如果不暴露的话，蓝图将无法识别到结构体中的属性。</p>
<p>结构体的命名必须以F开头，否则编译不通过。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs abnf">USTRUCT(BlueprintType)<br>struct FStru<br>&#123;<br>    GENERATED_BODY()<br>        <br>    UPROPERTY()<br>    FString tchr <span class="hljs-operator">=</span> TEXT(<span class="hljs-string">&quot;tchr&quot;</span>)<span class="hljs-comment">;</span><br>    FString GetTCHR()<br>    &#123;<br>        return tchr<span class="hljs-comment">;</span><br>    &#125;<br>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>结构体有两种写法，上面是一种，另种是：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs abnf">USTRUCT(BlueprintType)<br>struct FStru<br>&#123;<br>    GENERATED_USTRUCT_BODY()<br>        <br>    UPROPERTY()<br>    FString tchr <span class="hljs-operator">=</span> TEXT(<span class="hljs-string">&quot;tchr&quot;</span>)<span class="hljs-comment">;</span><br>    FString GetTCHR()<br>    &#123;<br>        return tchr<span class="hljs-comment">;</span><br>    &#125;<br>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>GENERATED_BODY和GENERARED_USTRUCT_BODY没有什么区别，在结构体中GENERATED_BODY就是GENERARED_USTRUCT_BODY，这是因为结构体不存在父类构造函数这一说，UE在ObjectMacros.h中做了预定义：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">GENERATED_USTRUCT_BODY</span>(...) <span class="hljs-built_in">GENERATED_BODY</span>()<br></code></pre></td></tr></table></figure>

<h1 id="五、蓝图函数库"><a href="#五、蓝图函数库" class="headerlink" title="五、蓝图函数库"></a>五、蓝图函数库</h1><p>C++蓝图函数库是一个UBlueprintFunctionLibrary的派生类，C++蓝图函数库存在的目的就是把C++的函数暴露给蓝图使用，所以函数库里的函数均需要使用static标识，且使用UFUNCTION(BlueprintCallable)暴露给蓝图，二者缺一，蓝图都无法识别到函数库里的函数。</p>
<p>由于静态函数是属于类的，所以无论函数是private、protected还是public都可以被蓝图识别到，但是函数库里的属性无论是否暴露给蓝图，蓝图都识别不到。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">UCLASS</span>()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MYPROJECT_API</span> UFunLib : <span class="hljs-keyword">public</span> UBlueprintFunctionLibrary<br>&#123;<br>    <span class="hljs-built_in">GENERATED_BODY</span>()<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UPROPERTY</span>(BlueprintReadWrite, Category=<span class="hljs-string">&quot;FunLib&quot;</span>)<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="hljs-string">&quot;FunLib&quot;</span>)<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Log</span><span class="hljs-params">()</span></span>;	<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002126.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002126.png" alt="img"></a></p>
<h1 id="六、代理"><a href="#六、代理" class="headerlink" title="六、代理"></a>六、代理</h1><p>C++自身不支持委托，所以UE自己用宏实现了委托，在UE里又叫代理。由于UE的代理是用宏来实现声明的，所以UE的代理没有办法像C#一样声明任意数量任意类型参数的代理，所以UE的代理就出现了一个很诡异的现象，即不同参数个数的代理需要使用不同的宏来声明，虽然很二，但是UE没法像底层语言一样自己去创建一个关键字来标识代理，这也许是在限制条件下的最优解了。</p>
<h2 id="1-代理的分类"><a href="#1-代理的分类" class="headerlink" title="1.代理的分类"></a>1.代理的分类</h2><h3 id="根据可绑定的响应函数的数量分"><a href="#根据可绑定的响应函数的数量分" class="headerlink" title="根据可绑定的响应函数的数量分"></a>根据可绑定的响应函数的数量分</h3><p><strong>单播代理</strong></p>
<p>单播代理只能绑定一个响应函数，形式如：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">//无返回值，无参数</span><br>DECLARE_DELEGATE(FDelegateOne);<br><span class="hljs-comment">//无返回值，两个参数</span><br>DECLARE_DELEGATE_TwoParams(FDelegateTwo, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">bool</span>);<br><span class="hljs-comment">//以此类推到</span><br>DECLARE_DELEGATE_NineParams(FDelegateNine,<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>);<br><span class="hljs-comment">//返回bool类型，两个参数</span><br>DECLARE_DELEGATE_RetVal_TwoParams(<span class="hljs-built_in">bool</span>, FDelegateTwo, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>);<br></code></pre></td></tr></table></figure>

<p><strong>多播代理</strong></p>
<p>多播代理可以绑定多个响应函数，形式如：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">//无返回值，无参数</span><br><span class="hljs-built_in">DECLARE_MULTICAST_DELEGATE</span>(FMulticastDelegateNone);<br><span class="hljs-comment">//无返回值，一个参数</span><br><span class="hljs-built_in">DECLARE_MULTICAST_DELEGATE_OneParam</span>(FMulticastDelegateOne, FString);<br><span class="hljs-comment">//同理类推到九个参数</span><br></code></pre></td></tr></table></figure>

<p>需要注意，所有的多播代理都没有返回值。</p>
<h3 id="根据是否可蓝图调用分"><a href="#根据是否可蓝图调用分" class="headerlink" title="根据是否可蓝图调用分"></a>根据是否可蓝图调用分</h3><p>静态&#x2F;动态，单播&#x2F;多播，有&#x2F;无返回值，参数个数，四个维度除了动态多播不能有返回值外其他的可以自由的互相组合。</p>
<p><strong>静态代理</strong></p>
<p>静态代理只能在C++中使用，前面单播代理和多播代理的例子都属于静态代理。</p>
<p>如：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">DECLARE_DELEGATE_RetVal_OneParam</span>(bool,FDynamicDelegateOne, FString,Str);<br></code></pre></td></tr></table></figure>

<p><strong>动态代理</strong></p>
<p>动态代理支持序列化，可以直接使用函数名字符串来创建委托，而无需传递函数入口地址，只有动态多播可以暴露给蓝图使用，使用UPROPERTY(BlueprintAssignable)标识即可暴露。</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">error </span>: &#x27;BlueprintAssignable&#x27; is only allowed on multicast delegate properties<br>DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParam(FDynamicMulticastDelegateOne, FString,param1,int,param2);<br></code></pre></td></tr></table></figure>

<p>动态代理在声明的时候和其他代理有所不同，不像其他代理声明含参代理时只需要注明参数类型，动态代理声明含参代理的时候必须注明参数类型和参数名，并且用<code>,</code>隔开。动态多播不能有返回值。</p>
<p>需要注意的时，代理的名称必须以F开头。</p>
<h2 id="2-代理的声明"><a href="#2-代理的声明" class="headerlink" title="2.代理的声明"></a>2.代理的声明</h2><p>代理可以声明在类内也可以声明在类外，声明在类的内外在实际效果上没有区别，只是在声明代理对象时有所区别，如：</p>
<h3 id="在类内声明代理对象"><a href="#在类内声明代理对象" class="headerlink" title="在类内声明代理对象"></a>在类内声明代理对象</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;GameFramework/Actor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Announcer.generated.h&quot;</span></span><br><span class="hljs-comment">//在类外声明代理</span><br><span class="hljs-built_in">DECLARE_DELEGATE_RetVal_OneParam</span>(FString, FMagazineNumberFive, <span class="hljs-type">int</span>);<br><span class="hljs-built_in">DECLARE_MULTICAST_DELEGATE_OneParam</span>(FMagazineNumberSix, <span class="hljs-type">int</span>);<br><span class="hljs-built_in">DECLARE_DYNAMIC_DELEGATE_RetVal_OneParam</span>(FString, FMagazineNumberSeven, <span class="hljs-type">int</span>, ReleaseNumber);<br><span class="hljs-built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam</span>(FMagazineNumberEight, <span class="hljs-type">int</span>, ReleaseNumber);<br><br><span class="hljs-built_in">UCLASS</span>()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MYPROJECT_API</span> AAnnouncer : <span class="hljs-keyword">public</span> AActor<br>&#123;<br>	<span class="hljs-built_in">GENERATED_BODY</span>()<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//在类内声明代理</span><br>    <span class="hljs-built_in">DECLARE_DELEGATE_RetVal_OneParam</span>(FString, FMagazineNumberOne, <span class="hljs-type">int</span>);<br>    <span class="hljs-built_in">DECLARE_MULTICAST_DELEGATE_OneParam</span>(FMagazineNumberTwo, <span class="hljs-type">int</span>);<br>    <span class="hljs-built_in">DECLARE_DYNAMIC_DELEGATE_RetVal_OneParam</span>(FString, FMagazineNumberThree, <span class="hljs-type">int</span>, ReleaseNumber);<br>    <span class="hljs-built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam</span>(FMagazineNumberFour, <span class="hljs-type">int</span>, ReleaseNumber);<br><br>    <span class="hljs-comment">//声明代理对象</span><br>    FMagazineNumberOne MagazineNumberOne;<br>    FMagazineNumberTwo MagazineNumberTwo;<br>    FMagazineNumberThree MagazineNumberThree;<br>    FMagazineNumberFour MagazineNumberFour;<br><br>    FMagazineNumberFive MagazineNumberFive;<br>    FMagazineNumberSix MagazineNumberSix;<br>    FMagazineNumberSeven MagazineNumberSeven;<br>    FMagazineNumberEight MagazineNumberEight;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> AAnnouncer* Announcer;<br><span class="hljs-keyword">public</span>:	<br>	<span class="hljs-built_in">AAnnouncer</span>();<br>    <span class="hljs-function"><span class="hljs-type">static</span> AAnnouncer* <span class="hljs-title">GetAnnouncerInstance</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OnPublicate</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">protected</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-keyword">public</span>:	<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Tick</span><span class="hljs-params">(<span class="hljs-type">float</span> DeltaTime)</span> <span class="hljs-keyword">override</span></span>;<br><br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="在类外声明代理对象"><a href="#在类外声明代理对象" class="headerlink" title="在类外声明代理对象"></a>在类外声明代理对象</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Delegate/Announcer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;GameFramework/Actor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;SubscripterNumberOne.generated.h&quot;</span></span><br><br><span class="hljs-built_in">UCLASS</span>()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MYPROJECT_API</span> ASubscripterNumberOne : <span class="hljs-keyword">public</span> AActor<br>&#123;<br>	<span class="hljs-built_in">GENERATED_BODY</span>()<br><span class="hljs-keyword">public</span>:	<br>	<span class="hljs-built_in">ASubscripterNumberOne</span>();<br>    <span class="hljs-comment">//声明在类内的代理声明代理对象</span><br>    AAnnouncer::FMagazineNumberOne MagazineNumberOne;<br>    <span class="hljs-comment">//声明在类外的代理声明代理对象</span><br>    FMagazineNumberFive MagazineNumberFive;<br><span class="hljs-keyword">protected</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-keyword">public</span>:	<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Tick</span><span class="hljs-params">(<span class="hljs-type">float</span> DeltaTime)</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="3-代理的绑定"><a href="#3-代理的绑定" class="headerlink" title="3.代理的绑定"></a>3.代理的绑定</h2><p>声明了代理对象之后就可以往对象身上绑定执行函数了，根据代理和执行函数的不同，绑定的方式也有所不同。</p>
<h3 id="静态单播"><a href="#静态单播" class="headerlink" title="静态单播"></a>静态单播</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-literal">void</span> ASubscripterNumberOne::BeginPlay()<br>&#123;<br>	Super::BeginPlay();<br>	<span class="hljs-regexp">//BindUObject-绑定UObject类的函数到单播代理,可以是UFUNCTION函数也可以不是</span><br><span class="hljs-regexp">    //</span>AAnnouncer::GetAnnouncerInstance<span class="hljs-function"><span class="hljs-params">()</span>-&gt;</span>MagazineNumberOne.BindUObject(this, &amp;ASubscripterNumberOne::SubscriptMagazineOne);<br><br>    <span class="hljs-regexp">//BindUFunction-通过名字绑定UObject类的UFUNCTION函数到单播代理</span><br><span class="hljs-regexp">    //</span>AAnnouncer::GetAnnouncerInstance<span class="hljs-function"><span class="hljs-params">()</span>-&gt;</span>MagazineNumberOne.BindUFunction(this, <span class="hljs-string">&quot;SubscriptMagazineOne&quot;</span>);<br><br>    <span class="hljs-regexp">//BindUFunction-通过名字绑定UObject类的静态UFUNCTION函数</span><br><span class="hljs-regexp">    //</span>AAnnouncer::GetAnnouncerInstance<span class="hljs-function"><span class="hljs-params">()</span>-&gt;</span>MagazineNumberOne.BindUFunction(this, STATIC_FUNCTION_FNAME(TEXT(<span class="hljs-string">&quot;ASubscripterNumberOne::SubscriptMagazineOneStatic&quot;</span>)));<br><br>    <span class="hljs-regexp">//BindRaw-绑定指向的C++类的函数的共享指针到单播代理</span><br><span class="hljs-regexp">    //</span>TSharedPtr&lt;FSubscripterNumberThree&gt; SubscripterNumberThree = MakeShareable(<span class="hljs-keyword">new</span> FSubscripterNumberThree());<br>    <span class="hljs-regexp">//MagazineNumberOne.BindRaw(SubscripterNumberThree.Get(), &amp;FSubscripterNumberThree::SubscriptMagazineOne);</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">    //</span>BindSP-绑定指向的C++类的函数的共享引用到单播代理<br>    <span class="hljs-regexp">//TSharedRef&lt;FSubscripterNumberThree&gt;  SubscripterNumberThree  = MakeShareable(new FSubscripterNumberThree());</span><br><span class="hljs-regexp">    //</span>AAnnouncer::GetAnnouncerInstance<span class="hljs-function"><span class="hljs-params">()</span>-&gt;</span>MagazineNumberOne.BindSP(SubscripterNumberThree, &amp;FSubscripterNumberThree::SubscriptMagazineOne);<br><br>    <span class="hljs-regexp">//BindThreadSafeSP-绑定指向的C++类的函数的线程安全的共享引用到单播代理</span><br><span class="hljs-regexp">    //</span>TSharedRef&lt;FSubscripterNumberThree,ESPMode::ThreadSafe&gt; SubscripterNumberThree = MakeShareable(<span class="hljs-keyword">new</span> FSubscripterNumberThree());<br>    <span class="hljs-regexp">//AAnnouncer::GetAnnouncerInstance()-&gt;MagazineNumberOne.BindThreadSafeSP(SubscripterNumberThree, &amp;FSubscripterNumberThree::SubscriptMagazineOne);</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">    //</span>BindLambda-绑定Lambda表达式到单播代理<br>    <span class="hljs-regexp">//MagazineNumberOne.BindLambda([](int ReleaseNumber)-&gt;FString &#123;</span><br><span class="hljs-regexp">    //</span>    TArray&lt;FStringFormatArg&gt; Arguments;<br>    <span class="hljs-regexp">//    Arguments.Add(FStringFormatArg((int32)ReleaseNumber));</span><br><span class="hljs-regexp">    //</span>    Arguments.Add(FStringFormatArg((int32)ReleaseNumber));<br>    <span class="hljs-regexp">//    FString PublicateContentOne = FString::Format(TEXT(&quot;发布者发布了&#123;0&#125;号杂志给订阅者3号，发布号:&#123;1&#125;&quot;), Arguments);</span><br><span class="hljs-regexp">    //</span>    UE_LOG(LogTemp, <span class="hljs-built_in">Error</span>, TEXT(<span class="hljs-string">&quot;%s&quot;</span>), *PublicateContentOne);<br>    <span class="hljs-regexp">//    return PublicateContentOne;</span><br><span class="hljs-regexp">    //</span>    &#125;);<br><br>    <span class="hljs-regexp">//BindWeakLambda-将Lambda表达式与指定对象进行弱关联，再绑定这个对象关联的Lambda表达式到单播代理</span><br><span class="hljs-regexp">    //</span>AAnnouncer::GetAnnouncerInstance<span class="hljs-function"><span class="hljs-params">()</span>-&gt;</span>MagazineNumberOne.BindWeakLambda(this, [](int ReleaseNumber) &#123;<br>    <span class="hljs-regexp">//    TArray&lt;FStringFormatArg&gt; Arguments;</span><br><span class="hljs-regexp">    //</span>    Arguments.Add(FStringFormatArg((int32)ReleaseNumber));<br>    <span class="hljs-regexp">//    Arguments.Add(FStringFormatArg((int32)ReleaseNumber));</span><br><span class="hljs-regexp">    //</span>    FString PublicateContentOne = FString::Format(TEXT(<span class="hljs-string">&quot;发布者发布了&#123;0&#125;号杂志给订阅者1号，发布号:&#123;1&#125;&quot;</span>), Arguments);<br>    <span class="hljs-regexp">//    UE_LOG(LogTemp, Error, TEXT(&quot;%s&quot;), *PublicateContentOne);</span><br><span class="hljs-regexp">    //</span>    <span class="hljs-keyword">return</span> PublicateContentOne;<br>    <span class="hljs-regexp">//   &#125;);</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">    //</span>BindStatic-绑定静态函数到单播代理，在类内外都可以使用，函数可以UFUNCTION函数也可以不是<br>    <span class="hljs-regexp">//AAnnouncer::GetAnnouncerInstance()-&gt;MagazineNumberOne.BindStatic(ASubscripterNumberOne::SubscriptMagazineOneStatic);</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">    //</span>BindStatic-绑定静态函数到单播代理，只能在类内使用，函数可以UFUNCTION函数也可以不是<br>    AAnnouncer::GetAnnouncerInstance<span class="hljs-function"><span class="hljs-params">()</span>-&gt;</span>MagazineNumberOne.BindStatic(SubscriptMagazineOneStatic);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>单播对象被销毁时会自动在析构函数中调用UnBind解绑</p>
<h3 id="静态多播"><a href="#静态多播" class="headerlink" title="静态多播"></a>静态多播</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-literal">void</span> ASubscripterNumberOne::BeginPlay()<br>&#123;<br>	Super::BeginPlay();<br>    <span class="hljs-regexp">//AddUObject-添加一个UObject类的函数到多播代理</span><br><span class="hljs-regexp">    AAnnouncer::GetAnnouncerInstance()-&gt;MagazineNumberTwo.AddUObject(this, &amp;ASubscripterNumberOne::SubscriptMagazineTwo);</span><br><span class="hljs-regexp">    //</span>AddUFunction-通过名字添加UObject类的UFUNCTION函数到多播代理<br>    AAnnouncer::GetAnnouncerInstance<span class="hljs-function"><span class="hljs-params">()</span>-&gt;</span>MagazineNumberTwo.AddUFunction(this, TEXT(<span class="hljs-string">&quot;SubscriptMagazineTwo&quot;</span>));<br>    <span class="hljs-regexp">//Add-添加一个指向UObject类的函数的FDelegate进入多播代理，FDelegate是代理的内部类</span><br><span class="hljs-regexp">    DelegateTwo = AAnnouncer::FMagazineNumberTwo::FDelegate::CreateUObject(this, &amp;ASubscripterNumberOne::SubscriptMagazineTwo);</span><br><span class="hljs-regexp">    AAnnouncer::GetAnnouncerInstance()-&gt;MagazineNumberTwo.Add(DelegateTwo);</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">    //</span>AddLambda-添加一个Lambda表达式到多播代理<br>    AAnnouncer::GetAnnouncerInstance<span class="hljs-function"><span class="hljs-params">()</span>-&gt;</span>MagazineNumberTwo.AddLambda<span class="hljs-function"><span class="hljs-params">([](int ReleaseNumber)-&gt;<span class="hljs-literal">void</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            TArray&lt;FStringFormatArg&gt; Arguments;</span></span><br><span class="hljs-params"><span class="hljs-function">            Arguments.Add(FStringFormatArg((int32)ReleaseNumber));</span></span><br><span class="hljs-params"><span class="hljs-function">            Arguments.Add(FStringFormatArg((int32)ReleaseNumber));</span></span><br><span class="hljs-params"><span class="hljs-function">            FString PublicateContentOne = FString::Format(TEXT(<span class="hljs-string">&quot;发布者发布了&#123;0&#125;号杂志给订阅者2号，发布号:&#123;1&#125;,Lambda&quot;</span>), Arguments);</span></span><br><span class="hljs-params"><span class="hljs-function">            UE_LOG(LogTemp, <span class="hljs-built_in">Error</span>, TEXT(<span class="hljs-string">&quot;%s&quot;</span>), *PublicateContentOne);</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;)</span>;</span><br><span class="hljs-function">    //<span class="hljs-title">AddWeakLambda</span>-将<span class="hljs-title">Lambda</span>表达式与指定对象进行弱关联，再添加这个对象关联的<span class="hljs-title">Lambda</span>表达式到多播代理</span><br><span class="hljs-function">    <span class="hljs-title">AAnnouncer</span>::<span class="hljs-title">GetAnnouncerInstance</span><span class="hljs-params">()</span>-&gt;</span>MagazineNumberTwo.AddWeakLambda<span class="hljs-function"><span class="hljs-params">(this, [](int ReleaseNumber)-&gt;<span class="hljs-literal">void</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            TArray&lt;FStringFormatArg&gt; Arguments;</span></span><br><span class="hljs-params"><span class="hljs-function">            Arguments.Add(FStringFormatArg((int32)ReleaseNumber));</span></span><br><span class="hljs-params"><span class="hljs-function">            Arguments.Add(FStringFormatArg((int32)ReleaseNumber));</span></span><br><span class="hljs-params"><span class="hljs-function">            FString PublicateContentOne = FString::Format(TEXT(<span class="hljs-string">&quot;发布者发布了&#123;0&#125;号杂志给订阅者2号，发布号:&#123;1&#125;,WeakLambda&quot;</span>), Arguments);</span></span><br><span class="hljs-params"><span class="hljs-function">            UE_LOG(LogTemp, <span class="hljs-built_in">Error</span>, TEXT(<span class="hljs-string">&quot;%s&quot;</span>), *PublicateContentOne);</span></span><br><span class="hljs-params"><span class="hljs-function">           &#125;)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    //<span class="hljs-title">AddRaw</span>-添加指向的<span class="hljs-title">C</span>++类的函数的共享指针到多播代理</span><br><span class="hljs-function">    <span class="hljs-title">TSharedPtr</span>&lt;<span class="hljs-title">FSubscripterNumberThree</span>&gt; <span class="hljs-title">SubscripterNumberThree</span> = <span class="hljs-title">MakeShareable</span><span class="hljs-params">(<span class="hljs-keyword">new</span> FSubscripterNumberThree())</span>;</span><br><span class="hljs-function">    <span class="hljs-title">AAnnouncer</span>::<span class="hljs-title">GetAnnouncerInstance</span><span class="hljs-params">()</span>-&gt;</span>MagazineNumberTwo.AddRaw(SubscripterNumberThree.Get(), &amp;FSubscripterNumberThree::SubscriptMagazineTwo);<br>    <span class="hljs-regexp">//AddSP-添加指向的C++类的函数的共享引用到多播代理</span><br><span class="hljs-regexp">    TSharedRef&lt;FSubscripterNumberThree&gt; SubscripterNumberThree2 = MakeShareable(new FSubscripterNumberThree());</span><br><span class="hljs-regexp">    AAnnouncer::GetAnnouncerInstance()-&gt;MagazineNumberTwo.AddSP(SubscripterNumberThree2, &amp;FSubscripterNumberThree::SubscriptMagazineTwo);</span><br><span class="hljs-regexp">    //</span>AddThreadSafeSP-添加指向的C++类的函数的线程安全的共享引用到多播代理<br>    TSharedRef&lt;FSubscripterNumberThree,ESPMode::ThreadSafe&gt; SubscripterNumberThree3 = MakeShareable(<span class="hljs-keyword">new</span> FSubscripterNumberThree());<br>    AAnnouncer::GetAnnouncerInstance<span class="hljs-function"><span class="hljs-params">()</span>-&gt;</span>MagazineNumberTwo.AddThreadSafeSP(SubscripterNumberThree3, &amp;FSubscripterNumberThree::SubscriptMagazineTwo);<br><br>    <span class="hljs-regexp">//AddStatic-添加静态函数到多播代理，在类内外都可以使用，函数可以UFUNCTION函数也可以不是</span><br><span class="hljs-regexp">    AAnnouncer::GetAnnouncerInstance()-&gt;MagazineNumberTwo.AddStatic(ASubscripterNumberOne::SubscriptMagazineTwoStatic);</span><br><span class="hljs-regexp">    //</span>AddStatic-添加静态函数到多播代理，只能在类内使用，函数可以UFUNCTION函数也可以不是<br>    AAnnouncer::GetAnnouncerInstance<span class="hljs-function"><span class="hljs-params">()</span>-&gt;</span>MagazineNumberTwo.AddStatic(SubscriptMagazineTwoStatic);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>AddSP和AddThreadSafeSP有一个坑，就是像上面的代码一样在一个函数里面去创建一个共享引用，并往多播代理添加这个共享引用，到代理触发执行函数时，函数不会执行，可能时因为共享引用在函数栈退出时就已经置空了，所以才无法触发，这里还没看到共享引用，暂时先当一个坑。</p>
<h3 id="动态单播"><a href="#动态单播" class="headerlink" title="动态单播"></a>动态单播</h3><p>动态代理就没那么多花里胡哨了，动态单播只有一个BindUFunction函数来绑定UFUNCTION函数，即动态单播代理只能用于绑定UObject类的UFUNCTION函数。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">void ASubscripterNumberOne::<span class="hljs-built_in">BeginPlay</span>()<br>&#123;<br>	Super::<span class="hljs-built_in">BeginPlay</span>();<br>    AAnnouncer::<span class="hljs-built_in">GetAnnouncerInstance</span>()-&gt;MagazineNumberThree.<span class="hljs-built_in">BindUFunction</span>(this, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;SubscriptMagazineThree&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="动态多播"><a href="#动态多播" class="headerlink" title="动态多播"></a>动态多播</h3><p>动态多播也相当简洁，只有Add和AddUnique函数，只能用来添加FScriptDelegate指向的函数，而TScriptDelegate也只提供一个BindUFunction函数来绑定UObject类的UFUNCTION函数，所以动态多播只能添加UObject的UFUNCTION函数，其中AddUnique会对已添加到多播的委托做检查，如果该函数已经存在在多播中了，就不在添加重复的函数。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css">void ASubscripterNumberOne::<span class="hljs-built_in">BeginPlay</span>()<br>&#123;<br>	Super::<span class="hljs-built_in">BeginPlay</span>();<br>TScriptDelegate&lt;FWeakObjectPtr&gt; SubscriptMagazineFourDelegate;<br>    SubscriptMagazineFourDelegate<span class="hljs-selector-class">.BindUFunction</span>(this, <span class="hljs-selector-tag">TEXT</span>(&quot;SubscriptMagazineFour&quot;));<br>    AAnnouncer::<span class="hljs-built_in">GetAnnouncerInstance</span>()-&gt;MagazineNumberFour.<span class="hljs-built_in">Add</span>(SubscriptMagazineFourDelegate);<br>    <br>    AAnnouncer::<span class="hljs-built_in">GetAnnouncerInstance</span>()-&gt;MagazineNumberFour.<span class="hljs-built_in">AddUnique</span>(SubscriptMagazineFourDelegate);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>AddRaw和BindRaw使用于C++函数，如果在代理执行之前C++对象已经被销毁，则会导致内存操作违规引起的崩溃。</li>
<li>AddLambda和BindLamb如果Lambda表达式有捕获外部变量，且在代理执行之前外部变量已经被销毁，则会导致内存操作违规引起的崩溃。</li>
<li>AddWeakLambda&#x2F;BindWeakLambda、AddUObject&#x2F;BindUObject、AddUFunction&#x2F;BindUFunction、AddSP&#x2F;BindSP、AddThreadSafeSP&#x2F;BindThreadSafeSP，如果相关对象在代理执行之前被GC回收了，而在执行Execute函数时没有做有效性判断，则会导致内存操作违规引起的崩溃。建议在执行Execute函数之前使用IsBound做有效性判断或直接使用ExecuteIfBound函数。</li>
</ul>
<h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>在网上看别人的博客和官方的4.27的文档动态多播的绑定都是使用的AddDybamic和AddUniquueDynamic，而我自己在4.26中使用时并没有这两个函数，取而代之的是<code>__Internal_AddDynamic</code>和<code>__Internal_AddUniqueDymanic</code>，不知道是引擎代码已经改了，而官方文档没更新还是怎么着。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002137.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002137.png" alt="img"></a></p>
<p>在查询资料的过程还发现了一个宏<code>FUNC_DECLARE_DYNAMIC_MULTICAST_DELEGATE</code>，看起来像是一个委托，但是实在是查不到资料，只能有事件自己再去摸索了。</p>
<h2 id="4-代理的执行"><a href="#4-代理的执行" class="headerlink" title="4.代理的执行"></a>4.代理的执行</h2><h3 id="单播代理"><a href="#单播代理" class="headerlink" title="单播代理"></a>单播代理</h3><p>UE提供Execute函数和ExectueIfBound两个函数供单播代理触发执行函数，其中Execute支持有返回值函数和无返回值函数，但不会做执行函数所属对象的有效性检查，需要手动使用IsBound函数做有效性检查；而ExecuteIfBound只支持无返回值的函数，会在触发执行函数时自动检查执行函数所属对象的有效性，有效的才执行。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">MagazineNumberOne.Execute(<span class="hljs-number">1</span>)<span class="hljs-comment">; </span><br></code></pre></td></tr></table></figure>

<h3 id="多播代理"><a href="#多播代理" class="headerlink" title="多播代理"></a>多播代理</h3><p>多播代理只有一个Broadcast函数用于触发执行函数，且不会进行一执行函数所属对象的有效性检查，也需要使用IsBound函数手动进行检查。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">MagazineNumberTwo.Broadcast(<span class="hljs-number">2</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<h2 id="5-代理的解绑"><a href="#5-代理的解绑" class="headerlink" title="5.代理的解绑"></a>5.代理的解绑</h2><h3 id="单播代理-1"><a href="#单播代理-1" class="headerlink" title="单播代理"></a>单播代理</h3><p>单播代理在对象被析构时会自动调用UnBind函数进行解绑，或者重新绑定新的函数会自动解绑当前绑定函数，所以UE4.26可能就没有再暴露Unbind函数供外部调用了(看网上的<a target="_blank" rel="noopener" href="https://www.cnblogs.com/kekec/p/10678905.html">博客</a>是可以直接调用Unbind函数的，我在4.26中已经不能调用了，不知道作者用的是那个版本的引擎)。</p>
<p>不过对于动态单播还是可以使用Unbind和Clear函数来进行函数解绑。</p>
<h3 id="多播代理-1"><a href="#多播代理-1" class="headerlink" title="多播代理"></a>多播代理</h3><p>多播代理无论是静态多播还是动态多播均提供Clear、Remove和RemoveAll三个函数来做函数解绑，其中Clear是解绑多播中的所有函数；Remove则是解绑FDelegateHandle指定的函数，FDelegateHandle是代理绑定行数的返回值类型；RemoveAll是解绑指定对象的所有函数，不影响已经绑定的其他对象的函数。</p>
<h2 id="6-代理的创建"><a href="#6-代理的创建" class="headerlink" title="6.代理的创建"></a>6.代理的创建</h2><p>一个代理的使用流程就是声明代理、声明代理对象、代理对象绑定函数、执行代理、代理解绑。除此之外对于静态单播UE还提供CreateRaw、CreateLambda、CreateWeakLambda、CreateUObject、CreateUFunction、CreateSP、CreateThreadSafeSP等来直接创建一个已经已经绑定了对应函数的静态单播，虽然感觉也没什么用😂。</p>
<h2 id="7-事件"><a href="#7-事件" class="headerlink" title="7.事件"></a>7.事件</h2><p>UE的事件效果上几乎和C#的事件一模一样，理解C#的事件对UE的事件就是秒懂，来一张C#的事件说明：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002143.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002143.png" alt="img"></a></p>
<p>事件就是一个被再次封装的静态多播，声明上，关键字只是把DELEGATE关键字改为EVENT，参数则需要指定一个类名，以便UE在生成反射代码是保证这个事件只能在指定类的内部使用，如：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">DECLARE_EVENT_OneParam</span>(AAnnouncer，FMagazineEvent, int);<br></code></pre></td></tr></table></figure>

<p>事件的绑定、使用、解绑基本和静态多播一样，可以直接参考静态多播。</p>
<h2 id="8-预制代理"><a href="#8-预制代理" class="headerlink" title="8.预制代理"></a>8.预制代理</h2><p>UE预制了大量的代理给我使用，由于量实在是巨大，这里就只列出所在文件了，需要用的时候再直接进源码去看吧。</p>
<ul>
<li>系统与引擎下相关的预制代理：FCoreDelegates 、FCoreUObjectDelegates，同时UEngine中也几个相关代理；</li>
<li>编辑器相关预制代理：FEditorDelegates、FGameDelegates，同时UWorld中也有几个相关代理；</li>
<li>World相关预制代理：FWorldDelegates</li>
<li>引擎子系统相关预制代理：FNetDelegates，子系统的代理基本都分布在各个子系统的类中了；</li>
<li>GamePlay相关预制代理：FGameModeEvents及各个GamePlay的类中；</li>
</ul>
<p>网上有以为大佬<a target="_blank" rel="noopener" href="https://www.cnblogs.com/kekec/p/10678905.html">可可西</a>整理一篇挺全的博客。</p>
<h1 id="七、指针与引用"><a href="#七、指针与引用" class="headerlink" title="七、指针与引用"></a>七、指针与引用</h1><p>UE4的共享指针和C++的智能指针原理和作用基本一致，UE4的共享指针存在的主要目的就是作用于UE4的跨平台。</p>
<p>UE4共享指针的特性：</p>
<ul>
<li>防止内存溢出；</li>
<li>有线程安全机制；</li>
<li>可虚拟化任何对象；</li>
<li>负载大，内存占用为原生C++指针的两倍。</li>
</ul>
<p>UE4共享指针共有TSharedPtr、TSharedRef、TWeakPtr、TAutoPtr四种。</p>
<p>在UE中共享指针的作用主要是用来管理C++类对象，由于C++类不在UObject体系中，所以如果C++对象管理不善用于出现内存泄漏、野指针和程序崩溃等问题，共享指针就是为了解决这些问题而存在的。</p>
<p>除了共享指针外UE还提供了很多其他类型的引用。</p>
<h2 id="1-TSharedPtr"><a href="#1-TSharedPtr" class="headerlink" title="1.TSharedPtr"></a>1.TSharedPtr</h2><ul>
<li>TSharedPtr不能指向UObject类，因为UObject类有自己的一套垃圾回收机制，而TSharedPtr也有自己的一套垃圾回收机制，如果使用TSharedPtr指向一个UObject类，当UObject自己回收后，会出现指针不为空，但是对象却被销毁了，所以在指针销毁对象的时候就会出现销毁不存在对象，而导致引擎崩溃。</li>
</ul>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">TSharedPtr</span>&lt;<span class="hljs-type">FMyClass</span>&gt; emptyPtr;<span class="hljs-comment">//单独声明出来的共享指针为空指针</span><br></code></pre></td></tr></table></figure>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TSharedPtr&lt;FMyClass&gt; <span class="hljs-title">onePtr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> FMyClass())</span></span>;<br>TSharedPtr&lt;FMyClass&gt; twoPtr = <span class="hljs-built_in">MakeShareable</span>&lt;FMyClass&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">FMyClass</span>());<br><span class="hljs-comment">//TSharedPtr不支持直接赋值的初始化，如：</span><br><span class="hljs-comment">//TharedPtr&lt;MyClass&gt; onePtr;</span><br><span class="hljs-comment">//onePtr = new Class();</span><br><span class="hljs-comment">//这样的初始化是错误的</span><br></code></pre></td></tr></table></figure>

<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">TSahredPtr&lt;FMyClass&gt; twoPtr <span class="hljs-operator">=</span> onePtr<span class="hljs-comment">;//指针复制，引用计数器+1</span><br></code></pre></td></tr></table></figure>

<h3 id="查看一块内存的引用计数"><a href="#查看一块内存的引用计数" class="headerlink" title="查看一块内存的引用计数"></a>查看一块内存的引用计数</h3><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">TSharedPtr</span>&lt;<span class="hljs-variable">T</span>&gt;::<span class="hljs-function"><span class="hljs-title">GetSharedReferenceCount</span>()</span><br></code></pre></td></tr></table></figure>

<p> 一块内存只能被一个TSharedPtr指针初始化，如果一块内存被多个SharedPtr引用，UE4会在编译时直接崩溃，比如下面代码：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">UMyObject *obj <span class="hljs-operator">=</span> NewObject&lt;UMyObject&gt;()<span class="hljs-comment">;</span><br>TSharedPtr&lt;UMyObject&gt; onePtr(obj)<span class="hljs-comment">;</span><br>TSharedPtr&lt;UMyObject&gt; twoPtr(obj)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p> 如果想要多个TSharedPtr指针指向一块内存地址，则需要使用TSharedPtr复制。</p>
<h3 id="获取原始指针"><a href="#获取原始指针" class="headerlink" title="获取原始指针"></a>获取原始指针</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">TSharedPtr&lt;FMyClass&gt; twoPtr<span class="hljs-comment">;</span><br><span class="hljs-attribute">twoPtr</span> <span class="hljs-operator">=</span> MakeShareable&lt;FMyClass&gt;(new FMyClass())<span class="hljs-comment">;</span><br>twoPtr.Get()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<h2 id="2-TSharedRef"><a href="#2-TSharedRef" class="headerlink" title="2.TSharedRef"></a>2.TSharedRef</h2><p>TSharedRef又称共享引用，相对于共享指针，共享引用由于不能为空，也无法置空，所以使用上比共享指针更安全，和引用一样，共享引用的初始化不能和声明分开，即声明的时候就必须做初始化了，共享引用的初始化可以使用MakeShareable函数或使用共享指针转换。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">TSharedRef&lt;FMyClass&gt; oneRef <span class="hljs-operator">=</span> MakeShareable&lt;FMyClass&gt;(new FClass())<span class="hljs-comment">;</span><br>TSharedPtr&lt;FMyClass&gt; Ptr <span class="hljs-operator">=</span> MakeShareable&lt;FMyClass&gt;(new FClass())<span class="hljs-comment">;</span><br>TSharedRef&lt;FMyClass&gt; twoRef <span class="hljs-operator">=</span> Ptr.toSharedRef()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<h3 id="TSharedPtr和TSharedRef的互相转换"><a href="#TSharedPtr和TSharedRef的互相转换" class="headerlink" title="TSharedPtr和TSharedRef的互相转换"></a>TSharedPtr和TSharedRef的互相转换</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">TSharedRef</span>&lt;<span class="hljs-type">FMyClass</span>&gt; oneRef <span class="hljs-operator">=</span> <span class="hljs-type">MakeShareable</span>&lt;<span class="hljs-type">FMyClass</span>&gt;(new <span class="hljs-type">FClass</span>());<br><span class="hljs-type">TSharedPtr</span>&lt;<span class="hljs-type">FMyClass</span>&gt; onePtr <span class="hljs-operator">=</span> <span class="hljs-type">MakeShareable</span>&lt;<span class="hljs-type">FMyClass</span>&gt;(new <span class="hljs-type">FClass</span>());<br><span class="hljs-comment">//共享指针转共享引用</span><br><span class="hljs-type">TSharedRef</span>&lt;<span class="hljs-type">FMyClass</span>&gt; twoRef <span class="hljs-operator">=</span> onePtr.toSharedRef();<br><span class="hljs-comment">//共享引用转共享指针</span><br><span class="hljs-type">TSharedPtr</span>&lt;<span class="hljs-type">FMyClass</span>&gt; twoPtr <span class="hljs-operator">=</span> oneRef<br></code></pre></td></tr></table></figure>

<h2 id="3-TWeakPtr"><a href="#3-TWeakPtr" class="headerlink" title="3.TWeakPtr"></a>3.TWeakPtr</h2><p>TWeakPtr是对标的STL的weak_ptr的，TweakPtr不对增加对象的引用计数，所以不会影响对象的释放，也就避免了互相引用的死锁而导致的内存溢出，但这也导致了TWeakPtr随时可能被置空的问题，所在使用都需要做有效性判断。</p>
<p>TWeakPtr只能通过TSharedPtr或TSharedRef来初始化。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">TSharedRef&lt;FCpp&gt; SharedRef <span class="hljs-operator">=</span> MakeShareable&lt;FCpp&gt;(new FCpp())<span class="hljs-comment">;</span><br>TSharedPtr&lt;FCpp&gt; SharedPtr <span class="hljs-operator">=</span> MakeShareable&lt;FCpp&gt;(new FCpp())<span class="hljs-comment">;</span><br><span class="hljs-attribute">WeakPtr</span> <span class="hljs-operator">=</span> SharedPtr<span class="hljs-comment">;</span><br><span class="hljs-attribute">WeakPtr</span> <span class="hljs-operator">=</span> SharedRef<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>需要注意的是，TWeakPtr并没有重写-&gt;，所以TWeakPtr不能直接使用指向对象的成员，要想要使用指向对象的成员，则需要先通过Pin()函数将TWeakPtr转换成TSharedPtr再使用。</p>
<h2 id="4-TUniquePtr"><a href="#4-TUniquePtr" class="headerlink" title="4.TUniquePtr"></a>4.TUniquePtr</h2><p>TUniquePtr可以保证指向一个对象只能被一个唯一的TUniquePtr指针指向，TUniquePtr不能赋值给其他的指针。</p>
<h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">TUniquePtr&lt;FCpp&gt; UniquePtr <span class="hljs-operator">=</span> MakeUnique&lt;FCpp&gt;(new FCpp())<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>TUniquePtr使用专门的MakeUnique函数进行初始化。</p>
<p>在使用的过程想到一个疑问，如果使用TUniquePtr指针指向一个对象，然后用另一个TSharedPtr也指向这个对象，直接绕开TUniquePtr而不是使用TUniquePtr赋值TSharedPtr，这样指向这个对象的指针就不止一个了。</p>
<p>事实证明这样子是行不通的，因为共享指针不能直接使用C++指针初始化，也不能指向C++指针。</p>
<h2 id="5-TAutoPtr-TScopedPointer"><a href="#5-TAutoPtr-TScopedPointer" class="headerlink" title="5.TAutoPtr,TScopedPointer"></a>5.TAutoPtr,TScopedPointer</h2><p>这两个指针在网上的很多文章里都有出现，然后我自己使用的时候发现根本没有这两个指针，然后查阅官方文档才发向这两个指针在4.15就已经废弃了删掉了。</p>
<h2 id="6-TWeakObjectPtr"><a href="#6-TWeakObjectPtr" class="headerlink" title="6.TWeakObjectPtr"></a>6.TWeakObjectPtr</h2><p>TWeakObjectPtr是UE专门用来指向UObject的指针，由于UObject的GC与共享指针的GC是两套系统，我们使用TSharedPtr来指向一个UObject可能会导致一个UObject已经被系统GC了，而TSharedPtr依旧是有效的，所指向的内容却已经没了，而引起的系统崩溃。但有的时候又有需要使用一个指针来引用UObject而又要不影响UObject的正常GC，于是TWeakObjectPtr就运行而生了，当UObject被GC后TWeakObjectPtr也会被自动置为nullptr。</p>
<p>TWeakObjectPtr可以直接指向一个UObject对象，也可以指向一个UObject指针。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">TWeakObjectPtr&lt;AAnnouncer&gt; WeakObjectPtr <span class="hljs-operator">=</span> GWorld-&gt;SpawnActor&lt;AAnnouncer&gt;()<span class="hljs-comment">;</span><br>AAnnouncer* Announcer <span class="hljs-operator">=</span> GWorld-&gt;SpawnActor&lt;AAnnouncer&gt;()<span class="hljs-comment">;</span><br>TWeakObjectPtr&lt;AAnnouncer&gt; WeakObjectPtr <span class="hljs-operator">=</span> Announcer<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<h2 id="7-TAutoWeakObjectPtr"><a href="#7-TAutoWeakObjectPtr" class="headerlink" title="7.TAutoWeakObjectPtr"></a>7.TAutoWeakObjectPtr</h2><p>TAutoWeakObjectPtr是TWeakObjectPtr的TAutoPtr版本，在对象声明周期结束后，指针会自动释放其引用对象。使用方式和TWeakObjectPtr一致。</p>
<h2 id="8-TSharedFromThis"><a href="#8-TSharedFromThis" class="headerlink" title="8.TSharedFromThis"></a>8.TSharedFromThis</h2><p>TSharedFromThis不是一个指针而是一个模板类，可供我们使用C++类去继承来创建一个自定义的共享指针。</p>
<p>TSharedFromThis类提供Get方法将共享指针转换成普通指针，提供AsShred方法将普通指针转成共享指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Templates/SharedPointer.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MYPROJECT_API</span> FCppPtr : <span class="hljs-keyword">public</span> TSharedFromThis&lt;FCppPtr&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">FCppPtr</span>();<br>	~<span class="hljs-built_in">FCppPtr</span>();<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="9-FSoftObjectPath"><a href="#9-FSoftObjectPath" class="headerlink" title="9.FSoftObjectPath"></a>9.FSoftObjectPath</h2><p>FSoftObjectPath是一个记录资源路径的结构体，用于C++暴露给编辑器，然后可以在编辑器中方便快捷的设置C++类需要使用的资源，C++加载蓝图资源需要使用UE给定的路径格式，FSoftObjectPath就可以通过直接选择的方式来提供C++所需要的资源路径。</p>
<p>这里直接使用一个例子来说明可能会更具象点。</p>
<p>创建一个C++类的Actor</p>
<p>.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;GameFramework/Actor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;OpreateActor.generated.h&quot;</span></span><br><br><span class="hljs-built_in">UCLASS</span>()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MYPROJECT_API</span> AOpreateActor : <span class="hljs-keyword">public</span> AActor<br>&#123;<br>	<span class="hljs-built_in">GENERATED_BODY</span>()	<br><span class="hljs-keyword">public</span>:	<br>	<span class="hljs-built_in">AOpreateActor</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Do</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">public</span>:<br>    UStaticMeshComponent* StaticMeshComponent;<br>    <span class="hljs-built_in">UPROPERTY</span>(EditAnywhere,meta=(AllowedClasses=<span class="hljs-string">&quot;Material&quot;</span>))<br>    TArray&lt;FSoftObjectPath&gt; MatArr;<br><span class="hljs-keyword">protected</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-keyword">public</span>:	<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Tick</span><span class="hljs-params">(<span class="hljs-type">float</span> DeltaTime)</span> <span class="hljs-keyword">override</span></span>;<br><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;TSharedPtr/OpreateActor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Runtime/Engine/Classes/Kismet/GameplayStatics.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Delegate/Announcer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Templates/SharedPointerInternals.h&quot;</span></span><br>AOpreateActor::<span class="hljs-built_in">AOpreateActor</span>()<br>&#123;<br>	PrimaryActorTick.bCanEverTick = <span class="hljs-literal">true</span>;<br>    <span class="hljs-function">ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt; <span class="hljs-title">StaticMesh</span><span class="hljs-params">(TEXT(<span class="hljs-string">&quot;StaticMesh&#x27;/Game/StarterContent/Shapes/Shape_Sphere.Shape_Sphere&#x27;&quot;</span>))</span></span>;<br>    StaticMeshComponent = <span class="hljs-built_in">CreateDefaultSubobject</span>&lt;UStaticMeshComponent&gt;(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;MeshComponent&quot;</span>));<br>    StaticMeshComponent-&gt;<span class="hljs-built_in">SetupAttachment</span>(<span class="hljs-built_in">GetRootComponent</span>());<br>    StaticMeshComponent-&gt;<span class="hljs-built_in">SetStaticMesh</span>(StaticMesh.Object);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AOpreateActor::Do</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> index = FMath::<span class="hljs-built_in">RandHelper</span>(MatArr.<span class="hljs-built_in">Num</span>());<br>    FString MatPath = <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Material&#x27;&quot;</span>) + MatArr[index].<span class="hljs-built_in">GetAssetPathString</span>() + <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;&#x27;&quot;</span>);<br>    UMaterial* Mat = <span class="hljs-built_in">LoadObject</span>&lt;UMaterial&gt;(<span class="hljs-literal">nullptr</span>, *MatPath);<br>    UMaterialInstanceDynamic* MatIns = UMaterialInstanceDynamic::<span class="hljs-built_in">Create</span>(Mat, StaticMeshComponent);<br>    StaticMeshComponent-&gt;<span class="hljs-built_in">SetMaterial</span>(<span class="hljs-number">0</span>,MatIns);  <br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AOpreateActor::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Super::<span class="hljs-built_in">BeginPlay</span>();<br>    <span class="hljs-built_in">EnableInput</span>(UGameplayStatics::<span class="hljs-built_in">GetPlayerController</span>(GWorld, <span class="hljs-number">0</span>));<br>    InputComponent-&gt;<span class="hljs-built_in">BindAction</span>(<span class="hljs-string">&quot;ActorInputP&quot;</span>, EInputEvent::IE_Pressed, <span class="hljs-keyword">this</span>, &amp;AOpreateActor::Do);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AOpreateActor::Tick</span><span class="hljs-params">(<span class="hljs-type">float</span> DeltaTime)</span></span><br><span class="hljs-function"></span>&#123;<br>	Super::<span class="hljs-built_in">Tick</span>(DeltaTime);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>创建一个FSoftObjectPath数组用于存储设置的材质路径，使用meta限定选择时只显示材质对象；</li>
<li>在构造对象时为这个Actor附加一个SceneComponent和StaticMeshComponent，材质需要附着在mesh组件上；</li>
<li>在BeginPlay函数中启动Actor接收输入，并为输入按键绑定执行函数Do()；</li>
<li>在Do函数中为Actor设置随机Material。</li>
<li>然后把Actor放入场景。</li>
</ul>
<p>来看一下效果：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002159.gif"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002159.gif" alt="img"></a></p>
<h2 id="10-TSoftObjectPtr"><a href="#10-TSoftObjectPtr" class="headerlink" title="10.TSoftObjectPtr"></a>10.TSoftObjectPtr</h2><p>TSoftObjectPtr是FSoftObjectPath和TWeakObjectPtr的模板类封装，非模板的封装则是FSoftObjectPtr，这两个指针功能上基本一致。按照<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/5.0/zh-CN/asynchronous-asset-loading/">官方文档</a>的描述，TSoftObjectPtr可以在其保存的弱引用指向的对象不存在时快速的通过FSoftObjectPath保存的路径加载对象到内存中，效果上和tSoftObjectPath差不多，只是省去了我们手动加载资源的步骤。</p>
<p>这里写个例子：</p>
<p>这里通过TSoftObjectPtr来加载两个内存中不存在Actor蓝图类对象Truck和Motorcycle，他们分别继承自C++Actor类ACar，ACar继承自接口IBPInterface，IBPInterface提供一个由蓝图实现的函数接口Log，然后在AOpreateActor的Do函数中来进行这些操作。</p>
<p>关于C++通过接口调用蓝图函数，请移步置<a target="_blank" rel="noopener" href="https://goulandis.github.io/2022/10/16/%E3%80%90UE4%E3%80%91C++%E7%BC%96%E7%A8%8B/#7.%E6%8E%A5%E5%8F%A3">接口</a>。</p>
<p>使用C++加载蓝图类并调用蓝图类中函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;GameFramework/Actor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;OpreateActor.generated.h&quot;</span></span><br><br><span class="hljs-built_in">UCLASS</span>()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MYPROJECT_API</span> AOpreateActor : <span class="hljs-keyword">public</span> AActor<br>&#123;<br>	<span class="hljs-built_in">GENERATED_BODY</span>()<br><span class="hljs-keyword">public</span>:	<br>	<span class="hljs-built_in">AOpreateActor</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Do</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UPROPERTY</span>(EditAnywhere)<br>    TArray&lt;TSoftObjectPtr&lt;UObject&gt;&gt; SoftObjectPtrArr;<br><span class="hljs-keyword">protected</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-keyword">public</span>:	<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Tick</span><span class="hljs-params">(<span class="hljs-type">float</span> DeltaTime)</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AOpreateActor::Do</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (TSoftObjectPtr&lt;UObject&gt; ObjPtr : SoftObjectPtrArr)<br>    &#123;<br>        FString ActorPath = <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Blueprint&#x27;&quot;</span>) + ObjPtr.<span class="hljs-built_in">ToSoftObjectPath</span>().<span class="hljs-built_in">GetAssetPathString</span>() + <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;&#x27;&quot;</span>);<br>        UObject* LoadObj = <span class="hljs-built_in">StaticLoadObject</span>(UBlueprint::<span class="hljs-built_in">StaticClass</span>(), <span class="hljs-literal">NULL</span>, *ActorPath);<br>        <span class="hljs-keyword">if</span> (LoadObj)<br>        &#123;<br>            UBlueprint* Blueprint = <span class="hljs-built_in">CastChecked</span>&lt;UBlueprint&gt;(LoadObj);<br>            FActorSpawnParameters SpawnParams;<br>            ACar* ActorBase = GWorld-&gt;<span class="hljs-built_in">SpawnActor</span>&lt;ACar&gt;(Blueprint-&gt;GeneratedClass, <span class="hljs-built_in">FVector</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-built_in">FRotator</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), SpawnParams);<br>            UClass* ActorClass = ActorBase-&gt;<span class="hljs-built_in">GetClass</span>();<br>            <span class="hljs-keyword">if</span> (ActorClass-&gt;<span class="hljs-built_in">ImplementsInterface</span>(UBPInterface::<span class="hljs-built_in">StaticClass</span>()))<br>            &#123;<br>                IBPInterface* BPInterface = <span class="hljs-built_in">CastChecked</span>&lt;IBPInterface&gt;(ActorBase);<br>                IBPInterface::<span class="hljs-built_in">Execute_Log</span>(ActorBase);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Truck的Log接口实现：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002212.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002212.png" alt="img"></a></p>
<p>Motorcycle的Log接口实现：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002223.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002223.png" alt="img"></a></p>
<p>将AOpreateActor放入Level并配置TSoftObjectPtr数组</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002229.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002229.png" alt="img"></a></p>
<p>运行效果：</p>
<p>开始时Level中没有Truck和Motorcycle；</p>
<p>运行后：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002233.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002233.png" alt="img"></a></p>
<h2 id="11-FSoftClassPath"><a href="#11-FSoftClassPath" class="headerlink" title="11.FSoftClassPath"></a>11.FSoftClassPath</h2><p>FSoftClassPath是FSoftObjectPath的子类，使用方式于效果和FSoftObjectPath一模一样，FSoftClassPath解决的是FSoftObjectPath只能引用资产而不能引用蓝图类的问题。FSoftObjectPath如果引用蓝图类会导致编辑器发生中断，而FSoftClassPath引用资产也会造成编辑器中断，并且二者对类型的筛选也是不一样的，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;GameFramework/Actor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;OpreateActor.generated.h&quot;</span></span><br><span class="hljs-built_in">UCLASS</span>()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MYPROJECT_API</span> AOpreateActor : <span class="hljs-keyword">public</span> AActor<br>&#123;<br>	<span class="hljs-built_in">GENERATED_BODY</span>()<br><span class="hljs-keyword">public</span>:	<br>	<span class="hljs-built_in">AOpreateActor</span>();<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UPROPERTY</span>(EditAnywhere,meta=(AllowedClasses=<span class="hljs-string">&quot;Material&quot;</span>))<br>    FSoftObjectPath SoftObjectPath;<br>    <span class="hljs-built_in">UPROPERTY</span>(EditAnywhere,meta=(MetaClass = <span class="hljs-string">&quot;Car&quot;</span>))<br>    FSoftClassPath SoftClassPath;<br><span class="hljs-keyword">protected</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-keyword">public</span>:	<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Tick</span><span class="hljs-params">(<span class="hljs-type">float</span> DeltaTime)</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>SoftClassPath就可以引用所有继承自ACar的蓝图类了。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002241.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002241.png" alt="img"></a></p>
<h2 id="12-TSoftClassPtr"><a href="#12-TSoftClassPtr" class="headerlink" title="12.TSoftClassPtr"></a>12.TSoftClassPtr</h2><p>TSoftClassPtr就是TSoftObjectPtr的减配版，只能提供FSoftObjectPath不能提供TWeakObjectPtr，除此之外使用和功能都和TSoftObjectPtr一样。</p>
<h2 id="13-TSubclassOf"><a href="#13-TSubclassOf" class="headerlink" title="13.TSubclassOf"></a>13.TSubclassOf</h2><p>TSubClassOf基本等于UClass，只是增加了类型安全和类型筛选。</p>
<h2 id="14-TAssestPtr"><a href="#14-TAssestPtr" class="headerlink" title="14.TAssestPtr"></a>14.TAssestPtr</h2><p>TAssestPtr是一个配合FStreamableManager进行资产异步加载使用的指向资产的指针，是一个弱指针，指向的资产可以已经被加载了也可以还未被加载。</p>
<h1 id="八、容器"><a href="#八、容器" class="headerlink" title="八、容器"></a>八、容器</h1><p>UE的容器主要有TArray，TMap，TSet，TQueue基本上和其他语言里的Array，Map，Set，Queue都没多大区别。</p>
<h2 id="1-TArray"><a href="#1-TArray" class="headerlink" title="1.TArray"></a>1.TArray</h2><p>TArray是UE中使用最广泛的容器，一个可扩容动态数组，TArray的定义在<code>Engine\Source\Runtime\Core\Public\Containers\Array.h</code>，是一个模板类，纵观TArray类的代码近3000行，但是变量却只有3个；</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002249.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002249.png" alt="img"></a></p>
<ul>
<li>AllocatorInstance是数组的内存分配器；</li>
<li>ArrayNum是数组元素的实际个数；</li>
<li>ArrayMax是数组最大可容纳的元素数量；</li>
</ul>
<p>所以一个空数组的大小就是这三个成员变量的大小，由于分配器也是一个模板类，所以根据分配器的类型不同，空数组的大小也会有所变化，最小是一个指针加两个整型，即16字节。</p>
<p>而一个数组的内存大小就是ArrayMax*sizeof(ElementType)+AllocatorInstance所占用的大小。</p>
<h3 id="TArray的扩容原理"><a href="#TArray的扩容原理" class="headerlink" title="TArray的扩容原理"></a>TArray的扩容原理</h3><p>TArray的扩容原理和C++ STL的vector差不多，当数组容量满了之后就会再分配一个更大的内存空间，和vector一样TArray也是分配的一个连续的内存空间，所以在重新分配了内存之后TArray会把旧地址上的内容拷贝到新的内存地址中并释放掉旧内存；在网上没有查到TArray的扩容机制，既然TArray在原理和vctor差不多，那么我想TArray的扩容机制应该也是两倍扩容。</p>
<h3 id="TArray的移动构造函数"><a href="#TArray的移动构造函数" class="headerlink" title="TArray的移动构造函数"></a>TArray的移动构造函数</h3><p>与vector不同的是TArray使用了C++11提供的新特性—移动构造函数，我们知道在使用一个数组来初始化另一个数组时会执行TArray的拷贝构造函数，如果数组元素中存在指针引用，那么此时的执行的拷贝构造函数就是深拷贝，即不仅要拷贝指针还要把指针指向的内容也一并拷贝一份，TArray在提供了普通的拷贝构造函数的同时还提供给了移动构造函数，在使用一个数组初始化另一个数组时，移动构造函数只会拷贝旧数组的分配器和数组容量，数组的内容则是直接从旧数组移交给新数组，然后把旧数组恢复到无份配的初始状态，这样旧数组就成了一个空数组。</p>
<p>我们写一段代码来测试一下：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl">TArray&lt;<span class="hljs-keyword">int</span>&gt; arr1 = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span> &#125;;<br>TArray&lt;<span class="hljs-keyword">int</span>&gt; arr2;<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Arr1:<span class="hljs-variable">%d</span>,Arr2:<span class="hljs-variable">%d</span>&quot;</span>), arr1.Num(), arr2.Num());<br>arr2 = MoveTemp(arr1);<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Arr1:<span class="hljs-variable">%d</span>,Arr2:<span class="hljs-variable">%d</span>&quot;</span>), arr1.Num(), arr2.Num());<br>TArray&lt;<span class="hljs-keyword">int</span>&gt; arr3(arr2);<br>UE_LOG(LogTemp, Warning, TEXT(<span class="hljs-string">&quot;Arr2:<span class="hljs-variable">%d</span>,Arr3:<span class="hljs-variable">%d</span>&quot;</span>), arr2.Num(), arr3.Num());<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002254.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002254.png" alt="img"></a></p>
<p>这里有一个一点是需要注意的，就是使用移动构造的时候必须使用MoveTemp显示调用，否则调用不成功，反而去执行了拷贝构造函数，用例对比就是arr1初始化arr2和arr2初始化arr3。</p>
<h2 id="2-TMap"><a href="#2-TMap" class="headerlink" title="2.TMap"></a>2.TMap</h2><p>TMap也是一个经常使用的UE4容器，和TArray不同的是TMap是一个散列结构，TMap的存储空间可能不是一个连续的内存片段，而是通过hash映射来存储的，所以相对于TArray来说TMap的元素查找非常快速。</p>
<p>TMap是通过TSet来实现的，TMap的底层实现原理就是HashTable–哈希表，这与C++STL的Map不一样，STL的Map底层实现原理选择的是Red-Black Tree–红黑树，哈希表于红黑树在数据结构上又有区别，哈希表是基于数组的数据结构，而红黑树则是基于链表的数据结构，这是由TMap在UE4中主要面向的是渲染系统决定的，在渲染系统中高平率的数据操作是查找，在这方面数组相较于链表是有优势的。</p>
<p>TMap的元素都是以<code>TPair&lt;KeyType,ValueType&gt;</code>的形式存储，其中KeyType和ValueType是任意TMap可支持的类型，之所以说是可支持的，是因为不是所有的类型都是可以作为TMap的键的，按照<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.26/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/TMap/">官方文档</a>的说法，只有支持GetTypeHash函数并提供<code>==</code>运算符重载来比较键值是否相等的类型才能作为TMap的键类型，而值就可以是任意类型了。</p>
<h3 id="TMap的内存分配原理"><a href="#TMap的内存分配原理" class="headerlink" title="TMap的内存分配原理"></a>TMap的内存分配原理</h3><p>TMap是支持自选内存分配器来控制内存分配行为的，当然一般情况下我们都是使用默认的内存分配器—FDefaultSetAllocator ，这里TMap和TSet是一致的，顺带一提，TArray使用默认内存分配器是FDefaultAllocator ，UE4的内存分配器的篇幅也挺长的，详情可查看：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/kekec/p/12012537.html%E3%80%82">https://www.cnblogs.com/kekec/p/12012537.html。</a></p>
<p>当我们创建一个TMap时：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">TMap&lt;<span class="hljs-built_in">int</span> FString&gt; StrMap<br></code></pre></td></tr></table></figure>

<p>此时StrMap是一个空Map，没有被分别任何内存。</p>
<p>和TArray一样，当我们往TMap中添加第一个元素时，TMap会使用配置的内存分配来申请一块内存空间，当这块内存空间被使用完之后，也会根据内存分配器的算法来进行扩容。</p>
<h3 id="自定义TMap键值"><a href="#自定义TMap键值" class="headerlink" title="自定义TMap键值"></a>自定义TMap键值</h3><p>前面有提到过，一个类型无论是结构体或是自定义类，只要满足重载<code>==</code>的自身类型比较和提供Hash值的GetTypeHash函数，则这个类型就可以作为TMap的键，所以自定键值的方式就很明确了。</p>
<p><strong>结构体</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">USTRUCT</span>()<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FCusKey</span><br>&#123;<br>	<span class="hljs-built_in">GENERATED_BODY</span>()<br>	UObject* Obj;<br>	<span class="hljs-keyword">friend</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> FCusKey&amp; A, <span class="hljs-type">const</span> FCusKey&amp; B)<br>	&#123;<br>		<span class="hljs-keyword">return</span> A.Obj == B.Obj;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">inline</span> uint32 <span class="hljs-title">GetTypeHash</span><span class="hljs-params">(<span class="hljs-type">const</span> FCusKey&amp; Key)</span></span><br><span class="hljs-function">	</span>&#123;<br>		uint32 Hash = <span class="hljs-number">0</span>;<br>		Hash = <span class="hljs-built_in">HashCombine</span>(Hash, <span class="hljs-built_in">GetTypeHash</span>(Key.Obj));<br>		<span class="hljs-keyword">return</span> Hash;<br>	&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>应用：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">void</span> AContainerctor::CusTMapFun()<br>&#123;<br>	TMap&lt;FCusKey, FString&gt; CusMap;<br>	FCusKey CusKey;<br>	CusKey.Obj = NewObject&lt;UObject&gt;();<br>	CusMap.<span class="hljs-keyword">Add</span>(CusKey, TEXT(&quot;FirstObj&quot;));<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>自定义类</strong></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">UE4CPP_API</span> <span class="hljs-type">FCusClassKey</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-class">public:</span><br><span class="hljs-class">	<span class="hljs-type">FCusClassKey</span>();</span><br><span class="hljs-class">	~<span class="hljs-type">FCusClassKey</span>();</span><br><span class="hljs-class"></span><br><span class="hljs-class">	friend bool operator==(<span class="hljs-type">FCusClassKey</span>&amp; <span class="hljs-type">A</span>,<span class="hljs-type">FCusClassKey</span>&amp; <span class="hljs-type">B</span>)</span><br><span class="hljs-class">	&#123;</span><br><span class="hljs-class">		return <span class="hljs-type">A</span> == <span class="hljs-type">B</span>;</span><br><span class="hljs-class">	&#125;</span><br><span class="hljs-class"></span><br><span class="hljs-class">	friend int <span class="hljs-type">GetTypeHash</span>(<span class="hljs-type">FCusClassKey</span>&amp; <span class="hljs-type">Key</span>)</span><br><span class="hljs-class">	&#123;</span><br><span class="hljs-class">		int <span class="hljs-type">Hash</span> = 0;</span><br><span class="hljs-class">		<span class="hljs-type">Hash</span> = <span class="hljs-type">HashCombine</span>(<span class="hljs-type">Hash</span>, <span class="hljs-type">GetTypeHash(Key)</span>);</span><br><span class="hljs-class">		return <span class="hljs-type">Hash</span>;</span><br><span class="hljs-class">	&#125;</span><br><span class="hljs-class">&#125;;</span><br></code></pre></td></tr></table></figure>

<p>应用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AContainerctor::CusTMapFun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	TMap&lt;FCusClassKey*, <span class="hljs-type">int</span>&gt; CusClassMap;<br>	CusClassMap.<span class="hljs-built_in">Add</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">FCusClassKey</span>(), <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>需要一提的是，两个函数中<code>friend</code>关键字是必须的否则编译就会报错，而<code>inline</code>和<code>const</code>都不是必须的，甚至GetTypeHash的返回值也不一定必须是uint32。</p>
<h2 id="3-TSet"><a href="#3-TSet" class="headerlink" title="3.TSet"></a>3.TSet</h2><p>UE4的TSet是通过TSparseArray实现的，本质上是一个特殊的数组，特殊之处在于TSet虽然是一个数组，但是TSet是散列的，内部存储元素不是连续的，并且TSet使用Hash值来映射index。</p>
<p>TSet和TMap极其相似，毕竟TMap就是使用TSet实现的，TSet也通过键值来操作元素，只不过TSet的键值和元素是同一个，同时TSet也能像TMap一样通过配置内存分配器来控制内存分配行为，也可以通过实现 重载<code>==</code>和GetTypeHash函数来自定义键值。</p>
<p>TSet与其他容器不同的是，TSet是一个自排序容器，添加进入TSet的元素，会按照TSet的默认排序规则自动排序，因为这个特性是的TSet对于元素的查找，删除，添加等操作都极为迅速，时间复杂度都是常数级的。</p>
<h2 id="4-TTuple"><a href="#4-TTuple" class="headerlink" title="4.TTuple"></a>4.TTuple</h2><p>看到TTuple时我是吃惊的，因为我一直以为元组是脚本类语言特有的容器，没想到UE4也实现了，更深入了解后才发现，原来C++中也有实现std::tuple。</p>
<p>不过UE4中元组的创建就不像脚本语言那样可以直接使用<code>[]</code>来得方便了，而是使用了专门的创建函数MakeTuple，这一点和智能指针有点类似。</p>
<p>另外UE4元组的元素数量和类型在声明元组时就已经确定了，不可以在运行时额外添加，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TTuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">bool</span>, <span class="hljs-type">float</span>, FString&gt; <span class="hljs-title">tuple1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">1.0f</span>, TEXT(<span class="hljs-string">&quot;aaa&quot;</span>))</span></span>;<br></code></pre></td></tr></table></figure>

<p>即使我们使用auto类型，也必须配合static使用，而静态类型又要求设置初始值，所以实际上，元组的类型依然是在声明时就定死的，无法在运行时添加声明以外的元素类型和数量。</p>
<p>另外UE4的代理就是使用元组来实现的。</p>
<h2 id="5-UE4容器的注意事项"><a href="#5-UE4容器的注意事项" class="headerlink" title="5.UE4容器的注意事项"></a>5.UE4容器的注意事项</h2><p>理论上说，由于TArray的扩容机制，在数组存储空间用完时UE4会重新分配一个更大的存储空间并把数组迁移到新的空间去，这就会导致在扩容前保存的数组元素的引用出现引用失效的可能，而TSet，TMap的底层都是TArray所以都会有这样的问题。但是在我的实际测试中，把我笔记本16G内存榨干了似乎也没有出现引用失效的情况。</p>
<h1 id="九、宏"><a href="#九、宏" class="headerlink" title="九、宏"></a>九、宏</h1><p>UE4中提供大量的宏于开发者使用，这些宏的作用就类似库函数一般。只是需要注意的是，有的宏末尾没有“；”而有的宏末尾需要加“；”，在下面的书写中需要“；”的宏我就直接在末尾加“；”，不需要的则不加。UE4不人性化的一点是很多宏里面的参数在VS中没有提示，也没有颜色变化，更不会提示错误，所以在给宏添加参数时尤其要注意书写正确。</p>
<h2 id="1-UE-LOG-；"><a href="#1-UE-LOG-；" class="headerlink" title="1.UE_LOG()；"></a>1.UE_LOG()；</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h3><p>UE_LOG();宏用于向UE4控制台输出内容。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h3><p>UE4提供三个级别的UE_LOG;宏，</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lisp">UE_LOG(<span class="hljs-name">LogTemp</span>, Log, TEXT(<span class="hljs-string">&quot;Hello World!&quot;</span>))<span class="hljs-comment">;</span><br>UE_LOG(<span class="hljs-name">LogTemp</span>, Warning, TEXT(<span class="hljs-string">&quot;Hello World!&quot;</span>))<span class="hljs-comment">;</span><br>UE_LOG(<span class="hljs-name">LogTemp</span>, Error, TEXT(<span class="hljs-string">&quot;Hello World!&quot;</span>))<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>LogTemp</strong>：是UE4提供给我们的一个临时UE_LOG();宏标签，这个标签是可以自定义的，如此我们便可以在不同的模块中使用不同标签的UE_LOG();宏，极大的便利了调试，这也是UE_LOG();宏的强大之处。</li>
<li><strong>Log&#x2F;Warning&#x2F;Error</strong>：这是UE_LOG();宏的三个级别，分别是日志级别–在控制台中输出白色字体；警告级别–在控制台中输出黄色字体，并有Warning提示；错误级别–在控制台中输出红色字体，并有Error提示。</li>
<li><strong>TEXT()</strong>：TEXT()也是一个宏用于将我们自定义的额字符串输出到控制台。</li>
</ul>
<p><strong>输出变量</strong></p>
<p>UE_LOG()宏可以输出FString字符串，且字符串类型中只能输出FString。</p>
<figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">UE_<span class="hljs-meta">LOG</span>(LogTemp, <span class="hljs-keyword">Error</span>, TEXT(<span class="hljs-string">&quot;%s&quot;</span>),<span class="hljs-comment">*str);</span><br></code></pre></td></tr></table></figure>

<p> 使用*str是因为FString是UE4的封装类，定义的FString对象都是指针。</p>
<h3 id="日志等级"><a href="#日志等级" class="headerlink" title="日志等级"></a>日志等级</h3><p>UE对日志的打印分了很多个级别，不同的级别打印的内容有所差异，这里就直接摘抄一段<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c550c3223a95">狼图腾_094d</a>的内容了。</p>
<ul>
<li>Fatal</li>
</ul>
<p>Fatal等级日志总是会打印到控制台和日志文件以及crash文件中，甚至logging功能被禁用。</p>
<p>使用Fatal等级的日志时，当代码运行到这个日志出会直接触发代码中断，是严重等级最高的日志等级。</p>
<ul>
<li>Error</li>
</ul>
<p>Error等级日志被打印到控制台和日志文件中，默认以红色显示。</p>
<ul>
<li>Warning</li>
</ul>
<p>Warning等级日志被打印到控制台和日志文件中，默认以黄色显示。</p>
<ul>
<li>Display</li>
</ul>
<p>Display等级日志被打印到控制台和日志文件中。</p>
<ul>
<li>Log</li>
</ul>
<p>Log等级日志打印到日志文件中但是不出现在game模式的控制台中，但是通过编辑器的日志输出窗口还是能够被看到。</p>
<ul>
<li>Verbose</li>
</ul>
<p>Verbose等级日志打印到日志文件中但是不出现在game模式的控制台中，这个通常被用来作为详细日志和调试使用。</p>
<ul>
<li>VeryVerbose</li>
</ul>
<p>VeryVerbose等级日志被打印到日志文件中但是不出现在game模式的控制台中，这通常用来打印非常详细的日志记录否则会产生很多不必要的垃圾输出。</p>
<p>严重级别从上往下一次递减，详细程度从上往下一次递增，日志类别的详细定义在LogVerbosity.h这个头文件中。</p>
<h3 id="自定义UE-LOG输出标签"><a href="#自定义UE-LOG输出标签" class="headerlink" title="自定义UE_LOG输出标签"></a>自定义UE_LOG输出标签</h3><p>UE提供<code>DECLARE_LOG_CATEGORY_EXTERN(CategoryName, DefaultVerbosity, CompileTimeVerbosity)</code>宏来让开发者自定日志标签，其中：</p>
<ul>
<li>CategoryName：日志类别的名称；</li>
<li>DefaultVerbosity：这个类别的日志等级，主要用于在控制台或ini文件里进行等级覆盖。</li>
<li>CompileTimeVerbosity：这个类别的日志可用的最大等级，如，设置成Warning，那么这个类别的日志就只能使用Warning、Error、Fatal三个等级，如果设置成All，那么这个类别就可以使用所有的日志等级，如果使用时传入的等级大于CompileTimeVerbosity规定的等级，那么这个日志行将不会被编译进程序里，运行时这一行代码不运行，这可以很好地进行批量地日志屏蔽。</li>
</ul>
<p>在.h文件中声明</p>
<h3 id="日志等级的覆盖"><a href="#日志等级的覆盖" class="headerlink" title="日志等级的覆盖"></a>日志等级的覆盖</h3><p>在代码里写好了的日志如果想要修改打印等级，除了直接修改代码外，UE还提供了更方便的方法，通过修改DefaultEngine.ini文件或输入命令行来修改日志等级。</p>
<ul>
<li><p>通过运行时命令行来动态地修改日志等级</p>
<p>运行通过按<code>~</code>键通过控制台输入<code>Log [CategoryName] [Level]</code>，（CategoryName：日志类别的名称，Level：等级）可以达到临时的动态的修改日志等级</p>
</li>
<li><p>通过修改Engine.ini来修改日志等级：我们在Engine.ini中添加一个</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Core.Log]</span><br><span class="hljs-attr">global</span>=Log<br><span class="hljs-attr">CategoryName</span>=Error<br></code></pre></td></tr></table></figure>

<p>global：对全局生效，覆盖所有日志的等级；CategoryName：日志类别的名称。</p>
</li>
<li><p>通过在Cmd启动exe在命令行后面接入指令或在exe快捷方式后面接入指令的方式修改日志等级</p>
<p>这里以快捷方式为例(cmd的效果是一样的)，首先打包一个windwos包，为exe创建一个快捷方式，打开快捷方式的属性，在快捷方式后面接入<code>-LogCmds=&quot;CategoryName Error,bar off&quot;</code>(CategoryName ：日志类别的名称)，启动游戏后就会按CompileTimeVerbosity的规则屏蔽或显示日志。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002306.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002306.png" alt="img"></a></p>
</li>
</ul>
<h2 id="3-UCLASS-UPROPERTY-UFUNCTION"><a href="#3-UCLASS-UPROPERTY-UFUNCTION" class="headerlink" title="3.UCLASS()&#x2F;UPROPERTY()&#x2F;UFUNCTION()"></a>3.UCLASS()&#x2F;UPROPERTY()&#x2F;UFUNCTION()</h2><p><strong>作用</strong></p>
<p>这三个宏主要用于为类(UCLASS())，成员变量(UPROPERTY())和成员函数(UFUNCTION())指定一些特性， <strong>他们用来指定被修饰对象可以被复制、被序列化，并可从蓝图中进行访问。垃圾回收器还使用它们来追踪对 UObject 的引用数。</strong></p>
<h3 id="UCLASS-宏的参数"><a href="#UCLASS-宏的参数" class="headerlink" title="UCLASS()宏的参数"></a>UCLASS()宏的参数</h3><table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Abstract</strong></td>
<td>抽象类说明符将类声明为 “抽象基类”, 防止用户在虚幻编辑器中向世界添加此类的参与者, 或在游戏中创建此类的实例。这对于那些本身没有意义的类很有用。例如, ATriggerBase 基类是抽象的, 而 ATriggerBox 子类别不是抽象的, 您可以在世界上放置一个 ATriggerBox 类的实例, 并且它是有用的, 而 ATriggerBase 的实例本身并不有用</td>
</tr>
<tr>
<td><strong>AdvancedClassDisplay</strong></td>
<td>AdvancedClassDisplay 类说明符强制类的所有属性只显示在 “详细信息” 面板的 “高级” 部分中, 默认情况下隐藏在 “视图” 中。若要在单个属性上重写此项, 请在该属性上使用 SimpleDisplay 说明符</td>
</tr>
<tr>
<td><strong>AutoCollapseCategories</strong>&#x3D;(Category1, Category2, …)</td>
<td>类说明符取消对父类AutoExpandCategories说明符的列出类别的影响</td>
</tr>
<tr>
<td><strong>DontAutoCollapseCategories</strong>&#x3D;(Category, Category, …)</td>
<td>否定从父类继承的列出类别的AutoCollapseCategories说明符</td>
</tr>
<tr>
<td><strong>AutoExpandCategories</strong>&#x3D;(Category1, Category2, …)</td>
<td>指定应在该类的对象的 “虚幻编辑器” 属性窗口中自动展开的一个或多个类别。若要自动声明为无类别的变量, 请使用声明变量的类的名称</td>
</tr>
<tr>
<td><strong>Blueprintable &#x2F; NotBlueprintable</strong></td>
<td>将此类公开为创建蓝图的可接受基类。默认是NotBlueprintable，除非继承，否则该说明符由子类继承</td>
</tr>
<tr>
<td><strong>BlueprintType</strong></td>
<td>将此类公开为可用于蓝图中的变量的类型</td>
</tr>
<tr>
<td><strong>ClassGroup</strong>&#x3D;GroupName</td>
<td>表示在Actor浏览器中启用Group View后，虚幻编辑器的Actor浏览器应该在指定的GroupName中包含此类以及此类的任何子类 <strong>CollapseCategories &#x2F; DontCollapseCategories</strong></td>
</tr>
<tr>
<td><strong>CollapseCategories &#x2F; DontCollapseCategories</strong></td>
<td>表示不应将此类的属性分组到虚幻编辑器属性窗口中的类别中。这个说明符被传播给子类；但是，子类可以使用DontCollapseCategories说明符来覆盖它</td>
</tr>
<tr>
<td><strong>Config</strong>&#x3D;ConfigName</td>
<td>表示允许此类在配置文件 (. ini) 中存储数据。如果有使用 config 或 globalconfig 说明符声明的任何类属性, 则此指定符将导致这些属性存储在命名的配置文件中。此说明符被传播到所有子类, 不能被否定, 但是子类可以通过 re-declaring 配置说明符并提供不同的 ConfigName 来更改配置文件。常见的 ConfigName 值是 “Engine”、”Editor”、”Input” 和 “Game”</td>
</tr>
<tr>
<td><strong>Const</strong></td>
<td>该类中的所有属性和函数都是const的，并以const的形式导出。该说明符由子类继承</td>
</tr>
<tr>
<td><strong>ConversionRoot</strong></td>
<td>Root转换将一个子类限制为仅能够转换为第一个Root类的子类，并上升到层次结构</td>
</tr>
<tr>
<td><strong>CustomConstructor</strong></td>
<td>阻止自动生成构造函数声明</td>
</tr>
<tr>
<td><strong>DefaultToInstanced</strong></td>
<td>这个类的所有实例都被认为是“实例化”的。实例化的类（组件）在构建时被复制。该说明符由子类继承</td>
</tr>
<tr>
<td><strong>DependsOn</strong>&#x3D;(ClassName1, ClassName2, …)</td>
<td>列出的所有类将在该类之前编译。类必须在同一个 (或上一个) 包中指定一个类。可以使用由逗号分隔的单个取决于行指定多个依赖项类, 也可以为每个类使用单独的取决于行指定。当类使用在另一个类中声明的结构或枚举时, 这一点很重要, 因为编译器只知道它已编译的类中的内容</td>
</tr>
<tr>
<td><strong>Deprecated</strong></td>
<td>这个类不推荐使用，而且这个类的对象在序列化的时候不会被保存。该说明符由子类继承</td>
</tr>
<tr>
<td><strong>EditInlineNew &#x2F; NotEditInlineNew</strong></td>
<td>表示可以从 “虚幻编辑器” 属性窗口创建此类的对象, 而不是从现有资产引用。默认行为是只有对现有对象的引用才可以通过属性窗口分配。此说明符被传播到所有子类；子类可以使用 NotEditInlineNew 说明符来重写此说明符</td>
</tr>
<tr>
<td><strong>HideCategories</strong>&#x3D;(Category1, Category2, …)</td>
<td>列出应隐藏在此类对象的 “虚幻编辑器” 属性窗口中的一个或多个类别。若要隐藏声明为 “no” 类别的属性, 请使用声明该变量的类的名称。此说明符被传播到子类</td>
</tr>
<tr>
<td><strong>ShowCategories</strong>&#x3D;(Category1, Category2, …)</td>
<td>为所列出的类别取消一个HideCategories说明符（从基类继承）</td>
</tr>
<tr>
<td><strong>HideDropdown</strong></td>
<td>防止在虚幻编辑器属性窗口组合框中显示此类</td>
</tr>
<tr>
<td><strong>HideFunctions</strong>&#x3D;(Category1, Category2, …)</td>
<td>从属性查看器隐藏指定类别中的所有函数</td>
</tr>
<tr>
<td><strong>ShowFunctions</strong>&#x3D;(Category1, Category2, …)</td>
<td>在属性查看器中显示列出的类别中的所有功能</td>
</tr>
<tr>
<td><strong>HideFunctions</strong>&#x3D;FunctionName</td>
<td>隐藏属性查看器中的指定名称的函数</td>
</tr>
<tr>
<td><strong>ShowFunctions</strong>&#x3D;FunctionName</td>
<td>显示属性查看器中的指定名称的函数</td>
</tr>
<tr>
<td><strong>Intrinsic</strong></td>
<td>这表明这个类是直接用C ++声明的，并且没有虚幻头文件工具生成的样板文件。不要在新类上使用这个说明符</td>
</tr>
<tr>
<td><strong>MinimalAPI</strong></td>
<td>仅导致要导出的类的类型信息供其他模块使用。类可以被强制转换, 但不能调用类的函数 (内联方法除外)。这提高了编译时间, 因为不为不需要在其他模块中访问所有函数的类导出所有内容</td>
</tr>
<tr>
<td><strong>NoExport</strong></td>
<td>表示此类的声明不应包含在由标头生成器自动生成的 c++ 头文件中。必须在单独的头文件中手动定义 c++ 类声明。仅对本机类有效。不要将此用于新类</td>
</tr>
<tr>
<td><strong>Placeable</strong>&#x2F;<strong>NotPlaceable</strong></td>
<td>表示可以在编辑器中创建此类, 并将其置于关卡、UI 场景或蓝图中 (具体取决于类类型)。此标志将传播到所有子类；子类可以使用 NotPlaceable 说明符来重写此标志</td>
</tr>
<tr>
<td><strong>Transient</strong>&#x2F;<strong>NonTransient</strong></td>
<td>属于此类的对象将永远不会保存到磁盘。这与某些非永久性的自然类 (如播放器或窗口) 结合使用非常有用。此说明符被传播到子类, 但可以由 NonTransient 说明符重写</td>
</tr>
<tr>
<td><strong>Within</strong>&#x3D;OuterClassName</td>
<td>这个类的对象不能存在于一个OuterClassName对象的实例之外。这意味着创建这个类的Object需要提供一个OuterClassName的实例作为其外部对象</td>
</tr>
</tbody></table>
<p>参考博客： <a target="_blank" rel="noopener" href="https://blog.csdn.net/u012793104/article/details/78547655">https://blog.csdn.net/u012793104/article/details/78547655</a></p>
<h3 id="UPROPERTY-宏的参数"><a href="#UPROPERTY-宏的参数" class="headerlink" title="UPROPERTY()宏的参数"></a>UPROPERTY()宏的参数</h3><table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>AdvancedDisplay</strong></td>
<td>属性在“详细信息”面板的高级下拉列表中</td>
</tr>
<tr>
<td><strong>AssetRegistrySearchable</strong></td>
<td>表明此属性及其值将会为任意将其作为成员变量而包含的资源类示例被自动添加到资源注册中。不可用于结构体属性或参数</td>
</tr>
<tr>
<td><strong>BlueprintAssignable</strong></td>
<td>仅能用于Multicast代理。应显示该属性，以供在蓝图中分配</td>
</tr>
<tr>
<td><strong>BlueprintCallable</strong></td>
<td>仅能用于Multicast代理。应显示该属性，以在蓝图代码中调用</td>
</tr>
<tr>
<td><strong>BlueprintReadOnly</strong></td>
<td>设置属性为蓝图只读。会在蓝图脚本中为被修饰的变量提供 Get 方法，没有 Set 方法</td>
</tr>
<tr>
<td><strong>BlueprintReadWrite</strong></td>
<td>设置属性为蓝图读写。会在蓝图脚本中为被修饰的变量提供 Get 和 Set 方法</td>
</tr>
<tr>
<td><strong>BlueprintGetter</strong></td>
<td>指定一个自定义存取器函数。如果这个属性没有被标记为BlueprintSetter或者BlueprintReadWrite，那么它就是隐式的BlueprintReadOnly。用法：<code>BlueprintGetter = GetterFunctionName()</code></td>
</tr>
<tr>
<td><strong>BlueprintSetter</strong></td>
<td>BlueprintSetter属性有一个自定义的mutator函数，并用BlueprintReadWrite隐式标记。注意，必须指定mutator函数，用法<code>BlueprintSetter = SetterFunctionName</code></td>
</tr>
<tr>
<td><strong>Category</strong> &#x3D; “TopCategory&#96;</td>
<td><code>SubCategory</code></td>
</tr>
<tr>
<td><strong>Config</strong></td>
<td>这个变量将被配置。当前值可以保存到与类关联的.ini文件中，并在创建时加载。无法在默认属性中给出值。意味着ReadOnly</td>
</tr>
<tr>
<td><strong>Const</strong></td>
<td>这个变量是常量,应该导出为常量。在编辑器中const属性将是不可修改的</td>
</tr>
<tr>
<td><strong>DuplicateTransient</strong></td>
<td>表示变量值应在任意类型的重复过程中(复制&#x2F;粘贴， 二进制文件复制等)被重置为类默认值</td>
</tr>
<tr>
<td><strong>EditAnywhere</strong></td>
<td>此属性可以通过属性窗口，原型和实例进行编辑（原型指的是类模板，实例指的是具体的对象实例），这里要注意，不要把指针变量设置成EditAnywhere</td>
</tr>
<tr>
<td><strong>VisibleAnywhere</strong></td>
<td>此属性在所有属性窗口中都可见，但无法编辑。这个标签与“Edit”标签不兼容</td>
</tr>
<tr>
<td><strong>EditDefaultsOnly</strong></td>
<td>该属性可以由属性窗口编辑，但只能在原型上编辑。该操作符与“Visible”标签不兼容</td>
</tr>
<tr>
<td><strong>VisibleDefaultOnly</strong></td>
<td>此属性仅在原型的属性窗口中可见，并且不能被编辑。这个标签与“Edit”标签不兼容</td>
</tr>
<tr>
<td><strong>EditInstanceOnly</strong></td>
<td>这个属性可以被属性窗口编辑，但只能在实例上编辑，而不能在原型上编辑。该操作符与“Visible”标签不兼容</td>
</tr>
<tr>
<td><strong>VisibleInstanceOnly</strong></td>
<td>此属性仅在实例的属性窗口中可见，而不在原型中显示，且无法编辑。这个标签与“编辑”标签不兼容</td>
</tr>
<tr>
<td><strong>EditFixedSize</strong></td>
<td>只对动态数组有用。这将防止用户通过虚幻编辑器属性窗口更改数组的长度</td>
</tr>
<tr>
<td><strong>EditInline</strong></td>
<td>允许用户编辑虚幻编辑器属性检查器中由该变量引用的对象的属性（仅用于对象引用，包括Object引用数组）</td>
</tr>
<tr>
<td><strong>Export</strong></td>
<td>仅适用于对象属性 (或对象数组)。指示在复制对象 (用于复制&#x2F;粘贴) 或导出到 T3D 时, 应将分配给此属性的对象整体导出为对象块, 而不是仅输出对象引用本身</td>
</tr>
<tr>
<td><strong>GlobleConfig</strong></td>
<td>像Config一样工作，只是你不能在子类中覆盖它。无法在默认属性中给出值。意味着ReadOnly</td>
</tr>
<tr>
<td><strong>Instanced</strong></td>
<td>对象 (UCLASS) 属性。创建此类的实例时, 将为默认情况下分配给该变量的对象提供一个唯一的副本。用于在类默认属性中定义的实例子。类似 EditInline 和 Export 修饰符</td>
</tr>
<tr>
<td><strong>Interp</strong></td>
<td>表示该值可由Matinee的浮点或向量属性轨迹来随时间驱动</td>
</tr>
<tr>
<td><strong>Localized</strong></td>
<td>此变量的值将定义本地值。最常用于字符串。ReadOnly</td>
</tr>
<tr>
<td><strong>Native</strong></td>
<td>C++代码负责对其序列化并显示给GC</td>
</tr>
<tr>
<td><strong>NoClear</strong></td>
<td>防止该对象引用在编辑器中被设置为None.隐藏编辑器的清除（以及浏览）按钮</td>
</tr>
<tr>
<td><strong>NoExport</strong></td>
<td>仅对native类有效。此变量不应被包含在自动生成的类声明中</td>
</tr>
<tr>
<td><strong>NonPIEDuplicateTeansient</strong></td>
<td>在复制过程中，该属性将被重置为默认值，除非复制PIE会话</td>
</tr>
<tr>
<td><strong>NonTransactional</strong></td>
<td>表示对此变量值所做的更改将不会包含在编辑器的撤销&#x2F;重做历史记录中</td>
</tr>
<tr>
<td><strong>NotReplicated</strong></td>
<td>跳过复制。这只适用于服务请求函数中的结构成员和参数</td>
</tr>
<tr>
<td><strong>Ref</strong></td>
<td>该值在函数调用后被复制出来。仅在函数参数声明中有效</td>
</tr>
<tr>
<td><strong>Replicated</strong></td>
<td>变量应通过网络进行复制</td>
</tr>
<tr>
<td><strong>ReplicatedUsing</strong> &#x3D; FunctionName</td>
<td>ReplicatedUsing标签指定了一个回调函数，当通过网络更新变量时执行回调函数</td>
</tr>
<tr>
<td><strong>RepRetry</strong></td>
<td>仅用于结构体属性。如无法被完全发送，请重试复制此属性（例如，对象引用尚无法通过节点网络来进行序列化）。对于简单引用来说，这是一个默认值，但对结构体来说，由于带宽消耗，很多情况下我们不需要。所以除非此标识被定义，否则其会被禁用</td>
</tr>
<tr>
<td><strong>SaveGame</strong></td>
<td>此说明符是一种简单的方法，可以在属性级别为检查点&#x2F;保存系统显式包含字段。该标志应设置在所有意图成为已保存游戏一部分的字段上，然后可使用代理归档程序对其进行读取&#x2F;写入</td>
</tr>
<tr>
<td><strong>SerializeText</strong></td>
<td>应将Native属性序列化为文本（ImportText，ExportText）</td>
</tr>
<tr>
<td><strong>SkipSerialization</strong></td>
<td>该属性不会被序列化，但仍然可以导出为文本格式（例如复制&#x2F;粘贴）</td>
</tr>
<tr>
<td><strong>SimpleDisplay</strong></td>
<td>“Visible”或“Edit”属性显示在“详细信息”面板中，不显示“高级”部分即可见</td>
</tr>
<tr>
<td><strong>TextExportTransient</strong></td>
<td>此属性不会被导出为文本格式（例如复制&#x2F;粘贴）</td>
</tr>
<tr>
<td><strong>Transient</strong></td>
<td>属性是暂时的，这意味着它不会被保存或加载。以这种方式标记的属性在加载时将被填满</td>
</tr>
</tbody></table>
<p>参考博客： <a target="_blank" rel="noopener" href="https://blog.csdn.net/u012793104/article/details/78480085">https://blog.csdn.net/u012793104/article/details/78480085</a></p>
<p>UPROPERTY()宏提供了一些元数据说明符，元数据说明符可以对变量做一些限制，比如输入值的大小限定在某一个范围内，如：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">UPROPRETY</span>(meta=(ClampMin=-<span class="hljs-number">5</span>.<span class="hljs-number">0</span>f,ClampMax=<span class="hljs-number">5</span>.<span class="hljs-number">0</span>f,UIMin=-<span class="hljs-number">5</span>.<span class="hljs-number">0</span>f,UIMax=<span class="hljs-number">5</span>.<span class="hljs-number">0</span>f))<br></code></pre></td></tr></table></figure>

<p>详细的说明参官方文档： <a target="_blank" rel="noopener" href="https://docs.unrealengine.com/zh-CN/Programming/UnrealArchitecture/Reference/Metadata/index.html">https://docs.unrealengine.com/zh-CN/Programming/UnrealArchitecture/Reference/Metadata/index.html</a></p>
<h3 id="UFUNCTION-宏的参数"><a href="#UFUNCTION-宏的参数" class="headerlink" title="UFUNCTION()宏的参数"></a>UFUNCTION()宏的参数</h3><table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>BlueprintAuthorityOnly</strong></td>
<td>如果在具有网络权限的计算机（服务器，专用服务器或单人游戏）上运行，此功能只能从Blueprint代码执行,如无网络权限，则该函数将不会从蓝图代码中执行</td>
</tr>
<tr>
<td><strong>BlueprintCallable</strong></td>
<td>该函数可以在蓝图或关卡蓝图图表中执行</td>
</tr>
<tr>
<td><strong>BlueprintCosmetic</strong></td>
<td>此函数为修饰函数而且无法运行在专属服务器上</td>
</tr>
<tr>
<td><strong>BlueprintGetter</strong></td>
<td>修饰自定义的Getter函数专用，该函数将用作Blueprint暴露属性的访问器。这个说明符意味着BlueprintPure和BlueprintCallable。参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u012793104/article/details/78480085">https://blog.csdn.net/u012793104/article/details/78480085</a></td>
</tr>
<tr>
<td><strong>BlueprintSetter</strong></td>
<td>修饰自定义的Setter函数专用，此函数将用作Blueprint暴露属性的增变器。这个说明符意味着BlueprintCallable。参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u012793104/article/details/78480085">https://blog.csdn.net/u012793104/article/details/78480085</a></td>
</tr>
<tr>
<td><strong>BlueprintImplementableEvent</strong></td>
<td>此函数可以在蓝图或关卡蓝图图表内进行重载<em>不能修饰private级别的函数，函数在C++代码中不需要实现定义</em></td>
</tr>
<tr>
<td><strong>BlueprintInternalUseOnly</strong></td>
<td>表示该函数不应该暴露给最终用户</td>
</tr>
<tr>
<td><strong>BlueprintNativeEvent</strong></td>
<td>此函数将由蓝图进行重载，但同时也包含native类的执行。提供一个名称为[FunctionName]_Implementation的函数本体而非[FunctionName];自动生成的代码将包含转换程序,此程序在需要时会调用实施方式</td>
</tr>
<tr>
<td><strong>BlueprintPure</strong></td>
<td>该函数不会以任何方式影响拥有对象，并且可以在蓝图或级别蓝图图表中执行</td>
</tr>
<tr>
<td><strong>CallInEditor</strong></td>
<td>该函数可以在编辑器中通过详细信息面板中的按钮在选定实例中调用</td>
</tr>
<tr>
<td><strong>Category</strong> &#x3D; “TopCategory&#96;</td>
<td>&#96;SubCategory|…”</td>
</tr>
<tr>
<td><strong>Client</strong></td>
<td>此函数仅在该函数从属对象所从属的客户端上执行。提供一个名称为[FunctionName]_Implementation的函数主体，而不是[FunctionName]; 自动生成的代码将包含一个转换程序来在需要时调用实现方法</td>
</tr>
<tr>
<td><strong>CustomThunk</strong></td>
<td>UnrealHeaderTool（虚幻头文件工具）的代码生成器将不会为此函数生成execFoo转换程序; 可由用户来提供</td>
</tr>
<tr>
<td><strong>Exec</strong></td>
<td>此函数可从游戏中的控制台中执行。Exec命令仅在特定类中声明时才产生作用,此标记修饰的函数应在可以接受输入的类中，才能正常接受命令</td>
</tr>
<tr>
<td><strong>NetMilticast</strong></td>
<td>无论角色的NetOwner如何，该函数都在服务器上本地执行并复制到所有客户端</td>
</tr>
<tr>
<td><strong>Reliable</strong></td>
<td>Reliable函数在网络间进行复制，并会忽略带宽或网络错误而被确保送达。仅在与客户端或服务器共同使用时可用</td>
</tr>
<tr>
<td><strong>UnReliable</strong></td>
<td>UnReliable函数在网络间复制，但可能会由于带宽限制或网络错误而传送失败。仅在与客户端或服务器一起使用时有效</td>
</tr>
<tr>
<td><strong>SealeEvent</strong></td>
<td>这个函数不能在子类中重写。 SealedEvent关键字只能用于事件。对于非事件函数，声明它们是static的还是final的来封闭它们</td>
</tr>
<tr>
<td><strong>ServiceRequest</strong></td>
<td>ServiceRequest函数是一个RPC服务请求</td>
</tr>
<tr>
<td><strong>ServiceResponse</strong></td>
<td>ServiceResponse函数是一个RPC服务响应</td>
</tr>
<tr>
<td><strong>Server</strong></td>
<td>此函数仅在服务器上执行。提供一个名称为[FunctionName]_Implementation的函数主体，而不是[FunctionName]; 自动生成的代码将包含一个转换程序来在需要时调用实现方法</td>
</tr>
<tr>
<td><strong>WithValidation</strong></td>
<td>声明一个名为与main函数相同的附加函数，但将_Validation添加到最后。该函数采用相同的参数，并返回一个布尔值来指示是否应该继续调用主函数</td>
</tr>
</tbody></table>
<p>UFUNCTION()宏也提供了元数据说明符，元数据说明符可以对参数做一些限制，这里不再列出，详细的说明参官方文档： <a target="_blank" rel="noopener" href="https://docs.unrealengine.com/zh-CN/Programming/UnrealArchitecture/Reference/Metadata/index.html">https://docs.unrealengine.com/zh-CN/Programming/UnrealArchitecture/Reference/Metadata/index.html</a></p>
<h2 id="4-meta"><a href="#4-meta" class="headerlink" title="4.meta"></a>4.meta</h2><p>meta是UCLASS、UPROPERTY、UFUNCTION、UINTERFACE、USTRUCT、UENUM宏使用的元数据说明，用以描述类、属性、函数、接口、结构体和枚举，对于不同的类型meta有不同的元数据说明符。</p>
<p>这里就直接摘抄<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/GameplayArchitecture/Metadata/">UE官网</a>的内容了。</p>
<h3 id="类元数据说明符"><a href="#类元数据说明符" class="headerlink" title="类元数据说明符"></a>类元数据说明符</h3><table>
<thead>
<tr>
<th align="left">说明符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>BlueprintSpawnableComponent</code></td>
<td align="left">如果存在，组件类可以由蓝图生成。</td>
</tr>
<tr>
<td align="left"><code>BlueprintThreadSafe</code></td>
<td align="left">仅对蓝图函数库有效。该说明符将此类中的函数标记为可在动画蓝图中的非游戏线程上调用。</td>
</tr>
<tr>
<td align="left"><code>ChildCannotTick</code></td>
<td align="left">用于 Actor 和 Component 类。如果原生类无法勾选，则基于此 Actor 或组件的蓝图生成的类将永远无法勾选，即使<code>bCanBlueprintsTickByDefault</code>为真。</td>
</tr>
<tr>
<td align="left"><code>ChildCanTick</code></td>
<td align="left">用于 Actor 和 Component 类。如果原生类无法勾选，则基于此 Actor 或组件的蓝图生成的类可以<code>bCanEverTick</code>覆盖该标志，即使该标志<code>bCanBlueprintsTickByDefault</code>为 false。</td>
</tr>
<tr>
<td align="left"><code>DeprecatedNode</code></td>
<td align="left">对于行为树节点，表示该类已弃用，编译时将显示警告。</td>
</tr>
<tr>
<td align="left"><code>DeprecationMessage=&quot;Message Text&quot;</code></td>
<td align="left">具有此元数据的已弃用类将包含此文本以及蓝图脚本在编译期间生成的标准弃用警告。</td>
</tr>
<tr>
<td align="left"><code>DisplayName=&quot;Blueprint Node Name&quot;</code></td>
<td align="left">蓝图脚本中此节点的名称将替换为此处提供的值，而不是代码生成的名称。</td>
</tr>
<tr>
<td align="left"><code>DontUseGenericSpawnObject</code></td>
<td align="left">不要使用蓝图脚本中的通用创建对象节点生成类的对象；此说明符仅适用于既不是 Actor 也不是 Actor 组件的蓝图类型类。</td>
</tr>
<tr>
<td align="left"><code>ExposedAsyncProxy</code></td>
<td align="left">在异步任务节点中公开此类的代理对象。</td>
</tr>
<tr>
<td align="left"><code>IgnoreCategoryKeywordsInSubclasses</code></td>
<td align="left">用于使类的第一个子类忽略所有继承的<code>ShowCategories</code>和说明<code>HideCategories</code>符。</td>
</tr>
<tr>
<td align="left"><code>IsBlueprintBase=&quot;true/false&quot;</code></td>
<td align="left">说明此类是（或不是）可接受的用于创建蓝图的基类，类似于<code>Blueprintable</code>或“NotBlueprintable”说明符。</td>
</tr>
<tr>
<td align="left"><code>KismetHideOverrides=&quot;Event1, Event2, ..&quot;</code></td>
<td align="left">不允许被覆盖的蓝图事件列表。</td>
</tr>
<tr>
<td align="left"><code>ProhibitedInterfaces=&quot;Interface1, Interface2, ..&quot;</code></td>
<td align="left">列出与类不兼容的接口。</td>
</tr>
<tr>
<td align="left"><code>RestrictedToClasses=&quot;Class1, Class2, ..&quot;</code></td>
<td align="left">蓝图函数库类可以使用它来限制对列表中命名的类的使用。</td>
</tr>
<tr>
<td align="left"><code>ShortToolTip=&quot;Short tooltip&quot;</code></td>
<td align="left">一个简短的工具提示，在某些情况下使用完整的工具提示可能会让人不知所措，例如父类选择器对话框。</td>
</tr>
<tr>
<td align="left"><code>ShowWorldContextPin</code></td>
<td align="left">指示放置在此类拥有的图表中的蓝图节点必须显示其世界上下文引脚，即使它们通常是隐藏的，因为此类的对象不能用作世界上下文。</td>
</tr>
<tr>
<td align="left"><code>UsesHierarchy</code></td>
<td align="left">指示类使用分层数据。用于实例化详细信息面板中的分层编辑功能。</td>
</tr>
<tr>
<td align="left"><code>ToolTip=&quot;Hand-written tooltip&quot;</code></td>
<td align="left">覆盖从代码注释自动生成的工具提示。</td>
</tr>
</tbody></table>
<h3 id="属性元数据说明符"><a href="#属性元数据说明符" class="headerlink" title="属性元数据说明符"></a>属性元数据说明符</h3><table>
<thead>
<tr>
<th align="left">说明符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>AllowAbstract=&quot;true/false&quot;</code></td>
<td align="left">用于<code>Subclass</code>和<code>SoftClass</code>属性。指示抽象类类型是否应显示在类选择器中。</td>
</tr>
<tr>
<td align="left"><code>AllowedClasses=&quot;Class1, Class2, ..&quot;</code></td>
<td align="left">用于<code>FSoftObjectPath</code>属性。逗号分隔列表，指示要在资产选择器中显示的资产的类类型。</td>
</tr>
<tr>
<td align="left"><code>AllowPreserveRatio</code></td>
<td align="left">用于<code>FVector</code>属性。在详细信息面板中显示此属性时，它会导致添加比率锁定。</td>
</tr>
<tr>
<td align="left"><code>ArrayClamp=&quot;ArrayProperty&quot;</code></td>
<td align="left">用于整数属性。将可在 UI 中输入的有效值限制在 0 和命名数组属性的长度之间。</td>
</tr>
<tr>
<td align="left"><code>AssetBundles</code></td>
<td align="left">用于<code>SoftObjectPtr</code>或<code>SoftObjectPath</code>属性。主数据资产中使用的 Bundle 名称列表，用于指定此引用属于哪些 Bundle。</td>
</tr>
<tr>
<td align="left"><code>BlueprintBaseOnly</code></td>
<td align="left">用于<code>Subclass</code>和<code>SoftClass</code>属性。指示类选择器中是否应仅显示蓝图类。</td>
</tr>
<tr>
<td align="left"><code>BlueprintCompilerGeneratedDefaults</code></td>
<td align="left"><code>CopyPropertiesForUnrelatedObjects</code>属性默认值由蓝图编译器生成，在编译后调用函数时不会被复制。</td>
</tr>
<tr>
<td align="left"><code>ClampMin=&quot;N&quot;</code></td>
<td align="left">用于浮点和整数属性。<code>N</code>指定可以为属性输入的最小值。</td>
</tr>
<tr>
<td align="left"><code>ClampMax=&quot;N&quot;</code></td>
<td align="left">用于浮点和整数属性。<code>N</code>指定可以为属性输入的最大值。</td>
</tr>
<tr>
<td align="left"><code>ConfigHierarchyEditable</code></td>
<td align="left">此属性被序列化为 config ( <code>.ini</code>) 文件，并且可以在配置层次结构中的任何位置设置。</td>
</tr>
<tr>
<td align="left"><code>ContentDir</code></td>
<td align="left">由<code>FDirectoryPath</code>属性使用。表示将使用<code>Content</code>文件夹内的 Slate 样式目录选择器选择路径。</td>
</tr>
<tr>
<td align="left"><code>DisplayAfter=&quot;PropertyName&quot;</code></td>
<td align="left"><code>PropertyName</code>只要两个属性属于同一类别，该属性就会在名为 的属性之后立即显示在蓝图编辑器中，无论其在源代码中的顺序如何。如果多个属性具有相同的<code>DisplayAfter</code>值和相同的<code>DisplayPriority</code>值，它们将按照在头文件中声明的顺序出现在命名属性之后。</td>
</tr>
<tr>
<td align="left"><code>DisplayName=&quot;Property Name&quot;</code></td>
<td align="left">为此属性显示的名称，而不是代码生成的名称。</td>
</tr>
<tr>
<td align="left"><code>DisplayPriority=&quot;N&quot;</code></td>
<td align="left">如果两个属性具有相同的<code>DisplayAfter</code>值，或者属于同一类别且没有<code>DisplayAfter</code>元标记，则此属性将确定它们的排序顺序。最高优先级值为 1，表示<code>DisplayPriority</code>值为 1 的属性将出现在<code>DisplayProirity</code>值为 2 的属性之上。如果多个属性具有相同的<code>DisplayAfter</code>值，它们将按照它们在标题中声明的顺序出现文件。</td>
</tr>
<tr>
<td align="left"><code>DisplayThumbnail=&quot;true&quot;</code></td>
<td align="left">表示该属性是一个资产类型，它应该显示所选资产的缩略图。</td>
</tr>
<tr>
<td align="left"><code>EditCondition=&quot;BooleanPropertyName&quot;</code></td>
<td align="left">命名一个布尔属性，用于指示是否禁用编辑此属性。放“！” 在属性名称反转测试之前。EditCondition 元标记不再局限于单个布尔属性。它现在使用成熟的表达式解析器进行评估，这意味着您可以包含完整的 C++ 表达式。</td>
</tr>
<tr>
<td align="left"><code>EditFixedOrder</code></td>
<td align="left">防止通过拖动对数组元素进行重新排序。</td>
</tr>
<tr>
<td align="left"><code>ExactClass=&quot;true&quot;</code></td>
<td align="left">用于<code>FSoftObjectPath</code>与 结合使用的属性<code>AllowedClasses</code>。指示是否只能使用中指定的确切类<code>AllowedClasses</code>，或者子类是否也有效。</td>
</tr>
<tr>
<td align="left"><code>ExposeFunctionCategories=&quot;Category1, Category2, ..&quot;</code></td>
<td align="left">指定在蓝图编辑器中构建功能列表时应公开其功能的类别列表。</td>
</tr>
<tr>
<td align="left"><code>ExposeOnSpawn=&quot;true&quot;</code></td>
<td align="left">指定该属性是否应在此 Class 类型的 Spawn Actor 节点上公开。</td>
</tr>
<tr>
<td align="left"><code>FilePathFilter=&quot;FileType&quot;</code></td>
<td align="left">由<code>FFilePath</code>属性使用。指示要在文件选择器中显示的路径过滤器。常用值包括“uasset”和“umap”，但这些不是唯一可能的值。</td>
</tr>
<tr>
<td align="left"><code>GetByRef</code></td>
<td align="left">使该属性的“获取”蓝图节点返回对该属性的 const 引用，而不是其值的副本。仅可用于稀疏类数据，并且仅在<code>NoGetter</code>不存在时使用。</td>
</tr>
<tr>
<td align="left"><code>HideAlphaChannel</code></td>
<td align="left">用于<code>FColor</code>和<code>FLinearColor</code>属性。指示<code>Alpha</code>在详细信息中显示属性小部件时应隐藏该属性。</td>
</tr>
<tr>
<td align="left"><code>HideViewOptions</code></td>
<td align="left">用于<code>Subclass</code>和<code>SoftClass</code>属性。隐藏在类选择器中更改视图选项的能力。</td>
</tr>
<tr>
<td align="left"><code>InlineEditConditionToggle</code></td>
<td align="left">表示布尔属性仅在其他属性中作为编辑条件切换内联显示，不应显示在其自己的行上。</td>
</tr>
<tr>
<td align="left"><code>LongPackageName</code></td>
<td align="left">由<code>FDirectoryPath</code>属性使用。将路径转换为长包名。</td>
</tr>
<tr>
<td align="left"><code>MakeEditWidget</code></td>
<td align="left">用于变换或旋转器属性，或变换或旋转器数组。指示该属性应在视口中作为可移动小部件公开。</td>
</tr>
<tr>
<td align="left"><code>NoGetter</code></td>
<td align="left">导致蓝图生成不为此属性生成“获取”节点。仅可用于稀疏类数据。</td>
</tr>
</tbody></table>
<h3 id="函数元数据说明符"><a href="#函数元数据说明符" class="headerlink" title="函数元数据说明符"></a>函数元数据说明符</h3><table>
<thead>
<tr>
<th align="left">说明符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>AdvancedDisplay=&quot;Parameter1, Parameter2, ..&quot;</code></td>
<td align="left">逗号分隔的参数列表将显示为高级引脚（需要 UI 扩展）。</td>
</tr>
<tr>
<td align="left"><code>AdvancedDisplay=N</code></td>
<td align="left">替换<code>N</code>为数字，第N个之后的所有参数都会显示为高级引脚（需要UI扩展）。例如，“AdvancedDisplay&#x3D;2”会将除前两个参数之外的所有参数都标记为高级）。</td>
</tr>
<tr>
<td align="left"><code>ArrayParm=&quot;Parameter1, Parameter2, ..&quot;</code></td>
<td align="left">指示<code>BlueprintCallable</code>函数应使用调用数组函数节点，并且列出的参数应视为通配符数组属性。</td>
</tr>
<tr>
<td align="left"><code>ArrayTypeDependentParams=&quot;Parameter&quot;</code></td>
<td align="left">使用时<code>ArrayParm</code>，该说明符表示一个参数，它将确定<code>ArrayParm</code>列表中所有参数的类型。</td>
</tr>
<tr>
<td align="left"><code>AutoCreateRefTerm=&quot;Parameter1, Parameter2, ..&quot;</code></td>
<td align="left">列出的参数虽然通过引用传递，但如果它们的引脚断开连接，将具有自动创建的默认值。这是蓝图的一项便利功能，通常用于阵列引脚。</td>
</tr>
<tr>
<td align="left"><code>BlueprintAutocast</code></td>
<td align="left"><code>BlueprintPure</code>仅由蓝图函数库中的静态函数使用。将自动为函数的返回类型和第一个参数的类型添加一个强制转换节点。</td>
</tr>
<tr>
<td align="left"><code>BlueprintInternalUseOnly</code></td>
<td align="left">该函数是一个内部实现细节，用于实现另一个函数或节点。它永远不会直接暴露在蓝图图表中。</td>
</tr>
<tr>
<td align="left"><code>BlueprintProtected</code></td>
<td align="left">此函数只能在蓝图中的所属对象上调用。它不能在另一个实例上调用。</td>
</tr>
<tr>
<td align="left"><code>CallableWithoutWorldContext</code></td>
<td align="left">用于<code>BlueprintCallable</code>具有<code>WorldContext</code>pin 的函数，以指示即使其 Class 未实现该函数也可以调用该<code>GetWorld</code>函数。</td>
</tr>
<tr>
<td align="left"><code>CommutativeAssociativeBinaryOperator</code></td>
<td align="left">指示<code>BlueprintCallable</code>函数应使用 Commutative Associative Binary 节点。该节点没有引脚名称，但有一个<strong>添加引脚</strong>按钮，可以创建额外的输入引脚。</td>
</tr>
<tr>
<td align="left"><code>CompactNodeTitle=&quot;Name&quot;</code></td>
<td align="left">指示<code>BlueprintCallable</code>函数应以紧凑显示模式显示，并提供在该模式下显示的名称。</td>
</tr>
<tr>
<td align="left"><code>CustomStructureParam=&quot;Parameter1, Parameter2, ..&quot;</code></td>
<td align="left">列出的参数都被视为通配符。此说明符需要<code>UFUNCTION</code>-level 说明符<code>CustomThunk</code>，这将要求用户提供自定义<code>exec</code>函数。在这个函数中，可以检查参数类型，并根据这些参数类型进行适当的函数调用。<code>UFUNCTION</code>永远不应该调用 基础，如果是，则应该断言或记录错误。要声明自定义函数，请使用原始函数名称的<code>exec</code>语法。<code>DECLARE_FUNCTION(execMyFunctionName)``MyFunctionName</code></td>
</tr>
<tr>
<td align="left"><code>DefaultToSelf</code></td>
<td align="left">对于<code>BlueprintCallable</code>函数，这表明 Object 属性的命名默认值应该是节点的自身上下文。</td>
</tr>
<tr>
<td align="left"><code>DeprecatedFunction</code></td>
<td align="left">对该函数的任何蓝图引用都会导致编译警告，告知用户该函数已被弃用。您可以使用元数据说明符添加到弃用警告消息（例如，提供有关替换弃用函数的说明）<code>DeprecationMessage</code>。</td>
</tr>
<tr>
<td align="left"><code>DeprecationMessage</code>&#x3D;”消息文本”</td>
<td align="left">如果该函数已弃用，则在尝试编译使用它的蓝图时，此消息将添加到标准弃用警告中。</td>
</tr>
<tr>
<td align="left"><code>DeterminesOutputType=&quot;Parameter&quot;</code></td>
<td align="left">函数的返回类型将动态更改以匹配连接到命名参数引脚的输入。参数应该是模板类型，例如<code>TSubClassOf&lt;X&gt;</code>or <code>TSoftObjectPtr&lt;X&gt;</code>，其中函数的原始返回类型是<code>X*</code>或具有值类型的容器<code>X*</code>，例如<code>TArray&lt;X*&gt;</code>.</td>
</tr>
<tr>
<td align="left"><code>DevelopmentOnly</code></td>
<td align="left">标记为的函数<code>DevelopmentOnly</code>只会在开发模式下运行。这对于调试输出等功能很有用，预计交付的产品中不存在该功能。</td>
</tr>
<tr>
<td align="left"><code>DisplayName=&quot;Blueprint Node Name&quot;</code></td>
<td align="left">蓝图中此节点的名称将替换为此处提供的值，而不是代码生成的名称。</td>
</tr>
<tr>
<td align="left"><code>ExpandEnumAsExecs=&quot;Parameter&quot;</code></td>
<td align="left">对于<code>BlueprintCallable</code>函数，这表示应该为<code>enum</code>参数使用的每个条目创建一个输入执行引脚。参数必须是具有<code>UENUM</code>标记的枚举类型。</td>
</tr>
<tr>
<td align="left"><code>HidePin=&quot;Parameter&quot;</code></td>
<td align="left">对于<code>BlueprintCallable</code>函数，这表明参数引脚应该从用户的视图中隐藏。以这种方式，每个功能只能隐藏一个引脚。</td>
</tr>
<tr>
<td align="left"><code>HideSelfPin</code></td>
<td align="left">隐藏“self”引脚，它指示正在调用函数的对象。“self”引脚在<code>BlueprintPure</code>与调用蓝图的类兼容的函数上自动隐藏。<code>HideSelfPin</code>经常使用元标记的函数也使用说明<code>DefaultToSelf</code>符。</td>
</tr>
<tr>
<td align="left"><code>InternalUseParam=&quot;Parameter&quot;</code></td>
<td align="left">与 类似<code>HidePin</code>，这从用户的视图中隐藏了命名参数的引脚，并且每个函数只能用于一个参数。</td>
</tr>
<tr>
<td align="left"><code>KeyWords=&quot;Set Of Keywords&quot;</code></td>
<td align="left">指定搜索此函数时可以使用的一组关键字，例如在蓝图图表中放置节点以调用函数时。</td>
</tr>
<tr>
<td align="left"><code>Latent</code></td>
<td align="left">表示潜在动作。潜在动作有一个类型参数<code>FLatentActionInfo</code>，该参数由说明<code>LatentInfo</code>符命名。</td>
</tr>
<tr>
<td align="left"><code>LatentInfo=&quot;Parameter&quot;</code></td>
<td align="left">对于 Latent<code>BlueprintCallable</code>函数，指示哪个参数是 LatentInfo 参数。</td>
</tr>
<tr>
<td align="left"><code>MaterialParameterCollectionFunction</code></td>
<td align="left">对于<code>BlueprintCallable</code>函数，指示应使用材质覆盖节点。</td>
</tr>
<tr>
<td align="left"><code>NativeBreakFunc</code></td>
<td align="left">对于<code>BlueprintCallable</code>函数，表示该函数应以与标准 Break Struct 节点相同的方式显示。</td>
</tr>
<tr>
<td align="left"><code>NotBlueprintThreadSafe</code></td>
<td align="left">仅在蓝图函数库中有效。此函数将被视为拥有类的一般<code>BlueprintThreadSafe</code>元数据的异常。</td>
</tr>
<tr>
<td align="left"><code>ShortToolTip=&quot;Short tooltip&quot;</code></td>
<td align="left">一个简短的工具提示，在某些情况下使用完整的工具提示可能会让人不知所措，例如父类选择器对话框。</td>
</tr>
<tr>
<td align="left"><code>ToolTip=&quot;Hand-written tooltip&quot;</code></td>
<td align="left">覆盖从代码注释自动生成的工具提示。</td>
</tr>
<tr>
<td align="left"><code>UnsafeDuringActorConstruction</code></td>
<td align="left">在 Actor 构造期间调用此函数是不安全的。</td>
</tr>
<tr>
<td align="left"><code>WorldContext=&quot;Parameter&quot;</code></td>
<td align="left">由<code>BlueprintCallable</code>函数用来指示哪个参数确定操作发生的世界。</td>
</tr>
</tbody></table>
<h3 id="接口元数据说明符"><a href="#接口元数据说明符" class="headerlink" title="接口元数据说明符"></a>接口元数据说明符</h3><table>
<thead>
<tr>
<th align="left">说明符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>CannotImplementInterfaceInBlueprint</code></td>
<td align="left">此接口可能不包含<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/GameplayArchitecture/Functions/Specifiers"><code>BlueprintImplementableEvent</code>或<code>BlueprintNativeEvent</code></a>函数，除了内部函数。如果它包含未定义蓝图的蓝图可调用函数，则必须在本机代码中实现这些函数。</td>
</tr>
</tbody></table>
<h3 id="结构体元数据说明符"><a href="#结构体元数据说明符" class="headerlink" title="结构体元数据说明符"></a>结构体元数据说明符</h3><table>
<thead>
<tr>
<th align="left">说明符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>HasNativeBreak=&quot;Module.Class.Function&quot;</code></td>
<td align="left">指示此结构具有自定义 Break Struct 节点。必须提供模块、类和函数名称。</td>
</tr>
<tr>
<td align="left"><code>HasNativeMake=&quot;Module.Class.Function&quot;</code></td>
<td align="left">指示此结构具有自定义 Make Struct 节点。必须提供模块、类和函数名称。</td>
</tr>
<tr>
<td align="left"><code>HiddenByDefault</code></td>
<td align="left">Make Struct 和 Break Struct 节点中的引脚默认隐藏。</td>
</tr>
<tr>
<td align="left"><code>ShortToolTip=&quot;Short tooltip&quot;</code></td>
<td align="left">一个简短的工具提示，在某些情况下使用完整的工具提示可能会让人不知所措，例如父类选择器对话框。</td>
</tr>
<tr>
<td align="left"><code>ToolTip=&quot;Hand-written tooltip</code></td>
<td align="left">覆盖从代码注释自动生成的工具提示。</td>
</tr>
</tbody></table>
<h3 id="枚举元数据说明符"><a href="#枚举元数据说明符" class="headerlink" title="枚举元数据说明符"></a>枚举元数据说明符</h3><table>
<thead>
<tr>
<th align="left">说明符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Bitflags</code></td>
<td align="left">指示此枚举类型可以用作使用元数据说明符<code>UPROPERTY</code>设置的整数变量的标志。<code>Bitmask</code>，关于位掩码的使用参见<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43844254/article/details/109208456">张悟基大佬的文章</a></td>
</tr>
<tr>
<td align="left"><code>Experimental</code></td>
<td align="left">将此类型标记为实验性且不受支持。</td>
</tr>
<tr>
<td align="left"><code>ScriptName=&quot;Display Name&quot;</code></td>
<td align="left">带引号的字符串将在编辑器中用作此枚举类型的名称，而不是 Unreal Header Tool 生成的默认名称。</td>
</tr>
<tr>
<td align="left"><code>ToolTip=&quot;Hand-written tooltip&quot;</code></td>
<td align="left">覆盖从代码注释自动生成的工具提示。</td>
</tr>
</tbody></table>
<h3 id="UMATE"><a href="#UMATE" class="headerlink" title="UMATE"></a>UMATE</h3><p>UMATE是枚举成员专用的元数据说明宏，可以使用如下说明符：</p>
<table>
<thead>
<tr>
<th>元数据说明符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DisplayName&#x3D;”Enumerated Value Name”</td>
<td>该值的名称将是此处提供的文本，而不是代码生成的名称。</td>
</tr>
<tr>
<td>Hidden</td>
<td>该值不会出现在编辑器中。</td>
</tr>
<tr>
<td>ToolTip&#x3D;”Hand-written tooltip.”</td>
<td>覆盖从代码注释自动生成的工具提示。</td>
</tr>
</tbody></table>
<h2 id="5-GENERATED-BODY"><a href="#5-GENERATED-BODY" class="headerlink" title="5.GENERATED_BODY()"></a>5.GENERATED_BODY()</h2><p>GENERATED_BODY()宏标识的类表示，此类不可以使用父类的声明，最常见的就是GENERATED_BODY标识的类必须要自己声明和实现无参构造函数，否则编译将无法通过。</p>
<h2 id="6-GENERATED-UCLASS-BODY"><a href="#6-GENERATED-UCLASS-BODY" class="headerlink" title="6.GENERATED_UCLASS_BODY()"></a>6.GENERATED_UCLASS_BODY()</h2><p>GENERATED_UCLASS_BODY()宏标识的类表示此类继承父类的声明，最常见的就是GENERATED_UCLASS_BODY()标识的类不需要声明构造函数，如果需要重写构造函数，则必须为构造函数传递FObjectInitializer类的常量引用，这也是为什么我们经常在UE4编程中看见如下代码的缘故</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">UMySQLDatabase</span>::<span class="hljs-function"><span class="hljs-title">UMySQLDatabase</span>(<span class="hljs-variable">const</span> <span class="hljs-variable">FObjectInitializer</span>&amp; <span class="hljs-variable">ObjectInitializer</span>)</span><br>	: <span class="hljs-function"><span class="hljs-title">Super</span>(<span class="hljs-variable">ObjectInitializer</span>)</span><br>&#123;<br>        <span class="hljs-comment">//重写块</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中Super()用于给父类传递参数</p>
<p> GENERATED_BODY()和GENERATED_UCLASS_BODY()宏都会为其标识的类生成一些成员函数，只是二者在使用权限上有一些区别，具体生成了什么成员函数及其区别由于目前自己搜索到的资料过少，暂时无法弄明白，需要以后慢慢研究。</p>
<h1 id="十、C-加载蓝图资源"><a href="#十、C-加载蓝图资源" class="headerlink" title="十、C++加载蓝图资源"></a>十、C++加载蓝图资源</h1><p>C++加载蓝图资源分两类，普通文件资源(如：mesh，material等)和蓝图类资源。</p>
<h2 id="1-加载文件资源"><a href="#1-加载文件资源" class="headerlink" title="1.加载文件资源"></a>1.加载文件资源</h2><p>UE4的文件资源一般都是继承自UObject，如：UStaticMesh、UMaterial、UUserWidget、UComponent等，这些继承自UObject的资源都可以通过<code>LoadObject</code>函数加载，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AContainerctor::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Super::<span class="hljs-built_in">BeginPlay</span>();<br>	UStaticMesh* Mesh = <span class="hljs-built_in">LoadObject</span>&lt;UStaticMesh&gt;(<span class="hljs-literal">nullptr</span>, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;StaticMesh&#x27;/Game/Cube.Cube&#x27;&quot;</span>));<br>	UStaticMeshComponent* MeshComp = <span class="hljs-built_in">NewObject</span>&lt;UStaticMeshComponent&gt;(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Cube&quot;</span>));<br>	MeshComp-&gt;<span class="hljs-built_in">RegisterComponent</span>();<br>	MeshComp-&gt;<span class="hljs-built_in">SetStaticMesh</span>(Mesh);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>除此之外UE4还提供一个<code>StaticLoadObject</code>函数，效果上和LoadObject函数一致，区别在于LoadObject是对StaticLOadObject的封装，LoadObject会自动转换UObject类型，而StaticLoadObject需要自己手动转换。</p>
<p>虽然LoadObject在构造函数内外都可以使用，不过UE4还是提供了一个专门给构造函数使用的资源加载函数<code>ConstructorHelpers::FObjectFinder</code></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-title class_">AContainerctor</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:AContainerctor</span>()<br>&#123;<br>	<span class="hljs-title class_">PrimaryActorTick</span>.bCanEverTick = <span class="hljs-literal">true</span>;<br>	<span class="hljs-title class_">ConstructorHelpers</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:FObjectFinder&lt;UStaticMesh&gt;</span> <span class="hljs-title class_">Mesh</span>(<span class="hljs-variable constant_">TEXT</span>(<span class="hljs-string">&quot;StaticMesh&#x27;/Game/Cube.Cube&#x27;&quot;</span>));<br>	<span class="hljs-title class_">UStaticMeshComponent</span>* <span class="hljs-title class_">MeshComp</span> = <span class="hljs-title class_">CreateDefaultSubobject</span>&lt;<span class="hljs-title class_">UStaticMeshComponent</span>&gt;(<span class="hljs-string">&quot;Cube&quot;</span>);<br>	<span class="hljs-title class_">MeshComp</span>-&gt;<span class="hljs-title class_">SetupAttachment</span>(<span class="hljs-title class_">GetRootComponent</span>());<br>	<span class="hljs-title class_">MeshComp</span>-&gt;<span class="hljs-title class_">SetStaticMesh</span>(<span class="hljs-title class_">Mesh</span>.<span class="hljs-title class_">Object</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们注意到直接通过编辑器拷贝的资源路径都有一个对应资源的前缀，在这里是StaticMesh，实际上这个前缀要不要效果是一样的。</p>
<p>上面的加载方式想要把资源路径做得更灵活，可以把资源路径以FString变量的形式传递，并可以把变量公开到蓝图，但是在输入上我们依然要输入一个资源路径，UE4封装了一个更便捷的封装方式—<code>FSoftObjectPath</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">UCLASS</span>()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UE4CPP_API</span> AContainerctor : <span class="hljs-keyword">public</span> AActor<br>&#123;<br>	<span class="hljs-built_in">GENERATED_BODY</span>()<br><span class="hljs-keyword">public</span>:	<br>	<span class="hljs-built_in">UPROPERTY</span>(EditAnywhere)<br>	FSoftObjectPath softObj;<br>	<span class="hljs-built_in">AContainerctor</span>();<br><span class="hljs-keyword">protected</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-keyword">public</span>:	<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Tick</span><span class="hljs-params">(<span class="hljs-type">float</span> DeltaTime)</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AContainerctor::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Super::<span class="hljs-built_in">BeginPlay</span>();<br>	UStaticMesh* Mesh = <span class="hljs-built_in">CastChecked</span>&lt;UStaticMesh&gt;(softObj.<span class="hljs-built_in">TryLoad</span>());<br>	UStaticMeshComponent* MeshComp = <span class="hljs-built_in">NewObject</span>&lt;UStaticMeshComponent&gt;(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Cube&quot;</span>));<br>	MeshComp-&gt;<span class="hljs-built_in">RegisterComponent</span>();<br>	MeshComp-&gt;<span class="hljs-built_in">SetStaticMesh</span>(Mesh);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这一顿操作下来就可以形成这样的资源的路径选择。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002325.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002325.png" alt="img"></a></p>
<h2 id="2-加载蓝图资源"><a href="#2-加载蓝图资源" class="headerlink" title="2.加载蓝图资源"></a>2.加载蓝图资源</h2><p>加载蓝图类使用的是<code>LoadClass</code>，相对的也存在一个<code>StaticLoadClass</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AContainerctor::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Super::<span class="hljs-built_in">BeginPlay</span>();<br>	UClass* uclass = <span class="hljs-built_in">LoadClass</span>&lt;AActor&gt;(<span class="hljs-literal">nullptr</span>,<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Blueprint&#x27;/Game/Act.Act_C&#x27;&quot;</span>));<br>	AActor* Act = <span class="hljs-built_in">GetWorld</span>()-&gt;<span class="hljs-built_in">SpawnActor</span>&lt;AActor&gt;(uclass);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>与加载资源不同的是，加载蓝图类的路径需要手动加载<code>_C</code>后缀，否则UE4会找不到对应的蓝图类。</p>
<p>同上，在构造函数中加载，UE4也提供了<code>ConstructorHelpers::FClassFinder</code>函数。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-title class_">ConstructorHelpers</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:FClassFinder&lt;AActor&gt;</span> <span class="hljs-title class_">Act</span>(<span class="hljs-variable constant_">TEXT</span>(<span class="hljs-string">&quot;Blueprint&#x27;/Game/Act.Act_C&#x27;&quot;</span>));<br></code></pre></td></tr></table></figure>

<p>但是由于UE4是不允许在构造函数中SpawnActor的，所以即使我们在构造函数中加载了类资源，也必须在构造函数外加载蓝图类。</p>
<p>同FSoftObjectPath一样，UE4提供FSoftClassPath。</p>
<p>最终的效果就是这样的：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002330.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002330.png" alt="img"></a></p>
<h1 id="十一、反射和垃圾回收"><a href="#十一、反射和垃圾回收" class="headerlink" title="十一、反射和垃圾回收"></a>十一、反射和垃圾回收</h1><p>UE4使用C++语言进行开发，但是C++并不支持反射和垃圾回收机制，所以UE4便自己实现了反射和垃圾回收。</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>UE4使用一系列的宏来实现反射，在反射中用的宏主要有</p>
<table>
<thead>
<tr>
<th>宏</th>
<th>对应的反射对象</th>
</tr>
</thead>
<tbody><tr>
<td>UCLASS</td>
<td>C++类</td>
</tr>
<tr>
<td>UFUNCTION</td>
<td>函数</td>
</tr>
<tr>
<td>UPROPERTY</td>
<td>成员变量</td>
</tr>
<tr>
<td>USTRUCT</td>
<td>结构体</td>
</tr>
</tbody></table>
<p>要使用这些宏，必须包含头文件<code>#include &quot;MyActor.generated.h&quot;</code>，并且这个头文件还必须放在左后一位。</p>
<h3 id="UE4是如何实现反射的呢？"><a href="#UE4是如何实现反射的呢？" class="headerlink" title="UE4是如何实现反射的呢？"></a>UE4是如何实现反射的呢？</h3><p>我们要想要让某一块代码块可以被反射，我们就必须在这个代码块中使用上面的宏，如：我们想要某个类可以被反射，那么就必须在类前添加宏<code>UCLASS()</code>，并且面的函数，成员变量，结构体前也必须添加相应的宏。当我们添加了宏后，UE4在编译时会调用中头文件<code>.generate.h</code>中相应宏定义有关反射的方法，并通过Unreal Build Tool(UBT)和Unreal Header Tool(UHT)两个工具生成一个<code>.generate.cpp</code>文件，<code>.generate.h</code>文件则是一个包含了反射数据的C++代码。如此UE4便可以通过<code>.generate.cpp</code>来获取元数据。</p>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>UE4的垃圾回收的使用有如下几种方式：</p>
<p><strong>继承自UObject类的类对象</strong></p>
<p>我们可以直接在成员变量前引入宏UPROPERTY()，这个宏不仅可以标记反射还可以为垃圾回收做标记。</p>
<p>我们也可以是使用TWeakObjectPtr指针，TWeakObjectPtr是一个弱指针，通常定义在类的内部用来操纵堆区中的对象。TWeakObjectPtr是一个泛型指针，使用时需要指定类型参数，如：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">TWeakObjectPtr&lt;ClassName&gt; tw<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p><strong>局部的UObject类对象</strong></p>
<p>有时我们可能在函数中定义一个局部的UObject对象，为了防止对象被UObject的回收机制回收，我们应当使用AddToRoot()来锁定对象，用完后使用RemoveFromRoot()来移除锁定。</p>
<p><strong>不继承自UObject和UStruct的结构体和类</strong></p>
<p>这种结构体我们使用TSharedPtr指针来引用堆区的对象，TSharedPtr也是一个泛型指针，使用时也需要指定类型参数。</p>
<p>如果我们想要使用引用而不是指针则使用TSharedRef，如：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">TSharedRef&lt;FMyCustom&gt; MyCustom <span class="hljs-operator">=</span> MakeShared&lt;FMyCustom&gt;()<span class="hljs-comment">; </span><br></code></pre></td></tr></table></figure>

<p>此时M有Custom就是<code>MakeShared&lt;FMyCustom&gt;()</code>返回对象的引用。</p>
<p>我们也可以使用TWeakPtr指针，TWeakPtr指针的效果和TWeakObjectPtr指针的效果是一致的，只是TweakPtr用于非UObject类对象。</p>
<p><strong>当一个不继承自UObject的结构体中出现了UObject对象时</strong></p>
<p>这种情况下，结构体可以正常访问，但是结构体里的UObject对象会由于UObject的回收机制，在过一段时间后被销毁，从而导致这个对象无法访问和出现野指针的情况，UE4则使用FGCObject类来解决这种情况，我们只需让这种情况下的结构体继承自FGCObject类积即可。</p>
<h1 id="十二、线程"><a href="#十二、线程" class="headerlink" title="十二、线程"></a>十二、线程</h1><p>由于不同的平台线程的调度有所差异，所以和UE4的其他模块一样，为了实现跨平台的特性，UE4为线程封装了<code>FRunnable</code>框架，并把线程封装进了<code>FRunnableThread</code>类，FRunnableThread类也提供一系列我们对线程的常规操作，所以我们要开启一个自己的线程就需要一个继承FRunnable类并重载相应的函数，然后通过FRunnableThread::Create在FRunnable的框架内完成线程的创建。</p>
<p>FRunnable和FRunnableThread的关系，这里盗用一张<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/38881269">Jerish</a>大佬的图来说明：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002336.jpg"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002336.jpg" alt="img"></a></p>
<h2 id="1-FRunnable和FRunnableThread"><a href="#1-FRunnable和FRunnableThread" class="headerlink" title="1.FRunnable和FRunnableThread"></a>1.FRunnable和FRunnableThread</h2><p>FRunnbale是不对编辑器暴露的，所以我们无法直接从编辑器创建一个继承自FRunnable的类，因为我们需要自己创建一个C++类然后手动继承FRunnable类。</p>
<p>FRunnable是一个抽象类，其中FRunnable::Run()函数是一个纯虚函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;HAL/Runnable.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UE4CPP_API</span> FMyRunnable : <span class="hljs-keyword">public</span> FRunnable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">FMyRunnable</span>(<span class="hljs-type">int</span> InCount);<br>	~<span class="hljs-built_in">FMyRunnable</span>();<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> uint32 <span class="hljs-title">Run</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Stop</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Exit</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Create</span><span class="hljs-params">(FString Name)</span></span>;<br><span class="hljs-keyword">public</span>:<br>	FRunnableThread* RunnableThread;<br>	<span class="hljs-type">int</span> Count;<br>	FString ThreadName;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这里要使用FRunnable需要包含<code>HAL/Runnable.h</code>头文件。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-meta">#include &quot;FMyRunnable.h&quot;</span><br>FMyRunnable::FMyRunnable(<span class="hljs-type">int</span> InCount):Count(InCount)<br>&#123;<br>&#125;<br>FMyRunnable::~FMyRunnable()<br>&#123;<br>&#125;<br><span class="hljs-type">bool</span> FMyRunnable::Init()<br>&#123;<br>    UE_LOG(LogTemp, <span class="hljs-keyword">Log</span>, TEXT(&quot;Thread %s inited successfully&quot;),*ThreadName);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br>uint32 FMyRunnable::Run()<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; Count; i++)<br>    &#123;<br>        UE_LOG(LogTemp, <span class="hljs-keyword">Log</span>, TEXT(&quot;i=%d&quot;),i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">void</span> FMyRunnable::Stop()<br>&#123;<br>    UE_LOG(LogTemp, <span class="hljs-keyword">Log</span>, TEXT(&quot;Stoped thread %s&quot;),*ThreadName);<br>&#125;<br><span class="hljs-type">void</span> FMyRunnable::<span class="hljs-keyword">Exit</span>()<br>&#123;<br>    UE_LOG(LogTemp, <span class="hljs-keyword">Log</span>, TEXT(&quot;Exit thread %s&quot;), *ThreadName);<br>&#125;<br><span class="hljs-type">bool</span> FMyRunnable::<span class="hljs-keyword">Create</span>(FString <span class="hljs-type">Name</span>)<br>&#123;<br>    ThreadName = <span class="hljs-type">Name</span>;<br>    RunnableThread = FRunnableThread::<span class="hljs-keyword">Create</span>(this, *<span class="hljs-type">Name</span>);<br>    <span class="hljs-keyword">if</span> (RunnableThread)<br>    &#123;<br>        UE_LOG(LogTemp, <span class="hljs-keyword">Log</span>, TEXT(&quot;Created a thread %s&quot;), *RunnableThread-&gt;GetThreadName());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        UE_LOG(LogTemp, <span class="hljs-keyword">Log</span>, TEXT(&quot;Failed to create a thread %s&quot;), *RunnableThread-&gt;GetThreadName());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后就可以在外部使用这个线程了。</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">void</span> <span class="hljs-variable">AContainerctor</span>::<span class="hljs-function"><span class="hljs-title">BeginPlay</span>()</span><br>&#123;<br>	<span class="hljs-variable">Super</span>::<span class="hljs-function"><span class="hljs-title">BeginPlay</span>();</span><br><span class="hljs-function">	<span class="hljs-variable">FMyRunnable</span>* <span class="hljs-variable">MyRunnable</span> = <span class="hljs-variable">new</span> <span class="hljs-title">FMyRunnable</span>(<span class="hljs-variable">Count</span>);</span><br><span class="hljs-function">	<span class="hljs-variable">MyRunnable</span>-&gt;<span class="hljs-title">Create</span>(<span class="hljs-title">TEXT</span>(<span class="hljs-string">&quot;MyFirstThread&quot;</span>));</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<p>我这里是直接把线程的操作FRunnableThread也一并封装到FMyRunnbale中了，以方便管理。如果不封装在一起就是这么使用的：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-literal">void</span> AContainerctor<span class="hljs-type">::BeginPlay</span>()<br>&#123;<br>	Super<span class="hljs-type">::BeginPlay</span>();<br>	FMyRunnable* MyRunnable = <span class="hljs-literal">new</span> FMyRunnable(Count);<br>	FRunnableThread* RunnableThread = FRunnableThread<span class="hljs-type">::Create</span>(MyRunnable,TEXT(<span class="hljs-string">&quot;MyFirstThread&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样的化就要管理两个对象，MyRunnable和RunnableThread。</p>
<ul>
<li>Init()：在线程被创建后自动调用，会初始化线程的一些数据，比如名字与ID，此时是不可以直接通过FRunnableThread对象去获取线程名字和ID的，否则会导致程序中断；</li>
<li>Run()：在线程初始化成功后自动调用，我们需要线程干的事情就写在这个函数里；</li>
<li>Stop()：主动结束线程；</li>
<li>Exit()：在Run()函数跑完之后自动调用，退出线程。</li>
</ul>
<p>FRunnable没有提供挂起线程的函数重写，如果需要挂起线程的操作，则需要我们主动调用<code>FRunnableThread::Suspend( bool bShouldPause = true )</code>函数，bShouldPause&#x3D;true表示挂起，bShouldPause&#x3D;false表示恢复。</p>
<p>这里在测试时碰到一个坑，即按照源码的说明Run函数是只在Init函数初始化成功之后才会调用，而事实情况则是Run函数与Init函数存在并行的情况，我在Run函数中调用线程挂起时，如果不做延迟处理会出现线程不可用的情况而导致程序中断，这说明Run函数运行初期，Init函数还未完成。</p>
<p><strong>正常情况：</strong></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss">uint32 FMyRunnable::<span class="hljs-built_in">Run</span>()<br>&#123;<br>    for (int i = <span class="hljs-number">0</span>; i &lt; Count; i++)<br>    &#123;<br>        <span class="hljs-built_in">UE_LOG</span>(LogTemp, Log, TEXT(&quot;i=%d&quot;),<span class="hljs-selector-tag">i</span>);<br>        FPlatformProcess::<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">1.0</span>f);<br>        if (i == <span class="hljs-number">5</span>)<br>        &#123;<br>            RunnableThread-&gt;<span class="hljs-built_in">Suspend</span>(true);<br>        &#125;<br>    &#125;<br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>中断情况：</strong></p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs excel">uint32 FMyRunnab<span class="hljs-symbol">le:</span><span class="hljs-symbol">:Ru</span><span class="hljs-built_in">n</span>()<br>&#123;<br>    for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">Count</span>; i++)<br>    &#123;<br>        UE_LOG(LogTemp, <span class="hljs-built_in">Log</span>, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;i=%d&quot;</span>),i);<br>        <span class="hljs-built_in">if</span> (i == <span class="hljs-number">5</span>)<br>        &#123;<br>            RunnableThread-&gt;Suspend(<span class="hljs-built_in">true</span>);<br>        &#125;<br>    &#125;<br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-FAsyncTask和FAutoDeleteAsyncTask"><a href="#2-FAsyncTask和FAutoDeleteAsyncTask" class="headerlink" title="2.FAsyncTask和FAutoDeleteAsyncTask"></a>2.FAsyncTask和FAutoDeleteAsyncTask</h2><p>FAsyncTask是UE使用FRunnable实现的，基于线程池的一套异步任务处理系统，经过封装的FAsyncTask在使用上就比FRunnable要方便得多了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Async/AsyncWork.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CoreMinimal.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UE4CPP_API</span> FMyAsyncTask : <span class="hljs-keyword">public</span> FNonAbandonableTask<br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">FMyAsyncTask</span>()&#123;&#125;;<br>	~<span class="hljs-built_in">FMyAsyncTask</span>()&#123;&#125;;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FAsyncTask</span>&lt;FMyAsyncTask&gt;;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoWork</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>    	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)<br>    	&#123;<br>        <span class="hljs-built_in">UE_LOG</span>(LogTemp, Log, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Doing work,i=%d&quot;</span>), i);<br>        FPlatformProcess::<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">1</span>);<br>    	&#125;<br>	&#125;<br>	<span class="hljs-function">FORCEINLINE TStatId <span class="hljs-title">GetStatId</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">	</span>&#123;<br>    	<span class="hljs-built_in">RETURN_QUICK_DECLARE_CYCLE_STAT</span>(FMyAsyncTask, STATGROUP_ThreadPoolAsyncTasks);<br>	&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这里声明的友元类<code>friend class FAsyncTask&lt;FMyAsyncTask&gt;</code>，目的就是让我们的自定义类可以访问FAsyncTask类的成员。</p>
<p><code>DoWork</code>和<code>TStatId</code>是两个必须实现的函数，DoWork负责任务要实现的逻辑，GetStatId是给UE底层使用的，用于统计任务用时，所以实现上基本是固定的。</p>
<p><code>FNonAbandonableTask</code>是一个空类，应该是UE为了实现多态而使用的，而要继承这个类则需要包含头文件<code>#include &quot;Async/AsyncWork.h&quot;</code>。</p>
<p>创建好类之后就可以使用了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//.h</span><br>FAsyncTask&lt;FMyAsyncTask&gt;* MyTask;<br><span class="hljs-comment">//...</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AContainerctor::CreateThread</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	MyTask = <span class="hljs-keyword">new</span> <span class="hljs-built_in">FAsyncTask</span>&lt;FMyAsyncTask&gt;();<br>	<span class="hljs-built_in">UE_LOG</span>(LogTemp, Log, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Created MyTask&quot;</span>));<br>	MyTask-&gt;<span class="hljs-built_in">StartBackgroundTask</span>();<br>    <span class="hljs-comment">//MyTask-&gt;EnsureCompletion();</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AContainerctor::Tick</span><span class="hljs-params">(<span class="hljs-type">float</span> DeltaTime)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (MyTask &amp;&amp; MyTask-&gt;<span class="hljs-built_in">IsDone</span>())<br>	&#123;<br>		<span class="hljs-keyword">delete</span> MyTask;<br>		MyTask = <span class="hljs-literal">nullptr</span>;<br>		<span class="hljs-built_in">UE_LOG</span>(LogTemp, Log, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Completed MyTask&quot;</span>));<br>	&#125;<br>	Super::<span class="hljs-built_in">Tick</span>(DeltaTime);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>需要注意的是我们自定的FMyAsyncTask类必须以<code>FAsyncTask&lt;FMyAsyncTask&gt;</code>类型来接收和创建，如上面的代码所示，否则我们的FMyAsyncTask类对象就不能访问FAsyncTask类的成员了。</p>
<p>还有一点因为FAsyncTask是需要手动销毁的，所以我们需要自行判断任务是否完成，UE提供了<code>FAsyncTask::EnsureCompletion</code>函数等待任务完成后再执行后续代码，但这会阻塞当前执行的线程，所以我上面使用了在Tick函数中判断的方式来销毁MyTask。</p>
<p>正式因为这样，UE又提供了<code>FAutoDeleteAsyncTask</code>类，FAutoDeleteAsyncTask提供任务完成后自动销毁的能力，DoWork函数退出后会自动调用析构函数析构对象。</p>
<p>实现上FAutoDeleteAsyncTask和FAsyncTask基本没什么区别，只是将友元类从FAsyncTask换成了FAutoDeleteAsyncTask。</p>
<p>FAsyncTask和FAutoDeleteAsyncTask有两种启动任务的方式即<code>StartSynchronousTask</code>和<code>StartBackgroundTask</code>，前者是在当前线程启动任务，这会导致当前线程阻塞，后者是将任务丢入UE预制的线程池，从线程池中获取线程执行任务。</p>
<h2 id="3-线程池"><a href="#3-线程池" class="headerlink" title="3.线程池"></a>3.线程池</h2><p>前面一节我们有提到过UE的预制线程池，这个线程池是在引擎与初始化时的<code>FEngineLoop::PreInit</code>函数中的<code>PreInitPreStartupScreen</code>函数创建的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs rust">int32 FEngineLoop::<span class="hljs-title function_ invoke__">PreInit</span>(<span class="hljs-keyword">const</span> TCHAR* CmdLine)<br>&#123;<br>	<span class="hljs-keyword">const</span> int32 rv1 = <span class="hljs-title function_ invoke__">PreInitPreStartupScreen</span>(CmdLine);<br>	<span class="hljs-keyword">if</span> (rv1 != <span class="hljs-number">0</span>)<br>	&#123;<br>		PreInitContext.<span class="hljs-title function_ invoke__">Cleanup</span>();<br>		<span class="hljs-keyword">return</span> rv1;<br>	&#125;<br><br>	<span class="hljs-keyword">const</span> int32 rv2 = <span class="hljs-title function_ invoke__">PreInitPostStartupScreen</span>(CmdLine);<br>	<span class="hljs-keyword">if</span> (rv2 != <span class="hljs-number">0</span>)<br>	&#123;<br>		PreInitContext.<span class="hljs-title function_ invoke__">Cleanup</span>();<br>		<span class="hljs-keyword">return</span> rv2;<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//FEngineLoop::PreInitPostStartupScreen</span><br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">if</span> (FPlatformProcess::<span class="hljs-title function_ invoke__">SupportsMultithreading</span>())<br>	&#123;<br>		&#123;<br>			<span class="hljs-title function_ invoke__">SCOPED_BOOT_TIMING</span>(<span class="hljs-string">&quot;GIOThreadPool-&gt;Create&quot;</span>);<br>			GIOThreadPool = FQueuedThreadPool::<span class="hljs-title function_ invoke__">Allocate</span>();<br>			int32 NumThreadsInThreadPool = FPlatformMisc::<span class="hljs-title function_ invoke__">NumberOfIOWorkerThreadsToSpawn</span>();<br>			<span class="hljs-keyword">if</span> (FPlatformProperties::<span class="hljs-title function_ invoke__">IsServerOnly</span>())<br>			&#123;<br>				NumThreadsInThreadPool = <span class="hljs-number">2</span>;<br>			&#125;<br>			<span class="hljs-title function_ invoke__">verify</span>(GIOThreadPool<span class="hljs-punctuation">-&gt;</span><span class="hljs-title function_ invoke__">Create</span>(NumThreadsInThreadPool, <span class="hljs-number">96</span> * <span class="hljs-number">1024</span>, TPri_AboveNormal, <span class="hljs-title function_ invoke__">TEXT</span>(<span class="hljs-string">&quot;IOThreadPool&quot;</span>)));<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<p>UE预制的线程是FQueuedThread类型的线程对象，FQueuedThread也是继承自FRunnable的子类，而FQueuedThread被存储在一个FQueuedThreadPool维护的队列里，说是队列其实在源码里就是一个FQueuedThread类型的TArray。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">FQueuedThreadPoolBase</span> : <span class="hljs-symbol">public</span> <span class="hljs-symbol">FQueuedThreadPool</span><br>&#123;<br><span class="hljs-keyword">protected</span>:<br>	<span class="hljs-comment">//...</span><br>	<span class="hljs-comment">/** The thread pool to dole work out to. */</span><br>	TArray&lt;FQueuedThread*&gt; QueuedThreads;<br>	<span class="hljs-comment">//...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>FQueuedThread里面会维护一个FEvent事件，用于任务的事件触发和线程控制。</p>
<p>预制的线程池被UE保存在一个GThreadPool指针中，和GEngine一样GThreadPool也是一个全局指针。</p>
<p>FAysncTask和FAutoDeleteAsyncTask的StartBackgroundTask函数默认情况下就是使用的线程池里的线程，当然我们也可以传自定义的线程进去，让任务使用自定义线程执行。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">//AsyncWork.h</span><br><span class="hljs-comment">/** </span><br><span class="hljs-comment">* Run this task on the lo priority thread pool. It is not safe to use this object after this call.</span><br><span class="hljs-comment">**/</span><br>void <span class="hljs-built_in">StartBackgroundTask</span>(FQueuedThreadPool* InQueuedPool = GThreadPool)<br>&#123;<br>	<span class="hljs-built_in">Start</span>(false, InQueuedPool);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="创建自定义线程池"><a href="#创建自定义线程池" class="headerlink" title="创建自定义线程池"></a>创建自定义线程池</h3><p>创建自定的线程池其实也比较简单，使用的方式就是和UE预制线程池是一样的。</p>
<p>首先我们需要创建自己的任务对象—一个实现了IQueuedWork的类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Misc/IQueuedWork.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UE4CPP_API</span> FMyWorker : <span class="hljs-keyword">public</span> IQueuedWork<br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">FMyWorker</span>(FString Name):<span class="hljs-built_in">WorkName</span>(Name)&#123;&#125;<br>	~<span class="hljs-built_in">FMyWorker</span>()&#123;&#125;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">DoThreadedWork</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>    	<span class="hljs-built_in">UE_LOG</span>(LogTemp, Log, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Doing work %s&quot;</span>), *WorkName);<br>    	FPlatformProcess::<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">1</span>);<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Abandon</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">        </span>&#123;<br>    	<span class="hljs-built_in">UE_LOG</span>(LogTemp, Log, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Abandoned work %s&quot;</span>), *WorkName);<br>    	<span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>	&#125;<br><span class="hljs-keyword">private</span>:<br>	FString WorkName;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这里有两个函数是必须重写的，<code>DoThreadedWork</code>和<code>Abandon</code>，DoThreadedWork会在任务对象加入线程池之后自动调用，用于处理自己的任务逻辑；Abandon则是放弃当前任务。</p>
<p>创建好了任务我们就可以创建线程池了：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs zephir">void AContainerctor::CreateThread()<br>&#123;<br>	FQueuedThreadPool* Pool = FQueuedThreadPool::Allocate();<br>	Pool-&gt;Create(<span class="hljs-number">5</span>, <span class="hljs-number">12</span> * <span class="hljs-number">1024</span>, TPri_Normal, TEXT(<span class="hljs-string">&quot;MyThreadPool&quot;</span>));<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)<br>	&#123;<br>		FString WorkName = TEXT(<span class="hljs-string">&quot;MyWork&quot;</span>) + FString::FromInt(i);<br>		Pool-&gt;AddQueuedWork(<span class="hljs-keyword">new</span> FMyWorker(WorkName));<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>FQueuedThreadPool::Allocate()</code>创建线程池对象，<code>Create</code>函数往线程池中加入线程，5为线程数量，12*1024为线程大小，TPri_Normal为线程类型，最后的字符串为线程名字。<code>AddQueuedWork</code>将任务对象加入线程池，任务即可开始执行。</p>
<h2 id="4-线程锁"><a href="#4-线程锁" class="headerlink" title="4.线程锁"></a>4.线程锁</h2><p>提到线程就一定逃避不了锁，为了保证线程安全锁是必要的，UE也提供了自己的一套锁机制，UE提供四种线程锁：</p>
<ul>
<li>FScopeLock：区域锁；</li>
<li>FCriticalSection：临界区；</li>
<li>FScopeRWLock：读写锁。</li>
<li>FSystemWideCriticalSection</li>
</ul>
<p>我们一个个来看。</p>
<h3 id="FScopeLock"><a href="#FScopeLock" class="headerlink" title="FScopeLock"></a>FScopeLock</h3><p>我们先来看看没有锁的情况以便和有锁的情况做对比。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UE4CPP_API</span> FMyRunnable : <span class="hljs-keyword">public</span> FRunnable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">FMyRunnable</span>(<span class="hljs-type">int</span> InCount);<br>	~<span class="hljs-built_in">FMyRunnable</span>();<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> uint32 <span class="hljs-title">Run</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Stop</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Exit</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Create</span><span class="hljs-params">(FString Name)</span></span>;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ChangeCount</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//供外部修改Count值</span><br><span class="hljs-keyword">public</span>:<br>	FRunnableThread* RunnableThread;<br>	<span class="hljs-type">int</span> Count;<span class="hljs-comment">//Count值在Run运行时不应该被修改</span><br>	FString ThreadName;<br>	FCriticalSection CountLock;<br>&#125;;<br><span class="hljs-function">uint32 <span class="hljs-title">FMyRunnable::Run</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; Count; i++)<br>    &#123;<br>        <span class="hljs-built_in">UE_LOG</span>(LogTemp, Log, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;i=%d&quot;</span>), i);<br>        FPlatformProcess::<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">0.001f</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FMyRunnable::ChangeCount</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Count += <span class="hljs-number">5</span>;<br>    <span class="hljs-built_in">UE_LOG</span>(LogTemp, Log, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Set Count=%d&quot;</span>), Count);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>线程外部：</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">void</span> <span class="hljs-variable">AContainerctor</span>::<span class="hljs-function"><span class="hljs-title">CreateThread</span>()</span><br>&#123;<br>	<span class="hljs-variable">MyRunnable</span> = <span class="hljs-variable">new</span> <span class="hljs-function"><span class="hljs-title">FMyRunnable</span>(<span class="hljs-number">1000</span>);</span><br><span class="hljs-function">	<span class="hljs-variable">MyRunnable</span>-&gt;<span class="hljs-title">Create</span>(<span class="hljs-title">TEXT</span>(<span class="hljs-string">&quot;MyRunnable&quot;</span>));</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-variable">void</span> <span class="hljs-variable">AContainerctor</span>::<span class="hljs-title">ChangeValue</span>()</span><br>&#123;<br>	<span class="hljs-variable">MyRunnable</span>-&gt;<span class="hljs-function"><span class="hljs-title">ChangeCount</span>();</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<p>然后在蓝图中通过按键触发CreateThread和ChangeCount函数，然后跑一下看看</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002351.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002351.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002354.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002354.png" alt="img"></a></p>
<p>可以看到在Run运行的过程中我们修改了Count的值到505，而线程结束时Count的值确实被修改了，这个结果明显不是我们先要的。</p>
<p>下面来使用锁对比效果。</p>
<p>FScopeLock和FCriticalSection是一起使用的，ScopeLock的使用方法有两种：</p>
<p><strong>方法一</strong></p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">//.h</span><br>FCriticalSection CountLock;<br><span class="hljs-comment">//.cpp</span><br><span class="hljs-keyword">void</span> FMyRunnable::Run()<br>&#123;<br>	&#123;<br>        FScopeLock ScopeLock(&amp;CountLock);<span class="hljs-comment">//对ScopeLock所在的作用域中的变量上锁</span><br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">Count</span>; i++)<br>    	&#123;<br>        	UE_LOG(LogTemp, <span class="hljs-built_in">Log</span>, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;i=%d&quot;</span>), i);<br>        	FPlatformProcess::Sleep(<span class="hljs-number">0.001</span>f);<br>    	&#125;<br>	&#125;<br>&#125;<br><span class="hljs-keyword">void</span> FMyRunnable::ChangeCount()<br>&#123;<br>    FScopeLock ScopeLock(&amp;CountLock);<br>    <span class="hljs-built_in">Count</span> += <span class="hljs-number">5</span>;<br>    UE_LOG(LogTemp, <span class="hljs-built_in">Log</span>, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Set Count=%d&quot;</span>), <span class="hljs-built_in">Count</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>需要注意的是这种方法需要在读和写的地方都要上锁，ScopeLock会把作用域中使用的外部变量都锁住，即使有的变量没有在写的时候上锁，我们把上面的例子改一下，上个锁再看一下。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002357.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002357.png" alt="img"></a></p>
<p>可以看到，Count的值是在线程退出之后才被设置到505</p>
<p><strong>方法二</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FMyRunnable::Run</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	FScopeLock* ScopeLock = <span class="hljs-keyword">new</span> <span class="hljs-built_in">FScopeLock</span>(&amp;CountLock);<span class="hljs-comment">//上锁</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; Count; i++)<br>    &#123;<br>        <span class="hljs-built_in">UE_LOG</span>(LogTemp, Log, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;i=%d&quot;</span>), i);<br>        FPlatformProcess::<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">0.001f</span>);<br>    &#125;<br>	<span class="hljs-keyword">delete</span> ScopeLock;<span class="hljs-comment">//解锁</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FMyRunnable::ChangeCount</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    FScopeLock* ScopeLock = <span class="hljs-keyword">new</span> <span class="hljs-built_in">FScopeLock</span>(&amp;CountLock);<span class="hljs-comment">//上锁</span><br>    Count += <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">delete</span> ScopeLock;<span class="hljs-comment">//解锁</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>和方法一一样，方法二也需要在读写的地方都要上锁。</p>
<p>在实际测试中发现ScopeLock似乎有一个bug，即当在ScopeLock的作用域中存在多个变量，有的需要上锁而有的不需要上锁时，会因为修改的时序导致结果有所差异，举个例子：</p>
<p>我们在上面的例子中在增加一个变量Num。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UE4CPP_API</span> FMyRunnable : <span class="hljs-keyword">public</span> FRunnable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">FMyRunnable</span>(<span class="hljs-type">int</span> InCount);<br>	~<span class="hljs-built_in">FMyRunnable</span>();<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> uint32 <span class="hljs-title">Run</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Stop</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Exit</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Create</span><span class="hljs-params">(FString Name)</span></span>;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ChangeCount</span><span class="hljs-params">()</span></span>;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ChangeNum</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">public</span>:<br>	FRunnableThread* RunnableThread;<br>	<span class="hljs-type">int</span> Count;<br>	<span class="hljs-type">int</span> Num = <span class="hljs-number">10</span>;<br>	FString ThreadName;<br>	FCriticalSection CountLock;<br>&#125;;<br><span class="hljs-function">uint32 <span class="hljs-title">FMyRunnable::Run</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    FScopeLock* ScopeLock = <span class="hljs-keyword">new</span> <span class="hljs-built_in">FScopeLock</span>(&amp;CountLock);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; Count; i++)<br>    &#123;<br>        <span class="hljs-built_in">UE_LOG</span>(LogTemp, Log, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;i=%d&quot;</span>), i);<br>        FPlatformProcess::<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">0.001f</span>);<br>    &#125;<br>    <span class="hljs-built_in">UE_LOG</span>(LogTemp, Log, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Num=%d&quot;</span>), Num);<br>    <span class="hljs-keyword">delete</span> ScopeLock;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FMyRunnable::ChangeCount</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    FScopeLock* ScopeLock = <span class="hljs-keyword">new</span> <span class="hljs-built_in">FScopeLock</span>(&amp;CountLock);<br>    Count += <span class="hljs-number">5</span>;<br>    <span class="hljs-built_in">UE_LOG</span>(LogTemp, Log, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Set Count=%d&quot;</span>), Count);<br>    <span class="hljs-keyword">delete</span> ScopeLock;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FMyRunnable::ChangeNum</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Num += <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">UE_LOG</span>(LogTemp, Log, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Set Num=%d&quot;</span>), Num);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果ChangeNum在ChangeCount之前调用那么在Run的运行期间，Num值会被修改，如果ChangeNum在ChangeCount之后调用，那么Num值会被锁住只能在线程结束后才会被修改。</p>
<p>还是一样我们来运行下看看。</p>
<p>情况一ChangeNum在ChangeCount之前运行：</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">void</span> <span class="hljs-variable">AContainerctor</span>::<span class="hljs-function"><span class="hljs-title">CreateThread</span>()</span><br>&#123;<br>	<span class="hljs-variable">MyRunnable</span> = <span class="hljs-variable">new</span> <span class="hljs-function"><span class="hljs-title">FMyRunnable</span>(<span class="hljs-variable">Count</span>);</span><br><span class="hljs-function">	<span class="hljs-variable">MyRunnable</span>-&gt;<span class="hljs-title">Create</span>(<span class="hljs-title">TEXT</span>(<span class="hljs-string">&quot;MyRunnable&quot;</span>));</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"><span class="hljs-variable">void</span> <span class="hljs-variable">AContainerctor</span>::<span class="hljs-title">ChangeValue</span>()</span><br>&#123;<br>    <span class="hljs-variable">MyRunnable</span>-&gt;<span class="hljs-function"><span class="hljs-title">ChangeNum</span>();</span><br><span class="hljs-function">	<span class="hljs-variable">MyRunnable</span>-&gt;<span class="hljs-title">ChangeCount</span>();</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002403.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002403.png" alt="img"></a></p>
<p>可以看到Num的值在线程结束前已经被修改了。</p>
<p>情况二ChangeNum在ChangeCount之后运行：</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">void</span> <span class="hljs-variable">AContainerctor</span>::<span class="hljs-function"><span class="hljs-title">CreateThread</span>()</span><br>&#123;<br>	<span class="hljs-variable">MyRunnable</span> = <span class="hljs-variable">new</span> <span class="hljs-function"><span class="hljs-title">FMyRunnable</span>(<span class="hljs-variable">Count</span>);</span><br><span class="hljs-function">	<span class="hljs-variable">MyRunnable</span>-&gt;<span class="hljs-title">Create</span>(<span class="hljs-title">TEXT</span>(<span class="hljs-string">&quot;MyRunnable&quot;</span>));</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"><span class="hljs-variable">void</span> <span class="hljs-variable">AContainerctor</span>::<span class="hljs-title">ChangeValue</span>()</span><br>&#123;<br>	<span class="hljs-variable">MyRunnable</span>-&gt;<span class="hljs-function"><span class="hljs-title">ChangeCount</span>();</span><br><span class="hljs-function">	<span class="hljs-variable">MyRunnable</span>-&gt;<span class="hljs-title">ChangeNum</span>();</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002408.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002408.png" alt="img"></a></p>
<p>可以看到Num值被锁住了，在线程结束之后才被设置到20。</p>
<h3 id="FCriticalSection"><a href="#FCriticalSection" class="headerlink" title="FCriticalSection"></a>FCriticalSection</h3><p>FCriticalSection除了配合FScopeLock使用，自己单独也可以当作锁来用，用法上和FScopeLock的方法二类似。</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arcade">FCriticalSection CountLock;<br><br>uint32 FMyRunnable::Run()<br>&#123;<br>    CountLock.Lock();<br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">Count</span>; i++)<br>    &#123;<br>        UE_LOG(LogTemp, <span class="hljs-built_in">Log</span>, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;i=%d&quot;</span>), i);<br>        FPlatformProcess::Sleep(<span class="hljs-number">0.001</span>f);<br>    &#125;<br>    CountLock.Unlock();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">void</span> FMyRunnable::ChangeCount()<br>&#123;<br>    CountLock.Lock();<br>    <span class="hljs-built_in">Count</span> += <span class="hljs-number">5</span>;<br>    UE_LOG(LogTemp, <span class="hljs-built_in">Log</span>, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Set Count=%d&quot;</span>), <span class="hljs-built_in">Count</span>);<br>    CountLock.Unlock();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>和FScopeLock一样，当锁的代码段出现了多个变量有的值需要保持不变而有的值需要改变时，FCriticalSection会出现和FScopeLock一样的问题。</p>
<h3 id="FScopeRWLock"><a href="#FScopeRWLock" class="headerlink" title="FScopeRWLock"></a>FScopeRWLock</h3><p>关于FScopeRWLock我在内外网几乎没有找到任何代码示例，官方文档的描述甚至只有短短的一句话，在内网中几乎找不到FScopeRWLock相关的关键字，只在一些博客里有看到FRWLock，而这个类我在引擎源码里搜索发现这只是一个类别名，写在各个平台相关的文件里，在源码里只找到了一个FScopeRWLock类，类也比较简单，具体怎么用只能等日后有时间再自己摸索了。</p>
<h3 id="FSystemWideCriticalSection"><a href="#FSystemWideCriticalSection" class="headerlink" title="FSystemWideCriticalSection"></a>FSystemWideCriticalSection</h3><p>FSystemWideCriticalSection和FCriticalSection的用法是一样的，他们的区别只在于FCriticalSection是用户模式下的临界区，线程进入临界区时不需要从用户态切换到内核态，所以效率上比FSystemWideCriticalSection高，但是也是由于没有进入内核态所以无法进行进程之间的同步，只能用于线程；FSystemWideCriticalSection则是基于内核对象Mutex实现的，线程进入临界区是会从用户态切换进入内核态，所以效率上不如FCriticalSection，但是可以进行线程进程的同步。</p>
<h2 id="5-TGraphTask"><a href="#5-TGraphTask" class="headerlink" title="5.TGraphTask"></a>5.TGraphTask</h2><p>TGraphTask是UE4基于多线程抽象出来的一个异步任务处理系统，一整个任务由一个个任务节点组成，个节点之间可以进行单向的依赖，用一张图来说明可能会更形象。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002413.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002413.png" alt="img"></a></p>
<p>我们以这个流程来做一个计算加速度的例子<code>(v2-v1)/t</code>来说明TaskGraph的用法。用任务1计算v1，任务2计算v2，用任务3来计算v2-v1，用任务4来计算加速度。</p>
<h3 id="创建自定义FGraphTask"><a href="#创建自定义FGraphTask" class="headerlink" title="创建自定义FGraphTask"></a>创建自定义FGraphTask</h3><p>和FRunnable一样，我们也需要创建一个C++类来实现自己的TGraphTask，这里我创建四个任务节点，FGraphTask1、FGraphTask2、FGraphTask3、FGraphTask4，和一个UObject—UDataObj用于在各个任务节点间传递数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;../Common/DataObj.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UE4CPP_API</span> FGraphTask1<br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">FGraphTask1</span>(FString Name,UDataObj* Obj) : <span class="hljs-built_in">TaskName</span>(Name),<span class="hljs-built_in">DataObj</span>(Obj) &#123;&#125;<br>	~<span class="hljs-built_in">FGraphTask1</span>() &#123;&#125;;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function">FORCEINLINE TStatId <span class="hljs-title">GetStatId</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-built_in">RETURN_QUICK_DECLARE_CYCLE_STAT</span>(FMyTaskGraph, STATGROUP_TaskGraphTasks);<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-type">static</span> ENamedThreads::Type <span class="hljs-title">GetDesiredThread</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> ENamedThreads::AnyThread;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-type">static</span> ESubsequentsMode::Type <span class="hljs-title">GetSubsequentsMode</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> ESubsequentsMode::TrackSubsequents;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoTask</span><span class="hljs-params">(ENamedThreads::Type CurrentThread, <span class="hljs-type">const</span> FGraphEventRef&amp; MyCompletionGraphEvent)</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-built_in">UE_LOG</span>(LogTemp, Log, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Doing %s&quot;</span>), *TaskName);<br>		FPlatformProcess::<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">3</span>);<br>		DataObj-&gt;V1 = <span class="hljs-number">15</span>;<br>		<span class="hljs-built_in">UE_LOG</span>(LogTemp, Log, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Done %s and setted V1=%f&quot;</span>), *TaskName,DataObj-&gt;V1);<br>	&#125;<br><span class="hljs-keyword">private</span>:<br>	FString TaskName;<br>	UDataObj* DataObj;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>剩下的三个任务节点实现方式都一样样，只是DoTask函数体有所区别。</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sqf">void FGraphTask2::DoTask(ENamedThreads::<span class="hljs-built_in">Type</span> CurrentThread, const FGraphEventRef&amp; MyCompletionGraphEvent)<br>	&#123;<br>		UE_LOG(LogTemp, <span class="hljs-built_in">Log</span>, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Doing %s&quot;</span>), *<span class="hljs-built_in">TaskName</span>);<br>		FPlatformProcess::<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">3</span>);<br>		DataObj-&gt;V2 = <span class="hljs-number">25</span>;<br>		UE_LOG(LogTemp, <span class="hljs-built_in">Log</span>, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Done %s and setted V2=%f&quot;</span>), *<span class="hljs-built_in">TaskName</span>, DataObj-&gt;V2);<br>	&#125;<br><span class="hljs-comment">//------------------------</span><br>void FGraphTask3::DoTask(ENamedThreads::<span class="hljs-built_in">Type</span> CurrentThread, const FGraphEventRef&amp; MyCompletionGraphEvent)<br>	&#123;<br>		UE_LOG(LogTemp, <span class="hljs-built_in">Log</span>, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Doing %s&quot;</span>), *<span class="hljs-built_in">TaskName</span>);<br>		FPlatformProcess::<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">3</span>);<br>		DataObj-&gt;Difference = DataObj-&gt;V2 - DataObj-&gt;V1;<br>		UE_LOG(LogTemp, <span class="hljs-built_in">Log</span>, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Done %s and setted Difference=%f&quot;</span>), *<span class="hljs-built_in">TaskName</span>, DataObj-&gt;Difference);<br>	&#125;<br><span class="hljs-comment">//------------------------</span><br>void FGraphTask4::DoTask(ENamedThreads::<span class="hljs-built_in">Type</span> CurrentThread, const FGraphEventRef&amp; MyCompletionGraphEvent)<br>	&#123;<br>		UE_LOG(LogTemp, <span class="hljs-built_in">Log</span>, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Doing %s&quot;</span>), *<span class="hljs-built_in">TaskName</span>);<br>		FPlatformProcess::<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">3</span>);<br>		DataObj-&gt;A = DataObj-&gt;Difference/DataObj-&gt;T;<br>		UE_LOG(LogTemp, <span class="hljs-built_in">Log</span>, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Done %s and setted A=%f&quot;</span>), *<span class="hljs-built_in">TaskName</span>, DataObj-&gt;A);<br>	&#125;<br></code></pre></td></tr></table></figure>

<p>其中<code>GetStatId</code>，<code>GetDesiredThread</code>，<code>GetSubsequentsMode</code>，<code>DoTask</code>这四个函数是必须要实现的。</p>
<ul>
<li>GetStatId用于统计任务用时；</li>
<li>GetDesiredThread函数用于告诉系统这个任务使用什么类型的线程执行，有4种类型可选，ENamedThreads::AnyThread，ENamedThreads::GameThread，ENamedThreads::RHIThread，ENamedThreads::AudioThread，一般我们都使用AnyThread表示使用UE4专门为TGraphTask系统预制的线程；</li>
<li>GetSubsequentsMode函数用于告诉系统当前任务完成后的后续执行模式，因为一个任务节点完成后可以接下一个任务节点，有两种模式ESubsequentsMode::TrackSubsequents后续有任务，ESubsequentsMode::FireAndForget后续无任务，我这里的例子中只有任务4没有后续任务。</li>
<li>DoTask函数用于处理自己的任务逻辑。</li>
</ul>
<p>UDataObj就只用来传递数据：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">UCLASS()<br><span class="hljs-keyword">class</span> <span class="hljs-symbol">UE4CPP_API</span> <span class="hljs-symbol">UDataObj</span> : <span class="hljs-symbol">public</span> <span class="hljs-symbol">UObject</span><br>&#123;<br>	GENERATED_BODY()<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">float</span> V1;<br>	<span class="hljs-built_in">float</span> V2;<br>	<span class="hljs-built_in">float</span> A;<br>	<span class="hljs-built_in">float</span> T = <span class="hljs-number">10</span>;<br>	<span class="hljs-built_in">float</span> Difference;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>然后创建任务节点并处理各个任务节点之间的依赖关系：</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sqf">void AContainerctor::<span class="hljs-built_in">CreateTask</span>()<br>&#123;<br>	FGraphEventRef Task1, Task2, Task3, Task4;<br>	UDataObj* DataObj = NewObject&lt;UDataObj&gt;();<br>	Task1 = TGraphTask&lt;FGraphTask1&gt;::<span class="hljs-built_in">CreateTask</span>().ConstructAndDispatchWhenReady(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Task1&quot;</span>), DataObj);<br>	Task2 = TGraphTask&lt;FGraphTask2&gt;::<span class="hljs-built_in">CreateTask</span>().ConstructAndDispatchWhenReady(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Task2&quot;</span>), DataObj);<br>	FGraphEventArray Prerequistites3;<br>	Prerequistites3.Add(Task1);<br>	Prerequistites3.Add(Task2);<br>	Task3 = TGraphTask&lt;FGraphTask3&gt;::<span class="hljs-built_in">CreateTask</span>(&amp;Prerequistites3).ConstructAndDispatchWhenReady(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Task3&quot;</span>), DataObj);<br>	FGraphEventArray Prerequistites4;<br>	Prerequistites4.Add(Task3);<br>	Task4 = TGraphTask&lt;FGraphTask4&gt;::<span class="hljs-built_in">CreateTask</span>(&amp;Prerequistites4).ConstructAndDispatchWhenReady(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Task4&quot;</span>), DataObj);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>CreateTask函数有两个参数<code>CreateTask(const FGraphEventArray* Prerequisites = NULL, ENamedThreads::Type CurrentThreadIfKnown = ENamedThreads::AnyThread)</code>，第一个参数传入这个任务要依赖的其他任务的数组，第二个参数指定这个任务跑在什么类型的线程里。</li>
<li>ConstructAndDispatchWhenReady函数在创建任务后会立刻执行任务里的DoTask函数，并且使用C++11的构造函数传参的特性，可以将参数传递给对应的类的构造函数中。</li>
<li>FGraphEventArray类是UE封装的专门用于装载依赖任务的数组。</li>
</ul>
<p>然后我们执行一下看看结果：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002420.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002420.png" alt="img"></a></p>
<h3 id="不使用自定义FGraphTask的TGraphTask任务"><a href="#不使用自定义FGraphTask的TGraphTask任务" class="headerlink" title="不使用自定义FGraphTask的TGraphTask任务"></a>不使用自定义FGraphTask的TGraphTask任务</h3><p>UE除了使用自定义的FGraphTask来执行任务外还提供一个使用Lambda表达式来执行任务的方式，我们直接先看一个例子，把上面的任务流程用新的方式在处理一遍：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-literal">void</span> AContainerctor::CreateTask()<br>&#123;<br>	FGraphEventRef Task1, Task2, Task3, Task4;<br>	Task1 = FFunctionGraphTask::CreateAndDispatchWhenReady<span class="hljs-function"><span class="hljs-params">([]()-&gt;<span class="hljs-literal">void</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">		UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Doing Task1&quot;</span>));</span></span><br><span class="hljs-params"><span class="hljs-function">		FPlatformProcess::Sleep(<span class="hljs-number">3</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">		&#125;)</span>;</span><br><span class="hljs-function">	<span class="hljs-title">Task2</span> = <span class="hljs-title">FFunctionGraphTask</span>::<span class="hljs-title">CreateAndDispatchWhenReady</span><span class="hljs-params">([]()-&gt;<span class="hljs-literal">void</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">		UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Doing Task2&quot;</span>));</span></span><br><span class="hljs-params"><span class="hljs-function">		FPlatformProcess::Sleep(<span class="hljs-number">3</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">		&#125;)</span>;</span><br><span class="hljs-function">	<span class="hljs-title">FGraphEventArray</span> <span class="hljs-title">Prerequistites3</span>;</span><br><span class="hljs-function">	<span class="hljs-title">Prerequistites3</span>.<span class="hljs-title">Add</span><span class="hljs-params">(Task1)</span>;</span><br><span class="hljs-function">	<span class="hljs-title">Prerequistites3</span>.<span class="hljs-title">Add</span><span class="hljs-params">(Task2)</span>;</span><br><span class="hljs-function">	<span class="hljs-title">Task3</span> = <span class="hljs-title">FFunctionGraphTask</span>::<span class="hljs-title">CreateAndDispatchWhenReady</span><span class="hljs-params">([]()-&gt;<span class="hljs-literal">void</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">		UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Doing Task3&quot;</span>));</span></span><br><span class="hljs-params"><span class="hljs-function">		FPlatformProcess::Sleep(<span class="hljs-number">3</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">		&#125;, TStatId&#123;&#125;, &amp; Prerequistites3)</span>;</span><br><span class="hljs-function">	<span class="hljs-title">FGraphEventArray</span> <span class="hljs-title">Prerequistites4</span>;</span><br><span class="hljs-function">	<span class="hljs-title">Prerequistites4</span>.<span class="hljs-title">Add</span><span class="hljs-params">(Task3)</span>;</span><br><span class="hljs-function">	<span class="hljs-title">Task3</span> = <span class="hljs-title">FFunctionGraphTask</span>::<span class="hljs-title">CreateAndDispatchWhenReady</span><span class="hljs-params">([]()-&gt;<span class="hljs-literal">void</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">		UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">&quot;Doing Task4&quot;</span>));</span></span><br><span class="hljs-params"><span class="hljs-function">		FPlatformProcess::Sleep(<span class="hljs-number">3</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">		&#125;, TStatId&#123;&#125;, &amp; Prerequistites4)</span>;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>DoTask的逻辑就写在了Lambda表达式里了；</li>
<li>按照源码的注释说明，CreateAndDispatchWhenReady接收的Lambda表达式必须是<code>void()</code> 或者 <code>void(ENamedThreads::Type, const FGraphEventRef&amp;)</code>类型的，所以不可以传外部参数进入Lambda表达式，所以这种方式创建的任务流只能处理一些不依赖外部数据的简单任务。</li>
</ul>
<h2 id="6-游戏线程"><a href="#6-游戏线程" class="headerlink" title="6.游戏线程"></a>6.游戏线程</h2><p>前面有提到UE中的一些预制线程，包括线程池中的线程，TGraphTask中的线程，还有GameThread、RenderThread、RHIThread、AudioThread等，这里面用的最多就是GameThread了，所以我们主要讨论一下GameThread。</p>
<p>GameThread顾名思义就是用于承载游戏逻辑的线程，UE在创建了GameThread后会把线程ID存储到GGameThreadId这个全局变量中。</p>
<p>有一些事情是只能在GameThread中做的，比如创建UObject，AActor，Widget等，所有的BeginPlay函数，Tick函数都跑在GameThread中，所有的蓝图函数也都跑在GameThread中。</p>
<h1 id="十三、模块"><a href="#十三、模块" class="headerlink" title="十三、模块"></a>十三、模块</h1><p>模块可以说是贯穿了整个引擎，整个UE引擎就是又一个个模块组合而成的，我们打开引擎源码的Source文件夹就可以看到如下文件夹：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002425.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002425.png" alt="img"></a></p>
<ul>
<li>Developer：存放跨平台工具以及一些引擎底层工具；</li>
<li>Editor：存放编辑器代码；</li>
<li>Programs：存放依赖于引擎的工具，如：UBT等；</li>
<li>Runtime：存放GamePlay相关的代码；</li>
<li>ThirdParty：存放第三方库和插件。</li>
</ul>
<h2 id="1-模块的描述"><a href="#1-模块的描述" class="headerlink" title="1.模块的描述"></a>1.模块的描述</h2><p>一个模块可以只由一个模块组成，也可也由多个模块组成，我们使用UE创建一个新项目的时候，这整个项目就是一个独立的模块，UE会默认为我们添加一些基础模块的引用，操作代码在.biuld.cs中，模块与模块之间可以互相引用，但是不可以出现循环引用。</p>
<p>模块的描述在.uproject文件中，如：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<br>	<span class="hljs-string">&quot;FileVersion&quot;</span>: <span class="hljs-number">3</span>,<br>	<span class="hljs-string">&quot;EngineAssociation&quot;</span>: <span class="hljs-string">&quot;4.27&quot;</span>,<br>	<span class="hljs-string">&quot;Category&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>	<span class="hljs-string">&quot;Description&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>	<span class="hljs-string">&quot;Modules&quot;</span>: [<br>		&#123;<br>			<span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;UE4Cpp&quot;</span>,<br>			<span class="hljs-string">&quot;Type&quot;</span>: <span class="hljs-string">&quot;Runtime&quot;</span>,<br>			<span class="hljs-string">&quot;LoadingPhase&quot;</span>: <span class="hljs-string">&quot;Default&quot;</span>,<br>			<span class="hljs-string">&quot;AdditionalDependencies&quot;</span>: [<br>				<span class="hljs-string">&quot;Engine&quot;</span>,<br>				<span class="hljs-string">&quot;CoreUObject&quot;</span><br>			]<br>		&#125;<br>	]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这是一个Json格式的文件，我们主要关注Modules数组里面的元素，一个元素就是一个模块，由于我的项目没有添加其他模块，所以只有一个元素。</p>
<ul>
<li><p>Name：模块名；</p>
</li>
<li><p>Type：加载模块的场景，是一个EHostType::Type类型，在ModuleDescriptor.h中，主要有以下类型：</p>
<p>Runtime：除了独立程序以外都加载；</p>
<p>RuntimeNoCommandlet：除了独立程序和运行命令行模式的编辑器模式以外都加载；</p>
<p>RuntimeAndProgram：任何情况下都加载；</p>
<p>CookedOnly：只有被烘焙过的程序才加载；</p>
<p>Developer：只有在Development运行模式下才加载；这个Development是游戏和编辑器的一种运行模式，除了Development还有GameDebug，打包的时候还有Shipping，编辑器的运行模式我们可以在VS编译的时候选择：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002429.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002429.png" alt="img"></a></p>
</li>
</ul>
<p>Editor：只在编辑器启动的时候加载；</p>
<p>EditorNoCommandlet：只在编辑器启动的时候加载，但不包括使用命令行启动的编辑器；</p>
<p>Program：只在独立程序中加载；</p>
<p>ServerOnly：除了专用客户端，其他情况都加载；</p>
<p>ClientOnly：除了专用服务器，其他情况都加载；</p>
<ul>
<li><p>LoadingPhase：标注模块应该被加载的时机，是一个ELoadingPhase::Type的类型，也在在ModuleDescriptor.h中，主要有如下类型：</p>
<p>EarliestPossible：尽早的被加载，一般用于Pak文件中有模块的情况，可以是模块从Pak文件中加载；</p>
<p>PostConfigInit：在引擎被完全初始化之前，在配置文件系统被初始化之后加载，一般用于拦截底层消息是使用；</p>
<p>PreEarlyLoadingScreen：在加载CoreUObject之前加载，可以设置手动加载屏幕，一般用于程序补丁；</p>
<p>PreLoadingScreen：在引擎完全初始化之前加载，一般用于需要触发之前挂接到加载屏幕的模块；</p>
<p>PreDefault：在默认阶段之前加载；</p>
<p>Default：在引擎初始化之前，在游戏 模块被加载之后加载，创建项目是引擎给的默认值，也是我们用的最多的加载时机。</p>
<p>PostDefault：在默认阶段之后加载；</p>
<p>PostEngineInit：在引擎被初始化之后加载；</p>
<p>None：不自动加载模块，引擎不会自动加载模块，需要我们自己手动的在程序里加载模块。</p>
</li>
<li><p>AdditionalDependencies：描述用于构建此模块的其他依赖项的列表。</p>
</li>
</ul>
<h2 id="2-创建自定义模块"><a href="#2-创建自定义模块" class="headerlink" title="2.创建自定义模块"></a>2.创建自定义模块</h2><p>创建自定义模块需要三个基础文件，并且需要单独的放在项目Source目录下的一个文件夹下。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002434.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002434.png" alt="img"></a></p>
<p>这三个基础文件引擎不会自动为我们生成，我们需要手动添加进去，并且需要手动实现里面的内容。</p>
<p><strong>.h</strong></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CoreMinimal.h&quot;</span></span><br></code></pre></td></tr></table></figure>

<p><strong>.cpp</strong></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;MyModule.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Modules/ModuleManager.h&quot;</span></span><br><br><span class="hljs-built_in">IMPLEMENT_PRIMARY_GAME_MODULE</span>(FDefaultGameModuleImpl, MyModule, <span class="hljs-string">&quot;MyModule&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>这是最简单的.h和.cpp文件。</p>
<p><strong>.Build.cs</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">using</span> <span class="hljs-title class_">UnrealBuildTool</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-title class_">System</span>.<span class="hljs-property">Collections</span>.<span class="hljs-property">Generic</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyModule</span> : <span class="hljs-title class_">ModuleRules</span><br>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title class_">MyModule</span>(<span class="hljs-title class_">ReadOnlyTargetRules</span> <span class="hljs-title class_">Target</span>) : <span class="hljs-title function_">base</span>(<span class="hljs-params"><span class="hljs-title class_">Target</span></span>)<br>	&#123;<br>		<span class="hljs-title class_">PCHUsage</span> = <span class="hljs-title class_">PCHUsageMode</span>.<span class="hljs-property">UseExplicitOrSharedPCHs</span>;<br>		<span class="hljs-title class_">PublicDependencyModuleNames</span>.<span class="hljs-title class_">AddRange</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123; <span class="hljs-string">&quot;Core&quot;</span>, <span class="hljs-string">&quot;CoreUObject&quot;</span>, <span class="hljs-string">&quot;Engine&quot;</span>, <span class="hljs-string">&quot;InputCore&quot;</span> &#125;);<br>		<span class="hljs-title class_">PrivateDependencyModuleNames</span>.<span class="hljs-title class_">AddRange</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123; &#125;);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后右键.uproject文件，重新Generate Visual Studio project file，这样VS就可以识别到我们新添加的文件夹和文件了。</p>
<p>到这一步我们的空的自定义模块就创建完成了。</p>
<h2 id="3-加载自定义模块"><a href="#3-加载自定义模块" class="headerlink" title="3.加载自定义模块"></a>3.加载自定义模块</h2><h3 id="引擎自动加载"><a href="#引擎自动加载" class="headerlink" title="引擎自动加载"></a>引擎自动加载</h3><p>修改项目的XX.Target.cs、XXEditor.Target.cs和.uproject文件，将我们新建的模块添加到项目中。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//XX.Target.cs</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UE4CppTarget</span> : <span class="hljs-title class_">TargetRules</span><br>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title class_">UE4CppTarget</span>(<span class="hljs-title class_">TargetInfo</span> <span class="hljs-title class_">Target</span>) : <span class="hljs-title function_">base</span>(<span class="hljs-params"><span class="hljs-title class_">Target</span></span>)<br>	&#123;<br>		<span class="hljs-title class_">Type</span> = <span class="hljs-title class_">TargetType</span>.<span class="hljs-property">Game</span>;<br>		<span class="hljs-title class_">DefaultBuildSettings</span> = <span class="hljs-title class_">BuildSettingsVersion</span>.<span class="hljs-property">V2</span>;<br><br>		<span class="hljs-title class_">ExtraModuleNames</span>.<span class="hljs-title class_">AddRange</span>( <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123; <span class="hljs-string">&quot;UE4Cpp&quot;</span>, <span class="hljs-string">&quot;MyModule&quot;</span> &#125; );<br>	&#125;<br>&#125;<br><span class="hljs-comment">//XXEditor.Target.cs</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UE4CppEditorTarget</span> : <span class="hljs-title class_">TargetRules</span><br>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title class_">UE4CppEditorTarget</span>(<span class="hljs-title class_">TargetInfo</span> <span class="hljs-title class_">Target</span>) : <span class="hljs-title function_">base</span>(<span class="hljs-params"><span class="hljs-title class_">Target</span></span>)<br>	&#123;<br>		<span class="hljs-title class_">Type</span> = <span class="hljs-title class_">TargetType</span>.<span class="hljs-property">Editor</span>;<br>		<span class="hljs-title class_">DefaultBuildSettings</span> = <span class="hljs-title class_">BuildSettingsVersion</span>.<span class="hljs-property">V2</span>;<br><br>		<span class="hljs-title class_">ExtraModuleNames</span>.<span class="hljs-title class_">AddRange</span>( <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123; <span class="hljs-string">&quot;UE4Cpp&quot;</span>,<span class="hljs-string">&quot;MyModule&quot;</span>&#125; );<br>	&#125;<br>&#125;<br><span class="hljs-comment">//.uproject</span><br>&#123;<br>	<span class="hljs-string">&quot;FileVersion&quot;</span>: <span class="hljs-number">3</span>,<br>	<span class="hljs-string">&quot;EngineAssociation&quot;</span>: <span class="hljs-string">&quot;4.27&quot;</span>,<br>	<span class="hljs-string">&quot;Category&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>	<span class="hljs-string">&quot;Description&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>	<span class="hljs-string">&quot;Modules&quot;</span>: [<br>		&#123;<br>			<span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;UE4Cpp&quot;</span>,<br>			<span class="hljs-string">&quot;Type&quot;</span>: <span class="hljs-string">&quot;Runtime&quot;</span>,<br>			<span class="hljs-string">&quot;LoadingPhase&quot;</span>: <span class="hljs-string">&quot;Default&quot;</span>,<br>			<span class="hljs-string">&quot;AdditionalDependencies&quot;</span>: [<br>				<span class="hljs-string">&quot;Engine&quot;</span>,<br>				<span class="hljs-string">&quot;CoreUObject&quot;</span><br>			]<br>		&#125;,<br>		&#123;<br>			<span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;MyModule&quot;</span>,<br>			<span class="hljs-string">&quot;Type&quot;</span>: <span class="hljs-string">&quot;Runtime&quot;</span>,<br>			<span class="hljs-string">&quot;LoadingPhase&quot;</span>: <span class="hljs-string">&quot;Default&quot;</span>,<br>			<span class="hljs-string">&quot;AdditionalDependencies&quot;</span>: [<br>				<span class="hljs-string">&quot;Engine&quot;</span>,<br>				<span class="hljs-string">&quot;CoreUObject&quot;</span><br>			]<br>		&#125;<br>	]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后我们重新编译下项目，模块就会按照.uproject中的配置进行加载。</p>
<p>如何查看引擎有没有识别到模块呢？</p>
<p>打开引擎新建C++类的界面，如果下拉列表中出现了我们的自定义模块名称，就说明自定义模块被引擎识别了。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002440.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002440.png" alt="img"></a></p>
<p>注意我这里用的是识别而不是加载，因为引擎识别到模块和引擎加载模块是两个不同的概念，引擎识别到模块，我就可以在引擎中往模块里添加新的类，但此时模块不一定已经加载了；而引擎加载模块即引擎识别到了模块并将模块初始化完成了。</p>
<p>那么如何查看模块有没有被引擎自动加载了呢？</p>
<p>这里我们就需要在模块的.h文件中实现一个<code>IModuleInterface</code>接口了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Modules/ModuleManager.h&quot;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FMyModule</span> : <span class="hljs-keyword">public</span> IModuleInterface<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">StartupModule</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShutdownModule</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br><span class="hljs-comment">//.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;MyModule.h&quot;</span></span><br><span class="hljs-built_in">IMPLEMENT_PRIMARY_GAME_MODULE</span>(FMyModule, MyModule, <span class="hljs-string">&quot;MyModule&quot;</span>);<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FMyModule::StartupModule</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">UE_LOG</span>(LogTemp, Error, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Loaded MyModule&quot;</span>));<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FMyModule::ShutdownModule</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>IModuleInterface在ModuleManager.h中，IModuleInterface提供如下接口：</p>
<ul>
<li>StartupModule：在模块被加载后调用；</li>
<li>ShutdownModule：在模块被卸载之前调用；</li>
<li>PreUnloadCallback：在模块被卸载之前调用，调用时机在ShutdownModule之前；</li>
<li>PostLoadCallback：在模块被重新加载后调用；</li>
<li>SupportsDynamicReloading：设置模块是否允许动态卸载，默认为允许；</li>
<li>SupportsAutomaticShutdown：设置模块是否允许在程序关闭时自动卸载清理，默认为允许；</li>
<li>IsGameModule：表示模块是否属于GamePlay，默认为false，如果模块要实现游戏逻辑，那么需要重写这个函数放回true；</li>
</ul>
<p>同时IMPLEMENT_PRIMARY_GAME_MODULE宏就不能使用默认的<code>FDefaultGameModuleImpl</code>类了，需要使用自己实现的<code>FMyModule</code>类了，FDefaultGameModuleImpl类是一个UE预制的继承自IModuleInterface的空类，IModuleInterface接口就是模块暴露给外部使用的指针，外部要获取模块的引用可以通过FModuleManager.Get().GetModule或者在动态加载时直接保存引用。</p>
<p>实现了上面的操作后，在模块加载时即可在日志文件中找到对应的日志打印了。</p>
<h3 id="代码手动加载"><a href="#代码手动加载" class="headerlink" title="代码手动加载"></a>代码手动加载</h3><p>前有提到模块可以被引擎自动加载，也可以通过代码手动加载，UE提供一下四种方式来动态加载模块：</p>
<ul>
<li>FModuleManager::Get().LoadModule：加载指定模块，返回操作模块的IModuleInterface指针；</li>
<li>FModuleManager::Get().LoadModuleChecked：加载指定模块，在加载前会检查模块是否可用，返回操作模块的IModuleInterface指针；</li>
<li>FModuleManager::Get().LoadModuleWithCallback：加载指定模块，可以使用FOutputDevice接收加载失败的错误信息，如果加载成功则会调用模块的PostLoadCallback函数；</li>
<li>FModuleManager::Get().LoadModuleWithFailureReason：加载指定模块，并且可以使用EModuleLoadResult对象接收加载信息。</li>
</ul>
<h2 id="4-引用模块的资源"><a href="#4-引用模块的资源" class="headerlink" title="4.引用模块的资源"></a>4.引用模块的资源</h2><p>前面有提到一个模块可以引用另一个模块里的资源，其实引用的方式也比较简单，对于模块资源的引用是无论模块有没有加载都是可以引用的，加载不过是为模块做一些初始化操作。</p>
<p>这里我在主模块中引用自定义模块的类资源。</p>
<p>往前面定义的MyModule模块中添加一个AMyModuleActor类，然后在主模块UE4Cpp中引用这个类的头文件并实力化Actor。</p>
<p>首先需要通过.Build.cs添加MyModule模块的引用：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">PublicDependencyModuleNames.AddRange(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123; <span class="hljs-string">&quot;Core&quot;</span>, <span class="hljs-string">&quot;CoreUObject&quot;</span>, <span class="hljs-string">&quot;Engine&quot;</span>, <span class="hljs-string">&quot;InputCore&quot;</span>,<span class="hljs-string">&quot;MyModule&quot;</span>&#125;);<br></code></pre></td></tr></table></figure>

<p>然后就可以在想要引用资源的地方添加头文件使用类资源了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;../MyModule/MyModuleActor.h&quot;</span></span><br><span class="hljs-comment">//...</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AContainerctor::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Super::<span class="hljs-built_in">BeginPlay</span>();<br>	AMyModuleActor* Actor = GWorld-&gt;<span class="hljs-built_in">SpawnActor</span>&lt;AMyModuleActor&gt;();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行下看看结果：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002447.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002447.png" alt="img"></a></p>
<p>可以看到AMyModuleActor已经被实例化出来了。</p>
<h2 id="5-模块的构建"><a href="#5-模块的构建" class="headerlink" title="5.模块的构建"></a>5.模块的构建</h2><p>在模块的构建过程中有下面三个宏是需要注意的：</p>
<ul>
<li>IMPLEMENT_MODULE(FModuleClass, ModuleName)：一般没有什么特殊的模块都使用这个宏；</li>
<li>IMPLEMENT_GAME_MODULE(FModuleClass, ModuleName)：如果模块有包含游戏逻辑，那么就使用这个宏，看了源码这个宏就是对IMPLEMENT_MODULE宏的调用，二者没有任何区别，应该是UE预留的宏；</li>
<li>IMPLEMENT_PRIMARY_GAME_MODULE(FModuleClass, ModuleName,”GameName”)：如果模块是项目的主模块就是用这个宏，一个项目中必须要至少有一个主模块。</li>
</ul>
<p>这三个宏做的事情就是向外部提供模块的IModuleInterface接口，并将模块构成静态库或者动态库，默认情况下都构建成动态库，存放在Binaries目录对应平台名目录下。</p>
<h2 id="6-模块打包的问题"><a href="#6-模块打包的问题" class="headerlink" title="6.模块打包的问题"></a>6.模块打包的问题</h2><p>由于要验证第五小节模块的构建，所以需要将引用了自定义模块的项目打包，但是打包的出现了很严重的问题，即引用了自定义模块资源的项目打包始终无法通过，无论使用原有的项目还是新建项目，无论是使用原有的模块还是新建新的模块，只要主项目使用了模块的资源，打包的时候都会报错：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-params">UATHelper:</span> Packaging (Windows (<span class="hljs-number">6</span>4-bit)):     AModule.cpp.<span class="hljs-params">obj :</span> error <span class="hljs-params">LNK2005:</span> <span class="hljs-string">&quot;wchar_t const * const GLiveCodingEngineDir&quot;</span> (<span class="hljs-operator">?</span>GLiveCodingEngineDir@@<span class="hljs-number">3</span>PEB_WEB) �Ѿ��� ModulePackage.cpp.obj �ж���<br><span class="hljs-params">UATHelper:</span> Packaging (Windows (<span class="hljs-number">6</span>4-bit)):     AModule.cpp.<span class="hljs-params">obj :</span> error <span class="hljs-params">LNK2005:</span> <span class="hljs-string">&quot;wchar_t const * const GLiveCodingProject&quot;</span> (<span class="hljs-operator">?</span>GLiveCodingProject@@<span class="hljs-number">3</span>PEB_WEB) �Ѿ��� ModulePackage.cpp.obj �ж���<br><span class="hljs-params">UATHelper:</span> Packaging (Windows (<span class="hljs-number">6</span>4-bit)):     AModule.cpp.<span class="hljs-params">obj :</span> error <span class="hljs-params">LNK2005:</span> <span class="hljs-string">&quot;class FChunkedFixedUObjectArray * &amp; GObjectArrayForDebugVisualizers&quot;</span> (<span class="hljs-operator">?</span>GObjectArrayForDebugVisualizers@@<span class="hljs-number">3</span>AEAPEAVFChunkedFixedUObjectArray@@EA) �Ѿ��� ModulePackage.cpp.obj �ж���<br><span class="hljs-params">UATHelper:</span> Packaging (Windows (<span class="hljs-number">6</span>4-bit)):     AModule.cpp.<span class="hljs-params">obj :</span> error <span class="hljs-params">LNK2005:</span> <span class="hljs-string">&quot;wchar_t * GInternalProjectName&quot;</span> (<span class="hljs-operator">?</span>GInternalProjectName@@<span class="hljs-number">3</span>PA_WA) �Ѿ��� ModulePackage.cpp.obj �ж���<br><span class="hljs-params">UATHelper:</span> Packaging (Windows (<span class="hljs-number">6</span>4-bit)):     AModule.cpp.<span class="hljs-params">obj :</span> error <span class="hljs-params">LNK2005:</span> <span class="hljs-string">&quot;wchar_t const * const GForeignEngineDir&quot;</span> (<span class="hljs-operator">?</span>GForeignEngineDir@@<span class="hljs-number">3</span>PEB_WEB) �Ѿ��� ModulePackage.cpp.obj �ж���<br><span class="hljs-params">UATHelper:</span> Packaging (Windows (<span class="hljs-number">6</span>4-bit)):     AModule.cpp.<span class="hljs-params">obj :</span> error <span class="hljs-params">LNK2005:</span> <span class="hljs-string">&quot;void * __cdecl operator new(unsigned __int64)&quot;</span> (<span class="hljs-operator">?</span><span class="hljs-operator">?</span><span class="hljs-number">2</span>@YAPEAX_K@Z) �Ѿ��� ModulePackage.cpp.obj �ж���<br><span class="hljs-params">UATHelper:</span> Packaging (Windows (<span class="hljs-number">6</span>4-bit)):     AModule.cpp.<span class="hljs-params">obj :</span> error <span class="hljs-params">LNK2005:</span> <span class="hljs-string">&quot;void * __cdecl operator new(unsigned __int64,struct std::nothrow_t const &amp;)&quot;</span> (<span class="hljs-operator">?</span><span class="hljs-operator">?</span><span class="hljs-number">2</span>@YAPEAX_KAEBUnothrow_t@std@@@Z) �Ѿ��� ModulePackage.cpp.obj �ж���<br><span class="hljs-params">UATHelper:</span> Packaging (Windows (<span class="hljs-number">6</span>4-bit)):     AModule.cpp.<span class="hljs-params">obj :</span> error <span class="hljs-params">LNK2005:</span> <span class="hljs-string">&quot;void __cdecl operator delete(void *)&quot;</span> (<span class="hljs-operator">?</span><span class="hljs-operator">?</span><span class="hljs-number">3</span>@YAXPEAX@Z) �Ѿ��� ModulePackage.cpp.obj �ж���<br><span class="hljs-params">UATHelper:</span> Packaging (Windows (<span class="hljs-number">6</span>4-bit)):     AModule.cpp.<span class="hljs-params">obj :</span> error <span class="hljs-params">LNK2005:</span> <span class="hljs-string">&quot;void __cdecl operator delete(void *,struct std::nothrow_t const &amp;)&quot;</span> (<span class="hljs-operator">?</span><span class="hljs-operator">?</span><span class="hljs-number">3</span>@YAXPEAXAEBUnothrow_t@std@@@Z) �Ѿ��� ModulePackage.cpp.obj �ж���<br><span class="hljs-params">UATHelper:</span> Packaging (Windows (<span class="hljs-number">6</span>4-bit)):     AModule.cpp.<span class="hljs-params">obj :</span> error <span class="hljs-params">LNK2005:</span> <span class="hljs-string">&quot;void __cdecl operator delete(void *,unsigned __int64)&quot;</span> (<span class="hljs-operator">?</span><span class="hljs-operator">?</span><span class="hljs-number">3</span>@YAXPEAX_K@Z) �Ѿ��� ModulePackage.cpp.obj �ж���<br><span class="hljs-params">UATHelper:</span> Packaging (Windows (<span class="hljs-number">6</span>4-bit)):     AModule.cpp.<span class="hljs-params">obj :</span> error <span class="hljs-params">LNK2005:</span> <span class="hljs-string">&quot;void __cdecl operator delete(void *,unsigned __int64,struct std::nothrow_t const &amp;)&quot;</span> (<span class="hljs-operator">?</span><span class="hljs-operator">?</span><span class="hljs-number">3</span>@YAXPEAX_KAEBUnothrow_t@std@@@Z) �Ѿ��� ModulePackage.cpp.obj �ж���<br><span class="hljs-params">UATHelper:</span> Packaging (Windows (<span class="hljs-number">6</span>4-bit)):     AModule.cpp.<span class="hljs-params">obj :</span> error <span class="hljs-params">LNK2005:</span> <span class="hljs-string">&quot;void * __cdecl operator new[](unsigned __int64)&quot;</span> (<span class="hljs-operator">?</span><span class="hljs-operator">?</span>_U@YAPEAX_K@Z) �Ѿ��� ModulePackage.cpp.obj �ж���<br><span class="hljs-params">UATHelper:</span> Packaging (Windows (<span class="hljs-number">6</span>4-bit)):     AModule.cpp.<span class="hljs-params">obj :</span> error <span class="hljs-params">LNK2005:</span> <span class="hljs-string">&quot;void * __cdecl operator new[](unsigned __int64,struct std::nothrow_t const &amp;)&quot;</span> (<span class="hljs-operator">?</span><span class="hljs-operator">?</span>_U@YAPEAX_KAEBUnothrow_t@std@@@Z) �Ѿ��� ModulePackage.cpp.obj �ж���<br><span class="hljs-params">UATHelper:</span> Packaging (Windows (<span class="hljs-number">6</span>4-bit)):     AModule.cpp.<span class="hljs-params">obj :</span> error <span class="hljs-params">LNK2005:</span> <span class="hljs-string">&quot;void __cdecl operator delete[](void *)&quot;</span> (<span class="hljs-operator">?</span><span class="hljs-operator">?</span>_V@YAXPEAX@Z) �Ѿ��� ModulePackage.cpp.obj �ж���<br><span class="hljs-params">UATHelper:</span> Packaging (Windows (<span class="hljs-number">6</span>4-bit)):     AModule.cpp.<span class="hljs-params">obj :</span> error <span class="hljs-params">LNK2005:</span> <span class="hljs-string">&quot;void __cdecl operator delete[](void *,struct std::nothrow_t const &amp;)&quot;</span> (<span class="hljs-operator">?</span><span class="hljs-operator">?</span>_V@YAXPEAXAEBUnothrow_t@std@@@Z) �Ѿ��� ModulePackage.cpp.obj �ж���<br><span class="hljs-params">UATHelper:</span> Packaging (Windows (<span class="hljs-number">6</span>4-bit)):     AModule.cpp.<span class="hljs-params">obj :</span> error <span class="hljs-params">LNK2005:</span> <span class="hljs-string">&quot;void __cdecl operator delete[](void *,unsigned __int64)&quot;</span> (<span class="hljs-operator">?</span><span class="hljs-operator">?</span>_V@YAXPEAX_K@Z) �Ѿ��� ModulePackage.cpp.obj �ж���<br><span class="hljs-params">UATHelper:</span> Packaging (Windows (<span class="hljs-number">6</span>4-bit)):     AModule.cpp.<span class="hljs-params">obj :</span> error <span class="hljs-params">LNK2005:</span> <span class="hljs-string">&quot;void __cdecl operator delete[](void *,unsigned __int64,struct std::nothrow_t const &amp;)&quot;</span> (<span class="hljs-operator">?</span><span class="hljs-operator">?</span>_V@YAXPEAX_KAEBUnothrow_t@std@@@Z) �Ѿ��� ModulePackage.cpp.obj �ж���<br><span class="hljs-params">UATHelper:</span> Packaging (Windows (<span class="hljs-number">6</span>4-bit)):     AModule.cpp.<span class="hljs-params">obj :</span> error <span class="hljs-params">LNK2005:</span> <span class="hljs-string">&quot;struct FTargetNameRegistration GTargetNameRegistration&quot;</span> (<span class="hljs-operator">?</span>GTargetNameRegistration@@<span class="hljs-number">3</span>UFTargetNameRegistration@@A) �Ѿ��� ModulePackage.cpp.obj �ж���<br><span class="hljs-params">UATHelper:</span> Packaging (Windows (<span class="hljs-number">6</span>4-bit)):     AModule.cpp.<span class="hljs-params">obj :</span> error <span class="hljs-params">LNK2005:</span> <span class="hljs-string">&quot;unsigned char * * GNameBlocksDebug&quot;</span> (<span class="hljs-operator">?</span>GNameBlocksDebug@@<span class="hljs-number">3</span>PEAPEAEEA) �Ѿ��� ModulePackage.cpp.obj �ж���<br><span class="hljs-params">UATHelper:</span> Packaging (Windows (<span class="hljs-number">6</span>4-bit)):       ���ڴ����� D:\Codes\UE4\ModulePackage\Binaries\Win64\ModulePackage.lib �Ͷ��� D:\Codes\UE4\ModulePackage\Binaries\Win64\ModulePackage.exp<br><span class="hljs-params">UATHelper:</span> Packaging (Windows (<span class="hljs-number">6</span>4-bit)):     D:\Codes\UE4\ModulePackage\Binaries\Win64\ModulePackage.<span class="hljs-params">exe :</span> fatal error <span class="hljs-params">LNK1169:</span> �ҵ�һ���������ض���ķ���<br><span class="hljs-params">LogSlate:</span> Took <span class="hljs-number">0.021891</span> seconds to synchronously load lazily loaded font &#x27;..<span class="hljs-operator">/</span>..<span class="hljs-operator">/</span>..<span class="hljs-operator">/</span>Engine<span class="hljs-operator">/</span>Content<span class="hljs-operator">/</span>Slate<span class="hljs-operator">/</span>Fonts<span class="hljs-operator">/</span>NotoNaskhArabicUI-Regular.ttf&#x27; (<span class="hljs-number">144</span>K)<br><span class="hljs-params">LogSlate:</span> Last resort fallback font was requested. <span class="hljs-params">Font:</span> &#x27;..<span class="hljs-operator">/</span>..<span class="hljs-operator">/</span>..<span class="hljs-operator">/</span>Engine<span class="hljs-operator">/</span>Content<span class="hljs-operator">/</span>Slate<span class="hljs-operator">/</span>Fonts<span class="hljs-operator">/</span>DroidSansFallback.ttf&#x27;, <span class="hljs-params">Character:</span> &#x27;Ͷ (U<span class="hljs-operator">+</span><span class="hljs-number">0376</span>)&#x27;<br><span class="hljs-params">LogSlate:</span> Took <span class="hljs-number">0.075434</span> seconds to synchronously load lazily loaded font &#x27;..<span class="hljs-operator">/</span>..<span class="hljs-operator">/</span>..<span class="hljs-operator">/</span>Engine<span class="hljs-operator">/</span>Content<span class="hljs-operator">/</span>SlateDebug<span class="hljs-operator">/</span>Fonts<span class="hljs-operator">/</span>LastResort.ttf&#x27; (<span class="hljs-number">5269</span>K)<br><span class="hljs-params">UATHelper:</span> Packaging (Windows (<span class="hljs-number">6</span>4-bit)): Took <span class="hljs-number">153.3858471</span>s to run UnrealBuildTool.exe, ExitCode<span class="hljs-operator">=</span><span class="hljs-number">6</span><br><span class="hljs-params">UATHelper:</span> Packaging (Windows (<span class="hljs-number">6</span>4-bit)): UnrealBuildTool failed. See log for more details. (C:\Users\Goulandis\AppData\Roaming\Unreal Engine\AutomationTool\Logs\D<span class="hljs-operator">+</span>UE_4.<span class="hljs-number">27</span>\UBT-ModulePackage-Win64-Development.txt)<br><span class="hljs-params">UATHelper:</span> Packaging (Windows (<span class="hljs-number">6</span>4-bit)): AutomationTool exiting <span class="hljs-keyword">with</span> ExitCode<span class="hljs-operator">=</span><span class="hljs-number">6</span> (<span class="hljs-number">6</span>)<br><span class="hljs-params">UATHelper:</span> Packaging (Windows (<span class="hljs-number">6</span>4-bit)): BUILD FAILED<br><span class="hljs-params">PackagingResults:</span> <span class="hljs-params">Error:</span> Unknown Error<br></code></pre></td></tr></table></figure>

<p>error LNK2005的原因是说有重定义，但是新建的类就是一个空类始终无法想明白是什么原因导致的，无论是使用自定的Actor还是自定义的C++类都一样。</p>
<p>而网上关于自定义模块的打包的资料基本没有我在内外网搜索都翻个7-8页基本挨边的资料都找不到，唉，这就是UE最痛苦的地方。</p>
<p>在测试的过程中还碰到另一个问题，就是往自定义模块添加类的时候，引擎添加新类会出现中断，这个情况下去引用模块的Actor类资源会出现.generated.h文件打不开，导致VS编译始终报错，具体原因也不明，不知道为什么编辑器向自定义模块添加新类会出现中断，也不知道为什么.generated.h文件命名存在VS就是打不开，即使把目录包含到项目属性的VC++目录也一样。</p>
<h1 id="十四、引用第三方库"><a href="#十四、引用第三方库" class="headerlink" title="十四、引用第三方库"></a>十四、引用第三方库</h1><p>第三方库份两种，一种是动态库(dll)一种是静态库(lib)，想找一个简单的库来做测试最好的方式还是自己创建一个，我就创建一个计算圆面积的库。</p>
<h2 id="1-创建Lib库"><a href="#1-创建Lib库" class="headerlink" title="1.创建Lib库"></a>1.创建Lib库</h2><p>使用VS新建一个空项目，往项目中添加四个文件，Mian.cpp，Area.h，Area.cpp，Source.def</p>
<ul>
<li><p>Main.cpp：是用来放main函数，我自己操作的时候没有main函数会报无法解析外部符号的错误，不过在网上看别人制作库的时候却并没有添加main函数，可能是使用C++版本或是VS版本不同的原因吧；</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>Area.h：声明方法的头文件，也是提供给外部调用时include的头文件；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Area</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">float</span> <span class="hljs-title">GetArea</span><span class="hljs-params">(<span class="hljs-type">float</span> R)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这里将方法封装在了一个类，当然我们也可以不用类来封装，而是直接写文件里作为全局函数来使用。</p>
</li>
<li><p>Area.cpp：实现方法的Cpp；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Area.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">Area::GetArea</span><span class="hljs-params">(<span class="hljs-type">float</span> R)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3.14</span>*<span class="hljs-built_in">pow</span>(R,<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>Source.def：是在<code>右键项目-&gt;添加-&gt;添加新项-&gt;代码-&gt;模块定义文件</code>中添加的，用来描述库需要导出的内容，这是因为一个项目要导出库不是所有内容都要导出的，.def文件就给予我们导出的灵活性。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002455.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002455.png" alt="img"></a></p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">LIBRARY</span> CircleArea<br><span class="hljs-keyword">EXPORTS</span><br>GetArea<br></code></pre></td></tr></table></figure>

<p>至于.def的具体语法在这里不是重点，就没有深入去研究了。</p>
</li>
</ul>
<p>然后将项目改成x64平台，因为UE的项目默认都是x64的，如果平台不一致，库将没有办法在UE中使用。</p>
<p>然后将<code>项目属性/配置属性/常规/配置类型</code>改为静态库。</p>
<p>然后生成项目，我们就可以在<code>项目目录/x64/Debug/</code>下看到我们的lib库了。</p>
<h2 id="2-添加Lib库"><a href="#2-添加Lib库" class="headerlink" title="2.添加Lib库"></a>2.添加Lib库</h2><p>第三方库UE有专门的文件夹放置—<code>项目目录/Source/ThirdParty</code>，ThirdParty文件夹还有include，lib两个文件夹，include放置第三方库的头文件，lib放置地方库的lib文件。</p>
<p>我们将上面制作出来的CircleArea库用到的头文件放入include中，将lib文件放库lib中。</p>
<p>然后编辑项目.Build.cs文件，哪个模块需要使用第三方库就编辑哪个模块的.Build.cs。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">using</span> UnrealBuildTool;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Collections.Generic;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.IO;<br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> UE4Cpp : ModuleRules<br>&#123;<br>	private string ModulePath<br>    &#123;<br>		<span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> ModuleDirectory; &#125;<br>	&#125;<br>	private string ThirdPartyPath<br>	&#123;<br>		<span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-type">Path</span>.GetFullPath(<span class="hljs-type">Path</span>.Combine(ModulePath, &quot;../ThirdParty&quot;)); &#125;<br>	&#125;<br>	<span class="hljs-built_in">public</span> UE4Cpp(ReadOnlyTargetRules Target) : base(Target)<br>	&#123;<br>		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;<br>		PublicDependencyModuleNames.AddRange(<span class="hljs-built_in">new</span> string[] &#123; &quot;Core&quot;, &quot;CoreUObject&quot;, &quot;Engine&quot;, &quot;InputCore&quot;,&quot;AModule&quot;&#125;);<br>		PrivateDependencyModuleNames.AddRange(<span class="hljs-built_in">new</span> string[] &#123;  &#125;);<br>		PublicIncludePaths.<span class="hljs-keyword">Add</span>(<span class="hljs-type">Path</span>.Combine(ThirdPartyPath, &quot;include&quot;));<br>		PublicAdditionalLibraries.<span class="hljs-keyword">Add</span>(<span class="hljs-type">Path</span>.Combine(ThirdPartyPath, &quot;lib&quot;, &quot;CircleArea.lib&quot;));<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在类里我对ModuleDirectory进行了封装，因为VS对UBT的支持还不是很好，很多UE提供的函数或变量VS是没有提示的，为了方便使用所以进行一次封装，同时也把ThirdParty文件路径也封装了。</p>
<p>在PublicIncludePaths中添加头文件的路径，在PublicAdditionalLibraries中添加lib库的路径，如此我们的库就添加进UE4中了</p>
<h2 id="3-使用Lib库"><a href="#3-使用Lib库" class="headerlink" title="3.使用Lib库"></a>3.使用Lib库</h2><p>使用Lib库的方法就比较简单了，直接在要使用的地方include头文件，然后就可以使用库里的类和方法了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;../ThirdParty/include/Area.h&quot;</span></span><br><span class="hljs-comment">//...</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AContainerctor::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Super::<span class="hljs-built_in">BeginPlay</span>();<br>	<span class="hljs-type">float</span> Area = Area::<span class="hljs-built_in">GetArea</span>(<span class="hljs-number">10</span>);<br>	<span class="hljs-built_in">UE_LOG</span>(LogTemp, Log, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Area=%f&quot;</span>), Area);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002503.png"><img src="https://raw.githubusercontent.com/Goulandis/ImgLib/main/img/20221016002503.png" alt="img"></a></p>
<h2 id="4-创建Dll库"><a href="#4-创建Dll库" class="headerlink" title="4.创建Dll库"></a>4.创建Dll库</h2><p>创建动态库的方法和静态库一样，只是把配置类型改为动态库，然后生成，就可以在<code>x64/Debug/</code>目录下看到生成的.dll文件和.lib文件。</p>
<h2 id="5-添加Dll库"><a href="#5-添加Dll库" class="headerlink" title="5.添加Dll库"></a>5.添加Dll库</h2><p>添加动态库的方式有两种，其一：</p>
<p>在.Build.cs文件中添加。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnrealBuildTool;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.IO;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UE4Cpp</span> : <span class="hljs-title">ModuleRules</span><br>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> ModulePath<br>    &#123;<br>		<span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> ModuleDirectory; &#125;<br>	&#125;<br>	<span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> ThirdPartyPath<br>	&#123;<br>		<span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> Path.GetFullPath(Path.Combine(ModulePath, <span class="hljs-string">&quot;../ThirdParty&quot;</span>)); &#125;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UE4Cpp</span>(<span class="hljs-params">ReadOnlyTargetRules Target</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">Target</span>)</span><br>	&#123;<br>		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;<br>		PublicDependencyModuleNames.AddRange(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123; <span class="hljs-string">&quot;Core&quot;</span>, <span class="hljs-string">&quot;CoreUObject&quot;</span>, <span class="hljs-string">&quot;Engine&quot;</span>, <span class="hljs-string">&quot;InputCore&quot;</span>,<span class="hljs-string">&quot;AModule&quot;</span>&#125;);		    PublicDelayLoadDLLs.Add(Path.Combine(ThirdPartyPath,<span class="hljs-string">&quot;dll&quot;</span>,<span class="hljs-string">&quot;CircleArea.dll&quot;</span>));<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个方式又引擎自动管理动态库的添加时机，在使用时要提前将动态库目录加入搜索列表，否则UE将找不到动态库。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">FPlatformProcess::<span class="hljs-built_in">PushDllDirectory</span>(*(FPaths::<span class="hljs-built_in">GameSourceDir</span>() / <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;ThirdParty/dll&quot;</span>)));<br></code></pre></td></tr></table></figure>

<p>其二就是在使用的时候直接使用绝对路径加载，详细可以直接看下一节的代码。</p>
<h2 id="6-使用Dll库"><a href="#6-使用Dll库" class="headerlink" title="6.使用Dll库"></a>6.使用Dll库</h2><p>如果使用第5节提到的第一种方法添加的动态库就这么使用：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs php">typedef <span class="hljs-keyword">float</span>(*_GetArea)(<span class="hljs-keyword">float</span> R);<br><span class="hljs-comment">//..</span><br><span class="hljs-keyword">void</span> <span class="hljs-title class_">AContainerctor</span>::<span class="hljs-title function_ invoke__">BeginPlay</span>()<br>&#123;<br>	<span class="hljs-title class_">Super</span>::<span class="hljs-title function_ invoke__">BeginPlay</span>();<br>	<span class="hljs-title class_">FPlatformProcess</span>::<span class="hljs-title function_ invoke__">PushDllDirectory</span>(*(<span class="hljs-title class_">FPaths</span>::<span class="hljs-title function_ invoke__">GameSourceDir</span>() / <span class="hljs-title function_ invoke__">TEXT</span>(<span class="hljs-string">&quot;ThirdParty/dll&quot;</span>)));<br>	<span class="hljs-keyword">void</span>* DllHandle = <span class="hljs-title class_">FPlatformProcess</span>::<span class="hljs-title function_ invoke__">GetDllHandle</span>(<span class="hljs-title function_ invoke__">TEXT</span>(<span class="hljs-string">&quot;CircleArea.dll&quot;</span>));<br>	<span class="hljs-keyword">if</span> (DllHandle)<br>	&#123;<br>		_GetArea DllGetArea = (_GetArea)<span class="hljs-title class_">FPlatformProcess</span>::<span class="hljs-title function_ invoke__">GetDllExport</span>(DllHandle, <span class="hljs-title function_ invoke__">TEXT</span>(<span class="hljs-string">&quot;GetArea&quot;</span>));<br>		<span class="hljs-keyword">if</span> (DllGetArea)<br>		&#123;<br>			<span class="hljs-keyword">float</span> Area = <span class="hljs-title function_ invoke__">DllGetArea</span>(<span class="hljs-number">10</span>);<br>			<span class="hljs-title function_ invoke__">UE_LOG</span>(LogTemp, Log, <span class="hljs-title function_ invoke__">TEXT</span>(<span class="hljs-string">&quot;Area=%f&quot;</span>), Area);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果使用的是第二种方法就这么使用：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs php">typedef <span class="hljs-keyword">float</span>(*_GetArea)(<span class="hljs-keyword">float</span> R);<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">void</span> <span class="hljs-title class_">AContainerctor</span>::<span class="hljs-title function_ invoke__">BeginPlay</span>()<br>&#123;<br>	<span class="hljs-title class_">Super</span>::<span class="hljs-title function_ invoke__">BeginPlay</span>();<br>	FString DllPath = <span class="hljs-title class_">FPaths</span>::<span class="hljs-title function_ invoke__">Combine</span>(*<span class="hljs-title class_">FPaths</span>::<span class="hljs-title function_ invoke__">GameSourceDir</span>(), <span class="hljs-title function_ invoke__">TEXT</span>(<span class="hljs-string">&quot;ThirdParty/dll&quot;</span>), <span class="hljs-title function_ invoke__">TEXT</span>(<span class="hljs-string">&quot;CircleArea.dll&quot;</span>));<br>	<span class="hljs-keyword">if</span> (<span class="hljs-title class_">FPaths</span>::<span class="hljs-title function_ invoke__">FileExists</span>(DllPath))<br>	&#123;<br>		<span class="hljs-keyword">void</span>* DllHandle = <span class="hljs-title class_">FPlatformProcess</span>::<span class="hljs-title function_ invoke__">GetDllHandle</span>(*DllPath);<br>		<span class="hljs-keyword">if</span> (DllHandle)<br>		&#123;<br>			_GetArea DllGetArea = (_GetArea)<span class="hljs-title class_">FPlatformProcess</span>::<span class="hljs-title function_ invoke__">GetDllExport</span>(DllHandle, <span class="hljs-title function_ invoke__">TEXT</span>(<span class="hljs-string">&quot;GetArea&quot;</span>));<br>			<span class="hljs-keyword">if</span> (DllGetArea)<br>			&#123;<br>				<span class="hljs-keyword">float</span> Area = <span class="hljs-title function_ invoke__">DllGetArea</span>(<span class="hljs-number">10</span>);<br>				<span class="hljs-title function_ invoke__">UE_LOG</span>(LogTemp, Log, <span class="hljs-title function_ invoke__">TEXT</span>(<span class="hljs-string">&quot;Area=%f&quot;</span>), Area);<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>typedef float(*_GetArea)(float R)</code>：这是定义了一个函数指针<code>_GetArea</code>，函数接收一个float类型参数，返回一个float类型的值，和dll中的GetArea函数对应。</li>
<li>FPlatformProcess::GetDllHandle：获取Dll的引用；</li>
<li>(_GetArea)FPlatformProcess::GetDllExport：通过名字获取Dll中的对应函数入口，并强转成我们定义的函数指针类型，因为函数指针的类型是我们根据Dll中对应函数来定义的，所以一般强转都是可以成功的；</li>
<li>DllGetArea(10)：通过函数指针来调用Dll中的函数。</li>
</ul>
<h2 id="7-碰到的问题"><a href="#7-碰到的问题" class="headerlink" title="7.碰到的问题"></a>7.碰到的问题</h2><p>在试验的过程中碰到两个问题。</p>
<p>其一就是如果一个动态库里有两个不同的类但是两个类都拥有一个同名的函数，我们在调用的的时候应该如何区分呢？这是看到UE是通过函数名来获取Dll中的函数想到的问题，这个其实对于使用者来说不需要考虑，因为Dll在导出的时候就要求了不能有同名函数，否则编译会报错。</p>
<p>其二就是我在网上查到的所有的使用Dll的文件基本都是告诉我们怎么去使用Dll中的函数，没有一篇是将怎么去使用Dll中的类的，有在C++中使用的方法，不过直接搬到UE4中似乎并不适用。</p>
<h1 id="十五、断言"><a href="#十五、断言" class="headerlink" title="十五、断言"></a>十五、断言</h1><p>断言是UE4程序中的一种代码检查机制，有时我们在执行一段代码时，有些值是要确保一定存在的，不存在程序将不能在往下执行直接中断，断言就被用来处理这个问题的，断言是一种来调试代码的工具，断言不会被编译进要发布的代码中，所以断言不会影响Shipping版本。</p>
<p>断言判断的内容必须为true，否则将执行中断。</p>
<p>断言的定义在AssertionMacros.h文件中，断言分三类，check、verify和ensure。</p>
<h2 id="1-Check类型断言"><a href="#1-Check类型断言" class="headerlink" title="1.Check类型断言"></a>1.Check类型断言</h2><h3 id="check-expr"><a href="#check-expr" class="headerlink" title="check(expr)"></a>check(expr)</h3><p>expr为false直接中断程序，可以在Debug、Development、Shipping的Editor版本中运行。</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">void</span> AContainerctor::CheckTest()<br>&#123;<br>	check(<span class="hljs-built_in">Count</span> == <span class="hljs-number">1</span>);<br>	UE_LOG(LogTemp, <span class="hljs-built_in">Log</span>, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Count=%d&quot;</span>),<span class="hljs-built_in">Count</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="checkSlow-expr"><a href="#checkSlow-expr" class="headerlink" title="checkSlow(expr)"></a>checkSlow(expr)</h3><p>expr为false直接中断程序，只能在Debug版本中运行</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">void</span> AContainerctor::CheckTest()<br>&#123;<br>	checkSlow(<span class="hljs-built_in">Count</span> == <span class="hljs-number">1</span>);<br>	UE_LOG(LogTemp, <span class="hljs-built_in">Log</span>, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Count=%d&quot;</span>),<span class="hljs-built_in">Count</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>按照官方文档的说明是只能在Debug版本中运行，但是我在实际调试中发现，checkSlow似乎在任何情况下都没有运行，于是我打开Build.h看了一下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">if</span> UE_BUILD_DEBUG</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DO_GUARD_SLOW</span><br>		<span class="hljs-meta">#<span class="hljs-keyword">define</span> DO_GUARD_SLOW									1</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DO_CHECK</span><br>		<span class="hljs-meta">#<span class="hljs-keyword">define</span> DO_CHECK										1</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DO_ENSURE</span><br>		<span class="hljs-meta">#<span class="hljs-keyword">define</span> DO_ENSURE										1</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STATS</span><br>		<span class="hljs-meta">#<span class="hljs-keyword">define</span> STATS											((WITH_UNREAL_DEVELOPER_TOOLS || !WITH_EDITORONLY_DATA || USE_STATS_WITHOUT_ENGINE || USE_MALLOC_PROFILER || FORCE_USE_STATS) &amp;&amp; !ENABLE_STATNAMEDEVENTS)</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> ALLOW_DEBUG_FILES</span><br>		<span class="hljs-meta">#<span class="hljs-keyword">define</span> ALLOW_DEBUG_FILES								1</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> ALLOW_CONSOLE</span><br>		<span class="hljs-meta">#<span class="hljs-keyword">define</span> ALLOW_CONSOLE									1</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> NO_LOGGING</span><br>		<span class="hljs-meta">#<span class="hljs-keyword">define</span> NO_LOGGING										0</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> UE_BUILD_DEVELOPMENT</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DO_GUARD_SLOW</span><br>		<span class="hljs-meta">#<span class="hljs-keyword">define</span> DO_GUARD_SLOW									0</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DO_CHECK</span><br>		<span class="hljs-meta">#<span class="hljs-keyword">define</span> DO_CHECK										1</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DO_ENSURE</span><br>		<span class="hljs-meta">#<span class="hljs-keyword">define</span> DO_ENSURE										1</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STATS</span><br>		<span class="hljs-meta">#<span class="hljs-keyword">define</span> STATS											((WITH_UNREAL_DEVELOPER_TOOLS || !WITH_EDITORONLY_DATA || USE_STATS_WITHOUT_ENGINE || USE_MALLOC_PROFILER || FORCE_USE_STATS) &amp;&amp; !ENABLE_STATNAMEDEVENTS)</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> ALLOW_DEBUG_FILES</span><br>		<span class="hljs-meta">#<span class="hljs-keyword">define</span> ALLOW_DEBUG_FILES								1</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> ALLOW_CONSOLE</span><br>		<span class="hljs-meta">#<span class="hljs-keyword">define</span> ALLOW_CONSOLE									1</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> NO_LOGGING</span><br>		<span class="hljs-meta">#<span class="hljs-keyword">define</span> NO_LOGGING										0</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> UE_BUILD_TEST</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DO_GUARD_SLOW</span><br>		<span class="hljs-meta">#<span class="hljs-keyword">define</span> DO_GUARD_SLOW									0</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DO_CHECK</span><br>		<span class="hljs-meta">#<span class="hljs-keyword">define</span> DO_CHECK										USE_CHECKS_IN_SHIPPING</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DO_ENSURE</span><br>		<span class="hljs-meta">#<span class="hljs-keyword">define</span> DO_ENSURE										USE_ENSURES_IN_SHIPPING</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STATS</span><br>		<span class="hljs-meta">#<span class="hljs-keyword">define</span> STATS											((USE_MALLOC_PROFILER || FORCE_USE_STATS) &amp;&amp; !ENABLE_STATNAMEDEVENTS)</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> ALLOW_DEBUG_FILES</span><br>		<span class="hljs-meta">#<span class="hljs-keyword">define</span> ALLOW_DEBUG_FILES								1</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> ALLOW_CONSOLE</span><br>		<span class="hljs-meta">#<span class="hljs-keyword">define</span> ALLOW_CONSOLE									1</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> NO_LOGGING</span><br>		<span class="hljs-meta">#<span class="hljs-keyword">define</span> NO_LOGGING										!USE_LOGGING_IN_SHIPPING</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> UE_BUILD_SHIPPING</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">if</span> WITH_EDITOR</span><br>		<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DO_GUARD_SLOW</span><br>			<span class="hljs-meta">#<span class="hljs-keyword">define</span> DO_GUARD_SLOW								0</span><br>		<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>		<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DO_CHECK</span><br>			<span class="hljs-meta">#<span class="hljs-keyword">define</span> DO_CHECK									1</span><br>		<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>		<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DO_ENSURE</span><br>			<span class="hljs-meta">#<span class="hljs-keyword">define</span> DO_ENSURE									1</span><br>		<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>		<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STATS</span><br>			<span class="hljs-meta">#<span class="hljs-keyword">define</span> STATS										1</span><br>		<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>		<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> ALLOW_DEBUG_FILES</span><br>			<span class="hljs-meta">#<span class="hljs-keyword">define</span> ALLOW_DEBUG_FILES							1</span><br>		<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>		<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> ALLOW_CONSOLE</span><br>			<span class="hljs-meta">#<span class="hljs-keyword">define</span> ALLOW_CONSOLE								0</span><br>		<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>		<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> NO_LOGGING</span><br>			<span class="hljs-meta">#<span class="hljs-keyword">define</span> NO_LOGGING									0</span><br>		<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>		<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DO_GUARD_SLOW</span><br>			<span class="hljs-meta">#<span class="hljs-keyword">define</span> DO_GUARD_SLOW								0</span><br>		<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>		<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DO_CHECK</span><br>			<span class="hljs-meta">#<span class="hljs-keyword">define</span> DO_CHECK									USE_CHECKS_IN_SHIPPING</span><br>		<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>		<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DO_ENSURE</span><br>			<span class="hljs-meta">#<span class="hljs-keyword">define</span> DO_ENSURE									USE_ENSURES_IN_SHIPPING</span><br>		<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>		<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STATS</span><br>			<span class="hljs-meta">#<span class="hljs-keyword">define</span> STATS										(FORCE_USE_STATS &amp;&amp; !ENABLE_STATNAMEDEVENTS)</span><br>		<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>		<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> ALLOW_DEBUG_FILES</span><br>			<span class="hljs-meta">#<span class="hljs-keyword">define</span> ALLOW_DEBUG_FILES							0</span><br>		<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>		<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> ALLOW_CONSOLE</span><br>			<span class="hljs-meta">#<span class="hljs-keyword">define</span> ALLOW_CONSOLE								ALLOW_CONSOLE_IN_SHIPPING</span><br>		<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>		<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> NO_LOGGING</span><br>			<span class="hljs-meta">#<span class="hljs-keyword">define</span> NO_LOGGING									!USE_LOGGING_IN_SHIPPING</span><br>		<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>	<span class="hljs-meta">#<span class="hljs-keyword">error</span> Exactly one of [UE_BUILD_DEBUG UE_BUILD_DEVELOPMENT UE_BUILD_TEST UE_BUILD_SHIPPING] should be defined to be 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<p>确实DO_GUARD_SLOW宏只有在Debug模式下才被置为1其他模式都是0，我把Developer模式下的DO_GUARD_SLOW宏也设置成1，发现checkFlow在Debug模式和Developer模式下都运行了，不知道是不是bug。</p>
<h3 id="checkf-expr-text"><a href="#checkf-expr-text" class="headerlink" title="checkf(expr,text)"></a>checkf(expr,text)</h3><p>expr为false直接中断程序，并把Text打印到日志，可以在Debug、Development、Shipping Editor版本中运行。</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">void</span> AContainerctor::CheckTest()<br>&#123;<br>	checkf(<span class="hljs-built_in">Count</span> == <span class="hljs-number">1</span>,<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Count!=1&quot;</span>));<br>	UE_LOG(LogTemp, <span class="hljs-built_in">Log</span>, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Count=%d&quot;</span>),<span class="hljs-built_in">Count</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>关于checkf我们不能使用VS拉起来的引擎测试效果，VS拉起来的引擎会直接在VS中中断，导致错误信息无法打印到日志中。</p>
<h3 id="checkfSlow-expr-text"><a href="#checkfSlow-expr-text" class="headerlink" title="checkfSlow(expr,text)"></a>checkfSlow(expr,text)</h3><p>checkSlow的checkf版，和checkSlow一样也有bug。</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">void</span> AContainerctor::CheckTest()<br>&#123;<br>	checkfSlow(<span class="hljs-built_in">Count</span> == <span class="hljs-number">1</span>,<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Count!=1&quot;</span>));<br>	UE_LOG(LogTemp, <span class="hljs-built_in">Log</span>, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Count=%d&quot;</span>),<span class="hljs-built_in">Count</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="checkCode-code"><a href="#checkCode-code" class="headerlink" title="checkCode(code)"></a>checkCode(code)</h3><p>直接执行（）中的代码，实际测试….这他呀的根本不会中断，感觉没什么卵用。</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">void</span> AContainerctor::CheckTest()<br>&#123;<br>	checkCode(<br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">Count</span> != <span class="hljs-number">1</span>)<br>		&#123;<br>			<span class="hljs-built_in">Count</span> = <span class="hljs-number">2</span>;<br>			UE_LOG(LogTemp, Error, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Count=%d&quot;</span>), <span class="hljs-built_in">Count</span>);<br>		&#125;<br>	);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="checkNoEntry"><a href="#checkNoEntry" class="headerlink" title="checkNoEntry()"></a>checkNoEntry()</h3><p>如果程序执行了此语句就直接中断,用来截断不能被执行的代码。</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">void</span> <span class="hljs-variable">AContainerctor</span>::<span class="hljs-function"><span class="hljs-title">CheckTest</span>()</span><br>&#123;<br>	<span class="hljs-function"><span class="hljs-title">checkNoEntry</span>();</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<h3 id="checkNoReentry"><a href="#checkNoReentry" class="headerlink" title="checkNoReentry()"></a>checkNoReentry()</h3><p>如果此语句被执行超过1次，就中断程序，用来标注只能被执行一次的代码。</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">void</span> <span class="hljs-variable">AContainerctor</span>::<span class="hljs-function"><span class="hljs-title">CheckTest</span>()</span><br>&#123;<br>	<span class="hljs-function"><span class="hljs-title">checkNoReentry</span>();</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<h3 id="checkNoRecusion"><a href="#checkNoRecusion" class="headerlink" title="checkNoRecusion()"></a>checkNoRecusion()</h3><p>判断函数是否递归，如果递归则中断。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">void AContainerctor::<span class="hljs-built_in">CheckTest</span>()<br>&#123;<br>	<span class="hljs-built_in">checkNoRecursion</span>();<br>	if (Count == <span class="hljs-number">1</span>)<br>	&#123;<br>		this-&gt;<span class="hljs-built_in">CreateThread</span>();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="unimplemented"><a href="#unimplemented" class="headerlink" title="unimplemented()"></a>unimplemented()</h3><p>如果被执行则中断，效果和checkNoEntry一样，不过主要用于因该被覆盖而不会被调用的虚函数，实则没什么乱用，我不理解不会被调用的函数留着干嘛。</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">void</span> <span class="hljs-variable">AContainerctor</span>::<span class="hljs-function"><span class="hljs-title">CheckTest</span>()</span><br>&#123;<br>	<span class="hljs-function"><span class="hljs-title">unimplemented</span>();</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<h2 id="2-Verify类型断言"><a href="#2-Verify类型断言" class="headerlink" title="2.Verify类型断言"></a>2.Verify类型断言</h2><p>Verify类型的断言中表达式会独立于断言运行，就是说无论断言是否生效(DO_CHECK&#x3D;1断言生效，DO_CHECK&#x3D;0断言不生效)，代码执行到此语句的时候表达式都会运行，而Check类型的断言则是断言不生效时，表达式就不会执行。</p>
<p>verify有verify、verifySlow、verifyf、verifyfSlow四种，用法上check一样，当然bug也是一样的。</p>
<h2 id="3-Ensure类型断言"><a href="#3-Ensure类型断言" class="headerlink" title="3.Ensure类型断言"></a>3.Ensure类型断言</h2><p>ensure类型的断言和verify有点类似，在不出现会导致程序崩溃的错误时(如读取空指针)，ensure都不会中断，程序依然会执行但是ensure会在首次执行时将消息通知给引擎的崩溃报告器。</p>
<h3 id="ensure-exps"><a href="#ensure-exps" class="headerlink" title="ensure(exps)"></a>ensure(exps)</h3><p>首次执行时将false消息通知到崩溃报告器，不执行中断。</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">void</span> AContainerctor::EnsureTest()<br>&#123;<br>	ensure(<span class="hljs-built_in">Count</span> == <span class="hljs-number">1</span>);<br>	UE_LOG(LogTemp, <span class="hljs-built_in">Log</span>, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Ensure&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过VS拉起的引擎在执行到ensure时会直接在VS中断，所以要验证效果的话，引擎不能通过VS拉起。</p>
<p>执行了ensure程序不会中断后面的代码依然执行，并且会在首次执行时将错误报告打印在日志。</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Warning:</span> Script Stack (<span class="hljs-number">2</span> frames):<br>Untitled_C.ExecuteUbergraph_Untitled<br>Untitled_C.InpActEvt_Three_K2Node_InputKeyEvent_0<br><span class="hljs-params">LogStats:</span> FPlatformStackWalk::StackWalkAndDump <span class="hljs-operator">-</span>  <span class="hljs-number">0.076</span> s<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> <span class="hljs-operator">==</span><span class="hljs-operator">=</span> Handled <span class="hljs-params">ensure:</span> <span class="hljs-operator">==</span><span class="hljs-operator">=</span><br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> Ensure condition <span class="hljs-params">failed:</span> Count <span class="hljs-operator">==</span> <span class="hljs-number">1</span> [File:D:\Codes\UE4\UE4Cpp\Source\UE4Cpp\Containerctor.cpp] [<span class="hljs-params">Line:</span> <span class="hljs-number">33</span>]<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> <span class="hljs-params">Stack:</span> <br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff92cfea1a8 UE4Editor-UE4Cpp.dll<span class="hljs-operator">!</span><span class="hljs-symbol">&lt;lambda_39fe32f94e8347501feb44ad8f6d752a&gt;</span>::operator()() [D:\Codes\UE4\UE4Cpp\Source\UE4Cpp\Containerctor.cpp:<span class="hljs-number">33</span>]<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff92cfe4b8e UE4Editor-UE4Cpp.dll<span class="hljs-operator">!</span>AContainerctor::CreateThread() [D:\Codes\UE4\UE4Cpp\Source\UE4Cpp\Containerctor.cpp:<span class="hljs-number">33</span>]<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff9667019c4 UE4Editor-CoreUObject.dll<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff9669bf37b UE4Editor-CoreUObject.dll<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff9669e2573 UE4Editor-CoreUObject.dll<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff9669e4d8d UE4Editor-CoreUObject.dll<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff9669b341a UE4Editor-CoreUObject.dll<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff9669e497c UE4Editor-CoreUObject.dll<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff9669e4d8d UE4Editor-CoreUObject.dll<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff9669e4184 UE4Editor-CoreUObject.dll<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff9667019c4 UE4Editor-CoreUObject.dll<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff9669e3ca3 UE4Editor-CoreUObject.dll<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff947ce942a UE4Editor-Engine.dll<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff948ffec64 UE4Editor-Engine.dll<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff94902eeee UE4Editor-Engine.dll<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff948b16460 UE4Editor-Engine.dll<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff948b2763c UE4Editor-Engine.dll<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff948b14c2b UE4Editor-Engine.dll<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff948b26739 UE4Editor-Engine.dll<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff947ccc06e UE4Editor-Engine.dll<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff948ee410e UE4Editor-Engine.dll<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff948eed2e4 UE4Editor-Engine.dll<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff966de2398 UE4Editor-Core.dll<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff966de27ce UE4Editor-Core.dll<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff966df40bd UE4Editor-Core.dll<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff948f093be UE4Editor-Engine.dll<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff948f0faba UE4Editor-Engine.dll<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff9485f349f UE4Editor-Engine.dll<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff9485fe2fc UE4Editor-Engine.dll<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff9465714c3 UE4Editor-UnrealEd.dll<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff946e72ba6 UE4Editor-UnrealEd.dll<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff664aa87a0 UE4Editor.exe<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff664ac0fcc UE4Editor.exe<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff664ac10ba UE4Editor.exe<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff664ac40dd UE4Editor.exe<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff664ad5984 UE4Editor.exe<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff664ad853a UE4Editor.exe<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff9d88f7034 KERNEL32.DLL<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogOutputDevice:</span> <span class="hljs-params">Error:</span> [Callstack] <span class="hljs-number">0</span>x00007ff9da0fd0d1 ntdll.dll<span class="hljs-operator">!</span>UnknownFunction []<br><span class="hljs-params">LogStats:</span>                SubmitErrorReport <span class="hljs-operator">-</span>  <span class="hljs-number">0.000</span> s<br><span class="hljs-params">LogStats:</span>                    SendNewReport <span class="hljs-operator">-</span>  <span class="hljs-number">1.662</span> s<br><span class="hljs-params">LogStats:</span>             FDebug::EnsureFailed <span class="hljs-operator">-</span>  <span class="hljs-number">1.787</span> s<br><span class="hljs-params">LogTemp:</span> Ensure<br></code></pre></td></tr></table></figure>

<h3 id="ensureMsgf-exps-text"><a href="#ensureMsgf-exps-text" class="headerlink" title="ensureMsgf(exps,text)"></a>ensureMsgf(exps,text)</h3><p>首次执行时将错误信息通知到崩溃报告器，并将text打印到日志。</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">void</span> AContainerctor::EnsureTest()<br>&#123;<br>	ensureMsgf(<span class="hljs-built_in">Count</span> == <span class="hljs-number">1</span>,<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Count!=1&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="ensureAlways-exps"><a href="#ensureAlways-exps" class="headerlink" title="ensureAlways(exps)"></a>ensureAlways(exps)</h3><p>区别于ensure只在首次执行时通知崩溃报告器，ensureAlways只要执行就将错误信息通知到崩溃报告器，无论执行多少次。</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">void</span> <span class="hljs-variable">AContainerctor</span>::<span class="hljs-function"><span class="hljs-title">EnsureTest</span>()</span><br>&#123;<br>	<span class="hljs-function"><span class="hljs-title">ensureAlways</span>(<span class="hljs-variable">Count</span> == <span class="hljs-number">1</span>);</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<h3 id="ensureAlwaysMsgf-exps-text"><a href="#ensureAlwaysMsgf-exps-text" class="headerlink" title="ensureAlwaysMsgf(exps,text)"></a>ensureAlwaysMsgf(exps,text)</h3><p>ensureMsgf的Always版本</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">void</span> <span class="hljs-variable">AContainerctor</span>::<span class="hljs-function"><span class="hljs-title">EnsureTest</span>()</span><br>&#123;<br>	<span class="hljs-function"><span class="hljs-title">ensureAlways</span>(<span class="hljs-variable">Count</span> == <span class="hljs-number">1</span>，<span class="hljs-title">TEXT</span>(<span class="hljs-string">&quot;Count!=1&quot;</span>));</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" class="category-chain-item">学习记录</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/UE4/" class="print-no-link">#UE4</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>【UE4】C++编程</div>
      <div>http://example.com/2022/10/16/【UE4】C++编程/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Goulandis</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年10月16日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/11/04/%E3%80%90UE5%E3%80%91%E8%A7%A3%E5%86%B3UE5%E6%97%A0%E6%B3%95%E6%92%AD%E6%94%BEmp4%E8%A7%86%E9%A2%91/" title="【UE5】解决UE5无法播放mp4视频">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">【UE5】解决UE5无法播放mp4视频</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/05/08/%E3%80%90UE4%E3%80%91%E5%85%A8%E5%B1%80Widget/" title="【UE4】全局Widget">
                        <span class="hidden-mobile">【UE4】全局Widget</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>







  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
