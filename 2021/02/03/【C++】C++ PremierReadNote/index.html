

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/shun.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Goulandis">
  <meta name="keywords" content="snoopy">
  <title>【C++】C++ PremierReadNote - Goulandis</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/vs2015.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","version":"1.8.6","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="Goulandis" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Goulandis</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/Post.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="【C++】C++ PremierReadNote">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-02-03 10:52" pubdate>
        February 3, 2021 am
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      59
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">【C++】C++ PremierReadNote</h1>
            
            <div class="markdown-body">
              <meta name="referrer" content="no-referrer">

<h1 id="C-Primer-阅读笔记"><a href="#C-Primer-阅读笔记" class="headerlink" title="C++ Primer 阅读笔记"></a>C++ Primer 阅读笔记</h1><hr>
<a id="more"></a>

<h1 id="一、开始"><a href="#一、开始" class="headerlink" title="一、开始"></a>一、开始</h1><hr>
<h2 id="1-输入输出流的数据传输过程"><a href="#1-输入输出流的数据传输过程" class="headerlink" title="1.输入输出流的数据传输过程"></a>1.输入输出流的数据传输过程</h2><p><strong>输入:</strong><br>[窗]-&gt;[输入流对象(cin)]</p>
<p><strong>输出:</strong><br>[输出流对象(cout，cerr，clog)-&gt;[窗口]</p>
<p>c++从窗口中读取输入时不是直接存储在变量中而是先存储在istream类型对象cin中，输出是也非直接从变量输出到窗口而是先写入ostream对象cout/cerr/clog中，在从对象传输到窗口。</p>
<h2 id="2-输出运算符“-lt-lt-”"><a href="#2-输出运算符“-lt-lt-”" class="headerlink" title="2.输出运算符“&lt;&lt;”"></a>2.输出运算符“&lt;&lt;”</h2><p>“&lt;&lt;”运算符输出的是一个ostream类型对象，“&lt;&lt;”接受两个运算对象，其中左侧的运算对象必须是一个ostream对象，右侧可以是需要输出的值，“&lt;&lt;”将需要输出的值写入到ostream对象中。<br>std::cout&lt;&lt;”num:”&lt;&lt;a&lt;&lt;std::endl；<br>“&lt;&lt;”连续表达式可以理解为:<br>((std::cout&lt;&lt;”num:”)&lt;&lt;a)&lt;&lt;std::endl；<br>每一个括号最终返回的都是一个ostream对象。其中endl是“操纵符”，运行效果是换行，并将与设备关联的缓冲区的内容刷新到设备中去，如果不写endl则在程序运行结束或缓冲区满后系统自动将缓冲区内容刷新到设备中去。<br>输入运算符“&gt;&gt;”和输出运算符运行逻辑一样。</p>
<h2 id="3-char与unsigned-char"><a href="#3-char与unsigned-char" class="headerlink" title="3.char与unsigned char"></a>3.char与unsigned char</h2><p>在计算机中char也是分无符号和有符号两类的，char与int等类型不同的是，int等类型不显示标注unsigned默认为有符号数，而char在不同硬件环境中表示的类型可能是不一样的，所以为保证移植性最好在使用时指定signed和unsigned，c++标准不建议使用char来存储数值，这种区别主要出现在char类型向值类型的转换的过程中。</p>
<h2 id="4-有符号数与无符号数的运算"><a href="#4-有符号数与无符号数的运算" class="headerlink" title="4.有符号数与无符号数的运算"></a>4.有符号数与无符号数的运算</h2><p>在c++运算优先级中，无符号数的优先级大于有符号数，所以当一个表达式中即存在有符号数又不存在无符号数时，运算将被转换为无符号数的运算，由于无符号数表示的最小值是0所以当表达式的运算结果为负数时就会出现运算错误。</p>
<h2 id="5-c-11的四种变量初始化方式"><a href="#5-c-11的四种变量初始化方式" class="headerlink" title="5.c++11的四种变量初始化方式"></a>5.c++11的四种变量初始化方式</h2><p>int a=0;<br>int a={0};<br>int a{0};</p>
<h2 id="int-a-0"><a href="#int-a-0" class="headerlink" title="int a(0);"></a>int a(0);</h2><h1 id="二、变量和基本类型"><a href="#二、变量和基本类型" class="headerlink" title="二、变量和基本类型"></a>二、变量和基本类型</h1><hr>
<p>1.const引用的隐式类型转换<br>举例使用const限定的int类型的引用来引用double类型的变量的过程：double b=3.14;const int a=b;<br>在将double类型变量赋值给const int类型的引用时系统先创建一个临时变量，并将double隐式成int类型的结果存放到临时变量中，然后再将临时变量赋给引用，此时引用本质上是int类型的临时变量的别名，之后如果更改了double类型变量的值，引用值随之改变。</p>
<h2 id="2-constexpr变量"><a href="#2-constexpr变量" class="headerlink" title="2.constexpr变量"></a>2.constexpr变量</h2><p>constexpr是一个常量表达式，与const不同的是，const限定的变量只能被常量、常量的引用、常量表达式和常量与常量引用的表达式赋值，而constexpr可以被常量、常量的引用、表达式、以及可以在编译阶段就确定返回值的函数赋值。const在程序运行时的本质是在程序用的const的地方直接替换成期对应<br>的常量，而constexpr则是替换其在编译器期计算出来的结果值。<br>constexpr的意义在于constexpr强制要求赋值给变量的表达式必须在编译阶段可计算出结果值，这对很多重复运算的简单表达式直接限定了在编译期只进行一次运算起到了优化效果。</p>
<h2 id="3-constexpr指针"><a href="#3-constexpr指针" class="headerlink" title="3.constexpr指针"></a>3.constexpr指针</h2><p>被constexpr限定的指针的初始值只能是nullptr或者0或者指向一个地址固定不变的对象，这里需要注意在函数里的任何对象都不是存储在固定地址中的，所以constexpr限定的指针不能指向函数中的对象，全局对象则是存在在固定地址中的所以constexpr限定的指针可以指向这样的对象。</p>
<h2 id="4-c-11的两种别名声明方法"><a href="#4-c-11的两种别名声明方法" class="headerlink" title="4.c++ 11的两种别名声明方法"></a>4.c++ 11的两种别名声明方法</h2><p>typedef bm int;<br>using bm=int;</p>
<h2 id="5-decltype类型指示符"><a href="#5-decltype类型指示符" class="headerlink" title="5.decltype类型指示符"></a>5.decltype类型指示符</h2><p>decltype的作用是通过表达式或函数的返回值动态的推断其指示变量的类型，如：</p>
<figure class="highlight crystal"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crystal">decltype(<span class="hljs-function"><span class="hljs-keyword">fun</span>()) <span class="hljs-title">sum</span></span> = x;<span class="hljs-regexp">//sum</span>的类型为<span class="hljs-function"><span class="hljs-keyword">fun</span>函数返回值的类型，<span class="hljs-title">sum</span></span>的值由x赋予<br></code></pre></div></td></tr></table></figure>

<h2 id="顶层Const与底层Const"><a href="#顶层Const与底层Const" class="headerlink" title="顶层Const与底层Const"></a>顶层Const与底层Const</h2><p>由于指针本身也是一个对象，所以在Const修饰指针时，就立存在修饰指针或修饰指针所指的对象。如果Const修饰指针则是底层Const，如果修饰指针所指的对象则是顶层Const。</p>
<figure class="highlight nim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nim"><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span>* pa;//<span class="hljs-keyword">const</span>修饰指针，所以为底层<span class="hljs-keyword">const</span><br><span class="hljs-built_in">int</span>* <span class="hljs-keyword">const</span> pb;//<span class="hljs-keyword">const</span>修饰pb，所以为顶层<span class="hljs-keyword">const</span><br></code></pre></div></td></tr></table></figure>
<hr>
<h1 id="三、字符串、向量和数组"><a href="#三、字符串、向量和数组" class="headerlink" title="三、字符串、向量和数组"></a>三、字符串、向量和数组</h1><hr>
<h2 id="1-c-11的string对象的初始化方式"><a href="#1-c-11的string对象的初始化方式" class="headerlink" title="1.c++11的string对象的初始化方式"></a>1.c++11的string对象的初始化方式</h2><p>string s;<br>string str=s;<br>string str(s);<br>string str(“str”);<br>string str=”str”;<br>string str(2,’s’);//这种形式得到的是字符串”ss”,其中括号里只能使用字符。</p>
<h2 id="2-cin、getline-和cin-getline"><a href="#2-cin、getline-和cin-getline" class="headerlink" title="2.cin、getline()和cin.getline()"></a>2.cin、getline()和cin.getline()</h2><p>cin在对象在从缓存中读取数据时遇到空格符，制表符，换行符时或读至文件尾时会结束读取。<br>getline()可以读取空格符，遇到换行符时或读至文件尾时结束读取。<br>cin.getline()作用和getline一样，只是cin.getline和cin都是标准输出流iosteeam中的对象方法，而getline这是属于string.h中的方法。</p>
<h2 id="3-string-size-type类型"><a href="#3-string-size-type类型" class="headerlink" title="3.string::size_type类型"></a>3.string::size_type类型</h2><p><code>size_type</code>类型是c++定义的几种标准库类型的几种配套类型，其目的在于解决在不同机器中因为机器字长不同而导致string.size()的返回值无法存储的问题，比如在一个16位的机器中int整型存储的最大字符数为32767，但这对于储存一个文件大小的string来说这个大小是明显不够的，所以c++引入<code>size_type</code>，以解决不同机器上string.size()的返回值一定能被存储。<br><code>size_type</code>的本质是无符号类型所以在使用string.size()和有符号数做运算时要十分注意，因为这会导致计算结果出现异常。<br>需要注意的一点是<code>size_type</code>类型实际上不是一个确定的类型，在使用<code>size_type</code>时应注明<code>size_type</code>的类型，如:<code>string::size_type,vector&lt;int&gt;::size_type</code>。</p>
<h2 id="4-cctype头文件提供的一些字符判断函数"><a href="#4-cctype头文件提供的一些字符判断函数" class="headerlink" title="4.cctype头文件提供的一些字符判断函数"></a>4.cctype头文件提供的一些字符判断函数</h2><ul>
<li><p>isalnum(c) 当c是字母过数字时为真</p>
</li>
<li><p>isalpha(c) 当c是字母时为真</p>
</li>
<li><p>iscntrl(c) 当c是控制字符时为真</p>
</li>
<li><p>isdigit(c) 当c是数字时为真</p>
</li>
<li><p>isgraph(c) 当c不是空格但可以打印时为真</p>
</li>
<li><p>islower(c) 当c是小写字母时为真</p>
</li>
<li><p>isprint(c) 当c是可打印字符时为真(即c是空格或c具有可视化形式)</p>
</li>
<li><p>ispunct(c) 当c是标点符号时为真(即c不是控制字符、数字、字母、可打印空白中的一种)</p>
</li>
<li><p>isspace(c) 当c是空格时为真</p>
</li>
<li><p>isupper(c) 当c是大写字母时为真</p>
</li>
<li><p>isxdigit(c) 当c是16进制数字时为真</p>
</li>
<li><p>tolower(c) 如果c是大写字母则输出其小写</p>
</li>
<li><p>toupper(c) 如果c是小写字母则输出其大写</p>
</li>
</ul>
<h2 id="5-c-11的“foreach”"><a href="#5-c-11的“foreach”" class="headerlink" title="5.c++11的“foreach”"></a>5.c++11的“foreach”</h2><p>c++本没有foreach循环，但是c++11为for语句添加了新的语法:<br>for(param:array){}这个for语法每次循环从array中读取一个数据并存放在param中用于操作<br>需要注意的是param如果不使用引用的话，param实际是array中元素的拷贝，此时对param进行修改不会改变array的元素，如需要更改array中的元素的值时需要对param取引用。<br>还有一点十分重要的是不可以在范围for语句中更改array的容量大小，这是因为能被范围for遍历的序列都需要包含begin,end两个返回迭代器的成员，我们可以先看一下范围for的源码:<br>for(auto beg=v.begin(),end=v.end();beg!=end;++beg)<br>{<br>}<br>可以看到在范围for中实际上在循环前就已经存储了可遍历序列的begin,end迭代器，所以如果在循环中改变了序列的大小循环就会出错。</p>
<h2 id="6-vector容器的初始化方式"><a href="#6-vector容器的初始化方式" class="headerlink" title="6.vector容器的初始化方式"></a>6.vector容器的初始化方式</h2><ul>
<li>vector<T> v v是一个空的vector</T></li>
<li>vector<T> v2(v) v2是一个包含v所有副本的的vector</T></li>
<li>vector<T> v2=v 等价物v2(v)</T></li>
<li>vector<T> v(n,val) v是一个包含了n个重复元素，每个元素都是val的vector</T></li>
<li>vector<T> v(n) v是一个包含了n个重复执行了初始化的对象</T></li>
<li>vector<T> v{a,b,c……} v是一个包含了初始值个数元素的vector，每个元素被赋予对应的初始值</T></li>
<li>vector<T> v={a,b,c……} 等于v{a,b,c……}</T></li>
<li><font color="red"> 使用数组初始化vector容器，vector<T>(begin(array),end(array))，其中begin(array)是数组array的首地址，end(array)是数组array的尾地址 </T></font></li>
</ul>
<h2 id="7-vector对象能高效增长"><a href="#7-vector对象能高效增长" class="headerlink" title="7.vector对象能高效增长"></a>7.vector对象能高效增长</h2><p>c++标准要求vector容器在运行时能高效快速地添加元素，在c++11标准中vector的动态添加元素的性能要优于预先规定容器大小的性能，只有一种情况例外，就是vector中的元素全部都是相同的时候这种情况会反过来。</p>
<h2 id="8-迭代器的end"><a href="#8-迭代器的end" class="headerlink" title="8.迭代器的end"></a>8.迭代器的end</h2><p>迭代器的end()并不实际指向某个元素，所以不能对其进行递增或解引用操作。 </p>
<h2 id="9-iterator和const-iterator"><a href="#9-iterator和const-iterator" class="headerlink" title="9.iterator和const_iterator"></a>9.iterator和const_iterator</h2><p>iterator和<code>const_iterator</code>是标准库定义的迭代器的类型，一般迭代器没有固定的类型，一般使用<code>类型::iterator</code>或<code>const_iterator</code>来确定迭代器的类型，如：<code>vector&lt;int&gt;::iterator  it</code><br><code>iterator</code>为可读可写迭代器，<code>iterator</code>迭代器只能用于非常量容器；<br><code>const_iterator</code>为只读迭代器，<code>const_iterator</code>既可以用于非常量容器又可以用于常量容器，但是常量容器只能使用<code>const_iterator</code>迭代器。</p>
<h2 id="10-cbegin与cend"><a href="#10-cbegin与cend" class="headerlink" title="10.cbegin与cend"></a>10.cbegin与cend</h2><p>cbegin和cend与begin和end相对，cbegin和cend返回const_iterator迭代器。</p>
<h2 id="11-迭代器的-gt-运算符"><a href="#11-迭代器的-gt-运算符" class="headerlink" title="11.迭代器的-&gt;运算符"></a>11.迭代器的-&gt;运算符</h2><p>在使用迭代器的过程中经常需要通过解引用后再进行.运算，如：<code>(*it).empty()</code>，操作较为繁琐，c++11对这个操作进行了简化，即通过-&gt;运算来替换<code>(*it).</code>，前面的操作就可以替换为<code>it-&gt;empty()</code></p>
<h2 id="12-容器的删添操作会是迭代器、引用和指针失效"><a href="#12-容器的删添操作会是迭代器、引用和指针失效" class="headerlink" title="12.容器的删添操作会是迭代器、引用和指针失效"></a>12.容器的删添操作会是迭代器、引用和指针失效</h2><p><font color="red">这是因为容器的删添操作可能会出现存储空间的重新分配，用string作为例子是最贴切的，当我们想一个string字符串中添加一个字符时，如：</font></p>
<figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">sting v</span> = <span class="hljs-string">&quot;str&quot;</span>;<br><span class="hljs-attribute">v</span> = v + ‘s’;<br><br></code></pre></div></td></tr></table></figure>
<p><font color="red">程序的实际操作是先创建一个临时变量来存储添加之后的字符串strs，然后再将v指向新分配的存储空间，于是指向之前空间位置的迭代器、引用和指针自然就失效了。</font></p>
<h2 id="13-迭代器的运算"><a href="#13-迭代器的运算" class="headerlink" title="13.迭代器的运算"></a>13.迭代器的运算</h2><p><img src="https://i.loli.net/2020/08/27/EG2yOZL4H8YvhsT.jpg" srcset="/img/loading.gif" alt="Alt"></p>
<p>迭代器之后同时也可以进行加减运算其结果为dfference_type的带符号整型数表示两个迭代器之间的距离。</p>
<h2 id="14-数组的特殊性"><a href="#14-数组的特殊性" class="headerlink" title="14.数组的特殊性"></a>14.数组的特殊性</h2><p><font color="red">不能使数组来初始化数组，也不能使用数组来赋值数组，有的编译器支持数组初始化和赋值这是编译器的自身扩展，但仍然不应该这样做，因为当换了编译环境后程序可能就会出错人。</font></p>
<h2 id="15-存放存放指针的数组和指向数组的指针"><a href="#15-存放存放指针的数组和指向数组的指针" class="headerlink" title="15.存放存放指针的数组和指向数组的指针"></a>15.存放存放指针的数组和指向数组的指针</h2><figure class="highlight less"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-selector-tag">int</span> *<span class="hljs-selector-tag">ptr</span><span class="hljs-selector-attr">[2]</span>;<span class="hljs-comment">//拥有两个指针成员的数组</span><br><span class="hljs-selector-tag">int</span> <span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-tag">ptr2</span><span class="hljs-selector-attr">[2]</span>;<span class="hljs-comment">//错误，不存在引用数组</span><br><span class="hljs-selector-tag">int</span> (*ptr3)<span class="hljs-selector-attr">[2]</span>;<span class="hljs-comment">//指向有两个长度的整型数组的指针</span><br><span class="hljs-selector-tag">int</span> (&amp;ptr4)<span class="hljs-selector-attr">[2]</span>;<span class="hljs-comment">//指向两个长度的整型数组的引用</span><br><br></code></pre></div></td></tr></table></figure>
<h2 id="16-数组和指针"><a href="#16-数组和指针" class="headerlink" title="16.数组和指针"></a>16.数组和指针</h2><p>数组的名字实际上就是指向数组收地址的指针，所以下面操作得到是指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> arr[<span class="hljs-number">2</span>] = &#123;&#125;;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ptr</span><span class="hljs-params">(arr)</span></span>;<span class="hljs-comment">//per是一个指向arr首地址的int*类型指针</span><br><br></code></pre></div></td></tr></table></figure>
<p><font color="red">使用decltype进行上面的操作不会得到指针，而是得到数组，如：</font></p>
<figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">decltype</span>(arr) arr<span class="hljs-number">2</span> = &#123;<span class="hljs-number">1</span>&#125;;//arr<span class="hljs-number">2</span>是一个包含一个元素的int型数组<br></code></pre></div></td></tr></table></figure>
<p><font color="red">对数组执行下标运算实质上是对指向数组首地址的指针执行下标运算，如：</font></p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> i = ia[<span class="hljs-number">2</span>]; <span class="hljs-comment">//实际得到是(ia+2)所指向的元素</span><br></code></pre></div></td></tr></table></figure>

<p><font color="red">数组的下标运算只要不超过数组长度就可以执行下标运算，如：含有10个元素数组下标从0-9，但是 下标运算可以取到10，即a[10]，a[10]是数组的尾元素的下一个位置，但是对a[10]只能进行去地址运算(&amp;a[10])，不能对a[10]解引用或读取。</font></p>
<h2 id="17-ptrdiff-t类型"><a href="#17-ptrdiff-t类型" class="headerlink" title="17.ptrdiff_t类型"></a>17.ptrdiff_t类型</h2><p>和<code>size_type</code>一样，<code>ptrdiff_t</code>是c++11专门定制给begin()与end()的运算结果的类型，用于适应不同机器的字长。<br><font color="red">需要注意的是，内置数组下标值不是<code>ptrdiff_t</code>类型，如：a[1]，1就不是<code>ptrdiff_t</code>类型。</font></p>
<h2 id="18-void-指针"><a href="#18-void-指针" class="headerlink" title="18.void *指针"></a>18.void *指针</h2><p>任何非常量值都可以存入<code>void *</code>指针中。</p>
<h1 id="四、表达式"><a href="#四、表达式" class="headerlink" title="四、表达式"></a>四、表达式</h1><hr>
<h2 id="1-为定义行为"><a href="#1-为定义行为" class="headerlink" title="1.为定义行为"></a>1.为定义行为</h2><p>c++中存在一些为定义行为，如&lt;&lt;运算符在c++中并没有定义其后表达式的运算顺序，此时运行下面代码就会出现为定义行为。</p>
<figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;++i&lt;&lt;<span class="hljs-built_in">endl</span>;<br></code></pre></div></td></tr></table></figure>
<p>此时会出现0，1或1，1两种结果，这是因为&lt;&lt;没有明确指定何时及如何对运算对象求值，但是在实际使用过程中并没有出现上述情况，这可能是编译器为&lt;&lt;规定了运算顺序。</p>
<h2 id="2-溢出与其他算术异常"><a href="#2-溢出与其他算术异常" class="headerlink" title="2.溢出与其他算术异常"></a>2.溢出与其他算术异常</h2><p><img src="https://i.loli.net/2020/09/04/QRnNjiTqEeOGaLV.jpg" srcset="/img/loading.gif" alt="6"></p>
<h2 id="3-运算符的优先级"><a href="#3-运算符的优先级" class="headerlink" title="3.运算符的优先级"></a>3.运算符的优先级</h2><p><img src="https://i.loli.net/2020/10/09/6aVu9jBoswIgUEY.jpg" srcset="/img/loading.gif" alt="Alt"></p>
<h2 id="4-前置递增运算符与后置递增运算符的运行过程"><a href="#4-前置递增运算符与后置递增运算符的运行过程" class="headerlink" title="4.前置递增运算符与后置递增运算符的运行过程"></a>4.前置递增运算符与后置递增运算符的运行过程</h2><p>前置递增运算符先将对象递增之后再返回递增后的结果，而后置递增运算符则先创建一个临时变量先将旧的值存储起来，然后再将变量递增，再将旧的值返回。<br>相对于前置递增运算符，后置递增运算符需要创建一个临时变量，这就产生了一个消耗，在一些普通的后置递增运算中可能不大可看得出来，但在较为复杂的迭代器中这种额外的消耗就会产生巨大的性能浪费，所以平时使用时尽量使用前置递增运算符。</p>
<h2 id="5-表达式在运算过程中值发生变化"><a href="#5-表达式在运算过程中值发生变化" class="headerlink" title="5.表达式在运算过程中值发生变化"></a>5.表达式在运算过程中值发生变化</h2><p><font color="red">在一个运算表达式中，参与运算的值不应该在运算的过程中发生变化，否则极易造成未定义行为，如：</font><br><font color="red"><code>v[i++]&lt;v[i]</code>，在大于号运算的过程中v[i++]的值向后移动了一位，造成了值的变化，由于C++没有定义二元运算符两端未定义自增运算符的运算顺序，所级就造成了未定义行为。</font></p>
<h2 id="6-有符号数的位运算"><a href="#6-有符号数的位运算" class="headerlink" title="6.有符号数的位运算"></a>6.有符号数的位运算</h2><p>有符号数尽量不要做位运算，因为位运算容易改变有符号数的符号位导致未定义行为。</p>
<h2 id="7-位运算中的类型提升"><a href="#7-位运算中的类型提升" class="headerlink" title="7.位运算中的类型提升"></a>7.位运算中的类型提升</h2><p>在程序编写时需要注意，任何占字节小于int类型的类型变量进行位运算时都会产生类型提升而被转换成int类型，如下代码所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">char</span> s=<span class="hljs-string">&#x27;s&#x27;</span>;<br><span class="hljs-keyword">short</span> a=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">bool</span> b=<span class="hljs-literal">true</span>;<br><span class="hljs-keyword">long</span> c=<span class="hljs-number">2</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(s)&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(~s)&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(s&lt;&lt;<span class="hljs-number">1</span>)&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;----------&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(a)&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(~a)&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;----------&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(b)&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(~b)&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;----------&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(c)&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(~c)&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;----------&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;~s&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;~b&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>输出结果：<br><img src="https://i.loli.net/2020/10/23/GUI54xhOrQs7oyK.jpg" srcset="/img/loading.gif" alt="Alt"></p>
<h2 id="8-sizeof计算指针大小"><a href="#8-sizeof计算指针大小" class="headerlink" title="8.sizeof计算指针大小"></a>8.sizeof计算指针大小</h2><p>sizeof在计算指针时有个很有趣的现象，因为sizeof满足右结合律且优先级与<code>*</code>相同，所以在<code>sizeof *p</code>中，先对p解引用，然后在对解引用后的内容计算所占内存大小，由于sizeof并没有使用解引用的内容，所以<code>*p</code>是否为空是否有效对sizeof的计算没有影响。<br><code>sizeof *p</code> == <code>sizeof(*p)</code></p>
<h2 id="9-隐式转换的过程"><a href="#9-隐式转换的过程" class="headerlink" title="9.隐式转换的过程"></a>9.隐式转换的过程</h2><p>以<code>int a=3.14+3；</code>为例<br>在这个例子中3.14是山比double类型，3是int类型，运算时为了保证精度C++会将int类型转换成double类型，而不是因为结果是int类型而将double类型转换成int类型，所以在表达示右侧的运算过程得到的结果是一个double类型的值，当这个值被赋值给a的时候才进行double到int的类型转换。</p>
<hr>
<h1 id="五、语句"><a href="#五、语句" class="headerlink" title="五、语句"></a>五、语句</h1><hr>
<h2 id="1-switch语句跨case标签引用变量"><a href="#1-switch语句跨case标签引用变量" class="headerlink" title="1.switch语句跨case标签引用变量"></a>1.switch语句跨case标签引用变量</h2><p>若需要在一个 case 语句下定义变量同时在多个 case 语下使用这个变量，则定义变量时不能同时初始化变量，应另起等于初始变量，否则编译器会报跨标签访问错误，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">switch</span> (a)<br>&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">int</span> b;  <span class="hljs-comment">//如果直接int b=1;则会报跨标签访问错误</span><br>        b=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        ;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="2-C-无法捕获计算溢出异常和除0异常"><a href="#2-C-无法捕获计算溢出异常和除0异常" class="headerlink" title="2.C++无法捕获计算溢出异常和除0异常"></a>2.C++无法捕获计算溢出异常和除0异常</h2><p>C++认为计算溢出和除0异常属于底层事件，应被同样底层的事件去处理，所以C++没有提供计算溢出和除0异常，如果需要捕获这两类异常在Windows系统中应使用Windows提供的SEH模型<code>__try</code>、<code>__except</code>、<code>__finally</code>异常语句，使用方法和try-catch基本类似，与try-catch不同的是，SEH中使用的是<code>__try-__except</code>搭配和<code>__try-__finally</code>搭配。</p>
<hr>
<h1 id="六、函数"><a href="#六、函数" class="headerlink" title="六、函数"></a>六、函数</h1><hr>
<h2 id="1-静态局布变量"><a href="#1-静态局布变量" class="headerlink" title="1.静态局布变量"></a>1.静态局布变量</h2><p>在函数体内使用static关键字可以效静态局布量，静态局布变量的生命周期从变量定义到程序结束，但是静态局布变量只对函数可见，在函数外不可访问。</p>
<h2 id="2-C-程序的编译过程"><a href="#2-C-程序的编译过程" class="headerlink" title="2.C++程序的编译过程"></a>2.C++程序的编译过程</h2><p><img src="https://i.loli.net/2020/11/09/bJ5xRFg6TGHnLCO.jpg" srcset="/img/loading.gif" alt="Alt"></p>
<h2 id="3-函数调用过程中的形参创建"><a href="#3-函数调用过程中的形参创建" class="headerlink" title="3.函数调用过程中的形参创建"></a>3.函数调用过程中的形参创建</h2><p>函数的每一次调用都会重新创建形参并传入实参对其进行初始化，形餐盘类型决定了形参与实参的交互类型，如果形参是引用类型，则形参与相对应的实参相绑定，作为实参的别名使用；如果形参是值类型，则实参的值拷贝给形参，形参与实参相互独立。</p>
<h2 id="4-函数的指针参数传递"><a href="#4-函数的指针参数传递" class="headerlink" title="4.函数的指针参数传递"></a>4.函数的指针参数传递</h2><p><font color="red">当指针作为实参传递给函数形参时，传递的是指针的值拷贝而不是指针所指的对象，且形参指针与实参指针是两个不同的指针，此时形参指针与实参指针指向同一对象，修改形参的指针指向不会影实参指针。</font></p>
<h2 id="5-引用形参的限制"><a href="#5-引用形参的限制" class="headerlink" title="5.引用形参的限制"></a>5.引用形参的限制</h2><ul>
<li><p>如果将函数的参数定义普通引用参数，那么这个形参就无法接受const对象、字面值和需要类型转换的对象作为实参。</p>
</li>
<li><p>如果将函数的参数定义为const引用参数，这个参数可以接受第一条中的参数，但是却无法修改参数的值。</p>
</li>
</ul>
<h2 id="6-数组的两个特殊性质"><a href="#6-数组的两个特殊性质" class="headerlink" title="6.数组的两个特殊性质"></a>6.数组的两个特殊性质</h2><ul>
<li>数组不可被拷贝</li>
<li>数组再使用时被转换为指针</li>
</ul>
<h2 id="7-数组引用形参"><a href="#7-数组引用形参" class="headerlink" title="7.数组引用形参"></a>7.数组引用形参</h2><p>当我们使用数组作普通形参时，</p>
<figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">void <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(int* arr)</span></span>;<br>void <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(int arr[])</span></span>;<br>void <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(int arr[<span class="hljs-number">10</span>])</span></span>;<br></code></pre></div></td></tr></table></figure>
<p>表示的都是同一个函数，且形参可接受任意长度的实参数组，但是当将普通形参改为引用形参时，</p>
<figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">void <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(int (&amp;arr)</span></span>[<span class="hljs-number">10</span>]);<br></code></pre></div></td></tr></table></figure>
<p><code>(&amp;arr)</code>中()不可缺少，否则形参变成引用的数组而非数组的引用，且形参只能接收长度为10的数组。</p>
<h2 id="8-main函数传参"><a href="#8-main函数传参" class="headerlink" title="8.main函数传参"></a>8.main函数传参</h2><p>有的时候我们会遇到这样的main函数：</p>
<figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>通常情况下，直接使用argv，argv中的内容是空的，那么main函数在什么情况下会接收参数呢？<br>事实上main函数本身就是当前程序的入口，在当前程序中没有其他程序为main函数传入参数了，当我们把写好的程序打包后在外部调用时就可以给main函数传入参数了，如在CMD中调程序</p>
<figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">prog -o -d ofile data0<span class="hljs-regexp">//</span>prog为程序名<br></code></pre></div></td></tr></table></figure>
<p><font color="red">需要注意的是argv数组的0号索引存储程序的名字，参数从1号索引开始存储，且最后一个索引位置固定内容为0</font></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/CPlus/">CPlus</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/02/04/%E3%80%90Python%E3%80%91Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">【Python】Python学习笔记</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/02/03/%E3%80%90Dev%E3%80%91DevExpress%E5%BA%94%E7%94%A8/">
                        <span class="hidden-mobile">【Dev】DevExpress应用</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://github.com/" target="_blank" rel="nofollow noopener"><span>Github</span></a> <i class="iconfont icon-love"></i> <a href="https://mp.csdn.net/console/article" target="_blank" rel="nofollow noopener"><span>CSDN</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
