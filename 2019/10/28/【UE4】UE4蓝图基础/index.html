<!DOCTYPE html>
<html lang="zh-CN">





<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
    <link rel="icon" type="image/png" href="/img/favicon.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="description" content>
    <meta name="author" content="John Doe">
    <meta name="keywords" content>
    <title>【UE4】UE4蓝图基础 ~ Goulandis</title>
    <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css?v=5.7.2">
    <link rel="stylesheet" href="/lib/mdbootstrap/css/bootstrap.min.css?v=4.3.1">
    <link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css?v=4.8.7">
    <link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css">
    <link rel="stylesheet" href="/lib/nprogress/nprogress.css?v=0.2.0">
    <link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">
    
        <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css">
    
    <link rel="stylesheet" href="/css/main.css">

    
</head>


<body>
<header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
<div class="container">
    <a class="navbar-brand" href="/">&nbsp;<strong>Goulandis</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ml-auto text-center">
            
            <li class="nav-item">
                <a class="nav-link" href="/">主页</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/archives/">归档</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/categories/">分类</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/tags/">标签</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/about/">关于</a>
            </li>
            
            
                <li class="nav-item" id="search-btn">
                    <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
                </li>
            
        </ul>
    </div>
</div>


</nav>
    <div class="view intro-2"
         style="background: url('/img/2.png')no-repeat center center;background-size: cover;">
        <div class="full-bg-img">
            <div class="mask rgba-black-light flex-center">
                <div class="container text-center white-text wow fadeInUp">
                    <span class="h2" id="subtitle">
                        
                    </span>
                    
                        <br>
                        <p>Monday, October 28th 2019, 9:17 pm</p>
                    
                </div>
            </div>
        </div>
    </div>
</header>

<main>
    
        

<div class="container-fluid">
    <div class="row">
        <div class="d-none d-lg-block col-lg-2"></div>
            <div class="col-lg-8 nopadding-md">
                <div class="py-5 z-depth-3 board">
                    <div class="post-content mx-auto">
                        <div class="markdown-body">
                            <h1 id="一、蓝图可视化脚本与蓝图系统"><a href="#一、蓝图可视化脚本与蓝图系统" class="headerlink" title="一、蓝图可视化脚本与蓝图系统"></a>一、蓝图可视化脚本与蓝图系统</h1><h2 id="1-蓝图脚本"><a href="#1-蓝图脚本" class="headerlink" title="1.蓝图脚本"></a>1.蓝图脚本</h2><p>蓝图可视化脚本简称“蓝图”或“蓝图脚本”，是一种需要编译的面向对象的可视化编程语言，蓝图完全集成在UE4中，蓝图通过节点与连线工作。</p>
<h3 id="蓝图脚本的节点"><a href="#蓝图脚本的节点" class="headerlink" title="蓝图脚本的节点"></a>蓝图脚本的节点</h3><ul>
<li>触发事件，在蓝图脚本中以红色的节点出现</li>
<li>函数，在看图脚本中以蓝色的节点出现</li>
<li>变量，在蓝图脚本中中以黄色节点出现</li>
</ul>
<h2 id="2-蓝图系统"><a href="#2-蓝图系统" class="headerlink" title="2.蓝图系统"></a>2.蓝图系统</h2><p>蓝图系统又称“蓝图”或“蓝图类”，蓝图类可以看成是一个包含游戏内容的容器，其中可以包含组件、脚本或可以仅仅包含数据。</p>
<p>蓝图类有点类似Unity3d中的预设(prefb)，蓝图类可以类似预设一般保存对象状态，可以随时拖入场景中使用，只是在其他功能上不如预设，如预设在U3D中的打包中可以发挥出优秀的效果，但是蓝图类只能作为容器使用。</p>
<p><font color="red"> 蓝图类包含蓝图脚本，每一个蓝图类都包含一个默认的蓝图脚本。</font></p>
<h3 id="蓝图类的分类"><a href="#蓝图类的分类" class="headerlink" title="蓝图类的分类"></a>蓝图类的分类</h3><ul>
<li><strong>关卡蓝图</strong>：关卡蓝图在每个Level中只能存在一个，负责整个关卡的运行逻辑，关卡的初始化，帧更新都在关卡蓝图里进行；</li>
<li><strong>普通蓝图</strong>：普通蓝图就是UE4的预设，在普通蓝图中我们可以对其中的对象进行一些的配置，如设置网格，贴图，粒子特效，添加相机，添加物理材质和挂载蓝图脚本等等；</li>
<li><strong>游戏模式蓝图</strong>：UE4中游戏模式也是以蓝图的形式存在的，游戏模式蓝图控制一系列游戏的规则；</li>
<li><strong>材质蓝图</strong>：在UE4中贴图材质也是蓝图的形式存在的，在材质蓝图中我们可以如同建模软件一般对材质进行一系列更高级的材质配置，如下图的一个简单示例：</li>
</ul>
<p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-24_09-41-27.png" alt></p>
<h2 id="4-创建蓝图"><a href="#4-创建蓝图" class="headerlink" title="4.创建蓝图"></a>4.创建蓝图</h2><p>创建蓝图的方法很多，这里介绍比较常用的方法</p>
<ul>
<li>可以直接在Content Browser(内容浏览器)中右键创建一个空的蓝图类，空蓝图除了包含一个根组件外不再包含其他东西，当我们在空蓝图中创建了对象后可以通过拖拽的方式将对象拖动到根组件位置处，用游戏对象替换根组件作为根组件，这样创建空蓝图时的白色小球就会消失；</li>
<li>在World Outliner(世界大纲)中选中游戏对象，可以通过工具栏中的Blueprints工具中的下面两个选项创建一个包含所选内容的蓝图类；</li>
</ul>
<p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-24_09-51-55.png" alt></p>
<ul>
<li>通过Blueprints工具的New Empty Blueprint Class也可以直接创建空蓝图类；</li>
<li>然而关卡蓝图似乎只能通过Blueprints工具的Open Blueprint Class打开。</li>
</ul>
<h1 id="二、变量与对象引用"><a href="#二、变量与对象引用" class="headerlink" title="二、变量与对象引用"></a>二、变量与对象引用</h1><h2 id="1-在蓝图中创建变量"><a href="#1-在蓝图中创建变量" class="headerlink" title="1.在蓝图中创建变量"></a>1.在蓝图中创建变量</h2><p>在蓝图中创建变量的方式有两种，其一：直接点击My BluePrint/Variables/+Variable，默认创建bool行的变量，可以点击变量前的色块更换变量类型。</p>
<p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-25_17-18-23.png" alt></p>
<p>其二：在蓝图脚本区域右键-&gt;输入Get New Var，可以直接在蓝图脚本中以节点的形式创建变量，在右侧细节面板中设置变量的值。</p>
<p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-25_17-23-27.png" alt></p>
<p>所有创建好的变量都会在My Blueprint面板Variables栏中显示。</p>
<p><font color="red"> 在创建好的变量的Details/Variable/Variable Type选项中可以设置变量为普通变量、数组、Set容器和Map容器。</font></p>
<p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-27_11-01-39.png" alt></p>
<h2 id="2-在蓝图中使用变量"><a href="#2-在蓝图中使用变量" class="headerlink" title="2.在蓝图中使用变量"></a>2.在蓝图中使用变量</h2><p>可以直接在蓝图脚本区域右键-&gt;输入Get/Set [变量名]即可获取变量的获取/设置组件，也可以直接从左侧的My Blueprint面板Variables栏中拖拽变量到蓝图脚本区域选择Get/Set。</p>
<h2 id="3-生成时公开与私有变量"><a href="#3-生成时公开与私有变量" class="headerlink" title="3.生成时公开与私有变量"></a>3.生成时公开与私有变量</h2><p>蓝图中的公有与私有与程序中的公有私有有一些不同，蓝图中只分为生成时公开和私有两种访问权限。</p>
<h3 id="生成时公开-Expose-on-Spawn"><a href="#生成时公开-Expose-on-Spawn" class="headerlink" title="生成时公开(Expose on Spawn)"></a>生成时公开(Expose on Spawn)</h3><p>勾选生成时公开后，在蓝图类使用Spawn Actor from Class组件生成蓝图类实例时，勾选生成时公开的变量将可以接受外部值输入。<br><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-28_16-45-41.png" alt></p>
<p>如上图可以看到勾选生成时公开的变量会以输入接口的形式出现在Spawn Actor from Class节点里。这里需要注意的是，勾选Expose on Spawn，还需要勾选Instance Editable，否则会报警告。</p>
<h3 id="私有变量-Private"><a href="#私有变量-Private" class="headerlink" title="私有变量(Private)"></a>私有变量(Private)</h3><p>设置成私有变量的变量只能在蓝图类里访问，蓝图类的外部实例也无法访问这个变量，如上图，变量L没有设置成私有，所以可以通过Spawn Actor from Class组件生成的实例访问这个变量，而设置成私有的K变量搜索不到Set K节点。</p>
<h2 id="3-在蓝图中使用组件引用"><a href="#3-在蓝图中使用组件引用" class="headerlink" title="3.在蓝图中使用组件引用"></a>3.在蓝图中使用组件引用</h2><p>很多时候我们需要调节自身Actor上的组件的某些参数，那么我们就需要获得这个组件的引用以便获取组件上的参数进行调节，那么我们如何获得组件的引用呢？</p>
<p>其实方法也很简单，在My Blueprint/Variabales下有一个子栏“Components”其中存放着当前Actor上的所有的组件的引用，使用方法就是直接将需要的组件引用拖拽到蓝图脚本区域即可。获得了组件引用我们就可以通过引用使用不同的方法获取组件上的不同的参数了。</p>
<h2 id="4-动态获取世界大纲中的Actor"><a href="#4-动态获取世界大纲中的Actor" class="headerlink" title="4.动态获取世界大纲中的Actor"></a>4.动态获取世界大纲中的Actor</h2><p>在蓝图脚本中有四个方法获取外部Actor：</p>
<ul>
<li>Get All Actor of Class：通过类型来获取外部Actor</li>
</ul>
<p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-31-16.png" alt></p>
<ul>
<li>Get All Actor with Tag：通过标签来获取外部Actor</li>
</ul>
<p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-31-23.png" alt></p>
<ul>
<li>Get All Actor with Interface：通过外部接口在获取外部Actor</li>
</ul>
<p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-31-36.png" alt></p>
<ul>
<li>Get Actors：通过层来获取Actor</li>
</ul>
<p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-31-47.png" alt></p>
<h1 id="三、蓝图的数据类型"><a href="#三、蓝图的数据类型" class="headerlink" title="三、蓝图的数据类型"></a>三、蓝图的数据类型</h1><h2 id="1-5个基本数据类型"><a href="#1-5个基本数据类型" class="headerlink" title="1.5个基本数据类型"></a>1.5个基本数据类型</h2><p>UE4蓝图中基本数据类型只有5个，需要注意的是蓝图中没有char、double、short、long等数据类型，在C++与蓝图的配合使用时需要注意这些类型的变量。</p>
<h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><h3 id="Byte"><a href="#Byte" class="headerlink" title="Byte"></a>Byte</h3><p>8位，一字节，0-255。</p>
<h3 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h3><p>32位整型，四字节。</p>
<h3 id="Integer64"><a href="#Integer64" class="headerlink" title="Integer64"></a>Integer64</h3><p>64位整型，八字节，能存储更大的数。</p>
<h3 id="Float"><a href="#Float" class="headerlink" title="Float"></a>Float</h3><p>32位单精度浮点型，其中1符号位、8指数位、23数值位，UE4中默认保留小数点后6位。UE4中只有Float类型没有Double类型。</p>
<h2 id="2-3种字符串"><a href="#2-3种字符串" class="headerlink" title="2.3种字符串"></a>2.3种字符串</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>蓝图中String类型就是蓝图C++中的FString类型，普通字符串，可以对其中的字符进行增删查改。</p>
<h3 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h3><p>Name是一种固定字符串类型，变量初始化以后不能在对其中的内容进行修改，且Name类型的字符串不区分大小写，多用于作为全局变量来唯一标识对象。Name类型的字符串在运行过程中存储于内存的字符串表中，使用效率高。</p>
<h3 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h3><p>Text是String的长度加强版，通常用于存储一段文字并可以进行国际化处理。</p>
<h2 id="3-Vector-维度向量"><a href="#3-Vector-维度向量" class="headerlink" title="3.Vector(维度向量)"></a>3.Vector(维度向量)</h2><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>默认创建的Vector是Vector 3D，即三维量，包含x、y、z三个值，可以表示任何任何三维量，如：三维坐标和RGB等。</p>
<h3 id="Vector-2D-和Vector-4"><a href="#Vector-2D-和Vector-4" class="headerlink" title="Vector 2D 和Vector 4"></a>Vector 2D 和Vector 4</h3><p>Vector 2D就是二维量，Vector 4就是四维量，常用于表示四元素。</p>
<h3 id="Two-Vectors"><a href="#Two-Vectors" class="headerlink" title="Two Vectors"></a>Two Vectors</h3><p>Two Vectors就是一个关于Vector的pair(对组)，pair在C++的STL种较为常用，是一个只包含两个元素的容器。</p>
<h2 id="4-Rotator-三维旋转量"><a href="#4-Rotator-三维旋转量" class="headerlink" title="4.Rotator(三维旋转量)"></a>4.Rotator(三维旋转量)</h2><p>包含：</p>
<p>x：roll，翻滚角，以x为轴，进行yz平面的旋转；</p>
<p>y：pitch，俯仰角，以y为轴，进行xz平面的旋转；</p>
<p>z：yaw，航向角，以z为轴，进行xy平面的旋转。</p>
<h2 id="5-Transform"><a href="#5-Transform" class="headerlink" title="5.Transform"></a>5.Transform</h2><p>Transfrom类型是一个3*3的矩阵，包含Location、Rotation和Scale三个三维向量。</p>
<h1 id="四、条件语句"><a href="#四、条件语句" class="headerlink" title="四、条件语句"></a>四、条件语句</h1><h2 id="1-Branch-if条件判断"><a href="#1-Branch-if条件判断" class="headerlink" title="1.Branch(if条件判断)"></a>1.Branch(if条件判断)</h2><p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-39-15.png" alt></p>
<p>传入一个bool值，进行分流，通常和比较组件配合使用，如：“==”、“&gt;”等。</p>
<h2 id="2-Switch"><a href="#2-Switch" class="headerlink" title="2.Switch"></a>2.Switch</h2><p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-25_19-14-34.png" alt></p>
<ul>
<li>Selection：case判断的变量；</li>
<li>Default：默认执行分支；</li>
<li>Add pin：添加执行分支。</li>
</ul>
<h1 id="五、循环语句"><a href="#五、循环语句" class="headerlink" title="五、循环语句"></a>五、循环语句</h1><h2 id="1-For-Loop-for循环"><a href="#1-For-Loop-for循环" class="headerlink" title="1.For Loop(for循环)"></a>1.For Loop(for循环)</h2><p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-39-35.png" alt></p>
<ul>
<li>First Index/Last Index：提供循环的次数；</li>
<li>Loop Body：循环体执行分支；</li>
<li>Index：返回当前循环索引；</li>
<li>Conpleted：循环完毕后执行分支。</li>
</ul>
<h2 id="2-For-Loop-whit-Break-可跳出的for循环"><a href="#2-For-Loop-whit-Break-可跳出的for循环" class="headerlink" title="2.For Loop whit Break(可跳出的for循环)"></a>2.For Loop whit Break(可跳出的for循环)</h2><p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-39-52.png" alt></p>
<p>使用方法和For Loop类似。</p>
<h2 id="3-For-Each-Loop-数组遍历"><a href="#3-For-Each-Loop-数组遍历" class="headerlink" title="3.For Each Loop(数组遍历)"></a>3.For Each Loop(数组遍历)</h2><p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-40-45.png" alt></p>
<p>专门有用遍历数组的循环。</p>
<ul>
<li>Array：需要遍历的数组；</li>
<li>Loop Body：循环体分支；</li>
<li>Array Element：遍历的数组元素；</li>
<li>Array Index：当前索引；</li>
<li>Completed：遍历结束执行分支。</li>
</ul>
<h2 id="4-For-Each-Loop-with-Break-可跳出的数组遍历"><a href="#4-For-Each-Loop-with-Break-可跳出的数组遍历" class="headerlink" title="4.For Each Loop with Break(可跳出的数组遍历)"></a>4.For Each Loop with Break(可跳出的数组遍历)</h2><p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-40-54.png" alt></p>
<p>用法和Foreach Loop一样，只是多了一个跳出执行分支。</p>
<h2 id="5-Reverse-for-Each-Loop-反向数组遍历"><a href="#5-Reverse-for-Each-Loop-反向数组遍历" class="headerlink" title="5.Reverse for Each Loop(反向数组遍历)"></a>5.Reverse for Each Loop(反向数组遍历)</h2><p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-25_18-40-59.png" alt></p>
<h2 id="6-While-Loop-while循环"><a href="#6-While-Loop-while循环" class="headerlink" title="6.While Loop(while循环)"></a>6.While Loop(while循环)</h2><p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-27_11-04-21.png" alt></p>
<h1 id="六、数组"><a href="#六、数组" class="headerlink" title="六、数组"></a>六、数组</h1><h2 id="1-创建数组"><a href="#1-创建数组" class="headerlink" title="1.创建数组"></a>1.创建数组</h2><p>创建数组要比创建变量多一个步骤，首先我们需要创建一个变量，然后再将这个变量的Details/Varialble Type选项的右侧色块选择九宫格，即可将对应变量转换成对应类型的数组。</p>
<p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-02-54.png" alt></p>
<h2 id="2-为数组赋值"><a href="#2-为数组赋值" class="headerlink" title="2.为数组赋值"></a>2.为数组赋值</h2><h3 id="Add-Array"><a href="#Add-Array" class="headerlink" title="Add(Array)"></a>Add(Array)</h3><p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-21-48.png" alt></p>
<p>传入一个数组和一个元素即可通过Add(Array)组件为组数赋值</p>
<p>如：</p>
<p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-24-33.png" alt></p>
<p>循环完毕后数组Array内便存储有0-10的是个int型元素。</p>
<h2 id="3-获取元素"><a href="#3-获取元素" class="headerlink" title="3.获取元素"></a>3.获取元素</h2><h3 id="Get-a-copy"><a href="#Get-a-copy" class="headerlink" title="Get(a copy)"></a>Get(a copy)</h3><p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-07-50.png" alt></p>
<p>获取指定索引的元素的拷贝。</p>
<h3 id="Get-a-ref"><a href="#Get-a-ref" class="headerlink" title="Get(a ref)"></a>Get(a ref)</h3><p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-07-44.png" alt></p>
<p>获取指定索引的元素的引用。</p>
<h2 id="4-插入元素"><a href="#4-插入元素" class="headerlink" title="4.插入元素"></a>4.插入元素</h2><h3 id="Add-Aray"><a href="#Add-Aray" class="headerlink" title="Add(Aray)"></a>Add(Aray)</h3><p>直接在数组的末尾插入元素的方法也是使用Add(Array)组件，Add(Array)组件的的插入过程就是直接在数组的末尾插入元素。</p>
<h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-37-55.png" alt></p>
<p>指定位置插入使用Insert组件，输入参数从上至下依次为目标数组、要插入的元素、目标插入的索引位置。</p>
<p>当要使用Insert组件在数组末尾插入，而又不知道数组大小时，可以使用Last Index组件直接获取输入数组的尾索引，当然直接使用只会在最后一个索引位置插入，而使最后一位元素向后移动一位，而达不到在数组尾部插入的效果，所以需要加一食用。</p>
<p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-46-46.png" alt></p>
<h3 id="Set-Array-Elem"><a href="#Set-Array-Elem" class="headerlink" title="Set Array Elem"></a>Set Array Elem</h3><p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-25-34.png" alt></p>
<p>设置输入数组指定索引的元素的值，Size to Fit选项可以设置如果指定索引不存在时数组自动扩充size大小。</p>
<h2 id="5-查找元素"><a href="#5-查找元素" class="headerlink" title="5.查找元素"></a>5.查找元素</h2><h3 id="Contains-Item"><a href="#Contains-Item" class="headerlink" title="Contains Item"></a>Contains Item</h3><p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-50-31.png" alt></p>
<p>Contains Item组件可以查找指定数组中是否包含某一元素，但是Contains Item只返回bool的判断结果，不会返回目标的索引值。</p>
<h3 id="Find-Item"><a href="#Find-Item" class="headerlink" title="Find Item"></a>Find Item</h3><p><img src="/2019/10/28/【UE4】UE4蓝图基础/Git/Temp/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80/Snipaste_2019-10-26_11-59-54.png" alt></p>
<p>Find Item则是从输入数组中查找指定元素并返回第一次查找到该元素的索引值。</p>
<h2 id="6-删除元素"><a href="#6-删除元素" class="headerlink" title="6.删除元素"></a>6.删除元素</h2><h3 id="Remove-Index"><a href="#Remove-Index" class="headerlink" title="Remove Index"></a>Remove Index</h3><p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-12-59.png" alt></p>
<p>通过索引删除元素</p>
<h3 id="Remove-Item"><a href="#Remove-Item" class="headerlink" title="Remove Item"></a>Remove Item</h3><p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-21-30.png" alt></p>
<p>从输入数组中移除指定元素，Remove Item会删除数组中所有指定的元素，如果删除成功则返回true，失败则返回false。</p>
<h2 id="7-筛选元素"><a href="#7-筛选元素" class="headerlink" title="7.筛选元素"></a>7.筛选元素</h2><h3 id="Filter-Array"><a href="#Filter-Array" class="headerlink" title="Filter Array"></a>Filter Array</h3><p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-53-49.png" alt></p>
<p>过滤数组可以按类型来筛选数组元素，用于父类型数组存储子类型元素时进行类型筛选，如：Actor数组筛选MyClass类型元素，Filter Array返回一个筛选后的新数组。</p>
<h2 id="8-清空数组"><a href="#8-清空数组" class="headerlink" title="8.清空数组"></a>8.清空数组</h2><p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-26_11-42-24.png" alt></p>
<p>使用Clear组件可以将数组内的元素全部清空。</p>
<h2 id="9-获取数组长度"><a href="#9-获取数组长度" class="headerlink" title="9.获取数组长度"></a>9.获取数组长度</h2><p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-29-34.png" alt></p>
<h2 id="10-设置数组长度"><a href="#10-设置数组长度" class="headerlink" title="10.设置数组长度"></a>10.设置数组长度</h2><p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-26_12-30-00.png" alt></p>
<h1 id="七、结构体"><a href="#七、结构体" class="headerlink" title="七、结构体"></a>七、结构体</h1><h2 id="1-结构体创建"><a href="#1-结构体创建" class="headerlink" title="1.结构体创建"></a>1.结构体创建</h2><p>蓝图中结构体的创建是没办法在蓝图脚本视图中创建的，UE4蓝图中结构体是与蓝图脚本同级的蓝图类，创建蓝图结构体的方法：在Content Browser中右键-&gt;Create Advanced Assect/Blueprint栏-&gt;Structure，即可创建一个结构体，创建出来的结构体默认拥有一个bool值得成员变量。</p>
<p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-26_17-38-54.png" alt></p>
<h2 id="2-定义成员变量"><a href="#2-定义成员变量" class="headerlink" title="2.定义成员变量"></a>2.定义成员变量</h2><p>蓝图中得结构体只能创建成员变量，不能创建成员函数，成员变量可以直接设置默认值。</p>
<p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-26_19-59-29.png" alt></p>
<h2 id="3-结构的使用"><a href="#3-结构的使用" class="headerlink" title="3.结构的使用"></a>3.结构的使用</h2><p>将结构体创建好以后便可以直接在蓝图脚本中搜索到并使用了。</p>
<h1 id="八、枚举"><a href="#八、枚举" class="headerlink" title="八、枚举"></a>八、枚举</h1><h2 id="1-枚举的创建"><a href="#1-枚举的创建" class="headerlink" title="1.枚举的创建"></a>1.枚举的创建</h2><p>枚举的创建和使用和结构体区别不大，创建方式一如结构体一般,Content Browser中右键-&gt;Create Advanced Assect/Blueprint栏-&gt;Enumeration，创建好后UE4也会在一个新的视图中对枚举进行编辑，枚举的编辑操作也相当简单，只有向枚举中添加与删除元素的操作，这些元素都可以添加注解提示，枚举也可以添加整个枚举的注解提示。</p>
<h2 id="2-枚举的使用"><a href="#2-枚举的使用" class="headerlink" title="2.枚举的使用"></a>2.枚举的使用</h2><p>枚举的使用就如同变量的使用一般，没有什么可说的。</p>
<h1 id="九、接口"><a href="#九、接口" class="headerlink" title="九、接口"></a>九、接口</h1><h2 id="1-接口的定义"><a href="#1-接口的定义" class="headerlink" title="1.接口的定义"></a>1.接口的定义</h2><p>接口的定义和和蓝图函数库，蓝图宏库一样，但是接口的不像函数库和宏库一般可以再一个蓝图类中定义多个函数和宏，接口就是一个蓝图类，并且接口的编辑界面及其简约，可编辑视图只有一个My Blueprint和一个Detials,在My Blueprint/Functions栏可以新建接口函数，在对应的接口函数的Details/Graph可以设置一些接口函数的描述和Const属性，在Details/Inputs和Outputs栏可以设置接口函数的输入与输出参数。</p>
<h2 id="2-接口的继承"><a href="#2-接口的继承" class="headerlink" title="2.接口的继承"></a>2.接口的继承</h2><p>接口是一个抽象蓝图，接口的实现必须通过继承接口的蓝图来实现，在蓝图中接口继承通过Toolbar/Class Settings/Interfaces栏即可添加接口到当前蓝图类是指继承此接口。</p>
<h2 id="3-接口的实现"><a href="#3-接口的实现" class="headerlink" title="3.接口的实现"></a>3.接口的实现</h2><h3 id="无返回值的接口实现"><a href="#无返回值的接口实现" class="headerlink" title="无返回值的接口实现"></a>无返回值的接口实现</h3><p>在一个蓝图继承了一个无返回值得接口后，这个接口将以事件的形式出现在这个蓝图类的All Actions for this Blueprint里</p>
<p>如：</p>
<p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-27_10-32-38.png" alt></p>
<p>蓝图以这个事件作为接口函数的入口，以此节点开始便可以开始实现各个蓝图类各自继承的接口函数的逻辑了。</p>
<h3 id="有返回值得接口实现"><a href="#有返回值得接口实现" class="headerlink" title="有返回值得接口实现"></a>有返回值得接口实现</h3><p>有返回值的接口不会以事件的形式出现在Add Event里，而是会直接出现在My Blueprint/Interface栏里，我们双击即可打开接口函数的编辑视图，在视图中实现接口即可。</p>
<p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-28_17-00-10.png" alt></p>
<h2 id="4-接口函数的调用"><a href="#4-接口函数的调用" class="headerlink" title="4.接口函数的调用"></a>4.接口函数的调用</h2><p>蓝图通过<code>[接口名](Mesasge)</code>组件来调用接口中的函数，如下图中的Interface1(Message)和Interface2(Message)。</p>
<p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-27_10-35-51.png" alt></p>
<p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-27_10-38-13.png" alt></p>
<p>接口的使用需要指定使用的接口是哪个蓝图类中实现的接口和接口需要传入的参数。在蓝图类的My Blueprint/Variables栏是可以搜索到我们自己创建的蓝图类的，通过过去蓝图类的引用便可以指定接口函数的实现者了。当然我们也可以使用Get All Actors with Interface组件来获取实现了指定接口的所有蓝图类，然后再对这些蓝图类中实现的函数进行调用。</p>
<h1 id="十、蓝图函数库"><a href="#十、蓝图函数库" class="headerlink" title="十、蓝图函数库"></a>十、蓝图函数库</h1><p><font color="red"> 蓝图函数库是一个可以被所有蓝图类调用的函数集合，蓝图函数库里的方法全部都被定义为静态方法</font>，用于定义一些不与特定游戏对象绑定的功能性函数的实现。</p>
<h2 id="1-创建蓝图函数库"><a href="#1-创建蓝图函数库" class="headerlink" title="1.创建蓝图函数库"></a>1.创建蓝图函数库</h2><p>创建蓝图函数库的方式和创建结构体类似，在Content Browser中右键-&gt;Create Advanced Assect/Blueprint栏-&gt;Bluprint Function LiberLibrary。</p>
<h2 id="2-实现蓝图函数库里的函数"><a href="#2-实现蓝图函数库里的函数" class="headerlink" title="2.实现蓝图函数库里的函数"></a>2.实现蓝图函数库里的函数</h2><p>和结构体一样，创建好的蓝图函数库UE4会创建一个新的界面用于编辑库里函数；</p>
<ul>
<li>在My Blueprint/Functions栏可以申明函数</li>
<li>在My Blueprint/Local Variables栏可以生命局部变量，在其Details中可以设置局部变量默认值；</li>
<li>在对应函数的Details/Input和Output栏可以分别设置函数的输入输出参数</li>
<li>在脚本编辑区可以实现函数逻辑。</li>
</ul>
<h2 id="3-使用蓝图函数库里的函数"><a href="#3-使用蓝图函数库里的函数" class="headerlink" title="3.使用蓝图函数库里的函数"></a>3.使用蓝图函数库里的函数</h2><p>要使用蓝图函数库里的函数，可直接在脚本编辑区右键输入函数名即可在Class栏中看到蓝图函数库里的函数了。</p>
<h1 id="十一、蓝图宏库"><a href="#十一、蓝图宏库" class="headerlink" title="十一、蓝图宏库"></a>十一、蓝图宏库</h1><p>宏在UE4中几乎无处不在，蓝图宏库是开发者使用蓝图自定义的一系列的宏的容器，蓝图宏库和蓝图函数库一样可以定义多个宏；</p>
<ul>
<li>蓝图宏库与蓝图函数库不同的是，蓝图宏库中的宏是在预编译过程中完成处理的，即蓝图宏库不需要编译；</li>
<li>自定义的宏，可以有任意数量的输入输出引脚，即一个宏可以没有输出引脚，这样的宏可以只进行数据处理，一个宏也可以有多个输入输出引脚，这样的宏可以根据不同的逻辑选择不同的执行流，而蓝图函数库中的函数必须有且只有一个输入和一个输出引脚；</li>
<li>与函数不同，宏中不可以再定义成员变量，即宏只负责处理逻辑，不提供暂存能力。</li>
</ul>
<h2 id="1-创建蓝图宏库"><a href="#1-创建蓝图宏库" class="headerlink" title="1.创建蓝图宏库"></a>1.创建蓝图宏库</h2><p>宏库的创建与函数库的创建是一样的，在Content Browser中右键-&gt;Create Advanced Assect/Blueprint栏-&gt;Bluprint Macro LiberLibrary。</p>
<h2 id="2-蓝图宏声明"><a href="#2-蓝图宏声明" class="headerlink" title="2.蓝图宏声明"></a>2.蓝图宏声明</h2><ul>
<li>在My Blueprint/Macro中可以声明一个宏；</li>
<li>在指定宏的Details/Inputs和Outputs中可以定义输入与输出引脚和参数。</li>
</ul>
<h2 id="3-蓝图宏的使用"><a href="#3-蓝图宏的使用" class="headerlink" title="3.蓝图宏的使用"></a>3.蓝图宏的使用</h2><p>和蓝图函数的使用方法一致。</p>
<h2 id="4-自定义流程控制"><a href="#4-自定义流程控制" class="headerlink" title="4.自定义流程控制"></a>4.自定义流程控制</h2><p>除了蓝图提供给我们的条件语句和循环语句等流程控制语句外，我还可以使用宏编写自己的流程控制，因为宏可以有多个输入和输出引脚，使用方法就是使用宏的形式定义自己的流程控制逻辑，通过不同的输入给予不同输出，即可达到自定义流程控制的目的。</p>
<h1 id="十二、事件"><a href="#十二、事件" class="headerlink" title="十二、事件"></a>十二、事件</h1><p>除了UE4蓝图中给我们提供大量的预定义事件，我也可以自定义事件。</p>
<h2 id="1-事件的定义"><a href="#1-事件的定义" class="headerlink" title="1.事件的定义"></a>1.事件的定义</h2><p>事件的定义也很简单，在All Actions for this Buleprint中选择Add Custom Event，便可以创建一个自定义事件的入口，之后通过这个入口实现事件的内部逻辑，一个事件便定义完成。</p>
<h2 id="2-事件的调用"><a href="#2-事件的调用" class="headerlink" title="2.事件的调用"></a>2.事件的调用</h2><p>事件调用必须通过实现这个事件的蓝图类才可以对其中的事件进行调用。如：</p>
<p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-27_11-28-43.png" alt></p>
<p>Event Blueprint为实现自定义事件的蓝图类；</p>
<p>Print Str为自定义事件。</p>
<h2 id="3-事件调度器"><a href="#3-事件调度器" class="headerlink" title="3.事件调度器"></a>3.事件调度器</h2><p>事件调度器的创建与使用请阅读目录：十七、蓝图类的通信/3.使用事件调度器进行通信</p>
<h1 id="十三、蓝图模块"><a href="#十三、蓝图模块" class="headerlink" title="十三、蓝图模块"></a>十三、蓝图模块</h1><p>蓝图中可以将一个复杂了逻辑处理合并成一个节点模块，从而简化整体的执行流复杂度，使蓝图的执行流变得简单明了。我们可以将需要合并的执行流多选选中然后右键，即可在Organization栏中通过Collapse Nodes选项来合并执行流。</p>
<p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-27_11-31-04.png" alt></p>
<p>除了将执行流合并成节点外，蓝图还提供将多个执行流合并成一个函数或一个宏的功能。合并好的模块也可以在Organizition/Expand Node进行模块分离。</p>
<h1 id="十四、角色控制"><a href="#十四、角色控制" class="headerlink" title="十四、角色控制"></a>十四、角色控制</h1><h2 id="1-为角色添加跟随相机"><a href="#1-为角色添加跟随相机" class="headerlink" title="1.为角色添加跟随相机"></a>1.为角色添加跟随相机</h2><p>相对U3D来说，UE4的相机跟随要简单得多，UE4中直接将相机设置成了蓝图类的组件，当蓝图类时Player时，即可实现相机对Player的跟随了。</p>
<p>相机跟随需要通过一个物理组件<code>Spring Arm</code>来链接相机和Player，将相机附着在Spring Arm下，即可在Spring Arm的作用下实现相机跟随。</p>
<p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-24_10-45-29.png" alt></p>
<h2 id="2-为角色添加控制器"><a href="#2-为角色添加控制器" class="headerlink" title="2.为角色添加控制器"></a>2.为角色添加控制器</h2><p>在UE4的游戏制作过程中，我们不难发现当我们运行游戏时，在世界大纲中多出了很多东西，如下图：</p>
<p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-24_10-53-34.png" alt></p>
<p>其实，UE4为我们提供很多已经预制好的必须品，如上图的PlayerController(角色控制器)、PlayerCameraMenager(角色相机管理器)等。也就是说不可以直接使用UE4预制给我们的角色控制器来控制我们的Player，而不需要自己再去为Player蓝图配置角色控制器了，我们只需将Player的细节面板上的Auto Possess Player设置成Player0即可，Player0即表示本地角色。</p>
<p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-24_10-53-06.png" alt></p>
<p>需要注意的是，对于角色控制更优的方式是使用<code>Player Start</code>组件去持有Player蓝图类，再通过Player Controller来控制Player Start达到控制角色的目的。</p>
<h2 id="3-自定义游戏模式"><a href="#3-自定义游戏模式" class="headerlink" title="3.自定义游戏模式"></a>3.自定义游戏模式</h2><p>在我们创建一个UE4工程后，UE4会启用UE4默认的游戏模式<code>GameModeBase</code>，GameModeBase就控制着Player Controller、PlayerCameraMenager、PlayerState等运行时UE4动态生成的一些游戏物体，我们可以通过启用我们自定义的游戏模式来设置这些游戏物体按自己的定义的规则来生成运行。</p>
<p>游戏模式也是一个蓝图类，创建游戏模式就是创建蓝图类，只是这个蓝图类需要继承自GameModeBase类，继承自GameModeBase类的蓝图就是一个游戏模式蓝图。不过在我们第一此=次打开游戏模式蓝图时，UE4会将游戏模式蓝图识别成一个普通蓝图，而进入普通蓝图的编辑模式，可能是bug吧，此时我们只需将蓝图关闭，再打开一次，UE4便可以识别出游戏模式蓝图了。</p>
<p>游戏模式蓝图中可以定义自己的游戏模式规则，比如我们可以通过修改Spectator Class选项为自定义的游戏物体，这样在游戏运行时，UE4将不再生成DefaulPawn，而是会生成我们指定的游戏物体。</p>
<p><img src="/2019/10/28/【UE4】UE4蓝图基础/%E3%80%90UE4%E3%80%91UE4%E8%93%9D%E5%9B%BE%E5%9F%BA%E7%A1%80%5CSnipaste_2019-10-24_11-09-34.png" alt></p>
<p>配置好游戏模式后我们还需要让当前项目使用我们自定义的游戏模式，通过Seettings -&gt;Project Settings-&gt;Project/Maps&amp;Modes-&gt;Dfault GameModes，选择我们自己的配置的游戏模式即可让当前项目启用我们自己定义的游戏模式了</p>
<p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-24_11-12-38.png" alt></p>
<h2 id="4-操控角色控制器"><a href="#4-操控角色控制器" class="headerlink" title="4.操控角色控制器"></a>4.操控角色控制器</h2><p>我们要操控角色控制器就需要配置键盘按键映射，配置好的键盘映射会以函数的形式加入蓝图脚本组件集中。</p>
<p>我们在Seettings -&gt;Project Settings-&gt;Engine/Input-&gt;Bindings/Axis Mappings设置键盘映射并可以配置映射的值，</p>
<p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-24_14-55-47.png" alt></p>
<p>配置好键盘映射以后便可以在蓝图脚本中使用这些函数主键来控制我们Player了，控制角色运动的方法很多，我这里以旋转力矩的方式来控制小球运动，具体的控制方法如下：</p>
<p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-24_15-11-12.png" alt></p>
<p>加入两个键盘映射函数组件(InputAxis MoveF/B,InputAxis MoveL/R)、两个添加角度力矩的组件(Add Torque in Radians,Add Torque in Radians)，但是添加角度力矩组件是需要一个控制目标的，我们需要从左侧的My Blueprint面板的Components中将需要控制的物体Player拖入脚本蓝图中，分别连接到添加角度力矩组件的Target上。</p>
<p>这里还需要注意的一点是，在我们为Player添加相机时，相机使用的是相对于Player的局部坐标，使用局部坐标的相机会跟随Player旋转，而使用世界坐标的相机将会固定某一个角度跟随Player移动。切换方法为：下拉Spring Arm的细节面板/Transform/Rotation的三角箭头选择切换。</p>
<p>并且相机默认情况下是启用了物理碰撞的，但大多数情况下我们是不需要让相机出现物理碰撞的，所以我们也应当取消相机的物理碰撞。操作方法为：取消Spring Arm的细节面板/Camera Collision/Do Collision Test选项。</p>
<p>当然要想比较真实的模拟出物理效果，光这样是不行的，因为默认情况下Player是没有启动物理模拟的，我们需要启用Player的细节面板/Physics/Simulate Physics选项，并且将调节Player的细节面板/Linear Damping(线性摩檫)和Player的细节面板/Angular Damping(旋转摩檫)到适当的值，应为UE4默认是没有旋转摩檫的并且，默认线性摩檫为0.01。</p>
<h2 id="小知识"><a href="#小知识" class="headerlink" title=" 小知识"></a><font color="Green"> 小知识</font></h2><ul>
<li><font color="green"> 大多数时候我们都需要勾选作用力函数组件的Acel Change选项，如：上面的Add Torque in Radians，勾选了Acel Change选项作用力组件会在作用目标物体时忽略物体的质量因素，因为存在质量影响的话，我们可能需要给一个极大的力才能推动目标物体；</font></li>
<li><font color="green"> 有时可能默认大小的作用力对目标物体的移动作用达不到我们理想的效果，此时可以先将作用力加倍后在传递给作用力组件，蓝图脚本组件集中提供多种多样的乘积组件，我们上面使用的是float*float组件</font>；</li>
</ul>
<h1 id="十五、触发器"><a href="#十五、触发器" class="headerlink" title="十五、触发器"></a>十五、触发器</h1><p>在游戏设计中触发器的使用是非常平凡的，而在蓝图中触发器的实现也并不复杂，我们来看一下具体操作：</p>
<h2 id="1-创建触发器"><a href="#1-创建触发器" class="headerlink" title="1.创建触发器"></a>1.创建触发器</h2><ul>
<li>蓝图模式中游戏的一切都是蓝图，触发器也不例外，所以要做一个触发器，首先我们的创建一个蓝图的壳子，并继承自Actor类</li>
<li>触发器还需要一个极为重要的东西就是碰撞体，当然这里的碰撞体不是具有物理碰撞的网格碰撞体，而是蓝图的物理组件集中的Box Collison，一个没有物理碰撞效果专门用于触发器的盒碰撞体，我们给蓝图类添加这个组件，一个触发器便完成了</li>
</ul>
<h2 id="2-使用触发器"><a href="#2-使用触发器" class="headerlink" title="2.使用触发器"></a>2.使用触发器</h2><p>当触发器放置于场景中，有物体进入触发器碰撞盒时，触发器便会出自动发触发Event ActorBeginOverlap时间组件，之后我们便可以进行一系列逻辑操作了。</p>
<h1 id="十六、蓝图类的通信"><a href="#十六、蓝图类的通信" class="headerlink" title="十六、蓝图类的通信"></a>十六、蓝图类的通信</h1><h2 id="1-使用引用进行通信"><a href="#1-使用引用进行通信" class="headerlink" title="1.使用引用进行通信"></a>1.使用引用进行通信</h2><p>两个蓝图类要想通过引用进行通信，那么其中一个蓝图类就必须拥有另一个蓝图类的引用，如何获取一个蓝图类的引用呢？</p>
<p>在My Blueprint/Variables栏中添加一个所需要引用的蓝图类类型的变量，勾选它的Details/Variable/Instance Editable选项，就可以在这个蓝图类的实例的Details/Default栏中看到引用变量(如果不勾选是没有default栏的)，如此便可以方便的获取另一个蓝图类的实例的引用了。</p>
<p>通过引用两个蓝图类之间便可以进行单向的信息传递了。即拥有引用的蓝图类可以获取所引用蓝图的传递过来的信息，反向则不行。</p>
<h2 id="2-使用接口进行通信"><a href="#2-使用接口进行通信" class="headerlink" title="2.使用接口进行通信"></a>2.使用接口进行通信</h2><p>使用接口进行通信的好处是可以很便利的通过同一事件让各种不同的蓝图做出不同的反应，如：当受到子弹攻击时，墙会反弹子弹，人会受伤，通过接口通信来实现这个效果就是，创建一个受到子弹攻击的接口OnTakeAttack，然后分别让墙和人都继承这个接口并实现不同的效果，如此当受到子弹攻击时，我们便可以通过Get All Actor with Interface来调用实现这些接口的Actor来做出各自的反应。</p>
<p>接口的实现与使用请阅读目录：九、接口。</p>
<h2 id="3-使用事件调度器通信"><a href="#3-使用事件调度器通信" class="headerlink" title="3.使用事件调度器通信"></a>3.使用事件调度器通信</h2><p>事件调度器的通信过程是一个调度者与一个或多个被调度者之间的通信过程，类似观察者模式的通信过程。</p>
<h3 id="创建事件调度器"><a href="#创建事件调度器" class="headerlink" title="创建事件调度器"></a>创建事件调度器</h3><p>使用事件调度器来进行蓝图通信，首先我们需要拥有一个事件调度器；</p>
<p>事件调度器只能被拥有者调用，所以我们需要在调度者蓝图上创建事件调度器，在My Blueprint/Event Dispatchers栏可以新建一个蓝图调度器，此时这个蓝图便拥有了一个事件调度器，我们可以通过拖拽事件调度器到脚本编辑视图或直接在All Actions for this Blueprint中搜索，可以对事件调度器进行事件绑定(Bind)、事件解绑(Unbind)、解绑全部事件(Unbind all)，直接为事件调度器绑定新事件(Assign)和调用事件调度器(Call)。当一个事件调度器被调用后，与这个事件调度器绑定的事件都会被调用，一次来达到信息传递的目的。</p>
<h3 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h3><p>调度者要事件调度器调用被调度者的事件，那么被调度者就需要向调度者的事件调度器上绑定事件，通过Bind Event to [事件调度器名]组件来绑定事件到事件调度器上。</p>
<p><img src="/2019/10/28/【UE4】UE4蓝图基础/Snipaste_2019-10-28_15-51-30.png" alt></p>
<p>Target：输入事件调度器的拥有者对象</p>
<p>Event：需要绑定的事件</p>
<p>如此一个基于事件调度器的通信机制便完成了。</p>

                            <hr>
                        </div>
                        <br>
                        <div>
                            
                                <p>
                                    <i class="iconfont icon-inbox"></i>
                                    
                                        <a class="hover-with-bg" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">学习笔记</a>
                                        &nbsp;
                                    
                                </p>
                            
                            <p>
                                <i class="iconfont icon-tag"></i>
                                
                                    <a class="hover-with-bg" href="/tags/UE4">UE4</a>
                                
                            </p>
                            
                                <p class="note note-warning">学！永不止步</p>
                            
                        </div>
                    </div>
                </div>
            </div>
        <div class="d-none d-lg-block col-lg-2 toc-container">
            
  <div id="toc">
    <p class="h4"><i class="far fa-list-alt"></i> Toc:</p> 
    <div id="tocbot"></div>
  </div>

        </div>
    </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
    <div class="container comments mx-auto" id="comments">
        
            <br><br>
            
            
    <script src="https://utteranc.es/client.js"
            repo="Goulandis/Comments"
            issue-term="pathname"
            
            label="utterances"
            
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>

	    
        
    </div>
</div>

    
</main>


    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
  aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="None" data-success="success" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>


<footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/0x2e/Material-T" target="_blank" rel="nofollow noopener"> <b>Material-T</b></a>
    <br>
    
  </div>
</footer>

  <!-- SCRIPTS -->
  <script src="/lib/mdbootstrap/js/jquery-3.4.1.min.js"></script>
  <script src="/lib/mdbootstrap/js/popper.min.js"></script>
  <script src="/lib/mdbootstrap/js/bootstrap.min.js?v=4.3.1"></script>
  <script src="/lib/mdbootstrap/js/mdb.min.js?v=4.8.7"></script>
  <script src="/lib/nprogress/nprogress.min.js?v=0.2.0"></script>
  <script src="/js/main.js"></script>
  
    
      <script src="/lib/tocbot/tocbot.min.js?v=4.7.0"></script>
    
    <script src="/js/post.js"></script>
  
  
    <script src="/lib/prettify/prettify.min.js?v=0.1.0"></script>
    <script>
      $(document).ready(function(){
        $('pre').addClass('prettyprint linenums');
        prettyPrint();
      })
    </script>
  
  
    <script src="/lib/typed/typed.min.js?v=2.0.9"></script>
    <script>
        var typed = new Typed('#subtitle', {
          strings: [
            '  ',
            "【UE4】UE4蓝图基础&nbsp;",
        ],
        cursorChar: "_",
        typeSpeed: 70,
        startDelay: 300, //开始之前延迟300毫秒
        loop: false,
        });
        $(".typed-cursor").addClass("h2");
    </script>
  
  
    <script src="/lib/anchor/anchor.min.js?v=4.2.0"></script>
    <script>
      anchors.options = {
        placement: "right",
        visible: "false",
        
      };
      var el = "h1,h2,h3,h4,h5,h6".split(",")
      var res = []
      for (item of el) {
        res.push(".markdown-body > " + item)
      }
      anchors.add(res.join(", "))
    </script>
  

  
    <script src="/js/local-search.js"></script>
    <script>
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function(){ getSearchFile(path); this.onclick = null }
    </script>
  
</body>
</html>