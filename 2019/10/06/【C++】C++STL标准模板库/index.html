<!DOCTYPE html>
<html lang="zh-CN">





<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <script>
    (function(){
        if('{{ page.password }}'){
            if (prompt('Goulandis') !== '{{ page.password }}'){
                alert('密码错误');
                history.back();
            }
        }
    })();
</script>
    <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
    <link rel="icon" type="image/png" href="/img/favicon.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="description" content>
    <meta name="author" content="John Doe">
    <meta name="keywords" content>
    <title>【C++】C++STL标准模板库 ~ Goulandis</title>
    <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css?v=5.7.2">
    <link rel="stylesheet" href="/lib/mdbootstrap/css/bootstrap.min.css?v=4.3.1">
    <link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css?v=4.8.7">
    <link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css">
    <link rel="stylesheet" href="/lib/nprogress/nprogress.css?v=0.2.0">
    <link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">
    
        <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css">
    
    <link rel="stylesheet" href="/css/main.css">

    
</head>


<body>
<header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
<div class="container">
    <a class="navbar-brand" href="/">&nbsp;<strong>Goulandis</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ml-auto text-center">
            
            <li class="nav-item">
                <a class="nav-link" href="/">主页</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/archives/">归档</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/categories/">分类</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/tags/">标签</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/about/">关于</a>
            </li>
            
            
                <li class="nav-item" id="search-btn">
                    <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
                </li>
            
        </ul>
    </div>
</div>


</nav>
    <div class="view intro-2"
         style="background: url('/img/2.png')no-repeat center center;background-size: cover;">
        <div class="full-bg-img">
            <div class="mask rgba-black-light flex-center">
                <div class="container text-center white-text wow fadeInUp">
                    <span class="h2" id="subtitle">
                        
                    </span>
                    
                        <br>
                        <p>Sunday, October 6th 2019, 10:20 am</p>
                    
                </div>
            </div>
        </div>
    </div>
</header>

<main>
    
        

<div class="container-fluid">
    <div class="row">
        <div class="d-none d-lg-block col-lg-2"></div>
            <div class="col-lg-8 nopadding-md">
                <div class="py-5 z-depth-3 board">
                    <div class="post-content mx-auto">
                        <div class="markdown-body">
                            <h1 id="一、STL的基本概念"><a href="#一、STL的基本概念" class="headerlink" title="一、STL的基本概念"></a>一、STL的基本概念</h1><h2 id="1-什么是STL"><a href="#1-什么是STL" class="headerlink" title="1.什么是STL"></a>1.什么是STL</h2><p> STL (Standard Template Librany）标准准模板庠是惠普实验室开发的一系列软件的统称。现在主要出现在C++中，但在被引入C++之前该技木就已存在了很长一段吋间了。</p>
<p>STL的从广义上讲分为三类: algorithm (算法)、container (容器)和iterator (迭代器)，容器和算法通过迭代器可以进行无缝链接。几乎所有的代码都釆用了模板类和模板函数的方式,这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。在C++标准中，STL 被组织为下面的13个尖文件:<code>&lt;algorithm&gt;</code>、<code>&lt;deque&gt;</code>、<code>&lt;functional&gt;</code>、<code>&lt;iterator&gt;</code>、<code>&lt;vector&gt;</code>、<code>&lt;list&gt;</code>、 <code>&lt;map&gt;</code>、<code>&lt;memory&gt;</code>、<code>&lt;numerio&gt;</code>、<code>&lt;queue&gt;</code>、<code>&lt;set&gt;</code>、    <code>&lt;stack&gt;</code> 和<code>&lt;utility&gt;</code>。</p>
<p><img src="/2019/10/06/【C++】C++STL标准模板库/Snipaste_2019-10-06_10-41-56.png" alt></p>
<p>我们详细的说六大组件：</p>
<ul>
<li>容器(Container)</li>
<li>算法(Algorithm)</li>
<li>迭代器(Iterator)</li>
<li>仿函数(Function object)</li>
<li>适配器(Adaptor)</li>
<li>空间配置器(allocator)</li>
</ul>
<h2 id="2-STL的好处"><a href="#2-STL的好处" class="headerlink" title="2.STL的好处"></a>2.STL的好处</h2><ul>
<li><p>STL是C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。</p>
</li>
<li><p>STL的一个重要特点是数据结构和算法的分离。尽管这是个简单的概念，但是这种分离确实使得STL变得非常通用。<br>例如，在STL 的vector容器中，可以放入元素、 基础数据类型变量、元素的地址;<br>STL的sort()函数可以用来操作vector,list等容器。</p>
</li>
<li><p>程序员可以不用思考STL具体的实现过程，只要能够熟综使用STL就OK了。这样他们就可以把精力放在程序开发的别的方面。</p>
</li>
<li><p>STL 具有高可重用性，高性能，高移植性，跨平台的优点。</p>
<p>  高可重用性: STL 中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。关于模板的知识，已经给大家介绍了。</p>
<p>高性能:如map可以高效地从十万条记录里面查找出指定的记录，因为map是采用红黑树的变体实现的。</p>
<p>高移植性:如在项目A上用STL编写的模块，可以直接移植到项目B上。</p>
<p>跨平台:如用windows的Visual Studio编写的代码可以在Mac OS的XCode上直接运行。</p>
</li>
<li><p>了解到STL的这些好处，我们知道STL无疑是最值得C++程序员骄傲的一部分。每一个C++程序员都应该好好学习STL.只有能够熟练使用STL的程序员，才是好的C++程序员。</p>
</li>
</ul>
<h1 id="二、容器"><a href="#二、容器" class="headerlink" title="二、容器"></a>二、容器</h1><h2 id="1-容器"><a href="#1-容器" class="headerlink" title="1.容器"></a>1.容器</h2><p>  在实际的开发过程中，数据结构本身的重要性不会逊于操作于数据结构的算法的重要性，当程序中存在着对时间要求很高的部分时，数据结构的选择就显得更加重要。</p>
<p>  经典的数据结构数量有限，但是我们常常重复着一些为了实现向量、链表等结构而编写的代码，这些代码都十分相似，只是为了适应不同数据的变化而在细节上有所出入。STL容器就为我们提供了这样的方便，它允许我们重复利用己有的实现构造自己的特定类型下的数据结构，通过设置-些模板，STL 容器对最常用的数据结构提供了支持，这些模板的参数允许我们指定容器中元素的数据类型，可以将我们许多重复而乏味的工作简化。</p>
<p>​    容器部分主要由头文件<code>&lt;vector&gt;</code>, <code>&lt;list&gt;</code>, <code>&lt;deque&gt;</code>, <code>&lt;set&gt;</code>, <code>&lt;map&gt;</code>, <code>&lt;stack&gt;</code>和<code>&lt;queue&gt;</code>组成。对于常用的一些容器和容器适配器(可以看作由其它容器实现的容器)，可以通过下表总结一:下它们和相应头文件的对应关系。</p>
<p><img src="/2019/10/06/【C++】C++STL标准模板库/Snipaste_2019-10-06_10-41-56.png" alt></p>
<h2 id="2-容器的分类"><a href="#2-容器的分类" class="headerlink" title="2.容器的分类"></a>2.容器的分类</h2><h3 id="序列式容器-Sequence-containers"><a href="#序列式容器-Sequence-containers" class="headerlink" title="序列式容器(Sequence containers)"></a>序列式容器(Sequence containers)</h3><p>每个元素都有固定位置–取决于插入时机和地点，和元素值无关。如：vector、deque、 Iist。</p>
<h3 id="关联式容器-Associated-containers"><a href="#关联式容器-Associated-containers" class="headerlink" title="关联式容器(Associated containers)"></a>关联式容器(Associated containers)</h3><p>元素位置取决于特定的排序准则，和插入顺序无关。如：sset、multiset、 map、multimapu。</p>
<p><img src="/2019/10/06/【C++】C++STL标准模板库/Snipaste_2019-10-06_14-36-13.png" alt></p>
<h2 id="3-string类"><a href="#3-string类" class="headerlink" title="3.string类"></a>3.string类</h2><h3 id="string类的本质"><a href="#string类的本质" class="headerlink" title="string类的本质"></a>string类的本质</h3><p><code>string</code>类本质上其实就是<code>char*</code>的容器，是<code>cahr*</code>的封装。</p>
<h3 id="string类的遍历"><a href="#string类的遍历" class="headerlink" title="string类的遍历"></a>string类的遍历</h3><p><strong>使用[]遍历：</strong></p>
<pre><code class="C++">string str = &quot;string_str&quot;;
for (int i = 0; i &lt; str.length(); i++)
    cout &lt;&lt; str[i];</code></pre>
<p><strong>使用迭代器遍历：</strong></p>
<pre><code class="C++">string str = &quot;string_str&quot;;
for(string::iteratori=str.begin();i&lt;str.end();i++)
    cout &lt;&lt;*i;</code></pre>
<p><font color="red"> 注意这里的<code>i</code>是一个指向string::iterator类型的指针。</font></p>
<p><strong>使用at()遍历：</strong></p>
<pre><code class="C++">string str = &quot;string_str&quot;;
for (int i = 0; i &lt; str.length(); i++)
    cout &lt;&lt; str.at(i);</code></pre>
<p><code>at()</code>与<code>[]</code>不同的是，当访问发生越界等错误时，<code>at()</code>会自动抛出异常，而<code>[]</code>不会抛出异常而中断程序。</p>
<h3 id="string解封成char"><a href="#string解封成char" class="headerlink" title="string解封成char*"></a>string解封成char*</h3><p>C++为string类提供了一个专门的函数<font color="red"> <strong>str.c_str()</strong></font>，str是string类型的对象，但是需要注意的是<code>str.c_str()</code>返回的是一个<font color="red"> <strong>const char*</strong></font>，不能再被赋值给其他的变量，但是我们可以直接将<code>str.c_str()</code>当作<code>char*</code>来使用，如：<code>str.c_str()[1]</code>，即通过<code>char*</code>指针访问str中的第二个元素。</p>
<h3 id="string类中一些常用函数"><a href="#string类中一些常用函数" class="headerlink" title="string类中一些常用函数"></a>string类中一些常用函数</h3><table>
<thead>
<tr>
<th></th>
<th>函数名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>复制</td>
<td>str.copy(char *buf,int cout)</td>
<td>从字符串str中拷贝cout个字符到char数组buf中</td>
</tr>
<tr>
<td>连接</td>
<td>str.append(string strs)</td>
<td>将字符串strs连接到str之后，支持string和char*</td>
</tr>
<tr>
<td>查找</td>
<td>int str.find(char *strs,int index)</td>
<td>从字符串str中的第index索引开始查找strs子串或字符，返回查找到的第一个匹配值的索引，返回的索引也可以使用迭代器来接收</td>
</tr>
<tr>
<td>替换</td>
<td>str.replace(int index,int length,char *strs)</td>
<td>在字符串str中，从index索引开始用strs字符串替换length个长度的子串</td>
</tr>
<tr>
<td>删除</td>
<td>str.erase(int index,int length)</td>
<td>删除字符出str从index位置开始的length长度的字符</td>
</tr>
<tr>
<td>插入</td>
<td>str.insert(int index,char *strs)</td>
<td>从str字符串的index位置开始插入字串strs</td>
</tr>
</tbody></table>
<h3 id="string类中常用算法函数"><a href="#string类中常用算法函数" class="headerlink" title="string类中常用算法函数"></a>string类中常用算法函数</h3><pre><code class="C++">string str = &quot;string_str_io_stdsfx.h_iostream&quot;;
transform(str.begin(), str.end(), str.begin(), toupper);
cout &lt;&lt; str &lt;&lt; endl;</code></pre>
<p>transform算法包含在<code>#include &lt;algorithm&gt;</code>头文件中</p>
<p><strong>transform算法的使用：</strong></p>
<p><strong>原型：</strong>transform(first,last,result,op);</p>
<p>first是容器的首迭代器，last为容器的末迭代器，result为存放结果的容器，op为要进行操作的一元函数对象或sturct、class。</p>
<p><strong>代码解释：</strong>str.begin()返回一个指向str首部位置的迭代器，str.end()返回一个指向str尾部位置的迭代器，因为我们把输出结果继续存放在str中，且迭代器始于容器相联系的，所以存放结果的容器也是str.begin()，而我们对str做的操作是将小写字母装换为大写，C++提供了标准的转换函数,所以操作函数为toupper。</p>
<p><strong>transform算法的另一个重载形式：</strong></p>
<p><strong>原型：</strong>transform(first1,last1,first2,result,binary_op);</p>
<p>first1是第一个容器的首迭代 器，last1为第一个容器的末迭代器，first2为第二个容器的首迭代器，result为存放结果的容器，binary_op为要进行操作的二元函数 对象或sturct、class。</p>
<p>需要注意的是，两个容器first1和first2中的元素数量必须相等，否则会抛异常。</p>
<h2 id="4-vector容器"><a href="#4-vector容器" class="headerlink" title="4.vector容器"></a>4.vector容器</h2><ul>
<li>vector是将元素置于一个<font color="red"> <strong>动态数组</strong></font>中加以管理的容器</li>
<li>vector支持随机存取元素，支持索引存取（[],at()）和迭代器存取</li>
<li>vector在尾部添加和移除元素速度快，在中部和头部速度慢</li>
<li>使用vector容易需要包含<code>#include&lt;vector&gt;</code>头文件</li>
</ul>
<h3 id="vector常用方法"><a href="#vector常用方法" class="headerlink" title="vector常用方法"></a>vector常用方法</h3><table>
  <tr>
    <th> </th>
    <th>函数</th>
    <th>作用</th>
  </tr>
  <tr>
    <td rowspan="4">读取与赋值</td>
    <td>front(void)</td>
    <td>获取容器首元素，既可以作左值也可以作右值</td>
  </tr>
  <tr>
    <td>back(void)</td>
    <td>获取容器尾元素，既可以作左值也可以作右值</td>
  </tr>
  <tr>
    <td>push_back(T t)</td>
    <td>在容器的尾部添加元素</td>
  </tr>
  <tr>
    <td>pop_back(T t)</td>
    <td>删除容器最后一个元素</td> 
  </tr>
  <tr>
    <td rowspan="4">只读</td>
    <td>begin(void)</td>
    <td>获取容器首部迭代器</td> 
  </tr>
  <tr>
    <td>end(void)</td>
    <td>获取容器尾部迭代器</td> 
  </tr>
  <tr>
    <td>rbegin(void)</td>
    <td>获取逆序首部迭代器，实际指向容器的尾部，只能使用vector&#60int&#62::reverse_iterator逆序迭代器接收</td> 
  </tr>
  <tr>
    <td>rend(void)</td>
    <td>获取逆序尾部部迭代器，实际指向容器的首部，只能使用vector&#60int&#62::reverse_iterator逆序迭代器接收</td> 
  </tr>
  <tr>
    <td rowspan="2">删除</td>
    <td>erase(iterator pos)</td>
    <td>删除迭代器pos指向位置的元素</td> 
  </tr>
  <tr>
    <td>erase(iterator begin,iterator end)</td>
    <td>从迭代器begin指向位置开始到end指向位置结束，区间删除元素</td> 
  </tr>
  <tr>
    <td>插入</td>
    <td>insert(iterator pos,T t)</td>
    <td>在pos迭代器指向的位置插入元素t，insert中的迭代器pos只能是begin()或end()否则会报错，似乎不止其他的迭代器</td> 
  </tr>
    <td>判空</td>
    <td>empty(void)</td>
    <td>容器判空</td> 
  
</table>

<h2 id="5-deque容器"><a href="#5-deque容器" class="headerlink" title="5.deque容器"></a>5.deque容器</h2><ul>
<li>deque容器是一个双端数组，在双端数组的两端均可以插入和删除元素</li>
<li>使用deque容器需要包头文件<code>#include&lt;deque&gt;</code></li>
</ul>
<p>deque容器可以说是vector容器的升级版，deque的用法基本和vector一致，但是deque不仅提供push_back()，pop_back()还提供<font color="red"> <strong>push_front()</strong></font> 和<font color="red"> <strong>pop_front()</strong></font>。</p>
<h2 id="6-stack容器"><a href="#6-stack容器" class="headerlink" title="6.stack容器"></a>6.stack容器</h2><ul>
<li>stack容器是一个栈模型</li>
<li>使用stack容器需要包含头文件<code>#include&lt;stack&gt;</code></li>
</ul>
<h3 id="stack常用方法"><a href="#stack常用方法" class="headerlink" title="stack常用方法"></a>stack常用方法</h3><table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>push(T t)</td>
<td>元素入栈顶</td>
</tr>
<tr>
<td>pop()</td>
<td>栈顶元素出栈</td>
</tr>
<tr>
<td>top()</td>
<td>获取栈顶元素</td>
</tr>
</tbody></table>
<h2 id="7-queue容器"><a href="#7-queue容器" class="headerlink" title="7.queue容器"></a>7.queue容器</h2><ul>
<li>queue容器是一个队列模型</li>
<li>使用queue容器需要包含头文件<code>#include&lt;queue&gt;</code></li>
</ul>
<h3 id="queue常用方法"><a href="#queue常用方法" class="headerlink" title="queue常用方法"></a>queue常用方法</h3><table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>push(T t)</td>
<td>元素入队尾</td>
</tr>
<tr>
<td>pop()</td>
<td>队首元素出队</td>
</tr>
<tr>
<td>front()</td>
<td>获取队首元素，既可以作左值也可以作右值</td>
</tr>
<tr>
<td>back()</td>
<td>获取队尾元素，既可以作左值也可以作右值</td>
</tr>
</tbody></table>
<h2 id="8-list容器"><a href="#8-list容器" class="headerlink" title="8.list容器"></a>8.list容器</h2><ul>
<li>list容器是一个双向链表模型，可以高效的进行元素的插入和删除操作</li>
<li>list容器不支持随机访问，即不支持[],at()和iterator + n(如：begin()+1)等形式的访问</li>
<li>使用list容器需要包含头文件<code>#include&lt;list&gt;</code></li>
</ul>
<p>list容器除了不支持随机访问外，用法和deque容器的用法基本一致，除此之外list容器还提供一个<font color="red"> <strong>remove(T t)</strong></font>函数来根据元素内容删除元素</p>
<p>使用list容器时有一点需要注意<font color="red"> <strong>list容器在使用erase删除元素时，遵循左闭右开的原则</strong></font>，如：</p>
<pre><code class="C++">list&lt;int&gt; li;
for (int i = 0; i &lt; 5; i++)
    li.push_back(i);
for (list&lt;int&gt;::iterator it = li.begin(); it != li.end(); it++)
    cout &lt;&lt; *it;
cout &lt;&lt; endl;
list&lt;int&gt;::iterator it1 = li.begin();//it1指向元素0
list&lt;int&gt;::iterator it2 = li.begin();
it2++; it2++; it2++;//此时it2指向元素3
li.erase(it1, it2);
for (list&lt;int&gt;::iterator it = li.begin(); it != li.end(); it++)
    cout &lt;&lt; *it;
cout &lt;&lt; endl;</code></pre>
<p><strong>输出结果：</strong></p>
<pre><code>01234
34</code></pre><p>可以看到erase在删除0-3的元素时删除了0，1，2而没有删除3，即左闭右开。</p>
<h2 id="9-priority-queue容器"><a href="#9-priority-queue容器" class="headerlink" title="9.priority_queue容器"></a>9.priority_queue容器</h2><ul>
<li><p><code>priority_queue</code>容器是一个具有优先级的队列，又叫优先级队列适配器，分为最大优先级队列和最小优先级队列两种</p>
</li>
<li><p>priority_queue容器是一种特殊的queue容器，所以也需要包含头文件<code>#include&lt;queue&gt;</code></p>
</li>
</ul>
<p>默认的定义<code>priority_queue&lt;T&gt; pr</code>的优先级队列是最大优先级队列，显示定义最大优先级队列：<code>priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt; pr</code>，<code>less</code>是一个谓词后面再学习，显示定义最小优先级队列：<code>priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; pr</code>，其中使用<code>greater</code>需要包含头文件<code>#include&lt;functional&gt;</code>。</p>
<p><code>priority_queue</code>容器的用法基本和<code>queue</code>一致，除此之外，<code>priority_queue</code>容器提供一个<code>top()</code>函数来获取队首元素，而<code>queue</code>容器没有这个方法。</p>
<p><strong>示例：</strong></p>
<pre><code class="C++">priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; pr;
pr.push(12);
pr.push(4);
pr.push(10);
pr.push(20);
cout &lt;&lt; &quot;最小元素：&quot; &lt;&lt;pr.top() &lt;&lt; endl;
while (pr.size() &gt; 0)
{
    cout &lt;&lt; pr.top() &lt;&lt; &quot;,&quot;;
    pr.pop();
}</code></pre>
<p><strong>输出结果：</strong></p>
<pre><code>最小元素：4
4,10,12,20,</code></pre><h2 id="10-set容器"><a href="#10-set容器" class="headerlink" title="10.set容器"></a>10.set容器</h2><ul>
<li><code>set</code>是一个<font color="red"><strong>集合</strong></font>容器，其中所包含的元素是<font color="red"><strong>唯一</strong></font>的，<font color="red"><strong>集合中的元素按一定的顺序排序</strong></font>，元素的插入过程是按排序规则插入，所以不能指定位置插入</li>
<li><code>set</code>采用红黑树变体的数据结构实现，红黑树属于平衡二叉树，在插入和删除操作上比<code>vector</code>容器速度更快</li>
<li><code>set</code>容器不支持[]和at()来存取元素</li>
<li><font color="red"><strong>set不支持直接修改容器中的元素</strong></font>，因为元素是自动排序的，如果希望修改一个元素值，就必须删除这个元素再插入新元素</li>
<li>要使用<code>set</code>容器需要包含头文件<code>#include&lt;set&gt;</code></li>
</ul>
<h3 id="set容器的基本特性"><a href="#set容器的基本特性" class="headerlink" title="set容器的基本特性"></a>set容器的基本特性</h3><p>默认情况下，直接定义的set容器采用最小优先排序，和priority_queue容器恰好相反，<code>set&lt;T&gt; se</code>就是隐式的<code>set&lt;T,less&lt;T&gt;&gt; se</code>，定义最大优先排序的set容器需要显示定义：<code>set&lt;T,greater&lt;T&gt;&gt; se</code>。</p>
<p>我们来看一个例子：</p>
<pre><code class="C++">set&lt;string,greater&lt;string&gt;&gt; se;//采用最大优先排序
for (int i = 0; i &lt; 5; i++)//生成随机字符串元素
{
    int tmp = rand();
    string str = &quot;&quot;;
    while (str.length()&lt;=3)
    {
        if(tmp &gt;= 97 &amp;&amp; tmp &lt;= 122)
            str += tmp;
        tmp = rand();
    }
    se.insert(str);
}
se.insert(&quot;strs&quot;);//插入相同的字符串元素
se.insert(&quot;strs&quot;);
se.insert(&quot;strs&quot;);
for (set&lt;string, greater&lt;string&gt;&gt;::iterator it = se.begin(); it != se.end(); it++)
    cout &lt;&lt; *it &lt;&lt; endl;</code></pre>
<p><strong>输出结果：</strong></p>
<pre><code>wqye
vfep
strs
omsk
kfnm
cdsb</code></pre><p>可以看到，容器里的字符串确实按照字符串的比较规则按从大到小的顺序排列着，并且无论我们插入多少个相同的元素，在容器内只会存储一个相同的元素值。</p>
<p>值得注意的是：</p>
<p><code>set</code>容器只提供了<code>insert(T t)</code>函数来插入元素。</p>
<h3 id="自定义元素的排序"><a href="#自定义元素的排序" class="headerlink" title="自定义元素的排序"></a>自定义元素的排序</h3><p>自定义类作元素可能会出现类中有多个字段，而我们需要其中的某一个字段来作为关键字在<code>set</code>容器中排序，要实现这样的行为，我们就需要用到<font color="red"><strong>仿函数</strong></font>了。</p>
<h4 id="什么是仿函数？"><a href="#什么是仿函数？" class="headerlink" title="什么是仿函数？"></a>什么是仿函数？</h4><p>仿函数实质上就是一个做了<code>()</code>重载的结构体，因为重载了<code>()</code>使用起来类似函数，所以称之为仿函数。</p>
<p>我们来看一个例子：</p>
<pre><code class="C++">class Student
{
public:
    string name;
    int age;
    bool isStudent;
    Student(const string name, const int age, const bool isStudent)
    {
        this-&gt;age = age;
        this-&gt;name = name;
        this-&gt;isStudent = isStudent;
    }
};
struct AgeSort//仿函数
{
    bool operator()(const Student &amp;lift, const Student &amp;right)
    {
        return (lift.age &lt; right.age);
    }
};
int main()
{
    set&lt;Student, AgeSort&gt; se;
    Student s1(&quot;Alian&quot;, 23, true);
    Student s2(&quot;Blank&quot;, 20, true);
    Student s3(&quot;Cary&quot;, 43, false);
    Student s4(&quot;Davel&quot;, 23, true);
    se.insert(s1); se.insert(s2);
    se.insert(s3); se.insert(s4);
    for (set&lt;Student, AgeSort&gt;::iterator it = se.begin(); it != se.end(); it++)
        cout &lt;&lt; it-&gt;name &lt;&lt; &quot;\t&quot; &lt;&lt; it-&gt;age &lt;&lt; &quot;\t&quot; &lt;&lt; it-&gt;isStudent &lt;&lt; endl;
    system(&quot;pause&quot;);
    return 0;
}</code></pre>
<p><strong>输出结果：</strong></p>
<pre><code>Blank   20      1
Alian   23      1
Cary    43      0</code></pre><p>其中<code>AgeSort</code>就是仿函数，它的比较关键字是<code>Student.age</code>，所以<code>set</code>容器对象se会以age作为排序关键字，其实我们之前使用的<code>less&lt;&gt;</code>和<code>greater&lt;&gt;</code>也是反函数，只不过是C++预定义好的仿函数。</p>
<p>细心的朋友可能会发现，我们插入的s4对象居然不再容器里！！！这是因为set容器中的元素具有唯一性，而set容器是通过关键字来识别元素的，所当碰到关键字相同的元素时，set只会存储一个元素。</p>
<p>那么这种情况该怎么解决呢？答案是set容器没有办法解决这种情况，如果有出现这种情况，就不能使用set容器而改用multiset容器。</p>
<p>在后面的算法模块我们详细介绍仿函数。</p>
<h3 id="set常用函数"><a href="#set常用函数" class="headerlink" title="set常用函数"></a>set常用函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>find(T t)</td>
<td>查找元素t，返回指向t元素的迭代器，查找失败返回指向set.end()的迭代器</td>
</tr>
<tr>
<td>count(T t)</td>
<td>返回容器中元素t的个数，值要么是0，要么是1</td>
</tr>
<tr>
<td>lower_bound(T t)</td>
<td>返回一个指向&gt;=t元素的迭代器，如果t存在则指向t，如果t不存在则指向t后面的一个元素</td>
</tr>
<tr>
<td>upper_bound(T t)</td>
<td>返回一个指向&gt;t元素的迭代器，即t元素后面的一个元素</td>
</tr>
<tr>
<td>equal_range(T t)</td>
<td>返回一个包含两个set类型的迭代器的对组pair&lt;set<t>::iterator,set<t>::iterator&gt;第一个迭代器指向t元素，第二个迭代器指向t后面的一个元素，如果t不存在，则两个迭代器都指向t后面的一个元素</t></t></td>
</tr>
</tbody></table>
<h3 id="小知识"><a href="#小知识" class="headerlink" title=" 小知识"></a><font color="blue"> 小知识</font></h3><p><font color="blue"> 事实上容器中的<code>insert</code>函数是有返回值的，<code>insert</code>的返回值是一个对组(pair)类型的泛型<code>pair&lt;set&lt;T&gt;::iterator, bool&gt;</code>的对象，<code>pair</code>是一个只有两个字段的模板，我们可以直接定义<code>pair&lt;set&lt;T&gt;::iterator, bool&gt;</code>类型对象来接收<code>insert</code>函数的返回值，如：</font></p>
<pre><code class="C++">pair&lt;set&lt;Student,AgeSort&gt;::iterator, bool&gt; pait=se.insert(s1);</code></pre>
<p><font color="blue"> 我们可以通过<code>pair.first</code>和<code>pair.second</code>来访问对组中的两个元素，通过<code>pair.first</code>来访问对组中的第一个元素<code>set&lt;Student,AgeSort&gt;::iterator</code>类型的迭代器，通过<code>pair.first-&gt;first</code>，和<code>pair.first-&gt;second</code>可以访问迭代器所指向的容器元素，我们通过<code>pair.second</code>来访问对组中的第二个元素，bool型的元素记录的是insert函数插入是否成功，如果插入成功则记录true，否则记录false。</font></p>
<h2 id="11-multiset容器"><a href="#11-multiset容器" class="headerlink" title="11.multiset容器"></a>11.multiset容器</h2><ul>
<li><code>multiset</code>容器可以说是set容器的升级版，multiset容器支持多个相同键值的元素的存储，所以要使用<code>multiset</code>需要包含头文件<code>#include&lt;set&gt;</code></li>
</ul>
<p>multiset的用法和set一致。</p>
<h2 id="12-map容器"><a href="#12-map容器" class="headerlink" title="12.map容器"></a>12.map容器</h2><ul>
<li><code>map</code>是标准的关联式容器，一个<code>map</code>元素是一个键值对(key,value),<code>map</code>提供基于键值的快速检索能力</li>
<li><code>map</code>中<font color="red"><code>key</code>值是唯一的</font></li>
<li><code>map</code>容器中的元素也是按一定顺序排列的，元素插入过程是按排序规则插入的，所以不能指定位置插入</li>
<li><code>map</code>容器的具体实现也是采用红黑二叉树变体的平衡二叉树的数据结构，在插入和删除的操作上比<code>vector</code>更快</li>
<li>与<code>set</code>不同的是<code>map</code>支持直接存取<code>key</code>值对应的<code>value</code>，也支持[]操作符</li>
<li>要使用<code>map</code>容器就需要包含头文件<code>#include&lt;map&gt;</code></li>
</ul>
<h3 id="map的元素插入"><a href="#map的元素插入" class="headerlink" title="map的元素插入"></a>map的元素插入</h3><pre><code class="C++">int main()
{
    map&lt;int, string&gt; ma;
    //方法一
    ma.insert(pair&lt;int, string&gt;(1, &quot;pair&quot;));
    ma.insert(pair&lt;int, string&gt;(1, &quot;pair_02&quot;));
    //方法二
    ma.insert(make_pair(2, &quot;make_pair&quot;));
    ma.insert(make_pair(2, &quot;make_pair_02&quot;));
    //方法三
    ma.insert(map&lt;int, string&gt;::value_type(3, &quot;value_type&quot;));
    ma.insert(map&lt;int, string&gt;::value_type(3, &quot;value_type_02&quot;));
    //方法四
    ma[4] = &quot;map&quot;;
    ma[4] = &quot;map_02&quot;;
    for (map&lt;int, string&gt;::iterator it = ma.begin(); it != ma.end(); it++)
        cout &lt;&lt; it-&gt;first &lt;&lt; &quot;\t&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;
    system(&quot;pause&quot;);
    return 0;
}</code></pre>
<p><strong>输出结果：</strong></p>
<pre><code>1       pair
2       make_pair
3       value_type
4       map_02</code></pre><p>上面四种方法都可以向map容器里添加元素，但是四者中也有一些微小的区别，前面三种方法在插入相同键值时，只会保存第一存储的结果，之后插入相同键值的元素时都会插入失败，而第四种方法则是后面赋值的元素覆盖前面赋值的元素。</p>
<p>map似乎没办法来指定是从大到小排序或是从小到大排序</p>
<p>map除了元素的形式不同，在其他方面map的用法基本和set一致</p>
<h2 id="13-multimap容器"><a href="#13-multimap容器" class="headerlink" title="13.multimap容器"></a>13.multimap容器</h2><p><code>multimap</code>容器和<code>multiset</code>容器一样，是<code>map</code>容器的升级版，支持一个键对应多个值，所以<code>multimap</code>的一个重要应用场景就是数据分组。</p>
<h2 id="14-容器在使用过程必须要注意的地方"><a href="#14-容器在使用过程必须要注意的地方" class="headerlink" title="14.容器在使用过程必须要注意的地方"></a>14.容器在使用过程必须要注意的地方</h2><p><font color="red"> 因为在将元素添加到容器里时，C++执行的是容器的默认的拷贝构造函数，将元素拷贝到容器里，这个过程是一个浅拷贝，既然是浅拷贝就会面临浅拷贝的两次内存释放的问题，尤其是类元素，所以在添加一些具有指针字段的元素到容器里时，一定在类里定义一个深拷贝的拷贝构造函数和=的重载函数。</font></p>
<h2 id="15-各个容器的比较"><a href="#15-各个容器的比较" class="headerlink" title="15.各个容器的比较"></a>15.各个容器的比较</h2><table>
<thead>
<tr>
<th></th>
<th>vector</th>
<th>deque</th>
<th>list</th>
<th>set</th>
<th>multiset</th>
<th>map</th>
<th>multimap</th>
</tr>
</thead>
<tbody><tr>
<td>内存结构</td>
<td>单端数组</td>
<td>双端数组</td>
<td>双向链表</td>
<td>二叉树</td>
<td>二叉树</td>
<td>二叉树</td>
<td>二叉树</td>
</tr>
<tr>
<td>随机存取</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>对key而言是</td>
<td>否</td>
</tr>
<tr>
<td>元素检索</td>
<td>慢</td>
<td>慢</td>
<td>非常慢</td>
<td>快</td>
<td>快</td>
<td>对key而言快</td>
<td>对key而言快</td>
</tr>
<tr>
<td>快速安插移除</td>
<td>尾端</td>
<td>头尾两端</td>
<td>任何位置</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<h1 id="三、算法"><a href="#三、算法" class="headerlink" title="三、算法"></a>三、算法</h1><h2 id="1-算法"><a href="#1-算法" class="headerlink" title="1.算法"></a>1.算法</h2><p>​    函数库对数据类型的选择对其可重用性起着至关重要的作用。举例来说，一个求方根的函数，在使用浮点数作为其参数类型的情况下的可重用性肯定比使用整型作为它的参数类性要高。而C++通过模板的机制允许推迟对某些类型的选择，直到真正想使用模板或者说对模板进行特化的时候，STL就利用了这一点提供了相当多的有用算法。它是在一个有效的框架中完成这些算法的–可以将所有的类型划分为少数的几类，然后就可以在模版的参数中使用一种类型替换掉同一种类中的其他类型。</p>
<p>  STL提供了大约100个实现算法的模版函数，比如算法for_ each 将为指定序列中的每一个元素调用指定的函数，stable_ _sort 以你所指定的规则对序列进行稳定性排序等等，这样一-来,只要熟悉了STL之后，许多代码可以被大大的化简，只需要通过调用一-两个算法模板，就可以完成所需要的功能并大大地提升效率。</p>
<p>  算法部分主要由头文件<code>&lt;algorithm&gt;</code>, <code>&lt;numeric&gt;</code>和<code>&lt;functional&gt;</code>组成。<code>&lt;algorithm&gt;</code>是所 有STL头文件中最大的一个(尽管它很好理解)，它是由一大堆模版函数组成的，可以认为每个函数在很大程度上都是独立的，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等等。<code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。<code>&lt;functional&gt;</code>中则定义了一些模板类，用以声明函数对象。</p>
<h2 id="2-算法的分类"><a href="#2-算法的分类" class="headerlink" title="2.算法的分类"></a>2.算法的分类</h2><h3 id="非可变序列算法"><a href="#非可变序列算法" class="headerlink" title="非可变序列算法"></a>非可变序列算法</h3><p>计数算法：count,count_if等 </p>
<p>搜索算法：search,find,find_if,find_list_of等</p>
<p>比较算法：equal,mismatch,lexicographical_compare等</p>
<h3 id="可变排序算法"><a href="#可变排序算法" class="headerlink" title="可变排序算法"></a>可变排序算法</h3><p>删除算法：remove,remove_if,remove_copy等</p>
<p>修改算法：for_each,transform等</p>
<p>排序算法：sort,stable_sort,partial_sort等</p>
<h2 id="3-仿函数"><a href="#3-仿函数" class="headerlink" title="3.仿函数"></a>3.仿函数</h2><h2 id="4-一些常用的算法模板"><a href="#4-一些常用的算法模板" class="headerlink" title="4.一些常用的算法模板"></a>4.一些常用的算法模板</h2><h3 id="find算法"><a href="#find算法" class="headerlink" title="find算法"></a>find算法</h3><p><strong>原型:</strong><code>iterator find(iterator begin,iterator end,T t)</code></p>
<p>在容器的begin迭代器所指向的位置开始到end所指向的位置结束，查找元素t，如果找到了，则返回指向t的迭代器。</p>
<h1 id="四、迭代器"><a href="#四、迭代器" class="headerlink" title="四、迭代器"></a>四、迭代器</h1><h2 id="1-迭代器"><a href="#1-迭代器" class="headerlink" title="1.迭代器"></a>1.迭代器</h2><p>​    迭代器从作用上来说是最基本的部分，可是理解起来比前两者都要费力一些。软件设计有一个基本原则，所有的问题都可以通过引进一个间接层来简化，这种简化在 STL中就是用迭代器来完成的。概括来说，迭代器在STL中用来将算法和容器联系起来，起着一种黏和剂的作用。几乎STL提供的所有算法都是通过送代器存取元素序列进行工作的，每一个容器都定义了其本身所专有的选代器，用以存取容器中的元素。</p>
<p>​    迭代器部分主要由头文件<code>&lt;utility&gt;</code>,<code>&lt;iterator&gt;</code>和<code>&lt;memory&gt;</code>组成。<code>&lt;utility&gt;</code>是-一个很小的头文件，它包括了贯穿使用在STL中的几个模板的声明，<code>&lt;iterator&gt;</code>中提供 了迭代器使用的许多方法，而对于<code>&lt;memory&gt;</code>的描述则十分的困难，它以不同寻常的方式为容器中的元素分配存储空间，同时也为某些算法执行期间产生的临时对象提供机制,<code>&lt;memory&gt;</code>中的主要部分是模板类<code>alocator</code>,它负责产生所有容器中的默认分配器。</p>
<h2 id="2-迭代器的基本原理"><a href="#2-迭代器的基本原理" class="headerlink" title="2.迭代器的基本原理"></a>2.迭代器的基本原理</h2><ul>
<li><p>迭代器是一个“可遍历STL容器内全部或部分元素”的对象</p>
</li>
<li><p>迭代器指出容器中的一个特定位置</p>
</li>
<li><p>迭代器就如同一个指针</p>
</li>
<li><p>迭代器提供对一个容器中的对象的访问方法，并且可以定义了容器中对象的范围</p>
</li>
</ul>
<h2 id="3-迭代器的分类"><a href="#3-迭代器的分类" class="headerlink" title="3.迭代器的分类"></a>3.迭代器的分类</h2><p><strong>输入迭代器</strong>:也有叫法称之为“只读迭代器”，它从容器中读取元素，只能一次读入一个元素向前移动，只支持一遍算法，同一个输入迭代器不能两遍遍历一个序列。</p>
<p><strong>输出迭代器</strong>:也有叫法称之为“只写迭代器”，它往容器中写入元素，只能一次写入一个元素向前移动，只支持一遍算法，同一个输出迭代器不能两遍遍历一个序列。</p>
<p><strong>正向迭代器</strong>:组合输入送代器和输出迭代器的功能,还可以多次解析一个迭代器指定的位置，可以对一个值进行多次读/写。</p>
<p><strong>双向达代器</strong>:组合正向迭代器的功能，还可以通过-操作符向后移动位置。</p>
<p><strong>随机访问送代器</strong>:组合双向送代器的功能，还可以向前向后跳过任意个位置，可以直接访问容器中任何位置的元素。</p>
<p># </p>

                            <hr>
                        </div>
                        <br>
                        <div>
                            
                                <p>
                                    <i class="iconfont icon-inbox"></i>
                                    
                                        <a class="hover-with-bg" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">学习笔记</a>
                                        &nbsp;
                                    
                                </p>
                            
                            <p>
                                <i class="iconfont icon-tag"></i>
                                
                                    <a class="hover-with-bg" href="/tags/C++">C++</a>
                                
                            </p>
                            
                                <p class="note note-warning">学！永不止步</p>
                            
                        </div>
                    </div>
                </div>
            </div>
        <div class="d-none d-lg-block col-lg-2 toc-container">
            
  <div id="toc">
    <p class="h4"><i class="far fa-list-alt"></i> Toc:</p> 
    <div id="tocbot"></div>
  </div>

        </div>
    </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
    <div class="container comments mx-auto" id="comments">
        
            <br><br>
            
            
    <script src="https://utteranc.es/client.js"
            repo="Goulandis/Comments"
            issue-term="pathname"
            
            label="utterances"
            
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>

	    
        
    </div>
</div>

    
</main>


    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
  aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="None" data-success="success" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>


<footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/0x2e/Material-T" target="_blank" rel="nofollow noopener"> <b>Material-T</b></a>
    <br>
    
  </div>
</footer>

  <!-- SCRIPTS -->
  <script src="/lib/mdbootstrap/js/jquery-3.4.1.min.js"></script>
  <script src="/lib/mdbootstrap/js/popper.min.js"></script>
  <script src="/lib/mdbootstrap/js/bootstrap.min.js?v=4.3.1"></script>
  <script src="/lib/mdbootstrap/js/mdb.min.js?v=4.8.7"></script>
  <script src="/lib/nprogress/nprogress.min.js?v=0.2.0"></script>
  <script src="/js/main.js"></script>
  
    
      <script src="/lib/tocbot/tocbot.min.js?v=4.7.0"></script>
    
    <script src="/js/post.js"></script>
  
  
    <script src="/lib/prettify/prettify.min.js?v=0.1.0"></script>
    <script>
      $(document).ready(function(){
        $('pre').addClass('prettyprint linenums');
        prettyPrint();
      })
    </script>
  
  
    <script src="/lib/typed/typed.min.js?v=2.0.9"></script>
    <script>
        var typed = new Typed('#subtitle', {
          strings: [
            '  ',
            "【C++】C++STL标准模板库&nbsp;",
        ],
        cursorChar: "_",
        typeSpeed: 70,
        startDelay: 300, //开始之前延迟300毫秒
        loop: false,
        });
        $(".typed-cursor").addClass("h2");
    </script>
  
  
    <script src="/lib/anchor/anchor.min.js?v=4.2.0"></script>
    <script>
      anchors.options = {
        placement: "right",
        visible: "false",
        
      };
      var el = "h1,h2,h3,h4,h5,h6".split(",")
      var res = []
      for (item of el) {
        res.push(".markdown-body > " + item)
      }
      anchors.add(res.join(", "))
    </script>
  

  
    <script src="/js/local-search.js"></script>
    <script>
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function(){ getSearchFile(path); this.onclick = null }
    </script>
  
</body>
</html>